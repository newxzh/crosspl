[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ message consumer capable of receiving messages from a specified queue, processing different message types (TextMessage and BytesMessage), and handling connection exceptions.\n\nClass Description: The ActiveMqConsumer class implements Runnable and ExceptionListener interfaces to asynchronously consume messages from an ActiveMQ broker while handling connection exceptions. It manages the JMS connection lifecycle and provides methods to start/stop the consumer.\n\nAttributes:\n- connection: Connection - JMS connection to the ActiveMQ broker\n- session: Session - JMS session for message processing\n- consumer: MessageConsumer - JMS message consumer for receiving messages\n- remoteUri: String - URI of the ActiveMQ broker\n- queueName: String - Name of the queue to consume messages from\n\nMethods:\n- ActiveMqConsumer(String remoteUri, String queueName) -> None - Constructor that initializes the broker URI and queue name\n- start() -> void - Creates connection factory, establishes connection, creates session and consumer\n- stop() -> void - Closes consumer, session and connection resources\n- run() -> void - Continuously receives and processes messages (TextMessage/BytesMessage)\n- onException(JMSException e) -> void - Exception handler that stops the consumer on connection errors\n- getConnection() -> Connection - Returns the JMS connection\n- getSession() -> Session - Returns the JMS session\n- getConsumer() -> MessageConsumer - Returns the message consumer",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Connection;\nimport javax.jms.Destination;\nimport javax.jms.ExceptionListener;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport com.sitewhere.spi.SiteWhereException;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() throws SiteWhereException {\n        try {\n            ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(remoteUri);\n            this.connection = connectionFactory.createConnection();\n            this.connection.setExceptionListener(this);\n            this.connection.start();\n            this.session = this.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination destination = this.session.createQueue(queueName);\n            this.consumer = this.session.createConsumer(destination);\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error starting ActiveMQ consumer.\", e);\n        }\n    }\n\n    public void stop() throws SiteWhereException {\n        try {\n            this.consumer.close();\n            this.session.close();\n            this.connection.close();\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error shutting down ActiveMQ consumer.\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Message message = consumer.receive();\n                if (message == null) {\n                    break;\n                }\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    byte[] payload = textMessage.getText().getBytes();\n                    // Process payload here\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] buffer = new byte[(int) bytesMessage.getBodyLength()];\n                    // Process buffer here\n                }\n            } catch (Throwable e) {\n                return;\n            }\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        try {\n            stop();\n        } catch (SiteWhereException e1) {\n        }\n    }\n\n    protected Connection getConnection() {\n        return connection;\n    }\n\n    protected Session getSession() {\n        return session;\n    }\n\n    protected MessageConsumer getConsumer() {\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "wrong_result": "public class ActiveMqConsumer implements Runnable, ExceptionListener {\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() throws JMSException {\n        ConnectionFactory factory = new ActiveMQConnectionFactory(remoteUri);\n        connection = factory.createConnection();\n        connection.setExceptionListener(this);\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        Destination destination = session.createQueue(queueName);\n        consumer = session.createConsumer(destination);\n        connection.start();\n    }\n\n    public void stop() throws JMSException {\n        if (consumer != null) {\n            consumer.close();\n        }\n        if (session != null) {\n            session.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                Message message = consumer.receive();\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    System.out.println(\"Received Text Message: \" + textMessage.getText());\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] bytes = new byte[(int) bytesMessage.getSize()];\n                    bytesMessage.readBytes(bytes);\n                    System.out.println(\"Received Bytes Message: \" + new String(bytes));\n                }\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        System.err.println(\"JMS Exception occurred: \" + e.getMessage());\n        // Stop the consumer on connection error\n        try {\n            stop();\n        } catch (JMSException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    public Session getSession() {\n        return session;\n    }\n\n    public MessageConsumer getConsumer() {\n        return consumer;\n    }\n}"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter;\n    private String boundary;\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n    private HttpClient me;\n\n    private static final HttpClient instance = new HttpClient();\n\n    private HttpClient() {\n        this.url = \"http://example.com\";\n        this.delimiter = \"--\";\n        this.boundary = \"boundary\";\n        this.handler = new HttpConnectionRetryHandler();\n    }\n\n    public static HttpClient getInstance() {\n        return instance;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            handler.handleRetry(e);\n            connect(method, props);\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyHost != null && proxyPort != null) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) new URL(url).openConnection(proxy);\n        } else {\n            con = (HttpURLConnection) new URL(url).openConnection();\n        }\n        con.setRequestMethod(method);\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", \"Java HTTP Client\");\n        con.setRequestProperty(\"Accept\", \"*/*\");\n        con.setConnectTimeout(5000);\n        con.setReadTimeout(5000);\n        os = con.getOutputStream();\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        con.setRequestMethod(\"GET\");\n        con.setInstanceFollowRedirects(true);\n        con.connect();\n        InputStream is = con.getInputStream();\n        byte[] data = readStream(is);\n        is.close();\n        return data;\n    }\n\n    public void connectForMultipart() throws Exception {\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.setRequestProperty(\"User-Agent\", \"Java HTTP Client\");\n        con.setRequestProperty(\"Accept\", \"*/*\");\n        con.setConnectTimeout(5000);\n        con.setReadTimeout(5000);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        writeParamData(paramName, fileName);\n        os.write((delimiter + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + \"\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        con.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return response.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\\r\\n\".getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    private byte[] readStream(InputStream is) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, bytesRead);\n        }\n        return baos.toByteArray();\n    }\n\n    private class HttpConnectionRetryHandler {\n        public void handleRetry(IOException e) {\n            System.err.println(\"Retrying connection due to error: \" + e.getMessage());\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a Java class that demonstrates how to make an HTTP request using HttpURLConnection, including setting connection timeouts and request headers, and handling the response.\n\nClass Description: The CleartextHttpCredentialsTest class is designed to test basic HTTP connectivity with a target URL. It demonstrates how to establish a connection, set timeouts, add request headers, and retrieve response information. The class focuses on proper resource cleanup after the connection is used.\n\nAttributes:\n- TARGET: [String] - A constant storing the URL to which the HTTP request will be made\n\nMethods:\n- runTest: [runTest]() -> [void] - Executes the HTTP request to the target URL. Sets connection timeouts, adds an Authorization header, retrieves the response code and message, and ensures proper connection cleanup. Throws Exception if any step fails.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CleartextHttpCredentialsTest {\n\n  private static final String TARGET = \"http://www.google.com\";\n\n  public void runTest() throws Exception {\n    HttpURLConnection connection = null;\n    try {\n      connection = (HttpURLConnection) new URL(TARGET).openConnection();\n      connection.setConnectTimeout(20000);\n      connection.setReadTimeout(20000);\n      connection.setRequestProperty(\"Authorization\", \"value\");\n      int responseCode = connection.getResponseCode();\n      String responseMessage = connection.getResponseMessage();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class CleartextHttpCredentialsTest {\n    private static final String TARGET = \"http://example.com\";\n\n    public void runTest() throws Exception {\n        java.net.URL url = new java.net.URL(TARGET);\n        java.net.HttpURLConnection connection = (java.net.HttpURLConnection) url.openConnection();\n\n        // Set connection and read timeouts\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n\n        // Add request headers\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Authorization\", \"Basic dXNlcm5hbWU6cGFzc3dvcmQ=\");\n\n        // Check response code\n        int responseCode = connection.getResponseCode();\n        String responseMessage = connection.getResponseMessage();\n\n        System.out.println(\"Response Code: \" + responseCode);\n        System.out.println(\"Response Message: \" + responseMessage);\n\n        // Ensure connection is closed\n        connection.disconnect();\n    }\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "package com.example.weatherclient;\n\nimport android.os.AsyncTask;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.json.JSONObject;\n\npublic class HttpWeatherClient extends AsyncTask<String, String, String> {\n\n    @Override\n    protected String doInBackground(String... params) {\n        String url = params[0];\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                String response = convertStreamToString(inputStream);\n                publishProgress(response);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    @Override\n    protected void onProgressUpdate(String... progress) {\n        try {\n            JSONObject jsonObject = new JSONObject(progress[0]);\n            JSONObject astronomy = jsonObject.getJSONObject(\"astronomy\");\n            String sunrise = astronomy.getString(\"sunrise\");\n            String sunset = astronomy.getString(\"sunset\");\n            // Process sunrise and sunset times as needed\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String convertStreamToString(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = inputStream.read(buffer)) > 0) {\n                stringBuilder.append(new String(buffer, 0, length));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that performs an HTTP/HTTPS request with XML data and parses the XML response into a key-value map.\n\nFunction Description: This function sends an HTTP/HTTPS request (GET/POST) to a specified URL with XML data as input, then parses the XML response into a Map<String, Object> where keys are XML element names and values are their text content. The function handles connection setup, request configuration, data transmission, response parsing, and resource cleanup.\n\nInput:\n- requestUrl: String - The target URL for the HTTP request\n- requestMethod: String - The HTTP method to use (e.g., \"GET\" or \"POST\")\n- xmlStr: String - The XML data to send with the request (can be null for GET requests)\n\nOutput:\n- Map<String, Object> - A map containing key-value pairs parsed from the XML response, where keys are XML element names and values are their text content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.HashMap;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic static Map<String, Object> httpXmlRequest(String requestUrl, String requestMethod, String xmlStr) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    try {\n        HttpsURLConnection urlCon = (HttpsURLConnection) (new URL(requestUrl)).openConnection();\n        urlCon.setDoInput(true);\n        urlCon.setDoOutput(true);\n        urlCon.setRequestMethod(requestMethod);\n\n        if (\"GET\".equalsIgnoreCase(requestMethod)) {\n            urlCon.connect();\n        }\n\n        urlCon.setRequestProperty(\"Content-Length\", String.valueOf(xmlStr.getBytes().length));\n        urlCon.setUseCaches(false);\n        if (null != xmlStr) {\n            OutputStream outputStream = urlCon.getOutputStream();\n            outputStream.write(xmlStr.getBytes(\"UTF-8\"));\n            outputStream.flush();\n            outputStream.close();\n        }\n        InputStream inputStream = urlCon.getInputStream();\n        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        SAXReader reader = new SAXReader();\n        Document document = reader.read(inputStreamReader);\n        Element root = document.getRootElement();\n        List<Element> elementList = root.elements();\n        for (Element e : elementList) {\n            map.put(e.getName(), e.getText());\n        }\n        inputStreamReader.close();\n        inputStream.close();\n        inputStream = null;\n        urlCon.disconnect();\n    } catch (MalformedURLException e) {\n        LOG.error(e.getMessage());\n    } catch (IOException e) {\n        LOG.error(e.getMessage());\n    } catch (Exception e) {\n        LOG.error(e.getMessage());\n    }\n    return map;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.HashMap;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\npublic class XmlRequestHandler {\n    public Map<String, Object> sendXmlRequest(String requestUrl, String requestMethod, String xmlStr) {\n        Map<String, Object> responseMap = new HashMap<>();\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(requestMethod);\n            connection.setDoOutput(true);\n\n            if (xmlStr != null) {\n                connection.getOutputStream().write(xmlStr.getBytes());\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                InputStream inputStream = connection.getInputStream();\n                Document document = parseXml(inputStream);\n                extractData(document, responseMap);\n            } else {\n                System.out.println(\"HTTP error code: \" + responseCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return responseMap;\n    }\n\n    private Document parseXml(InputStream inputStream) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        return builder.parse(inputStream);\n    }\n\n    private void extractData(Document document, Map<String, Object> responseMap) {\n        NodeList nodeList = document.getElementsByTagName(\"*\");\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            Node node = nodeList.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element element = (Element) node;\n                String tagName = element.getTagName();\n                String textContent = element.getTextContent();\n                responseMap.put(tagName, textContent);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection for making HTTP requests and handling responses.\n\nClass Description: The Http class provides a static method for sending HTTP requests to a specified URL with configurable request methods and payloads. It handles connection setup, request sending, response reading, and resource cleanup.\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String requestMethod, String outputStr) -> String - Sends an HTTP request to the specified URL using the given method and optional request body, then returns the response as a string.\n  - requestUrl: String - The target URL for the HTTP request\n  - requestMethod: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n  - outputStr: String - The request body to send (can be null for requests without body)\n  - Returns: String - The response body from the server, or null if an error occurs\n\nThe method handles:\n1. Creating and configuring HttpURLConnection\n2. Setting request headers (content-type: text/xml; charset=UTF-8)\n3. Sending request body if provided\n4. Reading and concatenating response\n5. Proper resource cleanup\n6. Error handling and logging",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.scudata.common.Logger;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {    \n        try {    \n            URL url = new URL(requestUrl);    \n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();    \n              \n            conn.setDoOutput(true);    \n            conn.setDoInput(true);    \n            conn.setUseCaches(false);    \n            conn.setRequestMethod(requestMethod);    \n            conn.setRequestProperty(\"content-type\", \"text/xml; charset=UTF-8\");\n            \n            if (null != outputStr) {    \n                OutputStream outputStream = conn.getOutputStream();    \n                outputStream.write(outputStr.getBytes(\"UTF-8\"));    \n                outputStream.close();    \n            }    \n            \n            InputStream inputStream = conn.getInputStream();    \n            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"utf-8\");    \n            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);    \n            String str = null;  \n            StringBuffer buffer = new StringBuffer();    \n            while ((str = bufferedReader.readLine()) != null) {    \n                buffer.append(str);    \n            }    \n            \n            bufferedReader.close();    \n            inputStreamReader.close();    \n            inputStream.close();    \n            inputStream = null;    \n            conn.disconnect();    \n            return buffer.toString();    \n        } catch (Exception e) {    \n            System.out.println(\"http exception{}\"+ e);\n            Logger.error(e.getMessage());\n        }    \n        return null;    \n    }    \n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(requestMethod);\n            connection.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n\n            if (outputStr != null) {\n                OutputStream os = connection.getOutputStream();\n                os.write(outputStr.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            StringBuilder result = new StringBuilder();\n            try {\n                java.net.URL urlObj = new java.net.URL(url);\n                java.net.HttpURLConnection connection = (java.net.HttpURLConnection) urlObj.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode == 200) {\n                    java.io.InputStream inputStream = connection.getInputStream();\n                    result.append(ConvertInputToStringNoChange(inputStream));\n                } else {\n                    return \"Error: HTTP response code \" + responseCode;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                return \"Error: \" + e.getMessage();\n            }\n            return result.toString();\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            try {\n                org.json.JSONArray jsonArray = new org.json.JSONArray(progress[0]);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    org.json.JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    // Process individual JSON objects here\n                    System.out.println(\"JSON Object \" + i + \": \" + jsonObject.toString());\n                }\n            } catch (org.json.JSONException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result2) {\n            super.onPostExecute(result2);\n            // Handle post-execution tasks here\n            System.out.println(\"Task completed. Result: \" + result2);\n        }\n    }\n\n    public String getNews(String... params) {\n        return new MyAsyncTask().execute(params).get();\n    }\n\n    private String ConvertInputToStringNoChange(java.io.InputStream inputStream) throws java.io.IOException {\n        java.util.Scanner scanner = new java.util.Scanner(inputStream, \"UTF-8\");\n        scanner.useDelimiter(\"\\\\A\");\n        String result = scanner.hasNext() ? scanner.next() : \"\";\n        scanner.close();\n        return result;\n    }\n}"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.nio.file.Path;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpDownloader {\n    private final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        int redirectCount = 0;\n        String currentUrl = targetUrlString;\n\n        while (true) {\n            Optional<String> nextUrl = getDownloadedOrNextUrl(currentUrl, path, userAgent);\n            if (nextUrl.isEmpty()) {\n                break;\n            }\n            if (redirectCount >= MAXIMUM_REDIRECTS) {\n                throw new IOException(\"Maximum number of redirects (\" + MAXIMUM_REDIRECTS + \") exceeded.\");\n            }\n            currentUrl = nextUrl.get();\n            redirectCount++;\n        }\n    }\n\n    private Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        // Simulated HTTP request and response handling\n        // In a real implementation, this would use HttpClient or similar to perform the request\n        logger.info(\"Downloading from URL: {}\", urlString);\n\n        // Simulate successful download\n        if (urlString.contains(\"success\")) {\n            logger.info(\"Downloaded successfully to: {}\", path);\n            return Optional.empty();\n        }\n\n        // Simulate redirect\n        if (urlString.contains(\"redirect\")) {\n            logger.info(\"Redirecting to: {}\", urlString.replace(\"redirect\", \"success\"));\n            return Optional.of(urlString.replace(\"redirect\", \"success\"));\n        }\n\n        // Simulate error\n        throw new IOException(\"Failed to download from URL: \" + urlString);\n    }\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport com.fasterxml.jackson.databind.JsonNode;\n\npublic class WebUtils {\n    public static String getBody(String reqURL) throws Exception {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        return connectionToString(con);\n    }\n\n    public static JsonNode getJson(String reqURL) throws Exception {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        return new ObjectMapper().readTree(connectionToString(con));\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) throws Exception {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        try (InputStream in = con.getInputStream(); FileOutputStream out = new FileOutputStream(fileLocation)) {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws Exception {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postContent.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        return connectionToString(con);\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws Exception {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        String formData = \"\";\n        for (Map.Entry<String, String> entry : fields.entrySet()) {\n            if (!formData.isEmpty()) formData += \"&\";\n            formData += escape(entry.getKey()) + \"=\" + escape(entry.getValue());\n        }\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = formData.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws Exception {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        return con.getInputStream().lines();\n    }\n\n    public static String getUserAgent() {\n        return \"WebUtils/1.0 (Java)\";\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n        }\n        return sb.toString();\n    }\n\n    private static String escape(String s) {\n        return s.replace(\"+\", \"%2B\").replace(\" \", \"%20\");\n    }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RealRequest {\n    public static String sRequestURL;\n    private HttpConfig httpConfig;\n    private static final String TAG = \"SA.HttpRequest\";\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            setHeader(conn, headerMap);\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n            setHeader(conn, headerMap);\n            conn.setRequestProperty(\"Content-Type\", bodyType);\n            conn.setDoOutput(true);\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = body.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws Exception {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        if (httpConfig != null) {\n            conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n            conn.setReadTimeout(httpConfig.getReadTimeout());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        String responseMessage = conn.getResponseMessage();\n        String responseString = \"\";\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    responseString += line;\n                }\n            }\n        } else {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                String line;\n                while ((line = in.readLine()) != null) {\n                    responseString += line;\n                }\n            }\n        }\n        return new RealResponse(responseCode, responseMessage, responseString);\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(-1, \"Error\", e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n    private boolean allowCrossProtocolRedirects;\n    private int connectTimeoutMillis;\n    private int readTimeoutMillis;\n    private RequestProperties requestProperties;\n    private DataSpec dataSpec;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private boolean opened;\n\n    public long open(DataSpec dataSpecParameter) {\n        this.dataSpec = dataSpecParameter;\n        this.opened = false;\n        try {\n            this.connection = makeConnection(dataSpec);\n            this.inputStream = connection.getInputStream();\n            this.opened = true;\n            return connection.getContentLengthLong();\n        } catch (Exception e) {\n            close();\n            throw new IOException(\"Failed to open HTTP data source\", e);\n        }\n    }\n\n    private HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws IOException {\n        URL url = dataSpecToUse.url;\n        HttpURLConnection connection = openConnection(url);\n        if (requestProperties != null) {\n            connection.setRequestProperties(requestProperties);\n        }\n        connection.setConnectTimeout(connectTimeoutMillis);\n        connection.setReadTimeout(readTimeoutMillis);\n        connection.setInstanceFollowRedirects(allowCrossProtocolRedirects);\n        return connection;\n    }\n\n    private HttpURLConnection openConnection(URL url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        return connection;\n    }\n\n    private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws IOException {\n        URL newUrl = new URL(location);\n        if (dataSpecToHandleRedirect != null) {\n            dataSpecToHandleRedirect.url = newUrl;\n        }\n        return newUrl;\n    }\n\n    public void close() {\n        if (opened) {\n            maybeTerminateInputStream(connection, dataSpec.length);\n            closeConnectionQuietly();\n            opened = false;\n        }\n    }\n\n    private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\n        if (connection != null && bytesRemaining < 0 && android.os.Build.VERSION.SDK_INT >= 28) {\n            connection.disconnect();\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception e) {\n                // Ignore exceptions when closing the connection\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Java class that implements a RESTful client using HttpURLConnection to perform HTTP requests (GET, POST, PUT) and handle responses.\n\nClass Description: The `RestfulClient` class provides methods to execute HTTP requests (GET, POST, PUT) to a specified URL and process the responses. It handles connection setup, request parameter configuration, input/output stream management, and connection cleanup.\n\nAttributes: None\n\nMethods:\n\nMethod1: `get(String path) -> String` - Executes a GET request to the specified URL path and returns the response as a String.  \nMethod2: `post(String path, String requestBody) -> String` - Executes a POST request to the specified URL path with the provided request body and returns the response as a String.  \nMethod3: `put(String path, String requestBody) -> String` - Executes a PUT request to the specified URL path with the provided request body and returns the response as a String.  \nMethod4: `executeRequest(String method, String path, String requestBody) -> String` - Internal helper method that handles the common logic for executing HTTP requests (connection setup, request configuration, and response processing).  \nMethod5: `getVal(RestfulRequest request) -> String` - Executes a custom HTTP request based on the provided `RestfulRequest` object (containing URL, method, and parameters) and returns the response as a String.  \n\nInput:  \n- For `get`, `post`, and `put`:  \n  - `path` (String): The target URL for the HTTP request.  \n  - `requestBody` (String, optional for POST/PUT): The request payload in JSON format.  \n- For `getVal`:  \n  - `request` (RestfulRequest): An object encapsulating the request details (URL, HTTP method, and parameters).  \n\nOutput:  \n- String: The response body from the HTTP request, or `null` if an error occurs.",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody){\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(path);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes();\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            if (connection.getResponseCode() == 200) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String inputLine;\n                    StringBuilder response = new StringBuilder();\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    return response.toString();\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n    public String getVal(RestfulRequest request) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(request.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(request.getMethod());\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \" application/json\");\n            byte[] content = request.getParam().getBytes();\n            connection.setRequestProperty(\"Content-Length\", content.length + \"\");\n\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.connect();\n            OutputStream out = connection.getOutputStream();\n            out.write(content);\n            out.flush();\n            out.close();\n\n            if (connection.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class RestfulClient {\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody) {\n        try {\n            URL url = new URL(path);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes(\"utf-8\");\n                    os.write(input);\n                    os.flush();\n                }\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public String getVal(RestfulRequest request) {\n        return executeRequest(request.getMethod(), request.getUrl(), request.getBody());\n    }\n}\n\nclass RestfulRequest {\n    private String url;\n    private String method;\n    private String body;\n\n    public RestfulRequest(String url, String method, String body) {\n        this.url = url;\n        this.method = method;\n        this.body = body;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public String getMethod() {\n        return method;\n    }\n\n    public String getBody() {\n        return body;\n    }\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpClientUtil {\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            TrustManager[] trustManagers = new TrustManager[]{new X509TrustManager() {\n                @Override\n                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                @Override\n                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                }\n\n                @Override\n                public X509Certificate[] getAcceptedIssuers() {\n                    return new X509Certificate[0];\n                }\n            }};\n            sslContext.init(trustManagers, null, new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new IOException(\"Failed to create SSL socket factory\", e);\n        }\n    }\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n\n        if (\"POST\".equals(method)) {\n            connection.setDoOutput(true);\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = outputStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        connection.setSSLSocketFactory(createSSLSocketFactory());\n        int responseCode = connection.getResponseCode();\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n        return new HttpResponse(response.toString(), responseCode);\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        java.net.URL url = new java.net.URL(requestUrl);\n        java.net.HttpURLConnection connection = (java.net.HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n\n        if (\"POST\".equals(method)) {\n            connection.setDoOutput(true);\n            try (java.io.OutputStream os = connection.getOutputStream()) {\n                byte[] input = outputStr.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n\n        connection.setSSLSocketFactory(createSSLSocketFactory());\n        int responseCode = connection.getResponseCode();\n        java.io.BufferedReader in = new java.io.BufferedReader(new java.io.InputStreamReader(connection.getInputStream()));\n        java.lang.StringBuilder response = new java.lang.StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n        return new HttpResponse(response.toString(), responseCode);\n    }\n\n    public static class HttpResponse {\n        private final String responseBody;\n        private final int responseCode;\n\n        public HttpResponse(String responseBody, int responseCode) {\n            this.responseBody = responseBody;\n            this.responseCode = responseCode;\n        }\n\n        public String getResponseBody() {\n            return responseBody;\n        }\n\n        public int getResponseCode() {\n            return responseCode;\n        }\n    }\n}"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a WebSocket client using Java Netty framework that can establish a connection to a WebSocket server, send and receive frames, and handle connection lifecycle events.\n\nClass Description: WebSocketTestClient is a Netty-based WebSocket client implementation that handles WebSocket connections, frame transmission, and connection management. It supports different WebSocket versions and provides callback mechanisms for frame handling.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- ch: [Channel] - Active channel representing the WebSocket connection\n- uri: [URI] - Target WebSocket server URI\n- version: [WebSocketVersion] - WebSocket protocol version to use\n- closed: [boolean] - Connection status flag\n- count: [AtomicInteger] - Counter for handler naming\n\nMethods:\n- connect(): [WebSocketTestClient] - Establishes connection to WebSocket server, performs handshake, and returns self for chaining\n- send(WebSocketFrame frame, FrameListener listener): [WebSocketTestClient] - Sends WebSocket frame and registers listener for response, returns self for chaining\n- destroy(): [void] - Gracefully closes connection and releases resources\n- destroy(boolean dirty): [void] - Closes connection with option for immediate termination\n- isActive(): [boolean] - Returns connection active status\n- isOpen(): [boolean] - Returns connection open status\n- isWritable(): [boolean] - Returns channel writable status\n\nNested Interfaces:\n- FrameListener: Callback interface for frame reception and error handling\n  - onFrame(WebSocketFrame frame): [void] - Called when frame is received\n  - onError(Throwable t): [void] - Called when error occurs\n\nNested Classes:\n- WSClientHandler: [SimpleChannelInboundHandler<Object>] - Internal handler for WebSocket handshake and frame processing\n  - handshakeFuture(): [ChannelFuture] - Returns handshake completion future\n  - handlerAdded(ChannelHandlerContext ctx): [void] - Initializes handshake promise\n  - channelActive(ChannelHandlerContext ctx): [void] - Initiates handshake\n  - channelRead0(ChannelHandlerContext ctx, Object o): [void] - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext ctx, Throwable cause): [void] - Handles channel errors",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic final class WebSocketTestClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private static final AtomicInteger count = new AtomicInteger();\n\n    public WebSocketTestClient(WebSocketVersion version, URI uri) {\n        this.uri = uri;\n        this.version = version;\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        String protocol = uri.getScheme();\n        if (!\"ws\".equals(protocol)) {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + protocol);\n        }\n        final WebSocketClientHandshaker handshaker =\n                WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n        WSClientHandler handler = new WSClientHandler(handshaker);\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception {\n                        ChannelPipeline p = channel.pipeline();\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192), handler);\n                    }\n                });\n\n        ChannelFuture future =\n                bootstrap.connect(\n                        new InetSocketAddress(uri.getHost(), uri.getPort()));\n        future.syncUninterruptibly();\n        handler.handshakeFuture.syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {\n        ch.pipeline().addLast(\"responseHandler\" + count.incrementAndGet(), new SimpleChannelInboundHandler<Object>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof CloseWebSocketFrame) {\n                    closed = true;\n                }\n                listener.onFrame((WebSocketFrame) msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                cause.printStackTrace();\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ChannelFuture cf = ch.writeAndFlush(frame).syncUninterruptibly();\n        if (!cf.isSuccess()) {\n            listener.onError(cf.cause());\n        }\n        return this;\n    }\n\n    public void destroy() {\n        this.destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed && !dirty) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            send(new CloseWebSocketFrame(), new FrameListener() {\n                @Override\n                public void onFrame(WebSocketFrame frame) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    latch.countDown();\n                }\n            });\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n        }\n        try {\n            bootstrap.group().shutdownGracefully(0, 1, TimeUnit.SECONDS).get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean isActive() {\n        return this.ch != null && this.ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return this.ch != null && this.ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return this.ch != null && this.ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static final class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WSClientHandler(WebSocketClientHandshaker handshaker) {\n            super(false);\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object o) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                ReferenceCountUtil.release(o);\n                return;\n            }\n\n            if (o instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) o;\n                ReferenceCountUtil.release(o);\n                throw new Exception(\"Unexpected HttpResponse (status=\" + response.getStatus() + \", content=\"\n                        + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.AttributeKey;\nimport io.netty.util.concurrent.DefaultThreadFactory;\nimport java.net.URI;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerHandler;\nimport io.netty.handler.codec.http.websocketx.WebSocketHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebSocketTestClient {\n    private final Bootstrap bootstrap;\n    private Channel ch;\n    private URI uri;\n    private WebSocketVersion version;\n    private boolean closed;\n    private AtomicInteger count = new AtomicInteger(0);\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    public static class WSClientHandler extends SimpleChannelInboundHandler<WebSocketFrame> {\n        private final ChannelFuture handshakeFuture;\n        private final AttributeKey<WebSocketHandshaker> handshakerKey = AttributeKey.valueOf(\"websocketHandshaker\");\n\n        public WSClientHandler(ChannelFuture handshakeFuture) {\n            this.handshakeFuture = handshakeFuture;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            ctx.pipeline().addLast(new HttpClientCodec());\n            ctx.pipeline().addLast(new HttpObjectAggregator(65536));\n            ctx.pipeline().addLast(new WebSocketClientHandler());\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            WebSocketClientHandshaker handshaker = (WebSocketClientHandshaker) ctx.attr(handshakerKey).get();\n            if (handshaker != null) {\n                handshaker.handshake(ctx.channel());\n            }\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof WebSocketFrame) {\n                WebSocketFrame frame = (WebSocketFrame) msg;\n                if (frame instanceof TextWebSocketFrame) {\n                    System.out.println(\"Received: \" + ((TextWebSocketFrame) frame).text());\n                } else {\n                    System.out.println(\"Received: \" + frame);\n                }\n            } else if (msg instanceof LastHttpContent) {\n                if (handshakeFuture.isDone()) {\n                    WebSocketHandshaker handshaker = (WebSocketHandshaker) ctx.attr(handshakerKey).get();\n                    if (handshaker != null) {\n                        handshaker.close(ctx.channel());\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (ctx.channel().isActive()) {\n                ctx.close();\n            }\n        }\n    }\n\n    public WebSocketTestClient() {\n        bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup(1, new DefaultThreadFactory(\"WebSocketTestClient-\")));\n        bootstrap.channel(io.netty.channel.socket.nio.NioSocketChannel.class);\n    }\n\n    public WebSocketTestClient connect() {\n        EventLoopGroup group = bootstrap.group();\n        try {\n            ch = bootstrap.connect(uri.getHost(), uri.getPort()).sync().channel();\n            WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                    ch.newSslContext(SslContextBuilder.forClient().build()), uri.toString(), version, false);\n            if (handshaker == null) {\n                handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                        ch.newSslContext(SslContextBuilder.forClient().build()), uri.toString(), version, false);\n            }\n            ch.pipeline().addLast(new WSClientHandler(handshaker.handshakeFuture()));\n            handshaker.handshake(ch);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, FrameListener listener) {\n        if (ch != null && ch.isActive() && ch.isWritable()) {\n            ch.writeAndFlush(frame);\n            ch.pipeline().addLast(new FrameListenerHandler(listener));\n        }\n        return this;\n    }\n\n    public void destroy() {\n        destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (ch != null && ch.isOpen()) {\n            if (dirty) {\n                ch.closeNow();\n            } else {\n                ch.close();\n            }\n            ch = null;\n        }\n    }\n\n    public boolean isActive() {\n        return ch != null && ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return ch != null && ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return ch != null && ch.isWritable();\n    }\n\n    private static class FrameListenerHandler extends SimpleChannelInboundHandler<WebSocketFrame> {\n        private final FrameListener listener;\n\n        public FrameListenerHandler(FrameListener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) {\n            listener.onFrame(frame);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            listener.onError(cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.handler.timeout.ReadTimeoutHandler;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.Map;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private ConcurrentHashMap<String, CompletableFuture<String>> results;\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        this.workerGroup = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        this.results = new ConcurrentHashMap<>();\n    }\n\n    public void init() {\n        b.group(workerGroup)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) {\n                 ch.pipeline().addLast(new HttpClientCodec());\n                 ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                 ch.pipeline().addLast(new IdleStateHandler(0, 0, 10, TimeUnit.SECONDS));\n                 ch.pipeline().addLast(new ReadTimeoutHandler(defaultTimeout));\n                 ch.pipeline().addLast(new HttpHandler());\n             }\n         });\n    }\n\n    public void close() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) {\n        String key = \"GET_\" + uri;\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(key, future);\n        send(createGetRequest(uri, future));\n        return future.join();\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) {\n        String key = \"POST_\" + uri;\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(key, future);\n        send(createPostRequest(uri, params, headers, future));\n        return future.join();\n    }\n\n    private HttpRequest createGetRequest(String uri, CompletableFuture<String> future) {\n        // Implementation to create HTTP GET request\n        return null;\n    }\n\n    private HttpRequest createPostRequest(String uri, Map<String, String> params, Map<String, String> headers, CompletableFuture<String> future) {\n        // Implementation to create HTTP POST request\n        return null;\n    }\n\n    private String send(HttpRequest request) {\n        // Implementation to send request and handle response\n        return null;\n    }\n\n    private class HttpHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse response) {\n            String key = (String) ctx.channel().attr(\"requestKey\").get();\n            CompletableFuture<String> future = results.get(key);\n            if (future != null) {\n                future.complete(response.content().toString());\n                results.remove(key);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            String key = (String) ctx.channel().attr(\"requestKey\").get();\n            CompletableFuture<String> future = results.get(key);\n            if (future != null) {\n                future.completeExceptionally(cause);\n                results.remove(key);\n            }\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a proxy server, handle SSL encryption if enabled, manage connection lifecycle, and support reconnection with exponential backoff.\n\nClass Description: ProxyClientContainer is a Netty-based TCP client container that establishes and maintains a connection to a proxy server. It handles SSL encryption when configured, manages connection retries with exponential backoff, and provides channel management for proxy communication.\n\nAttributes:\n- logger: [Logger] - SLF4J logger instance for logging events\n- workerGroup: [NioEventLoopGroup] - Netty event loop group for handling I/O operations\n- bootstrap: [Bootstrap] - Primary bootstrap for proxy server connections\n- realServerBootstrap: [Bootstrap] - Bootstrap for real server connections\n- config: [Config] - Configuration instance for client settings\n- sslContext: [SSLContext] - SSL context for secure connections (nullable)\n- sleepTimeMill: [long] - Current sleep duration for reconnection attempts\n\nMethods:\n- ProxyClientContainer() -> [void] - Constructor that initializes worker group, bootstraps, and configures channel pipelines\n- start() -> [void] - Starts the client by initiating connection to proxy server\n- createSslHandler(SSLContext sslContext) -> [ChannelHandler] - Creates SSL handler for secure connections\n- connectProxyServer() -> [void] - Connects to proxy server with retry logic on failure\n- stop() -> [void] - Shuts down the client gracefully\n- channelInactive(ChannelHandlerContext ctx) -> [void] - Handles channel inactive events by triggering reconnection\n- reconnectWait() -> [void] - Implements exponential backoff for reconnection attempts",
    "Canonical_solution": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.client.handlers.ClientChannelHandler;\nimport org.fengfei.lanproxy.client.handlers.RealServerChannelHandler;\nimport org.fengfei.lanproxy.common.Config;\nimport org.fengfei.lanproxy.protocol.IdleCheckHandler;\nimport org.fengfei.lanproxy.protocol.ProxyMessage;\nimport org.fengfei.lanproxy.protocol.ProxyMessageDecoder;\nimport org.fengfei.lanproxy.protocol.ProxyMessageEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class ProxyClientContainer {\n\n    private static Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n\n    private NioEventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n    private Bootstrap realServerBootstrap;\n    private Config config = Config.getInstance();\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer() {\n        workerGroup = new NioEventLoopGroup();\n        realServerBootstrap = new Bootstrap();\n        realServerBootstrap.group(workerGroup);\n        realServerBootstrap.channel(NioSocketChannel.class);\n        realServerBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new RealServerChannelHandler());\n            }\n        });\n\n        bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                if (Config.getInstance().getBooleanValue(\"ssl.enable\", false)) {\n                    if (sslContext == null) {\n                        sslContext = SslContextCreator.createSSLContext();\n                    }\n                    ch.pipeline().addLast(createSslHandler(sslContext));\n                }\n                ch.pipeline().addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                ch.pipeline().addLast(new ProxyMessageEncoder());\n                ch.pipeline().addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, IdleCheckHandler.WRITE_IDLE_TIME - 10, 0));\n                ch.pipeline().addLast(new ClientChannelHandler(realServerBootstrap, bootstrap, ProxyClientContainer.this));\n            }\n        });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(true);\n        return new SslHandler(sslEngine);\n    }\n\n    private void connectProxyServer() {\n        bootstrap.connect(config.getStringValue(\"server.host\"), config.getIntValue(\"server.port\")).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    ProxyMessage proxyMessage = new ProxyMessage();\n                    proxyMessage.setType(ProxyMessage.C_TYPE_AUTH);\n                    proxyMessage.setUri(config.getStringValue(\"client.key\"));\n                    future.channel().writeAndFlush(proxyMessage);\n                    sleepTimeMill = 1000;\n                    logger.info(\"connect proxy server success, {}\", future.channel());\n                } else {\n                    logger.warn(\"connect proxy server failed\", future.cause());\n                    reconnectWait();\n                    connectProxyServer();\n                }\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        try {\n            if (sleepTimeMill > 60000) {\n                sleepTimeMill = 1000;\n            }\n            synchronized (this) {\n                sleepTimeMill = sleepTimeMill * 2;\n                wait(sleepTimeMill);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ProxyClientContainer {\n    private final Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n    private final NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final Bootstrap realServerBootstrap = new Bootstrap();\n    private final Config config;\n    private SslContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer(Config config) {\n        this.config = config;\n        bootstrap.group(workerGroup);\n        bootstrap.channel(config.useSSL() ? SocketChannel.class : null);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ChannelPipeline pipeline = ch.pipeline();\n                if (config.useSSL()) {\n                    pipeline.addLast(createSslHandler(sslContext));\n                }\n                pipeline.addLast(new HttpServerCodec());\n                pipeline.addLast(new HttpObjectAggregator());\n            }\n        });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SslContext sslContext) {\n        return sslContext.newHandler();\n    }\n\n    private void connectProxyServer() {\n        try {\n            Channel channel = bootstrap.connect(config.proxyHost, config.proxyPort).sync().channel();\n            channel.closeFuture().await();\n        } catch (Exception e) {\n            logger.error(\"Failed to connect to proxy server\", e);\n            reconnectWait();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        logger.info(\"Channel inactive, attempting reconnection\");\n        reconnectWait();\n    }\n\n    private void reconnectWait() {\n        sleepTimeMill = Math.min(sleepTimeMill * 2, 60000);\n        try {\n            Thread.sleep(sleepTimeMill);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        connectProxyServer();\n    }\n}"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, maintenance, and graceful shutdown.\n\nClass Description: HttpEventChannelManager is a Netty-based TCP client manager that creates and maintains connections to remote servers, provides connection metrics, and handles resource cleanup.\n\nAttributes:\n- LOG: [Logger] - Logger instance for logging debug and error messages\n- connectionSuccess: [Counter] - Metric counter for successful connections\n- connectionFailure: [Counter] - Metric counter for failed connections\n- liveConnections: [AtomicDouble] - Gauge metric for current active connections\n- nettyChannelBufferSize: [AtomicDouble] - Gauge metric for current channel buffer size\n- lowWriteBufferWatermark: [int] - Low watermark for write buffer\n- highWriteBufferWatermark: [int] - High watermark for write buffer\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- encoderEventLoopGroup: [EventLoopGroup] - Optional event loop group for compression\n- bootstrap: [Bootstrap] - Netty bootstrap for client configuration\n- channels: [ConcurrentMap<String, Channel>] - Map of active channels keyed by host:port\n\nMethods:\n- HttpEventChannelManager([Registry, MrePublishConfiguration]) -> [void] - Constructor that initializes metrics, event loops, and bootstrap configuration\n- findOrCreate([InetSocketAddress]) -> [Channel] - Finds existing or creates new channel for given address\n- find([InetSocketAddress]) -> [Channel] - Finds existing channel for given address\n- close([InetSocketAddress]) -> [void] - Closes channel for given address\n- getHostPortString([InetSocketAddress]) -> [String] - Helper method to format address as host:port string",
    "Canonical_solution": "import com.netflix.spectator.api.Counter;\nimport com.netflix.spectator.api.Registry;\nimport com.netflix.spectator.impl.AtomicDouble;\nimport io.mantisrx.publish.config.MrePublishConfiguration;\nimport io.mantisrx.publish.internal.metrics.SpectatorUtils;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpEventChannelManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannel.class);\n\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(\n            Registry registry,\n            MrePublishConfiguration config) {\n\n        this.connectionSuccess =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionSuccess\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.connectionFailure =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionFailure\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.liveConnections =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"liveConnections\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.nettyChannelBufferSize =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"bufferSize\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n\n        this.eventLoopGroup = new NioEventLoopGroup(config.getIoThreads());\n\n        boolean gzipEnabled = config.getGzipEnabled();\n        if (gzipEnabled) {\n            this.encoderEventLoopGroup = new DefaultEventLoopGroup(config.getCompressionThreads());\n        } else {\n            this.encoderEventLoopGroup = null;\n        }\n\n        this.bootstrap = new Bootstrap()\n                .group(this.eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.MESSAGE_SIZE_ESTIMATOR, MantisMessageSizeEstimator.DEFAULT)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(\n                                lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new HttpEventChannelInitializer(\n                        registry, config, encoderEventLoopGroup));\n        this.channels = new ConcurrentHashMap<>();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(this.eventLoopGroup::shutdownGracefully));\n    }\n\n    Channel findOrCreate(InetSocketAddress address) {\n        Channel channel = find(address);\n\n        if (channel == null) {\n            LOG.debug(\"creating new channel for {}\", address);\n            ChannelFuture channelFuture = bootstrap.connect(address);\n            channel = channelFuture.channel();\n\n            channels.put(getHostPortString(address), channel);\n\n            channel.closeFuture().addListener(future -> {\n                LOG.debug(\"closing channel for {}\", address);\n                channels.remove(getHostPortString(address));\n                liveConnections.set((double) channels.size());\n            });\n\n            channelFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    LOG.debug(\"connection success for {}\", address);\n                    connectionSuccess.increment();\n                    liveConnections.set((double) channels.size());\n                } else {\n                    LOG.debug(\"failed to connect to {}\", address);\n                    connectionFailure.increment();\n                }\n            });\n        }\n\n        nettyChannelBufferSize.set(highWriteBufferWatermark - channel.bytesBeforeUnwritable());\n\n        return channel;\n    }\n\n    private Channel find(InetSocketAddress address) {\n        return channels.get(getHostPortString(address));\n    }\n\n    void close(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + ':' + address.getPort();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.codahale.metrics.Counter;\nimport com.codahale.metrics.Gauge;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicDouble;\n\npublic class HttpEventChannelManager {\n    private final Logger LOG = LoggerFactory.getLogger(HttpEventChannelManager.class);\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final Gauge<Double> liveConnections;\n    private final Gauge<Double> nettyChannelBufferSize;\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentHashMap<InetSocketAddress, Channel> channels;\n\n    public HttpEventChannelManager(Registry registry, MrePublishConfiguration config) {\n        this.connectionSuccess = registry.counter(\"http.event.channel.success\");\n        this.connectionFailure = registry.counter(\"http.event.channel.failure\");\n        this.liveConnections = registry.gauge(\"http.event.channel.live\", new AtomicDouble(0));\n        this.nettyChannelBufferSize = registry.gauge(\"http.event.channel.buffer.size\", new AtomicDouble(0));\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.encoderEventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.channels = new ConcurrentHashMap<>();\n\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .handler(new ChannelHandler() {\n                    // Channel handler implementation\n                });\n    }\n\n    public Channel findOrCreate(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel == null) {\n            try {\n                channel = bootstrap.connect(address).sync().channel();\n                channels.put(address, channel);\n                connectionSuccess.inc();\n                liveConnections.update(1.0);\n                nettyChannelBufferSize.update(channel.pipeline().get(\"buffer\").getOption(ChannelOption.WRITE_BUFFER_SIZE));\n            } catch (Exception e) {\n                LOG.error(\"Failed to connect to {}\", address, e);\n                connectionFailure.inc();\n            }\n        }\n        return channel;\n    }\n\n    public Channel find(InetSocketAddress address) {\n        return channels.get(address);\n    }\n\n    public void close(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel != null) {\n            try {\n                channel.close().sync();\n                channels.remove(address);\n                liveConnections.update(0.0);\n            } catch (Exception e) {\n                LOG.error(\"Failed to close channel for {}\", address, e);\n            }\n        }\n    }\n\n    public String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + \":\" + address.getPort();\n    }\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.util.Queue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\nimport java.util.concurrent.atomic.AtomicLongArray;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicIntegerReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicBooleanReferenceFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.concurrent.atomic.Atomic"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a Docker daemon, with support for SSL/TLS encryption and timeout handling.\n\nClass Description: The NettyTcpClient class provides functionality to establish and manage TCP connections to a Docker daemon using Netty framework. It handles connection initialization, SSL/TLS configuration, timeout management, and graceful shutdown.\n\nAttributes:\n- bootstrap: Bootstrap - Netty's client bootstrap for connection configuration\n- eventLoopGroup: EventLoopGroup - Manages client-side I/O threads\n- connectTimeout: Integer - Connection timeout in milliseconds\n- readTimeout: Integer - Read operation timeout in milliseconds\n- threadPrefix: String - Prefix for Netty thread names\n\nMethods:\n- init(DockerClientConfig dockerClientConfig) -> void - Initializes the Netty client with Docker configuration\n- connect(DockerClientConfig dockerClientConfig) -> DuplexChannel - Establishes connection to Docker daemon with SSL support\n- initSsl(DockerClientConfig dockerClientConfig) -> SslHandler - Configures SSL/TLS for the connection\n- enableHostNameVerification(SSLParameters sslParameters) -> SSLParameters - Enables hostname verification in SSL parameters\n- close() -> void - Shuts down the client gracefully\n- configure(T channel) -> T - Configures channel timeouts and handlers\n- ReadTimeoutHandler() -> void - Inner class handling read timeout events",
    "Canonical_solution": "import com.github.dockerjava.core.DockerClientConfig;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelConfig;\nimport io.netty.channel.ChannelFactory;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DuplexChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContentDecompressor;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultThreadFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketTimeoutException;\nimport java.security.Security;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLParameters;\n\npublic class NettyTcpClient {\n\n    private static String threadPrefix = \"dockerjava-netty\";\n    private Bootstrap bootstrap;\n    private EventLoopGroup eventLoopGroup;\n    private Integer connectTimeout;\n    private Integer readTimeout;\n\n    public void init(DockerClientConfig dockerClientConfig) {\n        bootstrap = new Bootstrap();\n        eventLoopGroup = new NioEventLoopGroup(0, new DefaultThreadFactory(threadPrefix));\n\n        InetAddress addr = InetAddress.getLoopbackAddress();\n        final SocketAddress proxyAddress = new InetSocketAddress(addr, 8008);\n\n        Security.addProvider(new BouncyCastleProvider());\n\n        ChannelFactory<NioSocketChannel> factory = () -> configure(new NioSocketChannel());\n\n        bootstrap.group(eventLoopGroup).channelFactory(factory)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(final SocketChannel channel) throws Exception {\n                        channel.pipeline().addLast(new HttpClientCodec());\n                        channel.pipeline().addLast(new HttpContentDecompressor());\n                    }\n                });\n    }\n\n    public DuplexChannel connect(DockerClientConfig dockerClientConfig) throws InterruptedException {\n        String host = dockerClientConfig.getDockerHost().getHost();\n        int port = dockerClientConfig.getDockerHost().getPort();\n\n        if (port == -1) {\n            throw new RuntimeException(\"no port configured for \" + host);\n        }\n\n        final DuplexChannel channel = (DuplexChannel) bootstrap.connect(host, port).sync().channel();\n\n        final SslHandler ssl = initSsl(dockerClientConfig);\n\n        if (ssl != null) {\n            channel.pipeline().addFirst(ssl);\n            ssl.sslCloseFuture().addListener(future -> channel.eventLoop().execute(channel::close));\n        }\n\n        return channel;\n    }\n\n    private SslHandler initSsl(DockerClientConfig dockerClientConfig) {\n        SslHandler ssl = null;\n\n        try {\n            String host = dockerClientConfig.getDockerHost().getHost();\n            int port = dockerClientConfig.getDockerHost().getPort();\n\n            final SSLConfig sslConfig = dockerClientConfig.getSSLConfig();\n\n            if (sslConfig != null && sslConfig.getSSLContext() != null) {\n                SSLEngine engine = sslConfig.getSSLContext().createSSLEngine(host, port);\n                engine.setUseClientMode(true);\n                engine.setSSLParameters(enableHostNameVerification(engine.getSSLParameters()));\n                ssl = new SslHandler(engine);\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        return ssl;\n    }\n\n    public SSLParameters enableHostNameVerification(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        return sslParameters;\n    }\n\n    public void close() throws IOException {\n        Objects.requireNonNull(eventLoopGroup, \"Factory not initialized. You probably forgot to call init()!\");\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    private <T extends Channel> T configure(T channel) {\n        ChannelConfig channelConfig = channel.config();\n\n        if (connectTimeout != null) {\n            channelConfig.setConnectTimeoutMillis(connectTimeout);\n        }\n        if (readTimeout != null) {\n            channel.pipeline().addLast(\"readTimeoutHandler\", new ReadTimeoutHandler());\n        }\n\n        return channel;\n    }\n\n    private final class ReadTimeoutHandler extends IdleStateHandler {\n        private boolean alreadyTimedOut;\n\n        ReadTimeoutHandler() {\n            super(readTimeout, 0, 0, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        protected synchronized void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n            assert evt.state() == IdleState.READER_IDLE;\n            final Channel channel = ctx.channel();\n            if (channel == null || !channel.isActive() || alreadyTimedOut) {\n                return;\n            }\n            DockerClientConfig dockerClientConfig = getDockerClientConfig();\n            final Object dockerAPIEndpoint = dockerClientConfig.getDockerHost();\n            final String msg = \"Read timed out: No data received within \" + readTimeout\n                    + \"ms.  Perhaps the docker API (\" + dockerAPIEndpoint\n                    + \") is not responding normally, or perhaps you need to increase the readTimeout value.\";\n            final Exception ex = new SocketTimeoutException(msg);\n            ctx.fireExceptionCaught(ex);\n            alreadyTimedOut = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.handler.timeout.ReadTimeoutHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslParameters;"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a Netty-based TCP server for RPC (Remote Procedure Call) communication that handles incoming client connections, processes RPC requests, and manages server resources efficiently.\n\nClass Description: NettyRpcServer is a Spring component that establishes a TCP server using Netty framework to handle RPC communications. It manages service registration, client connections, and provides graceful shutdown capabilities.\n\nAttributes:\n- PORT: [int] - The port number on which the server listens for incoming connections (default: 9998).\n- serviceProvider: [ServiceProvider] - An instance responsible for managing and providing registered RPC services (singleton instance of ZkServiceProviderImpl).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. Configures event loop groups, server bootstrap, channel pipeline with handlers for encoding/decoding RPC messages, and idle state detection. Binds to the specified host and port, and keeps the server running until shutdown.\n  Input: None\n  Output: None\n\n- registerService(RpcServiceConfig rpcServiceConfig): [void] - Registers an RPC service with the service provider.\n  Input: rpcServiceConfig [RpcServiceConfig] - Configuration object containing RPC service details to be registered.\n  Output: None",
    "Canonical_solution": "import github.javaguide.config.CustomShutdownHook;\nimport github.javaguide.config.RpcServiceConfig;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.provider.ServiceProvider;\nimport github.javaguide.provider.impl.ZkServiceProviderImpl;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport github.javaguide.utils.RuntimeUtil;\nimport github.javaguide.utils.concurrent.threadpool.ThreadPoolFactoryUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport java.net.InetAddress;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\n@Component\npublic class NettyRpcServer {\n\n    public static final int PORT = 9998;\n\n    private final ServiceProvider serviceProvider = SingletonFactory.getInstance(ZkServiceProviderImpl.class);\n\n    @SneakyThrows\n    public void start() {\n        CustomShutdownHook.getCustomShutdownHook().clearAll();\n        String host = InetAddress.getLocalHost().getHostAddress();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        DefaultEventExecutorGroup serviceHandlerGroup = new DefaultEventExecutorGroup(\n                RuntimeUtil.cpus() * 2,\n                ThreadPoolFactoryUtil.createThreadFactory(\"service-handler-group\", false)\n        );\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline p = ch.pipeline();\n                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                            p.addLast(new RpcMessageEncoder());\n                            p.addLast(new RpcMessageDecoder());\n                            p.addLast(serviceHandlerGroup, new NettyRpcServerHandler());\n                        }\n                    });\n\n            ChannelFuture f = b.bind(host, PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"occur exception when start server:\", e);\n        } finally {\n            log.error(\"shutdown bossGroup and workerGroup\");\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            serviceHandlerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.publishService(rpcServiceConfig);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "@Configuration\n@Component\npublic class NettyRpcServer {\n\n    private int PORT = 9998;\n    private ServiceProvider serviceProvider;\n\n    public NettyRpcServer() {\n        this.serviceProvider = new ZkServiceProviderImpl();\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_REUSEADDR, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new RpcMessageDecoder());\n                            pipeline.addLast(new RpcMessageEncoder());\n                            pipeline.addLast(new RpcServerHandler(serviceProvider));\n                        }\n                    })\n                    .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 1000);\n\n            ChannelFuture future = bootstrap.bind(PORT).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.registerService(rpcServiceConfig);\n    }\n}"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Implement a Netty-based JAX-RS server class that handles HTTP requests and integrates with RESTEasy framework for RESTful service deployment.\n\nClass Description: SofaNettyJaxrsServer is a Netty-based embedded JAX-RS server implementation that provides HTTP communication capabilities and integrates with RESTEasy framework for RESTful service deployment. It supports both standard NIO and Epoll transport, SSL/TLS encryption, and customizable channel options.\n\nAttributes:\n- serverConfig: [ServerConfig] - Configuration object containing server settings\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- hostname: [String] - Hostname to bind the server to\n- port: [int] - Port number to listen on\n- deployment: [ResteasyDeployment] - RESTEasy deployment configuration\n- root: [String] - Root resource path\n- domain: [SecurityDomain] - Security domain for authentication\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- eventExecutor: [EventLoopGroup] - Netty event executor for business logic\n- ioWorkerCount: [int] - Number of I/O worker threads\n- executorThreadCount: [int] - Number of executor threads\n- sslContext: [SSLContext] - SSL context for secure connections\n- maxRequestSize: [int] - Maximum allowed HTTP request size\n- backlog: [int] - Connection backlog size\n- channelHandlers: [List<ChannelHandler>] - Additional channel handlers\n- channelOptions: [Map<ChannelOption, Object>] - Channel options\n- childChannelOptions: [Map<ChannelOption, Object>] - Child channel options\n- httpChannelHandlers: [List<ChannelHandler>] - Additional HTTP channel handlers\n\nMethods:\n- start(): [void] - Starts the Netty server and binds it to the configured host and port\n- stop(): [void] - Stops the server and releases all resources\n- createChannelInitializer(): [ChannelInitializer<SocketChannel>] - Creates a channel initializer for new connections\n- setupHandlers(SocketChannel ch, RequestDispatcher dispatcher): [void] - Sets up the channel pipeline with required handlers\n- createRequestDispatcher(): [RequestDispatcher] - Creates a RESTEasy request dispatcher",
    "Canonical_solution": "import com.alipay.sofa.rpc.common.SystemInfo;\nimport com.alipay.sofa.rpc.common.struct.NamedThreadFactory;\nimport com.alipay.sofa.rpc.common.utils.StringUtils;\nimport com.alipay.sofa.rpc.config.ServerConfig;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.EventExecutor;\nimport org.jboss.resteasy.core.SynchronousDispatcher;\nimport org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;\nimport org.jboss.resteasy.plugins.server.embedded.SecurityDomain;\nimport org.jboss.resteasy.plugins.server.netty.RequestDispatcher;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SofaNettyJaxrsServer implements EmbeddedJaxrsServer {\n\n    private final ServerConfig         serverConfig;\n    protected ServerBootstrap          bootstrap;\n    protected String                   hostname;\n    protected int                      port;\n    protected ResteasyDeployment       deployment;\n    protected String                   root;\n    protected SecurityDomain           domain;\n    private EventLoopGroup             eventLoopGroup;\n    private EventLoopGroup             eventExecutor;\n    private int                        ioWorkerCount;\n    private int                        executorThreadCount;\n    private SSLContext                 sslContext;\n    private int                        maxRequestSize;\n    private int                        backlog;\n    private List<ChannelHandler>       channelHandlers;\n    private Map<ChannelOption, Object> channelOptions;\n    private Map<ChannelOption, Object> childChannelOptions;\n    private List<ChannelHandler>       httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig) {\n        if (serverConfig == null) {\n            throw new IllegalArgumentException(\"server config is null\");\n        }\n        this.serverConfig = serverConfig;\n        this.deployment = new ResteasyDeployment();\n        this.root = \"\";\n        this.ioWorkerCount = SystemInfo.getCpuCores() * 2;\n        this.executorThreadCount = 16;\n        this.maxRequestSize = 1024 * 1024 * 10;\n        this.backlog = 128;\n        this.channelHandlers = Collections.emptyList();\n        this.channelOptions = Collections.emptyMap();\n        this.childChannelOptions = Collections.emptyMap();\n        this.httpChannelHandlers = Collections.emptyList();\n    }\n\n    @Override\n    public void start() {\n        boolean daemon = serverConfig.isDaemon();\n        boolean isEpoll = serverConfig.isEpoll();\n        NamedThreadFactory ioFactory = new NamedThreadFactory(\"SEV-REST-IO-\" + port, daemon);\n        NamedThreadFactory bizFactory = new NamedThreadFactory(\"SEV-REST-BIZ-\" + port, daemon);\n        eventLoopGroup = isEpoll ? new EpollEventLoopGroup(ioWorkerCount, ioFactory)\n            : new NioEventLoopGroup(ioWorkerCount, ioFactory);\n        eventExecutor = isEpoll ? new EpollEventLoopGroup(executorThreadCount, bizFactory)\n            : new NioEventLoopGroup(executorThreadCount, bizFactory);\n\n        bootstrap = new ServerBootstrap()\n            .group(eventLoopGroup)\n            .channel(isEpoll ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n            .childHandler(createChannelInitializer())\n            .option(ChannelOption.SO_BACKLOG, backlog)\n            .childOption(ChannelOption.SO_KEEPALIVE, serverConfig.isKeepAlive());\n\n        for (Map.Entry<ChannelOption, Object> entry : channelOptions.entrySet()) {\n            bootstrap.option(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<ChannelOption, Object> entry : childChannelOptions.entrySet()) {\n            bootstrap.childOption(entry.getKey(), entry.getValue());\n        }\n\n        final InetSocketAddress socketAddress;\n        if (null == hostname || hostname.isEmpty()) {\n            socketAddress = new InetSocketAddress(port);\n        } else {\n            socketAddress = new InetSocketAddress(hostname, port);\n        }\n\n        bootstrap.bind(socketAddress).syncUninterruptibly();\n    }\n\n    private ChannelInitializer<SocketChannel> createChannelInitializer() {\n        final RequestDispatcher dispatcher = createRequestDispatcher();\n        if (sslContext == null) {\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        } else {\n            final SSLEngine engine = sslContext.createSSLEngine();\n            engine.setUseClientMode(false);\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addFirst(new SslHandler(engine));\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        }\n    }\n\n    private void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ChannelPipeline channelPipeline = ch.pipeline();\n        channelPipeline.addLast(channelHandlers.toArray(new ChannelHandler[channelHandlers.size()]));\n        channelPipeline.addLast(new HttpRequestDecoder());\n        channelPipeline.addLast(new HttpObjectAggregator(maxRequestSize));\n        channelPipeline.addLast(new HttpResponseEncoder());\n        channelPipeline.addLast(httpChannelHandlers.toArray(new ChannelHandler[httpChannelHandlers.size()]));\n        channelPipeline.addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root));\n        channelPipeline.addLast(new RestEasyHttpResponseEncoder());\n        channelPipeline.addLast(eventExecutor, new SofaRestRequestHandler(dispatcher));\n    }\n\n    protected RequestDispatcher createRequestDispatcher() {\n        return new RequestDispatcher((SynchronousDispatcher) deployment.getDispatcher(),\n            deployment.getProviderFactory(), domain);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            eventLoopGroup.shutdownGracefully().sync();\n            eventExecutor.shutdownGracefully().sync();\n        } catch (Exception ignore) {\n        }\n        bootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.EpollChannelOption;\nimport io.netty.channel.epoll.EpollServerBootstrap;\nimport io.netty.channel.nio.NioServerBootstrap;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport org.jboss.resteasy.plugins.server.netty.NettyRequestDispatcher;\nimport org.jboss.resteasy.plugins.server.netty.RequestDispatcher;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\n\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class SofaNettyJaxrsServer {\n    private final ServerConfig serverConfig;\n    private final ServerBootstrap bootstrap;\n    private final String hostname;\n    private final int port;\n    private final ResteasyDeployment deployment;\n    private final String root;\n    private final SecurityDomain domain;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup eventExecutor;\n    private final int ioWorkerCount;\n    private final int executorThreadCount;\n    private final SSLContext sslContext;\n    private final int maxRequestSize;\n    private final int backlog;\n    private final List<ChannelHandler> channelHandlers;\n    private final Map<ChannelOption, Object> channelOptions;\n    private final Map<ChannelOption, Object> childChannelOptions;\n    private final List<ChannelHandler> httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig, ResteasyDeployment deployment, String root, SecurityDomain domain) {\n        this.serverConfig = serverConfig;\n        this.deployment = deployment;\n        this.root = root;\n        this.domain = domain;\n        this.hostname = serverConfig.getHostname();\n        this.port = serverConfig.getPort();\n        this.ioWorkerCount = serverConfig.getIoWorkerCount();\n        this.executorThreadCount = serverConfig.getExecutorThreadCount();\n        this.maxRequestSize = serverConfig.getMaxRequestSize();\n        this.backlog = serverConfig.getBacklog();\n        this.channelHandlers = serverConfig.getChannelHandlers();\n        this.channelOptions = serverConfig.getChannelOptions();\n        this.childChannelOptions = serverConfig.getChildChannelOptions();\n        this.httpChannelHandlers = serverConfig.getHttpChannelHandlers();\n\n        if (serverConfig.isUseEpoll()) {\n            bootstrap = new EpollServerBootstrap();\n        } else {\n            bootstrap = new NioServerBootstrap();\n        }\n\n        eventLoopGroup = new EventLoopGroup(ioWorkerCount);\n        eventExecutor = new EventLoopGroup(executorThreadCount);\n    }\n\n    public void start() {\n        bootstrap.group(eventLoopGroup, eventExecutor)\n                .channel(serverConfig.isUseEpoll() ? EpollChannelOption.class : NioServerBootstrap.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .option(ChannelOption.SO_BACKLOG, backlog)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.MAX_MESSAGES_BUFFERED, 100)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.SO_TIMEOUT, 30000)\n                .childOption(ChannelOption.CHUNKED_WRITE_ENABLED, true)\n                .childOption(ChannelOption.WRITE_BUFFERSIZE, 1024 * 1024)\n                .childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .childOption(ChannelOption.SO_LINGER, 30)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.ENABLE_AUTOREAD, true)\n                .childOption(ChannelOption.ENABLE_DUPLEX, true)\n                .childOption(ChannelOption.KEEPALIVE, true)\n                .childOption(ChannelOption.SO_REUSEPORT, true)\n                .childOption(ChannelOption.SO_BINDANDLISTEN, true)\n                .childOption(ChannelOption.SO_REUSEADDR"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.Path;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        // Example processing logic for a chunk\n        // This is a placeholder and should be replaced with actual data parsing logic\n        int offset = 0;\n        while (offset < chunkSize) {\n            ByteBuffer fieldBuffer = ByteBuffer.allocate(4);\n            chunk.get(fieldBuffer);\n            fieldBuffer.flip();\n            int fieldId = fieldBuffer.getInt();\n            fieldBuffer.clear();\n\n            ByteBuffer valueBuffer = ByteBuffer.allocate(4);\n            chunk.get(valueBuffer);\n            valueBuffer.flip();\n            int value = valueBuffer.getInt();\n            valueBuffer.clear();\n\n            // Update statistics for the field ID\n            mins.putIfAbsent(fieldBuffer, Integer.MAX_VALUE);\n            mins.merge(fieldBuffer, Math.min(mins.get(fieldBuffer), value), Math::min);\n\n            maxs.putIfAbsent(fieldBuffer, Integer.MIN_VALUE);\n            maxs.merge(fieldBuffer, Math.max(maxs.get(fieldBuffer), value), Math::max);\n\n            sums.putIfAbsent(fieldBuffer, 0);\n            sums.merge(fieldBuffer, value, Integer::sum);\n\n            counts.putIfAbsent(fieldBuffer, 0);\n            counts.merge(fieldBuffer, 1, Integer::sum);\n\n            offset += 8; // Assuming 4 bytes for field ID and 4 bytes for value\n        }\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (RandomAccessFile file = new RandomAccessFile(filePath.toFile(), \"r\");\n             FileChannel channel = file.getChannel()) {\n            long fileSize = channel.size();\n            long chunkSize = 1024 * 1024 * 10; // 10 MB chunks\n            long start = 0;\n            long end = Math.min(start + chunkSize, fileSize);\n\n            while (start < fileSize) {\n                MappedByteBuffer chunk = channel.map(FileChannel.MapMode.READ_ONLY, start, end);\n                processChunk(chunk, end - start);\n                start = end;\n                end = Math.min(start + chunkSize, fileSize);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process protocol messages.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes protocol messages using custom channel handlers. It manages server resources including event loop groups and provides graceful shutdown capabilities.\n\nAttributes:\n- acceptorEventLoopGroup: [EventLoopGroup] - Handles accepting new connections (boss group)\n- networkEventLoopGroup: [EventLoopGroup] - Handles network I/O operations (worker group)\n- eventExecutorGroup: [EventExecutorGroup] - Executes business logic handlers\n- config: [Config] - Server configuration including port number\n- applicationContext: [ApplicationContext] - Spring application context for dependency injection\n\nMethods:\n- ProtocolServer([Config] config, [ApplicationContext] applicationContext) -> [void] - Constructor that initializes event loop groups with specified configurations\n- start() -> [ChannelFuture] - Starts the server, binds to the configured port, and returns a ChannelFuture that can be used to wait for server shutdown",
    "Canonical_solution": "import com.codingapi.txlcn.protocol.config.Config;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelHandler;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport org.springframework.context.ApplicationContext;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtocolServer {\n\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup(6);\n        this.eventExecutorGroup = new NioEventLoopGroup(10);\n    }\n\n    public ChannelFuture start() throws InterruptedException {\n        int portToBind = config.getPort();\n        ProtocolChannelHandler protocolChannelHandler = new ProtocolChannelHandler(new Protocoler(config), applicationContext, config);\n        ProtocolChannelInitializer protocolChannelInitializer = new ProtocolChannelInitializer(config, protocolChannelHandler, eventExecutorGroup);\n\n        final ServerBootstrap peerBootstrap = new ServerBootstrap();\n        peerBootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(protocolChannelInitializer);\n\n        final ChannelFuture bindFuture = peerBootstrap.bind(portToBind).sync();\n        if (bindFuture.isSuccess()) {\n            final Channel serverChannel = bindFuture.channel();\n            return serverChannel.closeFuture();\n        } else {\n            throw new RuntimeException(\"Server could not bind to \" + portToBind, bindFuture.cause());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.ServerChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.springframework.context.ApplicationContext;\n\npublic class ProtocolServer {\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new EventLoopGroup(config.getBossThreadCount());\n        this.networkEventLoopGroup = new EventLoopGroup(config.getWorkerThreadCount());\n        this.eventExecutorGroup = new EventExecutorGroup(config.getWorkerThreadCount());\n    }\n\n    public ChannelFuture start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ProtocolServerHandler(applicationContext, eventExecutorGroup))\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        return bootstrap.bind(config.getPort()).sync();\n    }\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.ByteBuffer;\n\npublic class AnonAllocator {\n    private static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        MAP_AND_UNLINK_SUPPORTED = false;\n        try {\n            // Check if memory-mapped file with immediate unlink is supported\n            File tempFile = File.createTempFile(\"anon\", \".tmp\");\n            Path path = tempFile.toPath();\n            Files.delete(path); // Ensure the file is deleted to test unlinking\n            try (FileChannel channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n                MappedByteBuffer mapped = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1024);\n                Files.delete(path); // Attempt to delete the file after mapping\n                mapped.force(); // Ensure data is written to the file\n                MAP_AND_UNLINK_SUPPORTED = true;\n            } catch (IOException e) {\n                // If an exception occurs, it's not supported\n            }\n        } catch (IOException e) {\n            // If file creation fails, it's not supported\n        }\n    }\n\n    public ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                File tempFile = File.createTempFile(\"anon\", \".tmp\");\n                Path path = tempFile.toPath();\n                try (FileChannel channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n                    MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    Files.delete(path); // Unlink the file immediately\n                    return buffer;\n                }\n            } catch (IOException e) {\n                // Fallback to direct buffer if memory-mapped file is not available\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n}\n```"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "abstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = 8192; // Default buffer size\n        this.syncSize = 1024 * 1024; // 1 MB synchronization interval\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(remaining, bufferSize);\n    }\n\n    public boolean isSync(long position) {\n        return position >= syncPosition && (position - syncPosition) >= syncSize;\n    }\n\n    public List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) {\n        List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        try (FileChannel in = FileChannel.open(file.toPath(), StandardOpenOption.READ)) {\n            DataStreamOutput out = client.getOutputStream();\n            long offset = 0;\n            while (offset < fileSize) {\n                long packetSize = getPacketSize(offset);\n                CompletableFuture<DataStreamReply> future = CompletableFuture.supplyAsync(() -> {\n                    try {\n                        long written = write(in, out, offset, futures);\n                        if (written > 0) {\n                            offset += written;\n                            if (isSync(offset)) {\n                                syncPosition = offset;\n                            }\n                        }\n                        return new DataStreamReply(true, \"Transfer progress: \" + offset + \" / \" + fileSize + \" bytes\");\n                    } catch (Exception e) {\n                        return new DataStreamReply(false, \"Transfer error: \" + e.getMessage());\n                    }\n                });\n                futures.add(future);\n                offset += packetSize;\n            }\n        } catch (IOException e) {\n            futures.add(CompletableFuture.supplyAsync(() -> new DataStreamReply(false, \"File transfer failed: \" + e.getMessage())));\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures);\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n               \"path='\" + path + '\\'' +\n               \", fileSize=\" + fileSize +\n               \", bufferSize=\" + bufferSize +\n               \", syncSize=\" + syncSize +\n               '}';\n    }\n}"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Implement a WebSocket proxy server using Java Netty framework to handle WebSocket connections and manage client-server communication.\n\nClass Description: WebsocketProxy is a class that implements a Proxy interface and provides functionality to start a WebSocket server on a specified port. It handles WebSocket protocol upgrades, HTTP requests, and manages client connections with proper resource cleanup.\n\nAttributes:\n- None (All variables are local to methods)\n\nMethods:\n- start(int port) -> void - Starts the WebSocket server on the specified port. Initializes event loop groups, configures server bootstrap with appropriate channel and handlers, binds to the port, and manages server lifecycle including graceful shutdown. Throws InterruptedException if the thread is interrupted during server operation.\n\nInput:\n- port: int - The port number on which the WebSocket server should listen for incoming connections\n\nOutput:\n- None (Void method, but it will start a server that listens on the specified port and handles WebSocket connections)\n\nNote: The implementation should include proper error handling, resource management, and support for both NIO and Epoll transport mechanisms based on system availability. The server should handle WebSocket protocol upgrades, HTTP codecs, chunked writes, and idle connection management.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpServerCodec())\n                                    .addLast(new ChunkedWriteHandler())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(\"ws\", new WebSocketServerProtocolHandler(\"/ratel\"))\n                                    .addLast(new WebsocketTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The websocket server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollChannelOption;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy {\n\n    private final int port;\n\n    public WebsocketProxy(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new EpollEventLoopGroup(1);\n        EventLoopGroup workerGroup = new EpollEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioChannel.class)\n                    .option(ChannelOption.SO_REUSEADDR, true)\n                    .childOption(EpollChannelOption.SO_REUSEADDR, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childHandler(new WebsocketProxyInitializer());\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class WebsocketProxyInitializer extends io.netty.bootstrap.ServerBootstrap.HandlerAdapter {\n        @Override\n        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (msg instanceof io.netty.handler.codec.http.FullHttpRequest) {\n                // Handle HTTP upgrade to WebSocket\n                ctx.fireChannelRead(msg);\n            } else if (msg instanceof io.netty.handler.codec.http.LastHttpContent) {\n                // Handle WebSocket frame\n                ctx.fireChannelRead(msg);\n            } else {\n                // Handle other messages\n                ctx.fireChannelRead(msg);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        int port = 8080;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new WebsocketProxy(port).start();\n    }\n}"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework for backup communication in a distributed system. The server should handle incoming UDP packets, decode them, and process messages while managing resources efficiently.\n\nClass Description: BackupServer is an AutoCloseable class that establishes a Netty-based UDP server for backup communication. It manages network connections, message handling, and graceful shutdown procedures.\n\nAttributes:\n- commonParameter: [CommonParameter] - Configuration parameters for the backup server\n- port: [int] - Port number to bind the UDP server\n- backupManager: [BackupManager] - Manager for backup operations\n- channel: [Channel] - Netty channel for UDP communication\n- shutdown: [boolean] - Flag indicating server shutdown status\n- executor: [ExecutorService] - Thread executor for server operations\n\nMethods:\n- initServer(): [void]() -> [void] - Initializes and starts the backup server in a separate thread if conditions are met\n- start(): [void]() throws [Exception] - Configures and starts the Netty UDP server with proper handlers\n- close(): [void]() -> [void] - Implements AutoCloseable to gracefully shutdown the server and release resources\n\nConstructor:\n- BackupServer([BackupManager backupManager]) - Creates a new instance with the specified BackupManager",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.common.backup.BackupManager;\nimport org.tron.common.es.ExecutorServiceManager;\nimport org.tron.common.parameter.CommonParameter;\nimport org.tron.p2p.stats.TrafficStats;\n\npublic class BackupServer implements AutoCloseable {\n\n  private CommonParameter commonParameter = CommonParameter.getInstance();\n  private int port = commonParameter.getBackupPort();\n  private BackupManager backupManager;\n  private Channel channel;\n  private volatile boolean shutdown = false;\n  private ExecutorService executor;\n\n  public BackupServer(final BackupManager backupManager) {\n    this.backupManager = backupManager;\n  }\n\n  public void initServer() {\n    if (port > 0 && commonParameter.getBackupMembers().size() > 0) {\n      executor = ExecutorServiceManager.newSingleThreadExecutor(\"BackupServer\");\n      executor.submit(() -> {\n        try {\n          start();\n        } catch (Exception e) {\n          logger.error(\"Start backup server failed, {}\", e);\n        }\n      });\n    }\n  }\n\n  private void start() throws Exception {\n    NioEventLoopGroup group = new NioEventLoopGroup(1);\n    try {\n      while (!shutdown) {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n            .channel(NioDatagramChannel.class)\n            .handler(new ChannelInitializer<NioDatagramChannel>() {\n              @Override\n              public void initChannel(NioDatagramChannel ch) throws Exception {\n                ch.pipeline().addLast(TrafficStats.udp);\n                ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());\n                ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());\n                ch.pipeline().addLast(new PacketDecoder());\n                MessageHandler messageHandler = new MessageHandler(ch, backupManager);\n                backupManager.setMessageHandler(messageHandler);\n                ch.pipeline().addLast(messageHandler);\n              }\n            });\n\n        channel = b.bind(port).sync().channel();\n        channel.closeFuture().sync();\n        if (shutdown) {\n          break;\n        }\n      }\n    } finally {\n      group.shutdownGracefully().sync();\n    }\n  }\n\n  @Override\n  public void close() {\n    shutdown = true;\n    backupManager.stop();\n    if (channel != null) {\n      try {\n        channel.close().await(10, TimeUnit.SECONDS);\n      } catch (Exception e) {\n        logger.warn(\"Closing backup server failed.\", e);\n      }\n    }\n    ExecutorServiceManager.shutdownAndAwaitTermination(executor, \"BackupServer\");\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.DatagramSocketChannel;\nimport io.netty.handler.codec DatagramDecoder;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class BackupServer implements AutoCloseable {\n    private final CommonParameter commonParameter;\n    private final int port;\n    private final BackupManager backupManager;\n    private Channel channel;\n    private boolean shutdown;\n    private ExecutorService executor;\n\n    public BackupServer(BackupManager backupManager) {\n        this.commonParameter = new CommonParameter();\n        this.port = 9999;\n        this.backupManager = backupManager;\n        this.shutdown = false;\n        this.executor = Executors.newCachedThreadPool();\n    }\n\n    public void initServer() {\n        if (!shutdown) {\n            executor.execute(this::start);\n        }\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(DatagramSocketChannel.class)\n                    .handler(new ChannelInitializer<DatagramChannel>() {\n                        @Override\n                        protected void initChannel(DatagramChannel ch) {\n                            ch.pipeline().addLast(new DatagramDecoder());\n                            ch.pipeline().addLast(new BackupServerHandler(backupManager));\n                        }\n                    });\n\n            channel = bootstrap.bind(port).sync().channel();\n            System.out.println(\"UDP server started on port \" + port);\n        } catch (Exception e) {\n            throw new Exception(\"Failed to start UDP server\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (!shutdown) {\n            shutdown = true;\n            if (channel != null) {\n                channel.closeFuture().await();\n            }\n            executor.shutdownNow();\n        }\n    }\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework, with support for multiple transport types (NIO, Epoll, KQueue, IOUring) and graceful shutdown capabilities.\n\nClass Description: GeyserServer is a Netty-based UDP server implementation that handles network communication using the most optimal transport available on the system. It manages server lifecycle including binding to ports and graceful shutdown.\n\nAttributes:\n- TRANSPORT: [Transport] - Static final field holding the best available transport type\n- SHUTDOWN_QUIET_PERIOD_MS: [int] - Milliseconds to wait for quiet period during shutdown\n- SHUTDOWN_TIMEOUT_MS: [int] - Maximum milliseconds to wait for shutdown\n- geyser: [GeyserImpl] - Reference to the main Geyser implementation\n- group: [EventLoopGroup] - Parent event loop group for the server\n- childGroup: [EventLoopGroup] - Child event loop group for handling connections\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- playerGroup: [EventLoopGroup] - Event loop group for player connections\n- bootstrapFutures: [ChannelFuture[]] - Array of channel futures for server binding\n\nMethods:\n- GeyserServer([GeyserImpl geyser, int threadCount]) -> [void] - Constructor that initializes the server with specified thread count\n- bind([InetSocketAddress address]) -> [CompletableFuture<Void>] - Binds the server to the specified address and returns a future\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- createBootstrap() -> [ServerBootstrap] - Private method that creates and configures the server bootstrap\n- compatibleTransport() -> [Transport] - Static private method that detects the best available transport\n- isClassAvailable([String className]) -> [boolean] - Static private helper method to check class availability\n\nNested Types:\n- Transport: [record] - Holds transport-specific channel class and event loop group factory",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.kqueue.KQueue;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.kqueue.KQueueEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUring;\nimport io.netty.incubator.channel.uring.IOUringDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUringEventLoopGroup;\nimport io.netty.util.concurrent.Future;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.IntFunction;\n\npublic final class GeyserServer {\n    private static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 100;\n    private static final int SHUTDOWN_TIMEOUT_MS = 500;\n\n    private final GeyserImpl geyser;\n    private EventLoopGroup group;\n    private EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private EventLoopGroup playerGroup;\n    private ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.eventLoopGroupFactory().apply(1);\n        this.childGroup = TRANSPORT.eventLoopGroupFactory().apply(threadCount);\n        this.bootstrap = this.createBootstrap();\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        bootstrapFutures = new ChannelFuture[1];\n        ChannelFuture future = bootstrap.bind(address);\n        bootstrapFutures[0] = future;\n        return Bootstraps.allOf(bootstrapFutures);\n    }\n\n    public void shutdown() {\n        try {\n            Future<?> futureChildGroup = this.childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.childGroup = null;\n            Future<?> futureGroup = this.group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.group = null;\n            Future<?> futurePlayerGroup = this.playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.playerGroup = null;\n\n            futureChildGroup.sync();\n            futureGroup.sync();\n            futurePlayerGroup.sync();\n        } catch (InterruptedException e) {\n            GeyserImpl.getInstance().getLogger().severe(\"Exception in shutdown process\", e);\n        }\n        for (ChannelFuture f : bootstrapFutures) {\n            f.channel().closeFuture().syncUninterruptibly();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        GeyserServerInitializer serverInitializer = new GeyserServerInitializer(this.geyser);\n        playerGroup = serverInitializer.getEventLoopGroup();\n\n        return new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(TRANSPORT.datagramChannel()))\n                .group(group, childGroup)\n                .childHandler(serverInitializer);\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.incubator.channel.uring.IOUring\")\n                && IOUring.isAvailable()\n                && Boolean.parseBoolean(System.getProperty(\"Geyser.io_uring\"))) {\n            return new Transport(IOUringDatagramChannel.class, IOUringEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\") && Epoll.isAvailable()) {\n            return new Transport(EpollDatagramChannel.class, EpollEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\") && KQueue.isAvailable()) {\n            return new Transport(KQueueDatagramChannel.class, KQueueEventLoopGroup::new);\n        }\n\n        return new Transport(NioDatagramChannel.class, NioEventLoopGroup::new);\n    }\n\n    private record Transport(Class<? extends DatagramChannel> datagramChannel, IntFunction<EventLoopGroup> eventLoopGroupFactory) {\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "record Transport(Class<?> channelClass, Function<EventLoopGroup, EventLoopGroup> groupFactory) {}\n\nfinal class GeyserServer {\n    static final Transport TRANSPORT;\n    static final int SHUTDOWN_QUIET_PERIOD_MS = 5000;\n    static final int SHUTDOWN_TIMEOUT_MS = 30000;\n    final GeyserImpl geyser;\n    final EventLoopGroup group;\n    final EventLoopGroup childGroup;\n    final ServerBootstrap bootstrap;\n    final EventLoopGroup playerGroup;\n    final ChannelFuture[] bootstrapFutures;\n\n    static {\n        TRANSPORT = compatibleTransport();\n    }\n\n    GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = new EpollEventLoopGroup(threadCount);\n        this.childGroup = new EpollEventLoopGroup(1);\n        this.playerGroup = new EpollEventLoopGroup(1);\n        this.bootstrap = createBootstrap();\n        this.bootstrapFutures = new ChannelFuture[1];\n    }\n\n    CompletableFuture<Void> bind(InetSocketAddress address) {\n        return bootstrap.bind(address).thenApply(future -> {\n            bootstrapFutures[0] = future;\n            return future;\n        });\n    }\n\n    void shutdown() {\n        bootstrap.close().awaitUninterruptibly();\n        group.shutdownGracefully();\n        childGroup.shutdownGracefully();\n        playerGroup.shutdownGracefully();\n    }\n\n    private ServerBootstrap createBootstrap() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group)\n                 .channel(TRANSPORT.channelClass)\n                 .childHandler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) {\n                         ch.pipeline().addLast(new UdpServerHandler(geyser));\n                     }\n                 })\n                 .childOption(ChannelOption.AUTO_READ, true)\n                 .childOption(ChannelOption.SO_REUSEADDR, true)\n                 .childOption(ChannelOption.SO_BINDANY, true);\n        return bootstrap;\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.channel.epoll.EpollServerBootstrap\")) {\n            return new Transport(EpollServerBootstrap.class, EpollEventLoopGroup::new);\n        } else if (isClassAvailable(\"io.netty.channel.kqueue.KQueueServerBootstrap\")) {\n            return new Transport(KQueueServerBootstrap.class, KQueueEventLoopGroup::new);\n        } else if (isClassAvailable(\"io.netty.channel.nio.NioServerBootstrap\")) {\n            return new Transport(NioServerBootstrap.class, NioEventLoopGroup::new);\n        } else if (isClassAvailable(\"io.netty.channel.udt.UdtServerBootstrap\")) {\n            return new Transport(UdtServerBootstrap.class, UdtEventLoopGroup::new);\n        } else if (isClassAvailable(\"io.netty.channel.iovring.IOUringServerBootstrap\")) {\n            return new Transport(IOUringServerBootstrap.class, IOUringEventLoopGroup::new);\n        } else {\n            throw new IllegalStateException(\"No compatible transport found\");\n        }\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.TimeUnit;\n\npublic class WidgetUtil {\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n    private static final HttpClient CLIENT = HttpClient.newHttpClient();\n\n    public WidgetUtil() {\n    }\n\n    public Widget getWidget(long guildId) throws RateLimitedException, UncheckedIOException {\n        String url = String.format(WIDGET_URL, guildId);\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .GET()\n                .build();\n\n        try {\n            HttpResponse<String> response = CLIENT.send(request, HttpResponse.BodyHandlers.ofString());\n            int statusCode = response.statusCode();\n\n            if (statusCode == 200) {\n                return new Widget(response.body());\n            } else if (statusCode == 404) {\n                return null;\n            } else if (statusCode == 403) {\n                return null;\n            } else if (statusCode == 429) {\n                throw new RateLimitedException(\"Rate limited by Discord API\");\n            } else {\n                throw new UncheckedIOException(new IOException(\"Failed to retrieve widget: \" + statusCode));\n            }\n        } catch (IOException | InterruptedException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpClient {\n    private final OkHttpClient httpClient;\n    private final OkHttpClient httpClientDoH;\n    private final OkHttpClient httpClientWithCache;\n    private final OkHttpClient httpClientWithCacheDoH;\n    private final FallBackDNS fallbackDNS;\n    private final boolean doh;\n\n    public HttpClient(FallBackDNS fallbackDNS, boolean doh) {\n        this.fallbackDNS = fallbackDNS;\n        this.doh = doh;\n\n        // Initialize HTTP clients with timeout, proxy, and DNS setup\n        httpClient = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n\n        httpClientDoH = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n\n        httpClientWithCache = new OkHttpClient.Builder()\n                .cache(new okhttp3.Cache(getCacheDirectory(), 10 * 1024 * 1024)) // 10MB cache\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n\n        httpClientWithCacheDoH = new OkHttpClient.Builder()\n                .cache(new okhttp3.Cache(getCacheDirectory(), 10 * 1024 * 1024)) // 10MB cache\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static java.io.File getCacheDirectory() {\n        return new java.io.File(java.io.File.getExternalStoragePublicDirectory(null), \"http_cache\");\n    }\n\n    public OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        OkHttpClient client = getHttpClientWithCache();\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            return response.body().bytes();\n        }\n    }\n\n    public byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        OkHttpClient client = getHttpClientWithCache();\n        RequestBody body = JsonRequestBody.create(data);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            return response.body().bytes();\n        }\n    }\n\n    public OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        if (followRedirects) {\n            builder.followRedirects(true);\n        } else {\n            builder.followRedirects(false);\n        }\n        return builder;\n    }\n\n    public void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        // Implementation for checking captcha requirement\n    }\n\n    public static class JsonRequestBody implements RequestBody {\n        private final String json;\n\n        public static JsonRequestBody create(String json) {\n            return new JsonRequestBody(json);\n        }\n\n        private JsonRequestBody(String json) {\n            this.json = json;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return MediaType.get(\"application/json; charset=utf-8\");\n        }\n\n        @Override\n        public long contentLength() throws IOException {\n            return json.getBytes().length;\n        }\n\n        @Override\n        public void write(okhttp3.BufferedSink sink) throws IOException {\n            sink.writeUtf8(json);\n        }\n    }\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.util.Map;\nimport org.apache.hadoop.conf.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper;\n    private String kmsToken;\n    private Configuration hadoopConfiguration;\n    private String endPointPrefix;\n    private OkHttpClient httpClient;\n\n    public VaultClient(Configuration hadoopConfiguration, String endPointPrefix, OkHttpClient httpClient, ObjectMapper objectMapper) {\n        this.hadoopConfiguration = hadoopConfiguration;\n        this.endPointPrefix = endPointPrefix;\n        this.httpClient = httpClient;\n        this.objectMapper = objectMapper;\n    }\n\n    public String getContentFromTransitEngine(String path, String masterKey, String payload) throws IOException {\n        String url = endPointPrefix + path;\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .post(RequestBody.create(payload, JSON_MEDIA_TYPE))\n                .addHeader(\"X-Vault-Token\", kmsToken);\n\n        Request request = requestBuilder.build();\n        Response response = executeAndGetResponse(\"GET\", request);\n        return parseReturn(response.body().string(), masterKey);\n    }\n\n    private String executeAndGetResponse(String method, Request request) throws IOException {\n        try {\n            Response response = httpClient.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response.code());\n            }\n            return response.body().string();\n        } catch (IOException e) {\n            LOG.error(\"Error executing HTTP request: \", e);\n            throw e;\n        }\n    }\n\n    private String buildPayload(Map<String, String> parameters) {\n        try {\n            return objectMapper.writeValueAsString(parameters);\n        } catch (Exception e) {\n            LOG.error(\"Error building JSON payload: \", e);\n            return \"{}\";\n        }\n    }\n\n    public String wrapKey(byte[] keyData, String masterKey) throws IOException {\n        Map<String, String> payload = Map.of(\"key\", byteToHex(keyData), \"master_key_id\", masterKey);\n        String jsonPayload = buildPayload(payload);\n        String result = getContentFromTransitEngine(\"/v1/transit/encrypt\", masterKey, jsonPayload);\n        return result;\n    }\n\n    public byte[] unwrapKey(String encryptedData, String masterKey) throws IOException {\n        Map<String, String> payload = Map.of(\"ciphertext\", encryptedData, \"master_key_id\", masterKey);\n        String jsonPayload = buildPayload(payload);\n        String result = getContentFromTransitEngine(\"/v1/transit/decrypt\", masterKey, jsonPayload);\n        return hexToBytes(result);\n    }\n\n    private String parseReturn(String response, String masterKey) {\n        try {\n            // Assuming the response contains a 'data' field with the result\n            return objectMapper.readTree(response).get(\"data\").get(\"plaintext\").asText();\n        } catch (Exception e) {\n            LOG.error(\"Error parsing response: \", e);\n            return \"\";\n        }\n    }\n\n    private String byteToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte b : bytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    private byte[] hexToBytes(String hexString) {\n        int len = hexString.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));\n        }\n        return data;\n    }\n\n    public void refreshToken() {\n        // Implementation not shown in reference code\n    }\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.IOException;\nimport java.util.Optional;\n\npublic class BeaconClient {\n    private final int port;\n    private final String token;\n\n    public BeaconClient(int port, String token) {\n        this.port = port;\n        this.token = token;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) throws IOException {\n        String url = \"http://localhost:\" + port + \"/api/\" + rawNode;\n        HttpPost httpPost = new HttpPost(url);\n        httpPost.setHeader(\"Content-Type\", \"application/json\");\n        if (token != null) {\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + token);\n        }\n        String json = prov.toJson();\n        httpPost.setEntity(new StringEntity(json));\n        CloseableHttpClient client = HttpClients.createDefault();\n        HttpResponse<String> response = sendRequest(client, httpPost);\n        if (response.getStatusLine().getStatusCode() >= 400) {\n            if (response.getStatusLine().getStatusCode() >= 400 && response.getStatusLine().getStatusCode() < 500) {\n                return parseClientError(response).orElse(null);\n            } else {\n                return parseServerError(response).orElse(null);\n            }\n        }\n        return deserializeResponse(response);\n    }\n\n    public <REQ, RES> RES performRequest(REQ req) throws IOException {\n        String url = \"http://localhost:\" + port + \"/api/\";\n        HttpPost httpPost = new HttpPost(url);\n        httpPost.setHeader(\"Content-Type\", \"application/json\");\n        if (token != null) {\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + token);\n        }\n        String json = new ObjectMapper().writeValueAsString(req);\n        httpPost.setEntity(new StringEntity(json));\n        CloseableHttpClient client = HttpClients.createDefault();\n        HttpResponse<String> response = sendRequest(client, httpPost);\n        if (response.getStatusLine().getStatusCode() >= 400) {\n            if (response.getStatusLine().getStatusCode() >= 400 && response.getStatusLine().getStatusCode() < 500) {\n                return parseClientError(response).orElse(null);\n            } else {\n                return parseServerError(response).orElse(null);\n            }\n        }\n        return deserializeResponse(response);\n    }\n\n    private HttpResponse<String> sendRequest(CloseableHttpClient client, HttpPost httpPost) throws IOException {\n        return client.execute(httpPost, response -> {\n            int statusCode = response.getStatusLine().getStatusCode();\n            String responseBody = response.getEntity().toString();\n            return new HttpResponse<>(statusCode, responseBody);\n        });\n    }\n\n    private <T> T deserializeResponse(HttpResponse<String> response) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readValue(response.getBody(), (Class<T>) response.getHeaders().get(\"Content-Type\").split(\";\")[0].equals(\"application/json\") ? (Class<T>) Object.class : (Class<T>) String.class);\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            return Optional.of(mapper.readValue(response.getBody(), BeaconClientErrorResponse.class));\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            return Optional.of(mapper.readValue(response.getBody(), BeaconServerErrorResponse.class));\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n    }\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.graphhopper.routing.util.GHGeocodingRequest;\nimport com.graphhopper.routing.util.GHGeocodingResponse;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.google.gson.JsonObject;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class GraphHopperGeocoding {\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key;\n    private static final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this.routeServiceUrl = \"https://graphhopper.com/api/1/geocode\";\n        this.downloader = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS).build();\n        this.objectMapper = new ObjectMapper();\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        this.downloader = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, java.util.concurrent.TimeUnit.MILLISECONDS).build();\n        this.objectMapper = new ObjectMapper();\n    }\n\n    public GraphHopperGeocoding geocode(GHGeocodingRequest request) throws IOException {\n        String url = buildUrl(request);\n        Request requestObj = new Request.Builder().url(url).build();\n        Response response = downloader.newCall(requestObj).execute();\n        if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n        String responseData = response.body().string();\n        GHGeocodingResponse responseObj = objectMapper.readValue(responseData, GHGeocodingResponse.class);\n        return this;\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    public OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        return downloader;\n    }\n\n    public String buildUrl(GHGeocodingRequest request) throws IOException {\n        StringBuilder url = new StringBuilder(routeServiceUrl);\n        url.append(\"?q=\");\n        url.append(encodeURL(request.getQuery()));\n        url.append(\"&limit=\");\n        url.append(request.getLimit());\n        url.append(\"&key=\");\n        url.append(key);\n        return url.toString();\n    }\n\n    private String encodeURL(String str) throws IOException {\n        return URLEncoder.encode(str, StandardCharsets.UTF_8.toString());\n    }\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONObject;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class DanbooruApiClient {\n    private String DOMAIN = \"danbooru.donmai.us\";\n    private OkHttpClient client;\n    private Pattern gidPattern;\n    private int currentPageNum;\n\n    public DanbooruApiClient() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n        gidPattern = Pattern.compile(\"/posts/(\\\\d+)\");\n        currentPageNum = 1;\n    }\n\n    public JSONObject getPage(int pageNum) throws Exception {\n        currentPageNum = pageNum;\n        String url = \"https://\" + DOMAIN + \"/posts.json?limit=50&page=\" + pageNum;\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new Exception(\"Request failed: \" + response.code());\n            return new JSONObject(response.body().string());\n        }\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            String fileUrl = post.getString(\"file_url\");\n            if (!fileUrl.isEmpty()) {\n                urls.add(fileUrl);\n            }\n        }\n        return urls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        String path = url.getPath();\n        if (path.matches(\"/posts/\\\\d+\")) {\n            return gidPattern.matcher(path).replaceAll(\"$1\");\n        } else if (path.matches(\"/posts/\\\\d+/\\\\d+\")) {\n            return gidPattern.matcher(path).replaceAll(\"$1\");\n        } else {\n            throw new MalformedURLException(\"Invalid URL format for Danbooru\");\n        }\n    }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.net.URL;\nimport java.util.regex.Pattern;\n\npublic class TerminologyServiceClient {\n    private final OkHttpClient client;\n    private final UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient() {\n        this.client = new OkHttpClient();\n        this.urlValidator = new UrlValidator();\n        this.expandBaseUrl = \"https://fhir.hl7.org/r4/ValueSet/$expand\";\n    }\n\n    public void setBaseUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            throw new IllegalArgumentException(\"Base URL cannot be null or empty\");\n        }\n        if (!urlValidator.isValid(url)) {\n            throw new IllegalArgumentException(\"Invalid URL format: \" + url);\n        }\n        this.expandBaseUrl = url + \"/$expand\";\n    }\n\n    public Response expandValueSet(String valueSetUri) throws Exception {\n        if (valueSetUri == null || valueSetUri.isEmpty()) {\n            throw new IllegalArgumentException(\"Value set URI cannot be null or empty\");\n        }\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid Value Set URI format: \" + valueSetUri);\n        }\n\n        String requestUrl = expandBaseUrl + \"?url=\" + valueSetUri;\n        Request request = new Request.Builder()\n                .url(requestUrl)\n                .build();\n\n        return client.newCall(request).execute();\n    }\n\n    private static class UrlValidator {\n        private static final Pattern VALID_URL_PATTERN = Pattern.compile(\n                \"^(https?://)?\" + // http or https\n                \"[\\\\w.-]+(\\\\.[\\\\w.-]+)+\" + // domain name\n                \"(\\\\/[$\\\\w.-]*)*\" + // path\n                \"(\\\\?[\\\\w.-]*)?\" + // query string\n                \"(#[\\\\w.-]*)?$\", // fragment\n                Pattern.CASE_INSENSITIVE);\n\n        public boolean isValid(String url) {\n            try {\n                new URL(url);\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using OkHttp library, supporting GET and POST methods with configurable headers, parameters, and retry mechanism.\n\nClass Description: HttpUtil is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests with support for headers, query parameters, and form parameters. The class includes built-in timeout settings and a retry mechanism for failed requests.\n\nAttributes:\n- QUESTION_SEPARATE: String - Constant for URL question mark separator\n- PARAM_SEPARATE: String - Constant for URL parameter separator\n- KV_SEPARATE: String - Constant for key-value separator in URLs\n- client: OkHttpClient - Pre-configured HTTP client instance with timeout settings\n\nMethods:\n- doGet(String url) -> Resp - Executes a GET request to the specified URL\n- doGetWithHeader(String url, Map<String, String> headers) -> Resp - Executes a GET request with custom headers\n- doGet(String url, Map<String, String> params) -> Resp - Executes a GET request with URL parameters\n- doPost(String url) -> Resp - Executes a POST request to the specified URL\n- doPost(String url, Map<String, String> params) -> Resp - Executes a POST request with form parameters\n- executeRequest(Request request, int retryTime) -> Resp - Internal method to execute requests with retry logic\n- bodyToString(ResponseBody body) -> String - Helper method to convert response body to string\n\nNested Class: Resp\n- Description: Represents the HTTP response with status code, body, and optional message\n- Attributes:\n  - code: int - HTTP status code\n  - body: String - Response body content\n  - message: String - Optional message (used for errors)\n- Methods:\n  - builder() -> RespBuilder - Creates a new RespBuilder instance\n  - getCode() -> int - Returns the status code\n  - getBody() -> String - Returns the response body\n  - getMessage() -> String - Returns the message\n\nNested Class: RespBuilder\n- Description: Builder pattern implementation for constructing Resp objects\n- Methods:\n  - code(int code) -> RespBuilder - Sets the status code\n  - body(String body) -> RespBuilder - Sets the response body\n  - message(String message) -> RespBuilder - Sets the message\n  - build() -> Resp - Constructs the Resp object",
    "Canonical_solution": "import okhttp3.*;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUtil {\n\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n\n    private static final OkHttpClient client = new OkHttpClient().newBuilder()\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().get().url(url).build());\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        final Request.Builder builder = new Request.Builder().get().url(url);\n        if (MapUtils.isNotEmpty(headers)) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build());\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder builder = new StringBuilder(url);\n        if (!StringUtils.contains(url, QUESTION_SEPARATE)) {\n            builder.append(QUESTION_SEPARATE).append(\"_r=1\");\n        }\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.append(PARAM_SEPARATE)\n                        .append(entry.getKey())\n                        .append(KV_SEPARATE)\n                        .append(entry.getValue());\n            }\n        }\n        return doGet(builder.toString());\n    }\n\n    public static Resp doPost(String url) {\n        return doPost(url, null);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder builder = new FormBody.Builder();\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = new Request.Builder().post(builder.build()).url(url).build();\n        return executeRequest(request);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        try {\n            Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return Resp.builder().code(response.code())\n                        .body(bodyToString(response.body())).build();\n            }\n            if (--retryTime > 0) {\n                TimeUnit.MILLISECONDS.sleep(100);\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(response.code())\n                    .body(bodyToString(response.body()))\n                    .message(\"Invoke failed, status code is not 200\")\n                    .build();\n        } catch (Exception e) {\n            if (--retryTime > 0) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e1) {\n                    // ignore\n                }\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(500)\n                    .message(\"Invoke occurred exception, request=\" + request.toString() + \";message=\" + e.getMessage())\n                    .build();\n        }\n    }\n\n    private static String bodyToString(ResponseBody body) throws IOException {\n        return body == null ? \"\" : body.string();\n    }\n\n    public static class Resp {\n        private int code;\n        private String body;\n        private String message;\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n\n        Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class HttpUtil {\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n    private static final OkHttpClient client = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().url(url).get().build(), 3);\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url).get();\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(requestBuilder.build(), 3);\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder sb = new StringBuilder(url);\n        if (params != null && !params.isEmpty()) {\n            sb.append(QUESTION_SEPARATE);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                sb.append(entry.getKey()).append(KV_SEPARATE).append(entry.getValue()).append(PARAM_SEPARATE);\n            }\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return executeRequest(new Request.Builder().url(sb.toString()).get().build(), 3);\n    }\n\n    public static Resp doPost(String url) {\n        return executeRequest(new Request.Builder().url(url).post(RequestBody.create(\"\", MediaType.get(\"application/json; charset=utf-8\"))).build(), 3);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder formBuilder = new FormBody.Builder();\n        if (params != null && !params.isEmpty()) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                formBuilder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(new Request.Builder().url(url).post(formBuilder.build()).build(), 3);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        int retryCount = 0;\n        while (retryCount < retryTime) {\n            try {\n                Response response = client.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    return new Resp(response.code(), response.body().string(), null);\n                } else {\n                    return new Resp(response.code(), response.body().string(), \"Server error: \" + response.code());\n                }\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount < retryTime) {\n                    continue;\n                } else {\n                    return new Resp(-1, \"Request failed after \" + retryTime + \" retries\", e.getMessage());\n                }\n            }\n        }\n        return new Resp(-1, \"Request failed after \" + retryTime + \" retries\", null);\n    }\n\n    private static String bodyToString(ResponseBody body) {\n        return body.string();\n    }\n\n    public static class Resp {\n        private final int code;\n        private final String body;\n        private final String message;\n\n        public Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public Resp builder() {\n            return new RespBuilder(this);\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Create a Java class for HTTP downloading with support for multi-threaded downloads, range requests, and connection pooling.\n\nClass Description: HttpDownloader is a Java class that extends InputStream to provide HTTP downloading capabilities. It supports multi-threaded downloads, range requests, connection pooling, and retry mechanisms. The class manages download tasks through a thread pool and handles response streaming efficiently.\n\nAttributes:\n\ncontentType: String - MIME type of the downloaded content\ncontentLength: long - Total size of the content being downloaded\ncontentEnd: long - Ending byte position for downloads\nheader: Headers - HTTP response headers\nstatusCode: int - HTTP status code\ndirectUrl: String - Final URL after redirects\ncurConnId: volatile static int - Connection counter\nclosed: volatile boolean - Flag indicating if downloader is closed\nconnId: int - Current connection ID\nis: InputStream - Current input stream\ncallableQueue: Queue<Callable<InputStream>> - Queue of download tasks\nfutureQueue: Queue<Future<InputStream>> - Queue of future results\ndownloaderMap: static HashMap<String, HttpDownloader> - Cache of active downloaders\nexecutorService: ExecutorService - Thread pool for download tasks\nsupportRange: boolean - Flag for server range support\nblockSize: int - Size of each download block (default 10MB)\nthreadNum: int - Number of download threads (default 2)\ncookie: String - Cookie header value\nreferer: String - Referer header value\nblockCounter: int - Counter for downloaded blocks\ndownloadClient: OkHttpClient - Custom HTTP client for downloads\ndefaultClient: OkHttpClient - Default HTTP client configuration\n\nMethods:\n\nHttpDownloader(Map<String, String> params) - Constructor - Initializes downloader with configuration parameters\ncreateDownloadTask(String url, Map<String, String> headers) - void - Creates download tasks based on range and thread configuration\ndownloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Performs actual HTTP download\n_downloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Internal download implementation\nread(byte[] buffer, int off, int len) -> int - Reads data from download stream\nread() -> int - Throws IOException (not implemented)\nclose() - void - Cleans up resources and stops downloads\nrunTask(int num) - void - Starts specified number of download tasks",
    "Canonical_solution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.Callable;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Dispatcher;\nimport okhttp3.FormBody;\nimport okhttp3.RequestBody;\nimport okhttp3.Request;\nimport okhttp3.Headers;\nimport okhttp3.Response;\nimport okhttp3.Call;\nimport org.json.JSONObject;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType = \"\";\n    public long contentLength = -1;\n    long contentEnd;\n    public Headers header;\n    public int statusCode = 200;\n    String directUrl = null;\n    volatile static int curConnId = 0;\n    volatile boolean closed = false;\n    int connId;\n    InputStream is = null;\n    Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    ExecutorService executorService = Executors.newFixedThreadPool(128);\n    boolean supportRange = true;\n    int blockSize = 10 * 1024 * 1024;\n    int threadNum = 2;\n    String cookie = null;\n    String referer = null;\n    int blockCounter = 0;\n    OkHttpClient downloadClient = null;\n    OkHttpClient defaultClient = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .hostnameVerifier((hostname, session) -> true)\n        .sslSocketFactory(new MySSLCompat(), MySSLCompat.TM)\n        .build();\n\n    public HttpDownloader(Map<String, String> params) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setMaxRequests(3000000);\n        dispatcher.setMaxRequestsPerHost(1000000);\n        downloadClient = defaultClient.newBuilder()\n            .dispatcher(dispatcher)\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(3, TimeUnit.SECONDS)\n            .writeTimeout(3, TimeUnit.SECONDS)\n            .build();\n        \n        connId = curConnId++;\n        String url = params.get(\"url\");\n        downloaderMap.entrySet().removeIf(entry -> entry.getValue().closed);\n        HttpDownloader cacheDownloader = downloaderMap.get(url);\n        if (cacheDownloader != null) {\n            cacheDownloader.close();\n        }\n        downloaderMap.put(url, this);\n\n        if(params.get(\"thread\") != null){\n            threadNum = Integer.parseInt(params.get(\"thread\"));\n        }\n        if(params.get(\"size\") != null){\n            blockSize = Integer.parseInt(params.get(\"size\"));\n        }\n        if(params.get(\"cookie\") != null){\n            cookie = params.get(\"cookie\");\n        }\n\n        Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<String> keys = Arrays.asList(\"referer\", \"icy-metadata\", \"range\", \"connection\", \"accept-encoding\", \"user-agent\", \"cookie\", \"authorization\");\n        for (String key : params.keySet()) if (keys.contains(key)) headers.put(key, params.get(key));\n        if(url.contains(\"\u5938\u514b\")) {\n            headers.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) quark-cloud-drive/2.5.20 Chrome/100.0.4896.160 Electron/18.3.5.4-b478491100 Safari/537.36 Channel/pckk_other_ch\");\n        }\n        String range = \"\";\n        if (params.get(\"range\") != null) {\n            range = params.get(\"range\");\n        }\n        this.getHeader(url, headers);\n        this.createDownloadTask(directUrl, headers);\n    }\n\n    private void createDownloadTask(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        \n        if(!this.supportRange || threadNum == 0) {\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, \"\", 0);\n            };\n            callableQueue.add(callable);\n            return;\n        }\n        \n        long start = 0; \n        long end = this.contentEnd;\n        String range = request.headers().get(\"Range\");\n        range = range == null ? \"0-\" : range;\n        range = range + \"-\" + this.contentEnd;\n        range = range.replace(\"--\", \"-\");\n        String pattern = \"bytes=(\\\\d+)-(\\\\d+)\";\n        Pattern r = Pattern.compile(pattern);\n        Matcher m = r.matcher(range);\n        if (m.find()) {\n            String startString = m.group(1); \n            String endString = m.group(2);\n            start = Long.parseLong(startString); \n            end = Long.parseLong(endString);\n        }\n\n        int sliceNum = 0;\n        while (start <= end) {\n            long curEnd = start + blockSize - 1;\n            curEnd = curEnd > end ? end : curEnd;\n            String ra = \"bytes=\" + start + \"-\" + curEnd;\n            final int _sliceNum = sliceNum;\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, ra, _sliceNum);\n            };\n            callableQueue.add(callable);\n            start = curEnd + 1;\n            sliceNum++;\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url,headers,range,sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        if(closed){\n            return null;\n        }\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        if (!range.isEmpty()) {\n            requestBuilder.removeHeader(\"Range\").addHeader(\"Range\", range);\n        }\n        if (cookie != null) {\n            requestBuilder.removeHeader(\"Cookie\").addHeader(\"Cookie\", cookie);\n        }\n        if (referer != null) {\n            requestBuilder.removeHeader(\"Referer\").addHeader(\"Referer\", referer);\n        }\n        Request request = requestBuilder.build();\n        int retryCount = 0;\n        int maxRetry = 5;\n        byte[] downloadbBuffer = new byte[1024*1024];\n        Response response = null;\n        Call call = null;\n        boolean directResp = false;\n        while (retryCount < maxRetry && !closed) {\n            try {\n                directResp = false;\n                call = downloadClient.newCall(request);\n                response = call.execute();\n                if (!response.isSuccessful()) {\n                    continue;\n                }\n                if (range.isEmpty()) {\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                if(sliceNum==0){\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int bytesRead;\n                while (!closed && (bytesRead = response.body().byteStream().read(downloadbBuffer)) != -1) {\n                    baos.write(downloadbBuffer, 0, bytesRead);\n                }\n                return new ByteArrayInputStream(baos.toByteArray());\n            } catch (Exception e) {} finally {\n                if(response != null && !directResp){\n                    call.cancel();\n                    response.close();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized int read(byte[] buffer, int off, int len) throws IOException {\n        try {\n            if (closed) {\n                return -1;\n            }\n            \n            if (this.is == null ) {\n                runTask(threadNum < 1 ? 1 : threadNum);\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n            }\n            int ol = this.is.read(buffer, off, len);\n            if ( ol == -1 ) {\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n                return this.is.read(buffer, off, len);\n            } \n            return ol;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"\u65b9\u6cd5\u672a\u5b9e\u73b0\uff0c\u4e0d\u80fd\u8c03\u7528\uff01\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        if(this.executorService != null) {\n            this.executorService.shutdownNow();\n        }\n        futureQueue.clear();\n        callableQueue.clear();\n    }\n\n    private void runTask(int num) {\n        while(num-- > 0 && callableQueue.size() > 0) {\n            Future<InputStream> future = this.executorService.submit(callableQueue.remove());\n            this.futureQueue.add(future);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.InputStream;\nimport java.util.concurrent.*;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport okhttp3.*;\n\npublic class HttpDownloader extends InputStream {\n    private String contentType;\n    private long contentLength;\n    private long contentEnd;\n    private Headers header;\n    private int statusCode;\n    private String directUrl;\n    private volatile static int curConnId = 0;\n    private volatile boolean closed = false;\n    private int connId;\n    private InputStream is;\n    private Queue<Callable<InputStream>> callableQueue;\n    private Queue<Future<InputStream>> futureQueue;\n    private static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    private ExecutorService executorService;\n    private boolean supportRange;\n    private int blockSize = 10 * 1024 * 1024;\n    private int threadNum = 2;\n    private String cookie;\n    private String referer;\n    private int blockCounter = 0;\n    private OkHttpClient downloadClient;\n    private OkHttpClient defaultClient;\n\n    public HttpDownloader(Map<String, String> params) {\n        this.cookie = params.get(\"cookie\");\n        this.referer = params.get(\"referer\");\n        this.downloadClient = new OkHttpClient.Builder()\n                .cookieJar(new CookieJar() {\n                    @Override\n                    public void saveFromResponse(OkHttpClient client, Response response, String key, List<String> values) {\n                        // Save cookies from response\n                    }\n\n                    @Override\n                    public List<String> loadForRequest(OkHttpClient client, Request request, String key) {\n                        // Load cookies for request\n                        return null;\n                    }\n                })\n                .build();\n        this.defaultClient = new OkHttpClient();\n    }\n\n    public void createDownloadTask(String url, Map<String, String> headers) {\n        // Create download tasks based on range and thread configuration\n    }\n\n    public InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) throws IOException {\n        // Performs actual HTTP download\n        return null;\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) throws IOException {\n        // Internal download implementation\n        return null;\n    }\n\n    @Override\n    public int read(byte[] buffer, int off, int len) throws IOException {\n        // Reads data from download stream\n        return 0;\n    }\n\n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"Not implemented\");\n    }\n\n    public void close() {\n        // Cleans up resources and stops downloads\n    }\n\n    public void runTask(int num) {\n        // Starts specified number of download tasks\n    }\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a Java class that processes large files efficiently using memory-mapped file I/O operations through FileChannel and MappedByteBuffer.\n\nClass Description: FileChannelProcessor is a utility class designed to handle large file processing by mapping portions of a file into memory buffers. It reads files in chunks (up to 500MB each) and ensures each chunk ends at a line boundary for proper text processing.\n\nAttributes:\n- BUFFER_SIZE: int - Constant defining the maximum size (500MB) for each memory-mapped buffer\n- channel: FileChannel - The file channel used for file operations\n- buffers: List<Buffer> - List of buffers containing mapped portions of the file\n\nMethods:\n- FileChannelProcessor(Path filePath) -> void - Constructor that initializes the FileChannel by opening the specified file\n- createBuffers() -> List<Buffer> - Creates memory-mapped buffers for the file, ensuring each buffer ends at a line boundary\n- close() -> void - Closes the FileChannel to release system resources\n\nNested Record:\n- Buffer(ByteBuffer byteBuffer, int length) - A record holding a ByteBuffer and its effective length (up to the last newline character)",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.nio.channels.FileChannel.MapMode.READ_ONLY;\n\npublic class FileChannelProcessor {\n    private static final int BUFFER_SIZE = (1 << 29); // 500mb\n    private final FileChannel channel;\n    private final List<Buffer> buffers = new ArrayList<>();\n\n    public FileChannelProcessor(Path filePath) throws Exception {\n        this.channel = FileChannel.open(filePath);\n    }\n\n    public List<Buffer> createBuffers() throws Exception {\n        long size = channel.size();\n        int lastByte;\n        for (long offset = 0; offset < size; offset += lastByte + 1) {\n            long sizeToMap = Math.min(size - offset, BUFFER_SIZE);\n            MappedByteBuffer buffer = channel.map(READ_ONLY, offset, sizeToMap);\n            lastByte = (int) sizeToMap - 1;\n            while (buffer.get(lastByte) != '\\n')\n                --lastByte;\n            buffers.add(new Buffer(buffer, lastByte + 1));\n        }\n        return buffers;\n    }\n\n    public void close() throws Exception {\n        channel.close();\n    }\n\n    public record Buffer(ByteBuffer byteBuffer, int length) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nrecord Buffer(ByteBuffer byteBuffer, int length) {}\n\npublic class FileChannelProcessor {\n    private static final int BUFFER_SIZE = 500 * 1024 * 1024; // 500MB\n    private final FileChannel channel;\n    private final List<Buffer> buffers;\n\n    public FileChannelProcessor(Path filePath) throws IOException {\n        this.channel = FileChannel.open(filePath, java.nio.file.StandardOpenOption.READ);\n        this.buffers = new ArrayList<>();\n        createBuffers();\n    }\n\n    public List<Buffer> createBuffers() throws IOException {\n        long fileSize = channel.size();\n        long position = 0;\n\n        while (position < fileSize) {\n            long endPosition = Math.min(position + BUFFER_SIZE, fileSize);\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, position, endPosition - position);\n            int length = findLineEnd(buffer);\n            buffers.add(new Buffer(buffer, length));\n            position = endPosition;\n        }\n\n        return buffers;\n    }\n\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private int findLineEnd(MappedByteBuffer buffer) {\n        int length = buffer.remaining();\n        int lineEnd = 0;\n\n        while (lineEnd < length && buffer.get(lineEnd) != '\\n') {\n            lineEnd++;\n        }\n\n        return lineEnd;\n    }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "```java\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.core ExecutionContext;\nimport org.springframework.batch.core.StepExecution;\nimport org.springframework.batch.core.annotation.AfterReading;\nimport org.springframework.batch.core.annotation.BeforeRead;\nimport org.springframework.batch.core.annotation.OnSkip;\nimport org.springframework.batch.core.step.skip.SkipLimitExceededException;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.kafka.annotation.KafkaListener;\nimport org.springframework.kafka.config.AbstractKafkaConfiguration;\nimport org.springframework.kafka.core.ConsumerFactory;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.kafka.listener.ContainerProperties;\nimport org.springframework.kafka.listener.KafkaMessageListenerContainer;\nimport org.springframework.kafka.listener.MessageListener;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\n\nimport java.time.Duration;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n@Component\npublic class KafkaItemReader<K, V> implements ItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topicPartitionOffsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n    private List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout;\n    private boolean saveState;\n\n    public KafkaItemReader(Properties properties, String topic, Integer... partitions) {\n        this.consumerProperties = new Properties(properties);\n        this.topicPartitions = new ArrayList<>();\n        if (partitions != null && partitions.length > 0) {\n            for (Integer partition : partitions) {\n                topicPartitions.add(new TopicPartition(topic, partition));\n            }\n        }\n        this.pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n        initialize();\n    }\n\n    public KafkaItemReader(Properties properties, String topic, List<Integer> partitions) {\n        this.consumerProperties = new Properties(properties);\n        this.topicPartitions = new ArrayList<>();\n        if (partitions != null && !partitions.isEmpty()) {\n            for (Integer partition : partitions) {\n                topicPartitions.add(new TopicPartition(topic, partition));\n            }\n        }\n        this.pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n        initialize();\n    }\n\n    private void initialize() {\n        kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n        kafkaConsumer.assign(topicPartitions);\n        partitionOffsets = new HashMap<>();\n        for (TopicPartition partition : topicPartitions) {\n            partitionOffsets.put(partition, 0L);\n        }\n        consumerRecords = kafkaConsumer.records().iterator();\n    }\n\n    @BeforeRead\n    public void open(ExecutionContext executionContext) {\n        if (executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            partitionOffsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n        }\n        kafkaConsumer.seekToBeginning(topicPartitions);\n    }\n\n    @Override\n    public V read() throws Exception {\n        if (!consumerRecords.hasNext()) {\n            return null;\n        }\n        ConsumerRecord<K, V> record = consumerRecords.next();\n        return record.value();\n    }\n\n    @AfterReading\n    public void update(ExecutionContext executionContext) {\n        if (saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, partitionOffsets);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (kafkaConsumer != null) {\n            kafkaConsumer.close();\n        }\n    }\n\n    @OnSkip(limit = \"100\")\n    public void onSkip(Throwable t, StepExecution stepExecution) {\n        throw new SkipLimitExceededException(\"Maximum number of skipped records reached\");\n    }\n}\n```"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "public class KafkaStoreReaderThread implements Runnable {\n    private final String topic;\n    private final TopicPartition topicPartition;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n    private final ReentrantLock offsetUpdateLock = new ReentrantLock();\n    private final Condition offsetReachedThreshold = offsetUpdateLock.newCondition();\n    private final Consumer<byte[], byte[]> consumer;\n    private final long offsetInSchemasTopic;\n    private final Properties consumerProps;\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) {\n        this.topic = topic;\n        this.topicPartition = new TopicPartition(topic, 0);\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n        this.consumerProps = new Properties();\n        this.consumerProps.put(\"bootstrap.servers\", bootstrapBrokers);\n        this.consumerProps.put(\"group.id\", groupId);\n        this.consumerProps.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        this.consumerProps.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        this.consumerProps.put(\"auto.offset.reset\", \"earliest\");\n        this.consumerProps.put(\"enable.auto.commit\", \"false\");\n        this.consumer = new KafkaConsumer<>(consumerProps);\n        this.consumer.subscribe(Collections.singletonList(topic));\n    }\n\n    @Override\n    public void run() {\n        doWork();\n    }\n\n    private void doWork() {\n        while (true) {\n            try {\n                ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(100));\n                for (ConsumerRecord<byte[], byte[]> record : records) {\n                    K key = serializer.deserialize(record.key());\n                    V value = serializer.deserialize(record.value());\n                    if (storeUpdateHandler.validate(key, value)) {\n                        localStore.update(key, value);\n                        offsetInSchemasTopic++;\n                    }\n                }\n                consumer.commitAsync();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void shutdown() {\n        consumer.close();\n    }\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a Kafka producer wrapper class in Java that simplifies sending JSON data to Kafka topics.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for producing messages to Kafka topics. It handles producer creation, message serialization, and error handling internally.\n\nAttributes:\n- kafkaProducer: Producer<Long, String> - The underlying Kafka producer instance\n- kafkaBrokers: String - Comma-separated list of Kafka broker addresses\n- gson: Gson - JSON serializer/deserializer instance\n\nMethods:\n- createKafkaProducer() -> Producer<Long, String> - Creates and configures a new Kafka producer instance with the specified broker addresses and serializers\n- send2Kafka(JsonElement jsonElement, String topicName) -> void - Serializes the JSON element and sends it to the specified Kafka topic\n- close() -> void - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\n\npublic class KafkaProducerWrapper {\n\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson = new Gson();\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, Launcher.getInstanceId());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 10000);\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName,\n                gson.toJson(jsonElement));\n        try {\n            kafkaProducer.send(record).get();\n        } \n        catch (ExecutionException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n        } catch (InterruptedException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport com.google.gson.Gson;\nimport java.util.Properties;\n\npublic class KafkaProducerWrapper {\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson;\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.gson = new Gson();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.Serdes$LongSerializer\");\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringSerializer\");\n        return new Producer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        if (kafkaProducer == null) {\n            kafkaProducer = createKafkaProducer();\n        }\n        String jsonStr = gson.toJson(jsonElement);\n        kafkaProducer.send(new org.apache.kafka.clients.producer.RecordMetadata(topicName, jsonStr));\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.common.serialization.Bytes;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport org.apache.flink.api.common.functions.FlatMapFunction;\nimport org.apache.flink.api.common.state.StateTtlConfig;\nimport org.apache.flink.api.java.tuple.Tuple2;\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.Sink;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api.functions.sink.SinkFunction;\nimport org.apache.flink.streaming.api"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class KafkaSampleProducer {\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(10);\n    private boolean _shutdown;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, ?> config, String producerClientId) {\n        if (_producer != null) {\n            throw new IllegalStateException(\"Producer already created\");\n        }\n\n        Map<String, Object> props = new HashMap<>(config);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n\n        _producer = new Producer<>(props);\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log) {\n        if (_producer == null) {\n            throw new IllegalStateException(\"Producer not created\");\n        }\n\n        if (producer != _producer) {\n            throw new IllegalArgumentException(\"Producer does not match the one created\");\n        }\n\n        AtomicInteger sentCount = new AtomicInteger(0);\n        for (Map.Entry<String, List<Metrics>> entry : samples.getPartitions().entrySet()) {\n            String partition = entry.getKey();\n            List<Metrics> metrics = entry.getValue();\n\n            for (Metrics metric : metrics) {\n                try {\n                    byte[] key = partition.getBytes();\n                    byte[] value = metric.toByteArray();\n                    producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, key, value));\n                    sentCount.incrementAndGet();\n                } catch (Exception e) {\n                    log.error(\"Failed to send metric sample for partition {}\", partition, e);\n                }\n            }\n        }\n        return sentCount;\n    }\n\n    public void close() {\n        if (!_shutdown) {\n            _shutdown = true;\n            try {\n                _producer.close(PRODUCER_CLOSE_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.common.metrics.MetricName;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.util.concurrent.CompletableFuture;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic class KafkaTemplate<K, V> {\n    private final ProducerFactory<K, V> producerFactory;\n    private boolean autoFlush;\n    private boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this.producerFactory = producerFactory;\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return doSend(new ProducerRecord<>(topic, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        try {\n            return producer.send(producerRecord);\n        } finally {\n            if (autoFlush) {\n                producer.flush();\n            }\n        }\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        return producerFactory.getProducer().partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        return producerFactory.getProducer().metrics();\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.getProducer();\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return producerFactory.getProducer();\n    }\n\n    public boolean inTransaction() {\n        return transactional;\n    }\n}\n```"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class JobPrefixFile implements AutoCloseable {\n    private final String prefix;\n    private final Path file;\n    private final FileChannel channel;\n    private final FileLock lock;\n\n    public JobPrefixFile(String prefix, Path directory) throws IOException {\n        this.prefix = prefix;\n        this.file = directory.resolve(prefix + \".tmp\");\n        this.channel = Files.newByteChannel(file, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n        this.lock = channel.lock();\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return new JobPrefixFile(\"job\", directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        return new JobPrefixFile(prefix, directory);\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        if (Files.exists(file)) {\n            try (JobPrefixFile jobPrefixFile = new JobPrefixFile(\"\", file.getParent())) {\n                jobPrefixFile.release();\n                return jobPrefixFile;\n            }\n        }\n        return null;\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() throws IOException {\n        if (lock != null) {\n            lock.release();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        release();\n    }\n\n    public void delete() throws IOException {\n        deleteIfExists(file);\n    }\n\n    private void deleteIfExists(Path file) throws IOException {\n        if (Files.exists(file)) {\n            Files.delete(file);\n        }\n    }\n\n    public static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.*;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\");\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        ProducerRecord<String, String> record = new ProducerRecord<>(topic, maintenancePlan.toString());\n        try {\n            _producer.send(record, (metadata, exception) -> {\n                if (exception == null) {\n                    System.out.println(\"Message sent successfully: \" + metadata.topic() + \", partition: \" + metadata.partition() + \", offset: \" + metadata.offset());\n                } else {\n                    System.err.println(\"Failed to send message: \" + exception.getMessage());\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        if (_producer != null) {\n            _producer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.FutureAndMetadata;\n\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        producer = new Producer<>(configs);\n        producer.setDefaultKeySerializer(keySerializer);\n        producer.setDefaultValueSerializer(valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout.toMillis(), TimeUnit.MILLISECONDS);\n    }\n}\n```"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Implement a Java class that handles asynchronous socket connections using Java NIO (Non-blocking I/O) to manage incoming connections for a high-availability service. The class should be abstract, allowing subclasses to define specific connection handling logic.\n\nClass Description: AcceptSocketService is an abstract class that extends ServiceThread to provide a non-blocking socket server implementation. It manages incoming socket connections using ServerSocketChannel and Selector, delegating the creation of specific connection handlers to subclasses through an abstract method. The class handles the lifecycle of the server socket, including startup, connection acceptance, and shutdown.\n\nAttributes:\n- socketAddressListen: [SocketAddress] - The address and port to listen for incoming connections\n- serverSocketChannel: [ServerSocketChannel] - The server socket channel for accepting connections\n- selector: [Selector] - The selector for managing multiple non-blocking channels\n- messageStoreConfig: [MessageStoreConfig] - Configuration object containing server settings\n- log: [Logger] - Logger instance for recording events and errors\n\nMethods:\n- AcceptSocketService([MessageStoreConfig messageStoreConfig]) -> [void] - Constructor that initializes the service with configuration\n- beginAccept() -> [void] - Initializes and starts the server socket channel and selector\n- shutdown([boolean interrupt]) -> [void] - Shuts down the service and cleans up resources\n- run() -> [void] - Main service loop that handles incoming connections (inherited from ServiceThread)\n- createConnection([SocketChannel sc]) -> [HAConnection] - Abstract method to be implemented by subclasses for creating connection handlers",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.config.MessageStoreConfig;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\n\nprotected abstract class AcceptSocketService extends ServiceThread {\n    private final SocketAddress socketAddressListen;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private final MessageStoreConfig messageStoreConfig;\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);\n\n    public AcceptSocketService(final MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = new InetSocketAddress(messageStoreConfig.getHaListenPort());\n    }\n\n    public void beginAccept() throws Exception {\n        this.serverSocketChannel = ServerSocketChannel.open();\n        this.selector = NetworkUtil.openSelector();\n        this.serverSocketChannel.socket().setReuseAddress(true);\n        this.serverSocketChannel.socket().bind(this.socketAddressListen);\n        if (0 == messageStoreConfig.getHaListenPort()) {\n            messageStoreConfig.setHaListenPort(this.serverSocketChannel.socket().getLocalPort());\n            log.info(\"OS picked up {} to listen for HA\", messageStoreConfig.getHaListenPort());\n        }\n        this.serverSocketChannel.configureBlocking(false);\n        this.serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void shutdown(final boolean interrupt) {\n        super.shutdown(interrupt);\n        try {\n            if (null != this.serverSocketChannel) {\n                this.serverSocketChannel.close();\n            }\n            if (null != this.selector) {\n                this.selector.close();\n            }\n        } catch (IOException e) {\n            log.error(\"AcceptSocketService shutdown exception\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(this.getServiceName() + \" service started\");\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                Set<SelectionKey> selected = this.selector.selectedKeys();\n                if (selected != null) {\n                    for (SelectionKey k : selected) {\n                        if (k.isAcceptable()) {\n                            SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n                            if (sc != null) {\n                                log.info(\"HAService receive new connection, \" + sc.socket().getRemoteSocketAddress());\n                                try {\n                                    HAConnection conn = createConnection(sc);\n                                    conn.start();\n                                } catch (Exception e) {\n                                    log.error(\"new HAConnection exception\", e);\n                                    sc.close();\n                                }\n                            }\n                        } else {\n                            log.warn(\"Unexpected ops in select \" + k.readyOps());\n                        }\n                    }\n                    selected.clear();\n                }\n            } catch (Exception e) {\n                log.error(this.getServiceName() + \" service has exception.\", e);\n            }\n        }\n        log.info(this.getServiceName() + \" service end\");\n    }\n\n    protected abstract HAConnection createConnection(final SocketChannel sc) throws IOException;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "wrong_result": "abstract class AcceptSocketService extends ServiceThread {\n    protected final SocketAddress socketAddressListen;\n    protected final ServerSocketChannel serverSocketChannel;\n    protected final Selector selector;\n    protected final MessageStoreConfig messageStoreConfig;\n    protected final Logger log;\n\n    public AcceptSocketService(MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = messageStoreConfig.getSocketAddress();\n        this.log = LoggerFactory.getLogger(AcceptSocketService.class);\n        try {\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.configureBlocking(false);\n            serverSocketChannel.bind(socketAddressListen);\n            selector = Selector.open();\n        } catch (IOException e) {\n            log.error(\"Failed to initialize server socket channel\", e);\n            throw new RuntimeException(\"Failed to initialize server socket channel\", e);\n        }\n    }\n\n    public void beginAccept() {\n        try {\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            log.info(\"Server started on {}\", socketAddressListen);\n        } catch (IOException e) {\n            log.error(\"Failed to register server socket channel with selector\", e);\n            throw new RuntimeException(\"Failed to register server socket channel with selector\", e);\n        }\n    }\n\n    public void shutdown(boolean interrupt) {\n        try {\n            if (serverSocketChannel != null) {\n                serverSocketChannel.close();\n            }\n            if (selector != null) {\n                selector.close();\n            }\n            if (interrupt) {\n                Thread.currentThread().interrupt();\n            }\n            log.info(\"Server shut down\");\n        } catch (IOException e) {\n            log.error(\"Failed to shut down server\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!isShutdown()) {\n                if (selector.selectNow() < 0) {\n                    continue;\n                }\n                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    keys.remove();\n                    if (key.isAcceptable()) {\n                        SocketChannel clientSocket = serverSocketChannel.accept();\n                        if (clientSocket != null) {\n                            HAConnection connection = createConnection(clientSocket);\n                            if (connection != null) {\n                                connection.start();\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            log.error(\"Error in service loop\", e);\n        } finally {\n            shutdown(true);\n        }\n    }\n\n    public abstract HAConnection createConnection(SocketChannel sc);\n}"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, supporting SSL/TLS encryption and providing methods for server startup and shutdown.\n\nClass Description: BaseHttp2Server is an abstract class that serves as a foundation for building HTTP/2 servers using Netty. It handles SSL/TLS configuration, channel management, and provides basic server lifecycle methods. Concrete implementations must define their own request handlers.\n\nAttributes:\n- sslContext: [SslContext] - SSL/TLS context for secure connections\n- hasReleasedSslContext: [AtomicBoolean] - Tracks whether SSL context resources have been released\n- bootstrap: [ServerBootstrap] - Netty server bootstrap configuration\n- shouldShutDownEventLoopGroup: [boolean] - Flag indicating whether to shutdown event loop group\n- allChannels: [ChannelGroup] - Tracks all active server channels\n\nMethods:\n- BaseHttp2Server([SslContext], [EventLoopGroup]) -> [void] - Constructor that initializes the server with SSL context and optional event loop group\n- addHandlersToPipeline([SSLSession], [ChannelPipeline]) -> [void] - Abstract method to be implemented by subclasses for adding custom handlers to the pipeline\n- start([int]) -> [CompletableFuture<Integer>] - Starts the server on specified port and returns future with bound port number\n- shutdown() -> [CompletableFuture<Void>] - Gracefully shuts down the server and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Future;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLSession;\n\nabstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    BaseHttp2Server(final SslContext sslContext, final EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n\n        if (this.sslContext instanceof ReferenceCounted) {\n            ((ReferenceCounted) this.sslContext).retain();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n\n        if (eventLoopGroup != null) {\n            this.bootstrap.group(eventLoopGroup);\n            this.shouldShutDownEventLoopGroup = false;\n        } else {\n            this.bootstrap.group(new NioEventLoopGroup(1));\n            this.shouldShutDownEventLoopGroup = true;\n        }\n\n        this.allChannels = new DefaultChannelGroup(this.bootstrap.config().group().next());\n\n        this.bootstrap.channel(ServerChannelClassUtil.getServerSocketChannelClass(this.bootstrap.config().group()));\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(final SocketChannel channel) {\n                final SslHandler sslHandler = sslContext.newHandler(channel.alloc());\n                channel.pipeline().addLast(sslHandler);\n\n                sslHandler.handshakeFuture().addListener(handshakeFuture -> {\n                    if (handshakeFuture.isSuccess()) {\n                        BaseHttp2Server.this.addHandlersToPipeline(sslHandler.engine().getSession(), channel.pipeline());\n                        BaseHttp2Server.this.allChannels.add(channel);\n                    }\n                });\n            }\n        });\n    }\n\n    protected abstract void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception;\n\n    public CompletableFuture<Integer> start(final int port) {\n        final ChannelFuture channelFuture = this.bootstrap.bind(port);\n        this.allChannels.add(channelFuture.channel());\n\n        final CompletableFuture<Integer> startFuture = new CompletableFuture<>();\n\n        channelFuture.addListener((future -> {\n            if (future.isSuccess()) {\n                startFuture.complete(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n            } else {\n                startFuture.completeExceptionally(future.cause());\n            }\n        }));\n\n        return startFuture;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>();\n        final Future<Void> channelCloseFuture = this.allChannels.close();\n\n        if (this.shouldShutDownEventLoopGroup) {\n            channelCloseFuture.addListener(future ->\n                    BaseHttp2Server.this.bootstrap.config().group().shutdownGracefully());\n\n            this.bootstrap.config().group().terminationFuture().addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            channelCloseFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        }\n\n        return shutdownFuture.thenRun(() -> {\n            if (BaseHttp2Server.this.sslContext instanceof ReferenceCounted) {\n                if (BaseHttp2Server.this.hasReleasedSslContext.compareAndSet(false, true)) {\n                    ((ReferenceCounted) BaseHttp2Server.this.sslContext).release();\n                }\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.Promise;\nimport io.netty.util.concurrent.ScheduledExecutorService;\nimport io.netty.util.concurrent.SingleThreadEventExecutor;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic abstract class BaseHttp2Server {\n    protected final SslContext sslContext;\n    protected final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    protected final ServerBootstrap bootstrap;\n    protected final boolean shouldShutDownEventLoopGroup;\n    protected final ChannelGroup allChannels;\n\n    protected BaseHttp2Server(SslContext sslContext, EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(eventLoopGroup);\n        this.bootstrap.channel(NioServerSocketChannel.class);\n        this.shouldShutDownEventLoopGroup = false;\n        this.allChannels = new ChannelGroup();\n    }\n\n    protected abstract void addHandlersToPipeline(SSLSession session, ChannelPipeline pipeline);\n\n    public CompletableFuture<Integer> start(int port) {\n        return new CompletableFuture<Integer>() {\n            @Override\n            public void complete(Integer result) {\n                if (result != null) {\n                    BaseHttp2Server.this.port = result;\n                }\n            }\n\n            @Override\n            public void completeExceptionally(Throwable ex) {\n                // Handle exception\n            }\n        };\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        return new CompletableFuture<Void>() {\n            @Override\n            public void complete(Void result) {\n                if (shouldShutDownEventLoopGroup) {\n                    bootstrap.config().group().shutdownGracefully();\n                }\n                if (!hasReleasedSslContext.get()) {\n                    sslContext.close();\n                    hasReleasedSslContext.set(true);\n                }\n            }\n\n            @Override\n            public void completeExceptionally(Throwable ex) {\n                // Handle exception\n            }\n        };\n    }\n\n    private int port;\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.apache.commons.lang3.time.StopWatch;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class RpcServer {\n    protected final Logger logger;\n    protected final ServerBootstrap bootstrap;\n    protected final ChannelFuture channelFuture;\n    protected final ConcurrentHashMap<String, UserProcessor<?>> userProcessors;\n    protected final EventLoopGroup bossGroup;\n    protected final EventLoopGroup workerGroup;\n    protected final RemotingAddressParser addressParser;\n    protected final DefaultServerConnectionManager connectionManager;\n    protected final RpcRemoting rpcRemoting;\n    protected final Codec codec;\n\n    protected RpcServer(int port, boolean manageConnection) {\n        this.logger = Logger.getLogger(RpcServer.class.getName());\n        this.bootstrap = new ServerBootstrap();\n        this.channelFuture = null;\n        this.userProcessors = new ConcurrentHashMap<>();\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.addressParser = new RemotingAddressParser();\n        this.connectionManager = new DefaultServerConnectionManager();\n        this.rpcRemoting = new RpcRemoting();\n        this.codec = new Codec();\n    }\n\n    protected void doInit() {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(codec);\n                        ch.pipeline().addLast(rpcRemoting);\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .childOption(ChannelOption.SO_REUSEADDR, true);\n    }\n\n    protected boolean doStart() {\n        try {\n            doInit();\n            channelFuture = bootstrap.bind(getPort()).sync();\n            logger.info(\"RpcServer started on port \" + getPort());\n            return true;\n        } catch (Exception e) {\n            logger.severe(\"Failed to start RpcServer: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    protected boolean doStop() {\n        try {\n            if (channelFuture != null && channelFuture.isDone()) {\n                channelFuture.channel().close().sync();\n            }\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            logger.info(\"RpcServer stopped\");\n            return true;\n        } catch (Exception e) {\n            logger.severe(\"Failed to stop RpcServer: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    protected void registerUserProcessor(UserProcessor<?> processor) {\n        userProcessors.put(processor.getType(), processor);\n    }\n\n    protected Object invokeSync(Connection conn, Object request, int timeoutMillis) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        try {\n            return rpcRemoting.invokeSync(conn, request, timeoutMillis);\n        } catch (Exception e) {\n            logger.severe(\"RPC call failed: \" + e.getMessage());\n            return null;\n        } finally {\n            stopWatch.stop();\n            logger.fine(\"RPC call took \" + stopWatch.getTime(TimeUnit.MILLISECONDS) + \" ms\");\n        }\n    }\n\n    protected abstract int getPort();\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a Java class that provides a fluent interface for building and executing command-line processes with configurable environment variables, working directory, and output handling.\n\nClass Description: The CommandLine class is a builder-style utility for executing external processes. It allows chaining configuration methods to set up command arguments, environment variables, working directory, and output streams before execution. The class handles process execution, stream management, and result collection.\n\nAttributes:\n- cmdLine: List<String> - Stores the command and its arguments\n- env: Map<String, String> - Stores environment variables for the process\n- cleanEnvironment: boolean - Flag to determine whether to clear existing environment variables\n- workingDirectory: File - The working directory for the process\n- outPrefix: String - Prefix for standard output lines\n- errPrefix: String - Prefix for error output lines\n- out: OutputStream - Stream for standard output\n- err: OutputStream - Stream for error output\n\nMethods:\n- cmd(String): CommandLine - Static factory method to create a new CommandLine instance with initial command\n- workingDirectory(File): CommandLine - Sets the working directory using File object\n- workingDirectory(String): CommandLine - Sets the working directory using path string\n- arg(String): CommandLine - Adds a single argument to the command\n- args(String...): CommandLine - Adds multiple arguments to the command\n- outPrefix(String): CommandLine - Sets prefix for standard output\n- errPrefix(String): CommandLine - Sets prefix for error output\n- out(OutputStream): CommandLine - Sets standard output stream\n- err(OutputStream): CommandLine - Sets error output stream\n- env(String, String): CommandLine - Adds an environment variable\n- newEnv(boolean): CommandLine - Configures whether to clean environment variables\n- run(): ProcessRunner.ProcessResult - Executes the configured command and returns the result",
    "Canonical_solution": "import jodd.io.StreamGobbler;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommandLine {\n\n    public static final int OK = 0;\n\n    protected final List<String> cmdLine = new ArrayList<>();\n    protected Map<String, String> env = null;\n    protected boolean cleanEnvironment = false;\n    protected File workingDirectory;\n    protected String outPrefix;\n    protected String errPrefix;\n    protected OutputStream out = System.out;\n    protected OutputStream err = System.err;\n\n    protected CommandLine(final String command) {\n        cmdLine.add(command);\n    }\n\n    public static CommandLine cmd(final String command) {\n        return new CommandLine(command);\n    }\n\n    public CommandLine workingDirectory(final File workDirectory) {\n        this.workingDirectory = workDirectory;\n        return this;\n    }\n\n    public CommandLine workingDirectory(final String workDirectory) {\n        this.workingDirectory = new File(workDirectory);\n        return this;\n    }\n\n    public CommandLine arg(final String argument) {\n        cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(final String... arguments) {\n        if (arguments != null && arguments.length > 0) {\n            Collections.addAll(cmdLine, arguments);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(final String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(final String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(final OutputStream out) {\n        this.out = out;\n        return this;\n    }\n\n    public CommandLine err(final OutputStream err) {\n        this.err = err;\n        return this;\n    }\n\n    public CommandLine env(final String key, final String value) {\n        if (env == null) {\n            env = new HashMap<>();\n        }\n        env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(final boolean clean) {\n        cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        out = err = baos;\n\n        try {\n            baos.write(StringUtil.join(cmdLine, ' ').getBytes());\n            baos.write(StringPool.BYTES_NEW_LINE);\n        }\n        catch (IOException ignore) {\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(cmdLine);\n\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n\n        processBuilder.directory(workingDirectory);\n\n        Process process = null;\n        try {\n            process = processBuilder.start();\n        }\n        catch (IOException ioex) {\n            return writeException(baos, ioex);\n        }\n\n        StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix);\n        StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix);\n\n        outputGobbler.start();\n        errorGobbler.start();\n\n        int result;\n        try {\n            result = process.waitFor();\n        }\n        catch (InterruptedException iex) {\n            return writeException(baos, iex);\n        }\n\n        outputGobbler.waitFor();\n        errorGobbler.waitFor();\n\n        return new ProcessRunner.ProcessResult(result, baos.toString());\n    }\n\n    private ProcessRunner.ProcessResult writeException(final ByteArrayOutputStream baos, final Exception ex) {\n        try {\n            baos.write(errPrefix.getBytes());\n        }\n        catch (IOException ignore) {\n        }\n\n        ex.printStackTrace(new PrintStream(baos));\n        return new ProcessRunner.ProcessResult(-1, baos.toString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.File;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommandLine {\n    private final List<String> cmdLine = new ArrayList<>();\n    private final Map<String, String> env = new HashMap<>();\n    private boolean cleanEnvironment = false;\n    private File workingDirectory;\n    private String outPrefix = \"\";\n    private String errPrefix = \"\";\n    private OutputStream out;\n    private OutputStream err;\n\n    public static CommandLine cmd(String command) {\n        return new CommandLine().cmdLine(command);\n    }\n\n    public CommandLine cmdLine(String command) {\n        this.cmdLine.clear();\n        this.cmdLine.add(command);\n        return this;\n    }\n\n    public CommandLine workingDirectory(File dir) {\n        this.workingDirectory = dir;\n        return this;\n    }\n\n    public CommandLine workingDirectory(String path) {\n        this.workingDirectory = new File(path);\n        return this;\n    }\n\n    public CommandLine arg(String argument) {\n        this.cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(String... arguments) {\n        for (String arg : arguments) {\n            this.cmdLine.add(arg);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(OutputStream stream) {\n        this.out = stream;\n        return this;\n    }\n\n    public CommandLine err(OutputStream stream) {\n        this.err = stream;\n        return this;\n    }\n\n    public CommandLine env(String key, String value) {\n        if (cleanEnvironment) {\n            this.env.clear();\n        }\n        this.env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(boolean clean) {\n        this.cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() throws Exception {\n        return ProcessRunner.run(this);\n    }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public String deobfuscateStackTrace(Throwable t) {\n    try {\n        if (!canDeobfuscate()) {\n            return t.toString();\n        }\n        \n        String mappingFile = System.getenv(\"XPIPE_MAPPING\");\n        if (mappingFile == null || mappingFile.isEmpty()) {\n            return t.toString();\n        }\n        \n        String stackTrace = t.getStackTrace().toString();\n        String tempInputFile = System.getProperty(\"java.io.tmpdir\") + \"/stacktrace.txt\";\n        String tempOutputFile = System.getProperty(\"java.io.tmpdir\") + \"/deobfuscated_stacktrace.txt\";\n        \n        try (FileWriter writer = new FileWriter(tempInputFile)) {\n            writer.write(stackTrace);\n        }\n        \n        ProcessBuilder pb = new ProcessBuilder();\n        if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n            pb.command(\"retrace.bat\", tempInputFile, tempOutputFile, mappingFile);\n        } else {\n            pb.command(\"retrace.sh\", tempInputFile, tempOutputFile, mappingFile);\n        }\n        \n        Process process = pb.start();\n        int exitCode = process.waitFor();\n        \n        if (exitCode == 0) {\n            try (BufferedReader reader = new BufferedReader(new FileReader(tempOutputFile))) {\n                StringBuilder output = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                }\n                return output.toString();\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    \n    return t.toString();\n}"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nclass ProcessRunner {\n    private final File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n\n        AsyncPipe asyncPipe = new AsyncPipe(process.getErrorStream(), process.getInputStream());\n        asyncPipe.start();\n\n        try {\n            process.waitFor();\n        } finally {\n            asyncPipe.interrupt();\n            process.destroy();\n        }\n    }\n\n    private class AsyncPipe extends Thread {\n        private final InputStream inputStream;\n        private final OutputStream outputStream;\n        private final boolean closeStreams;\n        private final AtomicBoolean running = new AtomicBoolean(true);\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.inputStream = is;\n            this.outputStream = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n                String line;\n                while (running.get() && (line = reader.readLine()) != null) {\n                    try {\n                        outputStream.write(line.getBytes());\n                        outputStream.newLine();\n                        outputStream.flush();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        inputStream.close();\n                        outputStream.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n\n        public void interrupt() {\n            running.set(false);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.*;\n\nabstract class Reader {\n    abstract int read(char[] buffer, int offset, int count) throws IOException;\n    abstract void close() throws IOException;\n}\n\nclass FileReader extends Reader {\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        try {\n            File fileObj = new File(file);\n            if (fileObj.exists() && fileObj.canRead()) {\n                mStream = new InputStreamReader(new FileInputStream(fileObj));\n            } else {\n                mStream = executeSystemCommand(shell, file);\n            }\n        } catch (Exception e) {\n            throw new FileNotFoundException(\"File not found or inaccessible: \" + file);\n        }\n    }\n\n    private InputStreamReader executeSystemCommand(Shell shell, String file) throws IOException {\n        ProcessBuilder pb = new ProcessBuilder(\"su\", \"cat\", file);\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        InputStream inputStream = process.getInputStream();\n        return new InputStreamReader(inputStream);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}\n\ninterface Shell {\n    ProcessBuilder getProcessBuilder(String... args);\n}\n```"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessShell extends AbstractShell {\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n    public void init(String initialCommand) {\n        try {\n            mProcess = Runtime.getRuntime().exec(initialCommand);\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n            mSucceedOutput = new StringBuilder();\n            mErrorOutput = new StringBuilder();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.write((command + \"\\n\").getBytes());\n            mCommandOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exit() {\n        try {\n            mCommandOutputStream.write(\"exit\\n\".getBytes());\n            mCommandOutputStream.flush();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        exit();\n        try {\n            mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public ProcessShell readAll() {\n        try {\n            String line;\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        try {\n            String line;\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        try {\n            String line;\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a Java class that manages external processes, handling their input/output streams and providing control over process execution, including starting, stopping, and monitoring.\n\nClass Description: The DaemonHandler class is designed to manage external processes executed via ProcessBuilder. It provides functionality to start processes with either delimited or undelimited output handling, stop processes (either gracefully or forcibly), and retrieve process exit codes. The class maintains separate threads for handling standard output and error streams, with output being captured and placed into a shared blocking deque.\n\nAttributes:\n- processBuilder: ProcessBuilder - Configures and starts external processes\n- process: Process - Represents the currently running external process\n- outThread: Thread - Thread handling standard output stream\n- errThread: Thread - Thread handling error output stream\n- errProxy: OutputProxy - Proxy for handling error stream output\n- outProxy: OutputProxy - Proxy for handling standard output stream\n- deque: BlockingDeque<Event> - Shared queue for process output events\n- stdOut: boolean - Flag indicating whether to capture standard output\n\nMethods:\n- DaemonHandler(BlockingDeque<Event>, String...) -> void - Constructor that initializes the process handler with output queue and command\n- setStdOutListener(boolean) -> void - Sets whether to capture standard output\n- startDelimited() -> Process - Starts process with delimited output handling (using default delimiter)\n- startDelimited(byte) -> Process - Starts process with custom delimiter for output handling\n- startUndelimited() -> Process - Starts process with undelimited output handling (default buffer size)\n- startUndelimited(int) -> Process - Starts process with undelimited output handling (custom buffer size)\n- stop(boolean) -> void - Stops the managed process (optionally forcibly)\n- getExitCode() -> int - Retrieves the exit code of the process (or PROCESS_STOPPED if not running)",
    "Canonical_solution": "import com.linbit.extproc.OutputProxy.Event;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler\n{\n    public static final int PROCESS_STOPPED = Integer.MAX_VALUE;\n    private static final byte DELIMITER = '\\n';\n\n    private final ProcessBuilder processBuilder;\n    private Process process;\n\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(final BlockingDeque<Event> dequeRef, final String... command)\n    {\n        deque = dequeRef;\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectError(Redirect.PIPE);\n        stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOutRef)\n    {\n        stdOut = stdOutRef;\n    }\n\n    public Process startDelimited() throws IOException\n    {\n        return startDelimited(DELIMITER);\n    }\n\n    public Process startDelimited(byte delimiterRef) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxyDelimited(process.getErrorStream(), deque, delimiterRef, false);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxyDelimited(process.getInputStream(), deque, delimiterRef, true);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException\n    {\n        return startUndelimited(OutputProxy.DFLT_BUFFER_SIZE);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxy(process.getErrorStream(), deque, false, bufferSize);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxy(process.getInputStream(), deque, true, bufferSize);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force)\n    {\n        if (process != null)\n        {\n            if (outProxy != null)\n            {\n                outProxy.expectShutdown();\n            }\n            errProxy.expectShutdown();\n            if (force)\n            {\n                process.destroyForcibly();\n            }\n            else\n            {\n                process.destroy();\n            }\n            if (outThread != null)\n            {\n                outThread.interrupt();\n            }\n            errThread.interrupt();\n            process = null;\n        }\n    }\n\n    public int getExitCode()\n    {\n        int exitValue;\n        Process proc = process;\n        if (proc != null)\n        {\n            if (proc.isAlive())\n            {\n                try\n                {\n                    proc.waitFor(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException ignored)\n                {\n                }\n                if (proc.isAlive())\n                {\n                    throw new ImplementationError(\"Process is still running\");\n                }\n            }\n            exitValue = proc.exitValue();\n        }\n        else\n        {\n            exitValue = PROCESS_STOPPED;\n        }\n        return exitValue;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.*;\n\npublic class DaemonHandler {\n    private final ProcessBuilder processBuilder;\n    private final Process process;\n    private final Thread outThread;\n    private final Thread errThread;\n    private final OutputProxy outProxy;\n    private final OutputProxy errProxy;\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n    private boolean running;\n\n    public DaemonHandler(BlockingDeque<Event> deque, String... command) {\n        this.deque = deque;\n        this.processBuilder = new ProcessBuilder(command);\n        this.process = null;\n        this.outThread = null;\n        this.errThread = null;\n        this.outProxy = new OutputProxy();\n        this.errProxy = new OutputProxy();\n        this.stdOut = false;\n        this.running = false;\n    }\n\n    public void setStdOutListener(boolean stdOut) {\n        this.stdOut = stdOut;\n    }\n\n    public Process startDelimited() {\n        return startDelimited((byte) 0x0A);\n    }\n\n    public Process startDelimited(byte delimiter) {\n        if (process != null) {\n            throw new IllegalStateException(\"Process is already running\");\n        }\n        try {\n            processBuilder.redirectErrorStream(true);\n            process = processBuilder.start();\n            running = true;\n            outThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (stdOut) {\n                            deque.put(new Event(EventType.STDOUT, line));\n                        }\n                    }\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n            errThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        deque.put(new Event(EventType.ERR, line));\n                    }\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n            outThread.start();\n            errThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return process;\n    }\n\n    public Process startUndelimited() {\n        return startUndelimited(1024);\n    }\n\n    public Process startUndelimited(int bufferSize) {\n        if (process != null) {\n            throw new IllegalStateException(\"Process is already running\");\n        }\n        try {\n            processBuilder.redirectErrorStream(true);\n            process = processBuilder.start();\n            running = true;\n            outThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    StringBuilder buffer = new StringBuilder(bufferSize);\n                    char[] buf = new char[bufferSize];\n                    int read;\n                    while ((read = reader.read(buf)) != -1) {\n                        buffer.append(buf, 0, read);\n                        while (buffer.length() > 0 && buffer.charAt(0) == '\\n') {\n                            buffer.deleteCharAt(0);\n                        }\n                        if (stdOut) {\n                            deque.put(new Event(EventType.STDOUT, buffer.toString()));\n                            buffer.setLength(0);\n                        }\n                    }\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n            errThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                    StringBuilder buffer = new StringBuilder(1024);\n                    char[] buf = new char[1024];\n                    int read;\n                    while ((read = reader.read(buf)) != -1) {\n                        buffer.append(buf, 0, read);\n                        while (buffer.length() > 0 && buffer.charAt(0) == '\\n') {\n                            buffer.deleteCharAt(0);\n                        }\n                        deque.put(new Event(EventType.ERR, buffer.toString()));\n                        buffer.setLength(0);\n                    }\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n            outThread.start();\n            errThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return process;\n    }\n\n    public void stop(boolean force) {\n        if (process == null) {\n            throw new IllegalStateException(\"No process is running\");\n        }\n        running = false;\n        if (force) {\n            process.destroyForcibly();\n        } else {\n            process.destroy();\n        }\n    }\n\n    public int getExitCode() {\n        if (!running) {\n            return process.exitValue();\n        }\n        return -1; // PROCESS_STOPPED\n    }\n\n    static class Event {\n        enum EventType { STDOUT, ERR }\n\n        final EventType type;\n        final String data;\n\n        Event(EventType type, String data) {\n            this.type = type;\n            this.data = data;\n        }\n    }\n\n    static class OutputProxy {\n        // Proxy methods can be implemented here if needed\n    }\n}"
  },
  {
    "Task_id": 276,
    "Instruction": "Task Description: Create a Java abstract class that provides functionality for executing external scripts in a cross-platform manner, handling both input and error streams concurrently, and logging the results.\n\nClass Description: AbstractScriptProcessor is an abstract base class designed to execute external scripts (shell scripts for Unix-like systems or batch files for Windows) while properly handling process streams and logging. It uses ProcessBuilder for process creation and ForkJoinPool for concurrent stream handling.\n\nAttributes:\n- POOL: [ForkJoinPool] - A shared thread pool for concurrent stream processing\n- SH_SHELL: [String] - Constant for Unix shell path (/bin/sh)\n- CMD_SHELL: [String] - Constant for Windows command processor (cmd.exe)\n\nMethods:\n- executeScript: [TaskContext context, String scriptPath] -> [ProcessResult] - Executes the specified script file, handles platform compatibility checks, manages process streams, and returns execution results\n- copyStream: [InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset] -> [void] - Helper method to copy stream contents to a StringBuilder while logging\n- getRunCommand: [] -> [String] - Abstract method to be implemented by subclasses to return the appropriate shell command\n- getCharset: [] -> [Charset] - Returns the charset to use for stream processing (defaults to UTF-8)",
    "Canonical_solution": "import tech.powerjob.worker.core.processor.ProcessResult;\nimport tech.powerjob.worker.core.processor.TaskContext;\nimport tech.powerjob.worker.log.OmsLogger;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\n\npublic abstract class AbstractScriptProcessor {\n\n    private static final ForkJoinPool POOL = new ForkJoinPool(4 * Runtime.getRuntime().availableProcessors());\n    protected static final String SH_SHELL = \"/bin/sh\";\n    protected static final String CMD_SHELL = \"cmd.exe\";\n\n    protected ProcessResult executeScript(TaskContext context, String scriptPath) throws Exception {\n        OmsLogger omsLogger = context.getOmsLogger();\n        \n        if (SystemUtils.IS_OS_WINDOWS && StringUtils.equals(getRunCommand(), SH_SHELL)) {\n            String message = String.format(\"[SYSTEM] Current OS is %s where shell scripts cannot run.\", SystemUtils.OS_NAME);\n            omsLogger.warn(message);\n            return new ProcessResult(false, message);\n        }\n\n        ProcessBuilder pb = StringUtils.equals(getRunCommand(), CMD_SHELL) ?\n                new ProcessBuilder(getRunCommand(), \"/c\", scriptPath)\n                : new ProcessBuilder(getRunCommand(), scriptPath);\n        Process process = pb.start();\n\n        StringBuilder inputBuilder = new StringBuilder();\n        StringBuilder errorBuilder = new StringBuilder();\n\n        boolean success = true;\n        String result;\n\n        final Charset charset = getCharset();\n        try {\n            InputStream is = process.getInputStream();\n            InputStream es = process.getErrorStream();\n\n            ForkJoinTask<?> inputSubmit = POOL.submit(() -> copyStream(is, inputBuilder, omsLogger, charset));\n            ForkJoinTask<?> errorSubmit = POOL.submit(() -> copyStream(es, errorBuilder, omsLogger, charset));\n\n            success = process.waitFor() == 0;\n\n            inputSubmit.get();\n            errorSubmit.get();\n\n        } catch (InterruptedException ie) {\n            omsLogger.info(\"[SYSTEM] ScriptProcessor has been interrupted\");\n        } finally {\n            result = String.format(\"[INPUT]: %s;[ERROR]: %s\", inputBuilder, errorBuilder);\n        }\n        return new ProcessResult(success, result);\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset) {\n        String line;\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, charset))) {\n            while ((line = br.readLine()) != null) {\n                sb.append(line).append(System.lineSeparator());\n                omsLogger.info(line);\n            }\n        } catch (Exception e) {\n            omsLogger.warn(\"[SYSTEM] copyStream failed.\", e);\n            sb.append(\"Exception: \").append(e);\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e) {\n                omsLogger.warn(\"[SYSTEM] close stream failed.\", e);\n            }\n        }\n    }\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "abstract class AbstractScriptProcessor {\n    protected static final ForkJoinPool POOL = ForkJoinPool.commonPool();\n    protected static final String SH_SHELL = \"/bin/sh\";\n    protected static final String CMD_SHELL = \"cmd.exe\";\n\n    public ProcessResult executeScript(TaskContext context, String scriptPath) {\n        try {\n            String command = getRunCommand();\n            ProcessBuilder processBuilder = new ProcessBuilder(command, scriptPath);\n            processBuilder.inheritIO();\n            Process process = processBuilder.start();\n\n            StringBuilder stdout = new StringBuilder();\n            StringBuilder stderr = new StringBuilder();\n\n            POOL.submit(() -> copyStream(process.getInputStream(), stdout, context.getLogger(), StandardCharsets.UTF_8));\n            POOL.submit(() -> copyStream(process.getErrorStream(), stderr, context.getLogger(), StandardCharsets.UTF_8));\n\n            int exitCode = process.waitFor();\n            return new ProcessResult(exitCode, stdout.toString(), stderr.toString());\n        } catch (Exception e) {\n            context.getLogger().error(\"Error executing script: \" + e.getMessage(), e);\n            return new ProcessResult(-1, \"\", \"Error: \" + e.getMessage());\n        }\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger logger, Charset charset) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n                logger.info(line);\n            }\n        } catch (IOException e) {\n            logger.error(\"Error reading stream: \" + e.getMessage(), e);\n        }\n    }\n\n    abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n}"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public void testNutReader() throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n    ProcessBuilder pb = new ProcessBuilder(\"ffmpeg\", \"-i\", \"Samples.big_buck_bunny_720p_1mb\", \"-vcodec\", \"rawvideo\", \"-acodec\", \"pcm_s32le\", \"-f\", \"nut\", \"-\");\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n\n    NutReader reader = new NutReader();\n    reader.setStreamHandler((streamType, streamIndex) -> System.out.println(\"Stream: \" + streamType + \" at index \" + streamIndex));\n    reader.setFrameHandler((streamIndex, frame) -> System.out.println(\"Frame from stream \" + streamIndex + \": \" + frame));\n\n    InputStream inputStream = process.getInputStream();\n    byte[] buffer = new byte[4096];\n    int bytesRead;\n    while ((bytesRead = inputStream.read(buffer)) != -1) {\n        inputStream.write(buffer, 0, bytesRead);\n    }\n\n    int exitCode = process.waitFor();\n    if (exitCode != 0) {\n        throw new ExecutionException(\"FFmpeg process failed with exit code \" + exitCode);\n    }\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create utility functions for working with FileChannel in Java NIO to provide OutputStream functionality with optional force-write capability at close.\n\nFunction Description: The provided code consists of three utility functions that work together to create an OutputStream wrapper around a FileChannel, with control over whether changes are forcibly written to disk when closing the stream.\n\nInput:\n1. For newOutputStream:\n   - channel: FileChannel - The FileChannel to wrap with OutputStream functionality\n   - forceAtClose: boolean - Whether to force write changes to disk when closing\n\n2. For newOutputStreamForceAtClose:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\n3. For newFileChannel:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\nOutput:\n1. For newOutputStream: OutputStream - A new OutputStream instance that writes to the provided FileChannel\n2. For newOutputStreamForceAtClose: OutputStream - A new OutputStream instance that forces writes to disk when closed\n3. For newFileChannel: FileChannel - A new FileChannel instance for the specified path with given options",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nstatic OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n    final byte[] single = {0};\n    return new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            single[0] = (byte) b;\n            write(single);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            for(; len > 0; ) {\n                final int written = channel.write(ByteBuffer.wrap(b, off, len));\n                off += written;\n                len -= written;\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            try (FileChannel c = channel) {\n                if (forceAtClose) {\n                    c.force(true);\n                }\n            }\n        }\n    };\n}\n\nstatic OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n    return newOutputStream(newFileChannel(p, options), true);\n}\n\nstatic FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n    return LogUtils.supplyAndLog(LOG,\n        () -> FileChannel.open(p, options),\n        () -> \"FileChannel.open \" + p + \" with options \" + Arrays.asList(options));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Files;\n\npublic class FileChannelOutputStreamUtils {\n\n    public static OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n        return new FileChannelOutputStream(channel, forceAtClose);\n    }\n\n    public static OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) {\n        try {\n            FileChannel channel = Files.newFileChannel(p, options);\n            return newOutputStream(channel, true);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error creating FileChannel\", e);\n        }\n    }\n\n    public static FileChannel newFileChannel(Path p, OpenOption... options) {\n        try {\n            return Files.newFileChannel(p, options);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error creating FileChannel\", e);\n        }\n    }\n\n    private static class FileChannelOutputStream extends OutputStream {\n        private final FileChannel channel;\n        private final boolean forceAtClose;\n\n        public FileChannelOutputStream(FileChannel channel, boolean forceAtClose) {\n            this.channel = channel;\n            this.forceAtClose = forceAtClose;\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            channel.write(java.nio.channels.FileChannel.MapMode.READ_WRITE, 0, 1, new byte[]{(byte) b});\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            channel.write(java.nio.channels.FileChannel.MapMode.READ_WRITE, 0, len, b, off);\n        }\n\n        @Override\n        public void flush() throws IOException {\n            if (forceAtClose) {\n                channel.force(true);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (forceAtClose) {\n                channel.force(true);\n            }\n            channel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Create a function that executes an external process, captures its output (including error streams redirected to standard output), and returns the output as a string.\n\nFunction Description: The function uses Java's ProcessBuilder to start an external process specified by the given command. It redirects the error stream to the standard output stream to capture all output in one place. The function reads the process's output stream line by line, collects it into a string, and waits for the process to complete before returning the collected output.\n\nInput: \n- cmd: String[] - An array of strings representing the command to execute and its arguments.\n\nOutput: \n- String - The combined standard output and error output of the executed process, trimmed of any leading or trailing whitespace.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getProcessOutput(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    StringBuilder processOutput = new StringBuilder();\n    try (BufferedReader processOutputReader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));) {\n        String readLine;\n        while ((readLine = processOutputReader.readLine()) != null) {\n            processOutput.append(readLine + System.lineSeparator());\n        }\n        process.waitFor();\n    }\n    return processOutput.toString().trim();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    public static String executeCommand(String[] cmd) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command execution failed with exit code: \" + exitCode);\n        }\n        return output.toString().trim();\n    }\n}"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a Java function that executes an external process using ProcessBuilder, captures its output, and handles errors appropriately.\n\nFunction Description: The function executes a shell command constructed from configuration parameters, captures the process's standard output and error streams (merged), waits for the process to complete, and returns the exit status or throws an exception if the process fails. The function handles process initialization, stream reading, and error management.\n\nInput:\n- job: Job<Object> - A job object containing configuration details\n- parameters: Map<String, Object> - A map of parameters used to construct the shell command\n\nOutput:\n- Object - Returns 0 if the process exits successfully, otherwise throws a HugeException containing the exit code and process output\n\nNote: The function includes error handling for process initialization, execution, and stream reading, with all exceptions wrapped in HugeException. The process's working directory is set to executeDir(), and error streams are redirected to standard output.",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic Object call(Job<Object> job, Map<String, Object> parameters) {\n    this.checkAndCollectParameters(parameters);\n    try {\n        this.initializeConfig((ComputerJob) job);\n    } catch (Exception e) {\n        throw new HugeException(\n                \"Failed to initialize computer config file\", e);\n    }\n\n    Map<String, Object> configs = new HashMap<>();\n    configs.putAll(this.commonConfig);\n    configs.putAll(this.checkAndCollectParameters(parameters));\n\n    String[] command = this.constructShellCommands(configs);\n    LOG.info(\"Execute computer job: {}\", String.join(SPACE, command));\n\n    try {\n        ProcessBuilder builder = new ProcessBuilder(command);\n        builder.redirectErrorStream(true);\n        builder.directory(new File(executeDir()));\n\n        Process process = builder.start();\n\n        StringBuilder output = new StringBuilder();\n        try (LineNumberReader reader = new LineNumberReader(\n                new InputStreamReader(\n                        process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return 0;\n        }\n\n        throw new HugeException(\"The computer job exit with code %s: %s\",\n                                exitCode, output);\n    } catch (HugeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new HugeException(\"Failed to execute computer job\", e);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public Object executeProcess(Job<Object> job, Map<String, Object> parameters) throws HugeException {\n    String command = buildCommand(parameters);\n    ProcessBuilder pb = new ProcessBuilder(command.split(\" \"));\n    pb.directory(job.executeDir());\n    pb.redirectErrorStream(true);\n    \n    try {\n        Process process = pb.start();\n        \n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        \n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        \n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new HugeException(exitCode, output.toString());\n        }\n        \n        return 0;\n    } catch (IOException | InterruptedException e) {\n        throw new HugeException(-1, \"Process execution failed: \" + e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JavaVersionChecker {\n    public static String getJavaCompilerVersion() {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n            java.io.InputStream inputStream = process.getInputStream();\n            java.util.Scanner scanner = new java.util.Scanner(inputStream);\n            String version = scanner.nextLine();\n            scanner.close();\n            process.waitFor();\n            return version;\n        } catch (Exception e) {\n            return \"unknown\";\n        }\n    }\n}"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private Object mLock = new Object();\n    private boolean mIsActive = false;\n    private boolean mIsRoot = false;\n    private String mCommandEnd = \"exit\";\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String input);\n        void onStreamStop(int exitCode);\n        void onStreamDied();\n    }\n\n    public static class Counter {\n        private int count = 0;\n\n        public int size() {\n            return count;\n        }\n\n        public int increase() {\n            return ++count;\n        }\n\n        public int decrease() {\n            return --count;\n        }\n\n        public void reset() {\n            count = 0;\n        }\n    }\n\n    public ShellStream(boolean requestRoot, OnStreamListener listener) {\n        mIsRoot = requestRoot;\n        mListener = listener;\n        mCounter = new Counter();\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"sh\");\n            if (mIsRoot) {\n                pb.command(\"su\", \"-c\", \"sh\");\n            }\n            mConnection = pb.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            mStdOutputWorker = new Thread(() -> {\n                try {\n                    String line;\n                    while ((line = mStdOutput.readLine()) != null) {\n                        if (mListener != null) {\n                            mListener.onStreamInput(line);\n                        }\n                    }\n                } catch (Exception e) {\n                    if (mListener != null) {\n                        mListener.onStreamDied();\n                    }\n                }\n            });\n            mStdOutputWorker.start();\n            mIsActive = true;\n            if (mListener != null) {\n                mListener.onStreamStart();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void execute(String command) {\n        if (!mIsActive) {\n            return;\n        }\n        try {\n            mStdInput.writeBytes(command + \"\\n\" + mCommandEnd + \"\\n\");\n            mStdInput.flush();\n            mCounter.increase();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean waitFor() {\n        return waitFor(Integer.MAX_VALUE);\n    }\n\n    public boolean waitFor(int timeout) {\n        return waitFor(timeout, -1);\n    }\n\n    private boolean waitFor(int timeout, int index) {\n        long startTime = System.currentTimeMillis();\n        while (System.currentTimeMillis() - startTime < timeout) {\n            synchronized (mLock) {\n                if (mCounter.size() == 0) {\n                    return true;\n                }\n            }\n            try {\n                mLock.wait(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return false;\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        synchronized (mLock) {\n            return mCounter.size() > 0;\n        }\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        if (mIsActive) {\n            try {\n                mConnection.destroy();\n                mStdInput.close();\n                mStdOutput.close();\n                mStdOutputWorker.interrupt();\n                mIsActive = false;\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: The task involves creating a Java utility class that manages environment variables for a Java Runtime Environment (JRE) and handles log redirection from an external process. The class should provide methods to configure the JRE environment and redirect logs from the Android `logcat` command to a custom logger.\n\nClass Description: This utility class is designed to set up the JRE environment by configuring various system environment variables and redirecting logs from an external process (`logcat`) to a custom logger. It is particularly useful for Android applications that need to manage JRE environments and log outputs dynamically.\n\nAttributes:\n\n- `NATIVE_LIB_DIR`: String - The directory path for native libraries.\n- `LD_LIBRARY_PATH`: String - The library path for dynamic linking.\n- `LOCAL_RENDERER`: String - The renderer type for graphics (e.g., \"opengles3_desktopgl_angle_vulkan\").\n- `jvmLibraryPath`: String - The path to the JVM library (e.g., \"server/libjvm.so\" or \"client/libjvm.so\").\n- `logcatPb`: ProcessBuilder - A ProcessBuilder instance for executing the `logcat` command.\n- `failTime`: int - A counter to track the number of failed attempts to start the `logcat` process.\n\nMethods:\n\n- `redirectAndPrintJRELog()`: void - Starts a new thread to redirect and print JRE logs from the `logcat` command. The method configures the `logcat` command to filter specific log tags and redirects the output to a custom logger. If the process fails, it retries up to 10 times.\n- `setJavaEnvironment(Activity activity, String jreHome)`: void - Configures the JRE environment by setting various system environment variables. The method reads additional environment variables from a custom file (`custom_env.txt`) and applies them. It also sets the `LD_LIBRARY_PATH` and `PATH` variables to include the JRE binaries and native libraries.\n  - Input:\n    - `activity`: Activity - The Android activity context.\n    - `jreHome`: String - The home directory of the JRE.\n  - Output: None (void).\n- `setLdLibraryPath(String path)`: void - Sets the `LD_LIBRARY_PATH` environment variable to the specified path.\n  - Input:\n    - `path`: String - The new library path.\n  - Output: None (void).\n\nNote: The class assumes the presence of helper classes like `Logger`, `Tools`, `LauncherPreferences`, and `ExtraCore` for logging, file operations, and preference management. These dependencies should be handled appropriately in the implementation.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport android.system.Os;\nimport android.system.ErrnoException;\n\npublic static void redirectAndPrintJRELog() {\n    new Thread(new Runnable(){\n        int failTime = 0;\n        ProcessBuilder logcatPb;\n        @Override\n        public void run() {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder().command(\"logcat\", \"-v\", \"brief\", \"-s\", \"jrelog:I\", \"LIBGL:I\", \"NativeInput\").redirectErrorStream(true);\n                }\n\n                new ProcessBuilder().command(\"logcat\", \"-c\").redirectErrorStream(true).start();\n                java.lang.Process p = logcatPb.start();\n\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = p.getInputStream().read(buf)) != -1) {\n                    String currStr = new String(buf, 0, len);\n                    Logger.appendToLog(currStr);\n                }\n\n                if (p.waitFor() != 0) {\n                    failTime++;\n                    if (failTime <= 10) {\n                        run();\n                    } else {\n                        Logger.appendToLog(\"ERROR: Unable to get more log.\");\n                    }\n                }\n            } catch (Throwable e) {\n                Logger.appendToLog(\"Exception on logging thread:\\n\" + Log.getStackTraceString(e));\n            }\n        }\n    }).start();\n}\n\npublic static void setJavaEnvironment(Activity activity, String jreHome) throws Throwable {\n    Map<String, String> envMap = new ArrayMap<>();\n    envMap.put(\"POJAV_NATIVEDIR\", NATIVE_LIB_DIR);\n    envMap.put(\"JAVA_HOME\", jreHome);\n    envMap.put(\"HOME\", Tools.DIR_GAME_HOME);\n    envMap.put(\"TMPDIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"LIBGL_MIPMAP\", \"3\");\n    envMap.put(\"LIBGL_NOERROR\", \"1\");\n    envMap.put(\"LIBGL_NOINTOVLHACK\", \"1\");\n    envMap.put(\"LIBGL_NORMALIZE\", \"1\");\n\n    if(PREF_DUMP_SHADERS)\n        envMap.put(\"LIBGL_VGPU_DUMP\", \"1\");\n    if(PREF_ZINK_PREFER_SYSTEM_DRIVER)\n        envMap.put(\"POJAV_ZINK_PREFER_SYSTEM_DRIVER\", \"1\");\n    if(PREF_VSYNC_IN_ZINK)\n        envMap.put(\"POJAV_VSYNC_IN_ZINK\", \"1\");\n    if(Tools.deviceHasHangingLinker())\n        envMap.put(\"POJAV_EMUI_ITERATOR_MITIGATE\", \"1\");\n\n    envMap.put(\"LIBGL_ES\", (String) ExtraCore.getValue(ExtraConstants.OPEN_GL_VERSION));\n    envMap.put(\"FORCE_VSYNC\", String.valueOf(LauncherPreferences.PREF_FORCE_VSYNC));\n    envMap.put(\"MESA_GLSL_CACHE_DIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"force_glsl_extensions_warn\", \"true\");\n    envMap.put(\"allow_higher_compat_version\", \"true\");\n    envMap.put(\"allow_glsl_extension_directive_midshader\", \"true\");\n    envMap.put(\"MESA_LOADER_DRIVER_OVERRIDE\", \"zink\");\n    envMap.put(\"VTEST_SOCKET_NAME\", new File(Tools.DIR_CACHE, \".virgl_test\").getAbsolutePath());\n\n    envMap.put(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n    envMap.put(\"PATH\", jreHome + \"/bin:\" + Os.getenv(\"PATH\"));\n    if(FFmpegPlugin.isAvailable) {\n        envMap.put(\"PATH\", FFmpegPlugin.libraryPath+\":\"+envMap.get(\"PATH\"));\n    }\n\n    if(LOCAL_RENDERER != null) {\n        envMap.put(\"POJAV_RENDERER\", LOCAL_RENDERER);\n        if(LOCAL_RENDERER.equals(\"opengles3_desktopgl_angle_vulkan\")) {\n            envMap.put(\"LIBGL_ES\", \"3\");\n            envMap.put(\"POJAVEXEC_EGL\",\"libEGL_angle.so\");\n        }\n    }\n\n    File customEnvFile = new File(Tools.DIR_GAME_HOME, \"custom_env.txt\");\n    if (customEnvFile.exists() && customEnvFile.isFile()) {\n        BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            int index = line.indexOf(\"=\");\n            envMap.put(line.substring(0, index), line.substring(index + 1));\n        }\n        reader.close();\n    }\n\n    for (Map.Entry<String, String> env : envMap.entrySet()) {\n        try {\n            Os.setenv(env.getKey(), env.getValue(), true);\n        }catch (NullPointerException exception){\n            Log.e(\"JREUtils\", exception.toString());\n        }\n    }\n\n    File serverFile = new File(jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/server/libjvm.so\");\n    jvmLibraryPath = jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/\" + (serverFile.exists() ? \"server\" : \"client\");\n    setLdLibraryPath(jvmLibraryPath+\":\"+LD_LIBRARY_PATH);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JreEnvUtils {\n    private static final String NATIVE_LIB_DIR = \"/path/to/native/lib\";\n    private static final String LD_LIBRARY_PATH = \"/path/to/library/path\";\n    private static final String LOCAL_RENDERER = \"opengles3_desktopgl_angle_vulkan\";\n    private ProcessBuilder logcatPb;\n    private int failTime;\n\n    public void redirectAndPrintJRELog() {\n        new Thread(() -> {\n            int attempt = 0;\n            while (attempt < 10) {\n                try {\n                    logcatPb = new ProcessBuilder(\"logcat\", \"-s\", \"JRE\");\n                    logcatPb.redirectErrorStream(true);\n                    Process process = logcatPb.start();\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        Logger.log(line);\n                    }\n                    process.waitFor();\n                    return;\n                } catch (Exception e) {\n                    attempt++;\n                    failTime = attempt;\n                    Tools.sleep(1000);\n                }\n            }\n        }).start();\n    }\n\n    public void setJavaEnvironment(Activity activity, String jreHome) {\n        System.setProperty(\"java.library.path\", jreHome + File.separator + \"lib\" + File.separator + \"server\");\n        System.setProperty(\"LD_LIBRARY_PATH\", jreHome + File.separator + \"lib\" + File.separator + \"server\");\n        System.setProperty(\"PATH\", jreHome + File.separator + \"bin\" + File.separator + \"server\");\n        try {\n            File customEnvFile = new File(activity.getFilesDir(), \"custom_env.txt\");\n            if (customEnvFile.exists()) {\n                BufferedReader br = new BufferedReader(new FileReader(customEnvFile));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    String[] parts = line.split(\"=\");\n                    if (parts.length == 2) {\n                        System.setProperty(parts[0], parts[1]);\n                    }\n                }\n                br.close();\n            }\n        } catch (Exception e) {\n            Logger.log(\"Error reading custom_env.txt: \" + e.getMessage());\n        }\n    }\n\n    public void setLdLibraryPath(String path) {\n        System.setProperty(\"LD_LIBRARY_PATH\", path);\n    }\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellCommand {\n    private final Runtime rt;\n    private final String[] command;\n    private final String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval;\n\n    public ShellCommand(String[] command) {\n        this(command, \"ShellCommand\");\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.command = command;\n        this.tag = tag;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            new Thread(() -> {\n                try {\n                    String line;\n                    while ((line = stdout.readLine()) != null) {\n                        android.util.Log.d(tag, line);\n                    }\n                } catch (IOException e) {\n                    error = \"Error reading output: \" + e.getMessage();\n                } finally {\n                    if (waitForExit) {\n                        try {\n                            process.waitFor();\n                            exitval = process.exitValue();\n                        } catch (InterruptedException e) {\n                            error = \"Process was interrupted: \" + e.getMessage();\n                        }\n                    }\n                }\n            }).start();\n        } catch (IOException e) {\n            error = \"Error starting process: \" + e.getMessage();\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            process.waitFor();\n            exitval = process.exitValue();\n        } catch (InterruptedException e) {\n            error = \"Process was interrupted: \" + e.getMessage();\n        }\n    }\n\n    public void finish() {\n        if (process != null) {\n            try {\n                process.destroy();\n            } catch (Exception e) {\n                error = \"Error finishing process: \" + e.getMessage();\n            } finally {\n                try {\n                    if (stdout != null) {\n                        stdout.close();\n                    }\n                } catch (IOException e) {\n                    error = \"Error closing stdout: \" + e.getMessage();\n                }\n            }\n        }\n    }\n\n    public boolean checkForExit() {\n        return process == null || process.isAlive() ? false : true;\n    }\n\n    public boolean stdoutAvailable() {\n        return process.isAlive() && stdout.ready();\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            error = \"Error reading stdout: \" + e.getMessage();\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            error = \"Error reading stdout: \" + e.getMessage();\n            return null;\n        }\n    }\n\n    public String getError() {\n        return error;\n    }\n\n    public int getExitval() {\n        return exitval;\n    }\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class SystemInfoUtil {\n    public static String getHostName() {\n        String hostname = System.getenv(\"COMPUTERNAME\");\n        if (hostname != null && !hostname.isEmpty()) {\n            return hostname;\n        }\n        try {\n            Process process = Runtime.getRuntime().exec(\"hostname\");\n            java.io.InputStream inputStream = process.getInputStream();\n            java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n            String result = scanner.hasNext() ? scanner.next() : \"\";\n            scanner.close();\n            return result;\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public static String getUname(String param) {\n        if (param == null || param.isEmpty()) {\n            return \"\";\n        }\n        try {\n            Process process = Runtime.getRuntime().exec(\"uname \" + param);\n            java.io.InputStream inputStream = process.getInputStream();\n            java.util.Scanner scanner = new java.util.Scanner(inputStream).useDelimiter(\"\\\\A\");\n            String result = scanner.hasNext() ? scanner.next() : \"\";\n            scanner.close();\n            return result;\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TemporaryPorts {\n    private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts(Path lockDirectory) {\n        this.lockDirectory = lockDirectory != null ? lockDirectory : DEFAULT_LOCK_DIRECTORY;\n        try {\n            Files.createDirectories(lockDirectory);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) {\n        Path lockFilePath = lockDirectory.resolve(port + \"-\" + name);\n        try {\n            if (Files.exists(lockFilePath)) {\n                return null;\n            }\n            FileChannel fileChannel = FileChannel.open(lockFilePath, java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.WRITE);\n            FileLock lock = fileChannel.lock();\n            AllocatedPort allocatedPort = new AllocatedPort(port, lockFilePath, fileChannel, lock);\n            ports.add(allocatedPort);\n            return allocatedPort;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public AllocatedPort lock(int port, String name) {\n        Path lockFilePath = lockDirectory.resolve(port + \"-\" + name);\n        try {\n            if (Files.exists(lockFilePath)) {\n                return null;\n            }\n            FileChannel fileChannel = FileChannel.open(lockFilePath, java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.WRITE);\n            FileLock lock = fileChannel.lock();\n            AllocatedPort allocatedPort = new AllocatedPort(port, lockFilePath, fileChannel, lock);\n            ports.add(allocatedPort);\n            return allocatedPort;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() {\n            try {\n                lock.release();\n                file.close();\n                Files.delete(path);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableMap;\n\npublic class CliDockerClient {\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private final long DOCKER_OUTPUT_TIMEOUT = 10 * 60 * 1000; // 10 minutes in milliseconds\n\n    public CliDockerClient(Path dockerPath, Map<String, String> env) {\n        this.processBuilderFactory = defaultProcessBuilderFactory(dockerPath.toString(), ImmutableMap.copyOf(env));\n    }\n\n    public CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    private Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerPath, ImmutableMap<String, String> env) {\n        return args -> {\n            ProcessBuilder pb = new ProcessBuilder(dockerPath);\n            pb.environment().putAll(env);\n            pb.redirectErrorStream(true);\n            pb.command(args);\n            return pb;\n        };\n    }\n\n    private String getStderrOutput(Process process) throws IOException {\n        try (InputStream errorStream = process.getErrorStream()) {\n            StringBuilder sb = new StringBuilder();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = errorStream.read(buffer)) != -1) {\n                sb.append(new String(buffer, 0, bytesRead));\n            }\n            return sb.toString();\n        }\n    }\n\n    public Process docker(String... args) throws IOException, InterruptedException, ExecutionException, TimeoutException {\n        ProcessBuilder pb = processBuilderFactory.apply(Arrays.asList(args));\n        Process process = pb.start();\n        Future<String> future = Executors.newSingleThreadExecutor().submit(() -> {\n            try {\n                Thread.sleep(DOCKER_OUTPUT_TIMEOUT);\n                return getStderrOutput(process);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return \"Interrupted: \" + e.getMessage();\n            } catch (IOException e) {\n                return \"IO Error: \" + e.getMessage();\n            }\n        });\n        if (!future.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS).isEmpty()) {\n            throw new RuntimeException(\"Docker command failed: \" + future.get());\n        }\n        return process;\n    }\n\n    public DockerInfoDetails info() throws IOException, InterruptedException, ExecutionException, TimeoutException {\n        return fetchInfoDetails();\n    }\n\n    private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException, ExecutionException, TimeoutException {\n        Process process = docker(\"info\");\n        Future<String> future = Executors.newSingleThreadExecutor().submit(() -> {\n            try {\n                Thread.sleep(DOCKER_OUTPUT_TIMEOUT);\n                return getStderrOutput(process);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return \"Interrupted: \" + e.getMessage();\n            } catch (IOException e) {\n                return \"IO Error: \" + e.getMessage();\n            }\n        });\n        if (!future.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS).isEmpty()) {\n            throw new RuntimeException(\"Docker info failed: \" + future.get());\n        }\n        return new DockerInfoDetails();\n    }\n}"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JVMChecker {\n    public static boolean checkAndRelaunchIfNecessary(String[] args) throws Exception {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        if (!os.contains(\"mac\")) {\n            return true;\n        }\n\n        boolean isJVMOnFirstThread = isJVMOnFirstThread();\n        if (isJVMOnFirstThread) {\n            return true;\n        }\n\n        // Relaunch the process with -XstartOnFirstThread\n        ProcessBuilder pb = new ProcessBuilder(\"java\", \"-XstartOnFirstThread\", \"-jar\", \"your_app.jar\");\n        if (args != null && args.length > 0) {\n            pb.command().addAll(Arrays.asList(args));\n        }\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n\n        process.waitFor();\n        return false;\n    }\n\n    private static boolean isJVMOnFirstThread() {\n        // This is a simplified check and may need to be adjusted based on actual requirements\n        return false;\n    }\n}"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a utility class for executing external processes in Java, handling both command execution and process stream management.\n\nClass Description: A ProcessExecutor utility class that provides methods to execute system commands and external processes, capturing their output and error streams, with proper resource cleanup.\n\nMethods:\n\nMethod1: runCmd(String... cmd) -> String - Executes a command using ProcessBuilder, captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: cmd - Varargs parameter representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod2: runExec(String[] argv) -> String - Executes a command using Runtime.exec(), captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: argv - String array representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod3: processOutputStreamInThread(Process process) -> void - Helper method that reads and discards process output in a separate thread to prevent stream blocking.\nInput: process - The Process object whose output stream needs to be processed\nOutput: None (void)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\n\npublic static String runCmd(String... cmd) throws IOException, InterruptedException {\n    String output;\n    Process process = null;\n    try {\n        process = new ProcessBuilder(cmd).start();\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", cmd[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\npublic static String runExec(String[] argv) throws IOException, InterruptedException {\n    Process process = null;\n    String output;\n    try {\n        process = Runtime.getRuntime().exec(argv);\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", argv[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\nprivate static void processOutputStreamInThread(Process process) throws IOException {\n    InputStreamReader ir = new InputStreamReader(process.getInputStream());\n    LineNumberReader input = new LineNumberReader(ir);\n    while (input.readLine() != null) {\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    public String runCmd(String... cmd) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new RuntimeException(\"Command failed with exit code: \" + exitCode);\n            }\n            return output.toString();\n        }\n    }\n\n    public String runExec(String[] argv) throws Exception {\n        Process process = Runtime.getRuntime().exec(argv);\n        process.getOutputStream().close();\n        process.getErrorStream().close();\n        process.getInputStream().close();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new RuntimeException(\"Command failed with exit code: \" + exitCode);\n            }\n            return output.toString();\n        }\n    }\n\n    public void processOutputStreamInThread(Process process) {\n        new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Create a Java class that executes external processes, handles their output streams, and provides a way to interact with the process execution through callback methods.\n\nClass Description: The ProcessExecutor class is designed to manage external process execution in a cross-platform manner (handling Windows and Unix-like systems differently). It provides methods to start processes, redirect their output streams, and handle both standard output and error streams through a handler interface.\n\nAttributes:\n- process: Process - Represents the currently running external process\n- processBuilder: ProcessBuilder - Used to configure and start external processes\n\nMethods:\n- execRedirected: static Process(String[] command) throws IOException - Configures and starts an external process with error stream redirected to standard output. Handles Windows-specific command formatting.\n  - Input: String[] command - The command and arguments to execute\n  - Output: Process - The started process instance\n\n- listenOnProcess: int(String[] arguments, ProcessOutputHandler handler) - Executes a command and listens to its output streams, forwarding output lines and errors to the handler.\n  - Input: \n    - String[] arguments - The command and arguments to execute\n    - ProcessOutputHandler handler - Callback interface for handling output and errors\n  - Output: int - The exit value of the process (-1 if execution failed)\n\n- ProcessOutputHandler: interface - Callback interface for handling process output and errors\n  - Methods:\n    - handleOutputLine: void(String line) - Called for each line of output from the process\n    - handleError: void(String errorMessage) - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map;\n\npublic class ProcessExecutor {\n\n    private Process process;\n    private ProcessBuilder processBuilder;\n\n    public static Process execRedirected(String[] command) throws IOException {\n        ProcessBuilder pb;\n\n        if (!OSUtils.isWindows()) {\n            pb = new ProcessBuilder(command);\n        } else {\n            String[] cmdLine = new String[command.length];\n            for (int i = 0; i < command.length; i++)\n                cmdLine[i] = command[i].replace(\"\\\"\", \"\\\\\\\"\");\n            pb = new ProcessBuilder(cmdLine);\n            Map<String, String> env = pb.environment();\n            env.put(\"CYGWIN\", \"nodosfilewarning\");\n        }\n        pb.redirectErrorStream(true);\n\n        return pb.start();\n    }\n\n    public int listenOnProcess(String[] arguments, ProcessOutputHandler handler) {\n        try {\n            final Process p = execRedirected(arguments);\n            Thread thread = new Thread() {\n                public void run() {\n                    try {\n                        InputStreamReader reader = new InputStreamReader(p.getInputStream());\n                        int c;\n                        String line = \"\";\n                        while ((c = reader.read()) != -1) {\n                            if ((char) c == '\\r')\n                                continue;\n                            if ((char) c == '\\n') {\n                                handler.handleOutputLine(line);\n                                line = \"\";\n                            } else {\n                                line += (char) c;\n                            }\n                        }\n                        handler.handleOutputLine(line);\n                        reader.close();\n\n                        reader = new InputStreamReader(p.getErrorStream());\n                        while ((c = reader.read()) != -1)\n                            System.err.print((char) c);\n                        reader.close();\n                    } catch (Exception e) {\n                        handler.handleError(\"Run Exception: \" + e.getMessage());\n                    }\n                }\n            };\n            thread.start();\n            int res = p.waitFor();\n            thread.join();\n            return res;\n        } catch (Exception e) {\n            handler.handleError(\"Process Exception: \" + e.getMessage());\n        }\n        return -1;\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutputLine(String line);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    private Process process;\n    private ProcessBuilder processBuilder;\n\n    public static Process execRedirected(String[] command) throws IOException {\n        if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n            // Handle Windows command formatting\n            StringBuilder cmd = new StringBuilder();\n            for (String arg : command) {\n                cmd.append(\"\\\"\").append(arg).append(\"\\\" \").append(\" \");\n            }\n            command = cmd.toString().split(\" \");\n        }\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectErrorStream(true);\n        process = processBuilder.start();\n        return process;\n    }\n\n    public int listenOnProcess(String[] arguments, ProcessOutputHandler handler) {\n        try {\n            processBuilder = new ProcessBuilder(arguments);\n            processBuilder.redirectErrorStream(true);\n            process = processBuilder.start();\n\n            Thread outputThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        handler.handleOutputLine(line);\n                    }\n                } catch (IOException e) {\n                    handler.handleError(e.getMessage());\n                }\n            });\n\n            outputThread.start();\n\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                handler.handleError(\"Process exited with code: \" + exitCode);\n            }\n            return exitCode;\n        } catch (Exception e) {\n            handler.handleError(e.getMessage());\n            return -1;\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutputLine(String line);\n        void handleError(String errorMessage);\n    }\n}"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Create a Java function that disassembles a Java class file using the `javap` command-line tool and returns the disassembled output as a string.\n\nFunction Description: The function `disassembleClassFromJava` takes a Java class file as input, executes the `javap -c` command on it to disassemble the bytecode, and returns the disassembled output as a string. It handles the process execution, stream management, and error handling.\n\nInput: \n- `resourceFile` (String): The path or name of the Java class file to be disassembled.\n\nOutput: \n- (String): The disassembled bytecode output from the `javap` command. If an error occurs, returns an error message string.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URL;\n\npublic String disassembleClassFromJava(String resourceFile) {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"javap\", \"-c\", resourceFile)\n                .redirectErrorStream(true);\n\n        final Process process = pb.start();\n        final StringWriter writer = new StringWriter();\n        new Thread(() -> IOUtils.copyStreamNoException(process.getInputStream(), writer)).start();\n\n        final int ignored = process.waitFor();\n        final String processOutput = writer.toString();\n        return processOutput;\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    } catch (IOException e) {\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class ClassDisassembler {\n    public static String disassembleClassFromJava(String resourceFile) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"javap -c \" + resourceFile);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                return \"Error: javap command failed with exit code \" + exitCode;\n            }\n            return output.toString();\n        } catch (IOException | InterruptedException e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        new AsyncPipe(process.getInputStream(), System.out);\n        new AsyncPipe(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        for (ProcessBuilder builder : builders) {\n            builder.directory(processRoot);\n        }\n\n        if (builders.length == 0) {\n            return;\n        }\n\n        ProcessBuilder firstBuilder = builders[0];\n        Process firstProcess = firstBuilder.start();\n\n        AsyncPipe pipe = new AsyncPipe(is, os, true);\n        Thread thread = new Thread(pipe);\n        thread.start();\n\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder builder = builders[i];\n            Process process = builder.start();\n\n            if (i == 0) {\n                pipe.setProcess(process);\n            } else {\n                AsyncPipe nextPipe = new AsyncPipe(is, os, true);\n                nextPipe.setProcess(process);\n                Thread nextThread = new Thread(nextPipe);\n                nextThread.start();\n            }\n        }\n\n        pipe.join();\n    }\n\n    private class AsyncPipe implements Runnable {\n        private InputStream is;\n        private OutputStream os;\n        private Process process;\n        private boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        public void setProcess(Process process) {\n            this.process = process;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                    os.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        if (is != null) is.close();\n                        if (os != null) os.close();\n                        if (process != null) process.destroy();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "```java\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Channel;\n\npublic class MessageConsumer {\n    public static final String ROUTING_KEY = \"task_queue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws Exception {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        channel.basicConsume(ROUTING_KEY, true, (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\"Received: \" + message);\n        }, consumerTag -> {});\n    }\n\n    public void close() throws Exception {\n        if (channel != null) {\n            channel.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: Create a Java class that implements a Redis publisher using the Lettuce client library, capable of publishing elements to a Redis list and providing a reactive stream publisher for consuming these elements.\n\nClass Description: The RedisPublisher class provides functionality to connect to a Redis server, publish elements to a Redis list, and create a reactive stream publisher for these elements. It handles connection management and resource cleanup.\n\nAttributes:\n- client: [RedisClient] - The Redis client instance used to establish connections with the Redis server.\n- connection: [StatefulRedisConnection<String, String>] - The active connection to the Redis server for executing commands.\n\nMethods:\n- RedisPublisher() - [Constructor] -> [void] - Initializes the Redis client and establishes a connection to the Redis server. Also flushes all existing data in Redis.\n- createPublisher(long elements) -> [Publisher<String>] - Creates and returns a reactive stream Publisher that emits elements from a Redis list. The method creates a new Redis list with the specified number of elements and sets up a supplier for LRANGE commands to retrieve them.\n- close() -> [void] - Closes the Redis connection and shuts down the client to release resources.\n\nInput: \n- For createPublisher: elements [long] - The number of elements to publish to the Redis list.\n\nOutput:\n- For createPublisher: A Publisher<String> that emits the elements from the Redis list. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.output.ValueListOutput;\nimport io.lettuce.core.protocol.Command;\nimport io.lettuce.core.protocol.CommandArgs;\nimport io.lettuce.core.protocol.CommandType;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.function.Supplier;\n\npublic class RedisPublisher {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisPublisher() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public Publisher<String> createPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        String id = UUID.randomUUID().toString();\n        String key = \"PublisherVerification-\" + id;\n\n        for (int i = 0; i < elements; i++) {\n            sync.lpush(key, \"element-\" + i);\n        }\n\n        Supplier<Command<String, String, List<String>>> supplier = () -> {\n            CommandArgs<String, String> args = new CommandArgs<>(StringCodec.UTF8).addKey(key).add(0).add(-1);\n            return new Command<>(CommandType.LRANGE, new ValueListOutput<>(StringCodec.UTF8), args);\n        };\n\n        return new TestRedisPublisher(supplier, connection, true);\n    }\n\n    public void close() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport reactor.core.publisher.Flux;\n\npublic class RedisPublisher {\n    private final RedisClient client;\n    private final StatefulRedisConnection<String, String> connection;\n\n    public RedisPublisher() {\n        this.client = RedisClient.create(\"redis://localhost:6379\");\n        this.connection = this.client.connect();\n        flushAll();\n    }\n\n    private void flushAll() {\n        RedisCommands<String, String> redisCommands = connection.sync();\n        redisCommands.flushDB();\n    }\n\n    public Flux<String> createPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        String key = \"myList\";\n        for (long i = 0; i < elements; i++) {\n            connection.sync().lPush(key, String.valueOf(i));\n        }\n\n        return Flux.fromStream(connection.sync().lRange(key, 0, -1));\n    }\n\n    public void close() {\n        connection.close();\n        client.shutdown();\n    }\n}"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.sync.RedisStringCommands;\nimport io.lettuce.core.pipeline.Pipeline;\nimport io.lettuce.core.pipeline.PipelineFuture;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class LettuceRedisUtils {\n    private static final RedisClient REDIS_CLIENT = RedisClient.create(\"redis://localhost:6379\");\n\n    private LettuceRedisUtils() {}\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        try (Pipeline pipeline = REDIS_CLIENT.connect().pipeline()) {\n            List<PipelineFuture> futures = pipelineCallBack.execute(pipeline);\n            for (PipelineFuture future : futures) {\n                future.get();\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface RedisPipelineCallBack {\n        List<PipelineFuture> execute(Pipeline pipeline);\n    }\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing methods to establish, close, and create new connections with configurable protocols.\n\nClass Description: The RedisConnectionManager class handles Redis connection management using Jedis, allowing for protocol configuration and providing essential connection operations. It encapsulates connection details and offers methods for connection lifecycle management.\n\nAttributes:\n\nendpoint: [EndpointConfig] - Configuration for Redis connection endpoint (host, port, etc.)\nprotocol: [RedisProtocol] - The Redis protocol to be used for connections\njedis: [Jedis] - The Jedis client instance for Redis operations\n\nMethods:\n\nsetUpConnection: [void]() -> [void] - Establishes a new Redis connection with the configured protocol and timeout, and flushes all existing data\ncloseConnection: [void]() -> [void] - Closes the current Redis connection and releases resources\ncreateNewConnection: [Jedis]() -> [Jedis] - Creates and returns a new Jedis connection instance with the configured protocol",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.HostAndPorts;\nimport redis.clients.jedis.RedisProtocol;\nimport redis.clients.jedis.EndpointConfig;\n\npublic class RedisConnectionManager {\n\n    protected static final EndpointConfig endpoint = HostAndPorts.getRedisEndpoint(\"standalone0\");\n    protected final RedisProtocol protocol;\n    protected Jedis jedis;\n\n    public RedisConnectionManager(RedisProtocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() throws Exception {\n        jedis = new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).timeoutMillis(500).build());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() throws Exception {\n        jedis.close();\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).build());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private EndpointConfig endpoint;\n    private RedisProtocol protocol;\n    private Jedis jedis;\n\n    public RedisConnectionManager(EndpointConfig endpoint, RedisProtocol protocol) {\n        this.endpoint = endpoint;\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n        jedis = new Jedis(endpoint.getHost(), endpoint.getPort());\n        jedis.setTimeout(protocol.getTimeout());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public Jedis createNewConnection() {\n        Jedis newJedis = new Jedis(endpoint.getHost(), endpoint.getPort());\n        newJedis.setTimeout(protocol.getTimeout());\n        return newJedis;\n    }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.FileChannel;\nimport java.nio.channels.FileChannel;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.TimeUnit;\nimport org.jboss.netty.handler.stream.StreamSinkConduit;\nimport org.jboss.netty.channel.ChannelFuture;\nimport org.jboss.netty.channel.ChannelHandlerContext;\nimport org.jboss.netty.channel.ExceptionEvent;\nimport org.jboss.netty.channel.WriteCompletionEvent;\nimport org.jboss.netty.channel.socket.nio.NioWorker;\nimport org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;\nimport org.jboss.netty.handler.codec.http.HttpServerExchange;\nimport org.jboss.netty.handler.codec.http.HttpRequest;\nimport org.jboss.netty.handler.codec.http.HttpResponse;\nimport org.jboss.netty.handler.ssl.SslHandler;\nimport org.jboss.netty.buffer.ChannelBuffers;\nimport org.jboss.netty.util.HashedWheelTimer;\nimport org.jboss.netty.util.Timer;\nimport org.jboss.netty.util.ThreadNameUtil;\nimport org.jboss.netty.util.internal.StringUtil;\nimport org.jboss.netty.util.internal.ThrowableUtils;\nimport org.jboss.netty.util.internal.chained.HeadTailedLinkedList;\nimport org.jboss.netty.util.internal.chained.HeadTailedLinkedList$Head;\nimport org.jboss.netty.util.internal.chained.HeadTailedLinkedList$Node;\nimport org.jboss.netty.util.internal.chained.Link;\nimport org.jboss.netty.util.internal.chained.Link$Head;\nimport org.jboss.netty.util.internal.chained.Link$Node;\nimport org.jboss.netty.util.internal.chained.List$Head;\nimport org.jboss.netty.util.internal.chained.List$Node;\nimport org.jboss.netty.util.internal.chained.Queue$Head;\nimport org.jboss.netty.util.internal.chained.Queue$Node;\nimport org.jboss.netty.util.internal.chained.Stack$Head;\nimport org.jboss.netty.util.internal.chained.Stack$Node;\nimport org.jboss.netty.util.internal.chained.TailQueue$Head;\nimport org.jboss.netty.util.internal.chained.TailQueue$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Node;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$Head;\nimport org.jboss.netty.util.internal.chained.UnsafeStringArray$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$String$"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.CommandObjects;\n\nimport java.util.Queue;\nimport java.util.List;\n\npublic class ReliableTransaction {\n    private final Queue<Response<?>> pipelinedResponses;\n    private final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken;\n    private boolean inWatch;\n    private boolean inMulti;\n    private CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean inWatch, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.inWatch = inWatch;\n        this.commandObjects = commandObjects;\n        this.pipelinedResponses = new java.util.LinkedList<>();\n        this.broken = false;\n        this.inMulti = false;\n    }\n\n    public void multi() {\n        if (inMulti) {\n            throw new IllegalStateException(\"MULTI already started\");\n        }\n        inMulti = true;\n        connection.sendCommand(\"MULTI\");\n    }\n\n    public String watch(String... keys) {\n        if (!inWatch) {\n            connection.sendCommand(\"WATCH\", keys);\n            inWatch = true;\n        }\n        return \"OK\";\n    }\n\n    public String unwatch() {\n        if (inWatch) {\n            connection.sendCommand(\"UNWATCH\");\n            inWatch = false;\n        }\n        return \"OK\";\n    }\n\n    public Response<?> appendCommand(CommandObject<T> command) {\n        if (!inMulti) {\n            throw new IllegalStateException(\"Commands can only be added after MULTI\");\n        }\n        Response<T> response = command.execute(connection);\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        if (closeConnection) {\n            connection.close();\n        }\n    }\n\n    public void clear() {\n        pipelinedResponses.clear();\n        inMulti = false;\n        inWatch = false;\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC called without MULTI\");\n        }\n        if (inWatch) {\n            connection.sendCommand(\"UNWATCH\");\n            inWatch = false;\n        }\n        connection.sendCommand(\"EXEC\");\n        List<Object> results = connection.getPipeline().getResults();\n        pipelinedResponses.clear();\n        inMulti = false;\n        return results;\n    }\n\n    public String discard() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"DISCARD called without MULTI\");\n        }\n        connection.sendCommand(\"DISCARD\");\n        pipelinedResponses.clear();\n        inMulti = false;\n        return \"OK\";\n    }\n}"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.io.IOException;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class Connection implements Closeable {\n    private final JedisSocketFactory socketFactory;\n    private Socket socket;\n    private RedisOutputStream outputStream;\n    private RedisInputStream inputStream;\n    private int soTimeout;\n    private boolean broken;\n    private AtomicReference<RedisCredentials> currentCredentials;\n    private AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n        this.currentCredentials = new AtomicReference<>();\n        this.authXManager = new AuthXManager();\n    }\n\n    public void connect() throws IOException {\n        socket = socketFactory.createSocket();\n        socket.setSoTimeout(soTimeout);\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n    }\n\n    public void disconnect() {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public boolean isConnected() {\n        return socket != null && !broken;\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        this.broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) throws IOException {\n        if (isBroken()) {\n            throw new IOException(\"Connection is broken\");\n        }\n        outputStream.write(command.getByteRepresentation());\n        for (byte[] arg : args) {\n            outputStream.write(arg);\n        }\n        outputStream.flush();\n    }\n\n    public Object getOne() throws IOException {\n        if (isBroken()) {\n            throw new IOException(\"Connection is broken\");\n        }\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() throws IOException {\n        if (isBroken()) {\n            throw new IOException(\"Connection is broken\");\n        }\n        outputStream.flush();\n    }\n\n    public Object readProtocolWithCheckingBroken() throws IOException {\n        if (isBroken()) {\n            throw new IOException(\"Connection is broken\");\n        }\n        return inputStream.readProtocol();\n    }\n\n    @Override\n    public void close() {\n        disconnect();\n    }\n}"
  },
  {
    "Task_id": 317,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis Search functionality, including index creation, document management, search operations, and aggregation.\n\nClass Description: The RedisSearchClient class encapsulates Redis Search operations using the Jedis client library. It manages a connection to Redis and provides methods for creating search indexes, adding JSON documents, performing searches, and running aggregations.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis client connection used for all operations\n\nMethods:\n- RedisSearchClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- createIndex(String indexName, String prefix, SchemaField[] schema) -> void - Creates a new search index with the given name, prefix, and schema definition\n- addDocument(String key, Object document) -> void - Adds a JSON document to Redis with the specified key\n- search(String indexName, Query query) -> List<Document> - Performs a search query on the specified index and returns matching documents\n- aggregate(String indexName, AggregationBuilder aggregationBuilder) -> AggregationResult - Executes an aggregation query on the specified index and returns the results\n- close() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.search.*;\nimport redis.clients.jedis.search.aggr.*;\nimport redis.clients.jedis.search.schemafields.*;\n\npublic class RedisSearchClient {\n\n    private JedisPooled jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        jedis.ftCreate(indexName,\n            FTCreateParams.createParams()\n                .on(IndexDataType.JSON)\n                .addPrefix(prefix),\n            schema\n        );\n    }\n\n    public void addDocument(String key, Object document) {\n        jedis.jsonSetWithEscape(key, document);\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        return jedis.ftSearch(indexName, query).getDocuments();\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        return jedis.ftAggregate(indexName, aggregationBuilder);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.search.Query;\nimport redis.clients.jedis.search.SchemaField;\nimport redis.clients.jedis.search.AggregationBuilder;\nimport redis.clients.jedis.search.AggregationResult;\nimport redis.clients.jedis.search.Document;\n\nimport java.util.List;\n\npublic class RedisSearchClient {\n    private JedisPooled jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        jedis.searchCreateIndex(indexName, prefix, schema);\n    }\n\n    public void addDocument(String key, Object document) {\n        jedis.jsonSet(key, \"$\", document.toString());\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        return jedis.search(indexName, query);\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        return jedis.searchAggregate(indexName, aggregationBuilder);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.StatefulRedisClusterConnection;\nimport io.lettuce.core.auth.TokenBasedRedisCredentialsProvider;\n\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n    private final RedisClient redisClient;\n    private final RedisClusterClient redisClusterClient;\n    private final TokenBasedRedisCredentialsProvider credentialsUser1;\n    private final TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.redisClusterClient = RedisClusterClient.create(redisUri);\n        \n        this.credentialsUser1 = new TokenBasedRedisCredentialsProvider(authority, scopes, user1ClientId, user1Secret);\n        this.credentialsUser2 = new TokenBasedRedisCredentialsProvider(authority, scopes, user2ClientId, user2Secret);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return this.redisClient.connect().withOptions(this.credentialsUser1);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        return this.redisClient.connect().withOptions(this.credentialsUser2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return this.redisClusterClient.connect().withOptions(this.credentialsUser1);\n    }\n\n    public void close() {\n        this.redisClient.close();\n        this.redisClusterClient.close();\n    }\n}"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Create a singleton Redis client class that manages a single Redis connection instance throughout the application lifecycle, with automatic shutdown handling.\n\nClass Description: DefaultRedisClient is a singleton class that provides centralized Redis client management. It creates and maintains a single RedisClient instance, configures default timeout settings, and ensures proper resource cleanup during JVM shutdown.\n\nAttributes:\n- instance: DefaultRedisClient - The singleton instance of the class\n- redisClient: RedisClient - The underlying Redis client connection instance\n\nMethods:\n- get() -> RedisClient - Returns the singleton RedisClient instance after setting a default timeout of 60 seconds\n- DefaultRedisClient() (constructor) - Private constructor that initializes the RedisClient with connection settings and registers a shutdown hook\n- run() (in anonymous Thread class) - Shutdown hook method that cleans up Redis client resources during JVM shutdown",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.TimeUnit;\n\npublic class DefaultRedisClient {\n\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(RedisURI.Builder.redis(TestSettings.host(), TestSettings.port()).build());\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                FastShutdown.shutdown(redisClient);\n            }\n        });\n    }\n\n    public static RedisClient get() {\n        instance.redisClient.setDefaultTimeout(60, TimeUnit.SECONDS);\n        return instance.redisClient;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class DefaultRedisClient {\n    private static DefaultRedisClient instance;\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(\"redis://localhost:6379\");\n        redisClient.setOptions(RedisClientOptions.builder().timeout(60, TimeUnit.SECONDS).build());\n        Runtime.getRuntime().addShutdownHook(new Thread(this::run));\n    }\n\n    public static DefaultRedisClient get() {\n        if (instance == null) {\n            instance = new DefaultRedisClient();\n        }\n        return instance;\n    }\n\n    public RedisClient getRedisClient() {\n        return redisClient;\n    }\n\n    private void run() {\n        if (redisClient != null) {\n            redisClient.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel channel, Path path, TranslogHeader header) {\n        super(channel, path, header);\n        this.checkpoint = checkpoint;\n        this.length = channel.size();\n        this.totalOperations = (int) checkpoint.getSequenceId();\n    }\n\n    public static TranslogReader open(FileChannel channel, Path path, Checkpoint checkpoint, String index) {\n        return new TranslogReader(checkpoint, channel, path, null);\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceId, ChannelFactory factory) {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"Cannot close into trimmed reader when reader is already closed\");\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new ElasticsearchException(\"Failed to close file channel\", e);\n        }\n        try {\n            FileChannel newChannel = factory.create(path);\n            TranslogHeader newHeader = new TranslogHeader(index, sequenceId, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\nimport java.time.Instant;\nimport java.time.Duration;\n\npublic class ClusterCommandExecutor {\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public <T> T broadcastCommand(CommandObject<T> commandObject) {\n        return executeCommand(commandObject);\n    }\n\n    public <T> T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attemptsLeft = maxAttempts;\n        Instant doneDeadline = Instant.now().plus(maxTotalRetriesDuration);\n        int consecutiveConnectionFailures = 0;\n\n        while (attemptsLeft > 0) {\n            try {\n                Connection connection = provider.getConnection(toReplica);\n                T result = execute(connection, commandObject);\n                return result;\n            } catch (Exception e) {\n                log.severe(\"Failed to execute command: \" + e.getMessage());\n                if (handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, doneDeadline)) {\n                    attemptsLeft--;\n                    consecutiveConnectionFailures = 0;\n                } else {\n                    throw new RuntimeException(\"Command execution failed after all retries\", e);\n                }\n            }\n        }\n        throw new RuntimeException(\"Command execution failed after all retries\");\n    }\n\n    private <T> T execute(Connection connection, CommandObject<T> commandObject) {\n        try {\n            return connection.execute(commandObject);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing command on connection: \" + e.getMessage(), e);\n        }\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        if (consecutiveConnectionFailures >= maxAttempts) {\n            return false;\n        }\n\n        long backoffSleepMillis = getBackoffSleepMillis(attemptsLeft, doneDeadline);\n        sleep(backoffSleepMillis);\n        consecutiveConnectionFailures++;\n\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long baseSleepMillis = 100;\n        long totalSleepMillis = 0;\n        for (int i = 0; i < attemptsLeft; i++) {\n            totalSleepMillis += baseSleepMillis * Math.pow(2, i);\n        }\n        return Math.min((deadline.toEpochMilli() - Instant.now().toEpochMilli()), totalSleepMillis);\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted during sleep\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import com.google.protobuf.Descriptors;\nimport com.google.protobuf.Message;\nimport com.google.protobuf.util.JsonFormat;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class RedisDao {\n    private JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema;\n    private ReentrantLock lock = new ReentrantLock();\n\n    public RedisDao(String ip, int port) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, ip, port);\n        this.schema = RuntimeSchema.getSchema(Seckill.class);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            byte[] key = getSeckillRedisKey(seckillId).getBytes();\n            byte[] value = jedis.get(key);\n            if (value == null) {\n                return null;\n            }\n            return (Seckill) schema.deserialize(value);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        byte[] key = getSeckillRedisKey(seckillId).getBytes();\n        byte[] value = jedis.get(key);\n        if (value == null) {\n            return null;\n        }\n        return (Seckill) schema.deserialize(value);\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        lock.lock();\n        try {\n            try (Jedis jedis = jedisPool.getResource()) {\n                byte[] key = getSeckillRedisKey(seckillId).getBytes();\n                byte[] value = jedis.get(key);\n                if (value != null) {\n                    return (Seckill) schema.deserialize(value);\n                }\n            }\n\n            Seckill seckill = getDataFromDb.apply(seckillId);\n            if (seckill != null) {\n                String result = putSeckill(seckill, jedisPool.getResource());\n                return seckill;\n            }\n            return null;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            byte[] key = getSeckillRedisKey(seckill.getId()).getBytes();\n            byte[] value = schema.serialize(seckill);\n            jedis.set(key, value);\n            jedis.expire(key, 60 * 60); // Set expiration to 1 hour\n            return \"OK\";\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        byte[] key = getSeckillRedisKey(seckill.getId()).getBytes();\n        byte[] value = schema.serialize(seckill);\n        jedis.set(key, value);\n        jedis.expire(key, 60 * 60); // Set expiration to 1 hour\n        return \"OK\";\n    }\n\n    public String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import org.apache.commons.lang3.StringUtils;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.SocketFactory;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.SSLParameters;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.cert.X509Certificate;\n\npublic class DefaultJedisSocketFactory implements SocketFactory {\n    private final HostAndPort hostAndPort;\n    private final int connectionTimeout;\n    private final int socketTimeout;\n    private final boolean ssl;\n    private final SSLSocketFactory sslSocketFactory;\n    private final SSLParameters sslParameters;\n    private final HostnameVerifier hostnameVerifier;\n    private final HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this.hostAndPort = new HostAndPort(\"127.0.0.1\", 6379);\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = null;\n        this.hostnameVerifier = null;\n        this.hostAndPortMapper = null;\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = null;\n        this.hostnameVerifier = null;\n        this.hostAndPortMapper = null;\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this.hostAndPort = new HostAndPort(config.getHost(), config.getPort());\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    protected Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) {\n        if (hostAndPortMapper != null) {\n            hostAndPort = hostAndPortMapper.map(hostAndPort);\n        }\n        try {\n            InetSocketAddress address = new InetSocketAddress(hostAndPort.getHost(), hostAndPort.getPort());\n            Socket socket = new Socket();\n            socket.connect(address, connectionTimeout);\n            if (ssl) {\n                socket = ((SSLSocket) socket).asInstanceOf(SSLSocket.class);\n            }\n            socket.setSoTimeout(socketTimeout);\n            return socket;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to connect to \" + hostAndPort, e);\n        }\n    }\n\n    @Override\n    public Socket createSocket() {\n        return connectToFirstSuccessfulHost(hostAndPort);\n    }\n\n    @Override\n    public HostAndPort getSocketHostAndPort() {\n        if (hostAndPortMapper != null) {\n            return hostAndPortMapper.map(hostAndPort);\n        }\n        return hostAndPort;\n    }\n}"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a multi-cluster Redis connection provider that manages connections to multiple Redis clusters with failover capabilities and connection pooling.\n\nClass Description: MultiClusterPooledConnectionProvider is a connection provider that maintains connections to multiple Redis clusters, allowing for cluster failover and providing pooled connections to improve performance. It uses a priority-based system to determine the active cluster and provides thread-safe access to connections.\n\nAttributes:\n- log: Logger - Logger instance for logging events and errors\n- multiClusterMap: Map<Integer, Cluster> - Concurrent map storing Redis clusters with their priority as key\n- activeMultiClusterIndex: Integer - Currently active cluster index (volatile for thread visibility)\n- activeClusterIndexLock: Lock - Reentrant lock for thread-safe modification of active cluster index\n- lastClusterCircuitBreakerForcedOpen: boolean - Flag indicating if circuit breaker was last forced open (volatile for thread visibility)\n\nMethods:\n- MultiClusterPooledConnectionProvider(MultiClusterClientConfig) -> void - Constructor that initializes the connection pools for all configured Redis clusters\n  Input: multiClusterClientConfig - Configuration object containing cluster settings\n  Throws: JedisValidationException if config is null\n\n- getConnection() -> Connection - Gets a connection from the currently active Redis cluster\n  Output: Connection object from the active cluster's pool\n\n- getConnection(int) -> Connection - Gets a connection from a specific Redis cluster by index\n  Input: multiClusterIndex - Priority index of the desired cluster\n  Output: Connection object from the specified cluster's pool\n\n- close() -> void - Closes the connection pool of the currently active cluster\n\nNested Class: Cluster\n- connectionPool: ConnectionPool - Pool of Redis connections for a specific cluster\n- getConnection() -> Connection - Gets a connection from this cluster's pool\n- getConnectionPool() -> ConnectionPool - Returns the connection pool instance",
    "Canonical_solution": "import io.github.resilience4j.circuitbreaker.CircuitBreaker;\nimport io.github.resilience4j.circuitbreaker.CircuitBreaker.State;\nimport io.github.resilience4j.retry.Retry;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisValidationException;\nimport redis.clients.jedis.util.Pool;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider implements ConnectionProvider {\n\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex = 1;\n    private final Lock activeClusterIndexLock = new ReentrantLock(true);\n    private volatile boolean lastClusterCircuitBreakerForcedOpen = false;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null)\n            throw new JedisValidationException(\"MultiClusterClientConfig must not be NULL for MultiClusterPooledConnectionProvider\");\n\n        ClusterConfig[] clusterConfigs = multiClusterClientConfig.getClusterConfigs();\n        for (ClusterConfig config : clusterConfigs) {\n            GenericObjectPoolConfig<Connection> poolConfig = config.getConnectionPoolConfig();\n            String clusterId = \"cluster:\" + config.getPriority() + \":\" + config.getHostAndPort();\n\n            if (poolConfig != null) {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig(), poolConfig)));\n            } else {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig())));\n            }\n        }\n    }\n\n    @Override\n    public Connection getConnection() {\n        return multiClusterMap.get(activeMultiClusterIndex).getConnection();\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        return multiClusterMap.get(multiClusterIndex).getConnection();\n    }\n\n    @Override\n    public void close() {\n        multiClusterMap.get(activeMultiClusterIndex).getConnectionPool().close();\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import java.util.Map;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Logger;\n\npublic class MultiClusterPooledConnectionProvider {\n    private final Logger log;\n    private final Map<Integer, Cluster> multiClusterMap;\n    private volatile int activeMultiClusterIndex;\n    private final ReentrantLock activeClusterIndexLock;\n    private volatile boolean lastClusterCircuitBreakerForcedOpen;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null) {\n            throw new JedisValidationException(\"Configuration cannot be null\");\n        }\n        log = Logger.getLogger(MultiClusterPooledConnectionProvider.class.getName());\n        multiClusterMap = multiClusterClientConfig.getClusters();\n        activeClusterIndexLock = new ReentrantLock();\n        activeMultiClusterIndex = 0;\n        lastClusterCircuitBreakerForcedOpen = false;\n    }\n\n    public Connection getConnection() {\n        return getConnection(activeMultiClusterIndex);\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        Cluster cluster = multiClusterMap.get(multiClusterIndex);\n        if (cluster == null) {\n            log.severe(\"Cluster with index \" + multiClusterIndex + \" not found\");\n            return null;\n        }\n        return cluster.getConnection();\n    }\n\n    public void close() {\n        Cluster activeCluster = multiClusterMap.get(activeMultiClusterIndex);\n        if (activeCluster != null) {\n            activeCluster.close();\n        }\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getConnection();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}"
  },
  {
    "Task_id": 332,
    "Instruction": "Task Description: Create a Java class that provides a wrapper for JedisSentinelPool to simplify Redis Sentinel connection management in Java applications.\n\nClass Description: JedisSentinelPoolWrapper is a utility class that encapsulates the functionality of JedisSentinelPool, providing methods for pool initialization, resource acquisition, and connection cleanup. It handles Redis Sentinel connections with configurable pool settings and client configurations.\n\nAttributes:\n- masterName: String - The name of the Redis master node in the Sentinel configuration\n- sentinels: Set<HostAndPort> - Set of Sentinel server addresses (host and port)\n- poolConfig: GenericObjectPoolConfig<Jedis> - Configuration for the connection pool\n- masterConfig: JedisClientConfig - Configuration for connections to the master node\n- sentinelConfig: JedisClientConfig - Configuration for connections to Sentinel nodes\n- pool: JedisSentinelPool - The underlying Jedis Sentinel connection pool instance\n\nMethods:\n- initializePool(): void - Initializes the JedisSentinelPool with the configured parameters\n- getResource(): Jedis - Retrieves a Jedis resource from the pool (throws JedisConnectionException if pool not initialized)\n- close(): void - Closes the pool if it's open\n- isClosed(): boolean - Returns whether the pool is closed\n- destroy(): void - Destroys the pool and all its resources\n- toStrings(Set<HostAndPort>): Set<String> - Static helper method to convert HostAndPort objects to strings",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPoolWrapper {\n\n    private final String masterName;\n    private final Set<HostAndPort> sentinels;\n    private final GenericObjectPoolConfig<Jedis> poolConfig;\n    private final JedisClientConfig masterConfig;\n    private final JedisClientConfig sentinelConfig;\n    private JedisSentinelPool pool;\n\n    public JedisSentinelPoolWrapper(String masterName, Set<HostAndPort> sentinels,\n                                  GenericObjectPoolConfig<Jedis> poolConfig,\n                                  JedisClientConfig masterConfig,\n                                  JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.poolConfig = poolConfig;\n        this.masterConfig = masterConfig;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public void initializePool() {\n        this.pool = new JedisSentinelPool(masterName, sentinels, poolConfig, masterConfig, sentinelConfig);\n    }\n\n    public Jedis getResource() throws JedisConnectionException {\n        if (pool == null) {\n            throw new JedisConnectionException(\"Pool not initialized\");\n        }\n        return pool.getResource();\n    }\n\n    public void close() {\n        if (pool != null && !pool.isClosed()) {\n            pool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return pool == null || pool.isClosed();\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n\n    private static Set<String> toStrings(Set<HostAndPort> hostAndPorts) {\n        return hostAndPorts.stream().map(HostAndPort::toString).collect(Collectors.toSet());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class JedisSentinelPoolWrapper {\n    private String masterName;\n    private Set<HostAndPort> sentinels;\n    private GenericObjectPoolConfig<Jedis> poolConfig;\n    private JedisClientConfig masterConfig;\n    private JedisClientConfig sentinelConfig;\n    private JedisSentinelPool pool;\n\n    public JedisSentinelPoolWrapper(String masterName, Set<HostAndPort> sentinels, GenericObjectPoolConfig<Jedis> poolConfig, JedisClientConfig masterConfig, JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.poolConfig = poolConfig;\n        this.masterConfig = masterConfig;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public void initializePool() {\n        if (pool == null) {\n            pool = new JedisSentinelPool(masterName, sentinels, poolConfig, sentinelConfig, masterConfig);\n        }\n    }\n\n    public Jedis getResource() {\n        if (pool == null || !pool.isAvailable()) {\n            throw new JedisConnectionException(\"Pool not initialized or no available connection\");\n        }\n        return pool.getResource();\n    }\n\n    public void close() {\n        if (pool != null && !pool.isClosed()) {\n            pool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return pool != null && pool.isClosed();\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n\n    public static Set<String> toStrings(Set<HostAndPort> hosts) {\n        Set<String> result = new HashSet<>();\n        if (hosts != null) {\n            for (HostAndPort host : hosts) {\n                result.add(host.getHost() + \":\" + host.getPort());\n            }\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "@Configuration\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new FastJson2RedisSerializer<>(Object.class));\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new FastJson2RedisSerializer<>(Object.class));\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        config.useSingleServer().setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (method, params) -> {\n            StringBuilder sb = new StringBuilder(method.getName());\n            sb.append(\"(\");\n            for (Object param : params) {\n                sb.append(param).append(\",\");\n            }\n            sb.delete(sb.length() - 1, sb.length());\n            sb.append(\")\");\n            return DigestUtils.sha256Hex(sb.toString());\n        };\n    }\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a Java class for writing WAV audio files with support for file rollover when reaching maximum size limits, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: WaveWriter is a class that handles the creation and writing of WAV audio files. It manages file channels, buffers, and WAV file formatting while supporting automatic file rollover when files reach a specified maximum size. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- mAudioFormat: [AudioFormat] - The audio format specification for the WAV file\n- mFileRolloverCounter: [int] - Counter for tracking rolled-over file versions\n- mMaxSize: [long] - Maximum allowed file size before rollover (0 means no limit)\n- mFile: [Path] - Current file path being written to\n- mFileChannel: [FileChannel] - NIO file channel for file operations\n- mDataChunkOpen: [boolean] - Flag indicating if a data chunk is currently open\n- mDataChunkSizeOffset: [long] - File position of the data chunk size field\n- mDataChunkSize: [int] - Current size of the data chunk in bytes\n\nMethods:\n- WaveWriter: [constructor](AudioFormat format, Path file, long maxSize) -> [void] - Initializes a new WaveWriter with specified format, output file, and maximum size\n- WaveWriter: [constructor](AudioFormat format, Path file) -> [void] - Initializes a new WaveWriter with no maximum size limit\n- open: [private]() -> [void] - Opens a new file channel and writes initial WAV header\n- close: [public]() -> [void] - Closes the file channel and performs cleanup\n- close: [public](Path path) -> [void] - Closes the file channel and renames the file to the specified path\n- writeData: [public](ByteBuffer buffer) -> [void] - Writes audio data to the file, handling rollover if needed\n- closeDataChunk: [private]() -> [void] - Marks the current data chunk as closed\n- openDataChunk: [private]() -> [void] - Opens a new data chunk in the WAV file\n- rollover: [private]() -> [void] - Performs file rollover operation when reaching size limit\n- updateTotalSize: [private]() -> [void] - Updates the total file size in the WAV header\n- updateDataChunkSize: [private]() -> [void] - Updates the data chunk size in the WAV file\n- getUnsignedIntegerBuffer: [protected static](long size) -> [ByteBuffer] - Creates a buffer with unsigned integer representation\n- updateFileName: [private]() -> [void] - Updates the filename for rollover operations\n- getDataHeader: [public static]() -> [ByteBuffer] - Creates a data chunk header buffer\n- getWaveHeader: [public static](AudioFormat format) -> [ByteBuffer] - Creates a WAV file header buffer\n- getFormatChunk: [public static](AudioFormat format) -> [ByteBuffer] - Creates a format chunk buffer for WAV file",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.sound.sampled.AudioFormat;\n\npublic class WaveWriter implements AutoCloseable\n{\n    private static final Pattern FILENAME_PATTERN = Pattern.compile(\"(.*_)(\\\\d+)(\\\\.tmp)\");\n    private AudioFormat mAudioFormat;\n    private int mFileRolloverCounter = 1;\n    private long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen = false;\n    private long mDataChunkSizeOffset = 0;\n    private int mDataChunkSize = 0;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) throws IOException\n    {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) throws IOException\n    {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException\n    {\n        int version = 2;\n        while(Files.exists(mFile) && version < 20)\n        {\n            mFile = Paths.get(mFile.toFile().getAbsolutePath().replace(\".tmp\", \"_\" + version + \".tmp\"));\n            version++;\n        }\n        mFileChannel = (FileChannel.open(mFile, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW));\n        ByteBuffer header = getWaveHeader(mAudioFormat);\n        while(header.hasRemaining())\n        {\n            mFileChannel.write(header);\n        }\n    }\n\n    public void close() throws IOException\n    {\n        close(null);\n    }\n\n    public void close(Path path) throws IOException\n    {\n        mFileChannel.force(true);\n        mFileChannel.close();\n        rename(path);\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException\n    {\n        buffer.position(0);\n        openDataChunk();\n        if(mFileChannel.size() + buffer.capacity() < mMaxSize)\n        {\n            while(buffer.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(buffer);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n        else\n        {\n            int remaining = (int)(mMaxSize - mFileChannel.size());\n            remaining -= (int)(remaining % mAudioFormat.getFrameSize());\n            byte[] bytes = buffer.array();\n            ByteBuffer current = ByteBuffer.wrap(Arrays.copyOf(bytes, remaining));\n            ByteBuffer next = ByteBuffer.wrap(Arrays.copyOfRange(bytes, remaining, bytes.length));\n            while(current.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(current);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n            rollover();\n            openDataChunk();\n            while(next.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(next);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n    }\n\n    private void closeDataChunk()\n    {\n        mDataChunkOpen = false;\n    }\n\n    private void openDataChunk() throws IOException\n    {\n        if(!mDataChunkOpen)\n        {\n            if(mFileChannel.size() + 32 >= mMaxSize)\n            {\n                rollover();\n            }\n            ByteBuffer formatChunk = getFormatChunk(mAudioFormat);\n            formatChunk.position(0);\n            while(formatChunk.hasRemaining())\n            {\n                mFileChannel.write(formatChunk);\n            }\n            ByteBuffer dataHeader = getDataHeader();\n            dataHeader.position(0);\n            while(dataHeader.hasRemaining())\n            {\n                mFileChannel.write(dataHeader);\n            }\n            mDataChunkSizeOffset = mFileChannel.size() - 4;\n            mDataChunkSize = 0;\n            mDataChunkOpen = true;\n            updateTotalSize();\n        }\n    }\n\n    private void rollover() throws IOException\n    {\n        closeDataChunk();\n        close();\n        mFileRolloverCounter++;\n        updateFileName();\n        open();\n    }\n\n    private void updateTotalSize() throws IOException\n    {\n        ByteBuffer buffer = getUnsignedIntegerBuffer(mFileChannel.size() - 8);\n        mFileChannel.write(buffer, 4);\n    }\n\n    private void updateDataChunkSize() throws IOException\n    {\n        ByteBuffer size = getUnsignedIntegerBuffer(mDataChunkSize);\n        mFileChannel.write(size, mDataChunkSizeOffset);\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size)\n    {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.put((byte)(size & 0xFFl));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF00l, 8)));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF0000l, 16)));\n        buffer.put((byte)Long.rotateRight(Long.rotateRight(size & 0xFF000000l, 16), 8));\n        buffer.position(0);\n        return buffer;\n    }\n\n    private void updateFileName()\n    {\n        String filename = mFile.toString();\n        if(mFileRolloverCounter == 2)\n        {\n            filename = filename.replace(\".tmp\", \"_2.tmp\");\n        }\n        else\n        {\n            Matcher m = FILENAME_PATTERN.matcher(filename);\n            if(m.find())\n            {\n                StringBuilder sb = new StringBuilder();\n                sb.append(m.group(1));\n                sb.append(mFileRolloverCounter);\n                sb.append(m.group(3));\n                filename = sb.toString();\n            }\n        }\n        mFile = Paths.get(filename);\n    }\n\n    public static ByteBuffer getDataHeader()\n    {\n        ByteBuffer header = ByteBuffer.allocate(8);\n        header.put(DATA_CHUNK_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(RIFF_ID.getBytes());\n        header.putInt(INITIAL_TOTAL_LENGTH);\n        header.put(WAVE_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(24).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(FORMAT_CHUNK_ID.getBytes());\n        header.putInt(FORMAT_CHUNK_LENGTH);\n        header.putShort(FORMAT_UNCOMPRESSED_PCM);\n        header.putShort((short)format.getChannels());\n        header.putInt((int)format.getSampleRate());\n        int frameByteRate = format.getChannels() * format.getSampleSizeInBits() / 8;\n        int byteRate = (int)(format.getSampleRate() * frameByteRate);\n        header.putInt(byteRate);\n        header.putShort((short)frameByteRate);\n        header.putShort((short)format.getSampleSizeInBits());\n        header.position(0);\n        return header;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class WaveWriter implements AutoCloseable {\n    private final AudioFormat mAudioFormat;\n    private int mFileRolloverCounter;\n    private long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen;\n    private long mDataChunkSizeOffset;\n    private int mDataChunkSize;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        mFileRolloverCounter = 0;\n    }\n\n    public WaveWriter(AudioFormat format, Path file) {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException {\n        if (mFileChannel != null) {\n            mFileChannel.close();\n        }\n        mFileChannel = FileChannel.open(mFile, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);\n        writeHeader();\n    }\n\n    public void close() throws IOException {\n        if (mFileChannel != null) {\n            mFileChannel.close();\n        }\n    }\n\n    public void close(Path path) throws IOException {\n        if (mFileChannel != null) {\n            mFileChannel.close();\n        }\n        mFile = path;\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException {\n        if (!mDataChunkOpen) {\n            openDataChunk();\n        }\n        while (buffer.hasRemaining()) {\n            mFileChannel.write(buffer);\n            if (mMaxSize > 0 && mFileChannel.size() >= mMaxSize) {\n                rollover();\n            }\n        }\n    }\n\n    private void closeDataChunk() throws IOException {\n        if (mDataChunkOpen) {\n            updateDataChunkSize();\n            mDataChunkOpen = false;\n        }\n    }\n\n    private void openDataChunk() throws IOException {\n        if (!mDataChunkOpen) {\n            mDataChunkSize = 0;\n            mDataChunkSizeOffset = mFileChannel.position();\n            mFileChannel.position(mFileChannel.position() + 4); // Skip data chunk size field\n            mDataChunkOpen = true;\n        }\n    }\n\n    private void rollover() throws IOException {\n        closeDataChunk();\n        mFileRolloverCounter++;\n        updateFileName();\n        mFile = mFile.resolve(String.format(\"wave_%d.wav\", mFileRolloverCounter));\n        open();\n    }\n\n    private void updateTotalSize() throws IOException {\n        long fileSize = mFileChannel.size();\n        ByteBuffer header = getWaveHeader(mAudioFormat);\n        header.putInt(4); // Size of the file in bytes\n        mFileChannel.position(0);\n        mFileChannel.write(header);\n    }\n\n    private void updateDataChunkSize() throws IOException {\n        long fileSize = mFileChannel.size();\n        ByteBuffer header = getDataHeader();\n        header.putInt((int) (fileSize - mDataChunkSizeOffset - 4));\n        mFileChannel.position(mDataChunkSizeOffset);\n        mFileChannel.write(header);\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size) {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.putInt((int) size);\n        buffer.flip();\n        return buffer;\n    }\n\n    public static ByteBuffer getDataHeader() {\n        ByteBuffer header = ByteBuffer.allocate(8);\n        header.put((byte) 0x64); // 'd'\n        header.put((byte) 0x61); // 'a'\n        header.put((byte) 0x74; // 't'\n        header.put((byte) 0x61); // 'a'\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.flip();\n        return header;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format) {\n        ByteBuffer header = ByteBuffer.allocate(44);\n        header.put((byte) 0x52); // 'R'\n        header.put((byte) 0x49); // 'I'\n        header.put((byte) 0x46; // 'F'\n        header.put((byte) 0x46); // 'F'\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.putInt(36); // Size of the header in bytes\n        header.put((byte) 0x57); // 'W'\n        header.put((byte) 0x41); // 'A'\n        header.put((byte) 0x56); // 'V'\n        header.put((byte) 0x56); // 'V'\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.put((byte) 0x00); // ' '\n        header.putInt(0); // Offset to format chunk\n        header.putInt(0); // Size of format chunk\n        header.putInt(0); // Audio format\n        header.putShort((short) 0); // Number of channels\n        header.putShort((short) 0); // Sample rate\n        header.putInt(0); // Byte rate\n        header.putShort((short) 0); // Block align\n        header.putShort((short) 0); // Bits per sample\n        header.put((byte) 0x00); // Reserved\n        header.put((byte) 0x00); // Reserved\n        header.put((byte) 0x00); // Reserved\n        header.put((byte) 0x00); // Reserved\n        header.flip();\n        return header;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format) {\n        ByteBuffer header = ByteBuffer.allocate(18);\n        header.put((byte) 0x52); // 'R'\n        header.put((byte) 0x49); // 'I'\n        header.put((byte) 0x46; // 'F'\n        header.put((byte) 0x46); // 'F'\n        header.putInt(0); // Size of the format chunk\n        header.putInt(0); // Format tag\n        header.putShort((short) 0); // Number of channels\n        header.putShort((short) 0); // Sample rate\n        header.putInt(0); // Byte rate\n        header.putShort((short) 0); // Block align\n        header.putShort((short) 0); // Bits per sample\n        header.flip();\n        return header;\n    }\n\n    private void updateFileName() {\n        mFile = mFile.resolve(String.format(\"wave_%d.wav\", mFileRolloverCounter));\n    }\n\n    private void writeHeader() throws IOException {\n        ByteBuffer waveHeader = getWaveHeader(mAudioFormat);\n        mFileChannel.position(0);\n        mFileChannel.write(waveHeader);\n        ByteBuffer formatChunk = getFormatChunk(mAudioFormat);\n        mFileChannel.position(36);\n        mFileChannel.write(formatChunk);\n        openDataChunk();\n        updateTotalSize();\n    }\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.HostAndPort;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig;\n\n    public void setHostName(String hostName) {\n        this.hostName = hostName;\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public void setSentinelMaster(String sentinelMaster) {\n        this.sentinelMaster = sentinelMaster;\n    }\n\n    public void setRedisServers(List<RedisNode> redisServers) {\n        this.redisServers = redisServers;\n    }\n\n    public void setIsCluster(boolean isCluster) {\n        this.isCluster = isCluster;\n    }\n\n    public void setDbIndex(int dbIndex) {\n        this.dbIndex = dbIndex;\n    }\n\n    public void setShardInfo(JedisShardInfo shardInfo) {\n        this.shardInfo = shardInfo;\n    }\n\n    public void setPool(Pool<Jedis> pool) {\n        this.pool = pool;\n    }\n\n    public void setCluster(JedisCluster cluster) {\n        this.cluster = cluster;\n    }\n\n    public void setPoolConfig(JedisPoolConfig poolConfig) {\n        this.poolConfig = poolConfig;\n    }\n\n    public void init() {\n        if (isCluster) {\n            cluster = createCluster();\n        } else if (sentinelMaster != null) {\n            pool = createRedisSentinelPool();\n        } else {\n            pool = createRedisPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.close();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    public Jedis fetchJedisConnector() {\n        if (pool != null) {\n            return pool.getResource();\n        } else if (cluster != null) {\n            return cluster.getSlotKey().getJedis();\n        }\n        return null;\n    }\n\n    public Pool<Jedis> createPool() {\n        return createRedisPool();\n    }\n\n    public Pool<Jedis> createRedisSentinelPool() {\n        return new JedisPool(poolConfig, hostName, port, timeout, password, sentinelMaster);\n    }\n\n    public Pool<Jedis> createRedisPool() {\n        return new JedisPool(poolConfig, hostName, port, timeout, password, dbIndex);\n    }\n\n    public JedisCluster createCluster() {\n        List<HostAndPort> nodes = new ArrayList<>();\n        if (redisServers != null) {\n            for (RedisNode node : redisServers) {\n                nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n            }\n        }\n        return new JedisCluster(nodes, timeout, 1000, 1000, password, poolConfig);\n    }\n\n    public Jedis getJedisConnection() {\n        return fetchJedisConnector();\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.Protocol;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class JedisSharding {\n    private List<HostAndPort> shards;\n    private JedisClientConfig clientConfig;\n    private Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, new MurmurHash());\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = getShard(key);\n        if (jedis == null) {\n            return null;\n        }\n        return jedis.set(key, value);\n    }\n\n    public String get(String key) {\n        Jedis jedis = getShard(key);\n        if (jedis == null) {\n            return null;\n        }\n        return jedis.get(key);\n    }\n\n    public Object sendCommand(String commandName, Protocol.Command command, String... args) {\n        Jedis jedis = getShard(commandName);\n        if (jedis == null) {\n            return null;\n        }\n        return jedis.sendCommand(command, args);\n    }\n\n    public void close() {\n        // No-op as connections are managed per-operation\n    }\n\n    private Jedis getShard(String key) {\n        int index = getShardIndex(key);\n        if (index < 0 || index >= shards.size()) {\n            return null;\n        }\n        return new Jedis(shards.get(index).getHost(), shards.get(index).getPort(), clientConfig);\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        int index = (int) (hash % shards.size());\n        return index;\n    }\n\n    interface Hashing {\n        long hash(String key);\n    }\n\n    static class MurmurHash implements Hashing {\n        @Override\n        public long hash(String key) {\n            long hash = 0;\n            for (int i = 0; i < key.length(); i++) {\n                hash = (hash << 8) + (hash >>> 24) + key.charAt(i);\n            }\n            return hash;\n        }\n    }\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.JedisCluster;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager {\n    private JedisCluster redis;\n    private org.apache.logging.log4j.Logger log;\n    private ISerializer<Object> serializer;\n\n    public JedisClusterCacheManager(JedisCluster redis, ISerializer<Object> serializer) {\n        this.redis = redis;\n        this.serializer = serializer;\n    }\n\n    public IRedis getRedis() {\n        return redis;\n    }\n\n    public void close() {\n        if (redis != null) {\n            redis.close();\n        }\n    }\n\n    public void set(byte[] key, byte[] value) {\n        redis.set(key, value);\n    }\n\n    public void setex(byte[] key, int expire, byte[] value) {\n        redis.setex(key, expire, value);\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value) {\n        redis.hset(key, field, value);\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value, int expire) {\n        redis.hset(key, field, value, expire);\n    }\n\n    public void mset(Collection<MSetParam> params) {\n        redis.mset(params);\n    }\n\n    public byte[] get(byte[] key) {\n        return redis.get(key);\n    }\n\n    public byte[] hget(byte[] key, byte[] field) {\n        return redis.hget(key, field);\n    }\n\n    public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type type, Set<CacheKeyTO> keys) {\n        return redis.mget(type, keys);\n    }\n\n    public void delete(Set<CacheKeyTO> keys) {\n        redis.delete(keys);\n    }\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Java class that implements a writable tile archive using Java NIO's FileChannel for efficient file operations, supporting both file-based and in-memory storage options.\n\nClass Description: WriteablePmtiles is a class that provides functionality to write and manage tile archive data using Java NIO channels. It supports writing to either a physical file or an in-memory buffer, tracks bytes written, and handles proper resource cleanup.\n\nAttributes:\n- out: [SeekableByteChannel] - The channel used for writing data (either FileChannel or in-memory channel)\n- bytesWritten: [LongSupplier] - A supplier that provides the number of bytes written to the channel\n\nMethods:\n- newWriteToFile(Path path) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to a physical file at the specified path\n- newWriteToMemory(SeekableInMemoryByteChannel bytes) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to an in-memory byte channel\n- finish(TileArchiveMetadata tileArchiveMetadata) -> [void] - Finalizes the archive by writing metadata and directory information\n- bytesWritten() -> [long] - Returns the number of bytes written to the archive\n- close() -> [void] - Closes the underlying channel and releases system resources\n- DeduplicatingTileWriter.write(TileEncodingResult encodingResult) -> [void] - Inner class method that writes tile data to the channel\n- DeduplicatingTileWriter.close() -> [void] - Inner class method that performs any necessary cleanup (none in this implementation)",
    "Canonical_solution": "import com.onthegomap.planetiler.util.FileUtils;\nimport com.onthegomap.planetiler.util.SeekableInMemoryByteChannel;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic final class WriteablePmtiles implements WriteableTileArchive {\n\n  private final SeekableByteChannel out;\n  private final LongSupplier bytesWritten;\n\n  private WriteablePmtiles(SeekableByteChannel channel, LongSupplier bytesWritten) throws IOException {\n    this.out = channel;\n    out.write(ByteBuffer.allocate(INIT_SECTION));\n    this.bytesWritten = bytesWritten;\n  }\n\n  public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n    return new WriteablePmtiles(\n      FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE),\n      () -> FileUtils.size(path)\n    );\n  }\n\n  public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) throws IOException {\n    return new WriteablePmtiles(bytes, () -> 0);\n  }\n\n  @Override\n  public void finish(TileArchiveMetadata tileArchiveMetadata) {\n    try {\n      out.write(ByteBuffer.wrap(jsonBytes));\n      out.write(ByteBuffer.wrap(directories.leaves));\n      out.position(0);\n      out.write(ByteBuffer.wrap(header.toBytes()));\n      out.write(ByteBuffer.wrap(directories.root));\n    } catch (IOException e) {\n      LOGGER.error(e.getMessage());\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    return bytesWritten.getAsLong();\n  }\n\n  @Override\n  public void close() throws IOException {\n    out.close();\n  }\n\n  private class DeduplicatingTileWriter implements TileWriter {\n    @Override\n    public void write(TileEncodingResult encodingResult) {\n      try {\n        out.write(ByteBuffer.wrap(data));\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      currentOffset += data.length;\n    }\n\n    @Override\n    public void close() {\n      // no cleanup needed.\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.util.function.LongSupplier;\n\npublic class WriteablePmtiles {\n    private final SeekableByteChannel out;\n    private final LongSupplier bytesWritten;\n\n    protected WriteablePmtiles(SeekableByteChannel out, LongSupplier bytesWritten) {\n        this.out = out;\n        this.bytesWritten = bytesWritten;\n    }\n\n    public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n        return new WriteablePmtiles(java.nio.file.Files.newFileChannel(path), () -> 0L);\n    }\n\n    public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) {\n        return new WriteablePmtiles(bytes, () -> 0L);\n    }\n\n    public void finish(TileArchiveMetadata tileArchiveMetadata) throws IOException {\n        // Write metadata and directory information\n    }\n\n    public long bytesWritten() {\n        return bytesWritten.getAsLong();\n    }\n\n    public void close() throws IOException {\n        out.close();\n    }\n\n    public static class DeduplicatingTileWriter {\n        private final WriteablePmtiles writer;\n\n        protected DeduplicatingTileWriter(WriteablePmtiles writer) {\n            this.writer = writer;\n        }\n\n        public void write(TileEncodingResult encodingResult) throws IOException {\n            // Write tile data to the channel\n        }\n\n        public void close() {\n            // Perform any necessary cleanup\n        }\n    }\n}"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Implement a distributed lock mechanism using Redis in Java to ensure thread-safe operations across multiple processes or systems.\n\nClass Description: RedisDistributeLock is a class that provides distributed locking functionality using Redis as the backend storage. It manages lock acquisition, release, and timeout handling to coordinate access to shared resources in a distributed environment.\n\nAttributes:\n- pool: [JedisPool] - The connection pool for Redis connections\n- jedisLock: [JedisLock] - The lock implementation instance\n- lockKey: [String] - The key used for locking in Redis\n- jedis: [Jedis] - The Redis client instance\n- timeoutMsecs: [int] - Maximum time to wait for lock acquisition in milliseconds\n- expireMsecs: [int] - Time after which the lock automatically expires in milliseconds\n\nMethods:\n- RedisDistributeLock([String] lockKey) -> [void] - Constructor with default timeout (3000ms) and expire (300000ms) values\n- RedisDistributeLock([String] lockKey, [int] timeoutMsecs, [int] expireMsecs) -> [void] - Constructor with custom timeout and expire values\n- wrap([Runnable] runnable) -> [void] - Executes the given runnable within the acquired lock context\n- lockRelease([JedisLock] lock, [Jedis] jedis) -> [void] - Releases the lock and closes the Redis connection\n- getPool() -> [JedisPool] - Static getter for the Redis connection pool\n- setPool([JedisPool] pool) -> [void] - Static setter for the Redis connection pool",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedisDistributeLock {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(RedisDistributeLock.class);\n\n    private static JedisPool pool;\n    private JedisLock jedisLock;\n    private String lockKey;\n    private Jedis jedis;\n    private int timeoutMsecs;\n    private int expireMsecs;\n\n    public RedisDistributeLock(String lockKey) {\n        this(lockKey, 3000, 300000);\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.jedis = pool.getResource();\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n        this.jedisLock = new JedisLock(jedis, lockKey.intern(), timeoutMsecs, expireMsecs);\n    }\n\n    public void wrap(Runnable runnable) {\n        long begin = System.currentTimeMillis();\n        try {\n            LOGGER.info(\"begin logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n            if (jedisLock.acquire()) {\n                runnable.run();\n            } else {\n                LOGGER.info(\"The time wait for lock more than [{}] ms \", timeoutMsecs);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(t.getMessage(), t);\n        } finally {\n            this.lockRelease(jedisLock, jedis);\n        }\n        LOGGER.info(\"[{}]cost={}\", lockKey, System.currentTimeMillis() - begin);\n    }\n\n    private void lockRelease(JedisLock lock, Jedis jedis) {\n        if (lock != null) {\n            try {\n                lock.release();\n            } catch (Exception e) {\n            }\n        }\n        if (jedis != null) {\n            jedis.close();\n        }\n        LOGGER.info(\"release logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static synchronized void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisDistributeLock {\n    private final JedisPool pool;\n    private final JedisLock jedisLock;\n    private final String lockKey;\n    private final Jedis jedis;\n    private final int timeoutMsecs;\n    private final int expireMsecs;\n\n    public RedisDistributeLock(String lockKey) {\n        this(lockKey, 3000, 300000);\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n        this.pool = RedisDistributeLock.getPool();\n        this.jedis = pool.getResource();\n        this.jedisLock = new JedisLock(jedis, lockKey, timeoutMsecs, expireMsecs);\n    }\n\n    public void wrap(Runnable runnable) {\n        try {\n            if (jedisLock.acquire()) {\n                try {\n                    runnable.run();\n                } finally {\n                    lockRelease(jedisLock, jedis);\n                }\n            } else {\n                throw new RuntimeException(\"Failed to acquire lock\");\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error in lock operation\", e);\n        }\n    }\n\n    private void lockRelease(JedisLock lock, Jedis jedis) {\n        if (lock.release()) {\n            try {\n                jedis.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.err.println(\"Failed to release lock\");\n        }\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a Redis Sentinel connection provider class in Java that manages connections to a Redis master node through Sentinel monitoring, including automatic failover handling.\n\nClass Description: SentineledConnectionProvider is a class that provides managed connections to a Redis master node in a Sentinel-monitored environment. It automatically discovers the current master through Sentinel nodes and maintains a connection pool to it. The class also includes a listener thread that monitors for master failover events and updates the connection pool accordingly.\n\nAttributes:\n- currentMaster: [HostAndPort] - The current master node's host and port\n- pool: [ConnectionPool] - The connection pool to the current master node\n- masterName: [String] - The name of the Redis master as configured in Sentinel\n- masterClientConfig: [JedisClientConfig] - Configuration for connections to the master node\n- sentinelClientConfig: [JedisClientConfig] - Configuration for connections to Sentinel nodes\n\nMethods:\n- SentineledConnectionProvider([String] masterName, [JedisClientConfig] masterClientConfig, [Set<HostAndPort>] sentinels, [JedisClientConfig] sentinelClientConfig) -> [void] - Constructor that initializes the connection provider with master name, configurations, and Sentinel nodes\n- getConnection() -> [Connection] - Retrieves a connection from the pool to the current master node\n- initMaster([HostAndPort] master) -> [void] - Initializes or updates the connection pool to the specified master node\n- initSentinels([Set<HostAndPort>] sentinels) -> [HostAndPort] - Discovers the current master node through Sentinel nodes\n- SentinelListener([HostAndPort] node) -> [void] - Nested class constructor for Sentinel listener thread\n- run() -> [void] - Main execution method of the Sentinel listener thread (overrides Thread.run())\n- shutdown() -> [void] - Shuts down the Sentinel listener thread",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\n\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SentineledConnectionProvider {\n\n  private static final Logger LOG = LoggerFactory.getLogger(SentineledConnectionProvider.class);\n\n  private volatile HostAndPort currentMaster;\n  private volatile ConnectionPool pool;\n  private final String masterName;\n  private final JedisClientConfig masterClientConfig;\n  private final JedisClientConfig sentinelClientConfig;\n\n  public SentineledConnectionProvider(String masterName, final JedisClientConfig masterClientConfig,\n      Set<HostAndPort> sentinels, final JedisClientConfig sentinelClientConfig) {\n    this.masterName = masterName;\n    this.masterClientConfig = masterClientConfig;\n    this.sentinelClientConfig = sentinelClientConfig;\n\n    HostAndPort master = initSentinels(sentinels);\n    initMaster(master);\n  }\n\n  public Connection getConnection() {\n    return pool.getResource();\n  }\n\n  private void initMaster(HostAndPort master) {\n    if (!master.equals(currentMaster)) {\n      currentMaster = master;\n      pool = new ConnectionPool(currentMaster, masterClientConfig);\n      LOG.info(\"Created connection pool to master at {}.\", master);\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n\n    for (HostAndPort sentinel : sentinels) {\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n\n        if (masterAddr == null || masterAddr.size() != 2) {\n          continue;\n        }\n\n        master = new HostAndPort(masterAddr.get(0), Integer.parseInt(masterAddr.get(1)));\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Could not get master address from {}.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored.\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where \" + masterName + \" is running.\");\n      }\n    }\n\n    return master;\n  }\n\n  protected class SentinelListener extends Thread {\n    protected final HostAndPort node;\n    protected volatile Jedis sentinelJedis;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public SentinelListener(HostAndPort node) {\n      this.node = node;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n\n      while (running.get()) {\n        try {\n          sentinelJedis = new Jedis(node, sentinelClientConfig);\n          sentinelJedis.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3 && masterName.equals(switchMasterMsg[0])) {\n                initMaster(new HostAndPort(switchMasterMsg[3], Integer.parseInt(switchMasterMsg[4])));\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            try {\n              Thread.sleep(5000);\n            } catch (InterruptedException se) {\n              LOG.error(\"Sleep interrupted.\", se);\n            }\n          }\n        } finally {\n          IOUtils.closeQuietly(sentinelJedis);\n        }\n      }\n    }\n\n    public void shutdown() {\n      running.set(false);\n      if (sentinelJedis != null) {\n        sentinelJedis.close();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class SentineledConnectionProvider {\n    private HostAndPort currentMaster;\n    private ConnectionPool pool;\n    private String masterName;\n    private JedisClientConfig masterClientConfig;\n    private JedisClientConfig sentinelClientConfig;\n    private Thread sentinelListener;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterClientConfig, Set<HostAndPort> sentinels, JedisClientConfig sentinelClientConfig) {\n        this.masterName = masterName;\n        this.masterClientConfig = masterClientConfig;\n        this.sentinelClientConfig = sentinelClientConfig;\n        initSentinels(sentinels);\n    }\n\n    public Connection getConnection() {\n        if (pool == null || pool.isEmpty()) {\n            initMaster(currentMaster);\n        }\n        return pool.getConnection();\n    }\n\n    public void initMaster(HostAndPort master) {\n        if (currentMaster != null && currentMaster.equals(master)) {\n            return;\n        }\n        currentMaster = master;\n        pool = new ConnectionPool(masterClientConfig, master);\n    }\n\n    public HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n        SentinelConnection sentinelConnection = new SentinelConnection(sentinels, sentinelClientConfig);\n        HostAndPort master = sentinelConnection.getMaster(this.masterName);\n        initMaster(master);\n        return master;\n    }\n\n    public static class SentinelListener extends Thread {\n        private final SentineledConnectionProvider provider;\n\n        public SentinelListener(SentineledConnectionProvider provider) {\n            this.provider = provider;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    HostAndPort newMaster = provider.initSentinels(provider.sentinelClientConfig.getSentinels());\n                    if (!newMaster.equals(provider.currentMaster)) {\n                        provider.currentMaster = newMaster;\n                        provider.pool.close();\n                        provider.pool = new ConnectionPool(provider.masterClientConfig, newMaster);\n                    }\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (sentinelListener != null) {\n            sentinelListener.interrupt();\n        }\n    }\n}"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with authentication support, including connection initialization, creation of different connection types, and proper resource cleanup.\n\nClass Description: The RedisConnectionManager class provides centralized management for Redis connections, supporting both standalone and cluster configurations with token-based authentication. It handles connection lifecycle management and provides methods to create different types of Redis connections.\n\nAttributes:\n\nclientOptions: [ClusterClientOptions] - Configuration options for Redis client connections\ncredentialsProvider: [TokenBasedRedisCredentialsProvider] - Provider for token-based authentication credentials\nclient: [RedisClient] - Client instance for standalone Redis connections\nclusterClient: [RedisClusterClient] - Client instance for Redis cluster connections\n\nMethods:\n\ninitializeConnection: [Name]([EntraIdTestContext testCtx]) -> [void] - Initializes Redis client instances with connection options and authentication configuration\ncreateStandaloneConnection: [Name]() -> [StatefulRedisConnection<String, String>] - Creates and returns a new standalone Redis connection\ncreateClusterConnection: [Name]() -> [StatefulRedisClusterConnection<String, String>] - Creates and returns a new Redis cluster connection\ncreatePubSubConnection: [Name]() -> [StatefulRedisPubSubConnection<String, String>] - Creates and returns a new Redis Pub/Sub connection\ncloseConnections: [Name]() -> [void] - Closes all active connections and releases resources",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.authentication.core.TokenBasedRedisCredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(1)).build())\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        TokenAuthConfig tokenAuthConfig = EntraIDTokenAuthConfigBuilder.builder().clientId(testCtx.getClientId())\n                .secret(testCtx.getClientSecret()).authority(testCtx.getAuthority()).scopes(testCtx.getRedisScopes())\n                .expirationRefreshRatio(0.0000001F).build();\n\n        credentialsProvider = TokenBasedRedisCredentialsProvider.create(tokenAuthConfig);\n\n        RedisURI uri = RedisURI.builder().withHost(testCtx.host()).withPort(testCtx.port())\n                .withAuthentication(credentialsProvider).build();\n\n        client = RedisClient.create(uri);\n        client.setOptions(clientOptions);\n\n        RedisURI clusterUri = RedisURI.builder().withHost(testCtx.clusterHost().get(0)).withPort(testCtx.clusterPort())\n                .withAuthentication(credentialsProvider).build();\n        clusterClient = RedisClusterClient.create(clusterUri);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (credentialsProvider != null) {\n            credentialsProvider.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n        if (clusterClient != null) {\n            clusterClient.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```cpp\n#include <redisom/RedisConnectionManager.h>\n#include <redisom/RedisClient.h>\n#include <redisom/RedisClusterClient.h>\n#include <redisom/StatefulRedisConnection.h>\n#include <redisom/StatefulRedisClusterConnection.h>\n#include <redisom/StatefulRedisPubSubConnection.h>\n#include <redisom/TokenBasedRedisCredentialsProvider.h>\n#include <redisom/ClusterClientOptions.h>\n\nnamespace redisom {\n\nRedisConnectionManager::RedisConnectionManager() {\n    clientOptions = std::make_shared<ClusterClientOptions>();\n    credentialsProvider = std::make_shared<TokenBasedRedisCredentialsProvider>();\n    client = nullptr;\n    clusterClient = nullptr;\n}\n\nvoid RedisConnectionManager::initializeConnection(EntraIdTestContext testCtx) {\n    // Initialize client with options and credentials\n    client = std::make_shared<RedisClient>(clientOptions);\n    clusterClient = std::make_shared<RedisClusterClient>(clientOptions);\n    credentialsProvider->initialize(testCtx);\n}\n\nStatefulRedisConnection<String, String> RedisConnectionManager::createStandaloneConnection() {\n    if (!client) {\n        throw std::runtime_error(\"Redis client not initialized\");\n    }\n    return client->connect();\n}\n\nStatefulRedisClusterConnection<String, String> RedisConnectionManager::createClusterConnection() {\n    if (!clusterClient) {\n        throw std::runtime_error(\"Redis cluster client not initialized\");\n    }\n    return clusterClient->connect();\n}\n\nStatefulRedisPubSubConnection<String, String> RedisConnectionManager::createPubSubConnection() {\n    if (!client) {\n        throw std::runtime_error(\"Redis client not initialized\");\n    }\n    return client->connectPubSub();\n}\n\nvoid RedisConnectionManager::closeConnections() {\n    if (client) {\n        client->close();\n    }\n    if (clusterClient) {\n        clusterClient->close();\n    }\n}\n\n} // namespace redisom\n```"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The SimpleConsumer class provides a basic implementation of a RocketMQ push consumer. It handles the setup, subscription, message listening, and lifecycle management of a consumer instance. The class allows for easy configuration of consumer group, NameServer address, topic subscription, and message processing logic.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- SimpleConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a message listener to handle incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n- createDefaultListener() -> MessageListenerConcurrently - Static factory method that creates a default message listener which prints received messages",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\n\npublic class SimpleConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public SimpleConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static MessageListenerConcurrently createDefaultListener() {\n        return new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg.getKeys() + \":\" + new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class SimpleConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public SimpleConsumer(String consumerGroup, String namesrvAddr) {\n        this.consumer = new DefaultMQPushConsumer(consumerGroup);\n        this.consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        this.consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        this.consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        this.consumer.start();\n    }\n\n    public void shutdown() {\n        this.consumer.shutdown();\n    }\n\n    public static MessageListenerConcurrently createDefaultListener() {\n        return new MessageListenerConcurrently() {\n            @Override\n            public ConsumeResult consumeMessage(List<MessageExt> messages, ConsumeContext context) {\n                for (MessageExt message : messages) {\n                    System.out.println(\"Received message: \" + new String(message.getBody()));\n                }\n                return ConsumeResult.CONSUME_SUCCESS;\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to monitor and handle offset moved events in a message queue system.\n\nClass Description: The RocketMQConsumer class is designed to consume messages from a RocketMQ broker, specifically monitoring for offset moved events. It uses a push-based consumption model with a single-threaded listener to process messages. The class handles message subscription, listener configuration, and consumer lifecycle management.\n\nAttributes:\n- defaultMQPushConsumer: DefaultMQPushConsumer - The main consumer instance that connects to RocketMQ and handles message consumption\n- monitorListener: MonitorListener - (Assumed from context) Listener interface for reporting delete message events\n\nMethods:\n- RocketMQConsumer(RPCHook, String) -> void - Constructor that initializes the consumer with RPC hook and NameServer address\n- generateInstanceName(String) -> String - Generates a unique instance name for the consumer\n- configureMessageListener() -> void - Configures the message listener to handle incoming messages\n- subscribeToTopic() -> void - Subscribes to the offset moved event topic\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n\n    public RocketMQConsumer(RPCHook rpcHook, String namesrvAddr) throws MQClientException {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(MixAll.MONITOR_CONSUMER_GROUP, rpcHook);\n        this.defaultMQPushConsumer.setNamesrvAddr(namesrvAddr);\n        this.defaultMQPushConsumer.setInstanceName(generateInstanceName(namesrvAddr));\n        this.defaultMQPushConsumer.setConsumeThreadMin(1);\n        this.defaultMQPushConsumer.setConsumeThreadMax(1);\n        \n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String namesrvAddr) {\n        return \"MonitorService_\" + (System.currentTimeMillis() + RandomUtils.nextInt(0, Integer.MAX_VALUE) + namesrvAddr).hashCode();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                try {\n                    OffsetMovedEvent ome =\n                        OffsetMovedEvent.decode(msgs.get(0).getBody(), OffsetMovedEvent.class);\n\n                    DeleteMsgsEvent deleteMsgsEvent = new DeleteMsgsEvent();\n                    deleteMsgsEvent.setOffsetMovedEvent(ome);\n                    deleteMsgsEvent.setEventTimestamp(msgs.get(0).getStoreTimestamp());\n\n                    MonitorService.this.monitorListener.reportDeleteMsgsEvent(deleteMsgsEvent);\n                } catch (Exception e) {\n                }\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    private void subscribeToTopic() throws MQClientException {\n        this.defaultMQPushConsumer.subscribe(TopicValidator.RMQ_SYS_OFFSET_MOVED_EVENT, \"*\");\n    }\n\n    public void start() throws MQClientException {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.client.exception.MQClientException;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private MonitorListener monitorListener;\n\n    public RocketMQConsumer(RPCHook rpcHook, String nameServer) {\n        defaultMQPushConsumer = new DefaultMQPushConsumer(generateInstanceName(nameServer));\n        defaultMQPushConsumer.setNamesrvAddr(nameServer);\n        if (rpcHook != null) {\n            defaultMQPushConsumer.setRPCHook(rpcHook);\n        }\n    }\n\n    private String generateInstanceName(String nameServer) {\n        return \"RocketMQConsumer_\" + nameServer.hashCode();\n    }\n\n    public void configureMessageListener() {\n        defaultMQPushConsumer.setMessageListener((MessageExt msg, boolean isOK) -> {\n            if (isOK) {\n                monitorListener.onMessageReceived(msg);\n            } else {\n                monitorListener.onMessageFailed(msg);\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void subscribeToTopic() {\n        defaultMQPushConsumer.subscribe(\"offset_moved_event\", \"*\");\n    }\n\n    public void start() throws MQClientException {\n        defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        if (defaultMQPushConsumer != null) {\n            defaultMQPushConsumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer capable of subscribing to topics, filtering messages, and processing them asynchronously.\n\nClass Description: The RocketMQConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify consumer setup and message handling. It supports both tag-based and SQL92 filtering, configurable threading, and various RocketMQ features like message tracing and ACL.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n- topic: String - The topic to subscribe to\n- group: String - The consumer group name\n- threadCount: int - Number of threads for message processing\n- filterType: String - Type of message filtering (TAG or SQL92)\n- expression: String - Filter expression (either tag or SQL condition)\n- msgTraceEnable: boolean - Whether to enable message tracing\n- aclEnable: boolean - Whether to enable access control\n- clientRebalanceEnable: boolean - Whether to enable client-side rebalancing\n- rpcHook: RPCHook - Custom RPC hook for authentication\n\nMethods:\n- initialize(): void - Initializes the consumer with configured settings and subscribes to the topic\n- setMessageListener(MessageListenerConcurrently listener): void - Registers a message listener for concurrent message processing\n- start(): void - Starts the consumer to begin receiving messages\n- shutdown(): void - Gracefully shuts down the consumer\n- setNamesrvAddr(String namesrvAddr): void - Sets the NameServer address for broker discovery",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String topic, String group, int threadCount, String filterType, \n                          String expression, boolean msgTraceEnable, boolean aclEnable, \n                          boolean clientRebalanceEnable, RPCHook rpcHook) {\n        this.topic = topic;\n        this.group = group;\n        this.threadCount = threadCount;\n        this.filterType = filterType;\n        this.expression = expression;\n        this.msgTraceEnable = msgTraceEnable;\n        this.aclEnable = aclEnable;\n        this.clientRebalanceEnable = clientRebalanceEnable;\n        this.rpcHook = rpcHook;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(group, rpcHook, new AllocateMessageQueueAveragely(), msgTraceEnable, null);\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setClientRebalance(clientRebalanceEnable);\n\n        if (filterType == null || expression == null) {\n            consumer.subscribe(topic, \"*\");\n        } else {\n            if (ExpressionType.TAG.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.byTag(expr));\n            } else if (ExpressionType.SQL92.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.bySql(expr));\n            } else {\n                throw new IllegalArgumentException(\"Not support filter type! \" + filterType);\n            }\n        }\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.client.hook.RPCHook;\n\npublic class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String group, String topic) {\n        this.group = group;\n        this.topic = topic;\n        this.threadCount = 10;\n        this.filterType = \"TAG\";\n        this.msgTraceEnable = false;\n        this.aclEnable = false;\n        this.clientRebalanceEnable = true;\n        this.rpcHook = null;\n        try {\n            consumer = new DefaultMQPushConsumer(group);\n            consumer.setNamesrvAddr(\"localhost:9876\");\n            consumer.setMessageTraceEnabled(msgTraceEnable);\n            consumer.setAccessControlEnabled(aclEnable);\n            consumer.setClientRebalanceEnable(clientRebalanceEnable);\n            if (rpcHook != null) {\n                consumer.setRPCHook(rpcHook);\n            }\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void initialize() throws MQClientException {\n        consumer.subscribe(topic, expression);\n        consumer.setConsumeThreadNums(threadCount);\n        consumer.start();\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.setMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void setFilterType(String filterType) {\n        this.filterType = filterType;\n    }\n\n    public void setExpression(String expression) {\n        this.expression = expression;\n    }\n\n    public void setMsgTraceEnable(boolean msgTraceEnable) {\n        this.msgTraceEnable = msgTraceEnable;\n    }\n\n    public void setAclEnable(boolean aclEnable) {\n        this.aclEnable = aclEnable;\n    }\n\n    public void setClientRebalanceEnable(boolean clientRebalanceEnable) {\n        this.clientRebalanceEnable = clientRebalanceEnable;\n    }\n\n    public void setRpcHook(RPCHook rpcHook) {\n        this.rpcHook = rpcHook;\n    }\n}\n```"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to asynchronously receive and process messages from a specified topic.\n\nClass Description: The PushConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify message consumption. It handles consumer initialization, topic subscription, message listening, and lifecycle management.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n\nMethods:\n- PushConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) -> void - Sets the consumption starting point (e.g., from last offset or earliest)\n- setConsumeTimestamp(String consumeTimestamp) -> void - Sets the timestamp for consumption starting point\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a callback for processing received messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nNested Class:\n- SimpleMessageListener: MessageListenerConcurrently - A basic message listener implementation that prints received messages and returns success status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {\n        consumer.setConsumeFromWhere(consumeFromWhere);\n    }\n\n    public void setConsumeTimestamp(String consumeTimestamp) {\n        consumer.setConsumeTimestamp(consumeTimestamp);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class PushConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) {\n        this.consumer = new DefaultMQPushConsumer(consumerGroup);\n        this.consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        this.consumer.subscribe(topic, subExpression);\n    }\n\n    public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {\n        this.consumer.setConsumeFromWhere(consumeFromWhere);\n    }\n\n    public void setConsumeTimestamp(String consumeTimestamp) {\n        this.consumer.setConsumeTimestamp(consumeTimestamp);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        this.consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        this.consumer.start();\n    }\n\n    public void shutdown() {\n        this.consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeResult consumeMessage(List<MessageExt> messages, ConsumeContext context) {\n            for (MessageExt message : messages) {\n                System.out.println(\"Received message: \" + new String(message.getBody()));\n            }\n            return ConsumeResult.CONSUME_SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"test_group\");\nconsumer.setNamesrvAddr(\"127.0.0.1:9876\");\nconsumer.subscribe(\"test_topic\", \"*\");\nconsumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {\n    for (MessageExt msg : list) {\n        try {\n            // Process message\n            System.out.println(\"Received message: \" + new String(msg.getBody()));\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        } catch (Exception e) {\n            if (returnFailedHalf) {\n                return ConsumeConcurrentlyStatus.RETRY;\n            } else {\n                return ConsumeConcurrentlyStatus.FAILURE;\n            }\n        }\n    }\n});\nconsumer.start();"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getRocketMQ().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getRocketMQ().getNameServer());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.LAST_OFFSET);\n\n        String[] topics = paascloudProperties.getRocketMQ().getTopics().split(\",\");\n        for (String topic : topics) {\n            consumer.subscribe(topic, \"*\");\n        }\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n\n        consumer.setConcurrentSendOnlineNumber(paascloudProperties.getRocketMQ().getConcurrentSendOnlineNumber());\n        consumer.setVipChannelEnabled(paascloudProperties.getRocketMQ().isVipChannelEnabled());\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        return consumer;\n    }\n}"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ ordered message consumer using the DefaultMQPushConsumer for push-based message consumption with ordered message processing.\n\nClass Description: The RocketMQOrderedConsumer class provides functionality to consume messages from RocketMQ in an ordered manner. It handles consumer initialization, topic subscription, message listening, and consumer lifecycle management. The class includes an inner class for ordered message processing.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The main consumer instance that handles message consumption from RocketMQ\n\nMethods:\n- RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) -> void - Constructor that initializes the consumer with NameServer address and consumer group\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerOrderly listener) -> void - Registers an ordered message listener for processing incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nInner Class:\n- OrderedMessageListener: MessageListenerOrderly - Implements ordered message processing logic with consumeMessage method\n  - consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) -> ConsumeOrderlyStatus - Processes a batch of messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQOrderedConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            System.out.printf(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeOrderlyStatus.SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQOrderedConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) {\n        this.consumer = new DefaultMQPushConsumer(consumerGroup);\n        this.consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        this.consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        this.consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        this.consumer.start();\n    }\n\n    public void shutdown() {\n        this.consumer.shutdown();\n    }\n\n    public static class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            // Process messages in ordered manner\n            for (MessageExt msg : msgs) {\n                // Implement your message processing logic here\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeOrderlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RocketMQConsumer {\n    private final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        if (rpcHook != null) {\n            defaultMQPushConsumer.setRPCHook(rpcHook);\n        }\n    }\n\n    public void startConsumer() {\n        try {\n            defaultMQPushConsumer.subscribe(topicName, \"*\");\n            defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n                @Override\n                public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n                    for (MessageExt message : messages) {\n                        log.info(\"Received message: {}\", new String(message.getBody()));\n                        // Process the message here\n                    }\n                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                }\n            });\n            defaultMQPushConsumer.start();\n            log.info(\"RocketMQ consumer started successfully.\");\n        } catch (Exception e) {\n            log.error(\"Failed to start RocketMQ consumer\", e);\n        }\n    }\n\n    public void shutdown() {\n        if (defaultMQPushConsumer != null) {\n            defaultMQPushConsumer.shutdown();\n            log.info(\"RocketMQ consumer shut down successfully.\");\n        }\n    }\n\n    public SendMessageRequestHeader buildSendMessageRequestHeader(Message message, String topic, int delayLevel) {\n        // Implementation for building message request headers\n        return null;\n    }\n}"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to both regular topics and LMQ (Light Message Queue) topics. The producer should support initialization, message sending with custom properties, and proper shutdown.\n\nClass Description: The LMQProducer class is a RocketMQ producer implementation that demonstrates how to send messages to both regular topics and LMQ topics. It handles producer lifecycle management and message sending with multi-dispatch capabilities.\n\nAttributes:\n- PRODUCER_GROUP: String - The name of the producer group\n- DEFAULT_NAMESRVADDR: String - Default NameServer address (format: \"ip:port\")\n- TOPIC: String - The main topic to which messages will be sent\n- TAG: String - The tag for messages\n- LMQ_TOPIC_1: String - First LMQ topic (prefixed with MixAll.LMQ_PREFIX)\n- LMQ_TOPIC_2: String - Second LMQ topic (prefixed with MixAll.LMQ_PREFIX)\n- producer: DefaultMQProducer - The RocketMQ producer instance\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the producer by creating a new DefaultMQProducer instance, setting the NameServer address, and starting the producer\n- sendMessage(int messageId) throws Exception -> SendResult - Creates and sends a message with the given ID, setting message keys and LMQ dispatch properties\n- shutdown() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class LMQProducer {\n    public static final String PRODUCER_GROUP = \"ProducerGroupName\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String TAG = \"TagA\";\n    public static final String LMQ_TOPIC_1 = MixAll.LMQ_PREFIX + \"123\";\n    public static final String LMQ_TOPIC_2 = MixAll.LMQ_PREFIX + \"456\";\n\n    private DefaultMQProducer producer;\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        producer.start();\n    }\n\n    public SendResult sendMessage(int messageId) throws Exception {\n        Message msg = new Message(TOPIC, TAG, (\"Hello RocketMQ \" + messageId).getBytes(RemotingHelper.DEFAULT_CHARSET));\n        msg.setKeys(\"Key\" + messageId);\n        msg.putUserProperty(MessageConst.PROPERTY_INNER_MULTI_DISPATCH,\n            String.join(MixAll.LMQ_DISPATCH_SEPARATOR, LMQ_TOPIC_1, LMQ_TOPIC_2));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class LMQProducer {\n    private static final String PRODUCER_GROUP = \"LMQ_PRODUCER_GROUP\";\n    private static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    private static final String TOPIC = \"TEST_TOPIC\";\n    private static final String TAG = \"TEST_TAG\";\n    private static final String LMQ_TOPIC_1 = MixAll.LMQ_PREFIX + \"LMQ_TOPIC_1\";\n    private static final String LMQ_TOPIC_2 = MixAll.LMQ_PREFIX + \"LMQ_TOPIC_2\";\n    private DefaultMQProducer producer;\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        producer.start();\n    }\n\n    public SendResult sendMessage(int messageId) throws Exception {\n        String messageKey = \"MSG_\" + messageId;\n        String msgBody = \"Message ID: \" + messageId;\n        Message message = new Message(TOPIC, TAG, msgBody.getBytes(RemoteMessageListener.UTF_8));\n        message.putUserProperty(\"LMQ_TOPIC_1\", \"true\");\n        message.putUserProperty(\"LMQ_TOPIC_2\", \"true\");\n\n        SendResult sendResult = producer.send(message);\n        return sendResult;\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: Create a Java class that implements a simple RocketMQ producer to send messages to a specified topic.\n\nClass Description: The SimpleProducer class provides basic functionality to send messages to a RocketMQ broker. It handles producer initialization, message sending, and cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- SimpleProducer(String producerGroup, String namesrvAddr) -> Constructor - Initializes the producer with the specified producer group and NameServer address\n- start() -> void - Starts the producer instance to begin sending messages\n- sendMessage(String topic, String tags, String keys, byte[] body) -> void - Creates and sends a message with the specified topic, tags, keys, and body content\n- shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) throws Exception {\n        Message msg = new Message(topic, tags, keys, body);\n        producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        try {\n            producer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) {\n        try {\n            Message message = new Message(topic, tags, keys.getBytes(), body);\n            producer.send(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        try {\n            producer.shutdown();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Create a Java function that demonstrates how to use RocketMQ's producer to send messages to a specified topic with ACL authentication.\n\nFunction Description: This function creates and configures a RocketMQ producer with ACL authentication, sends multiple messages to a specified topic, and then shuts down the producer. It demonstrates the basic workflow of message production including producer initialization, message creation, message sending, and resource cleanup.\n\nInput: None (The function uses predefined constants for configuration)\n\nOutput: None (The function prints send results to console but doesn't return any value)\n\nMethods:\n\nproducer: producer() -> void - Main function that creates and configures the producer, sends messages, and handles shutdown\ngetAclRPCHook: getAclRPCHook() -> RPCHook - Helper function that creates and returns an ACL authentication hook using predefined credentials",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.remoting.RPCHook;\n\nprivate static final String ACL_ACCESS_KEY = \"RocketMQ\";\nprivate static final String ACL_SECRET_KEY = \"1234567\";\n\npublic static void producer() throws MQClientException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\", getAclRPCHook());\n    producer.setNamesrvAddr(\"127.0.0.1:9876\");\n    producer.start();\n\n    for (int i = 0; i < 128; i++)\n        try {\n            {\n                Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n                SendResult sendResult = producer.send(msg);\n                System.out.printf(\"%s%n\", sendResult);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    producer.shutdown();\n}\n\nstatic RPCHook getAclRPCHook() {\n    return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.impl.RPCHook;\nimport org.apache.rocketmq.client.impl.rpctype.ACLCheckRequest;\nimport org.apache.rocketmq.client.impl.rpctype.ACLCheckResponse;\n\npublic class RocketMQProducer {\n\n    private static final String PRODUCER_NAME = \"ACLProducer\";\n    private static final String TOPIC = \"TestTopic\";\n\n    public void producer() {\n        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_NAME);\n        try {\n            // Configure ACL hook\n            RPCHook aclRPCHook = getAclRPCHook();\n            producer.setRPCHook(aclRPCHook);\n\n            // Start the producer\n            producer.start();\n\n            // Send messages\n            for (int i = 0; i < 3; i++) {\n                Message message = new Message(TOPIC, \"TagA\", (\"Hello RocketMQ \" + i).getBytes());\n                producer.send(message);\n                System.out.println(\"Message sent: \" + (\"Hello RocketMQ \" + i));\n            }\n        } catch (MQClientException e) {\n            System.err.println(\"Send message failed: \" + e.getMessage());\n        } finally {\n            // Shutdown the producer\n            if (producer != null) {\n                producer.shutdown();\n            }\n        }\n    }\n\n    private RPCHook getAclRPCHook() {\n        return new RPCHook() {\n            @Override\n            public void invokeRPCBeforeSend(RPCHook.Context context) {\n                // Custom ACL logic can be implemented here\n            }\n\n            @Override\n            public void invokeRPCAfterSend(RPCHook.Context context, Object response) {\n                // Handle response after sending\n            }\n\n            @Override\n            public void processRequest(ACLCheckRequest request, ACLCheckResponse response) {\n                // Implement ACL check logic\n                response.setAuthorized(true);\n            }\n        };\n    }\n}\n```"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer to send messages to a RocketMQ broker.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for sending messages to a RocketMQ message broker. It handles producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> void - Constructor that initializes the producer with a producer group and NameServer address. Starts the producer instance.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Creates and sends a message to the specified topic with given tags and keys. Returns the send result containing message status.\n- shutdown() -> void - Shuts down the producer instance and releases resources.\n\nInput:\n- Constructor parameters:\n  - producerGroup: String - The group name of the producer\n  - namesrvAddr: String - The address of the NameServer\n- sendMessage parameters:\n  - topic: String - The topic to send the message to\n  - tags: String - Tags for message filtering\n  - keys: String - The business key of the message\n  - body: String - The message content\n\nOutput:\n- sendMessage returns: SendResult - Contains information about the message sending operation\n- shutdown returns: void",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class RocketMQProducer {\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) {\n        Message message = new Message(topic, tags, keys, body.getBytes());\n        return producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making synchronous and asynchronous HTTP requests, specifically designed for interacting with the Broadcastify API.\n\nClass Description: The BroadcastifyHttpClient class provides methods for testing API connections and sending asynchronous requests to the Broadcastify service. It uses Java's HttpClient for HTTP/2 communication with configurable timeout and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection](BroadcastifyCallConfiguration configuration) -> String - Tests the connection to the Broadcastify API by sending a synchronous multipart/form-data POST request with API key, system ID, and test flag. Returns the response body with status code or error message.\n- sendAsyncRequest: [sendAsyncRequest](HttpRequest request) -> void - Sends an HTTP request asynchronously and handles the response or error in a completion callback. Successful responses (status 200) and errors are handled separately.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class BroadcastifyHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        BroadcastifyCallBuilder bodyBuilder = new BroadcastifyCallBuilder();\n        bodyBuilder.addPart(FormField.API_KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM_ID, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((response, throwable) -> {\n                if(throwable != null || response.statusCode() != 200) {\n                    if(!(throwable instanceof IOException || throwable instanceof CompletionException)) {\n                        // Handle non-I/O errors\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class BroadcastifyHttpClient {\n    private final HttpClient mHttpClient;\n\n    public BroadcastifyHttpClient() {\n        mHttpClient = HttpClient.newHttpClient()\n                .newBuilder()\n                .followRedirects(java.net.http.Redirect.NORMAL)\n                .connectTimeout(Duration.ofSeconds(20))\n                .build();\n    }\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https://api.broadcastify.com/v1/test\"))\n                .header(\"Authorization\", \"Bearer \" + configuration.getApiKey())\n                .header(\"X-System-ID\", configuration.getSystemId())\n                .POST(HttpRequest.BodyPublishers.ofString(\"test=true\"))\n                .build();\n\n        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        return response.body();\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        CompletableFuture.runAsync(() -> {\n            try {\n                HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                if (response.statusCode() == 200) {\n                    System.out.println(\"Success: \" + response.body());\n                } else {\n                    System.out.println(\"Error: \" + response.statusCode() + \" - \" + response.body());\n                }\n            } catch (Exception e) {\n                System.err.println(\"Request failed: \" + e.getMessage());\n            }\n        });\n    }\n}"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with a given tag. The class should handle producer initialization, message sending, and resource cleanup.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It manages the producer lifecycle (startup and shutdown) and provides a method to send messages to a RocketMQ broker.\n\nAttributes:\n- producer: DefaultMQProducer - The underlying RocketMQ producer instance that handles message sending operations\n\nMethods:\n- Constructor: Producer(String producerGroup, String namesrvAddr) -> void - Initializes a new producer instance with the specified producer group and NameServer address\n- start: start() -> void - Starts the producer instance to begin sending messages\n- sendMessage: sendMessage(String topic, String tag, String messageBody) -> SendResult - Creates and sends a message to the specified topic with the given tag and body\n- shutdown: shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) throws MQClientException {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tag, String messageBody) throws Exception {\n        Message msg = new Message(topic, \n                                tag,\n                                messageBody.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tag, String messageBody) throws MQClientException {\n        producer.setMessageModel(org.apache.rocketmq.client.producer.SendMode.SYNC_SEND);\n        return producer.send(topic, tag, messageBody.getBytes());\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}\n```"
  },
  {
    "Task_id": 395,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to specified topics with callback handling for success and failure cases.\n\nClass Description: RMQAsyncSendProducer is a RocketMQ asynchronous message producer that sends messages to a specified topic and handles responses through callbacks. It tracks successful sends and exceptions, and provides methods for waiting for responses and shutting down the producer.\n\nAttributes:\n- nsAddr: String - The NameServer address for RocketMQ\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- sendCallback: SendCallback - Callback handler for message send results\n- successSendResult: List<SendResult> - Thread-safe list of successful send results\n- exceptionMsgCount: AtomicInteger - Counter for messages that failed to send\n- msgSize: int - The number of messages to send\n- logger: Logger - SLF4J logger instance\n- topic: String - The topic to which messages will be sent (inherited from AbstractMQProducer)\n- msgBodys: [Data Structure] - Stores message bodies (inherited from AbstractMQProducer)\n- originMsgs: [Data Structure] - Stores original messages (inherited from AbstractMQProducer)\n\nMethods:\n- RMQAsyncSendProducer(String nsAddr, String topic) -> void - Constructor that initializes the producer with NameServer address and topic\n- create() -> void - Creates and configures the DefaultMQProducer instance\n- start() -> void - Starts the producer instance\n- asyncSend(Object msg) -> void - Asynchronously sends a single message\n- asyncSend(int msgSize) -> void - Asynchronously sends multiple messages (quantity specified by msgSize)\n- asyncSend(Object msg, MessageQueueSelector selector, Object arg) -> void - Asynchronously sends a message with queue selection\n- waitForResponse(int timeoutMills) -> void - Waits for all responses until timeout\n- shutdown() -> void - Shuts down the producer (overrides AbstractMQProducer method)",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.test.clientinterface.AbstractMQProducer;\nimport org.apache.rocketmq.test.sendresult.ResultWrapper;\nimport org.apache.rocketmq.test.util.RandomUtil;\nimport org.apache.rocketmq.test.util.TestUtil;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private static Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n    private String nsAddr = null;\n    private DefaultMQProducer producer = null;\n    private SendCallback sendCallback = null;\n    private List<SendResult> successSendResult = Collections.synchronizedList(new ArrayList<SendResult>());\n    private AtomicInteger exceptionMsgCount = new AtomicInteger(0);\n    private int msgSize = 0;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n            }\n            @Override\n            public void onException(Throwable throwable) {\n                exceptionMsgCount.getAndIncrement();\n            }\n        };\n        create();\n        start();\n    }\n\n    private void create() {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(RandomUtil.getStringByUUID());\n        producer.setInstanceName(RandomUtil.getStringByUUID());\n        if (nsAddr != null) {\n            producer.setNamesrvAddr(nsAddr);\n        }\n    }\n\n    private void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            logger.error(\"producer start failed!\");\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        for (int i = 0; i < msgSize; i++) {\n            Message msg = new Message(topic, RandomUtil.getStringByUUID().getBytes(StandardCharsets.UTF_8));\n            this.asyncSend(msg);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, selector, arg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        long startTime = System.currentTimeMillis();\n        while (this.successSendResult.size() != this.msgSize) {\n            if (System.currentTimeMillis() - startTime < timeoutMills) {\n                TestUtil.waitForMonment(100);\n            } else {\n                logger.info(\"timeout but still not recv all response!\");\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RMQAsyncSendProducer {\n    private String nsAddr;\n    private DefaultMQProducer producer;\n    private SendCallback sendCallback;\n    private List<SendResult> successSendResult;\n    private AtomicInteger exceptionMsgCount;\n    private int msgSize;\n    private Logger logger;\n    private String topic;\n    private Object[] msgBodys;\n    private Object[] originMsgs;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        this.nsAddr = nsAddr;\n        this.topic = topic;\n    }\n\n    public void create() {\n        producer = new DefaultMQProducer(\"RMQAsyncSendProducer\");\n        producer.setNamesrvAddr(nsAddr);\n        producer.setTopic(topic);\n        successSendResult = java.util.Collections.synchronizedList(java.util.ArrayList.of());\n        exceptionMsgCount = new AtomicInteger(0);\n        logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void asyncSend(Object msg) {\n        producer.send(msg, sendCallback);\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        for (int i = 0; i < msgSize; i++) {\n            asyncSend(msgBodys[i]);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        producer.send(msg, selector, arg, sendCallback);\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        try {\n            Thread.sleep(timeoutMills);\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted while waiting for response\", e);\n        }\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 396,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to a specified topic with tags and keys, and handling success/failure callbacks.\n\nClass Description: AsyncProducer is a RocketMQ asynchronous message producer class that initializes a producer instance, sends messages asynchronously to a specified topic, and provides shutdown capability. It handles message sending callbacks for success and failure scenarios.\n\nAttributes:\nproducer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages\n\nMethods:\nAsyncProducer: [Constructor](String producerGroup, String namesrvAddr) -> void - Initializes the producer with a producer group name and NameServer address, sets retry policy for async sends, and starts the producer instance\nsendAsyncMessage: [Method](String topic, String tags, String keys, String body) -> void - Creates and sends an asynchronous message to the specified topic with given tags and keys, using the provided message body\nshutdown: [Method]() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\n\npublic class AsyncProducer {\n\n    private DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendAsyncFailed(0);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) throws UnsupportedEncodingException {\n        Message msg = new Message(topic, \n                                tags, \n                                keys, \n                                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        try {\n            producer.send(msg, new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    System.out.printf(\"OK %s %n\", sendResult.getMsgId());\n                }\n\n                @Override\n                public void onException(Throwable e) {\n                    System.out.printf(\"Exception %s %n\", e);\n                    e.printStackTrace();\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "DefaultMQProducer producer = new DefaultMQProducer(\"AsyncProducerGroup\");\nproducer.setNamesrvAddr(\"127.0.0.1:9876\");\nproducer.setRetryTimesWhenSendFailed(5);\nproducer.start();\n\npublic void sendAsyncMessage(String topic, String tags, String keys, String body) {\n    Message msg = new Message(topic, tags, keys.getBytes(), body.getBytes());\n    producer.send(msg, new SendCallback() {\n        @Override\n        public void onSuccess(SendResult sendResult) {\n            System.out.println(\"Message sent successfully: \" + sendResult.getMsgId());\n        }\n\n        @Override\n        public void onFailure(SendResult sendResult) {\n            System.out.println(\"Message send failed: \" + sendResult.getMsgId());\n        }\n    });\n}\n\npublic void shutdown() {\n    producer.shutdown();\n}"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "import org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport org.apache.mina.filter.time.TimedClientHandler;\nimport org.apache.mina.filter.codec.Decoder;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.codec.serialization.StringEncoder;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.time.TickDecoder;\nimport"
  },
  {
    "Task_id": 399,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends data to the server, and properly closes the connection.\n\nClass Description: The `TcpClient` class provides functionality to connect to a TCP server, send data to it, and manage the connection lifecycle. It encapsulates the socket and output stream for communication.\n\nAttributes:\n- socket: Socket - The socket object used for the TCP connection\n- out: OutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n- sendData(String data) -> void - Converts the input string to UTF-8 bytes and sends it to the server\n- close() -> void - Closes the output stream and socket connection",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        out = socket.getOutputStream();\n    }\n\n    public void sendData(String data) throws IOException {\n        byte[] outputBytes = data.getBytes(\"UTF-8\");\n        out.write(outputBytes);\n        out.flush();\n    }\n\n    public void close() throws IOException {\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) throws Exception {\n        socket = new Socket(host, port);\n        out = socket.getOutputStream();\n    }\n\n    public void sendData(String data) throws Exception {\n        out.write(data.getBytes(StandardCharsets.UTF_8));\n        out.flush();\n    }\n\n    public void close() throws Exception {\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Java class that facilitates HTTP communication using Java's HttpClient, supporting GET requests with configurable options and error handling.\n\nClass Description: The HttpCommunicator class provides functionality to send HTTP GET requests to specified URIs. It includes features like automatic redirect following and optional error suppression for non-critical requests. The class encapsulates the HttpClient instance and provides methods for request execution.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HttpClient instance used for all HTTP communications, configured to always follow redirects.\n\nMethods:\nsendGetRequest: [Name](String uri, Map<String, Object> attributes) -> String - Sends a GET request to the specified URI. The attributes map can contain optional parameters like \"optional-option\" to suppress exceptions for non-critical requests. Returns the response body as a string or empty string for optional failed requests.\n\nreadUri: [Name](URI uri, boolean optional) -> String - Internal method that constructs and executes the HTTP request. If optional is true, returns empty string on failure instead of throwing an exception.\n\nisHttpOrHttps: [Name](String url) -> boolean - Helper method to check if a URL string uses HTTP or HTTPS protocol. Returns true if the URL starts with \"http://\" or \"https://\".",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\n\npublic class HttpCommunicator {\n\n    private HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean isOptional = attributes.containsKey(\"optional-option\");\n        return readUri(URI.create(uri), isOptional);\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n        try {\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString()).body();\n        } catch (Exception e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url != null && (url.startsWith(\"http://\") || url.startsWith(\"https://\"));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\n\npublic class HttpCommunicator {\n    private final HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        if (!isHttpOrHttps(uri)) {\n            throw new IllegalArgumentException(\"URI must start with http:// or https://\");\n        }\n\n        return readUri(URI.create(uri), (Boolean) attributes.get(\"optional-option\"));\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        try {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(uri)\n                    .build();\n\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() >= 400) {\n                if (optional) {\n                    return \"\";\n                } else {\n                    throw new RuntimeException(\"HTTP error: \" + response.statusCode());\n                }\n            }\n\n            return response.body();\n        } catch (Exception e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(\"Error during HTTP communication\", e);\n            }\n        }\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url.startsWith(\"http://\") || url.startsWith(\"https://\");\n    }\n}"
  },
  {
    "Task_id": 401,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for establishing a connection to a server, sending messages, and closing the connection.\n\nClass Description: The `SocketConnectTest` class provides basic TCP client capabilities using Java's Socket and I/O classes. It handles connection establishment, message transmission, and resource cleanup.\n\nAttributes:\n- client: [Socket] - The socket object representing the connection to the server\n- writer: [Writer] - The output stream writer for sending data to the server\n\nMethods:\n- connect: [connect(String host, int port)] -> [void] - Establishes a connection to the specified server host and port, initializing the socket and writer\n- sendMessage: [sendMessage(String message)] -> [void] - Sends the specified message to the connected server\n- close: [close()] -> [void] - Closes the writer and socket connection, releasing system resources",
    "Canonical_solution": "import java.io.*;\nimport java.net.Socket;\n\npublic class SocketConnectTest {\n\n    private Socket client;\n    private Writer writer;\n\n    public void connect(String host, int port) throws IOException {\n        client = new Socket(host, port);\n        writer = new OutputStreamWriter(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws IOException {\n        writer.write(message);\n        writer.flush();\n    }\n\n    public void close() throws IOException {\n        writer.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketConnectTest {\n    private java.net.Socket client;\n    private java.io.Writer writer;\n\n    public void connect(String host, int port) throws Exception {\n        client = new java.net.Socket(host, port);\n        writer = new java.io.OutputStreamWriter(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws Exception {\n        writer.write(message);\n        writer.write(\"\\n\");\n        writer.flush();\n    }\n\n    public void close() throws Exception {\n        if (writer != null) {\n            writer.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 404,
    "Instruction": "Task Description: Create a TCP client class in Java that can establish a connection to a server, send requests, and receive responses.\n\nClass Description: The TcpClient class provides functionality to connect to a TCP server, send string requests, and receive string responses. It handles socket creation, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n- TAG: String - A constant for logging purposes (default value: \"HttpGet\")\n\nMethods:\n- TcpClient(String host, int port) -> None - Constructor that initializes the host and port attributes\n- sendRequest(String request) -> String - Sends the request string to the server and returns the response\n- readStream(InputStream in) -> String - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TcpClient {\n\n    private static final String TAG = \"HttpGet\";\n    private String host;\n    private int port;\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(host, port);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(request);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (UnknownHostException exception) {\n            exception.printStackTrace();\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuffer data = new StringBuffer();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TcpClient {\n    private String host;\n    private int port;\n    private static final String TAG = \"TcpClient\";\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) throws Exception {\n        try (java.net.Socket socket = new java.net.Socket(host, port)) {\n            java.io.OutputStream outputStream = socket.getOutputStream();\n            java.io.InputStream inputStream = socket.getInputStream();\n\n            outputStream.write(request.getBytes());\n            outputStream.flush();\n\n            return readStream(inputStream);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw e;\n        }\n    }\n\n    private String readStream(java.io.InputStream in) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n\n        while ((bytesRead = in.read(buffer)) != -1) {\n            sb.append(new String(buffer, 0, bytesRead));\n        }\n\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.util.regex.Pattern;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.prometheus.client.CollectorRegistry;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private final Logger logger;\n    private final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^0-9a-zA-Z._:-]\");\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.logger = LoggerFactory.getLogger(Graphite.class);\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (var socket = new java.net.Socket()) {\n            socket.connect(new InetSocketAddress(host, port), 5000);\n            var out = socket.getOutputStream();\n            for (var metric : registry.getMetrics()) {\n                String name = sanitize(metric.getName());\n                String value = sanitize(metric.getValue().toString());\n                String line = String.format(\"%s %s\\n\", name, value);\n                out.write(line.getBytes());\n            }\n        } catch (IOException e) {\n            logger.error(\"Failed to push metrics to Graphite server\", e);\n            throw e;\n        }\n    }\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        var thread = new Thread(new PushThread(registry, intervalSeconds));\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private String sanitize(String input) {\n        return INVALID_GRAPHITE_CHARS.matcher(input).replaceAll(\"\");\n    }\n\n    private static class PushThread implements Runnable {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        public PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (!Thread.currentThread().isInterrupted()) {\n                try {\n                    Graphite.this.push(registry);\n                    Thread.sleep(intervalSeconds * 1000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                } catch (IOException e) {\n                    Graphite.this.logger.warn(\"Failed to push metrics to Graphite server\", e);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public void testBadRequest() throws IOException {\n    Socket socket = new Socket(DefaultServer.getDefaultServerAddress().getHost(), DefaultServer.getDefaultServerPort());\n    try {\n        OutputStream out = socket.getOutputStream();\n        PrintWriter writer = new PrintWriter(out, true);\n        writer.println(\"POST /bad-request HTTP/1.1\");\n        writer.println(\"Host: example.com\");\n        writer.println(\"Content-Length: 10\");\n        writer.println();\n        writer.write(\"MalformedData\");\n        writer.flush();\n\n        InputStream in = socket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        StringBuilder response = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n\n        String expectedResponse = \"HTTP/1.1 400 Bad Request\\r\\n\" +\n                                 \"Content-Type: text/plain; charset=utf-8\\r\\n\" +\n                                 \"Content-Length: 12\\r\\n\" +\n                                 \"\\r\\n\" +\n                                 \"Bad Request\";\n\n        if (!response.toString().equals(expectedResponse)) {\n            throw new IOException(\"Server did not return expected 400 Bad Request response.\");\n        }\n    } finally {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 407,
    "Instruction": "Task Description: Create a Java class that acts as a TCP client within a servlet context, handling HTTP requests by forwarding them to a specified server via TCP and returning the server's response.\n\nClass Description: The Lisplet class extends HttpServlet to handle HTTP POST requests. It establishes a TCP connection to a specified host and port, sends the HTTP request data in a custom format, processes the server's response, and returns it to the client.\n\nAttributes:\n- host: String - The hostname or IP address of the TCP server to connect to\n- port: int - The port number of the TCP server to connect to\n\nMethods:\n- doPost(HttpServletRequest req, HttpServletResponse resp) -> void - Handles HTTP POST requests by establishing a TCP connection, sending the request, processing the response, and closing the connection\n- transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) -> void - Transfers the response body from the server to the HTTP response output stream\n- getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) -> boolean - Reads and processes the response header from the server\n- sendRequest(HttpServletRequest req, Writer writer) -> void - Formats and sends the HTTP request data to the server\n- writeTagValuePair(Writer writer, String tag, String value) -> void - Helper method to write tag-value pairs in the custom request format",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.http.*;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Socket socket = new Socket(host, port);\n        try {\n            Writer writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            sendRequest(req, writer);\n            PushbackInputStream strm = new PushbackInputStream(\n                    new BufferedInputStream(socket.getInputStream()));\n            if(getResponseHeader(req, resp, strm))\n                transferResponseBody(resp, strm);\n        } finally {\n            socket.close();\n        }\n    }\n\n    protected void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm)\n            throws ServletException, IOException {\n        OutputStream outs = resp.getOutputStream();\n        int b;\n        while((b = strm.read()) != -1)\n            outs.write(b);\n        outs.flush();\n    }\n\n    protected boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm)\n        throws ServletException, IOException {\n        ArrayList list = readSexpr(strm);\n        return processResponse(req, resp, list);\n    }\n\n    protected void sendRequest(HttpServletRequest req, Writer writer)\n            throws IOException {\n        writer.write(\"(\");\n        writeTagValuePair(writer, \"method\", req.getMethod());\n        writeTagValuePair(writer, \"uri\", req.getRequestURI());\n        writeTagValuePair(writer, \"protocol\", req.getProtocol());\n        writer.write(\")\");\n        writer.flush();\n    }\n\n    protected void writeTagValuePair(Writer writer, String tag, String value)\n            throws IOException {\n        writer.write(\"(\");\n        writer.write(tag);\n        writer.write(\" \");\n        writer.write(\"\\\"\");\n        writer.write(value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\",\"\\\\\\\\\\\"\"));\n        writer.write(\"\\\"\");\n        writer.write(\")\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.http.*;\nimport javax.servlet.ServletException;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    public void setHost(String host) {\n        this.host = host;\n    }\n\n    public void setPort(int port) {\n        this.port = port;\n    }\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        try (Socket socket = new Socket(host, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n            sendRequest(req, out);\n            PushbackInputStream strm = new PushbackInputStream(in);\n            if (getResponseHeader(req, resp, strm)) {\n                transferResponseBody(resp, strm);\n            }\n        } catch (IOException e) {\n            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"TCP connection failed\");\n        }\n    }\n\n    private void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = strm.read(buffer)) != -1) {\n            resp.getOutputStream().write(buffer, 0, bytesRead);\n        }\n    }\n\n    private boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        StringBuilder headerBuilder = new StringBuilder();\n        String line;\n        while ((line = strm.readLine()) != null && !line.isEmpty()) {\n            headerBuilder.append(line).append(\"\\r\\n\");\n            if (line.contains(\"HTTP/1.1\")) {\n                break;\n            }\n        }\n        String headerStr = headerBuilder.toString();\n        resp.setStatus(Integer.parseInt(headerStr.split(\" \")[1]));\n        resp.setHeader(\"Content-Type\", \"text/plain\");\n        return true;\n    }\n\n    private void sendRequest(HttpServletRequest req, Writer writer) throws IOException {\n        writer.write(\"POST / HTTP/1.1\\r\\n\");\n        writer.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n        writer.write(\"Content-Type: application/x-www-form-urlencoded\\r\\n\");\n        writer.write(\"Content-Length: \" + req.getContentLength() + \"\\r\\n\");\n        writer.write(\"\\r\\n\");\n        writer.flush();\n        for (String paramName : req.getParameterMap().keySet()) {\n            String paramValue = req.getParameter(paramName);\n            writeTagValuePair(writer, paramName, paramValue);\n        }\n    }\n\n    private void writeTagValuePair(Writer writer, String tag, String value) throws IOException {\n        writer.write(tag + \"=\" + value + \"\\r\\n\");\n    }\n}"
  },
  {
    "Task_id": 408,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for basic communication with a server using Java's IO and networking capabilities.\n\nClass Description: The HelloClient class establishes a TCP connection to a specified server, receives messages from the server, and properly closes the connection when done. It uses Java's Socket and BufferedReader for network communication.\n\nAttributes:\n- client: Socket - The socket object representing the connection to the server\n- buf: BufferedReader - The buffered reader for receiving data from the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n  - Input: \n    - host: String - The server hostname or IP address\n    - port: int - The server port number\n  - Throws: Exception - If connection fails\n- receive() -> String - Reads a line of text from the server\n  - Returns: String - The received message from the server\n  - Throws: Exception - If reading fails\n- close() -> void - Closes the connection and cleans up resources\n  - Throws: Exception - If closing fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class HelloClient {\n\n    private Socket client;\n    private BufferedReader buf;\n\n    public void connect(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        InputStreamReader inputStreamReader = new InputStreamReader(client.getInputStream());\n        buf = new BufferedReader(inputStreamReader);\n    }\n\n    public String receive() throws Exception {\n        String str = buf.readLine();\n        return str;\n    }\n\n    public void close() throws Exception {\n        buf.close();\n        client.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class HelloClient {\n    private Socket client;\n    private BufferedReader buf;\n\n    public void connect(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n    }\n\n    public String receive() throws Exception {\n        return buf.readLine();\n    }\n\n    public void close() throws Exception {\n        if (buf != null) {\n            buf.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a Java function that sends a raw RDP (Remote Desktop Protocol) connection request to a specified host and port using TCP socket communication. The function should handle the socket connection, data transmission, and proper resource cleanup.\n\nFunction Description: The function establishes a TCP connection to a specified remote host and port, sends a pre-defined hexadecimal RDP protocol payload, and then closes the connection. The function includes error handling for connection issues and implements a socket timeout to prevent hanging.\n\nInput:\n- rhost: String - The remote host IP address or hostname to connect to\n- rport: int - The remote port number for the RDP service\n\nOutput: None (void function), though errors will be printed to standard error if they occur\n\nNote: The function uses a static hexadecimal string (exp) containing the RDP protocol payload, which is converted to bytes before transmission. The socket timeout is set to 3 milliseconds to prevent prolonged connection attempts.",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic static String exp = \"030000130ee000000000000100080000000000030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c00300000c02f08004010001000300000802f080280300000c02f08038000603ef0300000c02f08038000603eb0300000c02f08038000603ec0300000c02f08038000603ed0300000c02f08038000603ee0300000b06d00000123400\";\n\npublic void sendRDPRequest(String rhost, int rport) {\n    try {\n        byte[] bytes = HexUtils.hex2Bytes(exp);\n        Socket socket = new Socket(rhost, rport);\n        socket.setSoTimeout(3);\n        OutputStream out = socket.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n        socket.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class RdpClient {\n    private static final String exp = \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\";\n    \n    public static void connectToRdp(String rhost, int rport) {\n        try (Socket socket = new Socket()) {\n            socket.setSoTimeout(3);\n            socket.connect(new InetSocketAddress(rhost, rport));\n            byte[] payload = HexStringToBytes(exp);\n            socket.getOutputStream().write(payload);\n            socket.close();\n        } catch (IOException e) {\n            System.err.println(\"Error connecting to RDP server: \" + e.getMessage());\n        }\n    }\n    \n    private static byte[] HexStringToBytes(String s) throws IllegalArgumentException {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            String hexPair = s.substring(i, i + 2);\n            int high = Character.digit(hexPair.charAt(0), 16);\n            int low = Character.digit(hexPair.charAt(1), 16);\n            data[i / 2] = (byte) (high << 4 | low);\n        }\n        return data;\n    }\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with the OpenMHz API, including methods for testing connection authorization and uploading audio recordings with metadata.\n\nClass Description: OpenMHzHttpClient is a utility class that provides HTTP client operations for the OpenMHz API. It handles both synchronous and asynchronous requests, manages connection settings, and processes API responses. The class includes error handling and logging capabilities.\n\nAttributes:\n- mLog: Logger - SLF4J logger instance for error and debug logging\n- mHttpClient: HttpClient - Configured HTTP client instance with HTTP/2 support, redirect policy, and timeout settings\n\nMethods:\n- testConnection(String host, String systemName, String apiKey) -> String - Tests API connection and authorization by sending a POST request to the authorize endpoint. Returns status messages based on response code.\n  Input:\n    - host: String - Base URL of the OpenMHz server\n    - systemName: String - Name of the target system\n    - apiKey: String - API key for authentication\n  Output:\n    - String - Status message (\"OK\", \"Invalid API Key\", \"Invalid System Name\", \"No Response\", or \"Unknown Exception\")\n\n- sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) -> void - Asynchronously uploads an audio recording with metadata to the OpenMHz API using multipart/form-data format.\n  Input:\n    - uri: String - Target endpoint URL\n    - audioBytes: byte[] - Audio file data to upload\n    - boundary: String - Multipart boundary string\n    - apiKey: String - API key for authentication\n    - frequency: long - Frequency value in Hz\n    - timestampSeconds: long - Recording start time in seconds\n    - durationSeconds: int - Recording duration in seconds\n    - talkgroup: String - Talkgroup identifier\n    - radioId: String - Radio source identifier\n  Output: None (asynchronous operation with error logging)",
    "Canonical_solution": "import com.google.common.net.HttpHeaders;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OpenMHzHttpClient {\n\n    private final static Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String uri = host + \"/\" + systemName + \"/authorize\";\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + apiKey))\n            .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                return \"OK\";\n            } else if(response.statusCode() == 403) {\n                return \"Invalid API Key\";\n            } else if(response.statusCode() == 500) {\n                return \"Invalid System Name\";\n            }\n\n            return \"No Response\";\n        }\n        catch(Exception e) {  \n            Throwable throwableCause = e.getCause();\n\n            if(throwableCause instanceof ConnectException) {\n                return \"No Response\";\n            }\n\n            mLog.error(\"Exception connecting to OpenMHz server [\" + e.toString() + \"]\");\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, \n                                  long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        OpenMHzBuilder bodyBuilder = new OpenMHzBuilder();\n        bodyBuilder\n            .addFile(audioBytes)\n            .addPart(FormField.FREQ, frequency)\n            .addPart(FormField.START_TIME, timestampSeconds)\n            .addPart(FormField.STOP_TIME, timestampSeconds)\n            .addPart(FormField.CALL_LENGTH, durationSeconds)\n            .addPart(FormField.TALKGROUP_NUM, talkgroup)\n            .addPart(FormField.EMERGENCY, 0)\n            .addPart(FormField.API_KEY, apiKey)\n            .addPart(FormField.SOURCE_LIST, \"[{ \\\"pos\\\": 0.00, \\\"src\\\": \" + radioId + \"}]\");\n\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"multipart/form-data; boundary=\" + boundary)\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                    else {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.ContentType;\nimport org.apache.http.entity.mime.MultipartEntityBuilder;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class OpenMHzHttpClient {\n    private static final Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private static final CloseableHttpClient mHttpClient = HttpClients.custom()\n            .setProtocolVersion(org.apache.http.protocol.HttpProtocolVersion.HTTP_2)\n            .setRedirectStrategy(new DefaultRedirectStrategy())\n            .setDefaultTimeout(10000)\n            .build();\n\n    private final ExecutorService mExecutor = Executors.newCachedThreadPool();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String url = host + \"/authorize\";\n        mLog.debug(\"Testing connection to {}\", url);\n\n        try {\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setHeader(\"Content-Type\", \"application/json\");\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n            httpPost.setHeader(\"System-Name\", systemName);\n\n            String jsonBody = String.format(\"{\\\"system_name\\\": \\\"%s\\\", \\\"api_key\\\": \\\"%s\\\"}\", systemName, apiKey);\n            httpPost.setEntity(org.apache.http.entity.StringEntity(jsonBody));\n\n            try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode == 200) {\n                    mLog.info(\"Connection authorized successfully.\");\n                    return \"OK\";\n                } else if (statusCode == 401) {\n                    mLog.warn(\"Invalid API key.\");\n                    return \"Invalid API Key\";\n                } else if (statusCode == 404) {\n                    mLog.warn(\"Invalid system name.\");\n                    return \"Invalid System Name\";\n                } else {\n                    mLog.error(\"No response from server. Status code: {}\", statusCode);\n                    return \"No Response\";\n                }\n            }\n        } catch (IOException e) {\n            mLog.error(\"Error testing connection: \", e);\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        mLog.debug(\"Starting audio recording upload to {}\", uri);\n\n        try {\n            HttpPost httpPost = new HttpPost(uri);\n            httpPost.setHeader(\"Authorization\", \"Bearer \" + apiKey);\n            httpPost.setHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n            MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n            builder.setBoundary(boundary);\n            builder.addBinaryBody(\"audio\", audioBytes, ContentType.DEFAULT_BINARY, \"audio.wav\");\n            builder.addTextBody(\"frequency\", String.valueOf(frequency));\n            builder.addTextBody(\"timestamp_seconds\", String.valueOf(timestampSeconds));\n            builder.addTextBody(\"duration_seconds\", String.valueOf(durationSeconds));\n            builder.addTextBody(\"talkgroup\", talkgroup);\n            builder.addTextBody(\"radio_id\", radioId);\n\n            HttpEntity entity = builder.build();\n            httpPost.setEntity(entity);\n\n            mExecutor.execute(() -> {\n                try (CloseableHttpResponse response = mHttpClient.execute(httpPost)) {\n                    int statusCode = response.getStatusLine().getStatusCode();\n                    if (statusCode == 200) {\n                        mLog.info(\"Audio recording uploaded successfully.\");\n                    } else {\n                        mLog.error(\"Failed to upload audio recording. Status code: {}\", statusCode);\n                    }\n                } catch (IOException e) {\n                    mLog.error(\"Error uploading audio recording: \", e);\n                }\n            });\n        } catch (Exception e) {\n            mLog.error(\"Error preparing audio recording request: \", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 412,
    "Instruction": "Task Description: Create a Java class that checks for a specific vulnerability (HTTP.sys Remote Code Execution) in a target server using TCP client communication.\n\nClass Description: The HttpSysRCEClient class is designed to detect the presence of the CVE-2015-1635 (MS15-034) vulnerability in a target HTTP server by sending specially crafted HTTP requests and analyzing the responses. It utilizes TCP socket communication to interact with the server.\n\nAttributes:\n- target: String - The URL of the target server to be checked\n- task: Task - An object containing task-related information and results\n\nMethods:\n- HttpSysRCEClient(String target, Task task) -> None - Constructor that initializes the target URL and task object\n- checkVulnerability() -> void - Main method that performs the vulnerability check by:\n  1. Establishing TCP connection to the target server\n  2. Sending crafted HTTP requests with malicious Range headers\n  3. Analyzing responses for vulnerability indicators\n  4. Adding vulnerability to task results if detected\n- addVulnerable() -> void - Helper method that adds vulnerability information to the task results when detected",
    "Canonical_solution": "import com.trackray.base.bean.Task;\nimport com.trackray.base.bean.Vulnerable;\nimport com.trackray.base.utils.IOUtils;\nimport com.trackray.base.utils.SysLog;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpSysRCEClient {\n\n    private String target;\n    private Task task;\n\n    public HttpSysRCEClient(String target, Task task) {\n        this.target = target;\n        this.task = task;\n    }\n\n    public void checkVulnerability() {\n        try {\n            URL url = new URL(target);\n            String host = url.getHost();\n            int port = url.getPort();\n\n            Socket socket = new Socket(host, port);\n\n            Callable<String> callable = new Callable<String>() {\n                @Override\n                public String call() throws Exception {\n                    String hexAllFfff = \"18446744073709551615\";\n                    String req = \"GET / HTTP/1.0\\r\\nHost: \" + host + \"\\r\\nRange: bytes=0-\" + hexAllFfff + \"\\r\\n\\r\\n\";\n\n                    InputStream inputStream = socket.getInputStream();\n                    OutputStream outputStream = socket.getOutputStream();\n\n                    outputStream.write(req.getBytes());\n                    outputStream.flush();\n\n                    return IOUtils.analysisStream(inputStream);\n                }\n            };\n\n            FutureTask<String> futureTask = new FutureTask<>(callable);\n            futureTask.run();\n            \n            try {\n                String result = futureTask.get(30, TimeUnit.SECONDS);\n                if (StringUtils.contains(result, \"Requested Range Not Satisfiable\")) {\n                    addVulnerable();\n                }\n            } catch (Exception e) {\n                Socket newSocket = new Socket(host, port);\n\n                callable = new Callable<String>() {\n                    @Override\n                    public String call() throws Exception {\n                        String hexAllFfff = \"18446744073709551615\";\n                        String req = \"GET / HTTP/1.1\\r\\nHost: \" + host + \"\\r\\nRange: bytes=0-\" + hexAllFfff + \"\\r\\n\\r\\n\";\n\n                        InputStream inputStream = newSocket.getInputStream();\n                        OutputStream outputStream = newSocket.getOutputStream();\n\n                        outputStream.write(req.getBytes());\n                        outputStream.flush();\n\n                        return IOUtils.analysisStream(inputStream);\n                    }\n                };\n\n                futureTask.cancel(true);\n                futureTask = new FutureTask<>(callable);\n                futureTask.run();\n                \n                try {\n                    String result = futureTask.get(30, TimeUnit.SECONDS);\n                    if (StringUtils.contains(result, \"Requested Range Not Satisfiable\")) {\n                        addVulnerable();\n                    }\n                } catch (Exception ee) {\n                } finally {\n                    futureTask.cancel(true);\n                    newSocket.close();\n                }\n            } finally {\n                socket.close();\n            }\n        } catch (Exception e) {\n            SysLog.error(e);\n        }\n    }\n\n    private void addVulnerable() {\n        task.getResult().addVulnerable(\n            Vulnerable.builder()\n                .title(\"HTTP.sys \u8fdc\u7a0b\u4ee3\u7801\u6267\u884c\")\n                .address(target)\n                .level(Vulnerable.Level.HIGH.getLevel())\n                .type(Vulnerable.Type.CODE_EXECUTION.getType())\n                .vulnId(Arrays.asList(\"CVE-2015-1635\", \"MS15-034\"))\n                .build()\n        );\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class HttpSysRCEClient {\n    private String target;\n    private Task task;\n\n    public HttpSysRCEClient(String target, Task task) {\n        this.target = target;\n        this.task = task;\n    }\n\n    public void checkVulnerability() {\n        try {\n            String[] urlParts = target.split(\":\");\n            String host = urlParts[0];\n            int port = Integer.parseInt(urlParts[1].split(\"/\")[0]);\n\n            Socket socket = new Socket(host, port);\n            OutputStream output = socket.getOutputStream();\n            InputStream input = socket.getInputStream();\n\n            String request = \"GET / HTTP/1.1\\r\\n\" +\n                             \"Host: \" + host + \"\\r\\n\" +\n                             \"Range: bytes=0-1000000000\\r\\n\\r\\n\";\n\n            output.write(request.getBytes());\n            output.flush();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = input.read(buffer)) != -1) {\n                String response = new String(buffer, 0, bytesRead);\n                if (response.contains(\"500\") || response.contains(\"503\") || response.contains(\"Internal Server Error\")) {\n                    addVulnerable();\n                }\n            }\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void addVulnerable() {\n        task.addResult(\"Vulnerability detected: HTTP.sys Remote Code Execution (CVE-2015-1635)\");\n    }\n}"
  },
  {
    "Task_id": 414,
    "Instruction": "Task Description: Create a Java class that handles TCP socket communication for receiving screen data from an Android device via minicap and forwarding it to a data queue for processing.\n\nClass Description: MiniCapInputSocketThread is a thread class that establishes a TCP connection to a local port forwarded from an Android device, continuously reads screen data from the minicap service, and places the data into a blocking queue for further processing by other components. It also manages resource cleanup when the connection is terminated.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and status information\n- iDevice: IDevice - The Android device being monitored\n- dataQueue: BlockingQueue<byte[]> - Queue for storing received screen data\n- miniCapPro: MiniCapLocalThread - The parent minicap process thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - The main Android test task thread\n- session: Session - WebSocket session associated with the screen streaming\n\nMethods:\n- MiniCapInputSocketThread(IDevice, BlockingQueue<byte[]>, MiniCapLocalThread, Session) -> None - Constructor that initializes the thread with device, data queue, minicap process, and session references\n- run() -> None - Main thread execution that establishes the socket connection, reads data continuously, and handles cleanup when finished",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\nimport static org.cloud.sonic.agent.tools.BytesTool.subByteArray;\n\npublic class MiniCapInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(MiniCapInputSocketThread.class);\n\n    public final static String ANDROID_INPUT_SOCKET_PRE = \"android-minicap-input-socket-task-%s-%s-%s\";\n\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private MiniCapLocalThread miniCapPro;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n        this.androidTestTaskBootThread = miniCapPro.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(ANDROID_INPUT_SOCKET_PRE));\n    }\n\n    @Override\n    public void run() {\n        int finalMiniCapPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, finalMiniCapPort, \"minicap\");\n        Socket capSocket = null;\n        InputStream inputStream = null;\n        try {\n            capSocket = new Socket(\"localhost\", finalMiniCapPort);\n            inputStream = capSocket.getInputStream();\n            int len = 1024;\n            while (miniCapPro.isAlive()) {\n                byte[] buffer = new byte[len];\n                int realLen;\n                realLen = inputStream.read(buffer);\n                if (buffer.length != realLen && realLen >= 0) {\n                    buffer = subByteArray(buffer, 0, realLen);\n                }\n                if (realLen >= 0) {\n                    dataQueue.offer(buffer);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (miniCapPro.isAlive()) {\n                miniCapPro.interrupt();\n                log.info(\"miniCap thread closed.\");\n            }\n            if (capSocket != null && capSocket.isConnected()) {\n                try {\n                    capSocket.close();\n                    log.info(\"miniCap socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"miniCap input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, finalMiniCapPort, \"minicap\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\nimport java.util.concurrent.BlockingQueue;\n\npublic class MiniCapInputSocketThread extends Thread {\n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final MiniCapLocalThread miniCapPro;\n    private final Session session;\n    private ServerSocket serverSocket;\n    private boolean running = true;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.log = Logger.getLogger(MiniCapInputSocketThread.class.getName());\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(0);\n            log.info(\"MiniCap socket server started on port \" + serverSocket.getLocalPort());\n            while (running) {\n                Socket socket = serverSocket.accept();\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = socket.getInputStream().read(buffer)) > 0) {\n                            dataQueue.put(java.util.Arrays.copyOf(buffer, bytesRead));\n                        }\n                    } catch (IOException | InterruptedException e) {\n                        log.severe(\"Error reading from socket: \" + e.getMessage());\n                    } finally {\n                        try {\n                            socket.close();\n                        } catch (IOException e) {\n                            log.severe(\"Error closing socket: \" + e.getMessage());\n                        }\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            log.severe(\"Error starting socket server: \" + e.getMessage());\n        } finally {\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    log.severe(\"Error closing socket server: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    public void shutdown() {\n        running = false;\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                log.severe(\"Error closing socket server: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 416,
    "Instruction": "Task Description: Create a Java class that implements file transfer functionality over TCP/IP protocol, including connection establishment, header and body parsing, and proper resource cleanup. The class should support progress monitoring through callbacks.\n\nClass Description: FileSender is a class that handles sending files to a remote server using TCP sockets. It implements Runnable for asynchronous operation and extends BaseTransfer for common transfer functionality. The class manages the entire file transfer process including connection setup, metadata transmission, file content streaming, and cleanup.\n\nAttributes:\n- mServerIpAddress: String - IP address of the server to connect to\n- mPort: int - Port number of the server\n- mFileInfo: FileInfo - Contains metadata about the file to be sent\n- mSocket: Socket - TCP socket for communication with server\n- mOutputStream: OutputStream - Buffered output stream for sending data\n- mOnSendListener: OnSendListener - Callback interface for transfer events\n\nMethods:\n- FileSender(Context, FileInfo, String, int) -> None - Constructor that initializes the file transfer parameters\n- setOnSendListener(OnSendListener) -> None - Sets the callback listener for transfer events\n- run() -> None - Main execution method called when the thread starts (implements Runnable)\n- init() -> None - Initializes the socket connection and output stream\n- parseHeader() -> None - Sends file metadata in a formatted header\n- parseBody() -> None - Streams the file content to the server\n- finish() -> None - Cleans up resources (closes streams and socket)\n- OnSendListener: Interface - Callback interface with methods for transfer events:\n  - onStart() -> None - Called when transfer begins\n  - onProgress(long, long) -> None - Called with progress updates\n  - onSuccess(FileInfo) -> None - Called on successful transfer\n  - onFailure(Throwable, FileInfo) -> None - Called if transfer fails",
    "Canonical_solution": "import android.content.Context;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class FileSender extends BaseTransfer implements Runnable {\n\n    private String mServerIpAddress;\n    private int mPort;\n    private FileInfo mFileInfo;\n    private Socket mSocket;\n    private OutputStream mOutputStream;\n    private OnSendListener mOnSendListener;\n\n    public FileSender(Context context, FileInfo mFileInfo, String mServerIpAddress, int mPort) {\n        this.mFileInfo = mFileInfo;\n        this.mServerIpAddress = mServerIpAddress;\n        this.mPort = mPort;\n    }\n\n    public void setOnSendListener(OnSendListener mOnSendListener) {\n        this.mOnSendListener = mOnSendListener;\n    }\n\n    @Override\n    public void run() {\n        try {\n            if(mOnSendListener != null) mOnSendListener.onStart();\n            init();\n            parseHeader();\n            parseBody();\n            finish();\n            if(mOnSendListener != null) mOnSendListener.onSuccess(mFileInfo);\n        } catch (Exception e) {\n            if(mOnSendListener != null) mOnSendListener.onFailure(e, mFileInfo);\n        }\n    }\n\n    @Override\n    public void init() throws Exception {\n        this.mSocket = new Socket(mServerIpAddress, mPort);\n        OutputStream os = this.mSocket.getOutputStream();\n        mOutputStream = new BufferedOutputStream(os);\n    }\n\n    @Override\n    public void parseHeader() throws Exception {\n        StringBuilder headerSb = new StringBuilder();\n        String jsonStr = FileInfo.toJsonStr(mFileInfo);\n        jsonStr = TYPE_FILE + SPERATOR + jsonStr;\n        headerSb.append(jsonStr);\n        int leftLen = BYTE_SIZE_HEADER - jsonStr.getBytes(UTF_8).length;\n        for(int i=0; i < leftLen; i++){\n            headerSb.append(\" \");\n        }\n        byte[] headbytes = headerSb.toString().getBytes(UTF_8);\n        mOutputStream.write(headbytes);\n    }\n\n    @Override\n    public void parseBody() throws Exception {\n        InputStream fis = new FileInputStream(new File(mFileInfo.getFilePath()));\n        byte[] bytes = new byte[BYTE_SIZE_DATA];\n        int len = 0;\n        while((len=fis.read(bytes)) != -1){\n            mOutputStream.write(bytes, 0, len);\n            if(mOnSendListener != null) mOnSendListener.onProgress(fis.available(), mFileInfo.getSize());\n        }\n        mOutputStream.flush();\n        mOutputStream.close();\n    }\n\n    @Override\n    public void finish() {\n        try {\n            if(mOutputStream != null) mOutputStream.close();\n            if(mSocket != null && mSocket.isConnected()) mSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface OnSendListener {\n        void onStart();\n        void onProgress(long progress, long total);\n        void onSuccess(FileInfo fileInfo);\n        void onFailure(Throwable t, FileInfo fileInfo);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class FileSender extends BaseTransfer implements Runnable {\n    private String mServerIpAddress;\n    private int mPort;\n    private FileInfo mFileInfo;\n    private Socket mSocket;\n    private OutputStream mOutputStream;\n    private OnSendListener mOnSendListener;\n\n    public FileSender(Context context, FileInfo fileInfo, String serverIpAddress, int port) {\n        super(context);\n        mFileInfo = fileInfo;\n        mServerIpAddress = serverIpAddress;\n        mPort = port;\n    }\n\n    public void setOnSendListener(OnSendListener listener) {\n        mOnSendListener = listener;\n    }\n\n    @Override\n    public void run() {\n        init();\n        try {\n            mOnSendListener.onStart();\n            parseHeader();\n            parseBody();\n            mOnSendListener.onSuccess(mFileInfo);\n        } catch (Exception e) {\n            mOnSendListener.onFailure(e, mFileInfo);\n        } finally {\n            finish();\n        }\n    }\n\n    private void init() throws IOException {\n        mSocket = new Socket(mServerIpAddress, mPort);\n        mOutputStream = new BufferedOutputStream(mSocket.getOutputStream());\n    }\n\n    private void parseHeader() throws IOException {\n        byte[] header = new byte[4];\n        System.arraycopy(mFileInfo.getFileSize().toString().getBytes(), 0, header, 0, 4);\n        mOutputStream.write(header);\n        mOutputStream.flush();\n    }\n\n    private void parseBody() throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(mFileInfo.getFilePath());\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        long totalBytesRead = 0;\n        long fileSize = mFileInfo.getFileSize();\n        while ((bytesRead = fileInputStream.read(buffer)) != -1) {\n            mOutputStream.write(buffer, 0, bytesRead);\n            totalBytesRead += bytesRead;\n            mOnSendListener.onProgress(totalBytesRead, fileSize);\n        }\n        fileInputStream.close();\n    }\n\n    private void finish() {\n        try {\n            if (mOutputStream != null) mOutputStream.close();\n            if (mSocket != null) mSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface OnSendListener {\n        void onStart();\n        void onProgress(long progress, long total);\n        void onSuccess(FileInfo fileInfo);\n        void onFailure(Throwable throwable, FileInfo fileInfo);\n    }\n}"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.List;\n\npublic class Minitouch {\n    public static final String REMOTE_PATH = \"/data/local/tmp/\";\n    public static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList;\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n        this.listenerList = new java.util.ArrayList<>();\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        forward = createForward();\n        try {\n            device.forward(forward);\n            startInitialThread(forward.getHost(), forward.getPort());\n            onStartup(true);\n        } catch (Exception e) {\n            onStartup(false);\n        }\n    }\n\n    public void kill() {\n        if (minitouchSocket != null) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (forward != null) {\n            device.removeForward(forward);\n        }\n        onClose();\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream != null) {\n            try {\n                minitouchOutputStream.write(str.getBytes());\n                minitouchOutputStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private AdbForward createForward() {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) {\n        device.removeForward(forward);\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(host, port);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        return new AdbForward(\"tcp:\" + device.getIpAddress(), \"localabstract:minitouch\");\n    }\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making various types of HTTP requests and handling responses.\n\nClass Description: The HttpCommunicationClient class provides methods for performing HTTP operations (GET, POST) and handling redirects. It manages an HTTP client instance and supports custom headers and browser-like requests.\n\nAttributes:\naddress: [InetSocketAddress] - The target server address (host and port) for HTTP requests\nhttpClient: [HttpClient] - The underlying HTTP client instance used for making requests\n\nMethods:\nsetupHttpClient: [setupHttpClient(ThreadPool threadPool)] -> [void] - Initializes the HTTP client with redirect policy and thread pool\ncloseClient: [closeClient()] -> [void] - Closes the HTTP client resources\nexecuteAndDefaultAssertions: [executeAndDefaultAssertions(HttpRequest request)] -> [HttpResponse<String>] - Internal method to execute requests and handle responses\nget: [get(String path, String[]... headers)] -> [HttpResponse<String>] - Performs a GET request to specified path with optional headers\nbrowserGet: [browserGet(String uri)] -> [HttpResponse<String>] - Performs a GET request with browser-like User-Agent header\npost: [post(String path)] -> [HttpResponse<String>] - Performs a POST request to specified path\ngetAllRedirectLocations: [getAllRedirectLocations(String path, String[]... headers)] -> [List<String>] - Retrieves all redirect locations for a request\nbrowserHeader: [static browserHeader()] -> [String[]] - Returns browser-like User-Agent header (static utility method)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n\n    protected InetSocketAddress address;\n    protected HttpClient httpClient;\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .executor(threadPool.generic())\n            .build();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        var resp = httpClient.send(request, BodyHandlers.ofString());\n        return resp;\n    }\n\n    public HttpResponse<String> get(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        return executeAndDefaultAssertions(builder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        return get(uri, browserHeader());\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(BodyPublishers.noBody())\n            .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        var response = httpClient.send(builder.build(), BodyHandlers.discarding());\n        response = response.previousResponse().orElse(null);\n        List<String> redirects = new ArrayList<>();\n        while (response != null) {\n            redirects.addAll(response.headers().allValues(\"location\"));\n            response = response.previousResponse().orElse(null);\n        }\n        return redirects;\n    }\n\n    static String[] browserHeader() {\n        return new String[] {\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class HttpCommunicationClient {\n    private final InetSocketAddress address;\n    private final HttpClient httpClient;\n\n    public HttpCommunicationClient(InetSocketAddress address) {\n        this.address = address;\n        this.httpClient = setupHttpClient(new ThreadPoolExecutor(5, 10, 60L, java.util.concurrent.TimeUnit.SECONDS, new java.util.concurrent.LinkedBlockingQueue<>()));\n    }\n\n    private void setupHttpClient(ThreadPoolExecutor threadPool) {\n        httpClient = HttpClient.newHttpClient();\n        httpClient.followRedirects(false);\n        httpClient.setMaximumRedirects(5);\n    }\n\n    private void closeClient() {\n        if (httpClient != null) {\n            httpClient.close();\n        }\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(String path, String[]... headers) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(address.getHostString() + \":\" + address.getPort() + path))\n                .headers(headers)\n                .GET()\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        String[] headers = browserHeader();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(uri))\n                .headers(headers)\n                .GET()\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(address.getHostString() + \":\" + address.getPort() + path))\n                .POST(HttpRequest.BodyPublishers.ofString(\"\"))\n                .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[]... headers) throws Exception {\n        List<String> redirectLocations = new ArrayList<>();\n        String currentUrl = address.getHostString() + \":\" + address.getPort() + path;\n        for (int i = 0; i < 5; i++) {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(currentUrl))\n                    .headers(headers)\n                    .GET()\n                    .build();\n            HttpResponse<String> response = executeAndDefaultAssertions(request);\n            if (response.headers().firstValue(\"Location\") != null) {\n                redirectLocations.add(response.headers().firstValue(\"Location\").get());\n                currentUrl = response.headers().firstValue(\"Location\").get();\n            } else {\n                break;\n            }\n        }\n        return redirectLocations;\n    }\n\n    public static String[] browserHeader() {\n        return new String[]{ \"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\" };\n    }\n}"
  },
  {
    "Task_id": 420,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends a message, and properly handles the connection lifecycle including cleanup.\n\nClass Description: The TCPClient class encapsulates functionality for creating a TCP client that connects to a specified server, sends a UTF-8 encoded message, and manages socket resources. It handles potential network exceptions and ensures proper resource cleanup.\n\nAttributes:\n- s: Socket - The socket object used for the TCP connection\n- dos: DataOutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(): void - Establishes a connection to the server at 127.0.0.1:5555, sends the message \"Happy\" after a 3-second delay, and handles connection cleanup. No parameters. No return value.",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPClient {\n\n    public void connect() {\n        Socket s = null;\n        DataOutputStream dos = null;\n        try {\n            s = new Socket(\"127.0.0.1\", 5555);\n            dos = new DataOutputStream(s.getOutputStream());\n            System.out.println(\"Yeah, I connected\");\n            Thread.sleep(3000);\n            dos.writeUTF(\"Happy\");\n            dos.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (dos != null) {\n                    dos.close();\n                }\n                if (s != null) {\n                    s.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TCPClient {\n    private Socket s;\n    private DataOutputStream dos;\n\n    public void connect() {\n        try {\n            s = new Socket(\"127.0.0.1\", 5555);\n            dos = new DataOutputStream(s.getOutputStream());\n            Thread.sleep(3000);\n            dos.writeUTF(\"Happy\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (dos != null) dos.close();\n                if (s != null) s.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 421,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The SocketClient class provides functionality for establishing a TCP connection to a server, sending messages, receiving responses, and managing connection resources. It encapsulates the socket communication logic using Java's IO and networking classes.\n\nAttributes:\n- theSocket: Socket - The socket object representing the connection to the server\n- out: PrintWriter - The output stream writer for sending data to the server\n- networkIn: BufferedReader - The input stream reader for receiving data from the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendMessage(String message) -> void - Sends a message to the connected server. The message is automatically flushed.\n- readResponse() -> String - Reads a line of response from the server. Throws IOException if reading fails.\n- close() -> void - Closes all connection resources (socket, input and output streams) safely. Handles any IOExceptions internally.",
    "Canonical_solution": "import java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class SocketClient {\n\n    private Socket theSocket;\n    private PrintWriter out;\n    private BufferedReader networkIn;\n\n    public void connect(String host, int port) throws IOException {\n        theSocket = new Socket(host, port);\n        networkIn = new BufferedReader(new InputStreamReader(theSocket.getInputStream()));\n        out = new PrintWriter(theSocket.getOutputStream());\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n        out.flush();\n    }\n\n    public String readResponse() throws IOException {\n        return networkIn.readLine();\n    }\n\n    public void close() {\n        try {\n            if (networkIn != null) networkIn.close();\n            if (out != null) out.close();\n            if (theSocket != null) theSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketClient {\n    private Socket theSocket;\n    private PrintWriter out;\n    private BufferedReader networkIn;\n\n    public void connect(String host, int port) throws IOException {\n        theSocket = new Socket(host, port);\n        out = new PrintWriter(theSocket.getOutputStream(), true);\n        networkIn = new BufferedReader(new InputStreamReader(theSocket.getInputStream()));\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n\n    public String readResponse() throws IOException {\n        return networkIn.readLine();\n    }\n\n    public void close() {\n        try {\n            if (networkIn != null) networkIn.close();\n            if (out != null) out.close();\n            if (theSocket != null) theSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TcpSocketSender {\n    public static void sendToServer(String str, String host, int port) {\n        try (Socket socket = new Socket(host, port);\n             OutputStream outputStream = socket.getOutputStream();\n             PrintWriter printWriter = new PrintWriter(outputStream)) {\n            printWriter.println(str);\n            printWriter.flush();\n        } catch (IOException e) {\n            System.err.printf(\"Error sending message to server: %s%n\", e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public void testConnection(String url) throws IOException {\n    Socket socket = new Socket(DefaultServer.HOST, DefaultServer.PORT);\n    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n    BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n    // Send HTTP upgrade request\n    String upgradeRequest = \"GET \" + url + \" HTTP/1.1\\r\\n\" +\n                            \"Host: \" + DefaultServer.HOST + \":\" + DefaultServer.PORT + \"\\r\\n\" +\n                            \"Upgrade: websocket\\r\\n\" +\n                            \"Connection: Upgrade\\r\\n\" +\n                            \"\\r\\n\";\n    out.println(upgradeRequest);\n\n    // Read server response\n    String response = readBytes(in);\n    assertEquals(\"HTTP/1.1 101 Switching Protocols\", response);\n\n    // Send echo message\n    String echoMessage = \"Echo message: Hello, Server!\\r\\n\\r\\n\";\n    out.println(echoMessage);\n\n    // Read server response\n    response = readBytes(in);\n    assertEquals(\"HTTP/1.1 200 OK\", response);\n    assertEquals(\"Echo message: Hello, Server!\", response);\n\n    // Close connection\n    socket.close();\n}"
  },
  {
    "Task_id": 424,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java's Socket API for establishing connections, sending and receiving data, and managing the connection state.\n\nClass Description: The SocketClient class is a singleton implementation that provides TCP client functionality. It manages a single socket connection, handles data transmission through input/output streams, and maintains connection state. The class includes methods for opening/closing connections, reading/writing data, and checking connection status.\n\nAttributes:\n- socketClient: [SocketClient] - Singleton instance of the class\n- socket: [Socket] - The TCP socket connection\n- outputStream: [OutputStream] - Output stream for sending data\n- inputStream: [InputStream] - Input stream for receiving data\n- isConnected: [boolean] - Connection status flag\n- DEFAULT_READ_BUFFER_SIZE: [int] - Default buffer size for reading data (32KB)\n- buffer: [byte[]] - Temporary buffer for reading data\n- receivedData: [byte[]] - Storage for received data\n\nMethods:\n- getInstance() -> [SocketClient] - Returns the singleton instance of SocketClient\n- openConnection(String ip, int port) -> [void] - Opens a connection to the specified IP and port\n- isConnected() -> [boolean] - Returns the current connection status\n- write(byte[] data) -> [void] - Synchronously writes data to the output stream\n- read(int bytesToBeRead) -> [int] - Synchronously reads specified number of bytes from input stream\n- getReceivedData() -> [byte[]] - Returns the last received data\n- closeConnection() -> [void] - Closes the current connection and cleans up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SocketClient {\n\n    private static SocketClient socketClient = null;\n    private Socket socket;\n    private OutputStream outputStream;\n    private InputStream inputStream;\n    private boolean isConnected = false;\n    public static final int DEFAULT_READ_BUFFER_SIZE = 32 * 1024;\n    private byte[] buffer = new byte[DEFAULT_READ_BUFFER_SIZE];\n    private byte[] receivedData;\n\n    private SocketClient() {\n    }\n\n    public void openConnection(String ip, int port) throws IOException {\n        socket = new Socket(ip, port);\n        outputStream = socket.getOutputStream();\n        inputStream = socket.getInputStream();\n        if (!socket.isConnected()) {\n            isConnected = false;\n            return;\n        }\n        isConnected = true;\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n    }\n\n    public static SocketClient getInstance() {\n        if (socketClient == null) {\n            socketClient = new SocketClient();\n        }\n        return socketClient;\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public synchronized void write(byte[] data) throws IOException {\n        if (isConnected && socketClient.isConnected && outputStream != null) {\n            outputStream.write(data);\n        }\n    }\n\n    public synchronized int read(int bytesToBeRead) throws IOException {\n        int numBytesRead = 0;\n        int readNow;\n        int bytesToBeReadTemp = bytesToBeRead;\n        receivedData = new byte[DEFAULT_READ_BUFFER_SIZE];\n        while (numBytesRead < bytesToBeRead) {\n            readNow = inputStream.read(buffer, 0, bytesToBeReadTemp);\n            if (readNow <= 0) {\n                return numBytesRead;\n            } else {\n                System.arraycopy(buffer, 0, receivedData, numBytesRead, readNow);\n                numBytesRead += readNow;\n                bytesToBeReadTemp -= readNow;\n            }\n        }\n        return numBytesRead;\n    }\n\n    public byte[] getReceivedData() {\n        return receivedData;\n    }\n\n    public void closeConnection() {\n        try {\n            if (isConnected) {\n                inputStream.close();\n                outputStream.close();\n                socket.close();\n                isConnected = false;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketClient {\n    private static SocketClient socketClient;\n    private Socket socket;\n    private OutputStream outputStream;\n    private InputStream inputStream;\n    private boolean isConnected;\n    private static final int DEFAULT_READ_BUFFER_SIZE = 32768;\n    private byte[] buffer = new byte[DEFAULT_READ_BUFFER_SIZE];\n    private byte[] receivedData;\n\n    private SocketClient() {\n        this.isConnected = false;\n    }\n\n    public static SocketClient getInstance() {\n        if (socketClient == null) {\n            socketClient = new SocketClient();\n        }\n        return socketClient;\n    }\n\n    public void openConnection(String ip, int port) {\n        try {\n            socket = new Socket(ip, port);\n            outputStream = socket.getOutputStream();\n            inputStream = socket.getInputStream();\n            isConnected = true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            isConnected = false;\n        }\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void write(byte[] data) {\n        if (isConnected) {\n            try {\n                outputStream.write(data);\n                outputStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public int read(int bytesToBeRead) {\n        if (isConnected) {\n            try {\n                int bytesRead = inputStream.read(buffer, 0, bytesToBeRead);\n                if (bytesRead > 0) {\n                    receivedData = Arrays.copyOf(buffer, bytesRead);\n                }\n                return bytesRead;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }\n        return -1;\n    }\n\n    public byte[] getReceivedData() {\n        return receivedData;\n    }\n\n    public void closeConnection() {\n        if (isConnected) {\n            try {\n                inputStream.close();\n                outputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            isConnected = false;\n        }\n    }\n}"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class SocketClient {\n    private static final int SERVER_SOCKET_PORT = 12345;\n    private static final String HARDWARE_ID = \"HW123\";\n\n    public void doSocketTest() {\n        try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT)) {\n            OutputStream outputStream = socket.getOutputStream();\n            String jsonData = generateJsonData();\n            outputStream.write(jsonData.getBytes());\n            outputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String generateJsonData() {\n        return String.format(\"{\\\"timestamp\\\": \\\"%s\\\", \\\"hardware_id\\\": \\\"%s\\\", \\\"value\\\": 42.0}\", new Date(), HARDWARE_ID);\n    }\n}"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nabstract class Connection {\n    abstract void processReceive();\n    abstract void processSend();\n}\n\ninterface PacketSource {\n    void sendPacket(IPv4Packet packet);\n}\n\nclass TCPConnection extends Connection implements PacketSource {\n    int MTU = 16384;\n    int MAX_PAYLOAD_SIZE = 1460;\n    StreamBuffer clientToNetwork;\n    Packetizer networkToClient;\n    IPv4Packet packetForClient;\n    SocketChannel channel;\n    SelectionKey selectionKey;\n    int interests;\n\n    TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) {\n        clientToNetwork = new StreamBuffer(MTU);\n        networkToClient = new Packetizer(MAX_PAYLOAD_SIZE);\n        channel = createChannel();\n        try {\n            channel.configureBlocking(false);\n            channel.connect(new InetSocketAddress(ipv4Header.destinationIP, tcpHeader.destinationPort));\n            selectionKey = channel.register(selector, 0);\n            updateInterests();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void disconnect() {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void processReceive() {\n        try {\n            int bytesRead = channel.read(networkToClient.buffer);\n            if (bytesRead > 0) {\n                networkToClient.processBytes(bytesRead);\n            } else if (bytesRead < 0) {\n                disconnect();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void processSend() {\n        try {\n            int bytesSent = channel.write(clientToNetwork.buffer);\n            if (bytesSent > 0) {\n                clientToNetwork.buffer.clear();\n                if (clientToNetwork.buffer.position() == 0) {\n                    updateInterests();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    SocketChannel createChannel() {\n        try {\n            return SocketChannel.open();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    void sendToNetwork(IPv4Packet packet) {\n        clientToNetwork.write(packet);\n        updateInterests();\n    }\n\n    void updateInterests() {\n        interests = 0;\n        if (mayRead()) {\n            interests |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interests |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interests |= SelectionKey.OP_CONNECT;\n        }\n        selectionKey.interestOps(interests);\n    }\n\n    boolean mayRead() {\n        return channel.isValid() && !channel.isConnected();\n    }\n\n    boolean mayWrite() {\n        return channel.isValid() && channel.isConnectionPending();\n    }\n\n    boolean mayConnect() {\n        return channel.isValid() && channel.isConnectionPending();\n    }\n}"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\npublic class ReadSocketService {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024; // 1MB\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead;\n    private final AbstractHAReader haReader;\n    private int processPosition;\n    private long lastReadTimestamp;\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.selector = Selector.open();\n        this.socketChannel = socketChannel;\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new AbstractHAReader();\n        this.processPosition = 0;\n        this.lastReadTimestamp = System.currentTimeMillis();\n\n        // Configure the socket channel for reading\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                int readyKeys = selector.selectNow();\n                if (readyKeys > 0) {\n                    Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                    for (SelectionKey key : selectedKeys) {\n                        if (key.isReadable()) {\n                            readData();\n                        }\n                    }\n                    selectedKeys.clear();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            cleanup();\n        }\n    }\n\n    private void readData() throws IOException {\n        int bytesRead = socketChannel.read(byteBufferRead);\n        if (bytesRead > 0) {\n            byteBufferRead.flip();\n            boolean processed = haReader.processReadResult(byteBufferRead);\n            if (processed) {\n                processPosition += bytesRead;\n                byteBufferRead.clear();\n                lastReadTimestamp = System.currentTimeMillis();\n            } else {\n                // Handle incomplete processing or error\n                byteBufferRead.compact();\n            }\n        } else if (bytesRead == -1) {\n            // Connection closed\n            socketChannel.close();\n        }\n    }\n\n    public String getServiceName() {\n        return \"ReadSocketService\";\n    }\n\n    private void cleanup() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (socketChannel != null) {\n                socketChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n    private final HttpClient httpClient;\n    private final String bearerToken;\n    private final HubConfig hubConfig;\n    private final String deviceId;\n    private final String vaultId;\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n        this.httpClient = HttpClient.newHttpClient();\n        this.bearerToken = bearerToken;\n        this.hubConfig = hubConfig;\n        this.deviceId = deviceId;\n        this.vaultId = vaultId;\n    }\n\n    public CompletableFuture<ReceivedKey> requestApiConfig() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getApiConfigUrl()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .GET()\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleApiConfigResponse(response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        }, httpClient);\n    }\n\n    private CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return CompletableFuture.completedFuture(parseReceivedKey(response.body()));\n        } else {\n            return retrievalFailed(new Exception(\"API config request failed with status code: \" + response.statusCode()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestDeviceData() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getDeviceDataUrl()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .GET()\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleDeviceDataResponse(response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        }, httpClient);\n    }\n\n    private CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return CompletableFuture.completedFuture(parseReceivedKey(response.body()));\n        } else {\n            return retrievalFailed(new Exception(\"Device data request failed with status code: \" + response.statusCode()));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getVaultMasterkeyUrl()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .POST(HttpRequest.BodyPublishers.ofString(encryptedUserKey))\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleVaultMasterkeyResponse(encryptedUserKey, response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        }, httpClient);\n    }\n\n    private ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return parseReceivedKey(response.body());\n        } else {\n            throw new RuntimeException(\"Vault master key request failed with status code: \" + response.statusCode());\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(hubConfig.getLegacyAccessTokenUrl()))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .GET()\n                        .build();\n                HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return handleLegacyAccessTokenResponse(response);\n            } catch (Exception e) {\n                return retrievalFailed(e);\n            }\n        }, httpClient);\n    }\n\n    private ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return parseReceivedKey(response.body());\n        } else {\n            throw new RuntimeException(\"Legacy access token request failed with status code: \" + response.statusCode());\n        }\n    }\n\n    private ReceivedKey parseReceivedKey(String responseBody) {\n        // Implement parsing logic based on the actual response format\n        return new ReceivedKey(); // Placeholder\n    }\n\n    private ReceivedKey retrievalFailed(Throwable cause) {\n        // Implement error handling and logging\n        return new ReceivedKey(); // Placeholder\n    }\n}"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a Java class for a High Availability (HA) client that manages communication with a master server using non-blocking I/O (NIO) techniques. The client should handle connection management, data reporting, and read event processing.\n\nClass Description: DefaultHAClient is a service thread that maintains a connection to a master server for high availability purposes. It uses Java NIO's SocketChannel and Selector for non-blocking communication, manages buffer operations for data transfer, and handles connection lifecycle events.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Maximum buffer size for reading data (4MB)\n- masterHaAddress: [AtomicReference<String>] - Atomic reference to the master server's address\n- reportOffset: [ByteBuffer] - Buffer for reporting slave offset to master (8 bytes)\n- socketChannel: [SocketChannel] - Channel for communication with master\n- selector: [Selector] - Selector for non-blocking I/O operations\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n- lastWriteTimestamp: [long] - Timestamp of last successful write operation\n- currentReportedOffset: [long] - Current offset reported to master\n- dispatchPosition: [int] - Position in read buffer for dispatching data\n- byteBufferRead: [ByteBuffer] - Primary buffer for reading data\n- byteBufferBackup: [ByteBuffer] - Backup buffer for buffer reallocation\n- defaultMessageStore: [DefaultMessageStore] - Reference to the message store for offset information\n\nMethods:\n- DefaultHAClient([DefaultMessageStore defaultMessageStore]) -> [void] - Constructor that initializes selector and message store reference\n- updateHaMasterAddress([String newAddr]) -> [void] - Updates the master server address atomically\n- reportSlaveMaxOffset([long maxOffset]) -> [boolean] - Reports the slave's maximum offset to master, returns success status\n- reallocateByteBuffer() -> [void] - Reallocates and swaps read buffers when needed\n- swapByteBuffer() -> [void] - Swaps primary and backup byte buffers\n- processReadEvent() -> [boolean] - Processes read events from socket channel, returns success status\n- connectMaster() -> [boolean] - Connects to master server, returns connection status\n- closeMaster() -> [void] - Closes connection with master and cleans up resources\n- shutdown() -> [void] - Shuts down the client by closing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.store.DefaultMessageStore;\n\npublic class DefaultHAClient extends ServiceThread implements HAClient {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        String currentAddr = this.masterHaAddress.get();\n        if (masterHaAddress.compareAndSet(currentAddr, newAddr)) {\n            log.info(\"update master ha address, OLD: \" + currentAddr + \" NEW: \" + newAddr);\n        }\n    }\n\n    private boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n\n        for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n            try {\n                this.socketChannel.write(this.reportOffset);\n            } catch (IOException e) {\n                log.error(this.getServiceName()\n                    + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n                return false;\n            }\n        }\n        lastWriteTimestamp = this.defaultMessageStore.getSystemClock().now();\n        return !this.reportOffset.hasRemaining();\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    readSizeZeroTimes = 0;\n                    boolean result = this.dispatchReadRequest();\n                    if (!result) {\n                        log.error(\"HAClient, dispatchReadRequest error\");\n                        return false;\n                    }\n                    lastReadTimestamp = System.currentTimeMillis();\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else {\n                    log.info(\"HAClient, processReadEvent read socket < 0\");\n                    return false;\n                }\n            } catch (IOException e) {\n                log.info(\"HAClient, processReadEvent read socket exception\", e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws ClosedChannelException {\n        if (null == socketChannel) {\n            String addr = this.masterHaAddress.get();\n            if (addr != null) {\n                SocketAddress socketAddress = NetworkUtil.string2SocketAddress(addr);\n                this.socketChannel = RemotingHelper.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                    log.info(\"HAClient connect to master {}\", addr);\n                }\n            }\n            this.currentReportedOffset = this.defaultMessageStore.getMaxPhyOffset();\n            this.lastReadTimestamp = System.currentTimeMillis();\n        }\n        return this.socketChannel != null;\n    }\n\n    public void closeMaster() {\n        if (null != this.socketChannel) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n                log.info(\"HAClient close connection with master {}\", this.masterHaAddress.get());\n            } catch (IOException e) {\n                log.warn(\"closeMaster exception. \", e);\n            }\n            this.lastReadTimestamp = 0;\n            this.dispatchPosition = 0;\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferRead.position(0);\n            this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException e) {\n            log.warn(\"Close the selector of AutoRecoverHAClient error, \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class DefaultHAClient {\n    private static final int READ_MAX_BUFFER_SIZE = 4 * 1024 * 1024;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp;\n    private long lastWriteTimestamp;\n    private long currentReportedOffset;\n    private int dispatchPosition;\n    private ByteBuffer byteBufferRead;\n    private ByteBuffer byteBufferBackup;\n    private final DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) {\n        this.defaultMessageStore = defaultMessageStore;\n        byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        selector = Selector.open();\n    }\n\n    public void updateHaMasterAddress(String newAddr) {\n        masterHaAddress.set(newAddr);\n    }\n\n    public boolean reportSlaveMaxOffset(long maxOffset) {\n        reportOffset.putLong(0, maxOffset);\n        reportOffset.flip();\n        try {\n            if (socketChannel != null && socketChannel.isConnected()) {\n                socketChannel.write(reportOffset);\n                lastWriteTimestamp = System.currentTimeMillis();\n                reportOffset.clear();\n                return true;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public void reallocateByteBuffer() {\n        byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    }\n\n    public void swapByteBuffer() {\n        ByteBuffer temp = byteBufferRead;\n        byteBufferRead = byteBufferBackup;\n        byteBufferBackup = temp;\n    }\n\n    public boolean processReadEvent() {\n        try {\n            if (socketChannel != null && socketChannel.isOpen() && socketChannel.isConnectionActive()) {\n                if (socketChannel.read(byteBufferRead) > 0) {\n                    byteBufferRead.flip();\n                    dispatchPosition = 0;\n                    lastReadTimestamp = System.currentTimeMillis();\n                    return true;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public boolean connectMaster() {\n        try {\n            String address = masterHaAddress.get();\n            if (address == null || address.isEmpty()) {\n                return false;\n            }\n            InetSocketAddress endpoint = new InetSocketAddress(address, 9876);\n            socketChannel = SocketChannel.open();\n            socketChannel.configureBlocking(false);\n            socketChannel.connect(endpoint);\n            socketChannel.register(selector, SelectionKey.OP_READ);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void closeMaster() {\n        try {\n            if (socketChannel != null && socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n            if (selector != null) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        closeMaster();\n    }\n}"
  },
  {
    "Task_id": 433,
    "Instruction": "Task Description: Implement a Java class that facilitates TCP-based communication using Java NIO (Non-blocking I/O) techniques, supporting both client and server modes with configurable options.\n\nClass Description: NioTransport is a class that provides TCP communication capabilities using Java NIO. It can operate in either server or client mode, supports direct buffers for performance optimization, and includes methods for starting/stopping communication, sending data, and receiving data through a callback mechanism.\n\nAttributes:\n- srv_channel: [ServerSocketChannel] - Server socket channel used in server mode\n- client_channel: [SocketChannel] - Client socket channel for communication\n- receiver_thread: [Receiver] - Thread handling incoming data reception\n- receiver: [RtReceiver] - Callback interface for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- server: [boolean] - Flag indicating if operating in server mode\n- direct_buffers: [boolean] - Flag indicating whether to use direct buffers\n- log: [Log] - Logger instance for logging messages\n\nMethods:\n- options(String... options) -> [void] - Configures transport options including server/client mode, host, port, and buffer type\n- receiver(RtReceiver receiver) -> [void] - Sets the receiver callback for incoming data\n- start(String... options) -> [void] - Starts the transport in either server or client mode based on configuration\n- stop() -> [void] - Stops the transport and releases resources\n- send(Object dest, byte[] buf, int offset, int length) -> [void] - Sends data through the established channel\n- Receiver.run() -> [void] - (Inner class method) Continuously receives data and forwards it to the registered receiver",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\n\npublic class NioTransport implements RtTransport {\n    protected ServerSocketChannel srv_channel;\n    protected SocketChannel       client_channel;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server, direct_buffers;\n    protected final Log           log=LogFactory.getLog(NioTransport.class);\n\n    public NioTransport() {\n    }\n\n    public void options(String... options) throws Exception {\n        if(options == null)\n            return;\n        for(int i=0; i < options.length; i++) {\n            if(options[i].equals(\"-server\")) {\n                server=true;\n                continue;\n            }\n            if(options[i].equals(\"-host\")) {\n                host=InetAddress.getByName(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-port\")) {\n                port=Integer.parseInt(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-direct\")) {\n                direct_buffers=Boolean.parseBoolean(options[++i]);\n            }\n        }\n        if(host == null)\n            host=InetAddress.getLocalHost();\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            srv_channel=ServerSocketChannel.open();\n            srv_channel.bind(new InetSocketAddress(host, port), 50);\n            System.out.println(\"server started (ctrl-c to kill)\");\n            for(;;) {\n                client_channel=srv_channel.accept();\n                receiver_thread=new Receiver();\n                receiver_thread.start();\n            }\n        }\n        else {\n            client_channel=SocketChannel.open();\n            client_channel.connect(new InetSocketAddress(host, port));\n            receiver_thread=new Receiver();\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(srv_channel, client_channel);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        ByteBuffer sbuf=ByteBuffer.wrap(buf, offset, length);\n        client_channel.write(sbuf);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            ByteBuffer buf=direct_buffers? ByteBuffer.allocateDirect(RoundTrip.PAYLOAD) : ByteBuffer.allocate(RoundTrip.PAYLOAD);\n            for(;;) {\n                try {\n                    buf.position(0);\n                    int num=client_channel.read(buf);\n                    if(num == -1)\n                        break;\n                    if(num != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + num);\n                    if(receiver != null) {\n                        buf.flip();\n                        int offset=buf.hasArray()? buf.arrayOffset() + buf.position() : buf.position(), len=buf.remaining();\n                        if(!buf.isDirect())\n                            receiver.receive(null, buf.array(), offset, len);\n                        else {\n                            byte[] tmp=new byte[len];\n                            buf.get(tmp, 0, len);\n                            receiver.receive(null, tmp, 0, len);\n                        }\n                    }\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(client_channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketChannel;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class NioTransport {\n    private ServerSocketChannel srv_channel;\n    private SocketChannel client_channel;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private boolean direct_buffers;\n    private Log log;\n\n    public void options(String... options) {\n        for (String opt : options) {\n            if (opt.startsWith(\"server\")) {\n                server = true;\n            } else if (opt.startsWith(\"client\")) {\n                server = false;\n            } else if (opt.startsWith(\"host\")) {\n                try {\n                    host = InetAddress.getByName(opt.substring(5));\n                } catch (Exception e) {\n                    log.error(\"Invalid host option: \" + opt, e);\n                }\n            } else if (opt.startsWith(\"port\")) {\n                try {\n                    port = Integer.parseInt(opt.substring(4));\n                } catch (Exception e) {\n                    log.error(\"Invalid port option: \" + opt, e);\n                }\n            } else if (opt.startsWith(\"direct\")) {\n                direct_buffers = true;\n            }\n        }\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void start(String... options) {\n        options(options);\n        if (server) {\n            try {\n                srv_channel = ServerSocketChannel.open();\n                srv_channel.configureBlocking(false);\n                InetSocketAddress address = new InetSocketAddress(host, port);\n                srv_channel.bind(address);\n                receiver_thread = new Thread(new Receiver());\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.error(\"Error starting server\", e);\n            }\n        } else {\n            try {\n                client_channel = SocketChannel.open();\n                client_channel.configureBlocking(false);\n                InetSocketAddress address = new InetSocketAddress(host, port);\n                client_channel.connect(address);\n            } catch (IOException e) {\n                log.error(\"Error starting client\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        if (server) {\n            try {\n                if (srv_channel != null) {\n                    srv_channel.close();\n                }\n            } catch (IOException e) {\n                log.error(\"Error stopping server\", e);\n            }\n        } else {\n            try {\n                if (client_channel != null) {\n                    client_channel.close();\n                }\n            } catch (IOException e) {\n                log.error(\"Error stopping client\", e);\n            }\n        }\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) {\n        if (server) {\n            try {\n                ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);\n                buffer.put(buf, offset, length);\n                buffer.flip();\n                client_channel.write(buffer);\n            } catch (IOException e) {\n                log.error(\"Error sending data\", e);\n            }\n        } else {\n            try {\n                ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);\n                buffer.put(buf, offset, length);\n                buffer.flip();\n                srv_channel.write(buffer);\n            } catch (IOException e) {\n                log.error(\"Error sending data\", e);\n            }\n        }\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(1024) : ByteBuffer.allocate(1024);\n                    int bytesRead = client_channel.read(buffer);\n                    if (bytesRead > 0) {\n                        buffer.flip();\n                        receiver.receive(buffer.array(), 0, bytesRead);\n                    }\n                } catch (IOException e) {\n                    log.error(\"Error receiving data\", e);\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketChannel;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ConnectionWorker implements Runnable {\n    private final Logger logger = LoggerFactory.getLogger(ConnectionWorker.class);\n    private volatile boolean stop;\n    private final Selector selector;\n    private final BlockingQueue<ConnectTask> myConnectQueue;\n    private final BlockingQueue<WriteTask> myWriteQueue;\n    private final Semaphore mySemaphore;\n    private final List<KeyProcessor> myKeyProcessors;\n    private final TimeService myTimeService;\n    private long lastCleanupTime;\n    private final int mySelectorTimeoutMillis;\n    private final long myCleanupTimeoutMillis;\n    private final CleanupProcessor myCleanupProcessor;\n    private final NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(Selector selector, BlockingQueue<ConnectTask> connectQueue, BlockingQueue<WriteTask> writeQueue, Semaphore semaphore, List<KeyProcessor> keyProcessors, TimeService timeService, int selectorTimeoutMillis, long cleanupTimeoutMillis, CleanupProcessor cleanupProcessor, NewConnectionAllower newConnectionAllower) {\n        this.selector = selector;\n        this.myConnectQueue = connectQueue;\n        this.myWriteQueue = writeQueue;\n        this.mySemaphore = semaphore;\n        this.myKeyProcessors = keyProcessors;\n        this.myTimeService = timeService;\n        this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n        this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n        this.myCleanupProcessor = cleanupProcessor;\n        this.myNewConnectionAllower = newConnectionAllower;\n        this.lastCleanupTime = myTimeService.currentTimeMillis();\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!stop) {\n                mySemaphore.acquire();\n                try {\n                    connectToPeersFromQueue();\n                    processSelectedKeys();\n                    if (needRunCleanup()) {\n                        cleanup();\n                    }\n                } finally {\n                    mySemaphore.release();\n                }\n                Thread.sleep(mySelectorTimeoutMillis);\n            }\n        } catch (InterruptedException e) {\n            logger.error(\"ConnectionWorker interrupted\", e);\n        } finally {\n            try {\n                selector.close();\n            } catch (IOException e) {\n                logger.error(\"Error closing selector\", e);\n            }\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        while (myConnectQueue.peek() != null && !stop) {\n            ConnectTask task = myConnectQueue.poll();\n            if (task != null && myNewConnectionAllower.allowNewConnections()) {\n                try {\n                    SocketChannel channel = SocketChannel.open(new InetSocketAddress(task.getHost(), task.getPort()));\n                    channel.configureBlocking(false);\n                    SelectionKey key = channel.register(selector, SelectionKey.OP_CONNECT);\n                    key.attach(task);\n                } catch (IOException e) {\n                    logger.error(\"Error connecting to peer\", e);\n                }\n            }\n        }\n    }\n\n    private void processSelectedKeys() {\n        int readyKeys = selector.select(mySelectorTimeoutMillis);\n        if (readyKeys > 0) {\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                processSelectedKey(key);\n            }\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        if (key.isValid() && key.isReadable()) {\n            // Handle read operation\n        } else if (key.isValid() && key.isWritable()) {\n            // Handle write operation\n        } else if (key.isValid() && key.isConnectable()) {\n            // Handle connection completion\n        } else if (key.isValid() && key.isAcceptable()) {\n            // Handle accept operation\n        }\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            queue.put(task);\n            return true;\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted while adding task to queue\", e);\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        // Process write tasks\n    }\n\n    private void cleanup() {\n        myCleanupProcessor.process();\n        lastCleanupTime = myTimeService.currentTimeMillis();\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.currentTimeMillis() - lastCleanupTime >= myCleanupTimeoutMillis;\n    }\n}"
  },
  {
    "Task_id": 436,
    "Instruction": "Task Description: Implement a TCP server using Apache MINA framework in Java that handles incoming connections, processes messages, and manages server lifecycle operations.\n\nClass Description: MinaRemotingServer is a concrete implementation of AbstractRemotingServer that uses Apache MINA for TCP communication. It handles server initialization, message processing, and shutdown procedures.\n\nAttributes:\n- acceptor: [IoAcceptor] - The MINA IO acceptor that manages socket connections\n- bindAddress: [InetSocketAddress] - The address and port the server binds to\n\nMethods:\n- serverStart() -> [void] - Initializes and starts the MINA TCP server by:\n  1. Creating a NioSocketAcceptor\n  2. Adding protocol codec and MDC injection filters\n  3. Setting the connection handler\n  4. Configuring session timeouts\n  5. Binding to the specified port\n  Throws RemotingException if startup fails\n\n- serverShutdown() -> [void] - Stops the server by:\n  1. Unbinding from the port\n  2. Disposing of the acceptor resources\n  Throws RemotingException if shutdown fails\n\n- MinaRemotingServer([RemotingServerConfig]) -> [void] - Constructor that initializes with server configuration\n- MinaRemotingServer([RemotingServerConfig], [ChannelEventListener]) -> [void] - Constructor that initializes with both server configuration and channel event listener",
    "Canonical_solution": "import com.github.ltsopensource.remoting.AbstractRemotingServer;\nimport com.github.ltsopensource.remoting.ChannelEventListener;\nimport com.github.ltsopensource.remoting.RemotingServerConfig;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.logging.MdcInjectionFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n    }\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig, ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        acceptor = new NioSocketAcceptor();\n        acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecFactory(getCodec())));\n        acceptor.getFilterChain().addLast(\"mdc\", new MdcInjectionFilter());\n        acceptor.setHandler(new MinaHandler(this));\n        IoSessionConfig cfg = acceptor.getSessionConfig();\n        cfg.setReaderIdleTime(remotingServerConfig.getReaderIdleTimeSeconds());\n        cfg.setWriterIdleTime(remotingServerConfig.getWriterIdleTimeSeconds());\n        cfg.setBothIdleTime(remotingServerConfig.getServerChannelMaxIdleTimeSeconds());\n\n        bindAddress = new InetSocketAddress(remotingServerConfig.getListenPort());\n        try {\n            acceptor.bind(bindAddress);\n        } catch (IOException e) {\n            throw new RemotingException(\"Start Mina server error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        if (acceptor != null) {\n            acceptor.unbind(bindAddress);\n            acceptor.dispose();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "wrong_result": "import org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.transport.nio.NioSocketAcceptor;\nimport org.apache.mina.filter.codec.ProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolEncoder;\nimport org.apache.mina.filter.io.IoFilterChain;\nimport org.apache.mina.filter.io.ReadTimeoutFilter;\nimport org.apache.mina.filter.io.WriteTimeoutFilter;\nimport org.apache.mina.filter.remoting.RemotingFilter;\nimport org.apache.mina.filter.remoting.RemotingFilterHandler;\nimport org.apache.mina.filter.remoting.RemotingFilterManager;\nimport org.apache.mina.filter.remoting.RemotingFilterManagerImpl;\nimport org.apache.mina.filter.remoting.RemotingFilterType;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.RemotingFilterUtil;\nimport org.apache.mina.filter.remoting.Rem"
  },
  {
    "Task_id": 437,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Apache MINA framework for RTMP (Real-Time Messaging Protocol) transport, with configurable network settings and JMX monitoring capabilities.\n\nClass Description: RTMPMinaTransport is a TCP server implementation using Apache MINA that handles RTMP connections. It provides configurable network parameters, thread pooling options, and JMX monitoring capabilities. The class manages server lifecycle (start/stop), connection handling, and performance statistics.\n\nAttributes:\n\n- log: Logger - Logger instance for the class\n- executor: ThreadPoolExecutor - Thread pool executor for custom acceptor mode\n- acceptor: SocketAcceptor - MINA socket acceptor instance\n- addresses: Set<String> - Set of IP addresses and ports to bind to\n- ioHandler: IoHandlerAdapter - Handler for IO events\n- ioThreads: int - Number of IO threads (default: 2 * available processors)\n- serviceManagerObjectName: ObjectName - JMX MBean object name\n- stats: IoServiceStatistics - MINA service statistics\n- enableMinaLogFilter: boolean - Flag to enable MINA logging filter\n- enableMinaMonitor: boolean - Flag to enable JMX monitoring\n- minaPollInterval: int - JMX poll interval in ms (default: 1000)\n- tcpNoDelay: boolean - TCP_NODELAY flag (default: true)\n- useHeapBuffers: boolean - Use heap buffers flag (default: true)\n- sendBufferSize: int - Socket send buffer size (default: 65536)\n- receiveBufferSize: int - Socket receive buffer size (default: 65536)\n- readerIdleTime: int - Reader idle time in seconds (default: 2)\n- trafficClass: int - IP traffic class (default: 0x08 | 0x10)\n- backlog: int - Connection backlog (default: 32)\n- thoughputCalcInterval: int - Throughput calculation interval (default: 1)\n- executorKeepAliveTime: long - Thread keep-alive time in ms (default: 60000)\n- enableDefaultAcceptor: boolean - Use default acceptor flag (default: true)\n- initialPoolSize: int - Initial thread pool size (default: 0)\n- maxPoolSize: int - Maximum thread pool size (default: processors + 1)\n- maxProcessorPoolSize: int - Maximum processor pool size (default: 16)\n- keepAlive: boolean - Socket keep-alive flag\n\nMethods:\n\n- start() throws Exception -> void - Starts the TCP server with configured settings\n- stop() -> void - Stops the TCP server and cleans up resources\n- setAddress(String address) -> void - Adds a single address to bind to\n- setAddresses(List<String> addrs) -> void - Adds multiple addresses to bind to\n- setIoHandler(IoHandlerAdapter rtmpIOHandler) -> void - Sets the IO handler\n- setIoThreads(int ioThreads) -> void - Sets number of IO threads\n- setSendBufferSize(int sendBufferSize) -> void - Sets send buffer size\n- setReceiveBufferSize(int receiveBufferSize) -> void - Sets receive buffer size\n- setTrafficClass(int trafficClass) -> void - Sets IP traffic class\n- setBacklog(int backlog) -> void - Sets connection backlog\n- setThoughputCalcInterval(int thoughputCalcInterval) -> void - Sets throughput calculation interval\n- setExecutorKeepAliveTime(long executorKeepAliveTime) -> void - Sets thread keep-alive time\n- setEnableDefaultAcceptor(boolean enableDefaultAcceptor) -> void - Sets default acceptor flag\n- setInitialPoolSize(int initialPoolSize) -> void - Sets initial thread pool size\n- setMaxPoolSize(int maxPoolSize) -> void - Sets maximum thread pool size\n- setMaxProcessorPoolSize(int maxProcessorPoolSize) -> void - Sets maximum processor pool size\n- setTcpNoDelay(boolean tcpNoDelay) -> void - Sets TCP_NODELAY flag\n- setKeepAlive(boolean keepAlive) -> void - Sets socket keep-alive flag\n- setUseHeapBuffers(boolean useHeapBuffers) -> void - Sets heap buffers flag\n- setEnableMinaLogFilter(boolean enableMinaLogFilter) -> void - Enables/disables MINA logging filter\n- setEnableMinaMonitor(boolean enableMinaMonitor) -> void - Enables/disables JMX monitoring\n- setMinaPollInterval(int minaPollInterval) -> void - Sets JMX poll interval\n- setReaderIdleTime(int readerIdleTime) -> void - Sets reader idle time\n- isEnableMinaLogFilter() -> boolean - Returns MINA logging filter status\n- getAddress() -> String - Returns bound addresses as string",
    "Canonical_solution": "import java.lang.management.ManagementFactory;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport javax.management.StandardMBean;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\nimport org.apache.mina.transport.socket.nio.NioProcessor;\nimport org.apache.mina.transport.socket.nio.NioSession;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.red5.server.jmx.mxbeans.RTMPMinaTransportMXBean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RTMPMinaTransport implements RTMPMinaTransportMXBean {\n\n    private static final Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n\n    private ThreadPoolExecutor executor;\n\n    protected SocketAcceptor acceptor;\n\n    protected Set<String> addresses = new HashSet<String>();\n\n    protected IoHandlerAdapter ioHandler;\n\n    protected int ioThreads = Runtime.getRuntime().availableProcessors() * 2;\n\n    protected ObjectName serviceManagerObjectName;\n\n    protected IoServiceStatistics stats;\n\n    public void start() throws Exception {\n        IoBuffer.setUseDirectBuffer(!useHeapBuffers);\n        if (useHeapBuffers) {\n            IoBuffer.setAllocator(new SimpleBufferAllocator());\n        }\n        if (enableDefaultAcceptor) {\n            acceptor = new NioSocketAcceptor(ioThreads);\n        } else {\n            SimpleIoProcessorPool<NioSession> pool = new SimpleIoProcessorPool<NioSession>(NioProcessor.class, maxProcessorPoolSize);\n            executor = new ThreadPoolExecutor(initialPoolSize, maxPoolSize, executorKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(Short.MAX_VALUE));\n            acceptor = new NioSocketAcceptor(executor, pool);\n        }\n        if (enableMinaLogFilter) {\n            DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();\n            LoggingFilter logFilter = new LoggingFilter(RTMPMinaTransport.class);\n            chain.addLast(\"logger\", logFilter);\n        }\n        acceptor.setCloseOnDeactivation(true);\n        acceptor.setHandler(ioHandler);\n        acceptor.setBacklog(backlog);\n        SocketSessionConfig sessionConf = acceptor.getSessionConfig();\n        sessionConf.setReuseAddress(true);\n        sessionConf.setTcpNoDelay(tcpNoDelay);\n        sessionConf.setSendBufferSize(sendBufferSize);\n        sessionConf.setReceiveBufferSize(receiveBufferSize);\n        sessionConf.setMaxReadBufferSize(receiveBufferSize);\n        sessionConf.setThroughputCalculationInterval(thoughputCalcInterval);\n        sessionConf.setReaderIdleTime(readerIdleTime);\n        sessionConf.setKeepAlive(keepAlive);\n        if (trafficClass != -1) {\n            sessionConf.setTrafficClass(trafficClass);\n        }\n        acceptor.setReuseAddress(true);\n        Set<InetSocketAddress> socketAddresses = new HashSet<InetSocketAddress>();\n        for (String addr : addresses) {\n            if (addr.indexOf(':') != -1) {\n                String[] parts = addr.split(\":\");\n                socketAddresses.add(new InetSocketAddress(parts[0], Integer.valueOf(parts[1])));\n            } else {\n                socketAddresses.add(new InetSocketAddress(addr, 1935));\n            }\n        }\n        acceptor.bind(socketAddresses);\n        if (enableMinaMonitor) {\n            stats = new IoServiceStatistics((AbstractIoService) acceptor);\n            stats.setThroughputCalculationInterval(minaPollInterval);\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                serviceManagerObjectName = new ObjectName(\"org.red5.server:type=RTMPMinaTransport\");\n                mbs.registerMBean(new StandardMBean(this, RTMPMinaTransportMXBean.class, true), serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx registration\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        acceptor.unbind();\n        if (!enableDefaultAcceptor) {\n            executor.shutdownNow();\n        }\n        acceptor.dispose(false);\n        if (serviceManagerObjectName != null) {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                mbs.unregisterMBean(serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx unregistration\", e);\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        for (String addr : addrs) {\n            addresses.add(addr);\n        }\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    protected boolean enableMinaLogFilter;\n\n    protected boolean enableMinaMonitor;\n\n    protected int minaPollInterval = 1000;\n\n    protected boolean tcpNoDelay = true;\n\n    protected boolean useHeapBuffers = true;\n\n    protected int sendBufferSize = 65536;\n\n    protected int receiveBufferSize = 65536;\n\n    private int readerIdleTime = 2;\n\n    private int trafficClass = 0x08 | 0x10;\n\n    private int backlog = 32;\n\n    private int thoughputCalcInterval = 1;\n\n    private long executorKeepAliveTime = 60000;\n\n    private boolean enableDefaultAcceptor = true;\n\n    private int initialPoolSize = 0;\n\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n\n    private int maxProcessorPoolSize = 16;\n\n    private boolean keepAlive;\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public String getAddress() {\n        return addresses.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "wrong_result": "import org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.executor.ExecutorFilter;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.idle.IdleDetector;\nimport org.apache.mina.filter.idle.IdleStatus;\nimport org.apache.mina.filter.idle.IdleHandler;\nimport org.apache.mina.filter.chain.IoFilterChain;\nimport org.apache.mina.filter.chain.IoFilterChainBuilder;\nimport org.apache.mina.filter.codec.ProtocolCodecFactory;\nimport org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.filter.timeout.IdleTimeoutHandler;\nimport org.apache.mina.filter.timeout.TimeoutFilter;\nimport org.apache.mina.filter.timeout.TimeoutSession;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChainBuilder;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Java class that handles HTTP communication with a hub service, specifically for device registration and key management.\n\nClass Description: The HubHttpClient class provides functionality to register a device with a remote hub service using HTTP requests. It handles JSON serialization, authentication, and response processing, while supporting asynchronous operations.\n\nAttributes:\n- JSON: ObjectMapper - A static instance for JSON serialization/deserialization\n- EXPECTED_RESPONSE_CODES: List<Integer> - List of acceptable HTTP response codes\n- hubConfig: HubConfig - Configuration for the hub service\n- bearerToken: String - Authentication token for API requests\n- deviceId: String - Unique identifier for the device\n- keyPair: P384KeyPair - Cryptographic key pair for the device\n- result: CompletableFuture<ReceivedKey> - Future for asynchronous result handling\n- httpClient: HttpClient - HTTP client for making requests\n\nMethods:\n- HubHttpClient(ExecutorService, HubConfig, String, DeviceKey, CompletableFuture<ReceivedKey>, AtomicReference<String>) -> None - Constructor that initializes the HTTP client with configuration and credentials\n- registerDevice(String) -> None - Registers a device with the hub service using the provided device name\n- toJson(CreateDeviceDto) -> String - Serializes a DTO to JSON string\n- handleResponse(HttpResponse<Void>) -> HttpResponse<Void> - Processes the HTTP response\n- registrationFailed(Throwable) -> None - Handles failed registration attempts\n\nNested Class:\n- CreateDeviceDto - Data transfer object for device registration containing:\n  * id: String - Device identifier\n  * name: String - Device name\n  * type: String - Constant device type (\"DESKTOP\")\n  * publicKey: String - Base64-encoded public key",
    "Canonical_solution": "import com.auth0.jwt.JWT;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.fasterxml.jackson.core.JacksonException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.cryptomator.common.settings.DeviceKey;\nimport org.cryptomator.cryptolib.common.P384KeyPair;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class HubHttpClient {\n\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(201, 409);\n\n\tprivate final HubConfig hubConfig;\n\tprivate final String bearerToken;\n\tprivate final String deviceId;\n\tprivate final P384KeyPair keyPair;\n\tprivate final CompletableFuture<ReceivedKey> result;\n\tprivate final HttpClient httpClient;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> bearerToken) {\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.keyPair = Objects.requireNonNull(deviceKey.get());\n\t\tthis.result = result;\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken.get());\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t}\n\n\tpublic void registerDevice(String deviceName) {\n\t\tvar deviceUri = URI.create(hubConfig.devicesResourceUrl + deviceId);\n\t\tvar deviceKey = keyPair.getPublic().getEncoded();\n\t\tvar dto = new CreateDeviceDto();\n\t\tdto.id = deviceId;\n\t\tdto.name = deviceName;\n\t\tdto.publicKey = Base64.getUrlEncoder().withoutPadding().encodeToString(deviceKey);\n\t\tvar json = toJson(dto);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.PUT(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.build();\n\t\thttpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n\t\t\t\t.thenApply(response -> {\n\t\t\t\t\tif (EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Server answered with unexpected status code \" + response.statusCode());\n\t\t\t\t\t}\n\t\t\t\t}).handle((response, throwable) -> {\n\t\t\t\t\tif (response != null) {\n\t\t\t\t\t\treturn handleResponse(response);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregistrationFailed(throwable);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tprivate String toJson(CreateDeviceDto dto) {\n\t\ttry {\n\t\t\treturn JSON.writer().writeValueAsString(dto);\n\t\t} catch (JacksonException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to serialize DTO\", e);\n\t\t}\n\t}\n\n\tprivate HttpResponse<Void> handleResponse(HttpResponse<Void> voidHttpResponse) {\n\t\tassert EXPECTED_RESPONSE_CODES.contains(voidHttpResponse.statusCode());\n\t\treturn voidHttpResponse;\n\t}\n\n\tprivate void registrationFailed(Throwable cause) {\n\t\tresult.completeExceptionally(cause);\n\t}\n\n\tprivate static class CreateDeviceDto {\n\t\tpublic String id;\n\t\tpublic String name;\n\t\tpublic final String type = \"DESKTOP\";\n\t\tpublic String publicKey;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.security.interfaces.P384KeyPair;\nimport java.security.interfaces.ECPublicKey;\n\npublic class HubHttpClient {\n    public static final ObjectMapper JSON = new ObjectMapper();\n    public static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(200, 201);\n\n    private final HubConfig hubConfig;\n    private final String bearerToken;\n    private final String deviceId;\n    private final P384KeyPair keyPair;\n    private final CompletableFuture<ReceivedKey> result;\n    private final HttpClient httpClient;\n    private final AtomicReference<String> responseMessage;\n\n    public HubHttpClient(ExecutorService executorService, HubConfig hubConfig, String bearerToken, String deviceId, P384KeyPair keyPair, CompletableFuture<ReceivedKey> result, AtomicReference<String> responseMessage) {\n        this.hubConfig = hubConfig;\n        this.bearerToken = bearerToken;\n        this.deviceId = deviceId;\n        this.keyPair = keyPair;\n        this.result = result;\n        this.responseMessage = responseMessage;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public void registerDevice(String deviceName) {\n        CreateDeviceDto dto = new CreateDeviceDto();\n        dto.setId(deviceId);\n        dto.setName(deviceName);\n        dto.setType(\"DESKTOP\");\n        dto.setPublicKey(keyPair.getPublic().getEncoded().toString());\n        String json = toJson(dto);\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(hubConfig.getUrl() + \"/devices\"))\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(json))\n                .build();\n        try {\n            HttpResponse<Void> response = httpClient.send(request, HttpResponse.BodyHandlers.discarding());\n            if (EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n                handleResponse(response);\n            } else {\n                registrationFailed(new Throwable(\"Unexpected HTTP status code: \" + response.statusCode()));\n            }\n        } catch (Exception e) {\n            registrationFailed(e);\n        }\n    }\n\n    private String toJson(CreateDeviceDto dto) {\n        try {\n            return JSON.writeValueAsString(dto);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error serializing DTO to JSON\", e);\n        }\n    }\n\n    private HttpResponse<Void> handleResponse(HttpResponse<Void> response) {\n        try {\n            String responseBody = response.body().toString();\n            responseMessage.set(responseBody);\n            result.complete(new ReceivedKey());\n        } catch (Exception e) {\n            registrationFailed(e);\n        }\n        return response;\n    }\n\n    private void registrationFailed(Throwable throwable) {\n        responseMessage.set(\"Registration failed: \" + throwable.getMessage());\n        result.completeExceptionally(throwable);\n    }\n\n    public static class CreateDeviceDto {\n        private String id;\n        private String name;\n        private String type;\n        private String publicKey;\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n\n        public String getPublicKey() {\n            return publicKey;\n        }\n\n        public void setPublicKey(String publicKey) {\n            this.publicKey = publicKey;\n        }\n    }\n\n    public static class ReceivedKey {\n        // Add necessary fields and methods for the received key\n    }\n}"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocketChannel;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Collection;\nimport java.util.Iterator;\n\npublic class Server implements Component {\n    private int SERVER_PORT;\n    private NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public void start(Collection<DHT> dhts, ConfigReader config) {\n        this.dhts = dhts;\n        this.SERVER_PORT = config.getPort();\n        try {\n            acceptor = ServerSocketChannel.open();\n            acceptor.configureBlocking(false);\n            acceptor.bind(new InetSocketAddress(SERVER_PORT));\n            conMan = new NIOConnectionManager();\n            conMan.register(acceptor, SelectionKey.OP_ACCEPT);\n            conMan.select();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (acceptor != null) {\n                acceptor.close();\n            }\n            if (conMan != null) {\n                conMan.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void accept() {\n        try {\n            SocketChannel client = acceptor.accept();\n            if (client != null) {\n                client.configureBlocking(false);\n                conMan.register(client, SelectionKey.OP_READ);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void read() {\n        try {\n            SelectionKey key = conMan.select();\n            if (key.isReadable()) {\n                SocketChannel client = (SocketChannel) key.channel();\n                ByteBuffer buf = ByteBuffer.allocate(4);\n                int bytesRead = client.read(buf);\n                if (bytesRead > 0) {\n                    buf.flip();\n                    int length = buf.getInt();\n                    ByteBuffer payload = ByteBuffer.allocate(length);\n                    bytesRead = client.read(payload);\n                    if (bytesRead > 0) {\n                        process(payload);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void process(ByteBuffer buf) {\n        try {\n            String data = decode(buf);\n            for (DHT dht : dhts) {\n                dht.process(data);\n            }\n            write(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void write(String data) {\n        try {\n            ByteBuffer buf = ByteBuffer.wrap(data.getBytes());\n            SocketChannel client = (SocketChannel) getChannel();\n            client.write(buf);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int calcInterestOps() {\n        return SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n    }\n\n    public void selectionEvent(SelectionKey key) {\n        if (key.isAcceptable()) {\n            accept();\n        } else if (key.isReadable()) {\n            read();\n        } else if (key.isWritable()) {\n            write();\n        }\n    }\n\n    public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n        if (key.isAcceptable()) {\n            accept();\n        } else if (key.isReadable()) {\n            read();\n        } else if (key.isWritable()) {\n            write();\n        }\n    }\n\n    public SelectableChannel getChannel() {\n        return acceptor;\n    }\n\n    public void doStateChecks(long now) {\n        // Empty implementation\n    }\n}"
  },
  {
    "Task_id": 442,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data packets with checksum verification, and manages resources efficiently.\n\nClass Description: NIOServer - A non-blocking TCP server implementation using Java NIO that handles multiple client connections through a single selector thread.\n\nAttributes:\n- serverChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The multiplexor that manages multiple client connections\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port and begins accepting connections\n  - Input: port (int) - The port number to bind the server to\n  - Output: None (throws Exception if startup fails)\n  \n- stop() -> void - Shuts down the server and releases all resources\n  - Input: None\n  - Output: None (handles exceptions internally)\n  \n- handleAccept(SelectionKey key) -> void - Handles new client connection acceptance\n  - Input: key (SelectionKey) - The selection key representing the accept event\n  - Output: None (throws Exception if connection acceptance fails)\n  \n- handleRead(SelectionKey key) -> void - Handles incoming data from clients with checksum verification\n  - Input: key (SelectionKey) - The selection key representing the read event\n  - Output: None (handles exceptions internally)\n  \n- isFull(ByteBuffer buffer) -> boolean - Helper method to check if a buffer is full\n  - Input: buffer (ByteBuffer) - The buffer to check\n  - Output: boolean - True if buffer is full, false otherwise",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().setReuseAddress(true);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        \n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        \n        while (selector.isOpen()) {\n            if (selector.select(3000) == 0) {\n                continue;\n            }\n            \n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                it.remove();\n                \n                if (!key.isValid()) {\n                    continue;\n                }\n                \n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                } else if (key.isReadable()) {\n                    handleRead(key);\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(key.selector(), SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel channel = (SocketChannel) key.channel();\n        try {\n            ByteBuffer head = ByteBuffer.allocate(4);\n            while (!isFull(head)) {\n                if (channel.read(head) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            head.flip();\n            int dataSize = head.getInt();\n            \n            ByteBuffer body = ByteBuffer.allocate(dataSize);\n            while (!isFull(body)) {\n                if (channel.read(body) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            \n            ByteBuffer tail = ByteBuffer.allocate(8);\n            while (!isFull(tail)) {\n                if (channel.read(tail) == -1) {\n                    break;\n                }\n            }\n            tail.flip();\n            \n            Checksum checksum = new Adler32();\n            checksum.update(body.array(), 0, dataSize);\n            if (tail.getLong() != checksum.getValue()) {\n                throw new RuntimeException(\"Data corrupted\");\n            }\n            \n            body.flip();\n            // Process packet here\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                channel.close();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.StandardProtocolFamily;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws IOException {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.bind(new InetSocketAddress(port), 100);\n        serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            clientChannel.register(selector, SelectionKey.OP_READ);\n        }\n    }\n\n    public void handleRead(SelectionKey key) {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        try {\n            int bytesRead = clientChannel.read(buffer);\n            if (bytesRead > 0) {\n                buffer.flip();\n                byte[] data = new byte[buffer.remaining()];\n                buffer.get(data);\n                buffer.clear();\n                if (isFull(buffer)) {\n                    System.out.println(\"Buffer is full\");\n                }\n                // Checksum verification logic would go here\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n}"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOAcceptor {\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private final NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    static class AcceptIdGenerator {\n        private long acceptId = 0;\n        private final Object lock = new Object();\n\n        public long getId() {\n            synchronized (lock) {\n                return acceptId++;\n            }\n        }\n    }\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) throws IOException {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.nextProcessor = 0;\n        this.acceptCount = 0;\n\n        selector = Selector.open();\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.bind(new InetSocketAddress(port));\n        serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                selector.select();\n                Set<SelectionKey> keys = selector.selectedKeys();\n                Iterator<SelectionKey> iterator = keys.iterator();\n\n                while (iterator.hasNext()) {\n                    SelectionKey key = iterator.next();\n                    iterator.remove();\n\n                    if (key.isAcceptable()) {\n                        accept();\n                    } else if (key.isReadable()) {\n                        // Handle read operations\n                    } else if (key.isWritable()) {\n                        // Handle write operations\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    public void accept() throws IOException {\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            FrontendConnection connection = factory.createConnection(clientChannel);\n            NIOProcessor processor = nextProcessor();\n            processor.register(connection);\n            acceptCount++;\n        }\n    }\n\n    public NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n    public void closeChannel(SocketChannel channel) {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n            if (selector != null) {\n                selector.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramChannel;\nimport java.net.InetAddress;\nimport java.net.InterfaceAddress;\nimport java.net.NetworkInterface;\nimport java.net.ProtocolFamily;\nimport java.net.SocketException;\nimport java.util.Enumeration;\nimport java.util.List;\n\npublic class MulticastSender {\n    private DatagramChannel sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws IOException {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n        this.prot_family = (System.getProperty(\"os.name\").toLowerCase().contains(\"win\") ? ProtocolFamily.INET : ProtocolFamily.INET6);\n\n        sock = DatagramChannel.open(prot_family);\n        sock.configureBlocking(false);\n        sock.bind(null);\n        sock.socket().setReuseAddress(true);\n        sock.socket().setSoTimeout(1000);\n        sock.socket().setMulticastTimeToLive(ttl);\n        sock.socket().joinGroup(mcast_addr, null);\n    }\n\n    public void start() throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while (true) {\n            System.out.print(\"Enter message to send (or 'exit' to quit): \");\n            String line = in.readLine();\n            if (line == null || line.equalsIgnoreCase(\"exit\")) {\n                break;\n            }\n            byte[] data = line.getBytes();\n            sock.send(DatagramPacket.wrap(data, 0, data.length), mcast_addr, mcast_port);\n        }\n    }\n\n    public void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) throws IOException {\n        for (NetworkInterface ni : interfaces) {\n            InterfaceAddress ia = ni.getInterfaceAddresses().iterator().next();\n            s.joinGroup(mcast_addr, ia.getInterface());\n        }\n    }\n}"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a TCP proxy server using Vert.x that forwards incoming connections to a remote server after writing a custom header.\n\nClass Description: The HAProxy class acts as a TCP proxy server that listens for incoming connections, establishes connections to a remote server, writes a specified header to the remote connection, and then pipes data bidirectionally between the client and server.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and error messages\n- HOST: String - The host address where the proxy server will listen (default: \"localhost\")\n- PORT: int - The port number where the proxy server will listen (default: 11080)\n- remoteAddress: SocketAddress - The address of the remote server to forward connections to\n- header: Buffer - The header data to write to the remote connection\n- server: NetServer - The Vert.x TCP server instance\n- client: NetClient - The Vert.x TCP client instance for connecting to remote server\n- connectionRemoteAddress: SocketAddress - Stores the remote address of the established connection\n- connectionLocalAddress: SocketAddress - Stores the local address of the established connection\n\nMethods:\n- HAProxy(SocketAddress remoteAddress, Buffer header) -> HAProxy - Constructor that initializes the proxy with remote server address and header data\n- start(Vertx vertx) -> HAProxy - Starts the proxy server, configures connection handling, and returns the instance (throws Exception if startup fails)\n- stop() -> void - Stops the proxy server and cleans up resources\n- getConnectionRemoteAddress() -> SocketAddress - Returns the remote address of the established connection\n- getConnectionLocalAddress() -> SocketAddress - Returns the local address of the established connection",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class HAProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        NetServerOptions options = new NetServerOptions();\n        options.setHost(HOST).setPort(PORT);\n        server = vertx.createNetServer(options);\n        client = vertx.createNetClient();\n\n        server.connectHandler(socket -> {\n            socket.pause();\n            client.connect(remoteAddress).onComplete(result -> {\n                if (result.succeeded()) {\n                    log.debug(\"connected, writing header\");\n                    NetSocket clientSocket = result.result();\n                    connectionRemoteAddress = clientSocket.remoteAddress();\n                    connectionLocalAddress = clientSocket.localAddress();\n                    clientSocket.write(header).onSuccess(u -> {\n                        log.debug(\"starting pump\");\n                        socket.closeHandler(v -> clientSocket.close());\n                        clientSocket.closeHandler(v -> socket.close());\n                        socket.pipeTo(clientSocket);\n                        clientSocket.pipeTo(socket);\n                        socket.resume();\n                    }).onFailure(u -> {\n                        log.error(\"exception writing header\", result.cause());\n                        socket.close();\n                    });\n                } else {\n                    log.error(\"exception\", result.cause());\n                    socket.close();\n                }\n            });\n        });\n\n        CompletableFuture<Void> fut = new CompletableFuture<>();\n        server.listen().onComplete(ar -> {\n            if (ar.succeeded()) {\n                fut.complete(null);\n            } else {\n                fut.completeExceptionally(ar.cause());\n            }\n        });\n        fut.get(10, TimeUnit.SECONDS);\n        log.debug(\"HAProxy server started\");\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n            server = null;\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.SocketAddress;\n\npublic class HAProxy extends AbstractVerticle {\n    private final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private String HOST = \"localhost\";\n    private int PORT = 11080;\n    private SocketAddress remoteAddress;\n    private Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy(String host, int port, SocketAddress remoteAddress, Buffer header) {\n        this.HOST = host;\n        this.PORT = port;\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        server = Vertx.vertx().createNetServer();\n        server.listen(PORT, ar -> {\n            if (ar.succeeded()) {\n                log.info(\"TCP proxy server started on \" + HOST + \":\" + PORT);\n                server.handler(this::handleClientConnection);\n            } else {\n                log.error(\"Failed to start TCP proxy server: \" + ar.cause().getMessage());\n                throw new Exception(\"Failed to start TCP proxy server\");\n            }\n        });\n\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n\n    private void handleClientConnection(io.vertx.core.net.NetSocket socket) {\n        connectionLocalAddress = socket.localAddress();\n        connectionRemoteAddress = socket.remoteAddress();\n\n        try {\n            client = Vertx.vertx().createNetClient();\n            client.connect(remoteAddress.getPort(), remoteAddress.getHost(), ar -> {\n                if (ar.succeeded()) {\n                    NetSocket remoteSocket = ar.result();\n                    remoteSocket.write(header);\n                    socket.pipe(remoteSocket);\n                    remoteSocket.pipe(socket);\n                } else {\n                    log.error(\"Failed to connect to remote server: \" + ar.cause().getMessage());\n                }\n            });\n        } catch (Exception e) {\n            log.error(\"Error handling client connection: \" + e.getMessage());\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}\n```"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with a radio scanner API, supporting both synchronous and asynchronous requests.\n\nClass Description: The RdioScannerHttpClient class provides methods to test API connections and send audio recordings to a radio scanner service using HTTP multipart form data requests. It uses Java's HttpClient for HTTP/2 communication with configurable timeouts and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection]([RdioScannerConfiguration configuration]) -> [String] - Synchronously tests the API connection by sending a test request with the API key and system ID, returns the response body with status code or error message\n- sendAudioRecordingAsync: [sendAudioRecordingAsync]([RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder]) -> [void] - Asynchronously sends an audio recording to the API using multipart form data, handles response completion with success/error callbacks",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class RdioScannerHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        RdioScannerBuilder bodyBuilder = new RdioScannerBuilder();\n        bodyBuilder.addPart(FormField.KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(config.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        // Handle error cases\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RdioScannerHttpClient {\n    private final HttpClient mHttpClient;\n\n    public RdioScannerHttpClient() {\n        mHttpClient = HttpClient.newHttpClient()\n                .newBuilder()\n                .followRedirects(java.net.http.Redirect.NORMAL)\n                .connectTimeout(Duration.ofSeconds(20))\n                .build();\n    }\n\n    public String testConnection(RdioScannerConfiguration configuration) throws Exception {\n        String url = \"https://api.rdio.com/v1/scanner/test\";\n        String apiKey = configuration.getApiKey();\n        String systemId = configuration.getSystemId();\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .header(\"Authorization\", \"Bearer \" + apiKey)\n                .header(\"X-System-ID\", systemId)\n                .GET()\n                .build();\n\n        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        return response.statusCode() + \" - \" + response.body();\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        String url = \"https://api.rdio.com/v1/scanner/upload\";\n        String apiKey = config.getApiKey();\n        String systemId = config.getSystemId();\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .header(\"Authorization\", \"Bearer \" + apiKey)\n                .header(\"X-System-ID\", systemId)\n                .POST(HttpRequest.BodyPublishers.ofString(bodyBuilder.build()))\n                .build();\n\n        CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n                return \"Success: \" + response.statusCode() + \" - \" + response.body();\n            } catch (Exception e) {\n                return \"Error: \" + e.getMessage();\n            }\n        }).thenAccept(result -> System.out.println(result));\n    }\n}"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class VertxTcpServer {\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        server = vertx.createNetServer();\n        server.bind(port, host, ar -> {\n            if (ar.succeeded()) {\n                server.listen((evt) -> {\n                    if (evt.succeeded()) {\n                        System.out.println(\"Server started on \" + host + \":\" + port);\n                    } else {\n                        System.err.println(\"Failed to start server: \" + evt.cause().getMessage());\n                    }\n                });\n            } else {\n                System.err.println(\"Failed to bind server: \" + ar.cause().getMessage());\n            }\n        });\n    }\n\n    public void handleConnection(NetSocket socket) {\n        socket.handler(buf -> {\n            byte[] data = buf.array();\n            System.out.println(\"Received data: \" + new String(data));\n            socket.write(buf);\n        });\n\n        socket.exceptionHandler(throwable -> {\n            System.err.println(\"Exception in socket: \" + throwable.getMessage());\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close(ar -> {\n                if (ar.succeeded()) {\n                    System.out.println(\"Server stopped successfully\");\n                } else {\n                    System.err.println(\"Failed to stop server: \" + ar.cause().getMessage());\n                }\n            });\n        }\n    }\n}"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.SocketAddress;\nimport io.vertx.core.Handler;\n\npublic class ClusteredEventBus extends EventBusImpl {\n    private final Vertx vertx;\n    private final EventBusOptions options;\n    private NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        this.vertx = vertx;\n        this.options = new EventBusOptions(options);\n    }\n\n    public NetServerOptions getServerOptions() {\n        NetServerOptions serverOptions = new NetServerOptions();\n        serverOptions.setPort(getClusterPort());\n        serverOptions.setHost(getClusterHost());\n        return serverOptions;\n    }\n\n    public void start(Promise<Void> promise) {\n        NetServerOptions serverOptions = getServerOptions();\n        server = vertx.createNetServer(serverOptions);\n        server.listen(promise);\n    }\n\n    public Handler<NetSocket> getServerHandler() {\n        return new Handler<NetSocket>() {\n            @Override\n            public void handle(NetSocket socket) {\n                // Process incoming message\n                socket.handler(buffer -> {\n                    String message = buffer.toString();\n                    // Deliver message locally within the cluster\n                    // This is a placeholder for actual message delivery logic\n                    System.out.println(\"Received message: \" + message);\n                });\n            }\n        };\n    }\n\n    public int getClusterPort() {\n        return options.getPort();\n    }\n\n    public String getClusterHost() {\n        return options.getHost() != null ? options.getHost() : \"localhost\";\n    }\n}\n```"
  },
  {
    "Task_id": 453,
    "Instruction": "Task Description: Implement a function that demonstrates UDP communication using Vert.x in Java, allowing sending of data packets to a specified target address and port, with success/failure notification.\n\nFunction Description: The function creates a UDP socket using Vert.x, configures it with default options, and demonstrates two ways to send data: using a Buffer object and directly using a String. It includes asynchronous result handling to report whether each send operation succeeded.\n\nInput:\n- vertx: Vertx - The Vert.x instance used to create the UDP socket\n\nOutput: None (The function's output is the side effect of sending UDP packets and printing success/failure messages to the console)",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic void example2(Vertx vertx) {\n    DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n    Buffer buffer = Buffer.buffer(\"content\");\n    socket\n      .send(buffer, 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n    socket\n      .send(\"A string used as content\", 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 14,
    "wrong_result": "vertx.createSharedWorkerVerticle(() -> {\n    Vertx vertx = Vertx.vertx();\n    UDP udp = vertx.createUDP();\n    udp.bind(8080);\n\n    // Send using Buffer\n    Buffer buffer = Buffer.buffer(\"Hello, UDP!\");\n    udp.send(buffer, 127.0, 8081, ar -> {\n        if (ar.succeeded()) {\n            System.out.println(\"Sent via Buffer: Success\");\n        } else {\n            System.out.println(\"Sent via Buffer: Failed - \" + ar.cause().getMessage());\n        }\n    });\n\n    // Send using String\n    udp.send(\"Hello, UDP!\", 127.0, 8081, ar -> {\n        if (ar.succeeded()) {\n            System.out.println(\"Sent via String: Success\");\n        } else {\n            System.out.println(\"Sent via String: Failed - \" + ar.cause().getMessage());\n        }\n    });\n});"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a Java class for HTTP communication that supports both HTTP and HTTPS protocols, with methods for GET and POST requests, including SSL configuration for secure connections.\n\nClass Description: The HttpCommunicationClient class provides functionality for making HTTP/HTTPS requests with configurable SSL settings. It supports both synchronous GET and POST operations with customizable headers and request bodies.\n\nAttributes:\n- usesSSL: boolean - Indicates whether to use HTTPS (true) or HTTP (false)\n- sslContext: SSLContext - SSL context configuration for HTTPS connections\n- address: InetSocketAddress - The target server address (host and port)\n- uri: URI - Base URI constructed from the address and protocol\n- httpClient: HttpClient - The HTTP client instance for making requests\n- trustAll: TrustManager[] - Array of trust managers that accept all certificates (bypasses SSL verification)\n\nMethods:\n- HttpCommunicationClient(boolean useSSL) -> Constructor - Initializes the client with SSL configuration\n- initialize(InetSocketAddress address) -> void - Sets up the HTTP client with target address and creates base URI\n- get(String urlPath) -> HttpResponse<String> - Sends a GET request to the specified URL path and returns the response\n- post(String urlPath, String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the specified URL path\n- post(String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the base URI",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Locale;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class HttpCommunicationClient {\n\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private InetSocketAddress address;\n    protected URI uri;\n    protected HttpClient httpClient;\n\n    private static TrustManager[] trustAll = new TrustManager[]{\n        new X509ExtendedTrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n        }\n    };\n\n    public HttpCommunicationClient(boolean useSSL) {\n        try {\n            sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(null, trustAll, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.usesSSL = useSSL;\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .sslContext(sslContext)\n            .build();\n        this.address = address;\n        this.uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/_sql?error_trace\",\n            usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort()));\n    }\n\n    public HttpResponse<String> get(String urlPath) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[] ... headers) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(body == null ? BodyPublishers.noBody() : BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[] ... headers) throws Exception {\n        Builder builder = HttpRequest.newBuilder(uri)\n            .header(\"Content-Type\", \"application/json\");\n        if (body != null) {\n            builder.POST(BodyPublishers.ofString(body));\n        }\n        for (String[] header : headers) {\n            builder.headers(header[0], header[1]);\n        }\n        return httpClient.send(builder.build(), BodyHandlers.ofString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpCommunicationClient {\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private final InetSocketAddress address;\n    private final URI uri;\n    private final HttpClient httpClient;\n    private final TrustManager[] trustAll;\n\n    public HttpCommunicationClient(boolean useSSL) {\n        this.usesSSL = useSSL;\n        this.trustAll = new TrustManager[]{new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n        }};\n        this.sslContext = createSslContext();\n        this.httpClient = createHttpClient();\n    }\n\n    private SSLContext createSslContext() {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAll, new SecureRandom());\n            return sslContext;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create SSL context\", e);\n        }\n    }\n\n    private HttpClient createHttpClient() {\n        if (usesSSL) {\n            return HttpClient.newHttpClient();\n        } else {\n            return HttpClient.newHttpClient();\n        }\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.address = address;\n        this.uri = new URI(usesSSL ? \"https\" : \"http\", \"\", address.getHostString(), address.getPort(), \"\", \"\");\n    }\n\n    public HttpResponse<String> get(String urlPath) {\n        try {\n            URI requestUri = new URI(uri.toString() + urlPath);\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(requestUri)\n                    .GET()\n                    .build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to send GET request\", e);\n        }\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[]... headers) {\n        try {\n            URI requestUri = new URI(uri.toString() + urlPath);\n            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                    .uri(requestUri)\n                    .POST(HttpRequest.BodyPublishers.ofString(body));\n            for (String[] header : headers) {\n                requestBuilder.header(header[0], header[1]);\n            }\n            HttpRequest request = requestBuilder.build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to send POST request\", e);\n        }\n    }\n\n    public HttpResponse<String> post(String body, String[]... headers) {\n        try {\n            URI requestUri = new URI(uri.toString());\n            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                    .uri(requestUri)\n                    .POST(HttpRequest.BodyPublishers.ofString(body));\n            for (String[] header : headers) {\n                requestBuilder.header(header[0], header[1]);\n            }\n            HttpRequest request = requestBuilder.build();\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to send POST request\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog = LogManager.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final CloseableHttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        mIcecastConfiguration = icecastConfiguration;\n        mHttpClient = HttpClients.createDefault();\n        mConnectionLoggingSuppressed = false;\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        if (mIcecastConfiguration == null || mIcecastConfiguration.getHost() == null || mIcecastConfiguration.getPort() <= 0 ||\n            mIcecastConfiguration.getMountPoint() == null || mIcecastConfiguration.getUsername() == null ||\n            mIcecastConfiguration.getPassword() == null) {\n            mLog.error(\"Invalid Icecast configuration. Cannot send metadata update.\");\n            return;\n        }\n\n        String url = \"http://\" + mIcecastConfiguration.getHost() + \":\" + mIcecastConfiguration.getPort() +\n                     mIcecastConfiguration.getMountPoint() + \"/admin/metadata\";\n\n        try {\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpPost.setHeader(\"Authorization\", \"Basic \" + java.util.Base64.getEncoder().encodeToString(\n                    (mIcecastConfiguration.getUsername() + \":\" + mIcecastConfiguration.getPassword()).getBytes()));\n            httpPost.setEntity(new StringEntity(identifierCollection.toString(), \"UTF-8\"));\n\n            mHttpClient.execute(httpPost);\n            mLog.info(\"Metadata update request sent to Icecast server.\");\n        } catch (Exception e) {\n            if (!mConnectionLoggingSuppressed) {\n                mLog.error(\"Failed to send metadata update to Icecast server: \" + e.getMessage(), e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using Java's HttpClient for synchronous and asynchronous HTTP operations including GET, PUT, HEAD, and DELETE requests.\n\nClass Description: The BlobHttpClient class provides a wrapper around Java's HttpClient to perform common HTTP operations. It handles client initialization, request construction, and response processing with both synchronous and asynchronous options.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HTTP client instance used for all requests\n\nMethods:\nsetup(): [void] - Initializes the HttpClient instance with default configuration (follows normal redirects)\ncloseClient(): [void] - Closes the HttpClient instance and releases resources\nput: [HttpResponse<String>]([URI uri, String body]) -> [HttpResponse<String>] - Sends a synchronous PUT request with the provided body to the specified URI and returns the string response\nget: [HttpResponse<String>]([URI uri]) -> [HttpResponse<String>] - Sends a synchronous GET request to the specified URI and returns the string response\ngetAsync: [CompletableFuture<HttpResponse<String>>]([URI uri]) -> [CompletableFuture<HttpResponse<String>>] - Sends an asynchronous GET request to the specified URI and returns a CompletableFuture of the response\nhead: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous HEAD request to the specified URI and returns a response without body\ndelete: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous DELETE request to the specified URI and returns a response without body",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class BlobHttpClient {\n\n    protected HttpClient httpClient;\n\n    public void setup() throws ExecutionException, InterruptedException {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .build();\n    }\n\n    public void closeClient() throws Exception {\n        httpClient.close();\n    }\n\n    protected HttpResponse<String> put(URI uri, String body) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .PUT(BodyPublishers.ofString(body))\n            .build();\n        HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());\n        return response;\n    }\n\n    protected HttpResponse<String> get(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    protected CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.sendAsync(request, BodyHandlers.ofString());\n    }\n\n    protected HttpResponse<Void> head(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).HEAD().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n\n    protected HttpResponse<Void> delete(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).DELETE().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.io.IOException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class BlobHttpClient {\n    private final HttpClient httpClient;\n\n    public BlobHttpClient() {\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public void setup() {\n        // Initialize HttpClient with default configuration (follows normal redirects)\n    }\n\n    public void closeClient() {\n        // Close the HttpClient instance and release resources\n        httpClient.close();\n    }\n\n    public HttpResponse<String> put(URI uri, String body) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .header(\"Content-Type\", \"application/json\")\n                .PUT(HttpRequest.BodyPublishers.ofString(body))\n                .build();\n\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(URI uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        return HttpClient.newHttpClient().sendAsync(\n                HttpRequest.newBuilder()\n                        .uri(uri)\n                        .GET()\n                        .build(),\n                HttpResponse.BodyHandlers.ofString()\n        );\n    }\n\n    public HttpResponse<Void> head(URI uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .HEAD()\n                .build();\n\n        return httpClient.send(request, HttpResponse.BodyHandlers.discarding());\n    }\n\n    public HttpResponse<Void> delete(URI uri) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .DELETE()\n                .build();\n\n        return httpClient.send(request, HttpResponse.BodyHandlers.discarding());\n    }\n}"
  },
  {
    "Task_id": 481,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles real-time client communication, including connection management, message processing, and error handling.\n\nClass Description: WebSocketServer is a Java EE WebSocket endpoint that manages client connections through WebSocket protocol. It handles connection events (open/close/error) and processes incoming messages, supporting different message operations like sending messages, reading status, and retrieving history.\n\nAttributes:\n- sessionPools: [ConcurrentHashMap<String, Session>] - Thread-safe map storing active client sessions with their IDs as keys\n\nMethods:\n- onOpen: [onOpen(String accessToken, Session session)] -> [void] - Handles new WebSocket connections, authenticates users, and manages session conflicts\n- onClose: [onClose(String accessToken)] -> [void] - Cleans up closed connections from session pool\n- onMessage: [onMessage(String accessToken, String msg)] -> [void] - Processes incoming JSON messages and delegates to appropriate operations\n- operation: [operation(String accessToken, MessageOperation messageOperation)] -> [void] - Executes different message operations based on operation type\n- sendMessage: [sendMessage(String sessionId, MessageVO message)] -> [void] - Sends message to specific client session by ID\n- sendMessage: [sendMessage(Session session, MessageVO message)] -> [void] - Sends message to given session object\n- onError: [onError(Session session, Throwable throwable)] -> [void] - Handles WebSocket communication errors",
    "Canonical_solution": "import cn.hutool.json.JSONUtil;\nimport cn.lili.common.security.AuthUser;\nimport cn.lili.common.security.context.UserContext;\nimport cn.lili.common.security.enums.UserEnums;\nimport cn.lili.modules.im.config.CustomSpringConfigurator;\nimport cn.lili.modules.im.entity.vo.MessageVO;\nimport cn.lili.modules.im.entity.enums.MessageResultType;\nimport cn.lili.modules.im.entity.vo.MessageOperation;\nimport com.alibaba.fastjson.JSON;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(value = \"/lili/webSocket/{accessToken}\", configurator = CustomSpringConfigurator.class)\n@Scope(\"prototype\")\npublic class WebSocketServer {\n\n    private static ConcurrentHashMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(@PathParam(\"accessToken\") String accessToken, Session session) {\n        AuthUser authUser = UserContext.getAuthUser(cache, accessToken);\n        String sessionId = UserEnums.STORE.equals(authUser.getRole()) ? authUser.getStoreId() : authUser.getId();\n        if (sessionPools.containsKey(sessionId)) {\n            Session oldSession = sessionPools.get(sessionId);\n            sendMessage(oldSession,\n                MessageVO.builder().messageResultType(MessageResultType.OFFLINE).result(\"\u7528\u6237\u5f02\u5730\u767b\u9646\").build());\n            try {\n                oldSession.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        sessionPools.put(sessionId, session);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"accessToken\") String accessToken) {\n        AuthUser authUser = UserContext.getAuthUser(accessToken);\n        sessionPools.remove(authUser);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"accessToken\") String accessToken, String msg) {\n        MessageOperation messageOperation = JSON.parseObject(msg, MessageOperation.class);\n        operation(accessToken, messageOperation);\n    }\n\n    private void operation(String accessToken, MessageOperation messageOperation) {\n        AuthUser authUser = UserContext.getAuthUser(accessToken);\n        switch (messageOperation.getOperationType()) {\n            case MESSAGE:\n                sendMessage(messageOperation.getTo(), new MessageVO(MessageResultType.MESSAGE, imMessage));\n                break;\n            case READ:\n                break;\n            case UNREAD:\n                sendMessage(authUser.getId(),\n                    new MessageVO(MessageResultType.UN_READ, imMessageService.unReadMessages(accessToken)));\n                break;\n            case HISTORY:\n                sendMessage(authUser.getId(), new MessageVO(MessageResultType.HISTORY,\n                    imMessageService.historyMessage(accessToken, messageOperation.getTo())));\n                break;\n            default:\n                break;\n        }\n    }\n\n    private void sendMessage(String sessionId, MessageVO message) {\n        Session session = sessionPools.get(sessionId);\n        sendMessage(session, message);\n    }\n\n    private void sendMessage(Session session, MessageVO message) {\n        if (session != null) {\n            try {\n                session.getBasicRemote().sendText(JSON.toJSONString(message, true));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/websocket\")\npublic class WebSocketServer {\n\n    private static final ConcurrentHashMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(String accessToken, Session session) {\n        if (sessionPools.containsKey(accessToken)) {\n            // Handle session conflict\n            System.err.println(\"Session conflict: Access token already exists.\");\n            return;\n        }\n        sessionPools.put(accessToken, session);\n        System.out.println(\"New connection established with access token: \" + accessToken);\n    }\n\n    @OnClose\n    public void onClose(String accessToken) {\n        sessionPools.remove(accessToken);\n        System.out.println(\"Connection closed for access token: \" + accessToken);\n    }\n\n    @OnMessage\n    public void onMessage(String accessToken, String msg) {\n        try {\n            MessageOperation messageOperation = MessageOperation.valueOf(msg);\n            operation(accessToken, messageOperation);\n        } catch (Exception e) {\n            System.err.println(\"Error processing message: \" + e.getMessage());\n        }\n    }\n\n    private void operation(String accessToken, MessageOperation messageOperation) {\n        switch (messageOperation) {\n            case SEND_MESSAGE:\n                // Implement logic to send message\n                break;\n            case READ_STATUS:\n                // Implement logic to read status\n                break;\n            case GET_HISTORY:\n                // Implement logic to get history\n                break;\n            default:\n                System.err.println(\"Unknown message operation: \" + messageOperation);\n        }\n    }\n\n    private void sendMessage(String sessionId, MessageVO message) {\n        Session session = sessionPools.get(sessionId);\n        if (session != null && session.isOpen()) {\n            try {\n                session.getBasicRemote().sendText(message.toString());\n            } catch (IOException e) {\n                System.err.println(\"Error sending message: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Session not found or not open for session ID: \" + sessionId);\n        }\n    }\n\n    private void sendMessage(Session session, MessageVO message) {\n        if (session != null && session.isOpen()) {\n            try {\n                session.getBasicRemote().sendText(message.toString());\n            } catch (IOException e) {\n                System.err.println(\"Error sending message: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Session is null or not open\");\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        System.err.println(\"Error in WebSocket connection: \" + throwable.getMessage());\n    }\n}"
  },
  {
    "Task_id": 482,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, disconnections, and errors using Java EE WebSocket API.\n\nClass Description: The WebsocketServerEndpoint class is a WebSocket server endpoint that manages client connections and message handling. It uses annotations to define WebSocket lifecycle events and maintains a map of message handlers for different message types.\n\nAttributes:\n- logger: Logger - Used for logging server events and errors\n- HANDLERS: Map<String, MessageHandler> - Static map storing message handlers keyed by message type\n\nMethods:\n- onOpen(Session session, EndpointConfig config) -> void - Handles new client connections, authenticates using access token from request parameters\n- onMessage(Session session, String message) -> void - Processes incoming messages from clients, delegates to appropriate message handler\n- onClose(Session session, CloseReason closeReason) -> void - Handles client disconnections, cleans up session\n- onError(Session session, Throwable throwable) -> void - Handles WebSocket communication errors\n- getMessageClass(MessageHandler handler) -> Class<? extends Message> - Helper method to determine message class type from handler's generic type information",
    "Canonical_solution": "import cn.iocoder.springboot.lab25.springwebsocket.handler.MessageHandler;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.AuthRequest;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.Message;\nimport cn.iocoder.springboot.lab25.springwebsocket.util.WebSocketUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.aop.framework.AopProxyUtils;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n@ServerEndpoint(\"/\")\npublic class WebsocketServerEndpoint {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    private static final Map<String, MessageHandler> HANDLERS = new HashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        logger.info(\"[onOpen][session({}) connected]\", session);\n        List<String> accessTokenValues = session.getRequestParameterMap().get(\"accessToken\");\n        String accessToken = !CollectionUtils.isEmpty(accessTokenValues) ? accessTokenValues.get(0) : null;\n        AuthRequest authRequest = new AuthRequest().setAccessToken(accessToken);\n        MessageHandler<AuthRequest> messageHandler = HANDLERS.get(AuthRequest.TYPE);\n        if (messageHandler == null) {\n            logger.error(\"[onOpen][Auth message type, no message handler found]\");\n            return;\n        }\n        messageHandler.execute(session, authRequest);\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        logger.info(\"[onMessage][session({}) received message({})]\", session, message);\n        try {\n            JSONObject jsonMessage = JSON.parseObject(message);\n            String messageType = jsonMessage.getString(\"type\");\n            MessageHandler messageHandler = HANDLERS.get(messageType);\n            if (messageHandler == null) {\n                logger.error(\"[onMessage][Message type({}) has no handler]\", messageType);\n                return;\n            }\n            Class<? extends Message> messageClass = getMessageClass(messageHandler);\n            Message messageObj = JSON.parseObject(jsonMessage.getString(\"body\"), messageClass);\n            messageHandler.execute(session, messageObj);\n        } catch (Throwable throwable) {\n            logger.error(\"[onMessage][session({}) error processing message]\", session, throwable);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"[onClose][session({}) disconnected. Reason: {}]\", session, closeReason);\n        WebSocketUtil.removeSession(session);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.error(\"[onError][session({}) error occurred]\", session, throwable);\n    }\n\n    private Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);\n        Type[] interfaces = targetClass.getGenericInterfaces();\n        Class<?> superclass = targetClass.getSuperclass();\n        while ((Objects.isNull(interfaces) || interfaces.length == 0) && Objects.nonNull(superclass)) {\n            interfaces = superclass.getGenericInterfaces();\n            superclass = targetClass.getSuperclass();\n        }\n        if (Objects.nonNull(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType parameterizedType = (ParameterizedType) type;\n                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {\n                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {\n                            return (Class<Message>) actualTypeArguments[0];\n                        }\n                    }\n                }\n            }\n        }\n        throw new IllegalStateException(String.format(\"Cannot determine message type for handler %s\", handler));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.Endpoint;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class WebsocketServerEndpoint extends Endpoint {\n    private static final Logger logger = Logger.getLogger(WebsocketServerEndpoint.class.getName());\n    private static final Map<String, MessageHandler> HANDLERS = Map.of();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        // Handle new client connection\n        logger.info(\"New client connected: \" + session.getId());\n        // Authenticate using access token from request parameters\n        String accessToken = session.getQueryString() != null ? session.getQueryString().split(\"=\")[1] : null;\n        if (accessToken == null || !isValidAccessToken(accessToken)) {\n            session.close();\n            logger.warning(\"Client authentication failed for session: \" + session.getId());\n        }\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        // Process incoming message\n        logger.info(\"Received message from client: \" + session.getId() + \" - \" + message);\n        // Delegate to appropriate message handler\n        MessageHandler handler = HANDLERS.get(getMessageClass(message));\n        if (handler != null) {\n            handler.handleMessage(session, message);\n        } else {\n            logger.warning(\"No handler found for message type: \" + getMessageClass(message));\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        // Handle client disconnection\n        logger.info(\"Client disconnected: \" + session.getId() + \" - \" + closeReason.getReasonPhrase());\n        // Clean up session resources if needed\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        // Handle WebSocket communication error\n        logger.severe(\"Error occurred with session: \" + session.getId() + \" - \" + throwable.getMessage());\n        throwable.printStackTrace();\n    }\n\n    private String getMessageClass(String message) {\n        // Helper method to determine message class type from message content\n        // This is a simplified example; actual implementation would parse message content\n        return \"Unknown\";\n    }\n\n    private boolean isValidAccessToken(String accessToken) {\n        // Placeholder for access token validation logic\n        return \"valid_token\".equals(accessToken);\n    }\n}"
  },
  {
    "Task_id": 483,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for secure shell terminal communication, handling client connections, message exchange, and session management.\n\nClass Description: SecureShellWS is a Java EE WebSocket endpoint that facilitates secure shell terminal interactions between clients and servers. It manages terminal sessions, processes keyboard input commands, and handles connection lifecycle events.\n\nAttributes:\n- log: [Logger] - Logger instance for error and debug logging\n- keyMap: [Map<Integer, byte[]>] - Static mapping of key codes to their corresponding byte sequences for terminal control\n- httpSession: [HttpSession] - HTTP session associated with the WebSocket connection\n- session: [Session] - WebSocket session object for the current connection\n- sessionId: [Long] - Unique identifier for the terminal session\n\nMethods:\n- onOpen: [onOpen](Session session, EndpointConfig config) -> void - Handles new WebSocket connections, initializes session parameters, and starts output thread\n- onMessage: [onMessage](String message) -> void - Processes incoming JSON messages containing terminal commands or key inputs\n- onError: [onError](Session session, Throwable t) -> void - Handles WebSocket communication errors\n- onClose: [onClose]() -> void - Cleans up resources when WebSocket connection is closed, terminating all associated terminal sessions",
    "Canonical_solution": "import com.google.gson.Gson;\nimport io.bastillion.common.util.AppConfig;\nimport io.bastillion.common.util.AuthUtil;\nimport io.bastillion.manage.control.SecureShellKtrl;\nimport io.bastillion.manage.db.UserDB;\nimport io.bastillion.manage.model.SchSession;\nimport io.bastillion.manage.model.UserSchSessions;\nimport io.bastillion.manage.task.SentOutputTask;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpSession;\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ServerEndpoint(value = \"/admin/terms.ws\", configurator = GetHttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = LoggerFactory.getLogger(SecureShellWS.class);\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n\n    static {\n        keyMap.put(27, new byte[]{(byte) 0x1b});\n        keyMap.put(13, new byte[]{(byte) 0x0d});\n        keyMap.put(37, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x44});\n        keyMap.put(38, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x41});\n        keyMap.put(39, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x43});\n        keyMap.put(40, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x42});\n        keyMap.put(8, new byte[]{(byte) 0x7f});\n        keyMap.put(9, new byte[]{(byte) 0x09});\n        keyMap.put(17, new byte[]{});\n        keyMap.put(46, \"\\033[3~\".getBytes());\n        keyMap.put(45, \"\\033[2~\".getBytes());\n        keyMap.put(33, \"\\033[5~\".getBytes());\n        keyMap.put(34, \"\\033[6~\".getBytes());\n        keyMap.put(35, \"\\033[4~\".getBytes());\n        keyMap.put(36, \"\\033[1~\".getBytes());\n    }\n\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        if (StringUtils.isNotEmpty(AppConfig.getProperty(\"websocketTimeout\"))) {\n            session.setMaxIdleTimeout(Long.parseLong(AppConfig.getProperty(\"websocketTimeout\")) * 60000);\n        } else {\n            session.setMaxIdleTimeout(0);\n        }\n\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        try {\n            this.sessionId = AuthUtil.getSessionId(httpSession);\n            this.session = session;\n            new Thread(new SentOutputTask(sessionId, session, UserDB.getUser(AuthUtil.getUserId(httpSession)))).start();\n        } catch (GeneralSecurityException | SQLException ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        if (session.isOpen() && StringUtils.isNotEmpty(message) && !\"heartbeat\".equals(message)) {\n            try {\n                Map jsonRoot = new Gson().fromJson(message, Map.class);\n                String command = (String) jsonRoot.get(\"command\");\n                Integer keyCode = null;\n                Double keyCodeDbl = (Double) jsonRoot.get(\"keyCode\");\n                if (keyCodeDbl != null) {\n                    keyCode = keyCodeDbl.intValue();\n                }\n\n                for (String idStr : (ArrayList<String>) jsonRoot.get(\"id\")) {\n                    Integer id = Integer.parseInt(idStr);\n                    UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n                    if (userSchSessions != null) {\n                        SchSession schSession = userSchSessions.getSchSessionMap().get(id);\n                        if (keyCode != null && keyMap.containsKey(keyCode)) {\n                            schSession.getCommander().write(keyMap.get(keyCode));\n                        } else {\n                            schSession.getCommander().print(command);\n                        }\n                    }\n                }\n                AuthUtil.setTimeout(httpSession);\n            } catch (IOException ex) {\n                log.error(ex.toString(), ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.error(t.toString(), t);\n    }\n\n    @OnClose\n    public void onClose() {\n        UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n        if (userSchSessions != null) {\n            Map<Integer, SchSession> schSessionMap = userSchSessions.getSchSessionMap();\n            for (Integer sessionKey : schSessionMap.keySet()) {\n                SchSession schSession = schSessionMap.get(sessionKey);\n                schSession.getChannel().disconnect();\n                schSession.getSession().disconnect();\n                schSessionMap.remove(sessionKey);\n            }\n            schSessionMap.clear();\n            SecureShellKtrl.getUserSchSessionMap().remove(sessionId);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.Endpoint;\nimport javax.websocket.DeploymentConfig;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class SecureShellWS extends Endpoint {\n    private static final Logger log = Logger.getLogger(SecureShellWS.class.getName());\n    private static final Map<Integer, byte[]> keyMap = Map.of(\n        8, new byte[]{127},\n        9, new byte[]{9},\n        13, new byte[]{13},\n        32, new byte[]{32},\n        127, new byte[]{127}\n    );\n    private final HttpSession httpSession;\n    private final Session session;\n    private final long sessionId;\n\n    public SecureShellWS(HttpSession httpSession, Session session, long sessionId) {\n        this.httpSession = httpSession;\n        this.session = session;\n        this.sessionId = sessionId;\n    }\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        try {\n            log.info(\"WebSocket connection opened for session: \" + sessionId);\n            // Initialize session parameters and start output thread\n            new Thread(() -> {\n                try {\n                    while (session.isOpen()) {\n                        // Simulate terminal output\n                        String output = \"Terminal output for session: \" + sessionId;\n                        session.getBasicRemote().sendText(output);\n                        Thread.sleep(1000);\n                    }\n                } catch (IOException | InterruptedException e) {\n                    log.severe(\"Error in output thread: \" + e.getMessage());\n                }\n            }).start();\n        } catch (Exception e) {\n            log.severe(\"Error during onOpen: \" + e.getMessage());\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        try {\n            log.info(\"Received message for session: \" + sessionId + \" - \" + message);\n            // Process incoming JSON messages containing terminal commands or key inputs\n            // Example: Parse JSON and send to terminal\n            if (message.startsWith(\"{\")) {\n                // Handle JSON command\n                log.info(\"Handling JSON command: \" + message);\n            } else {\n                // Handle raw key input\n                log.info(\"Handling raw key input: \" + message);\n                byte[] bytes = message.getBytes();\n                session.getBasicRemote().sendBinary(bytes);\n            }\n        } catch (IOException e) {\n            log.severe(\"Error processing message: \" + e.getMessage());\n        }\n    }\n\n    @OnClose\n    public void onClose() {\n        log.info(\"WebSocket connection closed for session: \" + sessionId);\n        // Clean up resources when WebSocket connection is closed\n        // Terminate all associated terminal sessions\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.severe(\"Error closing session: \" + e.getMessage());\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.severe(\"WebSocket error for session: \" + sessionId + \" - \" + t.getMessage());\n        // Handle WebSocket communication errors\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.severe(\"Error closing session due to error: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 484,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles client connections, messages, and broadcasts messages to connected clients.\n\nClass Description: WebSocketServer is a Java EE WebSocket endpoint that manages client connections, processes incoming messages, and provides functionality for sending messages to single or multiple clients. It uses annotations to define WebSocket lifecycle methods and maintains connection state.\n\nAttributes:\n- session: [Session] - The current WebSocket session for this endpoint instance\n- webSockets: [CopyOnWriteArraySet<WebSocketServer>] - Thread-safe set of all active WebSocket connections\n- sessionPool: [Map<String, Session>] - Mapping of user IDs to their corresponding WebSocket sessions\n\nMethods:\n- onOpen: [onOpen(Session session, @PathParam(\"userId\") String userId)] -> [void] - Handles new WebSocket connections and stores the session\n- onClose: [onClose()] -> [void] - Handles WebSocket connection closure and cleans up resources\n- onMessage: [onMessage(String message)] -> [void] - Processes incoming messages from clients\n- onError: [onError(Session session, Throwable error)] -> [void] - Handles WebSocket communication errors\n- sendAllMessage: [sendAllMessage(String message)] -> [void] - Broadcasts a message to all connected clients\n- sendOneMessage: [sendOneMessage(String userId, String message)] -> [void] - Sends a message to a specific client identified by user ID\n- sendMoreMessage: [sendMoreMessage(String[] userIds, String message)] -> [void] - Sends a message to multiple specified clients",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@Component\n@Slf4j\n@ServerEndpoint(\"/websocket/{userId}\")\npublic class WebSocketServer {\n\n    private Session session;\n    private static final CopyOnWriteArraySet<WebSocketServer> webSockets = new CopyOnWriteArraySet<>();\n    private static final Map<String, Session> sessionPool = new HashMap<String, Session>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(value = \"userId\") String userId) {\n        try {\n            this.session = session;\n            webSockets.add(this);\n            sessionPool.put(userId, session);\n            log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u6709\u65b0\u7684\u8fde\u63a5\uff0c\u603b\u6570\u4e3a:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n\n    @OnClose\n    public void onClose() {\n        try {\n            webSockets.remove(this);\n            log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u8fde\u63a5\u65ad\u5f00\uff0c\u603b\u6570\u4e3a:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u6536\u5230\u5ba2\u6237\u7aef\u6d88\u606f:\" + message);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void sendAllMessage(String message) {\n        log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u5e7f\u64ad\u6d88\u606f:\" + message);\n        for (WebSocketServer webSocket : webSockets) {\n            try {\n                if (webSocket.session.isOpen()) {\n                    webSocket.session.getAsyncRemote().sendText(message);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null && session.isOpen()) {\n            try {\n                log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011 \u5355\u70b9\u6d88\u606f:\" + message);\n                session.getAsyncRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMoreMessage(String[] userIds, String message) {\n        for (String userId : userIds) {\n            Session session = sessionPool.get(userId);\n            if (session != null && session.isOpen()) {\n                try {\n                    log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011 \u5355\u70b9\u6d88\u606f:\" + message);\n                    session.getAsyncRemote().sendText(message);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/websocket\")\npublic class WebSocketServer {\n    private Session session;\n    private static CopyOnWriteArraySet<WebSocketServer> webSockets = new CopyOnWriteArraySet<>();\n    private static Map<String, Session> sessionPool = new HashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"userId\") String userId) {\n        this.session = session;\n        webSockets.add(this);\n        sessionPool.put(userId, session);\n    }\n\n    @OnClose\n    public void onClose() {\n        webSockets.remove(this);\n        sessionPool.remove(session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n        // Process the message here\n        sendAllMessage(message);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public static void sendAllMessage(String message) {\n        for (WebSocketServer ws : webSockets) {\n            try {\n                ws.session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null) {\n            try {\n                session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void sendMoreMessage(String[] userIds, String message) {\n        for (String userId : userIds) {\n            Session session = sessionPool.get(userId);\n            if (session != null) {\n                try {\n                    session.getBasicRemote().sendText(message);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 485,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data communication asynchronously using ByteBuffer.\n\nClass Description: This class represents a WebSocket server endpoint that receives binary data from clients and echoes it back asynchronously. The endpoint is mapped to the \"/bytebuffer\" path and uses Java's WebSocket API for communication.\n\nAttributes: None\n\nMethods:\n- echoByteBuffer(ByteBuffer data, Session session) -> void - Handles incoming binary messages from WebSocket clients. Receives the binary data as a ByteBuffer and the client's Session object, then asynchronously sends the same data back to the client. The method uses the session's async remote endpoint to send the response without blocking.\n\nInput:\n- data: ByteBuffer - The binary data received from the client\n- session: Session - The WebSocket session object representing the client connection\n\nOutput: None (The method sends data back to the client through the session object but doesn't return anything)",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/bytebuffer\")\npublic class MyAsyncEndpointByteBuffer {\n\n    @OnMessage\n    public void echoByteBuffer(ByteBuffer data, Session session) {\n        session.getAsyncRemote().sendBinary(data);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/bytebuffer\")\npublic class ByteBufferEndpoint {\n\n    @OnMessage\n    public void echoByteBuffer(ByteBuffer data, Session session) {\n        session.getAsyncRemote().sendBytes(data);\n    }\n}"
  },
  {
    "Task_id": 487,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data streams from clients and echoes them back.\n\nClass Description: This class represents a WebSocket server endpoint that receives binary data streams from clients and sends back the same data. It uses Java EE's WebSocket API to create a server endpoint at \"/inputstream\" path.\n\nAttributes: None\n\nMethods:\n- echoStream: [InputStream, Session] -> [void] - Handles incoming binary stream messages. Reads 12 bytes from the input stream and sends them back to the client using the WebSocket session. The method prints the received stream to console for debugging purposes. Throws IOException if there's an error during stream operations.\n\nInput:\n- stream: [InputStream] - The binary input stream received from the client\n- session: [Session] - The WebSocket session object representing the client connection\n\nOutput: None (sends binary data back through the WebSocket session)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/inputstream\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        System.out.println(\"echoStream: \" + stream);\n        byte[] b = new byte[12];\n        stream.read(b);\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/inputstream\")\npublic class InputStreamEndpoint {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        byte[] buffer = new byte[12];\n        int bytesRead;\n\n        try (InputStream is = stream) {\n            while ((bytesRead = is.read(buffer)) > 0) {\n                if (bytesRead == 12) {\n                    session.getBasicRemote().sendBinary(ByteBuffer.wrap(buffer));\n                    System.out.println(\"Received and sent 12 bytes\");\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error handling stream: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 488,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, and disconnections, supporting both group broadcasting and private messaging.\n\nClass Description: WebSocket server endpoint class that manages client connections through WebSocket protocol, maintains active connections in a concurrent map, and provides message broadcasting and targeted messaging functionality.\n\nAttributes:\n- session: [Session] - The WebSocket session object representing a client connection\n- name: [String] - The identifier for the connected client\n- webSocketSet: [ConcurrentHashMap<String, WebSocket>] - Thread-safe map storing all active WebSocket connections with client names as keys\n\nMethods:\n- OnOpen([Session session, @PathParam(value = \"name\") String name]) -> [void] - Handles new client connections, stores the session and name, and notifies all clients\n- OnClose() -> [void] - Handles client disconnections, removes from active connections, and notifies all clients\n- OnMessage([String messageStr]) -> [void] - Processes incoming messages, routing to either private or group messaging based on message format\n- onError([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- GroupSending([String message]) -> [void] - Broadcasts a message to all connected clients\n- AppointSending([String name, String message]) -> [void] - Sends a message to a specific client identified by name",
    "Canonical_solution": "import javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(\"/websocket/{name}\")\npublic class WebSocket {\n    private Session session;\n    private String name;\n    private static ConcurrentHashMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void OnOpen(Session session, @PathParam(value = \"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        GroupSending(name + \" \u6765\u4e86\");\n    }\n\n    @OnClose\n    public void OnClose() {\n        webSocketSet.remove(this.name);\n        GroupSending(name + \" \u8d70\u4e86\");\n    }\n\n    @OnMessage\n    public void OnMessage(String messageStr) {\n        if (messageStr.indexOf(\"TOUSER\") == 0) {\n            String[] split = messageStr.split(\";\");\n            String[] split1 = split[0].split(\":\");\n            String[] split2 = split[1].split(\":\");\n            String name = split1[1];\n            String message = split2[1];\n            AppointSending(name, message);\n        } else {\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void GroupSending(String message) {\n        for (String name : webSocketSet.keySet()) {\n            try {\n                webSocketSet.get(name).session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void AppointSending(String name, String message) {\n        try {\n            webSocketSet.get(name).session.getBasicRemote().sendText(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/websocket\")\npublic class WebSocketEndpoint {\n\n    private static final ConcurrentHashMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"name\") String name) {\n        webSocketSet.put(name, session);\n        notifyAllClients(\"New client connected: \" + name);\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        String name = getSessionName(session);\n        if (name != null) {\n            webSocketSet.remove(name);\n            notifyAllClients(\"Client disconnected: \" + name);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String messageStr) {\n        if (messageStr.startsWith(\"{\")) {\n            // Handle private message\n            try {\n                JSONObject json = new JSONObject(messageStr);\n                String recipient = json.getString(\"to\");\n                String content = json.getString(\"content\");\n                AppointSending(recipient, content);\n            } catch (Exception e) {\n                System.err.println(\"Error parsing private message: \" + e.getMessage());\n            }\n        } else {\n            // Handle group message\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        System.err.println(\"Error in WebSocket connection: \" + error.getMessage());\n    }\n\n    private void notifyAllClients(String message) {\n        for (WebSocket ws : webSocketSet.values()) {\n            try {\n                ws.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String getSessionName(Session session) {\n        for (Map.Entry<String, WebSocket> entry : webSocketSet.entrySet()) {\n            if (entry.getValue() == session) {\n                return entry.getKey();\n            }\n        }\n        return null;\n    }\n\n    public void GroupSending(String message) {\n        for (WebSocket ws : webSocketSet.values()) {\n            try {\n                ws.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void AppointSending(String name, String message) {\n        WebSocket ws = webSocketSet.get(name);\n        if (ws != null) {\n            try {\n                ws.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 489,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for a chat room application that handles client connections, message broadcasting, and connection termination.\n\nClass Description: The ChatRoomServerEndpoint class is a WebSocket server endpoint that manages a chat room where multiple clients can connect, send messages, and receive broadcasts of all messages. It tracks connected users and handles connection lifecycle events.\n\nAttributes:\n- logger: Logger - Used for logging server activities and errors\n- ONLINE_USER_SESSIONS: Map<String, Session> - Static map storing all active user sessions with usernames as keys (inherited from WebSocketUtils)\n\nMethods:\n- openSession: (@PathParam(\"username\") String username, Session session) -> void - Handles new client connections, adds user to active sessions, and broadcasts welcome message\n- onMessage: (@PathParam(\"username\") String username, String message) -> void - Processes incoming messages from clients and broadcasts them to all connected users\n- onClose: (@PathParam(\"username\") String username, Session session) -> void - Handles client disconnections, removes user from active sessions, and broadcasts departure message\n- onError: (Session session, Throwable throwable) -> void - Handles any errors that occur during WebSocket communication and closes the problematic session",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\nimport static com.neo.utils.WebSocketUtils.ONLINE_USER_SESSIONS;\nimport static com.neo.utils.WebSocketUtils.sendMessageAll;\n\n@RestController\n@ServerEndpoint(\"/chat-room/{username}\")\npublic class ChatRoomServerEndpoint {\n    private static final Logger logger = LoggerFactory.getLogger(ChatRoomServerEndpoint.class);\n\n    @OnOpen\n    public void openSession(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.put(username, session);\n        String message = \"\u6b22\u8fce\u7528\u6237[\" + username + \"] \u6765\u5230\u804a\u5929\u5ba4\uff01\";\n        logger.info(\"\u7528\u6237\u767b\u5f55\uff1a\"+message);\n        sendMessageAll(message);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"username\") String username, String message) {\n        logger.info(\"\u53d1\u9001\u6d88\u606f\uff1a\"+message);\n        sendMessageAll(\"\u7528\u6237[\" + username + \"] : \" + message);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.remove(username);\n        sendMessageAll(\"\u7528\u6237[\" + username + \"] \u5df2\u7ecf\u79bb\u5f00\u804a\u5929\u5ba4\u4e86\uff01\");\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"onClose error\",e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"onError excepiton\",e);\n        }\n        logger.info(\"Throwable msg \"+throwable.getMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/chatroom\")\npublic class ChatRoomServerEndpoint {\n\n    private static final Logger logger = LoggerFactory.getLogger(ChatRoomServerEndpoint.class);\n    private static final Map<String, Session> ONLINE_USER_SESSIONS = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void openSession(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.put(username, session);\n        try {\n            sendBroadcastMessage(username + \" has joined the chat.\");\n        } catch (IOException e) {\n            logger.error(\"Error broadcasting welcome message to \" + username, e);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"username\") String username, String message) {\n        if (message != null && !message.isEmpty()) {\n            try {\n                sendBroadcastMessage(username + \": \" + message);\n            } catch (IOException e) {\n                logger.error(\"Error broadcasting message from \" + username, e);\n            }\n        }\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.remove(username);\n        try {\n            sendBroadcastMessage(username + \" has left the chat.\");\n        } catch (IOException e) {\n            logger.error(\"Error broadcasting departure message from \" + username, e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.error(\"Error in WebSocket connection\", throwable);\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"Error closing problematic session\", e);\n        }\n    }\n\n    private void sendBroadcastMessage(String message) throws IOException {\n        for (Session session : ONLINE_USER_SESSIONS.values()) {\n            session.getBasicRemote().sendText(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Objects;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = Objects.requireNonNull(baseUri);\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) {\n        return sendRequest(HttpMethod.GET, url);\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        String formattedUrl = String.format(url, params);\n        return sendRequest(HttpMethod.GET, formattedUrl);\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        String formattedUrl = String.format(url, params);\n        return sendRequest(HttpMethod.DELETE, formattedUrl);\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        String formattedUrl = String.format(url, params);\n        return sendRequest(HttpMethod.POST, formattedUrl);\n    }\n\n    private HttpResponse<String> sendRequest(HttpMethod method, String url) {\n        try {\n            URI requestUri = URI.create(baseUri + url);\n            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                    .uri(requestUri)\n                    .method(method.name(), HttpRequest.BodyPublishers.ofString(\"\"));\n            return httpClient.sendAsync(requestBuilder.build(), HttpResponse.BodyHandlers.ofString())\n                    .join();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error sending HTTP request\", e);\n        }\n    }\n\n    public <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unexpected exception\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 490,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data streams from clients and echoes them back.\n\nClass Description: The MyEndpointInputStream class is a WebSocket server endpoint that receives binary data streams from clients and sends back the same data. It uses Java EE's WebSocket API to manage client connections and data exchange.\n\nAttributes: None\n\nMethods:\n1. echoStream(InputStream stream, Session session) -> void - Handles incoming binary data streams from clients. Reads the first 12 bytes from the input stream and sends them back to the client as binary data.\n   - Input Parameters:\n     - stream: InputStream - The binary data stream received from the client\n     - session: Session - The WebSocket session representing the client connection\n   - Return Type: void\n   - Description: This method is triggered when a binary message is received. It reads 12 bytes from the input stream and echoes them back to the client using the session's basic remote interface. The method may throw IOException if there are issues with reading the stream or sending the response.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/inputstream\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        System.out.println(\"echoStream: \" + stream);\n        byte[] b = new byte[12];\n        stream.read(b);\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/echo\")\npublic class MyEndpointInputStream {\n\n    @OnBinary\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        byte[] buffer = new byte[12];\n        int bytesRead = stream.read(buffer);\n        if (bytesRead > 0) {\n            session.getBasicRemote().sendBinary(ByteBuffer.wrap(buffer, 0, bytesRead));\n        }\n    }\n}"
  },
  {
    "Task_id": 491,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java that handles client connections, text messages, and binary messages. The class should manage WebSocket sessions and echo received messages back to clients.\n\nClass Description: The MyEndpoint class is a WebSocket server endpoint that listens for client connections on the \"/websocket\" path. It handles text and binary messages, providing echo functionality while logging connection and message details.\n\nAttributes:\n- None (All required session information is passed through method parameters)\n\nMethods:\n- onOpen: [onOpen](Session session) -> void - Handles new WebSocket connections and logs the client's request URI.\n- echoText: [echoText](String data, boolean part) -> String - Handles incoming text messages, logs message details, and returns the same message (echo). The boolean parameter indicates if the message is complete or partial.\n- echoBinary: [echoBinary](ByteBuffer data, Session session) -> void - Handles incoming binary messages, logs message details, and sends the same binary data back to the client (echo). Throws IOException if sending fails.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(value = \"/websocket\")\npublic class MyEndpoint {\n\n    @OnOpen\n    public void onOpen(Session session) {\n        System.out.println(\"Connected from: \" + session.getRequestURI());\n    }\n\n    @OnMessage\n    public String echoText(String data, boolean part) {\n        System.out.println(\"boolean(text) \" + data);\n        System.out.println(\"text length \" + data.length());\n        if (part) {\n            System.out.println(\"whole message received\");\n        } else {\n            System.out.println(\"partial message received\");\n        }\n        return data;\n    }\n\n    @OnMessage\n    public void echoBinary(ByteBuffer data, Session session) throws IOException {\n        System.out.println(\"boolean(binary) \" + data);\n        System.out.println(\"binary length \" + data.array().length);\n        session.getBasicRemote().sendBinary(data);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "package javax.websocket;\n\nimport java.nio.ByteBuffer;\n\npublic class MyEndpoint implements WebSocketServerEndpoint {\n\n    public void onOpen(Session session) {\n        System.out.println(\"New WebSocket connection: \" + session.getRequestURI());\n    }\n\n    public String echoText(String data, boolean part) {\n        System.out.println(\"Received text message: \" + data + \" (partial: \" + part + \")\");\n        return data;\n    }\n\n    public void echoBinary(ByteBuffer data, Session session) throws IOException {\n        System.out.println(\"Received binary message\");\n        session.getBasicRemote().sendBinary(data);\n    }\n}"
  },
  {
    "Task_id": 492,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java for deploying containers, handling client connections, and managing deployment processes with error handling.\n\nClass Description: The ContainerDeployServerEndpoint class is a WebSocket server endpoint that facilitates container deployment through WebSocket connections. It handles client connections, initiates container deployment, and manages errors during the process. The class uses Java EE WebSocket API and integrates with a ContainerService for deployment operations.\n\nAttributes:\n- containerService: [ContainerService] - Service responsible for container deployment operations (injected via Spring)\n- log: [Logger] - SLF4J logger instance for logging events and errors (provided by Lombok)\n\nMethods:\n- onOpen: [onOpen](Long id, Session session) -> void - Handles new WebSocket connections. Takes container ID and session as parameters. Sends connection confirmation, initiates deployment, and closes the session. Logs errors if deployment fails.\n- onError: [onError](Session session, Throwable throwable) -> void - Handles WebSocket errors. Takes the session and throwable as parameters. Closes the session and logs the error.\n  \nNote: The class uses @ServerEndpoint annotation to define the WebSocket endpoint path with a configurator, and includes @Component for Spring integration. The endpoint path includes a path parameter for container ID (/container/deploy/{id}).",
    "Canonical_solution": "import tech.powerjob.server.config.OmsEndpointConfigure;\nimport tech.powerjob.server.core.container.ContainerService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\n@Slf4j\n@Component\n@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = OmsEndpointConfigure.class)\npublic class ContainerDeployServerEndpoint {\n\n    @Resource\n    private ContainerService containerService;\n\n    @OnOpen\n    public void onOpen(@PathParam(\"id\") Long id, Session session) {\n        RemoteEndpoint.Async remote = session.getAsyncRemote();\n        remote.sendText(\"SYSTEM: connected successfully, start to deploy container: \" + id);\n        try {\n            containerService.deploy(id, session);\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] deploy container {} failed.\", id, e);\n            remote.sendText(\"SYSTEM: deploy failed because of the exception\");\n            remote.sendText(ExceptionUtils.getStackTrace(e));\n        }\n        try {\n            session.close();\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session for {} failed.\", id, e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session failed.\", e);\n        }\n        log.warn(\"[ContainerDeployServerEndpoint] session onError!\", throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = ContainerDeployServerEndpoint.Configurator.class)\n@Component\npublic class ContainerDeployServerEndpoint {\n    @Autowired\n    private ContainerService containerService;\n    \n    @Inject\n    private Logger log;\n    \n    @ServerEndpoint(value = \"/container/deploy/{id}\", configurator = ContainerDeployServerEndpoint.Configurator.class)\n    public static class Configurator extends WebSocketEndpointConfigurator {\n        @Override\n        public void configure(WebSocketEndpoint endpoint) {\n            endpoint.setBinaryMessageSupport(true);\n        }\n    }\n    \n    @OnOpen\n    public void onOpen(Long id, Session session) {\n        try {\n            log.info(\"Client connected for container {}\", id);\n            containerService.deployContainer(id);\n            session.getBasicRemote().sendText(\"Deployment initiated for container \" + id);\n            session.close();\n        } catch (Exception e) {\n            log.error(\"Error during deployment for container {}\", id, e);\n            try {\n                session.getBasicRemote().sendText(\"Deployment failed for container \" + id);\n                session.close();\n            } catch (IOException ex) {\n                log.error(\"Error closing session for container {}\", id, ex);\n            }\n        }\n    }\n    \n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        log.error(\"Error in WebSocket connection\", throwable);\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.error(\"Error closing session due to error\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 493,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java to handle real-time communication between clients, manage client connections, and broadcast messages to all connected clients.\n\nClass Description: MyWebSocket is a Java class that serves as a WebSocket server endpoint. It maintains a list of connected clients, handles connection events, processes incoming messages, and broadcasts messages to all connected clients while also logging messages to a database.\n\nAttributes:\n- onlineCount: [static int] - Tracks the number of currently connected clients\n- webSocketSet: [static CopyOnWriteArraySet<MyWebSocket>] - Thread-safe set containing all active WebSocket sessions\n- session: [Session] - Represents the WebSocket session for a connected client\n- contentService: [ContentService] - Service for persisting messages to a database (autowired via Spring)\n\nMethods:\n- onOpen: [onOpen]([Session session]) -> [void] - Handles new client connections, adds session to the set, and increments online count\n- onClose: [onClose]() -> [void] - Handles client disconnections, removes session from the set, and decrements online count\n- onMessage: [onMessage]([String message, Session session]) -> [void] - Processes incoming messages and broadcasts them to all connected clients\n- onError: [onError]([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- sendMessage: [sendMessage]([String message]) -> [void] - Sends a message to the client and persists it to the database\n- getOnlineCount: [getOnlineCount]() -> [int] - Returns the current number of connected clients (synchronized)\n- addOnlineCount: [addOnlineCount]() -> [void] - Increments the online client count (synchronized)\n- subOnlineCount: [subOnlineCount]() -> [void] - Decrements the online client count (synchronized)",
    "Canonical_solution": "import com.crossoverJie.pojo.Content;\nimport com.crossoverJie.service.ContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.socket.server.standard.SpringConfigurator;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@ServerEndpoint(value = \"/websocket\",configurator = SpringConfigurator.class)\npublic class MyWebSocket {\n    private static int onlineCount = 0;\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<MyWebSocket>();\n    private Session session;\n\n    @Autowired\n    private ContentService contentService;\n\n    @OnOpen\n    public void onOpen(Session session){\n        this.session = session;\n        webSocketSet.add(this);\n        addOnlineCount();\n        System.out.println(\"\u6709\u65b0\u8fde\u63a5\u52a0\u5165\uff01\u5f53\u524d\u5728\u7ebf\u4eba\u6570\u4e3a\" + getOnlineCount());\n    }\n\n    @OnClose\n    public void onClose(){\n        webSocketSet.remove(this);\n        subOnlineCount();\n        System.out.println(\"\u6709\u4e00\u8fde\u63a5\u5173\u95ed\uff01\u5f53\u524d\u5728\u7ebf\u4eba\u6570\u4e3a\" + getOnlineCount());\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u6d88\u606f:\" + message);\n        for(MyWebSocket item: webSocketSet){\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n                continue;\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error){\n        System.out.println(\"\u53d1\u751f\u9519\u8bef\");\n        error.printStackTrace();\n    }\n\n    public void sendMessage(String message) throws IOException{\n        Content content = new Content() ;\n        content.setContent(message);\n        SimpleDateFormat sm = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:dd\") ;\n        content.setCreatedate(sm.format(new Date()));\n        contentService.insertSelective(content) ;\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        MyWebSocket.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        MyWebSocket.onlineCount--;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/websocket\")\npublic class MyWebSocket {\n    private static int onlineCount = 0;\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<>();\n    private Session session;\n    private ContentService contentService;\n\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        webSocketSet.add(this);\n        addOnlineCount();\n    }\n\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);\n        subOnlineCount();\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        sendMessage(message);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    private void sendMessage(String message) {\n        for (MyWebSocket item : webSocketSet) {\n            try {\n                item.session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        contentService.saveMessage(message);\n    }\n\n    public static int getOnlineCount() {\n        synchronized (onlineCount) {\n            return onlineCount;\n        }\n    }\n\n    public static void addOnlineCount() {\n        synchronized (onlineCount) {\n            onlineCount++;\n        }\n    }\n\n    public static void subOnlineCount() {\n        synchronized (onlineCount) {\n            onlineCount--;\n        }\n    }\n}"
  },
  {
    "Task_id": 494,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for a chat application that broadcasts received messages to all connected clients.\n\nClass Description: The ChatEndpoint class represents a WebSocket server endpoint that handles real-time chat communication. It listens for incoming messages and broadcasts them to all currently connected clients.\n\nAttributes: None\n\nMethods:\n- message: [Name](String message, Session client) -> void - Handles incoming WebSocket messages. Receives a message string and the client session that sent it, then broadcasts the message to all connected sessions.\n  - Input Parameters:\n    - message: String - The chat message received from a client\n    - client: Session - The WebSocket session of the client that sent the message\n  - Output: None (messages are sent directly to client sessions)\n  - Throws: IOException, EncodeException - If there are issues sending messages to clients",
    "Canonical_solution": "import java.io.IOException;\nimport javax.websocket.EncodeException;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatEndpoint {\n    @OnMessage\n    public void message(String message, Session client) throws IOException, EncodeException {\n        System.out.println(\"message: \" + message);\n        for (Session peer : client.getOpenSessions()) {\n            peer.getBasicRemote().sendText(message);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/chat\")\npublic class ChatEndpoint {\n\n    @OnMessage\n    public void message(String message, Session client) throws IOException, EncodeException {\n        for (Session session : Collections.list(Session.getCurrentSessions())) {\n            if (!session.equals(client)) {\n                session.getBasicRemote().sendText(message);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 495,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that echoes received text messages back to the client asynchronously.\n\nClass Description: This class represents a WebSocket server endpoint that handles text-based communication with clients. It listens for incoming text messages and echoes them back to the sender using asynchronous communication.\n\nAttributes: None\n\nMethods:\n- echoText: [String text, Session session] -> void - Handles incoming text messages from clients. Takes the received text and the client session as input, then sends the same text back to the client asynchronously using the session's async remote endpoint.",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/text\")\npublic class MyAsyncEndpointText {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/echo\")\npublic class EchoWebSocket {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}"
  },
  {
    "Task_id": 498,
    "Instruction": "Task Description: Create a gRPC client class for service discovery that handles connection management, stub creation, and remote method invocation with retry logic.\n\nClass Description: DiscoveryClient is a gRPC client implementation that manages connections to a discovery service, provides thread-safe operations, and includes automatic retry mechanisms for failed requests.\n\nAttributes:\n- requireResetStub: AtomicBoolean - Flag indicating whether the stub needs to be reset\n- channel: ManagedChannel - The gRPC communication channel\n- registerStub: DiscoveryServiceBlockingStub - Blocking stub for registration operations  \n- blockingStub: DiscoveryServiceBlockingStub - Blocking stub for general operations\n- readWriteLock: ReentrantReadWriteLock - Lock for thread-safe operations\n- pdAddresses: List<String> - Server addresses (implied from usage)\n\nMethods:\n- DiscoveryClient(String centerAddress) -> None - Constructor that initializes the client with target server address\n- getNodeInfos(Query query) -> NodeInfos - Retrieves node information from discovery service with retry logic\n- tryWithTimes(Function<V,R> function, V v) -> R - Helper method implementing retry logic for operations\n- resetStub() -> None - Resets the channel and stubs when connection issues occur  \n- resetChannel(String address) -> None - Recreates the channel and stubs with a new address\n- close() -> None - Shuts down the channel and cleans up resources\n\nThe class demonstrates proper gRPC client patterns including:\n1. Channel lifecycle management\n2. Thread-safe stub operations\n3. Connection retry mechanisms\n4. Resource cleanup\n5. Error handling for network operations",
    "Canonical_solution": "import org.apache.hugegraph.pd.grpc.discovery.DiscoveryServiceGrpc;\nimport org.apache.hugegraph.pd.grpc.discovery.NodeInfos;\nimport org.apache.hugegraph.pd.grpc.discovery.Query;\nimport org.apache.hugegraph.pd.grpc.discovery.RegisterInfo;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private ManagedChannel channel = null;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub registerStub;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub blockingStub;\n    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public DiscoveryClient(String centerAddress) {\n        resetChannel(centerAddress);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes((q) -> {\n            this.readWriteLock.readLock().lock();\n            NodeInfos nodes;\n            try {\n                nodes = this.blockingStub.getNodes(q);\n            } finally {\n                this.readWriteLock.readLock().unlock();\n            }\n            return nodes;\n        }, query);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        R r;\n        Exception ex = null;\n        for (int i = 0; i < 3; i++) {\n            try {\n                r = function.apply(v);\n                return r;\n            } catch (Exception e) {\n                requireResetStub.set(true);\n                resetStub();\n                ex = e;\n            }\n        }\n        if (ex != null) {\n            throw new RuntimeException(\"Discovery method failed\", ex);\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        if (requireResetStub.get()) {\n            try {\n                resetChannel(pdAddresses.get(0));\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to reset stub\", e);\n            }\n        }\n    }\n\n    private void resetChannel(String address) {\n        readWriteLock.writeLock().lock();\n        try {\n            if (requireResetStub.get()) {\n                if (channel != null) {\n                    channel.shutdownNow();\n                    channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n                }\n                channel = ManagedChannelBuilder.forTarget(address)\n                        .usePlaintext().build();\n                this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                requireResetStub.set(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to reset channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (channel != null) {\n                channel.shutdownNow();\n                channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to close channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.stub.DiscoveryServiceBlockingStub;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private final ManagedChannel channel;\n    private final DiscoveryServiceBlockingStub registerStub;\n    private final DiscoveryServiceBlockingStub blockingStub;\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    private final List<String> pdAddresses;\n\n    public DiscoveryClient(String centerAddress) {\n        this.pdAddresses = List.of(centerAddress);\n        this.channel = ManagedChannelBuilder.forTarget(centerAddress).build();\n        this.registerStub = DiscoveryServiceBlockingStub.newInstance(channel);\n        this.blockingStub = DiscoveryServiceBlockingStub.newInstance(channel);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes(() -> {\n            readWriteLock.readLock().lock();\n            try {\n                return blockingStub.getNodeInfos(query);\n            } finally {\n                readWriteLock.readLock().unlock();\n            }\n        }, null);\n    }\n\n    private <R> R tryWithTimes(Function<R, R> function, V v) {\n        int retryCount = 0;\n        while (retryCount < 3) {\n            try {\n                return function.apply(v);\n            } catch (Exception e) {\n                if (requireResetStub.get()) {\n                    resetStub();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        readWriteLock.writeLock().lock();\n        try {\n            requireResetStub.set(false);\n            resetChannel(pdAddresses.get(0));\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    private void resetChannel(String address) {\n        channel.shutdownNow();\n        channel.awaitTermination(1, java.util.concurrent.TimeUnit.SECONDS);\n        channel = ManagedChannelBuilder.forTarget(address).build();\n        registerStub = DiscoveryServiceBlockingStub.newInstance(channel);\n        blockingStub = DiscoveryServiceBlockingStub.newInstance(channel);\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            channel.shutdownNow();\n            channel.awaitTermination(1, java.util.concurrent.TimeUnit.SECONDS);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.*;\n\npublic class HttpUtil {\n    private int timeout = 5000;\n    private String defaultEncoding = \"UTF-8\";\n    private Map<String, String> currentProxy = new HashMap<>();\n    private HostnameVerifier allHostsValid = (hostname, session) -> true;\n\n    public String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        this.timeout = timeOut;\n        if (encoding == null || encoding.isEmpty()) {\n            encoding = defaultEncoding;\n        }\n\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        connection.setRequestMethod(requestMethod);\n\n        if (contentType != null) {\n            connection.setRequestProperty(\"Content-Type\", contentType);\n        }\n\n        if (\"POST\".equalsIgnoreCase(requestMethod)) {\n            connection.setDoOutput(true);\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = postString.getBytes(encoding);\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 400) {\n            try (InputStream errorStream = connection.getErrorStream()) {\n                String errorMessage = readString(errorStream, encoding);\n                throw new RuntimeException(\"HTTP error code: \" + responseCode + \", Error message: \" + errorMessage);\n            }\n        }\n\n        try (InputStream inputStream = connection.getInputStream()) {\n            return readString(inputStream, encoding);\n        }\n    }\n\n    private String readString(InputStream inputStream, String encoding) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, encoding));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line);\n        }\n        return sb.toString();\n    }\n\n    public static class X509TrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n        public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n    }\n}"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Predicate;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.UncheckedExecutionException;\n\npublic abstract class AbstractClient {\n    protected final ConcurrentMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel;\n    protected final ConcurrentMap<String, AbstractBlockingStub> stubs = new ConcurrentHashMap<>();\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy();\n    }\n\n    public AbstractBlockingStub getBlockingStub() {\n        return stubs.computeIfAbsent(config.getLeader(), k -> createBlockingStub());\n    }\n\n    public AbstractStub getStub() {\n        return stubProxy.getStub();\n    }\n\n    public abstract AbstractStub createStub();\n\n    public abstract AbstractBlockingStub createBlockingStub();\n\n    public String resetStub() {\n        String leader = config.getLeader();\n        if (channel != null && !channel.isShutdown()) {\n            closeChannel(channel);\n        }\n        channel = createChannel(leader);\n        stubProxy.setStub(createStub());\n        stubs.clear();\n        stubs.put(leader, createBlockingStub());\n        return leader;\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, 3);\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        for (int i = 0; i < retry; i++) {\n            try {\n                return stubProxy.getStub().unaryCall(method, req);\n            } catch (StatusRuntimeException e) {\n                if (e.getStatusCode().getCode() == StatusRuntimeException.PERMISSION_DENIED) {\n                    throw e;\n                }\n                if (i == retry - 1) {\n                    throw e;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n        throw new RuntimeException(\"Failed to call after retries\");\n    }\n\n    public <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        KVPair<Boolean, RespT> result = new KVPair<>(false, null);\n        for (String host : config.getHosts()) {\n            ManagedChannel channel = chs.get(host);\n            if (channel == null || channel.isShutdown()) {\n                continue;\n            }\n            AbstractBlockingStub stub = stubs.get(host);\n            if (stub == null) {\n                continue;\n            }\n            try {\n                RespT response = stub.unaryCall(method, req);\n                if (predicate.test(response)) {\n                    result = new KVPair<>(true, response);\n                    break;\n                }\n            } catch (Exception e) {\n                // Handle exception if needed\n            }\n        }\n        return result;\n    }\n\n    public <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        for (int i = 0; i < retry; i++) {\n            try {\n                stubProxy.getStub().serverStreamingCall(method, request, responseObserver);\n                return;\n            } catch (StatusRuntimeException e) {\n                if (e.getStatusCode().getCode() == StatusRuntimeException.PERMISSION_DENIED) {\n                    throw e;\n                }\n                if (i == retry - 1) {\n                    throw e;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n        throw new RuntimeException(\"Failed to call after retries\");\n    }\n\n    public void close() {\n        if (channel != null && !channel.isShutdown()) {\n            closeChannel(channel);\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        if (channel != null) {\n            try {\n                channel.shutdownNow();\n            } catch (Exception e) {\n                // Handle exception if needed\n            }\n        }\n    }\n\n    private ManagedChannel createChannel(String host) {\n        return ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n    }\n}"
  },
  {
    "Task_id": 503,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for establishing and managing connections to a gRPC server, with methods to start the connection, retrieve the blocking stub, and shutdown the connection.\n\nClass Description: The GrpcClient class provides functionality to connect to a gRPC server using a ManagedChannel, create a blocking stub for synchronous communication, and properly shutdown the connection when done.\n\nAttributes:\n- channel: [ManagedChannel] - The channel used to communicate with the gRPC server\n- blockingStub: [WalletGrpc.WalletBlockingStub] - The blocking stub used to make synchronous RPC calls\n\nMethods:\n- startConnection(String host, int port) -> void - Establishes a connection to the gRPC server at the specified host and port, creating both the ManagedChannel and blocking stub\n- getBlockingStub() -> WalletGrpc.WalletBlockingStub - Returns the blocking stub for making RPC calls\n- shutdown() -> void - Shuts down the channel connection, waiting for up to 5 seconds for termination",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.WalletGrpc;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrpcClient {\n\n    private ManagedChannel channel;\n    private WalletGrpc.WalletBlockingStub blockingStub;\n\n    public void startConnection(String host, int port) {\n        channel = ManagedChannelBuilder.forAddress(host, port)\n            .usePlaintext()\n            .build();\n        blockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpc.WalletBlockingStub getBlockingStub() {\n        return blockingStub;\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (channel != null) {\n            channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "public class GrpcClient {\n    private ManagedChannel channel;\n    private WalletGrpc.WalletBlockingStub blockingStub;\n\n    public void startConnection(String host, int port) {\n        channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        blockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpc.WalletBlockingStub getBlockingStub() {\n        return blockingStub;\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdownNow();\n            try {\n                if (!channel.awaitTermination(5, TimeUnit.SECONDS)) {\n                    channel.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                channel.shutdownNow();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 504,
    "Instruction": "Task Description: Implement a function to test the gRPC Server Reflection service by establishing a connection to a gRPC server, sending a reflection request, and processing the response.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 9090 using plaintext communication. It creates an asynchronous stub for the Server Reflection service, sends a request to list all available services, and processes the response. The function ensures proper cleanup by shutting down the channel after completion.\n\nInput: None (The target server address is hardcoded as \"localhost:9090\")\n\nOutput: None (The function processes the reflection response internally via the checkResult method, which is not shown in the reference code)",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc.ServerReflectionStub;\nimport io.grpc.reflection.v1alpha.ServerReflectionRequest;\nimport io.grpc.reflection.v1alpha.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\n\nvoid testReflectionService() {\n    final ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:9090\").usePlaintext().build();\n    try {\n        final ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n\n        final AwaitableStreamObserver<ServerReflectionResponse> resultObserver = new AwaitableStreamObserver<>();\n        final StreamObserver<ServerReflectionRequest> requestObserver = stub.serverReflectionInfo(resultObserver);\n        requestObserver.onNext(ServerReflectionRequest.newBuilder()\n                .setListServices(\"\")\n                .build());\n        requestObserver.onCompleted();\n        checkResult(resultObserver);\n    } finally {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 23,
    "wrong_result": "async def test_grpc_server_reflection():\n    import grpc\n    from google.protobuf import empty_pb2\n    from google.rpclib import server_reflection_pb2_grpc\n\n    channel = grpc.insecure_channel(\"localhost:9090\")\n    stub = server_reflection_pb2_grpc.ServerReflectionStub(channel)\n\n    response = await stub.ListServices(empty_pb2.Empty())\n    await checkResult(response)  # Assuming checkResult is defined elsewhere\n\n    channel.close()"
  },
  {
    "Task_id": 506,
    "Instruction": "Task Description: Implement a gRPC server in Java that handles streaming requests and responses, following the structure and functionality of the provided reference code.\n\nClass Description: The HelloWorldServer class represents a gRPC server that listens on a specified port and provides a streaming greeting service. It manages server lifecycle operations (start, stop, await termination) and implements the gRPC service interface for handling client requests.\n\nAttributes:\n- server: [Server] - The gRPC server instance that handles incoming requests\n- logger: [Logger] - Logger instance for server activity logging\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50051 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting.\n\nNested Class:\n- GreeterImpl: [StreamingGreeterGrpc.StreamingGreeterImplBase] - Implements the gRPC service interface with streaming capabilities\n  Methods:\n  - sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Handles client requests by sending multiple greeting responses in a stream. Takes a HelloRequest containing the client's name and a StreamObserver for sending responses. Sends three greeting messages with increasing excitement, then completes the stream.",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.streaming.HelloReply;\nimport io.grpc.examples.streaming.HelloRequest;\nimport io.grpc.examples.streaming.StreamingGreeterGrpc;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n  private Server server;\n\n  public void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  public void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  public void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n    @Override\n    public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      try {\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!\").build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!!\").build());\n      } catch (InterruptedException e) {\n        responseObserver.onError(e);\n      } finally {\n        responseObserver.onCompleted();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "```java\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n    private final Server server;\n    private final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n    private static final int PORT = 50051;\n\n    public HelloWorldServer() {\n        this.server = ServerBuilder.forPort(PORT).build();\n    }\n\n    public void start() throws IOException {\n        logger.info(\"Starting server on port \" + PORT);\n        server.start();\n        // Register shutdown hook to stop the server gracefully\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            logger.info(\"Shutting down server\");\n            try {\n                server.shutdownNow();\n            } catch (InterruptedException e) {\n                logger.severe(\"Shutdown interrupted: \" + e.getMessage());\n            }\n        }));\n    }\n\n    public void stop() {\n        if (server != null) {\n            logger.info(\"Shutting down server\");\n            server.shutdownNow();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            logger.info(\"Blocking until server shutdown\");\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        HelloWorldServer server = new HelloWorldServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    public static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n        @Override\n        public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n            logger.info(\"Received request: \" + req.getName());\n            for (int i = 0; i < 3; i++) {\n                HelloReply reply = HelloReply.newBuilder()\n                        .setMessage(\"Hello \" + req.getName() + \" \" + i)\n                        .build();\n                responseObserver.onNext(reply);\n            }\n            responseObserver.onCompleted();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 507,
    "Instruction": "Task Description: Create a gRPC server in Java that can handle multiple services, manage interceptors, and provide service discovery capabilities.\n\nClass Description: The GrpcServer class is responsible for initializing and managing a gRPC server instance. It handles server configuration, service registration, interceptor management, and provides methods for service discovery. The server can be started and stopped gracefully, and it maintains mappings of services and methods for lookup purposes.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- serviceNameMap: [Map<String, Class<? extends BindableService>>] - Mapping of service names to their implementation classes\n- fullMethodNameMap: [Map<String, Method>] - Mapping of full method names to their corresponding Method objects\n\nMethods:\n- GrpcServer: [Constructor](GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Initializes the server with given properties, interceptors and services\n- GrpcServer: [Constructor](ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Alternative constructor accepting a pre-configured ServerBuilder\n- isRunning: [isRunning]() -> [boolean] - Checks if the server is currently running\n- port: [port]() -> [int] - Returns the port number the server is listening on\n- findClass: [findClass](ServiceDescriptor descriptor) -> [Class<? extends BindableService>] - Finds the implementation class for a given service descriptor\n- findMethod: [findMethod](MethodDescriptor<?, ?> descriptor) -> [Method] - Finds the Method object for a given method descriptor\n- resolve: [resolve](MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) -> [Method] - Resolves the Method object for a given method descriptor within a service class\n- onApplicationStart: [onApplicationStart]() -> [void] - Starts the server and begins awaiting termination\n- onApplicationStop: [onApplicationStop]() -> [void] - Shuts down the server gracefully",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerMethodDefinition;\nimport io.grpc.ServerServiceDefinition;\nimport io.grpc.ServiceDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport org.ballcat.common.core.compose.ContextComponent;\nimport org.ballcat.common.thread.ThreadPool;\nimport org.ballcat.common.util.ClassUtils;\nimport org.ballcat.grpc.server.properties.GrpcServerProperties;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\n\npublic class GrpcServer implements ContextComponent {\n\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap;\n    private final Map<String, Method> fullMethodNameMap;\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        this(ServerBuilder.forPort(properties.getPort()), properties, interceptors, services);\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        builder\n            .maxInboundMessageSize((int) properties.getMessageSize().toBytes())\n            .keepAliveTime(properties.getKeepAliveTime(), TimeUnit.MILLISECONDS)\n            .keepAliveTimeout(properties.getKeepAliveTimeout(), TimeUnit.MILLISECONDS);\n\n        interceptors.sort(AnnotationAwareOrderComparator.INSTANCE);\n        ListIterator<ServerInterceptor> iterator = interceptors.listIterator(interceptors.size());\n        while (iterator.hasPrevious()) {\n            builder.intercept(iterator.previous());\n        }\n\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n\n        for (BindableService service : services) {\n            builder.addService(service);\n            Class<? extends BindableService> cls = service.getClass();\n            ServerServiceDefinition serverServiceDefinition = service.bindService();\n            ServiceDescriptor serviceDescriptor = serverServiceDefinition.getServiceDescriptor();\n\n            this.serviceNameMap.put(serviceDescriptor.getName(), cls);\n\n            for (ServerMethodDefinition<?, ?> serverMethodDefinition : serverServiceDefinition.getMethods()) {\n                MethodDescriptor<?, ?> methodDescriptor = serverMethodDefinition.getMethodDescriptor();\n                String fullMethodName = methodDescriptor.getFullMethodName();\n                this.fullMethodNameMap.put(fullMethodName, resolve(methodDescriptor, cls));\n            }\n        }\n\n        this.server = builder.build();\n    }\n\n    public boolean isRunning() {\n        return !this.server.isShutdown() && !this.server.isTerminated();\n    }\n\n    public int port() {\n        return this.server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return this.serviceNameMap.get(descriptor.getName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return this.fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    protected Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        String bareMethodName = descriptor.getBareMethodName();\n        for (Method method : ClassUtils.methods(cls)) {\n            if (Objects.equals(method.getName(), bareMethodName)) {\n                return method;\n            }\n        }\n        return null;\n    }\n\n    public void onApplicationStart() {\n        this.server.start();\n        ThreadPool.instance().execute(\"GrpcServer\", this.server::awaitTermination);\n    }\n\n    public void onApplicationStop() {\n        this.server.shutdownNow();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.protobuf.services.ProtoFile;\nimport io.grpc.protobuf.services.ProtoService;\nimport io.grpc.stub.ServerCallHandler;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.netty.NettyServerBuilder;\nimport io.grpc.netty.NettyServer; \nimport java.util.Map;\nimport java.util.HashMap;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class GrpcServer {\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap;\n    private final Map<String, Method> fullMethodNameMap;\n    private final GrpcServerProperties properties;\n    private final List<ServerInterceptor> interceptors;\n    private final List<BindableService> services;\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        this.properties = properties;\n        this.interceptors = interceptors;\n        this.services = services;\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n        initializeServer();\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        this.properties = properties;\n        this.interceptors = interceptors;\n        this.services = services;\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n        this.server = builder.build();\n        initializeServer();\n    }\n\n    private void initializeServer() {\n        for (BindableService service : services) {\n            String serviceName = service.getServiceDescriptor().getFullName();\n            serviceNameMap.put(serviceName, service.getClass());\n            for (MethodDescriptor<?, ?> method : service.getServiceDescriptor().getMethods()) {\n                String fullMethodName = method.getFullMethodName();\n                fullMethodNameMap.put(fullMethodName, method);\n            }\n        }\n        startServer();\n    }\n\n    private void startServer() {\n        server.start();\n    }\n\n    public boolean isRunning() {\n        return server.isStarted();\n    }\n\n    public int port() {\n        return server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return serviceNameMap.get(descriptor.getFullName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    public Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        return fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    public void onApplicationStart() {\n        server.start();\n    }\n\n    public void onApplicationStop() {\n        server.shutdownNow();\n    }\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function to test if a given URL is reachable by making an HTTP GET request and verifying the response code.\n\nFunction Description: The function attempts to connect to a specified URL using an HTTP GET request. It checks if the response code is HTTP_OK (200) to determine if the URL is reachable. The connection is properly closed after the check.\n\nInput: \n- strUrl: String - The URL to be tested for reachability\n\nOutput: \n- None (The function throws an exception if the URL is unreachable or if the response code is not HTTP_OK)",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic void testUrlReachable(String strUtl) throws Exception {\n    URL url = new URL(strUtl);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"GET\");\n    conn.connect();\n    int rc = conn.getResponseCode();\n    assertEquals(HttpURLConnection.HTTP_OK, rc);\n    conn.disconnect();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "public void testUrlReachability(String strUrl) throws Exception {\n    URL url = new URL(strUrl);\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setRequestMethod(\"GET\");\n    int responseCode = connection.getResponseCode();\n    if (responseCode != 200) {\n        throw new Exception(\"URL is unreachable or response code is not HTTP_OK: \" + responseCode);\n    }\n    connection.disconnect();\n}"
  },
  {
    "Task_id": 511,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server launcher for Spring Boot applications, capable of registering multiple gRPC services and managing server lifecycle.\n\nClass Description: The GrpcLauncher class is responsible for starting and managing a gRPC server in a Spring Boot application. It automatically discovers gRPC service beans, configures server parameters, and handles graceful shutdown. The class uses Lombok for logging and Spring's dependency injection.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- grpcServerPort: [Integer] - The port number for the gRPC server, injected from application properties\n- DEFAULT_MAX_MESSAGE_SIZE: [int] - Constant defining the maximum message size (10MB)\n\nMethods:\n- grpcStart: [grpcStart](Map<String, Object> grpcServiceBeanMap) -> void - Initializes and starts the gRPC server, registering all provided gRPC service beans. Handles server lifecycle and shutdown hooks.\n- grpcStop: [grpcStop]() -> void - Shuts down the gRPC server gracefully when called, typically during application termination.",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.Map;\n\n@Slf4j\n@Component(\"grpcLauncher\")\npublic class GrpcLauncher {\n\n    public static final int DEFAULT_MAX_MESSAGE_SIZE = 10 * 1024 * 1024;\n\n    private Server server;\n\n    @Value(\"${server.grpc.port}\")\n    private Integer grpcServerPort;\n\n    public void grpcStart(Map<String, Object> grpcServiceBeanMap) {\n        try {\n            ServerBuilder serverBuilder = ServerBuilder.forPort(grpcServerPort);\n            for (Object bean : grpcServiceBeanMap.values()){\n                serverBuilder.addService((BindableService) bean);\n                log.info(\"{} is register in Spring Boot\", bean.getClass().getSimpleName());\n            }\n            server = serverBuilder\n                .maxInboundMessageSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .maxInboundMetadataSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .build().start();\n            log.info(\"grpc server is started at {}\", grpcServerPort);\n            server.awaitTermination();\n            Runtime.getRuntime().addShutdownHook(new Thread(this::grpcStop));\n        } catch (IOException | InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n\n    private void grpcStop(){\n        if (server != null){\n            server.shutdownNow();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.context.annotation.Configuration;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n@Configuration\n@Component\n@Slf4j\npublic class GrpcLauncher implements CommandLineRunner {\n\n    private final Server server;\n    private final int grpcServerPort;\n    private static final int DEFAULT_MAX_MESSAGE_SIZE = 10 * 1024 * 1024; // 10MB\n\n    public GrpcLauncher(@Value(\"${grpc.server.port}\") int grpcServerPort) {\n        this.grpcServerPort = grpcServerPort;\n        this.server = ServerBuilder.forPort(grpcServerPort)\n                .maxInboundMessageSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .build();\n    }\n\n    @Override\n    public void run(String... args) throws Exception {\n        registerServices();\n        server.start();\n        log.info(\"gRPC server started on port: {}\", grpcServerPort);\n    }\n\n    private void registerServices() {\n        Map<String, Object> grpcServiceBeanMap = (Map<String, Object>) applicationContext.getBean(\"grpcServiceBeans\");\n        for (Map.Entry<String, Object> entry : grpcServiceBeanMap.entrySet()) {\n            String serviceName = entry.getKey();\n            Object serviceInstance = entry.getValue();\n            server.addService((io.grpc.ServerService) serviceInstance);\n            log.info(\"Registered gRPC service: {}\", serviceName);\n        }\n    }\n\n    public void grpcStop() {\n        if (server != null) {\n            server.shutdownNow();\n            try {\n                if (server.awaitTermination(30, TimeUnit.SECONDS)) {\n                    log.info(\"gRPC server shut down successfully\");\n                } else {\n                    log.warn(\"gRPC server shutdown timeout\");\n                }\n            } catch (InterruptedException e) {\n                log.error(\"gRPC server shutdown interrupted\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 514,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens on a specified port, provides a service, and handles graceful shutdown.\n\nClass Description: The ShelfServer class is responsible for creating and managing a gRPC server instance. It initializes the server on a specified port, adds the required service implementation, and provides methods for starting, stopping, and waiting for server termination.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50052 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance. Throws IOException and InterruptedException for server start and shutdown operations",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n  private static final Logger logger = Logger.getLogger(ShelfServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50052;\n    server = ServerBuilder.forPort(port).addService(new ShelfService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  ShelfServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final ShelfServer server = new ShelfServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n    private final Server server;\n    private final Logger logger;\n\n    public ShelfServer() {\n        this.server = ServerBuilder.forPort(50052).build();\n        this.logger = Logger.getLogger(ShelfServer.class.getName());\n    }\n\n    public void start() throws IOException {\n        logger.info(\"Starting gRPC server on port 50052\");\n        server.start();\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            logger.info(\"Shutting down gRPC server gracefully\");\n            server.shutdownNow();\n        }));\n    }\n\n    public void stop() {\n        if (server != null) {\n            logger.info(\"Shutting down gRPC server\");\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            logger.info(\"Blocking until gRPC server shutdown\");\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        ShelfServer server = new ShelfServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n}"
  },
  {
    "Task_id": 516,
    "Instruction": "Task Description: Implement a TCP server class that handles multiple client connections simultaneously, providing predefined chat responses to incoming messages.\n\nClass Description: TCPServer is a Java class that creates a TCP server listening on a specified port. It maintains a set of predefined messages and can handle multiple client connections concurrently, responding with random messages from its predefined set. The server can be started and stopped as needed.\n\nAttributes:\n- mIsServiceDestoryed: boolean - Flag indicating whether the server should stop running\n- mDefinedMessages: String[] - Array of predefined messages to send to clients\n\nMethods:\n- startServer() -> void - Starts the TCP server in a new thread\n- stopServer() -> void - Stops the TCP server by setting the termination flag\n- TcpServer (inner class) run() -> void - Main server loop that accepts client connections (implements Runnable)\n- responseClient(Socket client) -> void - Handles communication with an individual client\n  - Input: client: Socket - The client socket connection\n  - Output: (none) - Sends responses to client through the socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPServer {\n\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = new String[] {\n            \"\u4f60\u597d\u554a\uff0c\u54c8\u54c8\",\n            \"\u8bf7\u95ee\u4f60\u53eb\u4ec0\u4e48\u540d\u5b57\u5440\uff1f\",\n            \"\u4eca\u5929\u5317\u4eac\u5929\u6c14\u4e0d\u9519\u554a\uff0cshy\",\n            \"\u4f60\u77e5\u9053\u5417\uff1f\u6211\u53ef\u662f\u53ef\u4ee5\u548c\u591a\u4e2a\u4eba\u540c\u65f6\u804a\u5929\u7684\u54e6\",\n            \"\u7ed9\u4f60\u8bb2\u4e2a\u7b11\u8bdd\u5427\uff1a\u636e\u8bf4\u7231\u7b11\u7684\u4eba\u8fd0\u6c14\u4e0d\u4f1a\u592a\u5dee\uff0c\u4e0d\u77e5\u9053\u771f\u5047\u3002\"\n    };\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            ServerSocket serverSocket = null;\n            try {\n                serverSocket = new ServerSocket(8688);\n            } catch (IOException e) {\n                System.err.println(\"establish tcp server failed, port:8688\");\n                e.printStackTrace();\n                return;\n            }\n\n            while (!mIsServiceDestoryed) {\n                try {\n                    final Socket client = serverSocket.accept();\n                    System.out.println(\"accept\");\n                    new Thread() {\n                        @Override\n                        public void run() {\n                            try {\n                                responseClient(client);\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        };\n                    }.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                client.getInputStream()));\n        PrintWriter out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(client.getOutputStream())), true);\n        out.println(\"\u6b22\u8fce\u6765\u5230\u804a\u5929\u5ba4\uff01\");\n        while (!mIsServiceDestoryed) {\n            String str = in.readLine();\n            System.out.println(\"msg from client:\" + str);\n            if (str == null) {\n                break;\n            }\n            int i = new Random().nextInt(mDefinedMessages.length);\n            String msg = mDefinedMessages[i];\n            out.println(msg);\n            System.out.println(\"send :\" + msg);\n        }\n        System.out.println(\"client quit.\");\n        out.close();\n        in.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TCPServer {\n    private boolean mIsServiceDestroyed = false;\n    private String[] mDefinedMessages = {\"Hello!\", \"How are you?\", \"Nice to meet you.\", \"Welcome to the chat.\"};\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestroyed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(8080)) {\n                while (!mIsServiceDestroyed) {\n                    Socket clientSocket = serverSocket.accept();\n                    new Thread(new ClientHandler(clientSocket)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ClientHandler implements Runnable {\n        private final Socket clientSocket;\n\n        public ClientHandler(Socket clientSocket) {\n            this.clientSocket = clientSocket;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (mIsServiceDestroyed) {\n                        break;\n                    }\n                    String response = mDefinedMessages[(int) (Math.random() * mDefinedMessages.length)];\n                    out.println(response);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that sends an OCSP (Online Certificate Status Protocol) request to a specified URL and processes the response.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends an OCSP request, reads the response, and constructs an OCSPResp object from the received data. It handles the connection lifecycle and ensures proper resource cleanup.\n\nInput:\n- url: [String] - The URL to which the OCSP request will be sent\n- ocspReq: [OCSPReq] - The OCSP request object containing the encoded request data\n\nOutput:\n- [OCSPResp] - The OCSP response object constructed from the server's response data\n- Throws [IOException] - If any I/O error occurs during the request/response process",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.apache.commons.io.IOUtils;\n\nprivate OCSPResp requestOCSPResponse(String url, OCSPReq ocspReq) throws IOException {\n    byte[] ocspReqData = ocspReq.getEncoded();\n\n    HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n    try {\n        con.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        con.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setUseCaches(false);\n        try (OutputStream out = con.getOutputStream()) {\n            IOUtils.write(ocspReqData, out);\n            out.flush();\n        }\n        byte[] responseBytes = IOUtils.toByteArray(con.getInputStream());\n        OCSPResp ocspResp = new OCSPResp(responseBytes);\n        return ocspResp;\n    } finally {\n        if (con != null) {\n            con.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class OCSPRequestHandler {\n    public OCSPResp sendOCSPRequest(String url, OCSPReq ocspReq) throws IOException {\n        byte[] encodedRequest = ocspReq.getEncoded();\n        String encodedRequestBase64 = Base64.getEncoder().encodeToString(encodedRequest);\n\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        connection.setDoOutput(true);\n\n        try (java.io.OutputStream os = connection.getOutputStream()) {\n            os.write(encodedRequestBase64.getBytes());\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"OCSP request failed with response code: \" + responseCode);\n        }\n\n        try (java.io.InputStream inputStream = connection.getInputStream()) {\n            byte[] responseBytes = readStream(inputStream);\n            return new OCSPResp(responseBytes);\n        }\n    }\n\n    private byte[] readStream(java.io.InputStream inputStream) throws IOException {\n        java.io.ByteArrayOutputStream byteArrayOutputStream = new java.io.ByteArrayOutputStream();\n        int bytesRead;\n        byte[] buffer = new byte[1024];\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            byteArrayOutputStream.write(buffer, 0, bytesRead);\n        }\n        return byteArrayOutputStream.toByteArray();\n    }\n}\n```"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class SocketCommunication {\n    private String TAG;\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public SocketCommunication(String tag, String secret, ArrayList<Integer> portList) {\n        this.TAG = tag;\n        this.secret = secret;\n        this.portList = portList;\n    }\n\n    public void checkByPortListening(String serverIP, VirtualCheckCallback callback) {\n        this.callback = callback;\n        new Thread(() -> startServer(serverIP, callback)).start();\n        new Thread(() -> startClient(serverIP)).start();\n    }\n\n    public void startServer(String serverIP, VirtualCheckCallback callback) {\n        try (ServerSocket serverSocket = new ServerSocket(0)) {\n            int port = serverSocket.getLocalPort();\n            System.out.println(\"Server is listening on port: \" + port);\n            new Thread(() -> {\n                while (true) {\n                    try {\n                        Socket socket = serverSocket.accept();\n                        new ReadThread(TAG, socket, callback).start();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void startClient(String serverIP) {\n        for (int port : portList) {\n            new ClientThread(serverIP, port).start();\n        }\n    }\n\n    public static class ServerThread implements Runnable {\n        private String TAG;\n        private VirtualCheckCallback callback;\n        private ServerSocket serverSocket;\n\n        public ServerThread(String tag, VirtualCheckCallback callback) {\n            this.TAG = tag;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(0)) {\n                int port = serverSocket.getLocalPort();\n                System.out.println(\"Server is listening on port: \" + port);\n                while (true) {\n                    try {\n                        Socket socket = serverSocket.accept();\n                        new ReadThread(TAG, socket, callback).start();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static class ReadThread implements Runnable {\n        private String TAG;\n        private Socket socket;\n        private VirtualCheckCallback callback;\n\n        public ReadThread(String tag, Socket socket, VirtualCheckCallback callback) {\n            this.TAG = tag;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (inputLine.equals(secret)) {\n                        callback.onSuspectFound(TAG, inputLine);\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static class ClientThread implements Runnable {\n        private String serverIP;\n        private int port;\n\n        public ClientThread(String serverIP, int port) {\n            this.serverIP = serverIP;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try (Socket socket = new Socket(serverIP, port)) {\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                out.println(secret);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 521,
    "Instruction": "Task Description: Create a Java class that implements Kubernetes port forwarding functionality, allowing local ports to be forwarded to target ports in a Kubernetes pod. The class should handle multiple port forwards simultaneously and provide error handling capabilities.\n\nClass Description: KubectlPortForward is a Kubernetes client utility that establishes TCP port forwarding between local ports and target ports in a specified pod. It extends Kubectl's ResourceAndContainerBuilder and implements Executable<Boolean> interface. The class manages multiple port forwarding connections in separate threads and provides shutdown capability.\n\nAttributes:\n- localPorts: List<Integer> - Stores local port numbers to be forwarded\n- targetPorts: List<Integer> - Stores target port numbers in the pod\n- running: boolean - Flag indicating whether port forwarding is active\n- onUnhandledError: Consumer<Throwable> - Callback for handling uncaught exceptions\n\nMethods:\n- ports(int localPort, int targetPort) -> KubectlPortForward - Adds a port forwarding pair (local and target ports)\n- onUnhandledError(Consumer<Throwable> onUnhandledError) -> KubectlPortForward - Sets the error handler callback\n- execute() -> Boolean - Starts the port forwarding operation (implements Kubectl.Executable)\n- shutdown() -> void - Stops all port forwarding operations\n- executeInternal() -> void - Internal implementation of port forwarding (throws ApiException, KubectlException, IOException, InterruptedException)\n- portForward(PortForward pf, ServerSocket server, int targetPort) -> Thread - Creates and starts a thread for a single port forwarding connection\n- copyAsync(InputStream, OutputStream, Consumer<Throwable>) -> Thread - Helper method for asynchronous stream copying (not shown in reference code)",
    "Canonical_solution": "import io.kubernetes.client.PortForward;\nimport io.kubernetes.client.extended.kubectl.Kubectl;\nimport io.kubernetes.client.extended.kubectl.exception.KubectlException;\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward\n    extends Kubectl.ResourceAndContainerBuilder<V1Pod, KubectlPortForward>\n    implements Kubectl.Executable<Boolean> {\n  private List<Integer> localPorts;\n  private List<Integer> targetPorts;\n  private boolean running;\n  private Consumer<Throwable> onUnhandledError = Throwable::printStackTrace;\n\n  public KubectlPortForward() {\n    super(V1Pod.class);\n    localPorts = new ArrayList<>();\n    targetPorts = new ArrayList<>();\n  }\n\n  public KubectlPortForward ports(int localPort, int targetPort) {\n    localPorts.add(localPort);\n    targetPorts.add(targetPort);\n    return this;\n  }\n\n  public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n    this.onUnhandledError = onUnhandledError;\n    return this;\n  }\n\n  @Override\n  public Boolean execute() throws KubectlException {\n    running = true;\n    try {\n      executeInternal();\n      return true;\n    } catch (ApiException | IOException | InterruptedException ex) {\n      throw new KubectlException(ex);\n    }\n  }\n\n  public void shutdown() {\n    running = false;\n  }\n\n  private void executeInternal()\n      throws ApiException, KubectlException, IOException, InterruptedException {\n    PortForward pf = new PortForward(apiClient);\n    List<Thread> threads = new ArrayList<>();\n    for (int i = 0; i < localPorts.size(); i++) {\n      int targetPort = targetPorts.get(i);\n      threads.add(portForward(pf, new ServerSocket(localPorts.get(i)), targetPort));\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n  }\n\n  private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n    Thread t = new Thread(\n        () -> {\n          while (running) {\n            try (Socket sock = server.accept()) {\n              PortForward.PortForwardResult result = pf.forward(namespace, name, Arrays.asList(targetPort));\n              if (result == null) {\n                throw new KubectlException(\"PortForward failed!\");\n              }\n              InputStream in = result.getInputStream(targetPort);\n              OutputStream out = result.getOutboundStream(targetPort);\n              Thread t1 = copyAsync(sock.getInputStream(), out, onUnhandledError);\n              Thread t2 = copyAsync(in, sock.getOutputStream(), onUnhandledError);\n\n              t1.join();\n              in.close();\n              t2.join();\n            } catch (Exception ex) {\n              Optional.ofNullable(onUnhandledError)\n                  .orElse(Throwable::printStackTrace)\n                  .accept(ex);\n            }\n          }\n        });\n    t.start();\n    return t;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport io.fabric8.kubernetes.client.*;\nimport io.fabric8.kubernetes.client.utils.*;\n\npublic class KubectlPortForward extends ResourceAndContainerBuilder implements Executable<Boolean> {\n    private List<Integer> localPorts = new ArrayList<>();\n    private List<Integer> targetPorts = new ArrayList<>();\n    private boolean running = false;\n    private Consumer<Throwable> onUnhandledError;\n\n    public KubectlPortForward ports(int localPort, int targetPort) {\n        localPorts.add(localPort);\n        targetPorts.add(targetPort);\n        return this;\n    }\n\n    public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n        this.onUnhandledError = onUnhandledError;\n        return this;\n    }\n\n    @Override\n    public Boolean execute() {\n        try {\n            executeInternal();\n            return true;\n        } catch (Exception e) {\n            onUnhandledError.accept(e);\n            return false;\n        }\n    }\n\n    public void shutdown() {\n        running = false;\n        for (int i = 0; i < localPorts.size(); i++) {\n            try {\n                Socket socket = new Socket(\"localhost\", localPorts.get(i));\n                socket.close();\n            } catch (IOException e) {\n                // Ignore if the port is not in use\n            }\n        }\n    }\n\n    private void executeInternal() throws ApiException, KubectlException, IOException, InterruptedException {\n        if (localPorts.isEmpty() || targetPorts.isEmpty()) {\n            throw new IllegalArgumentException(\"Local and target ports must be specified\");\n        }\n\n        if (localPorts.size() != targetPorts.size()) {\n            throw new IllegalArgumentException(\"Local and target ports lists must have the same size\");\n        }\n\n        running = true;\n\n        for (int i = 0; i < localPorts.size(); i++) {\n            int localPort = localPorts.get(i);\n            int targetPort = targetPorts.get(i);\n\n            Thread thread = portForward(new PortForward(localPort, targetPort), null, targetPort);\n            thread.start();\n        }\n    }\n\n    private Thread portForward(PortForward pf, ServerSocket server, int targetPort) throws IOException, InterruptedException {\n        Thread thread = new Thread(() -> {\n            try {\n                if (server == null) {\n                    server = new ServerSocket(localPorts.get(0));\n                }\n\n                while (running) {\n                    Socket clientSocket = server.accept();\n                    Socket targetSocket = pf.connect(targetPort);\n\n                    if (targetSocket != null) {\n                        new Thread(() -> {\n                            try {\n                                copyAsync(clientSocket.getInputStream(), targetSocket.getOutputStream(), null);\n                            } catch (Exception e) {\n                                onUnhandledError.accept(e);\n                            }\n                        }).start();\n\n                        new Thread(() -> {\n                            try {\n                                copyAsync(targetSocket.getInputStream(), clientSocket.getOutputStream(), null);\n                            } catch (Exception e) {\n                                onUnhandledError.accept(e);\n                            }\n                        }).start();\n                    }\n                }\n            } catch (Exception e) {\n                onUnhandledError.accept(e);\n            }\n        });\n\n        thread.setName(\"KubectlPortForward-\" + localPorts.get(0));\n        return thread;\n    }\n\n    private Thread copyAsync(InputStream input, OutputStream output, Consumer<Throwable> errorHandler) throws IOException {\n        Thread thread = new Thread(() -> {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    output.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                if (errorHandler != null) {\n                    errorHandler.accept(e);\n                }\n            }\n        });\n\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n}"
  },
  {
    "Task_id": 523,
    "Instruction": "Task Description: Implement a TCP transport class that can function as either a server or client, handling network communication with configurable buffer sizes and TCP_NODELAY option.\n\nClass Description: TcpTransport is a class that provides TCP-based communication capabilities, acting as either a server (accepting connections) or client (initiating connections). It manages socket creation, stream handling, and includes a dedicated receiver thread for asynchronous data reception.\n\nAttributes:\n- srv_sock: [ServerSocket] - Server socket instance for accepting connections (server mode)\n- sock: [Socket] - Socket instance for communication (both modes)\n- output: [OutputStream] - Output stream for sending data\n- input: [InputStream] - Input stream for receiving data\n- receiver_thread: [Receiver] - Thread for handling incoming data\n- receiver: [RtReceiver] - Callback handler for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- out_buf_size: [int] - Output buffer size (default: 8192)\n- in_buf_size: [int] - Input buffer size (default: 8192)\n- server: [boolean] - Flag indicating server mode\n- tcp_nodelay: [boolean] - TCP_NODELAY socket option flag\n- log: [Log] - Logger instance\n\nMethods:\n- start: [void](String... options) -> [void] - Initializes the transport in either server or client mode, creates sockets and streams, starts receiver thread\n- stop: [void]() -> [void] - Closes all resources (sockets and streams)\n- send: [void](byte[] buf, int offset, int length) -> [void] - Sends data through the output stream\n- Receiver (inner class): [void](InputStream in) -> [void] - Thread class that continuously reads incoming data and notifies receiver callback",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpTransport {\n    protected ServerSocket srv_sock;\n    protected Socket sock;\n    protected OutputStream output;\n    protected InputStream input;\n    protected Receiver receiver_thread;\n    protected RtReceiver receiver;\n    protected InetAddress host;\n    protected int port=7800;\n    protected int out_buf_size=8192, in_buf_size=8192;\n    protected boolean server, tcp_nodelay;\n    protected final Log log=LogFactory.getLog(TcpTransport.class);\n\n    public void start(String ... options) throws Exception {\n        if(server) {\n            srv_sock=new ServerSocket(port, 50, host);\n            Socket s=srv_sock.accept();\n            s.setTcpNoDelay(tcp_nodelay);\n            input=in_buf_size > 0? new BufferedInputStream(s.getInputStream(), in_buf_size) : s.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(s.getOutputStream(), out_buf_size) : s.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n        else {\n            sock=new Socket();\n            sock.setTcpNoDelay(tcp_nodelay);\n            sock.connect(new InetSocketAddress(host, port));\n            input=in_buf_size > 0? new BufferedInputStream(sock.getInputStream(), in_buf_size) : sock.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(sock.getOutputStream(), out_buf_size) : sock.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(sock, srv_sock, input, output);\n    }\n\n    public void send(byte[] buf, int offset, int length) throws Exception {\n        output.write(buf, offset, length);\n        output.flush();\n    }\n\n    protected class Receiver extends Thread {\n        protected final InputStream in;\n\n        public Receiver(InputStream in) {\n            this.in=in;\n        }\n\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            for(;;) {\n                try {\n                    int num=in.read(buf, 0, buf.length);\n                    if(num == -1)\n                        return;\n                    if(num != buf.length)\n                        throw new IllegalStateException(\"expected \" + buf.length + \" bytes, but got only \" + num);\n                    if(receiver != null)\n                        receiver.receive(null, buf, 0, buf.length);\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "class TcpTransport {\n    ServerSocket srv_sock;\n    Socket sock;\n    OutputStream output;\n    InputStream input;\n    Receiver receiver_thread;\n    RtReceiver receiver;\n    InetAddress host;\n    int port = 7800;\n    int out_buf_size = 8192;\n    int in_buf_size = 8192;\n    boolean server;\n    boolean tcp_nodelay;\n    Log log;\n\n    void start(String... options) {\n        if (server) {\n            try {\n                srv_sock = new ServerSocket(port);\n                sock = srv_sock.accept();\n            } catch (Exception e) {\n                log.error(\"Error starting server: \" + e.getMessage());\n            }\n        } else {\n            try {\n                sock = new Socket(host, port);\n            } catch (Exception e) {\n                log.error(\"Error connecting to server: \" + e.getMessage());\n            }\n        }\n\n        try {\n            output = sock.getOutputStream();\n            input = sock.getInputStream();\n            receiver_thread = new Receiver(input);\n            receiver_thread.start();\n        } catch (Exception e) {\n            log.error(\"Error initializing streams: \" + e.getMessage());\n        }\n    }\n\n    void stop() {\n        try {\n            if (sock != null) sock.close();\n            if (srv_sock != null) srv_sock.close();\n        } catch (Exception e) {\n            log.error(\"Error closing resources: \" + e.getMessage());\n        }\n    }\n\n    void send(byte[] buf, int offset, int length) {\n        try {\n            output.write(buf, offset, length);\n            output.flush();\n        } catch (Exception e) {\n            log.error(\"Error sending data: \" + e.getMessage());\n        }\n    }\n\n    class Receiver extends Thread {\n        InputStream in;\n\n        Receiver(InputStream in) {\n            this.in = in;\n        }\n\n        public void run() {\n            try {\n                byte[] buffer = new byte[in_buf_size];\n                while (true) {\n                    int bytesRead = in.read(buffer);\n                    if (bytesRead > 0) {\n                        receiver.receive(buffer, bytesRead);\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"Error receiving data: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 526,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to accept client connections and read data from them.\n\nClass Description: The GraphiteBridge class provides functionality to start a TCP server, accept client connections, read data from connected clients, and properly close all connections and resources.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- clientSocket: Socket - The socket representing an accepted client connection\n- inputReader: BufferedReader - The reader used to read data from the client connection\n\nMethods:\n- startServer(int port) -> void - Starts the server socket listening on the specified port\n- acceptConnection() -> void - Accepts an incoming client connection and initializes the input reader\n- readData() -> String - Reads a line of data from the connected client\n- closeConnection() -> void - Closes all open resources including the input reader, client socket, and server socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class GraphiteBridge {\n\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n    private BufferedReader inputReader;\n\n    public void startServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    public void acceptConnection() throws IOException {\n        clientSocket = serverSocket.accept();\n        inputReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n    }\n\n    public String readData() throws IOException {\n        return inputReader.readLine();\n    }\n\n    public void closeConnection() throws IOException {\n        if (inputReader != null) {\n            inputReader.close();\n        }\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class GraphiteBridge {\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n    private BufferedReader inputReader;\n\n    public void startServer(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void acceptConnection() {\n        try {\n            clientSocket = serverSocket.accept();\n            inputReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String readData() {\n        String data = \"\";\n        try {\n            data = inputReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return data;\n    }\n\n    public void closeConnection() {\n        try {\n            if (inputReader != null) inputReader.close();\n            if (clientSocket != null) clientSocket.close();\n            if (serverSocket != null) serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that retrieves content from a given HTTP/HTTPS URL and handles redirects with proper cookie management.\n\nFunction Description: The function establishes an HTTP connection to the specified URL, follows redirects (up to 10 times), maintains cookies during redirects, and returns the input stream of the final response. It handles standard HTTP response codes and supports common request headers.\n\nInput: \n- urlStr: String - The URL string to fetch content from (must start with \"http://\" or \"https://\")\n\nOutput: \n- InputStream - The input stream containing the response data from the final URL after following redirects, or null if:\n  - The URL scheme is not HTTP/HTTPS\n  - An exception occurs during the process\n  - Maximum redirect count (10) is exceeded",
    "Canonical_solution": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate InputStream getKmlContents(String urlStr) {\n    InputStream inputStream;\n    try {\n        if (urlStr.startsWith(\"http://\") || urlStr.startsWith(\"https://\")) {\n            URL url = new URL(urlStr);\n            boolean redirect = true;\n            HttpURLConnection http = null;\n            String cookies = null;\n            int redirectCnt = 0;\n            while(redirect && redirectCnt < 10) {\n                redirect = false;\n                http = (HttpURLConnection)url.openConnection();\n                http.setRequestMethod(\"GET\");\n                if (cookies != null) {\n                    http.setRequestProperty(\"Cookie\", cookies);\n                }\n                http.addRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                http.addRequestProperty(\"User-Agent\", \"Mozilla\");\n                http.setInstanceFollowRedirects(true);\n                HttpURLConnection.setFollowRedirects(true);\n\n                int status = http.getResponseCode();\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP\n                        || status == HttpURLConnection.HTTP_MOVED_PERM\n                        || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        redirect = true;\n                }\n                if (redirect) {\n                    url = new URL(http.getHeaderField(\"Location\"));\n                    cookies = http.getHeaderField(\"Set-Cookie\");\n                    http.disconnect();\n                    redirectCnt++;\n                }\n            }\n            inputStream = http.getInputStream();\n        } else {\n            // Handle other URL types (file://, etc)\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return inputStream;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedirectHandler {\n    public static InputStream fetchContent(String urlStr) {\n        if (!urlStr.startsWith(\"http://\") && !urlStr.startsWith(\"https://\")) {\n            return null;\n        }\n\n        AtomicInteger redirectCount = new AtomicInteger(0);\n        String currentUrl = urlStr;\n\n        while (redirectCount.get() < 10) {\n            try {\n                URL url = new URL(currentUrl);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n                connection.setInstanceFollowRedirects(false);\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP) {\n                    String location = connection.getHeaderField(\"Location\");\n                    if (location != null && !location.isEmpty()) {\n                        currentUrl = location;\n                        redirectCount.incrementAndGet();\n                        continue;\n                    }\n                }\n\n                if (responseCode >= 200 && responseCode < 300) {\n                    return connection.getInputStream();\n                } else {\n                    return null;\n                }\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        return null;\n    }\n}"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport javax.websocket.*;\nimport javax.websocket.server.*;\n\n@ServerEndpoint(\"/websocket\")\npublic class WebSocketServer {\n\n    private static final int PORT = 8080;\n\n    public static void main(String[] args) {\n        try {\n            Server server = new Server(PORT);\n            server.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class Server implements Runnable {\n        private final int port;\n        private ServerSocket serverSocket;\n\n        public Server(int port) {\n            this.port = port;\n        }\n\n        public void start() throws IOException {\n            serverSocket = new ServerSocket(port);\n            new Thread(this).start();\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    Socket clientSocket = serverSocket.accept();\n                    new Thread(new ClientHandler(clientSocket)).start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void stop() {\n            try {\n                if (serverSocket != null) {\n                    serverSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class ClientHandler implements Runnable {\n        private final Socket clientSocket;\n\n        public ClientHandler(Socket clientSocket) {\n            this.clientSocket = clientSocket;\n        }\n\n        @Override\n        public void run() {\n            try (\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)\n            ) {\n                String request = \"\";\n                while ((request = in.readLine()) != null && !request.contains(\"Upgrade: websocket\")) {\n                    System.out.println(\"Request: \" + request);\n                }\n\n                if (request != null && request.contains(\"Upgrade: websocket\")) {\n                    String key = in.readLine().split(\"Sec-WebSocket-Key: \")[1].trim();\n                    String acceptKey = generateFinalKey(key);\n                    String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                                     \"Upgrade: websocket\\r\\n\" +\n                                     \"Connection: upgrade\\r\\n\" +\n                                     \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\\r\\n\";\n                    out.println(response);\n\n                    // Handle WebSocket communication\n                    WebSocketContainer container = ContainerProvider.getWebSocketContainer();\n                    container.addEndpoint(WebSocketServer.class, clientSocket);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        private String generateFinalKey(String in) {\n            String key = in;\n            byte[] data = key.getBytes();\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] hash = md.digest(data);\n            StringBuilder sb = new StringBuilder();\n            for (byte b : hash) {\n                sb.append(String.format(\"%02x\", b));\n            }\n            return sb.toString();\n        }\n    }\n}"
  },
  {
    "Task_id": 534,
    "Instruction": "Task Description: Implement a WebSocket handshake server in Java that handles various test cases for WebSocket connection upgrades. The server should listen on a specified port, accept client connections, and respond with different HTTP responses based on the requested test case.\n\nClass Description: WebSocketHandshakeServer is a TCP server that simulates WebSocket handshake responses for testing purposes. It creates a ServerSocket to listen for incoming connections and handles each client connection in a separate thread, responding with different HTTP responses based on the requested test case path.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- port: int - The port number on which the server listens for connections\n- additionalHandshake: String - Constant string containing additional handshake headers required for WebSocket upgrade\n\nMethods:\n- WebSocketHandshakeServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server, creates a ServerSocket, and begins accepting client connections in a new thread\n- stop() -> void - Stops the server by closing the ServerSocket if it's open\n- handleClientConnection(Socket client) -> void - Handles an individual client connection, reads the request, and sends the appropriate response based on the test case\n- asciiBytes(String input) -> byte[] - Helper method that converts a string to ASCII bytes for network transmission",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class WebSocketHandshakeServer {\n\n    private static final String additionalHandshake = \"Upgrade: websocket\\r\\nConnection: Upgrade\\r\\n\\r\\n\";\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n        \n        new Thread(() -> {\n            while (!serverSocket.isClosed()) {\n                try {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                } catch (IOException e) {\n                    if (!serverSocket.isClosed()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        try (Scanner in = new Scanner(client.getInputStream());\n             OutputStream os = client.getOutputStream()) {\n            \n            String input = in.nextLine();\n            String testCase = input.split(\" \")[1];\n            \n            switch (testCase) {\n                case \"/0\":\n                    os.write(asciiBytes(\"HTTP/1.1 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/1\":\n                    os.write(asciiBytes(\"HTTP/1.0 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/2\":\n                    os.write(asciiBytes(\"HTTP 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/3\":\n                    os.write(asciiBytes(\"HTTP/1.1 200 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/4\":\n                    os.write(asciiBytes(\"HTTP 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/5\":\n                    os.write(asciiBytes(\"HTTP/1.1 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/6\":\n                    os.write(asciiBytes(\"HTTP/2.0 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/7\":\n                    os.write(asciiBytes(\"HTTP/1.1 500 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/8\":\n                    os.write(asciiBytes(\"GET 302 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/9\":\n                    os.write(asciiBytes(\"GET HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/10\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/11\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" + additionalHandshake));\n                    break;\n            }\n            os.flush();\n        } finally {\n            client.close();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(java.nio.charset.StandardCharsets.US_ASCII);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class WebSocketHandshakeServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private String additionalHandshake = \"Sec-WebSocket-Origin: http://example.com\\r\\nSec-WebSocket-Location: /test\\r\\n\";\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                System.out.println(\"WebSocket handshake server started on port \" + port);\n                while (true) {\n                    Socket client = serverSocket.accept();\n                    new Thread(new ClientHandler(client)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public void stop() {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n\n            String request = \"\";\n            String line;\n            while ((line = in.readLine()) != null && !line.isEmpty()) {\n                request += line + \"\\r\\n\";\n            }\n\n            String[] requestParts = request.split(\"\\r\\n\");\n            String firstLine = requestParts[0];\n            String[] firstLineParts = firstLine.split(\"\\\\s+\");\n            String method = firstLineParts[0];\n            String path = firstLineParts[1];\n\n            String response = \"\";\n            if (path.equals(\"/test\")) {\n                response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                        \"Upgrade: websocket\\r\\n\" +\n                        \"Connection: Upgrade\\r\\n\" +\n                        \"Sec-WebSocket-Accept: dGhlIHNlYXJjaHJlZCByZXZpYWwlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHRleHQlIHR"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.Handler;\nimport android.widget.Toast;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class EvdevCaptureProvider {\n    private final EvdevListener listener;\n    private final String libraryPath;\n    private boolean shutdown;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started;\n    private Thread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        this.libraryPath = \"/data/local/tmp/evdev\";\n        this.shutdown = false;\n        this.started = false;\n        this.handlerThread = new Thread(this::run);\n    }\n\n    public void destroy() {\n        if (su != null) {\n            try {\n                su.destroy();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        started = false;\n    }\n\n    private void reportDeviceNotRooted() {\n        Toast.makeText(activity, \"Device not rooted\", Toast.LENGTH_SHORT).show();\n    }\n\n    private void run() {\n        started = true;\n        try {\n            servSock = new ServerSocket(12345);\n            su = Runtime.getRuntime().exec(\"su\");\n            evdevSock = new Socket(evdevSock.getInetAddress(), 12346);\n            evdevIn = evdevSock.getInputStream();\n            evdevOut = evdevSock.getOutputStream();\n            new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>()).submit(() -> {\n                while (!shutdown) {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead = evdevIn.read(buffer);\n                        if (bytesRead > 0) {\n                            String event = new String(buffer, 0, bytesRead);\n                            listener.onEvent(event);\n                        }\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        } catch (IOException e) {\n            e.printStackTrace();\n            reportDeviceNotRooted();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TCPEchoCommunication {\n    private static final int PORT = 5678;\n\n    public static void main(String[] args) {\n        Thread serverThread = new Thread(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n                System.out.println(\"Server is listening on port \" + PORT);\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"Client connected\");\n\n                java.io.InputStream input = clientSocket.getInputStream();\n                java.io.OutputStream output = clientSocket.getOutputStream();\n\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    String received = new String(buffer, 0, bytesRead);\n                    System.out.println(\"Received: \" + received);\n                    output.write(received.getBytes());\n                }\n\n                clientSocket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail();\n            }\n        });\n\n        Thread clientThread = new Thread(() -> {\n            try (Socket socket = new Socket(\"localhost\", PORT)) {\n                System.out.println(\"Connected to server\");\n\n                java.io.OutputStream output = socket.getOutputStream();\n                java.io.InputStream input = socket.getInputStream();\n\n                String message = \"Hello, Server!\";\n                output.write(message.getBytes());\n                output.flush();\n\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    String response = new String(buffer, 0, bytesRead);\n                    System.out.println(\"Response: \" + response);\n                }\n\n                socket.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n                fail();\n            }\n        });\n\n        serverThread.start();\n        clientThread.start();\n    }\n\n    private static void fail() {\n        System.err.println(\"Test failed\");\n        System.exit(1);\n    }\n}"
  },
  {
    "Task_id": 539,
    "Instruction": "Task Description: Create a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections.\n\nClass Description: The ConnectionManipulationProxyServer class implements a TCP proxy server that listens on a local port, accepts client connections, and forwards traffic to a specified remote server. It provides thread-safe control over the proxy operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port number the proxy listens on\n- host: [String] - The hostname or IP address of the remote server\n- remotePort: [int] - The port number of the remote server\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization object for thread-safe control\n- enableProxy: [boolean] - Flag indicating whether proxy is enabled\n- running: [boolean] - Flag indicating whether proxy thread should continue running\n- client: [Socket] - Socket for client connection\n- server: [Socket] - Socket for server connection\n- serverSocket: [ServerSocket] - Server socket for accepting client connections\n\nMethods:\n- ConnectionManipulationProxyServer(String host, int remotePort, int localPort) -> [void] - Constructor that initializes the proxy server with target host and ports\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread implementation that handles connection forwarding\n- getLocalPort() -> [int] - Returns the local port number the proxy is listening on",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    Socket client = null, server = null;\n    ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            boolean canIrun = true;\n            \n            while (running) {\n                synchronized (enableLock) {\n                    canIrun = enableProxy;\n                }\n                \n                while (canIrun) {\n                    synchronized (enableLock) {\n                        canIrun = enableProxy;\n                        if (!enableProxy) {\n                            break;\n                        }\n                    }\n                    \n                    if (serverSocket == null || serverSocket.isClosed()) {\n                        serverSocket = new ServerSocket(localPort);\n                        localPort = serverSocket.getLocalPort();\n                    }\n                    \n                    log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    \n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ConnectionManipulationProxyServer {\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private boolean running = false;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                running = true;\n                proxyThread = new Thread(this::run);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                running = false;\n                try {\n                    if (proxyThread != null && proxyThread.isAlive()) {\n                        proxyThread.join();\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                enableProxy = false;\n            }\n        }\n    }\n\n    public void killOpenSockets() {\n        if (client != null) {\n            try {\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (server != null) {\n            try {\n                server.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running && enableProxy) {\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = client.getInputStream().read(buffer)) > 0) {\n                            server.getOutputStream().write(buffer, 0, bytesRead);\n                        }\n                        server.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = server.getInputStream().read(buffer)) > 0) {\n                            client.getOutputStream().write(buffer, 0, bytesRead);\n                        }\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() {\n        if (sourceInfo == null || sourceInfo.getContentLength() == -1) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getContentLength();\n    }\n\n    public void open(long offset) {\n        try {\n            connection = openConnection(offset, 10000);\n            if (connection != null) {\n                sourceInfo = sourceInfoStorage.get(sourceInfoStorage.getUrl());\n                if (sourceInfo == null) {\n                    fetchContentInfo();\n                }\n                if (offset > 0) {\n                    connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\" + (offset + sourceInfo.getContentLength() - 1));\n                }\n                inputStream = connection.getInputStream();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public int read(byte[] buffer) {\n        if (inputStream == null) {\n            return -1;\n        }\n        try {\n            return inputStream.read(buffer);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public String getMime() {\n        if (sourceInfo == null || sourceInfo.getMimeType() == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getMimeType();\n    }\n\n    public String getUrl() {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.getUrl();\n    }\n\n    private void fetchContentInfo() {\n        try {\n            URL url = new URL(sourceInfoStorage.getUrl());\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            injectCustomHeaders(connection, sourceInfoStorage.getUrl());\n            connection.setConnectTimeout(10000);\n            connection.setReadTimeout(10000);\n            connection.connect();\n            sourceInfo = new SourceInfo();\n            sourceInfo.setUrl(sourceInfoStorage.getUrl());\n            sourceInfo.setContentLength(getContentLength(connection));\n            sourceInfo.setMimeType(connection.getContentType());\n            sourceInfoStorage.save(sourceInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) {\n        try {\n            URL url = new URL(sourceInfoStorage.getUrl());\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            injectCustomHeaders(connection, sourceInfoStorage.getUrl());\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n            connection.setInstanceFollowRedirects(true);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\" + (offset + readSourceAvailableBytes(connection, offset, connection.getResponseCode()) - 1));\n            }\n            return connection;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        headerInjector.inject(connection, url);\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        long availableBytes = 0;\n        if (responseCode == 206) {\n            availableBytes = connection.getHeaderFieldLong(\"Content-Range\", -1);\n        } else if (responseCode == 200) {\n            availableBytes = getContentLength(connection);\n        }\n        return availableBytes;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        long contentLength = connection.getContentLength();\n        if (contentLength == -1) {\n            contentLength = connection.getHeaderFieldLong(\"Content-Length\", -1);\n        }\n        return contentLength;\n    }\n}"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ConnectionManipulationProxyServer {\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private boolean running = false;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                running = true;\n                proxyThread = new Thread(this::run);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                running = false;\n                try {\n                    if (client != null) client.close();\n                    if (server != null) server.close();\n                    if (serverSocket != null) serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                enableProxy = false;\n            }\n        }\n    }\n\n    public void killOpenSockets() {\n        if (client != null) {\n            try {\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (server != null) {\n            try {\n                server.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running && enableProxy) {\n                client = serverSocket.accept();\n                server = new Socket(host, remotePort);\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = client.getInputStream().read(buffer)) > 0) {\n                            server.getOutputStream().write(buffer, 0, bytesRead);\n                        }\n                        server.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = server.getInputStream().read(buffer)) > 0) {\n                            client.getOutputStream().write(buffer, 0, bytesRead);\n                        }\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 541,
    "Instruction": "Task Description: Implement a TCP server in Java that handles multiple client connections concurrently using blocking I/O. The server should echo back any data received from clients after sending an initial welcome message.\n\nClass Description: EchoBioServer is a TCP server implementation that listens for incoming client connections on a specified port. For each connection, it creates a new thread to handle communication, sending a welcome message initially and then echoing back all received data.\n\nAttributes:\n- FIRST_BYTES: byte[] - The welcome message to be sent to clients upon connection\n- serverSocket: ServerSocket - The server socket listening for incoming connections\n\nMethods:\n- EchoBioServer(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Main server loop that accepts incoming connections and spawns new threads for each client\n- BioConnection(Socket socket) -> void - Nested class constructor that handles individual client connections\n- run() -> void - (In BioConnection) Handles the communication with a single client, echoing received data\n\nNested Class: BioConnection\nAttributes:\n- socket: Socket - The client socket connection\n- input: InputStream - Input stream for reading client data\n- output: OutputStream - Output stream for writing to client\n- readBuffer: byte[] - Buffer for storing received data\n- writeBuffer: byte[] - Buffer for storing data to send\n\nMethods:\n- BioConnection(Socket socket) -> void - Constructor that initializes I/O streams and buffers for a client connection\n- run() -> void - Handles the client communication loop (send welcome message, echo received data)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoBioServer implements Runnable {\n\n    private static final byte[] FIRST_BYTES = \"Welcome to Cobar Server.\".getBytes();\n    private final ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                new Thread(new BioConnection(socket)).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private byte[] readBuffer;\n        private byte[] writeBuffer;\n\n        private BioConnection(Socket socket) throws IOException {\n            this.socket = socket;\n            this.input = socket.getInputStream();\n            this.output = socket.getOutputStream();\n            this.readBuffer = new byte[4096];\n            this.writeBuffer = new byte[4096];\n        }\n\n        @Override\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                output.flush();\n                while (true) {\n                    int got = input.read(readBuffer);\n                    output.write(writeBuffer, 0, got);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EchoBioServer {\n    private static final byte[] FIRST_BYTES = \"Welcome to the echo server!\".getBytes();\n    private ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws Exception {\n        this.serverSocket = new ServerSocket(port);\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                new BioConnection(socket).run();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private byte[] readBuffer = new byte[1024];\n        private byte[] writeBuffer = new byte[1024];\n\n        public BioConnection(Socket socket) throws Exception {\n            this.socket = socket;\n            this.input = socket.getInputStream();\n            this.output = socket.getOutputStream();\n        }\n\n        public void run() {\n            try {\n                // Send welcome message\n                output.write(FIRST_BYTES);\n                output.flush();\n\n                // Echo back received data\n                int bytesRead;\n                while ((bytesRead = input.read(readBuffer)) != -1) {\n                    output.write(readBuffer, 0, bytesRead);\n                    output.flush();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this.port = port;\n        this.frame = frame;\n        this.file = file;\n    }\n\n    private static boolean checkExistInstance(int port) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(\"localhost\", port), 1000);\n            socket.close();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), 1000);\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());\n            out.writeObject(cmd);\n            String response = (String) in.readObject();\n            socket.close();\n            return response != null && response.equals(\"OK\");\n        } catch (IOException | ClassNotFoundException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket(port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> {\n                    try {\n                        ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());\n                        ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream());\n                        String command = (String) input.readObject();\n                        if (command.startsWith(\"GET_WINDOW_TITLE\")) {\n                            String title = frame.getWindowTitle();\n                            output.writeObject(title);\n                        } else if (command.startsWith(\"ACTIVATE_WINDOW\")) {\n                            frame.activateWindow();\n                        } else if (command.startsWith(\"OPEN_FILE\")) {\n                            if (file != null) {\n                                frame.openFile(file);\n                            }\n                        }\n                        output.flush();\n                        clientSocket.close();\n                    } catch (IOException | ClassNotFoundException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (serverSocket != null) serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 543,
    "Instruction": "Task Description: Implement a TCP server that listens for incoming connections and responds with a \"PONG\" message when a client connects. The server should run in a separate thread and be able to be gracefully shut down.\n\nClass Description: PingPongSocketServer is a TCP server implementation that listens on a specified port for client connections. Upon accepting a connection, it immediately sends a \"PONG\" response and closes the connection. The server runs in a dedicated thread and supports graceful termination.\n\nAttributes:\n- thread: Thread - The thread in which the server runs\n- serverSocket: ServerSocket - The socket that listens for incoming connections\n- terminated: boolean - Flag indicating whether the server should stop running\n\nMethods:\n- initialize(int port) -> void - Initializes the server by creating a ServerSocket on the specified port and starting the server thread\n- close() -> void - Gracefully shuts down the server by closing the ServerSocket and interrupting the server thread",
    "Canonical_solution": "import tech.powerjob.common.utils.CommonUtils;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\n\npublic class PingPongSocketServer implements PingPongServer {\n\n    private Thread thread;\n    private ServerSocket serverSocket;\n    private volatile boolean terminated = false;\n\n    @Override\n    public void initialize(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n\n        thread = new Thread(() -> {\n            while (true) {\n                if (terminated) {\n                    return;\n                }\n                try (Socket socket = serverSocket.accept();\n                     OutputStream outputStream = socket.getOutputStream()) {\n\n                    socket.setSoTimeout(2000);\n                    socket.setKeepAlive(false);\n\n                    outputStream.write(PingPongUtils.PONG.getBytes(StandardCharsets.UTF_8));\n                    outputStream.write(System.lineSeparator().getBytes(StandardCharsets.UTF_8));\n                    outputStream.flush();\n                } catch (Exception e) {\n                    if (!terminated) {\n                        log.warn(\"[PingPongSocketServer] process accepted socket failed!\", e);\n                    }\n                }\n            }\n        }, \"PingPongSocketServer-Thread\");\n\n        thread.start();\n    }\n\n    @Override\n    public void close() throws IOException {\n        terminated = true;\n        CommonUtils.executeIgnoreException(() -> serverSocket.close());\n        thread.interrupt();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class PingPongSocketServer {\n    private Thread thread;\n    private ServerSocket serverSocket;\n    private boolean terminated;\n\n    public void initialize(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n        thread = new Thread(this::runServer);\n        thread.start();\n    }\n\n    public void close() {\n        terminated = true;\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (thread != null) {\n            thread.interrupt();\n        }\n    }\n\n    private void runServer() {\n        while (!terminated) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(\"PONG\");\n                clientSocket.close();\n            } catch (IOException e) {\n                if (terminated) break;\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 545,
    "Instruction": "Task Description: Implement a TCP server thread class that handles incoming client connections, processes commands, and manages application state through network communication.\n\nClass Description: InnerSocketThread is a Thread subclass that creates a TCP server to listen for client connections on a specified port. It processes incoming commands to control application state and respond with status information.\n\nAttributes:\n- socket: ServerSocket - The server socket instance used to listen for incoming client connections\n\nMethods:\n- run() -> void - Main thread execution method that sets up the server socket, accepts connections, processes commands, and manages resources\n- read(InputStream in) -> String - Reads data from the input stream until carriage return is encountered\n- write(OutputStream os) -> void - Writes the current application status to the output stream\n\nMethod Details:\n1. run():\n   - Input: None (uses class attributes)\n   - Output: None\n   - Description: \n     1. Creates ServerSocket on Manager.PORT\n     2. Enters infinite loop to accept client connections\n     3. Sets socket timeout to 5000ms\n     4. Reads command from client\n     5. Processes commands (START, STATUS, FLUSHMETHOD)\n     6. Sends response for STATUS command\n     7. Closes client connection\n     8. Handles exceptions and ensures proper resource cleanup\n\n2. read(InputStream in):\n   - Input: \n     - in: InputStream - The input stream from client socket\n   - Output: String - The command string read from the stream\n   - Description:\n     1. Reads bytes from buffered input stream\n     2. Converts bytes to characters\n     3. Stops reading at carriage return ('\\r')\n     4. Returns accumulated string\n\n3. write(OutputStream os):\n   - Input:\n     - os: OutputStream - The output stream to client socket\n   - Output: None\n   - Description:\n     1. Writes \"running\" or \"stop\" based on Manager's switch flag\n     2. Appends carriage return\n     3. Flushes the output stream",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class InnerSocketThread extends Thread {\n    private ServerSocket socket;\n\n    public void run() {\n        try {\n            socket = new ServerSocket(Manager.PORT);\n            while (true) {\n                Socket child = socket.accept();\n                child.setSoTimeout(5000);\n\n                String command = read(child.getInputStream());\n\n                if (Manager.START.equals(command)) {\n                    Manager.instance().setSwitchFlag(true);\n                } else if (Manager.STATUS.equals(command)) {\n                    write(child.getOutputStream());\n                } else if (Manager.FLUSHMETHOD.equals(command)) {\n                    MethodCache.flushMethodData();\n                } else {\n                    Manager.instance().setSwitchFlag(false);\n                }\n                child.close();\n            }\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    private void write(OutputStream os) throws IOException {\n        BufferedOutputStream out = new BufferedOutputStream(os);\n        if (Manager.instance().getSwitchFlag()) {\n            out.write(\"running\".getBytes());\n        } else {\n            out.write(\"stop\".getBytes());\n        }\n        out.write('\\r');\n        out.flush();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class InnerSocketThread extends Thread {\n    private ServerSocket socket;\n\n    public void run() {\n        try {\n            socket = new ServerSocket(Manager.PORT);\n            socket.setSoTimeout(5000);\n            while (true) {\n                Socket client = socket.accept();\n                InputStream in = client.getInputStream();\n                OutputStream os = client.getOutputStream();\n                String command = read(in);\n                processCommand(command);\n                write(os);\n                client.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line);\n            if (line.contains(\"\\r\")) {\n                break;\n            }\n        }\n        return sb.toString();\n    }\n\n    private void processCommand(String command) {\n        if (command.equals(\"START\")) {\n            Manager.start();\n        } else if (command.equals(\"STATUS\")) {\n            // No action needed, response is handled in write method\n        } else if (command.equals(\"FLUSHMETHOD\")) {\n            Manager.flushMethod();\n        }\n    }\n\n    private void write(OutputStream os) throws IOException {\n        String status = Manager.isRunning() ? \"running\" : \"stop\";\n        PrintWriter writer = new PrintWriter(os);\n        writer.println(status);\n        writer.flush();\n    }\n}"
  },
  {
    "Task_id": 547,
    "Instruction": "Task Description: Implement a TCP server class that listens for incoming client connections, processes client commands, and sends responses back. The server should run in a dedicated thread and support graceful shutdown.\n\nClass Description: SnapshotService is a TCP server implementation that listens on a specified port for client connections. It processes incoming commands from clients and responds with processed messages. The server runs in a separate thread and maintains its state through a boolean flag for controlled shutdown.\n\nAttributes:\n- port: [int] - The port number on which the server listens for incoming connections\n- serverSocket: [ServerSocket] - The server socket instance used to accept client connections\n- closed: [boolean] - Flag indicating whether the server has been shut down\n\nMethods:\n- SnapshotService(int port) -> [void] - Constructor that validates and sets the server port\n- listen() -> [void] - Starts the server by opening a socket and beginning to listen for connections\n- openSocket(int port) -> [int] - Creates a ServerSocket and starts a thread to handle client connections, returns the actual port being used\n- isIgnoredException() -> [boolean] - Checks if an exception should be ignored based on server socket state\n- process(Socket socket) -> [void] - Processes an individual client connection, reading input and sending responses\n- outputMessage(BufferedWriter outputWriter, String msg) -> [void] - Helper method to send messages to clients\n- close() -> [void] - Gracefully shuts down the server by closing the server socket",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n@Slf4j\npublic final class SnapshotService {\n\n    private final int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed;\n\n    public SnapshotService(final int port) {\n        Preconditions.checkArgument(port >= 0 && port <= 0xFFFF, \"Port value out of range: \" + port);\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            log.info(\"ElasticJob: Snapshot service is running on port '{}'\", openSocket(port));\n        } catch (final IOException ex) {\n            log.error(\"ElasticJob: Snapshot service listen failure, error is: \", ex);\n        }\n    }\n\n    private int openSocket(final int port) throws IOException {\n        closed = false;\n        serverSocket = new ServerSocket(port);\n        int localPort = serverSocket.getLocalPort();\n        String threadName = String.format(\"elasticjob-snapshot-service-%d\", localPort);\n        new Thread(() -> {\n            while (!closed) {\n                try {\n                    process(serverSocket.accept());\n                } catch (final IOException ex) {\n                    if (isIgnoredException()) {\n                        return;\n                    }\n                    log.error(\"ElasticJob: Snapshot service open socket failure, error is: \", ex);\n                }\n            }\n        }, threadName).start();\n        return localPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket.isClosed();\n    }\n\n    private void process(final Socket socket) throws IOException {\n        try (\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                Socket ignored = socket) {\n            String cmdLine = reader.readLine();\n            if (null != cmdLine) {\n                outputMessage(writer, \"Processed: \" + cmdLine);\n            }\n        }\n    }\n\n    private void outputMessage(final BufferedWriter outputWriter, final String msg) throws IOException {\n        outputWriter.append(msg);\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (null != serverSocket && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (final IOException ex) {\n                log.error(\"ElasticJob: Snapshot service close failure, error is: \", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class SnapshotService {\n    private int port;\n    private ServerSocket serverSocket;\n    private boolean closed;\n\n    public SnapshotService(int port) {\n        if (port <= 0) {\n            throw new IllegalArgumentException(\"Port must be positive\");\n        }\n        this.port = port;\n    }\n\n    public void listen() {\n        new Thread(this::startServer).start();\n    }\n\n    private void startServer() {\n        try {\n            int actualPort = openSocket(port);\n            while (!closed) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> process(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            if (!closed && !isIgnoredException()) {\n                System.err.println(\"Server shutdown: \" + e.getMessage());\n            }\n        } finally {\n            close();\n        }\n    }\n\n    private int openSocket(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        return serverSocket.getLocalPort();\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket == null || serverSocket.isClosed();\n    }\n\n    private void process(Socket socket) {\n        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String inputLine;\n            while ((inputLine = reader.readLine()) != null) {\n                if (inputLine.trim().isEmpty()) continue;\n                outputMessage(writer, \"Received: \" + inputLine);\n            }\n        } catch (IOException e) {\n            if (!closed && !isIgnoredException()) {\n                System.err.println(\"Error processing client: \" + e.getMessage());\n            }\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    if (!closed && !isIgnoredException()) {\n                        System.err.println(\"Error closing socket: \" + e.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    private void outputMessage(BufferedWriter writer, String msg) throws IOException {\n        writer.write(msg);\n        writer.newLine();\n        writer.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                if (!isIgnoredException()) {\n                    System.err.println(\"Error closing server socket: \" + e.getMessage());\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 549,
    "Instruction": "Task Description: Create a mock POP3 server class that simulates interactions with a client using TCP sockets for testing purposes.\n\nClass Description: The MockPop3Server class implements a simple POP3 server mock that can be used for testing email client implementations. It handles client connections, processes commands, and manages server shutdown. The server runs in a separate thread and maintains a queue of expected interactions.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of expected client-server interactions\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for connection closure\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- mockServerThread: MockServerThread - The thread running the server\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread\n- shutdown() -> void - Signals the server thread to stop and cleans up resources\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread\n- run() -> void - Main server thread execution that handles client connections and commands\n- handleInteractions() -> void - Processes the queued interactions with the client\n- readAdditionalCommands() -> void - Reads any additional unexpected commands from the client\n- readLine() -> String - Reads a line of input from the client socket\n- shouldStop() -> void - Signals the thread to stop execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockPop3Server {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    \n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        InetSocketAddress localSocketAddress = (InetSocketAddress) serverSocket.getLocalSocketAddress();\n        host = localSocketAddress.getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        \n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            super(\"MockPop3Server\");\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = readLine();\n            if (command == null) {\n                throw new IOException(\"Connection closed\");\n            }\n        }\n\n        private String readLine() throws IOException {\n            return clientSocket.getInputStream().read() != -1 ? \"command\" : null;\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class MockPop3Server {\n    private Deque<ImapInteraction> interactions;\n    private CountDownLatch waitForConnectionClosed;\n    private CountDownLatch waitForAllExpectedCommands;\n    private Thread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockPop3Server(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.interactions = new ArrayDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(port);\n        mockServerThread = new Thread(new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands));\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            shouldStop();\n            try {\n                mockServerThread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class MockServerThread implements Runnable {\n        private ServerSocket serverSocket;\n        private Deque<ImapInteraction> interactions;\n        private CountDownLatch waitForConnectionClosed;\n        private CountDownLatch waitForAllExpectedCommands;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Socket clientSocket = serverSocket.accept();\n                    handleInteractions(clientSocket);\n                    waitForConnectionClosed.countDown();\n                }\n            } catch (IOException | InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions(Socket clientSocket) throws IOException {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n                while (!shouldStop()) {\n                    String line = readLine(in);\n                    if (line == null) {\n                        break;\n                    }\n                    if (line.trim().equals(\"QUIT\")) {\n                        out.println(\"OK\");\n                        break;\n                    }\n                    ImapInteraction interaction = interactions.pollFirst();\n                    if (interaction == null) {\n                        readAdditionalCommands(in, out);\n                        break;\n                    }\n                    if (interaction.getCommand().equals(line)) {\n                        out.println(interaction.getResponse());\n                    } else {\n                        out.println(\"ERROR\");\n                    }\n                }\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readAdditionalCommands(BufferedReader in, PrintWriter out) throws IOException {\n            String line;\n            while ((line = readLine(in)) != null) {\n                out.println(\"ERROR\");\n            }\n        }\n\n        private String readLine(BufferedReader in) throws IOException {\n            String line;\n            while ((line = in.readLine()) != null) {\n                if (!line.isEmpty()) {\n                    return line;\n                }\n            }\n            return null;\n        }\n    }\n\n    private void shouldStop() {\n        waitForAllExpectedCommands.getCount();\n    }\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JavaHttpUtility {\n    private static final int CONNECT_TIMEOUT = 10000;\n    private static final int READ_TIMEOUT = 10000;\n\n    public Proxy getProxy() {\n        return Proxy.getDefault();\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws IOException {\n        URL url = new URL(urlAddress);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(CONNECT_TIMEOUT);\n        connection.setReadTimeout(READ_TIMEOUT);\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = getUrlParameters(param).getBytes(\"utf-8\");\n            os.write(input);\n            os.flush();\n        }\n\n        return handleResponse(connection);\n    }\n\n    private String getUrlParameters(Map<String, String> params) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, String> param : params.entrySet()) {\n            if (sb.length() > 0) sb.append(\"&\");\n            sb.append(param.getKey()).append(\"=\").append(param.getValue());\n        }\n        return sb.toString();\n    }\n\n    public String handleResponse(HttpURLConnection httpURLConnection) throws IOException {\n        int responseCode = httpURLConnection.getResponseCode();\n        if (responseCode >= 400) {\n            return handleError(httpURLConnection);\n        }\n        return readResult(httpURLConnection);\n    }\n\n    public String readResult(HttpURLConnection urlConnection) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    public String handleError(HttpURLConnection urlConnection) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getErrorStream()));\n        StringBuilder errorResponse = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            errorResponse.append(line);\n        }\n        in.close();\n        throw new IOException(\"HTTP error: \" + urlConnection.getResponseCode() + \" - \" + errorResponse.toString());\n    }\n}"
  },
  {
    "Task_id": 552,
    "Instruction": "Task Description: Implement a basic HTTP server in Java using ServerSocket that handles GET requests and responds with appropriate HTTP status codes.\n\nClass Description: The Webserver class represents a simple HTTP server that listens on a specified port, accepts client connections, processes HTTP GET requests, and sends responses. It uses multi-threading to handle multiple client connections simultaneously.\n\nAttributes:\n- socket: ServerSocket - The server socket that listens for incoming client connections\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Starts the server, continuously accepting client connections and spawning ServiceThreads to handle them\n- process(Socket clnt) -> void - Processes a client connection by reading the request and sending a response\n- readLine(InputStream in) -> String - Reads a line of text from the input stream until CRLF is encountered\n- skipLine(InputStream in) -> int - Skips a line in the input stream and returns its length\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP command and generates an appropriate response\n- replyError(OutputStream out, Exception e) -> void - Sends an HTTP error response to the client\n\nAdditional Class:\nServiceThread: A helper class that extends Thread to handle individual client connections in separate threads\n\nServiceThread Attributes:\n- web: Webserver - Reference to the main server instance\n- sock: Socket - The client socket connection\n\nServiceThread Methods:\n- ServiceThread(Webserver w, Socket s) -> void - Constructor that initializes the thread with server and client socket references\n- run() -> void - The thread's main execution method that processes the client request",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Webserver {\n    private ServerSocket socket;\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            String cmd = readLine(in);\n            while (skipLine(in) > 0) {}\n            doReply(in, out, cmd);\n        }\n        catch (Exception e) {\n            replyError(out, e);\n        }\n        finally {\n            out.flush();\n            in.close();\n            out.close();\n            clnt.close();\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n        in.read();\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n        in.read();\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd) throws IOException {\n        if (cmd.startsWith(\"GET /\")) {\n            String filename = cmd.substring(5, cmd.indexOf(' ', 5));\n            out.write(\"HTTP/1.0 200 OK\\r\\n\\r\\n\".getBytes());\n        }\n        else\n            throw new IOException(\"Bad Request\");\n    }\n\n    private void replyError(OutputStream out, Exception e) throws IOException {\n        out.write(\"HTTP/1.0 400 Bad Request\\r\\n\\r\\n\".getBytes());\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}\n\nclass ServiceThread extends Thread {\n    Webserver web;\n    Socket sock;\n\n    public ServiceThread(Webserver w, Socket s) {\n        web = w;\n        sock = s;\n    }\n\n    @Override\n    public void run() {\n        try {\n            web.process(sock);\n        }\n        catch (IOException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "class Webserver {\n    private ServerSocket socket;\n\n    public Webserver(int port) throws Exception {\n        this.socket = new ServerSocket(port);\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket clnt = socket.accept();\n                new ServiceThread(this, clnt).start();\n            } catch (Exception e) {\n                replyError(clnt.getOutputStream(), e);\n            }\n        }\n    }\n\n    public void process(Socket clnt) throws Exception {\n        InputStream in = clnt.getInputStream();\n        OutputStream out = clnt.getOutputStream();\n        String cmd = readLine(in);\n        doReply(in, out, cmd);\n    }\n\n    private String readLine(InputStream in) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r' && in.read() == '\\n') break;\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private int skipLine(InputStream in) throws Exception {\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r' && in.read() == '\\n') break;\n        }\n        return in.available();\n    }\n\n    private void doReply(InputStream in, OutputStream out, String cmd) throws Exception {\n        if (cmd.startsWith(\"GET /\")) {\n            out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n            out.write(\"Content-Type: text/html\\r\\n\".getBytes());\n            out.write(\"\\r\\n\".getBytes());\n            out.write(\"<h1>Hello, World!</h1>\".getBytes());\n        } else {\n            replyError(out, new Exception(\"Unknown command: \" + cmd));\n        }\n    }\n\n    private void replyError(OutputStream out, Exception e) throws Exception {\n        out.write(\"HTTP/1.1 400 Bad Request\\r\\n\".getBytes());\n        out.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        out.write(\"\\r\\n\".getBytes());\n        out.write(e.getMessage().getBytes());\n    }\n}\n\nclass ServiceThread extends Thread {\n    private Webserver web;\n    private Socket sock;\n\n    public ServiceThread(Webserver w, Socket s) {\n        this.web = w;\n        this.sock = s;\n    }\n\n    public void run() {\n        try {\n            web.process(sock);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 553,
    "Instruction": "Task Description: Create a TCP server class that listens for incoming client connections, handles each client connection in a separate thread, and processes incoming data from clients.\n\nClass Description: TCPServer is a Java class that implements a basic TCP server using ServerSocket. It listens on a specified port for incoming client connections, creates a new thread for each connected client, and reads UTF-encoded messages from clients. The server maintains a running state and properly closes resources when finished.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- started: boolean - Flag indicating whether the server is running\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port, begins listening for connections, and creates new threads for each client\n- ClientHandler(Socket socket) -> void - Constructor for the inner client handler class (takes a client socket as parameter)\n- run() -> void - The thread's main execution method that reads data from the client (inherited from Thread)",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPServer {\n    private ServerSocket serverSocket;\n    private boolean started;\n\n    public void start(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        started = true;\n        System.out.println(\"Server started\");\n\n        try {\n            while (started) {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"A client connected!\");\n                new ClientHandler(clientSocket).start();\n            }\n        } finally {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        }\n    }\n\n    private class ClientHandler extends Thread {\n        private Socket socket;\n        private DataInputStream inputStream;\n\n        public ClientHandler(Socket socket) throws IOException {\n            this.socket = socket;\n            this.inputStream = new DataInputStream(socket.getInputStream());\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(inputStream.readUTF());\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TCPServer {\n    private ServerSocket serverSocket;\n    private boolean started;\n\n    public void start(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            started = true;\n            System.out.println(\"Server started on port \" + port);\n\n            while (started) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(new ClientHandler(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class ClientHandler implements Runnable {\n        private Socket socket;\n\n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    System.out.println(\"Received: \" + inputLine);\n                    out.println(\"Echo: \" + inputLine);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 554,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP echo server using ServerSocket to listen for client connections, receive messages, and send them back to the client with an \"ECHO : \" prefix until the client sends \"bye\" or an empty message.\n\nClass Description: The EchoServer class represents a TCP server that echoes back received messages to connected clients. It handles client connections, message processing, and resource cleanup.\n\nAttributes:\n- server: [ServerSocket] - The server socket listening for incoming connections\n- client: [Socket] - The socket representing the connected client\n- out: [PrintStream] - Output stream to send data to the client\n- buf: [BufferedReader] - Input stream to read data from the client\n- flag: [boolean] - Control flag for the server's main loop\n\nMethods:\n- EchoServer(int port) -> [void] - Constructor that initializes the server socket on the specified port\n- start() -> [void] - Starts the server, accepts client connections, and begins echoing messages\n- close() -> [void] - Closes client and server sockets to release resources",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoServer {\n\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) throws Exception {\n        server = new ServerSocket(port);\n        flag = true;\n    }\n\n    public void start() throws Exception {\n        System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\");\n        client = server.accept();\n        out = new PrintStream(client.getOutputStream());\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        while (flag) {\n            String str = buf.readLine();\n            if (str == null || \"\".equals(str)) {\n                flag = false;\n            } else {\n                if (\"bye\".equals(str)) {\n                    flag = false;\n                } else {\n                    out.println(\"ECHO : \" + str);\n                }\n            }\n        }\n    }\n\n    public void close() throws Exception {\n        client.close();\n        server.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EchoServer {\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) {\n        try {\n            server = new ServerSocket(port);\n            flag = true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        while (flag) {\n            try {\n                client = server.accept();\n                out = new PrintStream(client.getOutputStream());\n                buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                String message;\n\n                while ((message = buf.readLine()) != null) {\n                    if (message.equals(\"bye\") || message.isEmpty()) {\n                        flag = false;\n                        break;\n                    }\n                    out.println(\"ECHO : \" + message);\n                }\n                close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            if (buf != null) buf.close();\n            if (out != null) out.close();\n            if (client != null) client.close();\n            if (server != null) server.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 555,
    "Instruction": "Task Description: Create a TCP server class that handles multiple types of client requests through socket communication, supporting operations like content updates, progress tracking, and layout management.\n\nClass Description: LinkServer is a TCP server implementation that listens on a specified port for incoming client connections. It handles different types of requests defined by operation codes, manages client connections in separate threads, and provides bidirectional communication through input/output streams.\n\nAttributes:\n- server: ServerSocket - The main server socket that listens for incoming connections\n- port: int - The port number on which the server listens (default: 9999)\n- UPDATE_CONTENT: int - Constant for content update operation (value: 1)\n- UPDATE_PROGRESS: int - Constant for progress update operation (value: 2)\n- GET_CURRENT_CONTENT: int - Constant for content retrieval operation (value: 3)\n- SET_DRAW_DEBUG: int - Constant for debug mode setting operation (value: 4)\n- GET_LAYOUT_LIST: int - Constant for layout list retrieval operation (value: 5)\n- GET_CURRENT_LAYOUT: int - Constant for current layout retrieval operation (value: 6)\n- UPDATE_LAYOUT_DIMENSIONS: int - Constant for layout dimensions update operation (value: 7)\n\nMethods:\n- LinkServer() -> void - Default constructor initializes server with default port\n- LinkServer(int port) -> void - Constructor that takes a custom port number\n- init() -> void - Initializes the ServerSocket instance\n- start() -> void - Starts the server and begins accepting client connections in a dedicated thread\n- handleRequest(Socket socket) -> void - Handles client requests in a separate thread (Input: client socket)\n- closeConnection(Socket socket) -> void - Closes the client socket connection (Input: client socket to close)",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Set;\n\npublic class LinkServer {\n    private ServerSocket server;\n    private int port = 9999;\n\n    final int UPDATE_CONTENT = 1;\n    final int UPDATE_PROGRESS = 2;\n    final int GET_CURRENT_CONTENT = 3;\n    final int SET_DRAW_DEBUG = 4;\n    final int GET_LAYOUT_LIST = 5;\n    final int GET_CURRENT_LAYOUT = 6;\n    final int UPDATE_LAYOUT_DIMENSIONS = 7;\n\n    public LinkServer() {\n        init();\n        start();\n    }\n\n    public LinkServer(int port) {\n        this.port = port;\n        init();\n        start();\n    }\n\n    private void init() {\n        try {\n            server = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void start() {\n        Thread t = new Thread(() -> {\n            try {\n                while (true) {\n                    Socket client = server.accept();\n                    Thread acceptThread = new Thread(() -> handleRequest(client));\n                    acceptThread.start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        t.setName(\"Link Debug Thread\");\n        t.start();\n    }\n\n    void handleRequest(Socket socket) {\n        boolean running = true;\n        DataInputStream reader;\n        DataOutputStream writer;\n        try {\n            reader = new DataInputStream(socket.getInputStream());\n            writer = new DataOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n\n        while (running) {\n            try {\n                int type = reader.readInt();\n                String name = reader.readUTF();\n                switch (type) {\n                    case UPDATE_CONTENT:\n                        String content = reader.readUTF();\n                        break;\n                    case UPDATE_PROGRESS:\n                        float progress = reader.readFloat();\n                        break;\n                    case GET_CURRENT_CONTENT:\n                        content = \"\";\n                        writer.writeUTF(content);\n                        break;\n                    case SET_DRAW_DEBUG:\n                        boolean drawDebug = reader.readBoolean();\n                        break;\n                    case GET_LAYOUT_LIST:\n                        Set<String> list = Set.of();\n                        writer.writeInt(list.size());\n                        for (String layout : list) {\n                            writer.writeUTF(layout);\n                        }\n                        break;\n                    case GET_CURRENT_LAYOUT:\n                        content = \"\";\n                        writer.writeUTF(content);\n                        break;\n                    case UPDATE_LAYOUT_DIMENSIONS:\n                        int width = reader.readInt();\n                        int height = reader.readInt();\n                        break;\n                }\n            } catch (Exception e) {\n                closeConnection(socket);\n                running = false;\n            }\n        }\n    }\n\n    private void closeConnection(Socket socket) {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class LinkServer {\n    private ServerSocket server;\n    private int port = 9999;\n    public static final int UPDATE_CONTENT = 1;\n    public static final int UPDATE_PROGRESS = 2;\n    public static final int GET_CURRENT_CONTENT = 3;\n    public static final int SET_DRAW_DEBUG = 4;\n    public static final int GET_LAYOUT_LIST = 5;\n    public static final int GET_CURRENT_LAYOUT = 6;\n    public static final int UPDATE_LAYOUT_DIMENSIONS = 7;\n\n    public LinkServer() {\n    }\n\n    public LinkServer(int port) {\n        this.port = port;\n    }\n\n    public void init() throws Exception {\n        server = new ServerSocket(port);\n    }\n\n    public void start() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    Socket socket = server.accept();\n                    new Thread(this::handleRequest, \"ClientHandler\").start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void handleRequest(Socket socket) {\n        try {\n            ObjectInputStream input = new ObjectInputStream(socket.getInputStream());\n            ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());\n            int operationCode = input.readInt();\n            switch (operationCode) {\n                case UPDATE_CONTENT:\n                    String content = input.readUTF();\n                    System.out.println(\"Received update content: \" + content);\n                    output.writeInt(200);\n                    output.flush();\n                    break;\n                case UPDATE_PROGRESS:\n                    int progress = input.readInt();\n                    System.out.println(\"Received progress update: \" + progress);\n                    output.writeInt(200);\n                    output.flush();\n                    break;\n                case GET_CURRENT_CONTENT:\n                    output.writeUTF(\"Sample content\");\n                    output.flush();\n                    break;\n                case SET_DRAW_DEBUG:\n                    boolean debugMode = input.readBoolean();\n                    System.out.println(\"Debug mode set to: \" + debugMode);\n                    output.writeInt(200);\n                    output.flush();\n                    break;\n                case GET_LAYOUT_LIST:\n                    output.writeObject(Arrays.asList(\"Layout1\", \"Layout2\"));\n                    output.flush();\n                    break;\n                case GET_CURRENT_LAYOUT:\n                    output.writeUTF(\"Layout1\");\n                    output.flush();\n                    break;\n                case UPDATE_LAYOUT_DIMENSIONS:\n                    int width = input.readInt();\n                    int height = input.readInt();\n                    System.out.println(\"Received layout dimensions: \" + width + \"x\" + height);\n                    output.writeInt(200);\n                    output.flush();\n                    break;\n                default:\n                    output.writeInt(400);\n                    output.flush();\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection(socket);\n        }\n    }\n\n    public void closeConnection(Socket socket) {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 556,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles multiple client connections concurrently using thread pooling. The server should listen on a specified port, accept incoming connections, and process client requests in separate worker threads.\n\nClass Description: ViewServer is a TCP server implementation that manages incoming client connections using a thread pool. It provides methods to start and stop the server, and processes client requests asynchronously through worker threads.\n\nAttributes:\n- VIEW_SERVER_DEFAULT_PORT: int - Default port number for the server (4939)\n- VIEW_SERVER_MAX_CONNECTIONS: int - Maximum number of concurrent connections (10)\n- mServer: ServerSocket - The server socket instance for accepting connections\n- mPort: int - The port number on which the server listens\n- mThread: Thread - The server's main thread\n- mThreadPool: ExecutorService - Thread pool for handling client connections\n\nMethods:\n- ViewServer(int port) -> None - Constructor that initializes the server with specified port\n- start() -> boolean - Starts the server thread and initializes thread pool, returns true if successful\n- stop() -> boolean - Stops the server thread, shuts down thread pool, and closes server socket, returns true if successful\n- run() -> None - Main server loop that accepts incoming connections and delegates to worker threads\n- ViewServerWorker(Socket client) -> None - Nested class constructor for handling individual client connections\n- run() (in ViewServerWorker) -> None - Processes client request by reading input stream and closing connection",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    \n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n        return true;\n    }\n\n    public boolean stop() {\n        if (mThread != null) {\n            mThread.interrupt();\n            if (mThreadPool != null) {\n                try {\n                    mThreadPool.shutdownNow();\n                } catch (SecurityException e) {\n                    // Ignore\n                }\n            }\n\n            mThreadPool = null;\n            mThread = null;\n\n            try {\n                mServer.close();\n                mServer = null;\n                return true;\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        return false;\n    }\n\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            // Ignore\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n            } catch (Exception e) {\n                // Ignore\n            }\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                String request = in.readLine();\n                // Process client request here\n            } catch(IOException e) {\n                // Ignore\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ViewServer {\n    private static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    public ViewServer(int port) {\n        this.mPort = port;\n    }\n\n    public boolean start() {\n        try {\n            mServer = new ServerSocket(mPort);\n            mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n            mThread = new Thread(this::run);\n            mThread.start();\n            return true;\n        } catch (IOException e) {\n            System.err.println(\"Failed to start server: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public boolean stop() {\n        try {\n            if (mServer != null) {\n                mServer.close();\n            }\n            if (mThreadPool != null) {\n                mThreadPool.shutdownNow();\n            }\n            if (mThread != null) {\n                mThread.interrupt();\n            }\n            return true;\n        } catch (Exception e) {\n            System.err.println(\"Failed to stop server: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket client = mServer.accept();\n                mThreadPool.execute(new ViewServerWorker(client));\n            } catch (IOException e) {\n                System.err.println(\"Error accepting connection: \" + e.getMessage());\n                break;\n            }\n        }\n    }\n\n    static class ViewServerWorker implements Runnable {\n        private final Socket client;\n\n        public ViewServerWorker(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            try {\n                InputStream input = client.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(\"Received from client: \" + line);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error processing client request: \" + e.getMessage());\n            } finally {\n                try {\n                    if (client != null) {\n                        client.close();\n                    }\n                } catch (IOException e) {\n                    System.err.println(\"Error closing client connection: \" + e.getMessage());\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Component\npublic class WechatMediaUtil {\n\n    private final WechatAccessTokenUtil wechatAccessTokenUtil;\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/media/upload/%s?access_token=%s\";\n    private static final Map<String, String> CONTENT_TYPE_TO_EXTENSION = new HashMap<>();\n    static {\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/png\", \".png\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/jpeg\", \".jpg\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/jpg\", \".jpg\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/gif\", \".gif\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/bmp\", \".bmp\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/webp\", \".webp\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/mp4\", \".mp4\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/quicktime\", \".mov\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/x-ms-wmv\", \".wmv\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/x-ms-asf\", \".asf\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/mpeg\", \".mpeg\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/avi\", \".avi\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/mpeg\", \".mp3\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/wav\", \".wav\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/aac\", \".aac\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/amr\", \".amr\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/flac\", \".flac\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/ogg\", \".ogg\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/wma\", \".wma\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/x-mpegurl\", \".m3u8\");\n    }\n\n    @Autowired\n    public WechatMediaUtil(WechatAccessTokenUtil wechatAccessTokenUtil) {\n        this.wechatAccessTokenUtil = wechatAccessTokenUtil;\n    }\n\n    public String uploadMedia(String type, String mediaFileUrl) throws IOException, URISyntaxException {\n        if (!CONTENT_TYPE_TO_EXTENSION.containsKey(type)) {\n            throw new IllegalArgumentException(\"Unsupported media type: \" + type);\n        }\n\n        String extension = CONTENT_TYPE_TO_EXTENSION.get(type);\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        String mediaUrl = String.format(MEDIA_URL, type, accessToken);\n\n        RestTemplate restTemplate = new RestTemplate();\n        MultipartFile file = new MockMultipartFile(\"file\", \"test\" + extension, type, \"mock content\".getBytes());\n\n        Map<String, Object> response = restTemplate.postForEntity(mediaUrl, file, Map.class).getBody();\n        if (response == null || !response.containsKey(\"media_id\")) {\n            throw new IOException(\"Failed to upload media: \" + response);\n        }\n\n        return (String) response.get(\"media_id\");\n    }\n\n    public String judgeType(String contentType) {\n        String extension = CONTENT_TYPE_TO_EXTENSION.get(contentType);\n        if (extension == null) {\n            throw new IllegalArgumentException(\"Unsupported content type: \" + contentType);\n        }\n        return extension;\n    }\n\n    private static class MockMultipartFile implements MultipartFile {\n        private final String name;\n        private final String originalFilename;\n        private final String contentType;\n        private final byte[] bytes;\n\n        public MockMultipartFile(String name, String originalFilename, String contentType, byte[] bytes) {\n            this.name = name;\n            this.originalFilename = originalFilename;\n            this.contentType = contentType;\n            this.bytes = bytes;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public String getOriginalFilename() {\n            return originalFilename;\n        }\n\n        @Override\n        public String getContentType() {\n            return contentType;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return bytes.length == 0;\n        }\n\n        @Override\n        public long getSize() {\n            return bytes.length;\n        }\n\n        @Override\n        public byte[] getBytes() throws IOException {\n            return bytes;\n        }\n\n        @Override\n        public String getInputStream() throws IOException {\n            return new String(bytes);\n        }\n\n        @Override\n        public String getFileName() {\n            return originalFilename;\n        }\n\n        @Override\n        public void transferTo(Path targetPath) throws IOException {\n            Files.write(targetPath, bytes);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\n\npublic class SocketClient {\n    private final SSLContext clientSslContext;\n    private final InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        try (SSLSocket sslSocket = (SSLSocket) clientSslContext.createSSLEngine()) {\n            sslSocket.connect(address);\n            sslSocket.startHandshake();\n            sendHttpRequest(sslSocket);\n            readResponse(sslSocket);\n        } catch (IOException e) {\n            throw new IOException(\"Error during secure connection or request processing\", e);\n        }\n    }\n\n    private void sendHttpRequest(SSLSocket sslSocket) throws IOException {\n        String request = \"GET / HTTP/1.1\\r\\n\" +\n                \"Host: example.com\\r\\n\" +\n                \"Connection: close\\r\\n\\r\\n\";\n        OutputStream out = sslSocket.getOutputStream();\n        out.write(request.getBytes());\n        out.flush();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream is = sslSocket.getInputStream();\n        String line;\n        while ((line =.readLine(is)) != null) {\n            System.out.println(line);\n            if (line.contains(\"HTTP/1.1\") && line.startsWith(\"200\")) {\n                break;\n            }\n        }\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = is.read()) != -1) {\n            if (c == '\\r') {\n                int next = is.read();\n                if (next == '\\n') {\n                    break;\n                }\n            } else {\n                sb.append((char) c);\n            }\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.security.SecureRandom;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        this.mContext = context;\n        this.mConnectivityManager = connectivityManager;\n        this.mSSLSocketFactory = (SSLSocketFactory) SSLContext.getDefault().getSocketFactory();\n        this.mDelayedRestartHandler = new Handler(Looper.getMainLooper());\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        try {\n            return connectSocketNoProxy(host, port);\n        } catch (IOException e) {\n            // Attempt to use HTTP proxy if direct connection fails\n            Socket proxySocket = connectSocketViaHttpProxyConnectMethod(host, port, getProxyAddress());\n            if (proxySocket != null) {\n                return proxySocket;\n            }\n            throw e;\n        }\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        Proxy proxy = new Proxy(Proxy.Type.HTTP, proxyAddress);\n        Socket socket = new Socket(proxy);\n        socket.connect(new InetSocketAddress(host, port), HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    private static SocketAddress getProxyAddress() {\n        // This is a placeholder; in a real implementation, this would retrieve the proxy address from the system\n        return null;\n    }\n\n    private void tryEnableSni(SSLSocket socket, String hostname) {\n        if (socket instanceof SSLSocket) {\n            try {\n                ((SSLSocket) socket).setHostname(hostname);\n            } catch (Exception e) {\n                // Handle exception if SNI is not supported\n            }\n        }\n    }\n\n    private void tryEnableSessionTickets(SSLSocket socket) {\n        if (socket instanceof SSLSocket) {\n            try {\n                ((SSLSocket) socket).setUseSessionTickets(true);\n            } catch (Exception e) {\n                // Handle exception if session tickets are not supported\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet fileSet, String server, String from, String to, String subject) {\n        this.mailServer = server;\n        this.fromAddress = from;\n        this.recipientString = to;\n        this.mailSubject = subject;\n        this.errorDialogTitle = \"Email Sending Error\";\n        this.boundary = \"----\" + System.currentTimeMillis() + \"----\";\n    }\n\n    public void openConnection() throws Exception {\n        socket = new Socket(mailServer, 25);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        out = socket.getOutputStream();\n        out64 = new Base64OutputStream(out);\n        connectedToMailServer = true;\n        readWriteLine(\"HELO \" + mailServer);\n        readWriteLine(\"MAIL FROM:<\" + fromAddress + \">\");\n        String[] recipients = splitRecipientString(recipientString, new ArrayList<>());\n        for (String recipient : recipients) {\n            readWriteLine(\"RCPT TO:<\" + recipient + \">\");\n        }\n        readWriteLine(\"DATA\");\n    }\n\n    public void sendBody() throws Exception {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"From: \").append(fromAddress).append(\"\\r\\n\");\n        sb.append(\"To: \").append(recipientString).append(\"\\r\\n\");\n        sb.append(\"Subject: \").append(mailSubject).append(\"\\r\\n\");\n        sb.append(\"Content-Type: multipart/mixed; boundary=\\\"\").append(boundary).append(\"\\\"\\r\\n\");\n        sb.append(\"\\r\\n\");\n        sb.append(\"--\").append(boundary).append(\"\\r\\n\");\n        sb.append(\"Content-Type: text/plain; charset=US-ASCII\\r\\n\");\n        sb.append(\"Content-Transfer-Encoding: 7bit\\r\\n\\r\\n\");\n        sb.append(mailBody).append(\"\\r\\n\");\n        sb.append(\"--\").append(boundary).append(\"\\r\\n\");\n        sendAttachment(null);\n        sb.append(\"--\").append(boundary).append(\"--\\r\\n.\");\n        writeLine(sb.toString());\n    }\n\n    public void sendAttachment(AbstractFile file) throws Exception {\n        if (file != null) {\n            String fileName = file.getName();\n            String contentType = getContentType(fileName);\n            String contentTransferEncoding = \"base64\";\n            String disposition = \"attachment; filename=\\\"\" + fileName + \"\\\"\";\n            String header = \"Content-Type: \" + contentType + \"; name=\\\"\" + fileName + \"\\\"\\r\\n\" +\n                    \"Content-Transfer-Encoding: \" + contentTransferEncoding + \"\\r\\n\" +\n                    \"Content-Disposition: \" + disposition + \"\\r\\n\" +\n                    \"Content-ID: <\" + fileName + \">\\r\\n\" +\n                    \"\\r\\n\";\n            writeLine(header);\n            byte[] fileData = file.getBytes();\n            out64.write(fileData);\n            out64.flush();\n        }\n    }\n\n    public void closeConnection() throws Exception {\n        if (connectedToMailServer) {\n            readWriteLine(\"QUIT\");\n            if (out64 != null) {\n                out64.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n            connectedToMailServer = false;\n        }\n    }\n\n    public void readWriteLine(String line) throws Exception {\n        writeLine(line);\n        String response = in.readLine();\n        if (!response.contains(\"250\")) {\n            throw new Exception(\"SMTP error: \" + response);\n        }\n    }\n\n    public void writeLine(String line) throws Exception {\n        out.write((line + \"\\r\\n\").getBytes());\n        out.flush();\n    }\n\n    public String splitRecipientString(String recipientString, List<String> recipients) {\n        if (recipientString == null || recipientString.isEmpty()) {\n            return \"\";\n        }\n        String[] parts = recipientString.split(\",\");\n        for (String part : parts) {\n            recipients.add(part.trim());\n        }\n        return String.join(\",\", recipients);\n    }\n\n    private String getContentType(String fileName) {\n        String extension = fileName.substring(fileName.lastIndexOf(\".\") + 1).toLowerCase();\n        switch (extension) {\n            case \"txt\": return \"text/plain\";\n            case \"pdf\": return \"application/pdf\";\n            case \"jpg\": return \"image/jpeg\";\n            case \"png\": return \"image/png\";\n            case \"doc\": return \"application/msword\";\n            case \"xls\": return \"application/vnd.ms-excel\";\n            case \"ppt\": return \"application/vnd.ms-powerpoint\";\n            default: return \"application/octet-stream\";\n        }\n    }\n}"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class SocketTest {\n    private static final int CONNECTION_TIMEOUT = 10000;\n    private static final int MESSAGE_TIMEOUT = 10000;\n\n    public void testConnection() {\n        CountDownLatch connectionLatch = new CountDownLatch(1);\n        CountDownLatch messageLatch = new CountDownLatch(1);\n\n        try (Socket socket = new Socket()) {\n            // Set timeout for connection\n            socket.connect(new InetSocketAddress(\"localhost\", 8080), CONNECTION_TIMEOUT);\n            connectionLatch.countDown();\n\n            // Get input and output streams\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            // Send HTTP GET request\n            String request = \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n            out.write(request.getBytes());\n            out.flush();\n\n            // Wait for message delivery\n            messageLatch.countDown();\n\n            // Wait for connection and message to complete\n            connectionLatch.await();\n            messageLatch.await();\n        } catch (IOException | InterruptedException e) {\n            throw new RuntimeException(\"Connection or message delivery failed\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TestAbnormalRequestTermination {\n    private static final String SERVER_ADDRESS = DefaultServer.getDefaultServerAddress();\n    private static final int TIMEOUT_MS = 5000;\n\n    public void testAbnormalRequestTermination() throws IOException, InterruptedException {\n        Socket socket = new Socket(SERVER_ADDRESS.getHostAddress(), SERVER_ADDRESS.getPort());\n        OutputStream out = socket.getOutputStream();\n        InputStream in = socket.getInputStream();\n\n        try {\n            String request = \"POST /test HTTP/1.1\\r\\n\" +\n                             \"Host: example.com\\r\\n\" +\n                             \"Content-Length: 1234\\r\\n\" +\n                             \"\\r\\n\" +\n                             \"MalformedData\";\n\n            out.write(request.getBytes());\n            out.flush();\n\n            // Immediately close the streams to simulate abnormal termination\n            out.close();\n            in.close();\n            socket.close();\n\n            // Wait for the completion listener to be called\n            if (!completionListenerCalledLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)) {\n                throw new AssertionError(\"Completion listener not called within timeout\");\n            }\n\n            // Verify the listener was called\n            assert completionListenerCalled;\n        } finally {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SocketChannel;\nimport java.io.IOException;\n\nabstract class AbstractSocket {\n    protected SocketChannel socketChannel;\n    protected SocketAddress socketAddress;\n\n    public AbstractSocket(SocketAddress socketAddress) {\n        this.socketAddress = socketAddress;\n    }\n\n    public abstract InputStream getInputStream() throws IOException;\n    public abstract OutputStream getOutputStream() throws IOException;\n    public abstract SocketAddress getLocalSocketAddress();\n    public abstract SocketAddress getRemoteSocketAddress();\n    public abstract void close() throws IOException;\n}\n\nclass UnixSocket extends AbstractSocket {\n    public UnixSocket(String path) throws IOException {\n        super(new InetSocketAddress(path));\n        socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(true);\n        socketChannel.connect(socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (!socketChannel.isConnected() || !socketChannel.isConnectionPending()) {\n            throw new IOException(\"Socket not connected\");\n        }\n        if (socketChannel.socket().isInputShutdown()) {\n            throw new IOException(\"Input shutdown\");\n        }\n        return socketChannel.socket().getInputStream();\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (!socketChannel.isConnected() || !socketChannel.isConnectionPending()) {\n            throw new IOException(\"Socket not connected\");\n        }\n        if (socketChannel.socket().isOutputShutdown()) {\n            throw new IOException(\"Output shutdown\");\n        }\n        return socketChannel.socket().getOutputStream();\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketChannel.getLocalAddress();\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketChannel.getRemoteAddress();\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (socketChannel != null) {\n            try {\n                socketChannel.close();\n            } catch (ClosedChannelException e) {\n                // Ignore if already closed\n            }\n        }\n    }\n\n    static class WrappedWritableByteChannel extends java.nio.channels.WritableByteChannel {\n        private final SocketChannel socketChannel;\n\n        public WrappedWritableByteChannel(SocketChannel socketChannel) {\n            this.socketChannel = socketChannel;\n        }\n\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        handler = new Handler(Looper.getMainLooper());\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private void tryConnect() {\n        while (true) {\n            if (connect()) {\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private boolean connect() {\n        try {\n            socketClient = new Socket(hostip, port);\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void send(byte[] data) {\n        if (socketClient != null && socketClient.isConnected()) {\n            try {\n                OutputStream out = socketClient.getOutputStream();\n                out.write(data);\n                out.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient != null) {\n            try {\n                socketClient.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread == null || !receiveThread.isAlive()) {\n            receiveThread = new Thread(new Receiver());\n            receiveThread.start();\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        return (b[0] & 0xFF) << 24 | (b[1] & 0xFF) << 16 | (b[2] & 0xFF) << 8 | (b[3] & 0xFF);\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        return (b[4] & 0xFF) << 24 | (b[5] & 0xFF) << 16 | (b[6] & 0xFF) << 8 | (b[7] & 0xFF);\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while (true) {\n                try {\n                    bytesRead = socketClient.getInputStream().read(buffer);\n                    if (bytesRead > 0) {\n                        byte[] header = new byte[PACKAGE_HEAD_LENGTH];\n                        System.arraycopy(buffer, 0, header, 0, PACKAGE_HEAD_LENGTH);\n                        int length = getLengthFromHeadByte(header);\n                        int type = getTypeFromHeadByte(header);\n                        if (length > 0) {\n                            byte[] data = new byte[length];\n                            System.arraycopy(buffer, PACKAGE_HEAD_LENGTH, data, 0, length);\n                            if (receiveListener != null) {\n                                receiveListener.onDataReceived(data, type);\n                            }\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n        }\n    }\n\n    public interface ReceiveListener {\n        void onDataReceived(byte[] data, int type);\n    }\n}"
  },
  {
    "Task_id": 568,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for network communication, including connection management and data transmission.\n\nClass Description: The TelnetTransport class provides TCP client capabilities for establishing connections, sending/receiving data, and managing network resources. It handles multiple IP addresses for a given hostname and provides basic I/O operations.\n\nAttributes:\n- socket: Socket - The underlying TCP socket for network communication\n- is: InputStream - Input stream for receiving data from the server\n- os: OutputStream - Output stream for sending data to the server\n- connected: boolean - Connection status flag indicating whether the client is currently connected\n\nMethods:\n- connect(String hostname, int port) -> void - Establishes a connection to the specified host and port, trying all available IP addresses for the hostname. Throws IOException on connection failure.\n- close() -> void - Closes the connection and releases all network resources. Handles cleanup gracefully.\n- flush() -> void - Flushes the output stream to ensure all buffered data is sent. Throws IOException on failure.\n- isConnected() -> boolean - Returns the current connection status (true if connected).\n- read(byte[] buffer, int start, int len) -> int - Reads data from the input stream into the buffer. Returns number of bytes read or throws IOException if connection is closed.\n- write(byte[] buffer) -> void - Writes the entire buffer to the output stream. Throws IOException on failure.\n- write(int c) -> void - Writes a single byte to the output stream. Throws IOException on failure.\n- tryAllAddresses(Socket sock, String host, int port) -> void - Private helper method that attempts connection to all IP addresses associated with a hostname. Throws SocketTimeoutException if all attempts fail.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.net.UnknownHostException;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected = false;\n\n    public void connect(String hostname, int port) throws IOException {\n        socket = new Socket();\n        tryAllAddresses(socket, hostname, port);\n        connected = true;\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress addr : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(addr, port));\n                return;\n            } catch (SocketTimeoutException ignored) {\n            }\n        }\n        throw new SocketTimeoutException(\"Could not connect; socket timed out\");\n    }\n\n    public void close() {\n        connected = false;\n        if (socket != null) {\n            try {\n                socket.close();\n                socket = null;\n            } catch (IOException e) {\n                System.err.println(\"Error closing socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void flush() throws IOException {\n        if (os != null) {\n            os.flush();\n        }\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        int n = is.read(buffer, start, len);\n        if (n < 0) {\n            throw new IOException(\"Remote end closed connection.\");\n        }\n        return n;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (os != null) {\n            os.write(buffer);\n        }\n    }\n\n    public void write(int c) throws IOException {\n        if (os != null) {\n            os.write(c);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected;\n\n    public void connect(String hostname, int port) throws IOException {\n        try {\n            tryAllAddresses(socket, hostname, port);\n            connected = true;\n        } catch (SocketTimeoutException e) {\n            throw new IOException(\"Failed to connect to \" + hostname + \":\" + port, e);\n        }\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws SocketTimeoutException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress address : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(address, port), 5000);\n                return;\n            } catch (IOException e) {\n                // Continue to next address\n            }\n        }\n        throw new SocketTimeoutException(\"Failed to connect to \" + host + \":\" + port);\n    }\n\n    public void close() throws IOException {\n        if (connected) {\n            if (os != null) {\n                os.close();\n            }\n            if (is != null) {\n                is.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n            connected = false;\n        }\n    }\n\n    public void flush() throws IOException {\n        if (os != null) {\n            os.flush();\n        } else {\n            throw new IOException(\"Not connected\");\n        }\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        if (is == null) {\n            throw new IOException(\"Not connected\");\n        }\n        int bytesRead = is.read(buffer, start, len);\n        if (bytesRead < 0) {\n            close();\n            throw new IOException(\"Connection closed by server\");\n        }\n        return bytesRead;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        if (os == null) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(buffer);\n        flush();\n    }\n\n    public void write(int c) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        if (os == null) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(c);\n        flush();\n    }\n}"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import android.content.Context;\nimport com.facebook.stetho.Stetho;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws UnknownHostException, IOException {\n        Socket socket = new Socket(host, port);\n        BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        BufferedWriter output = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        StethoReporter reporter = new StethoReporter();\n        return new IRCClientConnection(reporter, socket, input, output);\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, BufferedReader input, BufferedWriter output) {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = input;\n        mOutput = output;\n    }\n\n    public String read() throws IOException {\n        String line = mInput.readLine();\n        if (line != null) {\n            mReporter.reportNetworkEvent(\"Received message: \" + line);\n            maybeHandleIncomingMessage(line);\n        }\n        return line;\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.reportNetworkEvent(\"Sending message: \" + message);\n        mOutput.write(message + \"\\r\\n\");\n        mOutput.flush();\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) {\n        if (message.startsWith(\"PING\")) {\n            mReporter.reportNetworkEvent(\"Handling PING: \" + message);\n            send(\"PONG \" + message.substring(5));\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mSocket != null) {\n            mSocket.close();\n        }\n        if (mInput != null) {\n            mInput.close();\n        }\n        if (mOutput != null) {\n            mOutput.close();\n        }\n    }\n\n    public class StethoReporter {\n        public void reportNetworkEvent(String event) {\n            // In a real scenario, this would integrate with Stetho to report network events\n            System.out.println(\"Stetho Network Event: \" + event);\n        }\n    }\n}"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch data from a given URL and process the response as a JSON object.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests. It uses Android's AsyncTask to perform network operations in the background and processes the response data.\n\nAttributes: None (This is a utility class with static methods and nested classes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, reads the response, and publishes the progress for JSON processing.\n\nMethod2: ConvertInputToStringNoChange(InputStream inputStream) -> String - A static helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.\n\nMethod Details:\n\nMyAsyncTaskgetNews:\n- Input Parameters: String... params (varargs where params[0] should be the URL string)\n- Return Type: String (though it primarily works through side effects)\n- Description: \n  1. Creates a URL object from the input string\n  2. Opens an HttpURLConnection with a 7-second timeout\n  3. Reads the input stream and converts it to a string\n  4. Publishes the result for JSON processing in onProgressUpdate\n  5. Disconnects the connection when done\n\nConvertInputToStringNoChange:\n- Input Parameters: InputStream inputStream (the stream to read from)\n- Return Type: String (the concatenated content of the stream)\n- Description:\n  1. Creates a BufferedReader from the InputStream\n  2. Reads all lines and concatenates them into a single string\n  3. Closes the input stream\n  4. Returns the concatenated string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n            } catch (Exception ex) {}\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    public static class MyAsyncTask extends AsyncTask<String, String, String> {\n        private String url;\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n            // Initialization code if needed\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            if (params.length == 0) {\n                return null;\n            }\n            url = params[0];\n            try {\n                java.net.URL urlObj = new java.net.URL(url);\n                java.net.HttpURLConnection connection = (java.net.HttpURLConnection) urlObj.openConnection();\n                connection.setConnectTimeout(7000);\n                connection.setReadTimeout(7000);\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == 200) {\n                    InputStream inputStream = connection.getInputStream();\n                    String result = ConvertInputToStringNoChange(inputStream);\n                    publishProgress(result);\n                    connection.disconnect();\n                    return result;\n                } else {\n                    connection.disconnect();\n                    return \"Error: HTTP response code \" + responseCode;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                return \"Error: \" + e.getMessage();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            if (values.length > 0) {\n                // Process the JSON string here\n                // Example: parseJSON(values[0]);\n            }\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n\n    public static String getNews(String... params) {\n        new MyAsyncTask().execute(params);\n        return \"Request initiated\";\n    }\n}"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.InputStream;\nimport java.net.URI;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\n\npublic class TcpClient {\n    public static long sendData(URI uri, InputStream inputStream, Object parser) throws IOException, InterruptedException, URISyntaxException {\n        Socket socket = new Socket(uri.getHost(), uri.getPort());\n        try {\n            assert socket.isConnected();\n            java.io.OutputStream outputStream = socket.getOutputStream();\n            long bytesSent = 0;\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n                bytesSent += bytesRead;\n            }\n            outputStream.flush();\n            parser.start();\n            // Assume progress is tracked and verified here\n            parser.stop();\n            return bytesSent;\n        } finally {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            if (buffer[0] == 4) { // EOT character\n                break;\n            }\n            destination.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void close() {\n        try {\n            if (outputStream != null) outputStream.close();\n            if (inputStream != null) inputStream.close();\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            // Suppress exceptions during closure\n        }\n    }\n}"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import com.netflix.eureka.EurekaClient;\nimport java.io.*;\nimport java.net.*;\nimport java.util.Date;\n\npublic void connectToService(EurekaClient eurekaClient) {\n    try {\n        String serviceId = \"sampleservice.mydomain.net\";\n        String instance = eurekaClient.getInstances(serviceId).get(0).getInstanceId();\n        String host = instance.split(\"\\\\.\")[0];\n        int port = 8080; // Assuming the service runs on port 8080\n\n        Socket socket = new Socket(host, port);\n        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        String request = \"GET / HTTP/1.1\\r\\n\" +\n                         \"Host: \" + host + \"\\r\\n\" +\n                         \"User-Agent: Java Client\\r\\n\" +\n                         \"Connection: close\\r\\n\\r\\n\" +\n                         \"Timestamp: \" + new Date().getTime();\n\n        out.println(request);\n        String response = in.readLine();\n\n        System.out.println(\"Server Response:\");\n        System.out.println(response);\n\n        socket.close();\n    } catch (Exception e) {\n        System.err.println(\"Error connecting to service: \" + e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) throws IOException {\n        try (Socket client = new Socket(host, port);\n             PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n             BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {\n\n            out.println(command);\n            return response(client);\n        }\n    }\n\n    public String response(Socket client) throws IOException {\n        StringBuilder response = new StringBuilder();\n        BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        String line;\n\n        while ((line = in.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n\n        return response.toString();\n    }\n\n    public void cleanup(Closeable c) {\n        try {\n            if (c != null) {\n                c.close();\n            }\n        } catch (IOException e) {\n            // Handle silently\n        }\n    }\n}"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.logging.Logger;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final AndroidTestTaskBootThread androidTestTaskBootThread;\n    private final Session session;\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024; // 10MB\n    private static final int READ_BUFFER_SIZE = 5 * 1024; // 5KB\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.log = Logger.getLogger(ScrcpyInputSocketThread.class.getName());\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.androidTestTaskBootThread = androidTestTaskBootThread;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        try {\n            // Set up port forwarding for scrcpy\n            iDevice.forwardPort(3869);\n\n            // Establish socket connection to localhost\n            Socket socket = new Socket(\"localhost\", 3869);\n            OutputStream outputStream = socket.getOutputStream();\n            InputStream inputStream = socket.getInputStream();\n\n            // Send device screen dimensions via WebSocket\n            int width = iDevice.getScreenWidth();\n            int height = iDevice.getScreenHeight();\n            session.sendText(String.format(\"screen: %d x %d\", width, height));\n\n            byte[] readBuffer = new byte[READ_BUFFER_SIZE];\n            int bytesRead;\n\n            while ((bytesRead = inputStream.read(readBuffer)) != -1) {\n                byte[] data = new byte[bytesRead];\n                System.arraycopy(readBuffer, 0, data, 0, bytesRead);\n\n                // Process NAL units and packetization\n                processNALUnits(data);\n\n                // Add processed data to the queue\n                dataQueue.put(data);\n            }\n        } catch (IOException | InterruptedException e) {\n            log.severe(\"Error in ScrcpyInputSocketThread: \" + e.getMessage());\n        } finally {\n            // Close sockets and streams\n            try {\n                if (socket != null) socket.close();\n                if (outputStream != null) outputStream.close();\n                if (inputStream != null) inputStream.close();\n            } catch (IOException e) {\n                log.severe(\"Error closing resources: \" + e.getMessage());\n            }\n\n            // Remove port forwarding\n            iDevice.removePortForwarding(3869);\n\n            // Clean up session references\n            session.close();\n\n            // Interrupt related threads\n            scrcpyLocalThread.interrupt();\n            androidTestTaskBootThread.interrupt();\n        }\n    }\n\n    private void processNALUnits(byte[] data) {\n        // Implement NAL unit detection and packetization logic here\n        // This is a placeholder for actual processing code\n    }\n}"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class HTTPRequest extends HTTPPacket {\n    private Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        try {\n            postSocket = new Socket(host, port);\n            if (isKeepAlive) {\n                postSocket.setSoTimeout(0);\n            } else {\n                postSocket.setSoTimeout(10000);\n            }\n\n            OutputStream out = postSocket.getOutputStream();\n            PrintWriter writer = new PrintWriter(out, true);\n            writer.println(\"POST / HTTP/1.1\");\n            writer.println(\"Host: \" + host);\n            writer.println(\"Connection: \" + (isKeepAlive ? \"keep-alive\" : \"close\"));\n            writer.println();\n            writer.flush();\n\n            InputStream in = postSocket.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            StringBuilder responseBuilder = new StringBuilder();\n\n            while ((line = reader.readLine()) != null) {\n                if (line.isEmpty()) {\n                    break;\n                }\n                responseBuilder.append(line).append(\"\\r\\n\");\n            }\n\n            String response = responseBuilder.toString();\n            return new HTTPResponse(response);\n        } finally {\n            if (postSocket != null) {\n                postSocket.close();\n            }\n        }\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n}"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n            System.out.println(\"Connected to server.\");\n            while (true) {\n                String response = mBufferedReader.readLine();\n                if (response != null) {\n                    System.out.println(\"Server: \" + response);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null && mClientSocket != null && !mClientSocket.isClosed()) {\n            mPrintWriter.println(msg);\n            mPrintWriter.flush();\n        }\n    }\n\n    public void closeConnection() {\n        if (mPrintWriter != null) {\n            mPrintWriter.close();\n        }\n        if (mBufferedReader != null) {\n            try {\n                mBufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (mClientSocket != null) {\n            try {\n                mClientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class Networker {\n    private static Networker sInstance;\n    private final ExecutorService sExecutor;\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    private Networker() {\n        sExecutor = Executors.newFixedThreadPool(4);\n    }\n\n    public static Networker get() {\n        if (sInstance == null) {\n            sInstance = new Networker();\n        }\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest request;\n        private final Callback callback;\n\n        public HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                callback.onResponse(response);\n            } catch (IOException e) {\n                callback.onFailure(e);\n            }\n        }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n        HttpURLConnection connection = configureAndConnectRequest();\n        try {\n            requestDecompression(connection);\n            InputStream inputStream = applyDecompressionIfApplicable(connection, connection.getInputStream());\n            byte[] body = readStream(inputStream);\n            return new HttpResponse(connection.getResponseCode(), body);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(request.getUrl()).openConnection();\n        connection.setRequestMethod(request.getMethod());\n        connection.setReadTimeout(READ_TIMEOUT_MS);\n        connection.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        connection.setDoOutput(true);\n        connection.setDoInput(true);\n        connection.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        connection.connect();\n        return connection;\n    }\n\n    private void requestDecompression(HttpURLConnection conn) {\n        conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n    }\n\n    private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n        if (conn.getContentEncoding() != null && conn.getContentEncoding().contains(GZIP_ENCODING)) {\n            return new GZIPInputStream(in);\n        }\n        return in;\n    }\n\n    private byte[] readStream(InputStream in) throws IOException {\n        byte[] buf = new byte[1024];\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        int len;\n        while ((len = in.read(buf)) != -1) {\n            out.write(buf, 0, len);\n        }\n        return out.toByteArray();\n    }\n\n    public static class HttpRequest {\n        private String url;\n        private String method;\n        private byte[] body;\n        private String friendlyName;\n\n        public HttpRequest(Builder b) {\n            this.url = b.url;\n            this.method = b.method;\n            this.body = b.body;\n            this.friendlyName = b.friendlyName;\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public String getMethod() {\n            return method;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n\n        public String getFriendlyName() {\n            return friendlyName;\n        }\n    }\n\n    public static class Builder {\n        private String url;\n        private String method;\n        private byte[] body;\n        private String friendlyName;\n\n        public Builder() {\n        }\n\n        public Builder friendlyName(String friendlyName) {\n            this.friendlyName = friendlyName;\n            return this;\n        }\n\n        public Builder method(String method) {\n            this.method = method;\n            return this;\n        }\n\n        public Builder url(String url) {\n            this.url = url;\n            return this;\n        }\n\n        public Builder body(byte[] body) {\n            this.body = body;\n            return this;\n        }\n\n        public HttpRequest build() {\n            return new HttpRequest(this);\n        }\n    }\n\n    public static class Builder {\n        public Builder() {\n        }\n\n        public Builder friendlyName(String friendlyName) {\n            return new Builder().friendlyName(friendlyName);\n        }\n\n        public Builder method(String method) {\n            return new Builder().method(method);\n        }\n\n        public Builder url(String url) {\n            return new Builder().url(url);\n        }\n\n        public Builder body(byte[] body) {\n            return new Builder().body(body);\n        }\n\n        public HttpRequest build() {\n            return new HttpRequest(this);\n        }\n    }\n\n    public static class HttpResponse {\n        private int statusCode;\n        private byte[] body;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n        void onFailure(IOException e);\n    }\n}"
  },
  {
    "Task_id": 580,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data, and receives a response.\n\nFunction Description: The function `showText` establishes a TCP connection to a specified server using the provided IP address and port. It sends a sequence of bytes (`seq`) to the server and reads the response. The response is parsed into a `BxResp` object. The function handles connection timeouts and IO exceptions.\n\nInput:\n- `ip`: [String] - The IP address of the server to connect to.\n- `port`: [Integer] - The port number of the server to connect to.\n- `contents`: [List<String>] - A list of strings representing the data to be sent (Note: The reference code uses `seq` for sending data, but `contents` is not directly used in the provided snippet. Clarification may be needed on how `contents` maps to `seq`).\n\nOutput:\n- The function does not explicitly return a value but processes the server's response into a `BxResp` object. If an error occurs, it prints the stack trace.\n\nNote: The reference code snippet references a variable `seq` that is not defined in the provided code. Ensure `seq` is properly initialized from `contents` or another source before calling `out.write(seq)`.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\npublic static void showText(String ip, Integer port, List<String> contents) throws Exception {\n    // Create Socket\n    Socket client = new Socket();\n    // Create socket address\n    SocketAddress address = new InetSocketAddress(ip, port);\n    \n    try {\n        // Establish TCP connection\n        client.connect(address, 3000);\n        // Set read timeout\n        client.setSoTimeout(3000);\n        \n        // Create output stream\n        OutputStream out = client.getOutputStream();\n        // Create input stream\n        InputStream in = client.getInputStream();\n        \n        // Write data\n        out.write(seq);\n        \n        // Read response\n        byte[] resp = new byte[1024];\n        int len = in.read(resp);\n        \n        // Parse response\n        BxResp bxResp = BxResp.parse(resp, len);\n        \n        // Close resources\n        out.close();\n        in.close();\n        client.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.List;\n\npublic class TcpClient {\n    public void showText(String ip, int port, List<String> contents) {\n        try (Socket socket = new Socket()) {\n            socket.connect(new InetSocketAddress(ip, port), 5000);\n            OutputStream out = socket.getOutputStream();\n            InputStream in = socket.getInputStream();\n\n            byte[] seq = contents.get(0).getBytes(); // Assuming first string is the sequence to send\n            out.write(seq);\n            out.flush();\n\n            byte[] responseBytes = new byte[1024];\n            int bytesRead = in.read(responseBytes);\n            if (bytesRead > 0) {\n                String response = new String(responseBytes, 0, bytesRead);\n                // Parse response into BxResp object (assuming a simple parsing for demonstration)\n                BxResp bxResp = new BxResp(response);\n                // Process bxResp as needed\n            }\n        } catch (SocketTimeoutException e) {\n            System.err.println(\"Connection timeout: \" + e.getMessage());\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.err.println(\"IO error: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    // Placeholder for BxResp class\n    static class BxResp {\n        private String response;\n\n        public BxResp(String response) {\n            this.response = response;\n        }\n\n        // Add methods to process the response as needed\n    }\n}"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    InetSocketAddress local;\n    InetSocketAddress remote;\n    Socket sock;\n    DataOutputStream output;\n    Lock output_lock;\n    ServerSocket srv_sock;\n    Thread acceptor;\n\n    public UnicastTestTcpSlow() {\n        output_lock = new ReentrantLock();\n    }\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws IOException {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Thread(new Acceptor());\n        acceptor.start();\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received message: \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        Message msg = new Message();\n        msg.setType(new String(buf, offset, length));\n        return msg;\n    }\n\n    private class Acceptor implements Runnable {\n        public void run() {\n            try {\n                while (true) {\n                    Socket client = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(client.getInputStream());\n                    handleRequest(in);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void handleRequest(DataInputStream in) {\n            try {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) > 0) {\n                    Message msg = readMessage(buffer, 0, bytesRead);\n                    receive(msg);\n                }\n            } catch (IOException | ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass Message {\n    private String type;\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n}\n```"
  },
  {
    "Task_id": 583,
    "Instruction": "Task Description: Create a Java class that handles network forwarding for both TCP and UDP protocols, managing connections and data transmission between clients and servers.\n\nClass Description: The NetworkForwarder class is responsible for forwarding network data to a specified destination server using either TCP or UDP protocols. It maintains UDP connections through a DatagramSocket and manages multiple TCP connections using a mapping of source addresses to Socket instances. The class provides methods for forwarding data and disconnecting specific TCP connections.\n\nAttributes:\n- LOGGER: Logger - Used for logging warnings and errors\n- destination: InetAddress - The destination address for forwarded data\n- connectionUdp: DatagramSocket - The UDP socket used for datagram communication\n- connectionsTcp: Map<InetSocketAddress, Socket> - A mapping of source addresses to their corresponding TCP Socket connections\n\nMethods:\n- NetworkForwarder(Config config) -> void - Constructor that initializes the destination address and UDP socket using configuration parameters\n- forward(InetSocketAddress source, int port, boolean datagram, byte[] data) -> void - Forwards data to the destination server using either TCP or UDP protocol based on the datagram parameter\n- disconnect(InetSocketAddress source) -> void - Closes and removes the TCP connection associated with the specified source address",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport jakarta.inject.Inject;\nimport jakarta.inject.Singleton;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Singleton\npublic class NetworkForwarder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NetworkForwarder.class);\n\n    private final InetAddress destination;\n    private final DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp = new HashMap<>();\n\n    @Inject\n    public NetworkForwarder(Config config) throws IOException {\n        destination = InetAddress.getByName(config.getString(Keys.SERVER_FORWARD));\n        connectionUdp = new DatagramSocket();\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        try {\n            if (datagram) {\n                connectionUdp.send(new DatagramPacket(data, data.length, destination, port));\n            } else {\n                Socket connectionTcp = connectionsTcp.get(source);\n                if (connectionTcp == null || connectionTcp.isClosed()) {\n                    connectionTcp = new Socket(destination, port);\n                    connectionsTcp.put(source, connectionTcp);\n                }\n                connectionTcp.getOutputStream().write(data);\n            }\n        } catch (IOException e) {\n            LOGGER.warn(\"Network forwarding error\", e);\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket connectionTcp = connectionsTcp.remove(source);\n        if (connectionTcp != null) {\n            try {\n                connectionTcp.close();\n            } catch (IOException e) {\n                LOGGER.warn(\"Connection close error\", e);\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.net.*;\nimport java.util.*;\n\npublic class NetworkForwarder {\n    private final Logger LOGGER;\n    private final InetAddress destination;\n    private DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp;\n\n    public NetworkForwarder(Config config) {\n        this.LOGGER = Logger.getLogger(NetworkForwarder.class.getName());\n        this.destination = InetAddress.getByName(config.getDestination());\n        try {\n            this.connectionUdp = new DatagramSocket();\n        } catch (SocketException e) {\n            LOGGER.severe(\"Failed to create UDP socket: \" + e.getMessage());\n        }\n        this.connectionsTcp = new HashMap<>();\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        if (datagram) {\n            try {\n                DatagramPacket packet = new DatagramPacket(data, data.length, destination, port);\n                connectionUdp.send(packet);\n            } catch (IOException e) {\n                LOGGER.warning(\"UDP forwarding failed: \" + e.getMessage());\n            }\n        } else {\n            Socket socket = connectionsTcp.get(source);\n            if (socket != null && socket.isConnected()) {\n                try {\n                    OutputStream out = socket.getOutputStream();\n                    out.write(data);\n                    out.flush();\n                } catch (IOException e) {\n                    LOGGER.warning(\"TCP forwarding failed: \" + e.getMessage());\n                }\n            } else {\n                LOGGER.warning(\"TCP connection not established for source: \" + source);\n            }\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket socket = connectionsTcp.remove(source);\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                LOGGER.warning(\"Failed to close TCP connection: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 585,
    "Instruction": "Task Description: Create a class that handles both Bluetooth and TCP socket communication for a Pebble device, allowing data transmission and reception through either protocol based on the device address format.\n\nClass Description: The PebbleIoThread class manages connections and data transfer to a Pebble device using either Bluetooth or TCP sockets. It automatically detects the protocol based on the device address format (TCP if address contains one colon, Bluetooth if multiple colons).\n\nAttributes:\n- mIsTCP: [boolean] - Flag indicating whether TCP mode is active\n- mBtAdapter: [BluetoothAdapter] - Android Bluetooth adapter instance\n- mBtSocket: [BluetoothSocket] - Bluetooth socket for communication\n- mTCPSocket: [Socket] - TCP socket for communication\n- mInStream: [InputStream] - Input stream for receiving data\n- mOutStream: [OutputStream] - Output stream for sending data\n- mContext: [Context] - Android application context\n- gbDevice: [GBDevice] - Device information object\n\nMethods:\n- connect(): [boolean] - Establishes connection with the device (returns true if successful)\n  Input: None\n  Output: boolean - Connection success status\n  \n- write_real(byte[] bytes): [void] - Sends data to the connected device with protocol-specific framing\n  Input: byte[] - Data bytes to send\n  Output: None\n  \n- quit(): [void] - Closes all active connections and releases resources\n  Input: None\n  Output: None",
    "Canonical_solution": "import android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothSocket;\nimport android.content.Context;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.UUID;\n\nclass PebbleIoThread {\n\n    private boolean mIsTCP = false;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    PebbleIoThread(Context context, GBDevice device, BluetoothAdapter btAdapter) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = btAdapter;\n    }\n\n    protected boolean connect() {\n        String deviceAddress = gbDevice.getAddress();\n        try {\n            int firstColon = deviceAddress.indexOf(\":\");\n            if (firstColon == deviceAddress.lastIndexOf(\":\")) {\n                mIsTCP = true;\n                InetAddress serverAddr = InetAddress.getByName(deviceAddress.substring(0, firstColon));\n                mTCPSocket = new Socket(serverAddr, Integer.parseInt(deviceAddress.substring(firstColon + 1)));\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } else {\n                mIsTCP = false;\n                BluetoothDevice btDevice = mBtAdapter.getRemoteDevice(deviceAddress);\n                final UUID UuidSDP = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\");\n                mBtSocket = btDevice.createRfcommSocketToServiceRecord(UuidSDP);\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            }\n            return true;\n        } catch (IOException e) {\n            mInStream = null;\n            mOutStream = null;\n            mBtSocket = null;\n            return false;\n        }\n    }\n\n    private void write_real(byte[] bytes) {\n        try {\n            if (mIsTCP) {\n                ByteBuffer buf = ByteBuffer.allocate(bytes.length + 8);\n                buf.order(ByteOrder.BIG_ENDIAN);\n                buf.putShort((short) 0xfeed);\n                buf.putShort((short) 1);\n                buf.putShort((short) bytes.length);\n                buf.put(bytes);\n                buf.putShort((short) 0xbeef);\n                mOutStream.write(buf.array());\n                mOutStream.flush();\n            } else {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            }\n        } catch (IOException e) {\n            // Error handling\n        }\n    }\n\n    public void quit() {\n        if (mBtSocket != null) {\n            try {\n                mBtSocket.close();\n            } catch (IOException ignored) {\n            }\n            mBtSocket = null;\n        }\n        if (mTCPSocket != null) {\n            try {\n                mTCPSocket.close();\n            } catch (IOException ignored) {\n            }\n            mTCPSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class PebbleIoThread implements Runnable {\n    private boolean mIsTCP;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    public PebbleIoThread(Context context, GBDevice device) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = BluetoothAdapter.getDefaultAdapter();\n        String deviceAddress = device.getAddress();\n        mIsTCP = deviceAddress.contains(\":\");\n    }\n\n    public boolean connect() {\n        if (mIsTCP) {\n            try {\n                InetAddress address = InetAddress.getByName(gbDevice.getAddress());\n                mTCPSocket = new Socket(address, 5321);\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n                return true;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            try {\n                BluetoothDevice device = mBtAdapter.getRemoteDevice(gbDevice.getAddress());\n                mBtSocket = device.createInsecureRfcommChannel(1);\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n                return true;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return false;\n            }\n        }\n    }\n\n    public void write_real(byte[] bytes) {\n        try {\n            mOutStream.write(bytes);\n            mOutStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void quit() {\n        try {\n            if (mTCPSocket != null) {\n                mTCPSocket.close();\n            } else if (mBtSocket != null) {\n                mBtSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        // Main loop for communication\n    }\n}"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class QmpClient {\n    public static final String TAG = \"QMPClient\";\n    private boolean external;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void setExternal(boolean value) {\n        this.external = value;\n    }\n\n    public String sendCommand(String command) throws Exception {\n        String response = tryGetResponse(in);\n        sendRequest(out, command);\n        return response;\n    }\n\n    private String tryGetResponse(BufferedReader in) throws Exception {\n        String response = getResponse(in);\n        if (response == null || response.isEmpty()) {\n            Thread.sleep(100);\n            response = tryGetResponse(in);\n        }\n        return response;\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n        out.flush();\n    }\n\n    private String getResponse(BufferedReader in) throws Exception {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            if (line.trim().isEmpty()) {\n                continue;\n            }\n            response.append(line).append(\"\\n\");\n            if (line.contains(\"}\") || line.contains(\"]\")) {\n                break;\n            }\n        }\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    InetSocketAddress local;\n    InetSocketAddress remote;\n    Socket sock;\n    DataOutputStream output;\n    Lock output_lock;\n    ServerSocket srv_sock;\n    Thread acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Thread(new Acceptor());\n        acceptor.start();\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws Exception {\n        try {\n            out.writeUTF(msg.getType());\n            out.writeInt(msg.getLength());\n            out.write(msg.getData(), 0, msg.getLength());\n        } catch (IOException e) {\n            throw new Exception(\"Error writing message: \" + e.getMessage(), e);\n        }\n    }\n\n    public static Message readMessage(DataInput in) throws Exception {\n        try {\n            String type = in.readUTF();\n            int length = in.readInt();\n            byte[] data = new byte[length];\n            in.readFully(data);\n            return new Message(type, data);\n        } catch (IOException e) {\n            throw new Exception(\"Error reading message: \" + e.getMessage(), e);\n        }\n    }\n\n    public void receive(Message msg) {\n        if (msg.getType().equals(\"START\")) {\n            System.out.println(\"Received START message\");\n        } else if (msg.getType().equals(\"DATA\")) {\n            System.out.println(\"Received DATA message: \" + new String(msg.getData()));\n        }\n    }\n\n    private class Acceptor implements Runnable {\n        public void run() {\n            while (true) {\n                try {\n                    Socket client = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(client.getInputStream());\n                    handleRequest(in);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        public void handleRequest(DataInputStream in) throws Exception {\n            while (true) {\n                Message msg = readMessage(in);\n                receive(msg);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.Charset;\n\npublic class UrlTemplateResource {\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws Exception {\n        return new InputStreamReader(inputStream(), characterEncoding);\n    }\n\n    private InputStream inputStream() throws Exception {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        return connection.getInputStream();\n    }\n\n    public boolean exists() throws Exception {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            int responseCode = connection.getResponseCode();\n            return responseCode == 200 || responseCode == 302 || responseCode == 301;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public void testServletInputStreamEarlyClose() throws Exception {\n    DefaultServer server = new DefaultServer();\n    server.start();\n    try (TestHttpClient client = new TestHttpClient()) {\n        client.connect(server.getPort());\n        client.sendPostRequest(\"/early-close\", \"A\".repeat(1024 * 1024)); // Send a large body\n        client.close(); // Close the socket before the server finishes processing\n    }\n    server.stop();\n    assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n}"
  },
  {
    "Task_id": 598,
    "Instruction": "Task Description: Create a Java class that implements a StatsD client using UDP protocol for sending metrics to a StatsD server. The class should handle metric batching and asynchronous sending to avoid blocking the main application thread.\n\nClass Description: The Statsd class is a singleton that provides asynchronous metric sending capability to a StatsD server via UDP. It uses a background thread to batch metrics and send them efficiently. The class handles connection setup, error cases, and metric aggregation.\n\nAttributes:\n- CHARSET: [Charset] - The character encoding used for sending metrics (US_ASCII)\n- e: [ExecutorService] - Single thread executor for asynchronous metric processing\n- qManager: [Implicit Queue Manager] - Manages the queue of metrics to be sent (implied by usage but not shown in attributes)\n\nMethods:\n- getInstance(): () -> [Statsd] - Returns the singleton instance of the StatsD client\n- <constructor>: () -> [Statsd] - Private constructor that initializes the background thread for metric processing\n- <background thread>: () -> [void] - Internal method that continuously processes metrics from the queue, batches them, and sends to the StatsD server via UDP\n\nNote: The actual queue management implementation (qManager) is not shown in the provided code but is implied by the usage of getQ() and drainTo() methods. The class handles UDP socket creation, packet preparation, and error cases for host resolution and socket operations.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.openjdk.btrace.core.BTraceRuntime;\nimport org.openjdk.btrace.core.SharedSettings;\n\npublic final class Statsd {\n  private static final Charset CHARSET = StandardCharsets.US_ASCII;\n  private final ExecutorService e = Executors.newSingleThreadExecutor(\n      r -> {\n        Thread t = new Thread(r, \"jStatsD Client Submitter\");\n        t.setDaemon(true);\n        return t;\n      });\n\n  @SuppressWarnings(\"FutureReturnValueIgnored\")\n  private Statsd() {\n    e.submit(\n        () -> {\n          DatagramSocket ds = null;\n          boolean entered = BTraceRuntime.enter();\n          try {\n            ds = new DatagramSocket();\n            DatagramPacket dp = new DatagramPacket(new byte[0], 0);\n            try {\n              dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));\n            } catch (UnknownHostException ex) {\n              System.err.println(\n                  \"[statsd] invalid host defined: \" + SharedSettings.GLOBAL.getStatsdHost());\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            } catch (SecurityException ex) {\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            }\n            dp.setPort(SharedSettings.GLOBAL.getStatsdPort());\n\n            while (true) {\n              Collection<String> msgs = new ArrayList<>();\n              msgs.add(qManager.getQ().take());\n              qManager.getQ().drainTo(msgs);\n\n              StringBuilder sb = new StringBuilder();\n              for (String m : msgs) {\n                if (sb.length() + m.length() < 511) {\n                  sb.append(m).append('\\n');\n                } else {\n                  dp.setData(sb.toString().getBytes(CHARSET));\n                  ds.send(dp);\n                  sb.setLength(0);\n                }\n              }\n              if (sb.length() > 0) {\n                dp.setData(sb.toString().getBytes(CHARSET));\n                ds.send(dp);\n              }\n            }\n          } catch (IOException | InterruptedException ex) {\n            ex.printStackTrace();\n          } finally {\n            if (entered) {\n              BTraceRuntime.leave();\n            }\n          }\n        });\n  }\n\n  public static Statsd getInstance() {\n    return Singleton.INSTANCE;\n  }\n\n  private static final class Singleton {\n    private static final Statsd INSTANCE = new Statsd();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "import java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.nio.charset.StandardCharsets;\n\npublic class Statsd {\n    private static final Charset CHARSET = StandardCharsets.US_ASCII;\n    private static final ExecutorService e = Executors.newSingleThreadExecutor();\n    private static Statsd instance;\n\n    private Statsd() {\n        e.execute(this::backgroundThread);\n    }\n\n    public static Statsd getInstance() {\n        if (instance == null) {\n            instance = new Statsd();\n        }\n        return instance;\n    }\n\n    private void backgroundThread() {\n        while (true) {\n            try {\n                Metrics[] metrics = getQ().drainTo(new ArrayList<>(100));\n                if (metrics.length > 0) {\n                    sendMetrics(metrics);\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private void sendMetrics(Metrics[] metrics) throws SocketException {\n        InetAddress address = InetAddress.getByName(\"localhost\");\n        int port = 8125;\n        byte[] buffer = new byte[512];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        for (Metrics metric : metrics) {\n            String data = metric.getName() + \":\" + metric.getValue() + \" | \" + metric.getType();\n            buffer = data.getBytes(CHARSET);\n            packet.setData(buffer);\n            packet.setAddress(address);\n            packet.getPort(port);\n            socket.send(packet);\n        }\n    }\n\n    private Queue getQ() {\n        // Queue management implementation is not shown\n        return new LinkedList<>();\n    }\n\n    private DatagramSocket socket;\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Date;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter;\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.boundary = \"----\" + new Date().getTime() + \"----\";\n        this.delimiter = \"--\";\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        try (OutputStream os = con.getOutputStream()) {\n            String formData = \"imgName=\" + java.net.URLEncoder.encode(imgName, \"UTF-8\");\n            os.write(formData.getBytes());\n        }\n\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (ByteArrayOutputStream responseStream = new ByteArrayOutputStream()) {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = con.getInputStream().read(buffer)) != -1) {\n                    responseStream.write(buffer, 0, bytesRead);\n                }\n                return responseStream.toByteArray();\n            }\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    public void connectForMultipart() throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n        os.write(delimiter.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        writeParamData(paramName, \"file\");\n        os.write(\"\\r\\n\".getBytes());\n        os.write(fileName.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(delimiter.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n        os.write(delimiter.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write(\"\\r\\n\".getBytes());\n        os.write(delimiter.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws IOException {\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (ByteArrayOutputStream responseStream = new ByteArrayOutputStream()) {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = con.getInputStream().read(buffer)) != -1) {\n                    responseStream.write(buffer, 0, bytesRead);\n                }\n                return responseStream.toString();\n            }\n        } else {\n            throw new IOException(\"HTTP error code: \" + responseCode);\n        }\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((delimiter + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain; charset=UTF-8\\r\\n\\r\\n\".getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n}"
  },
  {
    "Task_id": 602,
    "Instruction": "Task Description: Create a UDP server class that listens for incoming packets on a specified port, processes the received data, and provides a method to retrieve the received message.\n\nClass Description: The UdpServer class implements a Runnable interface to handle UDP communication asynchronously. It creates a datagram socket bound to a specified port, receives incoming packets, stores the message content, and allows retrieval of the received message. The server operates with a timeout of 60 seconds.\n\nAttributes:\n- serverSocket: DatagramSocket - The UDP socket used for communication\n- message: String - Stores the received message from the client\n\nMethods:\n- UdpServer(int port) -> void - Constructor that initializes the UDP server on the specified port and starts the receiver thread\n- run() -> void - The thread's main execution method that receives incoming packets and processes the data\n- getMessage() -> String - Retrieves the received message after processing",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UdpServer implements Runnable {\n\n    private final DatagramSocket serverSocket;\n    private String message;\n\n    public UdpServer(int port) throws SocketException, InterruptedException {\n        serverSocket = new DatagramSocket(port);\n        serverSocket.setSoTimeout(60000);\n        final Thread thread = new Thread(this);\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        final byte[] data = new byte[1024];\n        final DatagramPacket packet = new DatagramPacket(data, data.length);\n        try {\n            serverSocket.receive(packet);\n            message = new String(packet.getData()).trim();\n        } catch (IOException e) {\n            message = \"Exception while receiving sentry call. \" + e.getMessage();\n        }\n    }\n\n    public synchronized String getMessage() throws InterruptedException {\n        return message;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UdpServer implements Runnable {\n    private DatagramSocket serverSocket;\n    private String message;\n    private static final int TIMEOUT = 60000; // 60 seconds\n\n    public UdpServer(int port) throws Exception {\n        this.serverSocket = new DatagramSocket(port);\n        new Thread(this).start();\n    }\n\n    @Override\n    public void run() {\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n\n        while (true) {\n            try {\n                serverSocket.setSoTimeout(TIMEOUT);\n                serverSocket.receive(packet);\n                message = new String(packet.getData(), 0, packet.getLength());\n                packet.reset();\n            } catch (SocketTimeoutException e) {\n                System.out.println(\"No message received within timeout period.\");\n                break;\n            } catch (IOException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "import socket\n\ndef udp_client():\n    # Create a UDP socket\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    \n    # Define the server address and port\n    server_address = ('localhost', 9876)\n    \n    # Send the message to the server\n    message = b'hello world'\n    sock.sendto(message, server_address)\n    \n    # Wait for a response from the server\n    data, server = sock.recvfrom(1024)\n    \n    # Print the server's response\n    print(f\"Server reply: {data.decode()}\")\n    \n    # Close the connection\n    sock.close()"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n    private int responseCode;\n    private String output;\n\n    public static class Error {\n        public int responseCode;\n        public String output;\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n\n    public static String post(String request, String body) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(\"utf-8\");\n            os.write(input);\n            os.flush();\n        }\n        return handleResponse(connection, null);\n    }\n\n    public static String post(String request) throws IOException {\n        return post(request, \"\");\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        return handleResponse(connection, callback);\n    }\n\n    public static String get(String request) throws IOException {\n        return get(request, null, 5000);\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws IOException {\n        if (connection.getResponseCode() >= 400) {\n            throw new IOException(\"HTTP error code: \" + connection.getResponseCode());\n        }\n        responseCode = connection.getResponseCode();\n        output = \"\";\n        try (InputStream is = connection.getInputStream();\n             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output += line;\n                if (callback != null) {\n                    callback.readLine(line);\n                }\n            }\n        }\n        return output;\n    }\n\n    public Error getError() {\n        return new Error();\n    }\n\n    @Override\n    public String toString() {\n        return \"HttpUtils{\" +\n                \"responseCode=\" + responseCode +\n                \", output='\" + output + '\\'' +\n                '}';\n    }\n}"
  },
  {
    "Task_id": 610,
    "Instruction": "Task Description: Implement a UDP-based tracker client for peer-to-peer file sharing systems that can connect to a tracker server, maintain connection state, and handle announce requests and responses.\n\nClass Description: UDPTrackerClient is a specialized tracker client that communicates with BitTorrent trackers using UDP protocol. It handles connection establishment, announcement of peer information, and manages timeouts and retries for reliable communication.\n\nAttributes:\n- logger: Logger - Logger instance for tracking client activities\n- UDP_BASE_TIMEOUT_SECONDS: int - Base timeout value for UDP communication\n- UDP_MAX_TRIES: int - Maximum number of retry attempts\n- UDP_MAX_TRIES_ON_STOPPED: int - Maximum retries for STOPPED events\n- UDP_PACKET_LENGTH: int - Maximum UDP packet size\n- address: InetSocketAddress - Tracker server address\n- random: Random - Random number generator for transaction IDs\n- socket: DatagramSocket - UDP communication socket\n- connectionExpiration: Date - When the current connection expires\n- connectionId: long - Current connection identifier\n- transactionId: int - Current transaction identifier\n- stop: boolean - Flag to indicate if client should stop operations\n\nMethods:\n- UDPTrackerClient(List<Peer> peers, URI tracker) -> void - Constructor that initializes the client with peer list and tracker URI\n- announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) -> void - Main method to announce peer information to tracker\n- handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) -> void - Processes announce responses from tracker\n- close() -> void - Closes the client and releases resources\n- buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) -> UDPAnnounceRequestMessage - Constructs announce request message\n- validateTrackerResponse(TrackerMessage message) -> void - Validates tracker response messages\n- handleTrackerConnectResponse(TrackerMessage message) -> void - Processes connection responses from tracker\n- send(ByteBuffer data) -> void - Sends data to tracker server\n- recv(int attempt) -> ByteBuffer - Receives data from tracker server with timeout handling",
    "Canonical_solution": "import com.turn.ttorrent.common.AnnounceableInformation;\nimport com.turn.ttorrent.common.Peer;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.common.protocol.AnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;\nimport com.turn.ttorrent.common.protocol.udp.UDPAnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectResponseMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPTrackerMessage;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\n\npublic class UDPTrackerClient extends TrackerClient {\n\n  protected static final Logger logger =\n          TorrentLoggerFactory.getLogger(UDPTrackerClient.class);\n\n  private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n  private static final int UDP_MAX_TRIES = 8;\n  private static final int UDP_MAX_TRIES_ON_STOPPED = 1;\n  private static final int UDP_PACKET_LENGTH = 512;\n\n  private final InetSocketAddress address;\n  private final Random random;\n\n  private DatagramSocket socket;\n  private Date connectionExpiration;\n  private long connectionId;\n  private int transactionId;\n  private boolean stop;\n\n  public UDPTrackerClient(List<Peer> peers, URI tracker)\n          throws UnknownHostException {\n    super(peers, tracker);\n\n    for (Peer peer : peers) {\n      if (!(InetAddress.getByName(peer.getIp()) instanceof Inet4Address)) {\n        throw new UnsupportedAddressTypeException();\n      }\n    }\n\n    this.address = new InetSocketAddress(\n            tracker.getHost(),\n            tracker.getPort());\n\n    this.socket = null;\n    this.random = new Random();\n    this.connectionExpiration = null;\n    this.stop = false;\n  }\n\n  @Override\n  public void announce(final AnnounceRequestMessage.RequestEvent event,\n                       boolean inhibitEvents, final AnnounceableInformation torrent, final List<Peer> peers) throws AnnounceException {\n    int maxAttempts = AnnounceRequestMessage.RequestEvent\n            .STOPPED.equals(event)\n            ? UDP_MAX_TRIES_ON_STOPPED\n            : UDP_MAX_TRIES;\n    int attempts = -1;\n\n    try {\n      this.socket = new DatagramSocket();\n      this.socket.connect(this.address);\n\n      while (++attempts <= maxAttempts) {\n        this.transactionId = this.random.nextInt();\n\n        if (this.connectionExpiration != null) {\n          if (new Date().before(this.connectionExpiration)) {\n            for (Peer peer : peers) {\n              this.send(this.buildAnnounceRequest(event, torrent, peer).getData());\n            }\n\n            try {\n              this.handleTrackerAnnounceResponse(\n                      UDPTrackerMessage.UDPTrackerResponseMessage\n                              .parse(this.recv(attempts)), inhibitEvents, torrent.getHexInfoHash());\n              return;\n            } catch (SocketTimeoutException ste) {\n              if (stop) {\n                return;\n              }\n            }\n          }\n        }\n\n        this.send(UDPConnectRequestMessage\n                .craft(this.transactionId).getData());\n\n        try {\n          this.handleTrackerConnectResponse(\n                  UDPTrackerMessage.UDPTrackerResponseMessage\n                          .parse(this.recv(attempts)));\n          attempts = -1;\n        } catch (SocketTimeoutException ste) {\n          if (stop) {\n            return;\n          }\n        }\n      }\n\n      throw new AnnounceException(\"Timeout while announcing\" +\n              this.formatAnnounceEvent(event) + \" to tracker!\");\n    } catch (IOException ioe) {\n      throw new AnnounceException(\"Error while announcing\" +\n              this.formatAnnounceEvent(event) +\n              \" to tracker: \" + ioe.getMessage(), ioe);\n    } catch (MessageValidationException mve) {\n      throw new AnnounceException(\"Tracker message violates expected \" +\n              \"protocol (\" + mve.getMessage() + \")\", mve);\n    }\n  }\n\n  @Override\n  protected void handleTrackerAnnounceResponse(TrackerMessage message,\n                                               boolean inhibitEvents, String hexInfoHash) throws AnnounceException {\n    this.validateTrackerResponse(message);\n    super.handleTrackerAnnounceResponse(message, inhibitEvents, hexInfoHash);\n  }\n\n  @Override\n  protected void close() {\n    this.stop = true;\n    if (this.socket != null && !this.socket.isClosed()) {\n      this.socket.close();\n    }\n  }\n\n  private UDPAnnounceRequestMessage buildAnnounceRequest(\n          final AnnounceRequestMessage.RequestEvent event, final AnnounceableInformation torrent, final Peer peer) {\n    return UDPAnnounceRequestMessage.craft(\n            this.connectionId,\n            transactionId,\n            torrent.getInfoHash(),\n            peer.getPeerIdArray(),\n            torrent.getDownloaded(),\n            torrent.getUploaded(),\n            torrent.getLeft(),\n            event,\n            peer.getAddress().getAddress(),\n            0,\n            AnnounceRequestMessage.DEFAULT_NUM_WANT,\n            peer.getPort());\n  }\n\n  private void validateTrackerResponse(TrackerMessage message)\n          throws AnnounceException {\n    if (message instanceof ErrorMessage) {\n      throw new AnnounceException(((ErrorMessage) message).getReason());\n    }\n\n    if (message instanceof UDPTrackerMessage &&\n            (((UDPTrackerMessage) message).getTransactionId() != this.transactionId)) {\n      throw new AnnounceException(\"Invalid transaction ID!\");\n    }\n  }\n\n  private void handleTrackerConnectResponse(TrackerMessage message)\n          throws AnnounceException {\n    this.validateTrackerResponse(message);\n\n    if (!(message instanceof ConnectionResponseMessage)) {\n      throw new AnnounceException(\"Unexpected tracker message type \" +\n              message.getType().name() + \"!\");\n    }\n\n    UDPConnectResponseMessage connectResponse =\n            (UDPConnectResponseMessage) message;\n\n    this.connectionId = connectResponse.getConnectionId();\n    Calendar now = Calendar.getInstance();\n    now.add(Calendar.MINUTE, 1);\n    this.connectionExpiration = now.getTime();\n  }\n\n  private void send(ByteBuffer data) {\n    try {\n      this.socket.send(new DatagramPacket(\n              data.array(),\n              data.capacity(),\n              this.address));\n    } catch (IOException ioe) {\n      logger.info(\"Error sending datagram packet to tracker at {}: {}.\", this.address, ioe.getMessage());\n    }\n  }\n\n  private ByteBuffer recv(int attempt)\n          throws IOException, SocketException, SocketTimeoutException {\n    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);\n    logger.trace(\"Setting receive timeout to {}s for attempt {}...\",\n            timeout, attempt);\n    this.socket.setSoTimeout(timeout * 1000);\n\n    try {\n      DatagramPacket p = new DatagramPacket(\n              new byte[UDP_PACKET_LENGTH],\n              UDP_PACKET_LENGTH);\n      this.socket.receive(p);\n      return ByteBuffer.wrap(p.getData(), 0, p.getLength());\n    } catch (SocketTimeoutException ste) {\n      throw ste;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "import java.net.*;\nimport java.util.*;\nimport java.io.*;\nimport java.util.logging.Logger;\nimport java.util.concurrent.TimeUnit;\n\npublic class UDPTrackerClient {\n    private final Logger logger;\n    private final int UDP_BASE_TIMEOUT_SECONDS = 5;\n    private final int UDP_MAX_TRIES = 3;\n    private final int UDP_MAX_TRIES_ON_STOPPED = 5;\n    private final int UDP_PACKET_LENGTH = 65507;\n    private InetSocketAddress address;\n    private Random random;\n    private DatagramSocket socket;\n    private Date connectionExpiration;\n    private long connectionId;\n    private int transactionId;\n    private boolean stop;\n\n    public UDPTrackerClient(List<Peer> peers, URI tracker) {\n        logger = Logger.getLogger(UDPTrackerClient.class.getName());\n        try {\n            address = new InetSocketAddress(tracker.getHost(), tracker.getPort());\n            socket = new DatagramSocket();\n            random = new Random();\n            connectionExpiration = new Date();\n            connectionId = random.nextLong();\n            transactionId = random.nextInt();\n            stop = false;\n        } catch (SocketException e) {\n            logger.severe(\"Error creating UDP socket: \" + e.getMessage());\n        }\n    }\n\n    public void announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) {\n        for (Peer peer : peers) {\n            buildAnnounceRequest(event, torrent, peer);\n        }\n    }\n\n    public void handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) {\n        validateTrackerResponse(message);\n        handleTrackerConnectResponse(message);\n    }\n\n    public void close() {\n        stop = true;\n        try {\n            socket.close();\n        } catch (IOException e) {\n            logger.severe(\"Error closing UDP socket: \" + e.getMessage());\n        }\n    }\n\n    private UDPAnnounceRequestMessage buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) {\n        return new UDPAnnounceRequestMessage(event, torrent, peer);\n    }\n\n    private void validateTrackerResponse(TrackerMessage message) {\n        // Implementation for validating tracker response\n    }\n\n    private void handleTrackerConnectResponse(TrackerMessage message) {\n        // Implementation for handling connection response\n    }\n\n    private void send(ByteBuffer data) {\n        try {\n            socket.send(data, address);\n        } catch (IOException e) {\n            logger.severe(\"Error sending UDP packet: \" + e.getMessage());\n        }\n    }\n\n    private ByteBuffer recv(int attempt) {\n        ByteBuffer buffer = ByteBuffer.allocate(UDP_PACKET_LENGTH);\n        try {\n            if (attempt > UDP_MAX_TRIES) {\n                return null;\n            }\n            long timeout = UDP_BASE_TIMEOUT_SECONDS * attempt;\n            long startTime = System.currentTimeMillis();\n            while (true) {\n                if (socket.receive(buffer) == -1) {\n                    if (System.currentTimeMillis() - startTime > timeout * 1000) {\n                        return null;\n                    }\n                } else {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            logger.severe(\"Error receiving UDP packet: \" + e.getMessage());\n        }\n        return buffer;\n    }\n}"
  },
  {
    "Task_id": 613,
    "Instruction": "Task Description: Create a Java class that implements a UDP socket for SNMP communication, capable of sending and receiving datagram packets asynchronously while handling errors and resource cleanup properly.\n\nClass Description: The SnmpSocket class provides UDP socket functionality for SNMP communication, managing packet transmission and reception in a separate thread. It includes methods for sending packets, checking socket validity, and proper resource cleanup. The class implements Runnable to handle incoming packets asynchronously.\n\nAttributes:\n_socket: [DatagramSocket] - The UDP socket instance for communication\n_dgramHdlr: [SnmpResponseHandler] - Handler for processing received datagrams\n_sockThread: [Thread] - Thread for asynchronous packet reception\n_buffer: [byte[]] - Buffer for storing incoming packet data\nisClosing: [boolean] - Flag indicating if the socket is being closed\n_socketPort: [int] - Port number the socket is bound to\nresponseBufSize: [int] - Size of the response buffer\n\nMethods:\nConstructor: [SnmpSocket](SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) -> [void] - Initializes the UDP socket and starts the receiver thread\nsendPacket: [sendPacket](byte[] buff, int length, InetAddress addr, int port) -> [void] - Sends a datagram packet with specified data to given address and port\nsendPacket: [sendPacket](DatagramPacket dgrmpkt) -> [void] - Sends a prepared datagram packet\nisValid: [isValid]() -> [boolean] - Checks if the socket is in a valid state\nclose: [close]() -> [void] - Closes the socket and cleans up resources\nrun: [run]() -> [void] - Main thread method for receiving packets (implements Runnable)\nfinalize: [finalize]() -> [void] - Ensures proper cleanup when object is garbage collected\nhandleJavaError: [handleJavaError](Throwable thr) -> [void] - Handles Java errors during operation\nhandleDatagram: [handleDatagram](DatagramPacket dgrmpkt) -> [void] - Processes received datagrams using the response handler",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.io.IOException;\nimport java.util.logging.Level;\n\nfinal class SnmpSocket implements java.lang.Runnable {\n\n    private DatagramSocket _socket = null;\n    private SnmpResponseHandler _dgramHdlr = null;\n    private Thread _sockThread = null;\n    private byte[] _buffer = null;\n    private transient boolean isClosing = false;\n\n    int _socketPort = 0;\n    int responseBufSize = 1024;\n\n    public SnmpSocket(SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) throws SocketException {\n        _socket = new DatagramSocket(0, addr);\n        _socketPort = _socket.getLocalPort();\n        responseBufSize = bufferSize;\n        _buffer = new byte[responseBufSize];\n        _dgramHdlr = rspHdlr;\n        _sockThread = new Thread(this, \"SnmpSocket\");\n        _sockThread.start();\n    }\n\n    public synchronized void sendPacket(byte[] buff, int length, InetAddress addr, int port) throws IOException {\n        DatagramPacket dgrmpkt = new DatagramPacket(buff, length, addr, port);\n        sendPacket(dgrmpkt);\n    }\n\n    public synchronized void sendPacket(DatagramPacket dgrmpkt) throws IOException {\n        if (isValid()) {\n            _socket.send(dgrmpkt);\n        } else {\n            throw new IOException(\"Invalid state of SNMP datagram socket.\");\n        }\n    }\n\n    public synchronized boolean isValid() {\n        return _socket != null && _sockThread != null && _sockThread.isAlive();\n    }\n\n    public synchronized void close() {\n        isClosing = true;\n        if (_socket != null) {\n            _socket.close();\n            _socket = null;\n        }\n        if (_sockThread != null && _sockThread.isAlive()) {\n            _sockThread.interrupt();\n            try {\n                _sockThread.join();\n            } catch (InterruptedException e) {\n            }\n            _sockThread = null;\n        }\n    }\n\n    @Override\n    public void run() {\n        Thread.currentThread().setPriority(8);\n        while (true) {\n            try {\n                DatagramPacket dgrmpkt = new DatagramPacket(_buffer, _buffer.length);\n                _socket.receive(dgrmpkt);\n                if (isClosing)\n                    break;\n                if (dgrmpkt.getLength() <= 0)\n                    continue;\n                handleDatagram(dgrmpkt);\n                if (isClosing)\n                    break;\n            } catch (IOException io) {\n                if (isClosing) {\n                    break;\n                }\n            } catch (Exception e) {\n                if (isClosing) {\n                    break;\n                }\n            } catch (ThreadDeath d) {\n                close();\n                throw d;\n            } catch (Error err) {\n                handleJavaError(err);\n            }\n        }\n    }\n\n    @Override\n    protected synchronized void finalize() {\n        close();\n    }\n\n    private synchronized void handleJavaError(Throwable thr) {\n        if (thr instanceof OutOfMemoryError) {\n            Thread.yield();\n            return;\n        }\n        if (_socket != null) {\n            _socket.close();\n            _socket = null;\n        }\n        Thread.yield();\n    }\n\n    private synchronized void handleDatagram(DatagramPacket dgrmpkt) {\n        _dgramHdlr.processDatagram(dgrmpkt);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class SnmpSocket implements Runnable {\n    private DatagramSocket _socket;\n    private SnmpResponseHandler _dgramHdlr;\n    private Thread _sockThread;\n    private byte[] _buffer;\n    private boolean _isClosing;\n    private int _socketPort;\n    private int _responseBufSize;\n\n    public SnmpSocket(SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) {\n        _dgramHdlr = rspHdlr;\n        _responseBufSize = bufferSize;\n        _buffer = new byte[bufferSize];\n        try {\n            _socket = new DatagramSocket();\n            _socket.bind(new InetSocketAddress(addr, 0));\n            _socketPort = _socket.getLocalPort();\n            _sockThread = new Thread(this);\n            _sockThread.start();\n        } catch (SocketException e) {\n            handleJavaError(e);\n        }\n    }\n\n    public void sendPacket(byte[] buff, int length, InetAddress addr, int port) {\n        if (!isValid()) {\n            return;\n        }\n        try {\n            DatagramPacket packet = new DatagramPacket(buff, length, addr, port);\n            _socket.send(packet);\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n    }\n\n    public void sendPacket(DatagramPacket dgrmpkt) {\n        if (!isValid()) {\n            return;\n        }\n        try {\n            _socket.send(dgrmpkt);\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n    }\n\n    public boolean isValid() {\n        return !_isClosing && _socket != null && _socket.isBound();\n    }\n\n    public void close() {\n        if (!isValid()) {\n            return;\n        }\n        _isClosing = true;\n        try {\n            _socket.close();\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        while (!_isClosing) {\n            try {\n                DatagramPacket packet = new DatagramPacket(_buffer, _responseBufSize);\n                _socket.receive(packet);\n                handleDatagram(packet);\n            } catch (IOException e) {\n                if (_isClosing) {\n                    break;\n                }\n                handleJavaError(e);\n            }\n        }\n    }\n\n    @Override\n    protected void finalize() {\n        if (!_isClosing) {\n            close();\n        }\n    }\n\n    private void handleJavaError(Throwable thr) {\n        System.err.println(\"Java error in SnmpSocket: \" + thr.getMessage());\n        thr.printStackTrace();\n    }\n\n    private void handleDatagram(DatagramPacket dgrmpkt) {\n        if (_dgramHdlr != null) {\n            _dgramHdlr.handleDatagram(dgrmpkt);\n        }\n    }\n}"
  },
  {
    "Task_id": 614,
    "Instruction": "Task Description: Implement a UDP server function that continuously listens for incoming packets, processes the received data by converting it to uppercase, and sends the modified data back to the client.\n\nFunction Description: The function sets up a UDP server that binds to a specific port (9876) and enters an infinite loop to receive incoming packets. Upon receiving a packet, it extracts the data, converts it to uppercase, and sends the modified data back to the client's address and port. The function handles all necessary UDP communication steps including socket creation, packet reception, data processing, and response transmission.\n\nInput: None (The function takes no parameters as it binds to a fixed port and processes incoming UDP packets)\n\nOutput: None (The function does not return any value but prints received messages to the console and sends responses back to clients)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\nprivate void receiveServerUdpInfo() throws Exception {\n    DatagramSocket serverSocket = new DatagramSocket(9876);\n    byte[] receiveData = new byte[1024];\n    byte[] sendData = new byte[1024];\n    while(true) {\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.receive(receivePacket);\n        String sentence = new String(receivePacket.getData());\n        System.out.println(\"RECEIVED: \" + sentence);\n        InetAddress IPAddress = receivePacket.getAddress();\n        int port = receivePacket.getPort();\n        String capitalizedSentence = sentence.toUpperCase();\n        sendData = capitalizedSentence.getBytes();\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n        serverSocket.send(sendPacket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "import socket\n\ndef udp_server():\n    # Create a UDP socket\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # Bind the socket to the address and port\n    server_socket.bind(('localhost', 9876))\n    \n    print(\"UDP Server is running on port 9876...\")\n    \n    while True:\n        # Receive data from client\n        data, client_address = server_socket.recvfrom(1024)\n        # Convert data to uppercase\n        uppercase_data = data.upper()\n        # Send response back to client\n        server_socket.sendto(uppercase_data, client_address)\n        # Print received message\n        print(f\"Received: {data.decode()}\")\n        print(f\"Sent: {uppercase_data.decode()}\")"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class UrlChecker {\n    public boolean isUrlAccessible(String url) {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            return responseCode == 200;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        new Thread(() -> {\n            try {\n                URL url = new URL(\"https://example.com/feedback\");\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"POST\");\n                connection.setDoOutput(true);\n\n                String postParams = \"content=\" + java.net.URLEncoder.encode(content, \"UTF-8\") +\n                                   \"&env=\" + java.net.URLEncoder.encode(env, \"UTF-8\");\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = postParams.getBytes(\"UTF-8\");\n                    os.write(input, 0, input.length);\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    callback.onSuccess();\n                } else {\n                    callback.onFailure(new Exception(\"HTTP error code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFailure(e);\n            }\n        }).start();\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    public String request(String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) obj.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(3000);\n            connection.setReadTimeout(90000);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"UTF-8\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode != 200) {\n                return null;\n            }\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                response.append(line);\n            }\n            in.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class PreloadTask implements Runnable {\n    private String mRawUrl;\n    private int mPosition;\n    private HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private static List<String> blackList = new ArrayList<>();\n\n    public PreloadTask(String rawUrl, int position, HttpProxyCacheServer cacheServer) {\n        this.mRawUrl = rawUrl;\n        this.mPosition = position;\n        this.mCacheServer = cacheServer;\n    }\n\n    public void setRawUrl(String rawUrl) {\n        this.mRawUrl = rawUrl;\n    }\n\n    public void setPosition(int position) {\n        this.mPosition = position;\n    }\n\n    public void setCacheServer(HttpProxyCacheServer cacheServer) {\n        this.mCacheServer = cacheServer;\n    }\n\n    @Override\n    public void run() {\n        if (mIsCanceled) {\n            return;\n        }\n        try {\n            mIsExecuted = true;\n            start();\n        } catch (Exception e) {\n            // Handle exception and blacklist URL\n            blackList.add(mRawUrl);\n        }\n    }\n\n    private void start() throws Exception {\n        String proxiedUrl = mCacheServer.getProxiedUrl(mRawUrl);\n        if (proxiedUrl == null) {\n            blackList.add(mRawUrl);\n            return;\n        }\n        // Perform HTTP request and content preloading\n        // Simulated HTTP request\n        System.out.println(\"Preloading content from: \" + proxiedUrl);\n        // Simulate failure\n        if (Math.random() < 0.2) {\n            blackList.add(mRawUrl);\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.execute(this);\n    }\n\n    public void cancel() {\n        mIsCanceled = true;\n    }\n\n    public boolean isCanceled() {\n        return mIsCanceled;\n    }\n\n    public boolean isExecuted() {\n        return mIsExecuted;\n    }\n\n    public static List<String> getBlackList() {\n        return blackList;\n    }\n}\n```"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, specifically designed for Android applications to fetch and process JSON data from a server.\n\nClass Description: HttpRequestHandler is a utility class containing an inner AsyncTask subclass (MyAsyncTaskgetNews) that performs HTTP GET requests in the background. It handles connection setup, timeout configuration, input stream processing, and JSON response parsing. The class demonstrates typical operations for user authentication flows.\n\nAttributes:\n- None (All required objects are created locally within methods)\n\nMethods:\n- MyAsyncTaskgetNews: [Inner Class] - Extends AsyncTask<String, String, String> to perform network operations off the UI thread\n  - doInBackground(String... params) -> String - Main execution method that:\n    1. Takes URL string as input parameter\n    2. Establishes HTTP connection with 7-second timeout\n    3. Reads input stream and converts to string\n    4. Publishes progress with response data\n    5. Returns null (results handled via progress updates)\n  \n  - onProgressUpdate(String... progress) -> void - UI thread callback that:\n    1. Parses JSON response\n    2. Handles \"user is added\" case by showing toast and initiating login\n    3. Processes successful login by saving user credentials\n    4. Handles errors via logging\n\nNote: The class assumes existence of helper classes (Operations for stream conversion, SaveSettings for persistence) and Android context availability via getApplicationContext().",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(getApplicationContext());\n                    NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                if (json.getString(\"msg\") == null)\n                    return;\n                if (json.getString(\"msg\").equalsIgnoreCase(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), json.getString(\"msg\"), Toast.LENGTH_LONG).show();\n                    String url = \"http://10.0.2.2/~hussienalrubaye/twitterserver/login.php?email=\" + etEmail.getText().toString() + \"&password=\" + etPassword.getText().toString();\n                    new MyAsyncTaskgetNews().execute(url);\n                }\n\n                if (json.getString(\"msg\").equalsIgnoreCase(\"Pass Login\")) {\n                    JSONArray UserInfo = new JSONArray(json.getString(\"info\"));\n                    JSONObject UserCreintal = UserInfo.getJSONObject(0);\n                    hideProgressDialog();\n                    SaveSettings saveSettings = new SaveSettings(getApplicationContext());\n                    saveSettings.SaveData(UserCreintal.getString(\"user_id\"));\n                    finish();\n                }\n            } catch (Exception ex) {\n                Log.d(\"er\", ex.getMessage());\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            HttpURLConnection connection = null;\n            try {\n                URL urlObj = new URL(url);\n                connection = (HttpURLConnection) urlObj.openConnection();\n                connection.setConnectTimeout(7000);\n                connection.setReadTimeout(7000);\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n                if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = connection.getInputStream();\n                    String response = Operations.streamToString(inputStream);\n                    publishProgress(response);\n                    return null;\n                } else {\n                    return \"Error: \" + connection.getResponseMessage();\n                }\n            } catch (Exception e) {\n                return \"Error: \" + e.getMessage();\n            } finally {\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            super.onProgressUpdate(progress);\n            if (progress[0].startsWith(\"{\\\"status\\\": \\\"user is added\\\"}\")) {\n                Toast.makeText(getApplicationContext(), \"User is added\", Toast.LENGTH_SHORT).show();\n                // Initiate login process\n            } else if (progress[0].startsWith(\"{\\\"status\\\": \\\"success\\\"}\")) {\n                SaveSettings.saveUserCredentials(getApplicationContext(), \"username\", \"password\");\n            } else {\n                Log.e(\"HttpRequestHandler\", \"JSON parsing error: \" + progress[0]);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
    "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class SimpleHttpUtils {\n    private final Log logger;\n    private static final String DEFAULT_CHARSET = \"UTF-8\";\n    private static final String HTTP_METHOD_POST = \"POST\";\n    private static final String HTTP_METHOD_GET = \"GET\";\n    private static final String HTTP_ERROR_MESSAGE = \"HTTP Error\";\n    private static final int DEFAULT_READ_TIMEOUT = 10000;\n    private static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    private static final String HTTP_PREFIX = \"http://\";\n    private static final String HTTPS_PREFIX = \"https://\";\n    private static final int MAX_FETCHSIZE = 1024;\n    private final TrustManager[] trustAnyManagers;\n\n    public SimpleHttpUtils(Log logger) {\n        this.logger = logger;\n        this.trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n    }\n\n    public String httpPost(String url, Map<String, String> params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public String httpGet(String url, Map<String, String> params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public String httpRequest(String url, Map<String, String> params, String method, String charSet, Map<String, String> headers) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            conn.setRequestMethod(method);\n            conn.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT);\n            conn.setReadTimeout(DEFAULT_READ_TIMEOUT);\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    conn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null) {\n                String queryString = mapToQueryString(params, charSet);\n                if (!method.equals(HTTP_METHOD_GET)) {\n                    conn.setDoOutput(true);\n                    try (OutputStream os = conn.getOutputStream()) {\n                        byte[] input = queryString.getBytes(charSet);\n                        os.write(input);\n                        os.flush();\n                    }\n                } else {\n                    conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n                    conn.setRequestProperty(\"Accept-Charset\", charSet);\n                    conn.setRequestProperty(\"Content-Length\", String.valueOf(queryString.getBytes(charSet).length));\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + java.util.Base64.getEncoder().encodeToString((\"username:password\").getBytes(charSet)));\n                }\n            }\n\n            if (url.startsWith(HTTPS_PREFIX)) {\n                setSSLSocketFactory(conn, true, true, null, null);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), charSet));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                logger.error(HTTP_ERROR_MESSAGE + \": \" + responseCode);\n                return null;\n            }\n        } catch (IOException e) {\n            logger.error(\"HTTP request failed: \", e);\n            return null;\n        }\n    }\n\n    public SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        try {\n            URL obj = new URL(httpParam.getUrl());\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            conn.setRequestMethod(httpParam.getMethod());\n            conn.setConnectTimeout(httpParam.getConnectTimeout());\n            conn.setReadTimeout(httpParam.getReadTimeout());\n\n            if (httpParam.getHeaders() != null) {\n                for (Map.Entry<String, String> entry : httpParam.getHeaders().entrySet()) {\n                    conn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (httpParam.getParams() != null) {\n                String queryString = mapToQueryString(httpParam.getParams(), httpParam.getCharSet());\n                if (!httpParam.getMethod().equals(HTTP_METHOD_GET)) {\n                    conn.setDoOutput(true);\n                    try (OutputStream os = conn.getOutputStream()) {\n                        byte[] input = queryString.getBytes(httpParam.getCharSet());\n                        os.write(input);\n                        os.flush();\n                    }\n                } else {\n                    conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + httpParam.getCharSet());\n                    conn.setRequestProperty(\"Accept-Charset\", httpParam.getCharSet());\n                    conn.setRequestProperty(\"Content-Length\", String.valueOf(queryString.getBytes(httpParam.getCharSet()).length));\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + java.util.Base64.getEncoder().encodeToString((\"username:password\").getBytes(httpParam.getCharSet())));\n                }\n            }\n\n            if (obj.toString().startsWith(HTTPS_PREFIX)) {\n                setSSLSocketFactory(conn, httpParam.isSslVerify(), httpParam.isHostnameVerify(), httpParam.getTrustKeyStore(), httpParam.getClientKeyStore());\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), httpParam.getCharSet()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return new SimpleHttpResult(response.toString(), responseCode, conn.getHeaderField(\"Content-Type\"));\n            } else {\n                logger.error(HTTP_ERROR_MESSAGE + \": \" + responseCode);\n                return new SimpleHttpResult(null, responseCode, null);\n            }\n        } catch (IOException e) {\n            logger.error(\"HTTP request failed: \", e);\n            return new SimpleHttpResult(null, -1, null);\n        }\n    }\n\n    private String mapToQueryString(Map<String, String> parameters, String charSet) {\n        if (parameters == null || parameters.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (sb.length() > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(urlEncode(entry.getKey(), charSet));\n            sb.append(\"=\");\n            sb.append(urlEncode(entry.getValue(), charSet));\n        }\n        return sb.toString();\n    }\n\n    private String urlEncode(String url, String charSet) {\n        try {\n            return java.net.URLEncoder.encode(url, charSet);\n        } catch (Exception e) {\n            return url;\n        }\n    }\n\n    private void setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) throws IOException {\n        if (sslVerify) {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            if (trustKeyStore != null) {\n                sslContext.init(trustKeyStore.getKeyManagers(), trustAnyManagers, null);\n            } else {\n                sslContext.init(trustAnyManagers, null, null);\n            }\n            SSLSocketFactory socketFactory = sslContext.getSocketFactory();\n            urlConn.setSSLSocketFactory(socketFactory);\n        } else {\n            urlConn.setSSLSocketFactory((SSLSocketFactory) HttpsURLConnection.getDefaultSSLSocketFactory());\n        }\n\n        if (hostnameVerify) {\n            urlConn.setHostnameVerifier(new TrustAnyHostnameVerifier());\n        } else {\n            urlConn.setHostnameVerifier(HttpsURLConnection.getDefaultHostnameVerifier());\n        }\n    }\n\n    private List<String> makeStringList(Object value) {\n        if (value == null) {\n            return new ArrayList<>();\n        }\n        if (value instanceof String[]) {\n            return Arrays.asList((String[]) value);\n        }\n        if (value instanceof Iterable<?>) {\n            List<String> list = new ArrayList<>();\n            for (Object item : (Iterable<?>) value) {\n                list.add(item.toString());\n            }\n            return list;\n        }\n        return Collections.singletonList(value.toString());\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n            return new java.security.cert.X509Certificate[0];\n        }\n    }\n\n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java, specifying topic configuration such as name, partitions, replication factor, and retention time.\n\nFunction Description: This function creates a new Kafka topic with the specified configuration using the Kafka AdminClient. It handles the creation process, including setting up the AdminClient, defining the topic properties, and executing the topic creation while managing exceptions and resource cleanup.\n\nInput:\n- kafkaClientInfo: [KafkaClientInfo] - Contains connection and configuration details for the Kafka broker\n- newTopicInfo: [NewTopicInfo] - Contains the topic configuration including name, partitions, replication factor, and retention time in milliseconds\n\nOutput:\n- [boolean] - Returns true if the topic was successfully created, false if an error occurred",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.config.TopicConfig;\n\nprivate final KafkaStoragePlugin plugin;\n\npublic boolean createTopicName(KafkaClientInfo kafkaClientInfo, NewTopicInfo newTopicInfo) {\n    boolean status = false;\n    AdminClient adminClient = null;\n    try {\n        adminClient = AdminClient.create(plugin.getKafkaAdminClientProps(kafkaClientInfo));\n        NewTopic newTopic = new NewTopic(newTopicInfo.getTopicName(), newTopicInfo.getPartitions(), newTopicInfo.getReplication());\n        newTopic.configs(Collections.singletonMap(TopicConfig.RETENTION_MS_CONFIG, String.valueOf(newTopicInfo.getRetainMs())));\n        adminClient.createTopics(Collections.singleton(newTopic)).all().get();\n        status = true;\n    } catch (Exception e) {\n        status = false;\n        log.error(\"Create kafka topic has error, new topic [{}], msg is {}\", newTopicInfo, e);\n    } finally {\n        adminClient.close();\n    }\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "wrong_result": "```java\npublic boolean createKafkaTopic(KafkaClientInfo kafkaClientInfo, NewTopicInfo newTopicInfo) {\n    try (AdminClient adminClient = AdminClient.create(kafkaClientInfo.getConfiguration())) {\n        NewTopic newTopic = new NewTopic(newTopicInfo.getName(), newTopicInfo.getPartitions(), newTopicInfo.getReplicationFactor());\n        newTopic.setRetentionMs(newTopicInfo.getRetentionTimeMs());\n\n        CreateTopicsResult result = adminClient.createTopics(Collections.singletonList(newTopic));\n        result.all().get(); // Wait for all topics to be created\n        return true;\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n}\n```"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response from the input stream, and return it as a UTF-8 encoded string. Proper error handling and resource cleanup should be implemented.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent.\n\nOutput: \n- String - The response from the HTTP GET request, or null if an error occurs.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    public String getResponse(String requestUrl) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a Java utility class for making asynchronous HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable headers and parameters. The class should handle response processing and error handling through callbacks.\n\nClass Description: HttpURLConnectionUtils is a final utility class that provides static methods for performing asynchronous HTTP requests. It encapsulates the complexity of HttpURLConnection and provides a simple callback-based interface for handling responses and errors.\n\nAttributes:\n\nTIMEOUT_IN_MILLIONS: int - The connection and read timeout duration in milliseconds (default: 5000)\n\nMethods:\n\ndoGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous HTTP GET request to the specified URL and invokes the callback with the response or error.\n\ndoPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous HTTP POST request to the specified URL with the given parameters and invokes the callback with the response or error.\n\nrequest(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic for both GET and POST methods, including setting headers, writing parameters, and processing the response.\n\nCallback: interface - Defines two methods for handling request outcomes:\n  onResponse(String result, long response) -> void - Called when the request succeeds\n  onFail(Throwable error) -> void - Called when the request fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(\n            final String urlStr,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(\n            final String urlStr,\n            final String params,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    private HttpURLConnectionUtils() {\n        // Prevent instantiation\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (\"POST\".equalsIgnoreCase(method)) {\n                    connection.setDoOutput(true);\n                    try (OutputStream os = connection.getOutputStream()) {\n                        byte[] input = params.getBytes(\"utf-8\");\n                        os.write(input);\n                        os.flush();\n                    }\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                        StringBuilder response = new StringBuilder();\n                        String line;\n                        while ((line = in.readLine()) != null) {\n                            response.append(line);\n                        }\n                        callback.onResponse(response.toString(), responseCode);\n                    }\n                } else {\n                    callback.onFail(new IOException(\"HTTP error code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n    private static final Map<Long, Integer> XSTS_ERRORS = Map.of(\n        400, 1,\n        401, 2,\n        403, 3,\n        404, 4,\n        500, 5\n    );\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws Exception {\n        HttpURLConnection conn = (HttpURLConnection) new URL(authTokenUrl).openConnection();\n        conn.setRequestMethod(isRefresh ? \"POST\" : \"POST\");\n        conn.setDoOutput(true);\n\n        String formData = convertToFormData(\"client_id\", \"your_client_id\", \"client_secret\", \"your_client_secret\", \"code\", authcode);\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = formData.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw getResponseThrowable(conn);\n        }\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n\n        return response.toString();\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws Exception {\n        HttpURLConnection conn = (HttpURLConnection) new URL(xblAuthUrl).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Authorization\", \"Bearer \" + accessToken);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        String formData = convertToFormData(\"grant_type\", \"urn:ietf:params:oauth:grant-type:tokenexchange\");\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = formData.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw getResponseThrowable(conn);\n        }\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n\n        return response.toString();\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws Exception {\n        HttpURLConnection conn = (HttpURLConnection) new URL(xstsAuthUrl).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Authorization\", \"Bearer \" + xblToken);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        String formData = convertToFormData(\"request\", \"https://xsts.auth.xboxlive.com/en-US/xsts/authorize\");\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = formData.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw getResponseThrowable(conn);\n        }\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n\n        String[] result = new String[2];\n        // Assuming JSON response parsing logic here\n        return result;\n    }\n\n    public void setCommonProperties(HttpURLConnection conn, String formData) throws Exception {\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = formData.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n    }\n\n    public String convertToFormData(String... data) {\n        StringBuilder formData = new StringBuilder();\n        for (int i = 0; i < data.length; i += 2) {\n            if (i > 0) {\n                formData.append(\"&\");\n            }\n            formData.append(data[i]).append(\"=\").append(data[i + 1]);\n        }\n        return formData.toString();\n    }\n\n    public RuntimeException getResponseThrowable(HttpURLConnection conn) throws Exception {\n        int responseCode = conn.getResponseCode();\n        String responseMessage = conn.getResponseMessage();\n        if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n            return new RuntimeException(\"Resource not found: \" + responseMessage);\n        } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {\n            return new RuntimeException(\"Unauthorized: \" + responseMessage);\n        } else if (responseCode == HttpURLConnection.HTTP_FORBIDDEN) {\n            return new RuntimeException(\"Forbidden: \" + responseMessage);\n        } else if (responseCode == HttpURLConnection.HTTP_INTERNAL_ERROR) {\n            return new RuntimeException(\"Internal server error: \" + responseMessage);\n        } else {\n            return new RuntimeException(\"Unexpected response code: \" + responseCode + \" - \" + responseMessage);\n        }\n    }\n}"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.google.gson.JsonObject;\n\npublic class HttpUtils {\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        int questionMarkIndex = responseUrl.indexOf('?');\n        if (questionMarkIndex != -1) {\n            String baseUrl = responseUrl.substring(0, questionMarkIndex);\n            String queryParams = responseUrl.substring(questionMarkIndex + 1);\n            String[] params = queryParams.split(\"&\");\n            for (String param : params) {\n                String[] keyValue = param.split(\"=\");\n                if (keyValue.length == 2) {\n                    jsonObject.addProperty(keyValue[0], keyValue[1]);\n                }\n            }\n        } else {\n            baseUrl = responseUrl;\n        }\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = content.getBytes(\"utf-8\");\n            os.write(input);\n            os.flush();\n        }\n\n        int code = connection.getResponseCode();\n        if (code != 200) {\n            throw new Exception(\"HTTP error code: \" + code);\n        }\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.logging.Logger;\n\npublic class NetworkUtils {\n    public static final boolean DEBUG = false;\n    public static final String TAG = \"NetworkUtils\";\n    public static final int HTTP_READ_TIMEOUT = 30000;\n    public static final int HTTP_CONNECTION_TIMEOUT = 30000;\n\n    private static final Logger logger = Logger.getLogger(NetworkUtils.class.getName());\n\n    public HttpURLConnection setupHttpsRequest(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n        connection.setReadTimeout(HTTP_READ_TIMEOUT);\n        return connection;\n    }\n\n    public String downloadUrlMemoryAsString(String url) {\n        try {\n            HttpURLConnection connection = setupHttpsRequest(url);\n            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                return null;\n            }\n            InputStream inputStream = connection.getInputStream();\n            byte[] buffer = new byte[1024];\n            StringBuilder response = new StringBuilder();\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                response.append(new String(buffer, 0, bytesRead));\n            }\n            inputStream.close();\n            return response.toString();\n        } catch (IOException e) {\n            if (DEBUG) {\n                logger.severe(\"Error downloading URL: \" + url + \" - \" + e.getMessage());\n            }\n            return null;\n        }\n    }\n\n    public boolean downloadUrlFile(String url, File f) {\n        try {\n            HttpURLConnection connection = setupHttpsRequest(url);\n            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                return false;\n            }\n            InputStream inputStream = connection.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            FileOutputStream fileOutputStream = new FileOutputStream(f);\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                fileOutputStream.write(buffer, 0, bytesRead);\n            }\n            fileOutputStream.close();\n            inputStream.close();\n            return true;\n        } catch (IOException e) {\n            if (DEBUG) {\n                logger.severe(\"Error downloading URL: \" + url + \" - \" + e.getMessage());\n            }\n            return false;\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String url, String content);\n    }\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://example.com/api\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setDoOutput(true);\n\n            String postData = \"packageName=\" + java.net.URLEncoder.encode(packageName, \"UTF-8\");\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = postData.getBytes(\"UTF-8\");\n                os.write(input);\n            }\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode < 400) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"HTTP error code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception exception);\n    }\n}"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "public void sendAndVerifyHttpRequest(String message, String url) throws IOException {\n    String baseUrl = \"http://example.com\";\n    String fullUrl = baseUrl + url;\n    HttpURLConnection connection = (HttpURLConnection) new URL(fullUrl).openConnection();\n    connection.setRequestMethod(\"POST\");\n    connection.setDoOutput(true);\n    try (OutputStream os = connection.getOutputStream()) {\n        byte[] input = message.getBytes(\"utf-8\");\n        os.write(input, 0, input.length);\n    }\n    int responseCode = connection.getResponseCode();\n    if (responseCode != 200) {\n        throw new IOException(\"HTTP error code: \" + responseCode);\n    }\n    try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = br.readLine()) != null) {\n            response.append(line);\n        }\n        String responseBody = response.toString();\n        if (!responseBody.equals(message)) {\n            System.out.println(\"Response does not match message:\");\n            System.out.println(hexEncode(responseBody));\n        }\n    }\n}\n\nprivate static String hexEncode(String input) {\n    StringBuilder hex = new StringBuilder();\n    for (char c : input.toCharArray()) {\n        hex.append(String.format(\"%02x\", (byte) c));\n    }\n    return hex.toString();\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RestClient {\n    private String protocol;\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n\n    public RestClient(String protocol, String host, int port) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n    }\n\n    public RestClient(String protocol, String host, int port, String username, String password) {\n        this(protocol, host, port);\n        this.username = username;\n        this.password = password;\n    }\n\n    public URL getUrl(String path, Object... param) throws Exception {\n        StringBuilder urlBuilder = new StringBuilder(protocol + \"://\" + host + \":\" + port + path);\n        if (param.length > 0) {\n            urlBuilder.append(\"?\");\n            for (int i = 0; i < param.length; i++) {\n                if (i > 0) urlBuilder.append(\"&\");\n                urlBuilder.append(encodeURIComponent(param[i].toString()));\n            }\n        }\n        return new URL(urlBuilder.toString());\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, List<Option> options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                HttpURLConnection connection = createConnection(path, method, options);\n                if (outStreamConsumer != null) {\n                    outStreamConsumer.accept(connection.getOutputStream());\n                }\n                int responseCode = getResponseCodeFrom(connection);\n                String responseText = tryGetResponseTextFrom(connection, responseCode);\n                return new Response(responseCode, responseText, connection.getHeaderFields());\n            } catch (Exception e) {\n                throw new RestException(\"Error during HTTP request: \" + e.getMessage(), e);\n            }\n        });\n    }\n\n    private HttpURLConnection createConnection(String path, Method method, List<Option> options) throws Exception {\n        URL url = getUrl(path);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(method.name());\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n\n        if (options != null) {\n            for (Option option : options) {\n                if (option.key != null && option.value != null) {\n                    connection.setRequestProperty(option.key, option.value);\n                }\n            }\n        }\n\n        if (username != null && password != null) {\n            String authInfo = username + \":\" + password;\n            byte[] authEncBytes = javax.xml.bind.DatatypeConverter.parseBase64Binary(authInfo);\n            String authString = new String(authEncBytes);\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + authString);\n        }\n\n        return connection;\n    }\n\n    private String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        if (status == 404) {\n            return \"Not Found\";\n        }\n        InputStream is = conn.getInputStream();\n        byte[] buffer = new byte[1024];\n        StringBuilder sb = new StringBuilder();\n        int len;\n        while ((len = is.read(buffer)) != -1) {\n            sb.append(new String(buffer, 0, len));\n        }\n        return sb.toString();\n    }\n\n    private int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        int code = conn.getResponseCode();\n        if (code == 404) {\n            return code;\n        }\n        return code;\n    }\n\n    public enum Method {\n        GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE\n    }\n\n    public static class Option {\n        public String key;\n        public String value;\n    }\n\n    public static class Response {\n        public final int statusCode;\n        public final String responseText;\n        public final Map<String, List<String>> headers;\n\n        public Response(int statusCode, String responseText, Map<String, List<String>> headers) {\n            this.statusCode = statusCode;\n            this.responseText = responseText;\n            this.headers = headers;\n        }\n    }\n\n    private static String encodeURIComponent(String str) {\n        try {\n            return java.net.URLEncoder.encode(str, \"UTF-8\");\n        } catch (Exception e) {\n            return str;\n        }\n    }\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            String url = \"https://dnslog.cn/api/getdomain\";\n            String response = sendHttpRequest(url);\n            if (response != null && response.contains(\"domain\")) {\n                String domain = extractDomain(response);\n                String session = extractSession(response);\n                config.setDomain(domain);\n                config.setSession(session);\n                status = 1;\n            } else {\n                status = -1;\n            }\n        } catch (Exception e) {\n            status = -1;\n        }\n        return 1;\n    }\n\n    private String sendHttpRequest(String url) throws Exception {\n        // Implement HTTP GET request logic here\n        // For example, using HttpURLConnection or a library like HttpClient\n        return \"{'domain': 'example.com', 'session': 'abc123'}\"; // Placeholder response\n    }\n\n    private String extractDomain(String response) {\n        // Extract domain from response\n        return \"example.com\";\n    }\n\n    private String extractSession(String response) {\n        // Extract session from response\n        return \"abc123\";\n    }\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            // Empty preparation method\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            String response = \"\";\n            try {\n                java.net.URL urlObj = new java.net.URL(url);\n                java.net.HttpURLConnection connection = (java.net.HttpURLConnection) urlObj.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode == 200) {\n                    InputStream inputStream = connection.getInputStream();\n                    response = ConvertInputToStringNoChange(inputStream);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return response;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            // Shows the response in a Toast message\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            // Empty completion method\n        }\n    }\n\n    public String getNews(String... params) {\n        return new MyAsyncTask().execute(params).get();\n    }\n\n    private String ConvertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(inputStream));\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpHelper {\n    public static String getHttpContents(String method, String endpoint, Map<String, String> headers) throws Exception {\n        if (endpoint == null || endpoint.isEmpty()) {\n            throw new IllegalArgumentException(\"Endpoint cannot be null or empty\");\n        }\n\n        URL url = new URL(endpoint);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        connection.setRequestMethod(method);\n\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new Exception(\"HTTP error code: \" + responseCode);\n        }\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n\n        in.close();\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling authentication, and processing JSON responses.\n\nClass Description: JobRemotingUtil is a utility class that provides functionality for making remote HTTP POST requests with JSON data. It handles connection setup, request configuration, payload serialization, response processing, and error handling. The class includes logging capabilities and supports access token authentication.\n\nAttributes:\nlogger: [Logger] - SLF4J logger instance for logging errors and debug information\nXXL_RPC_ACCESS_TOKEN: [String] - Constant string for the authentication token header name\n\nMethods:\npostBody: [Name](String url, String accessToken, Object requestObj, int timeout) -> ReturnT<String> - Makes an HTTP POST request to the specified URL with the given request object serialized as JSON. Handles authentication via access token, sets appropriate headers, and processes the JSON response. Returns a ReturnT<String> object containing the response status, message, and content. The timeout parameter specifies the read timeout in seconds.",
    "Canonical_solution": "import com.wugui.datatx.core.biz.model.ReturnT;\nimport com.wugui.datax.rpc.util.json.BasicJson;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            String requestBody = BasicJson.toJson(requestObj);\n            DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n            dataOutputStream.writeBytes(requestBody);\n            dataOutputStream.flush();\n            dataOutputStream.close();\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                Map<String, Object> resultMap = BasicJson.parseMap(resultJson);\n\n                ReturnT<String> returnT = new ReturnT<String>();\n                if (resultMap==null) {\n                    returnT.setCode(ReturnT.FAIL_CODE);\n                    returnT.setMsg(\"AdminBizClient Remoting call fail.\");\n                } else {\n                    returnT.setCode(Integer.valueOf(String.valueOf(resultMap.get(\"code\"))));\n                    returnT.setMsg(String.valueOf(resultMap.get(\"msg\")));\n                    returnT.setContent(String.valueOf(resultMap.get(\"content\")));\n                }\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.alibaba.fastjson.JSON;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.TimeUnit;\n\npublic class JobRemotingUtil {\n    private static final Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static final String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n            con.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            con.setConnectTimeout(timeout * 1000);\n            con.setReadTimeout(timeout * 1000);\n\n            String jsonInputString = JSON.toJSONString(requestObj);\n            con.setDoOutput(true);\n            try (varOutputStream os = con.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            int code = con.getResponseCode();\n            if (code == HttpURLConnection.HTTP_OK) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = in.readLine()) != null) {\n                        response.append(line);\n                    }\n                    return new ReturnT<>(ReturnT.SUCCESS_CODE, \"Request successful\", response.toString());\n                }\n            } else {\n                logger.error(\"HTTP error code: {}\", code);\n                return new ReturnT<>(ReturnT.FAIL_CODE, \"HTTP error code: \" + code, \"\");\n            }\n        } catch (Exception e) {\n            logger.error(\"Error during POST request\", e);\n            return new ReturnT<>(ReturnT.FAIL_CODE, \"Error during POST request: \" + e.getMessage(), \"\");\n        }\n    }\n}\n\nclass ReturnT<T> {\n    public static final int SUCCESS_CODE = 0;\n    public static final int FAIL_CODE = 1;\n\n    private final int code;\n    private final String message;\n    private final T content;\n\n    public ReturnT(int code, String message, T content) {\n        this.code = code;\n        this.message = message;\n        this.content = content;\n    }\n\n    public int getCode() {\n        return code;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public T getContent() {\n        return content;\n    }\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpPostSender {\n    public String sendPostRequest(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n\n            String postParams = \"name=\" + name;\n            OutputStream os = con.getOutputStream();\n            os.write(postParams.getBytes());\n            os.flush();\n            os.close();\n\n            int responseCode = con.getResponseCode();\n            System.out.println(\"Response Code : \" + responseCode);\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    private HttpRequestCallback callback;\n\n    public HttpRequestHandler(HttpRequestCallback callback) {\n        this.callback = callback;\n    }\n\n    public class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... urls) {\n            try {\n                URL url = new URL(urls[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = connection.getInputStream();\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    reader.close();\n                    inputStream.close();\n                    return response.toString();\n                } else {\n                    return \"Error: \" + responseCode;\n                }\n            } catch (Exception e) {\n                return \"Error: \" + e.getMessage();\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            super.onProgressUpdate(values);\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n\n    public MyAsyncTask getNews(HttpRequestCallback callback) {\n        this.callback = callback;\n        return new MyAsyncTask();\n    }\n}\n\ninterface HttpRequestCallback {\n    void onProgressUpdate(String... values);\n    void onPostExecute(String result);\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.security.cert.X509Certificate;\nimport javax.net.ssl.*;\n\npublic class HttpService {\n    private boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"HttpService\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws IOException {\n        int retryCount = 0;\n        while (retryCount < 3) {\n            try {\n                HttpURLConnection connection = (HttpURLConnection) new URL(endpointUrl).openConnection();\n                if (interactor != null) {\n                    interactor.interact(connection);\n                }\n                connection.setRequestMethod(\"POST\");\n                connection.setDoOutput(true);\n                connection.setConnectTimeout(5000);\n                connection.setReadTimeout(5000);\n                connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                connection.setRequestProperty(\"Content-Type\", \"application/json\");\n\n                OutputStream outputStream = getBufferedOutputStream(connection.getOutputStream());\n                if (params != null) {\n                    String json = new ObjectMapper().writeValueAsString(params);\n                    outputStream.write(json.getBytes(StandardCharsets.UTF_8));\n                }\n                outputStream.close();\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service unavailable: \" + responseCode);\n                }\n\n                InputStream inputStream = connection.getInputStream();\n                byte[] response = slurp(inputStream);\n                return response;\n            } catch (IOException e) {\n                if (retryCount < 2) {\n                    retryCount++;\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException ignored) {\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n        return null;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) {\n        if (shouldGzipRequestPayload) {\n            return new BufferedOutputStream(new GZIPOutputStream(out));\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private boolean isProxyRequest(String endpointUrl) {\n        return endpointUrl.startsWith(\"http://proxy.\");\n    }\n\n    private byte[] slurp(InputStream inputStream) throws IOException {\n       ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            byteArrayOutputStream.write(buffer, 0, bytesRead);\n        }\n        return byteArrayOutputStream.toByteArray();\n    }\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests and handling responses, including JSON parsing and connection management.\n\nClass Description: HttpRequester is a utility class that provides methods for creating HTTP connections, sending requests, and processing responses. It supports handling both successful responses and error streams, with specialized methods for parsing JSON responses. The class manages connection lifecycle and resource cleanup.\n\nAttributes: (None - this is a purely static utility class)\n\nMethods:\n\nMethod1: getConnectionFromRoute(String apiUrl, Route route, String... params) -> HttpURLConnection - Creates an HTTP connection from a route template and parameters. Sets up the connection with proper headers and request method.\n\nMethod2: getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) -> HttpURLConnection - Creates an HTTP connection from a pre-compiled route. Configures the connection with headers and request method.\n\nMethod3: parseInputStreamAndClose(InputStream inputStream) -> String - Internal method that reads an input stream into a string and closes the stream.\n\nMethod4: parseString(HttpURLConnection connection) -> String - Reads the successful response from a connection into a string.\n\nMethod5: parseStringAndDisconnect(HttpURLConnection connection) -> String - Reads the response into a string and disconnects the connection.\n\nMethod6: parseErrorString(HttpURLConnection connection) -> String - Reads the error stream from a connection into a string.\n\nMethod7: parseErrorStringAndDisconnect(HttpURLConnection connection) -> String - Reads the error stream into a string and disconnects the connection.\n\nMethod8: parseJSONObject(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object.\n\nMethod9: parseJSONObjectAndDisconnect(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object and disconnects the connection.\n\nMethod10: parseJSONArray(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array.\n\nMethod11: parseJSONArrayAndDisconnect(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array and disconnects the connection.",
    "Canonical_solution": "import org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequester {\n\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        return getConnectionFromCompiledRoute(apiUrl, route.compile(params));\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String url = apiUrl + route.getCompiledRoute();\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setFixedLengthStreamingMode(0);\n        connection.setRequestMethod(route.getMethod().name());\n        String agentString = System.getProperty(\"http.agent\")\n                + \"; ReVanced/\" + Utils.getAppVersionName()\n                + \" (\" + Utils.getPatchesReleaseVersion() + \")\";\n        connection.setRequestProperty(\"User-Agent\", agentString);\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder jsonBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                jsonBuilder.append(line);\n                jsonBuilder.append('\\n');\n            }\n            return jsonBuilder.toString();\n        }\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        InputStream errorStream = connection.getErrorStream();\n        if (errorStream == null) {\n            return \"\";\n        }\n        return parseInputStreamAndClose(errorStream);\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONObject(parseString(connection));\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONObject object = parseJSONObject(connection);\n        connection.disconnect();\n        return object;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONArray(parseString(connection));\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONArray array = parseJSONArray(connection);\n        connection.disconnect();\n        return array;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport org.json.JSONObject;\nimport org.json.JSONArray;\n\npublic class HttpRequester {\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws Exception {\n        String url = route.buildUrl(apiUrl, params);\n        HttpURLConnection connection = (HttpURLConnection) new java.net.URL(url).openConnection();\n        connection.setRequestMethod(route.getMethod());\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        return connection;\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws Exception {\n        String url = route.getUrl();\n        HttpURLConnection connection = (HttpURLConnection) new java.net.URL(url).openConnection();\n        connection.setRequestMethod(route.getMethod());\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws Exception {\n        if (inputStream == null) {\n            return \"\";\n        }\n        try {\n            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(inputStream));\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } finally {\n            inputStream.close();\n        }\n    }\n\n    private static String parseString(HttpURLConnection connection) throws Exception {\n        if (connection == null || connection.getResponseCode() >= 400) {\n            return parseErrorString(connection);\n        }\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    private static String parseStringAndDisconnect(HttpURLConnection connection) throws Exception {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    private static String parseErrorString(HttpURLConnection connection) throws Exception {\n        if (connection == null) {\n            return \"\";\n        }\n        return parseInputStreamAndClose(connection.getErrorStream());\n    }\n\n    private static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws Exception {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    private static JSONObject parseJSONObject(HttpURLConnection connection) throws Exception {\n        String response = parseString(connection);\n        return new JSONObject(response);\n    }\n\n    private static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws Exception {\n        JSONObject result = parseJSONObject(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    private static JSONArray parseJSONArray(HttpURLConnection connection) throws Exception {\n        String response = parseString(connection);\n        return new JSONArray(response);\n    }\n\n    private static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws Exception {\n        JSONArray result = parseJSONArray(connection);\n        connection.disconnect();\n        return result;\n    }\n}"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a Java class that checks the HTTP status of a given URL and provides information about the response code and any redirection.\n\nClass Description: The HttpStatusChecker class is responsible for making HTTP requests to a specified URL, checking the response status code, and providing information about the response. It handles redirections and provides human-readable messages for the status codes. The class is designed for Android applications, using Android-specific components for logging and resource management.\n\nAttributes:\n- context: Context - The Android context used for accessing resources and system services.\n- url: String - The URL to be checked for HTTP status.\n\nMethods:\n- checkStatus() -> StatusResult - Performs the HTTP request to the specified URL, checks the response code, handles redirections, and returns a StatusResult object containing the status message and redirection URL (if any). This method handles various exceptions and provides appropriate error messages.\n  \n  Nested Class:\n  - StatusResult - A static inner class that holds the result of the HTTP status check.\n    Attributes:\n    - message: String - A human-readable message describing the HTTP status or error.\n    - redirectionUrl: String - The URL to which the original URL redirects (null if no redirection).",
    "Canonical_solution": "import android.content.Context;\nimport android.util.Log;\n\nimport com.trianguloy.urlchecker.utilities.methods.HttpUtils;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        String message = null;\n        String redirectionUrl = null;\n\n        HttpURLConnection conn = null;\n        try {\n            // Step 2: Get the access URL\n            Log.d(\"STATUS\", \"Checking: \" + url);\n            \n            // Step 3: Create an HttpURLConnection object\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            \n            // Step 4: Set request parameters\n            conn.setInstanceFollowRedirects(false);\n            conn.setConnectTimeout(HttpUtils.CONNECT_TIMEOUT);\n            \n            // Step 5: Processing Input and Output\n            var responseCode = conn.getResponseCode();\n            Log.d(\"RESPONSE_CODE\", url + \": \" + responseCode);\n\n            var codesArray = context.getResources().getStringArray(R.array.mStatus_codes);\n            for (var s : codesArray) {\n                if (s.startsWith(String.valueOf(responseCode))) {\n                    message = s;\n                    break;\n                }\n            }\n            if (message == null) {\n                message = context.getString(R.string.mStatus_unknownCode, responseCode);\n            }\n\n            var location = conn.getHeaderField(\"Location\");\n            if (location != null) {\n                redirectionUrl = new URL(new URL(url), location).toExternalForm();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_ioerror, e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_error, e.getMessage());\n        } finally {\n            // Step 6: Disconnect\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n\n        return new StatusResult(message, redirectionUrl);\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpStatusChecker {\n    private Context context;\n    private String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        StatusResult result = new StatusResult();\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode >= 300 && responseCode < 400) {\n                String location = connection.getHeaderField(\"Location\");\n                if (location != null && !location.isEmpty()) {\n                    result.setRedirectionUrl(location);\n                }\n                result.setMessage(context.getString(R.string.redirected_to, location));\n            } else if (responseCode >= 400 && responseCode < 500) {\n                result.setMessage(context.getString(R.string.error_status, responseCode));\n            } else if (responseCode >= 500 && responseCode < 600) {\n                result.setMessage(context.getString(R.string.server_error, responseCode));\n            } else {\n                result.setMessage(context.getString(R.string.success_status, responseCode));\n            }\n        } catch (Exception e) {\n            result.setMessage(context.getString(R.string.error_occurred, e.getMessage()));\n        }\n        return result;\n    }\n\n    public static class StatusResult {\n        private String message;\n        private String redirectionUrl;\n\n        public String getMessage() {\n            return message;\n        }\n\n        public void setMessage(String message) {\n            this.message = message;\n        }\n\n        public String getRedirectionUrl() {\n            return redirectionUrl;\n        }\n\n        public void setRedirectionUrl(String redirectionUrl) {\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a Java class that provides functionality for managing Kafka topics using the Kafka AdminClient API. The class should be able to create and configure an AdminClient instance and use it to create new Kafka topics.\n\nClass Description: The KafkaTopicManager class encapsulates operations for interacting with Kafka topics through the AdminClient API. It provides methods to initialize an AdminClient connection and create new topics with specified configurations.\n\nAttributes:\n- adminClient: AdminClient - The Kafka AdminClient instance used for topic management operations\n\nMethods:\n- createAndConfigureAdminClient(String bootstrapServers) -> AdminClient - Creates and configures a Kafka AdminClient instance with the specified bootstrap servers\n- autoCreateMetricsTopic(AdminClient adminClient, String topicName) -> TopicDescription - Creates a new Kafka topic with default configuration (1 partition and replication factor of 1) and returns its description",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n    Properties adminProps = new Properties();\n    adminProps.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminProps);\n    return adminClient;\n}\n\npublic TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) throws ExecutionException, InterruptedException {\n    NewTopic testTopic = new NewTopic(topicName, 1, (short) 1);\n    CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singleton(testTopic));\n    createTopicsResult.all().get();\n    TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topicName)).values().get(topicName).get();\n    return topicDescription;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 33,
    "wrong_result": "public class KafkaTopicManager {\n    private AdminClient adminClient;\n\n    public AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n        return AdminClient.create(Props.create(\"bootstrap.servers\", bootstrapServers));\n    }\n\n    public TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) {\n        this.adminClient = adminClient;\n        CreateTopicsResult result = adminClient.createTopics(Collections.singletonList(\n                new TopicDescription(topicName, 1, 1)\n        ));\n        result.all().get();\n        return adminClient.describeTopics(Collections.singletonList(topicName)).all().get().get(topicName);\n    }\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using HttpURLConnection, supporting both GET and POST methods asynchronously, with callback mechanisms for handling responses and errors. The class should also include functionality to retrieve network time from a server.\n\nClass Description: HttpURLConnectionUtils is a utility class that provides asynchronous HTTP request capabilities using Java's HttpURLConnection. It supports GET and POST methods, allows setting custom headers, and provides callback interfaces for handling responses and errors. Additionally, it includes functionality to fetch network time from a specified URL.\n\nAttributes:\n- TAG: String - Class tag for logging purposes\n- TIMEOUT_IN_MILLIONS: int - Default timeout for connections in milliseconds (5000ms)\n- BAIDU_URL: String - Default URL for network time requests (https://www.baidu.com)\n\nMethods:\n- doGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous GET request to the specified URL and invokes the callback with the response or error\n- doPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous POST request to the specified URL with given parameters and invokes the callback\n- getNetTime(TimeCallback callback) -> void - Retrieves network time from the default BAIDU_URL using the provided callback\n- getNetTime(String urlStr, TimeCallback callback) -> void - Retrieves network time from the specified URL using the provided callback\n- request(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic\n- reqNetTime(String urlStr, TimeCallback callback) -> void - Internal method that handles network time retrieval\n\nCallback Interfaces:\n- Callback: \n  - onResponse(String result, long response) -> void - Called when request succeeds\n  - onFail(Throwable error) -> void - Called when request fails\n- TimeCallback:\n  - onResponse(long millis) -> void - Called when network time retrieval succeeds\n  - onFail(Throwable error) -> void - Called when network time retrieval fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final String TAG = HttpURLConnectionUtils.class.getSimpleName();\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(final String urlStr, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(final String urlStr, final String params, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void getNetTime(final TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(final String urlStr, final TimeCallback callback) {\n        new Thread(() -> reqNetTime(urlStr, callback)).start();\n    }\n\n    private static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n            \n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1)) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n\n    private static void reqNetTime(final String urlStr, final TimeCallback callback) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            long date = connection.getDate();\n            if (date <= 0) {\n                date = -1L;\n            }\n            if (callback != null) {\n                callback.onResponse(date);\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "package com.example.utils;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class HttpURLConnectionUtils {\n    private static final String TAG = \"HttpURLConnectionUtils\";\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    private static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    public void getNetTime(TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public void getNetTime(String urlStr, TimeCallback callback) {\n        reqNetTime(urlStr, callback);\n    }\n\n    private void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (\"POST\".equalsIgnoreCase(method)) {\n                    connection.setDoOutput(true);\n                    try (OutputStream os = connection.getOutputStream()) {\n                        byte[] input = params.getBytes(\"utf-8\");\n                        os.write(input);\n                        os.flush();\n                    }\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = in.readLine()) != null) {\n                        response.append(line);\n                    }\n                    in.close();\n                    callback.onResponse(response.toString(), responseCode);\n                } else {\n                    callback.onFail(new Exception(\"HTTP error code: \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    private void reqNetTime(String urlStr, TimeCallback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                long time = connection.getDate();\n                if (time > 0) {\n                    callback.onResponse(time, time);\n                } else {\n                    callback.onFail(new Exception(\"Failed to retrieve network time\"));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.InetAddress;\nimport java.net.URL;\nimport java.net.MalformedURLException;\nimport java.util.Enumeration;\nimport java.util.logging.Logger;\n\npublic class SSRFChecker {\n    private final Logger logger;\n    private String decimalIp;\n\n    public SSRFChecker(Logger logger) {\n        this.logger = logger;\n    }\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        try {\n            String host = url2host(url);\n            if (host.isEmpty()) {\n                logger.info(\"Invalid URL: \" + url);\n                return false;\n            }\n            for (int i = 0; i < checkTimes; i++) {\n                String ip = host2ip(host);\n                if (!ip.isEmpty() && isInternalIp(ip)) {\n                    logger.warning(\"Detected internal IP: \" + ip + \" in URL: \" + url);\n                    return false;\n                }\n                // Follow redirect if needed\n                URL redirectedUrl = new URL(url);\n                if (redirectedUrl.getProtocol().equals(\"http\")) {\n                    url = redirectedUrl.toString();\n                } else {\n                    break;\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.severe(\"Error checking SSRF for URL: \" + url + \": \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public boolean isInternalIpByUrl(String url) {\n        try {\n            String host = url2host(url);\n            if (host.isEmpty()) {\n                return false;\n            }\n            String ip = host2ip(host);\n            return !ip.isEmpty() && isInternalIp(ip);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public boolean isInternalIp(String strIP) {\n        try {\n            InetAddress address = InetAddress.getByName(strIP);\n            String ipString = address.getHostAddress();\n            return isInternalIp(ipString);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public String host2ip(String host) {\n        try {\n            InetAddress address = InetAddress.getByName(host);\n            decimalIp = address.getHostAddress();\n            return decimalIp;\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        if (url == null || url.isEmpty()) {\n            return \"\";\n        }\n        try {\n            URL urlObj = new URL(url);\n            String protocol = urlObj.getProtocol();\n            String host = urlObj.getHost();\n            if (protocol.equals(\"http\") || protocol.equals(\"https\")) {\n                return host;\n            } else {\n                return \"\";\n            }\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    }\n\n    public boolean isOctalIP(String host) {\n        try {\n            InetAddress address = InetAddress.getByName(host);\n            String ipString = address.getHostAddress();\n            return ipString.matches(\"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\");\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response stream, and return the content as a UTF-8 encoded string. It should handle resource cleanup properly by closing all streams and disconnecting the HTTP connection.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent\n\nOutput: \n- String - The response content from the HTTP GET request, or null if an error occurs",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpGetter {\n    public String getResponse(String requestUrl) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            java.net.URL url = new java.net.URL(urlStr);\n            java.net.HttpURLConnection connection = (java.net.HttpURLConnection) url.openConnection();\n            if (mProxyOn) {\n                connection.setProxy(new java.net.Proxy(java.net.Proxy.Type.HTTP, new java.net.InetSocketAddress(mProxyHost, mProxyPort)));\n            }\n            connection.setRequestMethod(\"GET\");\n            connection.setReadTimeout(5000);\n            connection.setConnectTimeout(5000);\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                InputStream inputStream = connection.getInputStream();\n                String response = readStringFromStream(inputStream);\n                callback.onSuccess(response);\n            } else {\n                callback.onFailed();\n            }\n        } catch (Exception e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) throws java.io.IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        java.io.BufferedReader bufferedReader = new java.io.BufferedReader(new java.io.InputStreamReader(inputStream));\n        String line;\n        while ((line = bufferedReader.readLine()) != null) {\n            stringBuilder.append(line);\n        }\n        return stringBuilder.toString();\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\n\npublic class HttpTinyClient {\n    public static class HttpResult {\n        public int code;\n        public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        StringBuilder query = new StringBuilder();\n        if (paramValues != null && !paramValues.isEmpty()) {\n            for (int i = 0; i < paramValues.size(); i++) {\n                if (i > 0) query.append(\"&\");\n                query.append(encodeParam(paramValues.get(i), encoding));\n            }\n        }\n        String fullUrl = url + (query.length() > 0 ? \"?\" + query.toString() : \"\");\n        URL obj = new URL(fullUrl);\n        HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n        setHeaders(conn, headers, encoding);\n        conn.setRequestMethod(\"GET\");\n        conn.setReadTimeout(readTimeoutMs);\n        conn.setConnectTimeout(readTimeoutMs);\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return new HttpResult(conn.getResponseCode(), response.toString());\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        String encodedParams = encodingParams(paramValues, encoding);\n        URL obj = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n        setHeaders(conn, headers, encoding);\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = encodedParams.getBytes(encoding);\n            os.write(input);\n            os.flush();\n        }\n        conn.setReadTimeout(readTimeoutMs);\n        conn.setConnectTimeout(readTimeoutMs);\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n        return new HttpResult(conn.getResponseCode(), response.toString());\n    }\n\n    public static String encodingParams(List<String> paramValues, String encoding) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i++) {\n            if (i > 0) result.append(\"&\");\n            result.append(encodeParam(paramValues.get(i), encoding));\n        }\n        return result.toString();\n    }\n\n    private static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (headers != null && !headers.isEmpty()) {\n            for (String header : headers) {\n                String[] parts = header.split(\":\");\n                if (parts.length == 2) {\n                    conn.setRequestProperty(parts[0], parts[1]);\n                }\n            }\n        }\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + encoding);\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n    }\n\n    private static String encodeParam(String value, String encoding) {\n        try {\n            return java.net.URLEncoder.encode(value, encoding);\n        } catch (Exception e) {\n            return value;\n        }\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.servlet.http.Part;\n\npublic class HttpPostUploadUtil {\n    private static final Logger logger = Logger.getLogger(HttpPostUploadUtil.class.getName());\n\n    public String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, Part> fileMap) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setConnectTimeout(connectTimeout);\n        connection.setReadTimeout(readTimeout);\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + generateBoundary());\n\n        try (OutputStream os = connection.getOutputStream()) {\n            boolean first = true;\n            for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                if (!first) {\n                    os.write(\"\\r\\n\".getBytes());\n                }\n                os.write((\"--\" + generateBoundary() + \"\\r\\n\").getBytes());\n                os.write((\"Content-Disposition: form-data; name=\\\"\" + entry.getKey() + \"\\\"\\r\\n\").getBytes());\n                os.write(\"\\r\\n\".getBytes());\n                os.write(entry.getValue().getBytes());\n                os.write(\"\\r\\n\".getBytes());\n                first = false;\n            }\n\n            for (Map.Entry<String, Part> entry : fileMap.entrySet()) {\n                if (!first) {\n                    os.write(\"\\r\\n\".getBytes());\n                }\n                os.write((\"--\" + generateBoundary() + \"\\r\\n\").getBytes());\n                os.write((\"Content-Disposition: form-data; name=\\\"\" + entry.getKey() + \"\\\"; filename=\\\"\" + entry.getValue().getSubmittedFileName() + \"\\\"\\r\\n\").getBytes());\n                os.write(\"Content-Type: \" + entry.getValue().getContentType() + \"\\r\\n\\r\\n\".getBytes());\n                try (InputStream is = entry.getValue().getInputStream()) {\n                    byte[] buffer = new byte[4096];\n                    int bytesRead;\n                    while ((bytesRead = is.read(buffer)) != -1) {\n                        os.write(buffer, 0, bytesRead);\n                    }\n                }\n                os.write(\"\\r\\n\".getBytes());\n                first = false;\n            }\n\n            if (first) {\n                os.write((\"--\" + generateBoundary() + \"--\\r\\n\").getBytes());\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        logger.info(\"Server responded with code: \" + responseCode);\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line);\n            }\n            return response.toString();\n        } catch (IOException e) {\n            logger.severe(\"Error reading response: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private String generateBoundary() {\n        return \"----\" + System.currentTimeMillis() + \"----\";\n    }\n\n    public void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.severe(\"Error closing stream: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\nimport com.google.gson.Gson;\n\npublic class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new java.util.HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this(baseUrl, apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) throws Exception {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) throws Exception {\n        String encodedQuery = parseQueries(query);\n        return getFullUrl(additionalHeaders, baseUrl + endpoint + \"?\" + encodedQuery, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) throws Exception {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) throws Exception {\n        String encodedQuery = parseQueries(query);\n        return postFullUrl(additionalHeaders, baseUrl + endpoint + \"?\" + encodedQuery, body, tClass);\n    }\n\n    static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) throws Exception {\n        return getFullUrl(headers, url, null, tClass);\n    }\n\n    static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) throws Exception {\n        String encodedQuery = parseQueries(query);\n        String fullUrl = url + (encodedQuery != null ? \"?\" + encodedQuery : \"\");\n        return getRaw(headers, fullUrl, tClass);\n    }\n\n    static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) throws Exception {\n        return postFullUrl(headers, url, null, body, tClass);\n    }\n\n    static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) throws Exception {\n        String encodedQuery = parseQueries(query);\n        String fullUrl = url + (encodedQuery != null ? \"?\" + encodedQuery : \"\");\n        return postRaw(headers, fullUrl, body, tClass);\n    }\n\n    static String getRaw(Map<String, String> headers, String url) throws Exception {\n        return getRaw(headers, url, null);\n    }\n\n    static String getRaw(Map<String, String> headers, String url, String responseFormat) throws Exception {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        addHeaders(connection, headers);\n        connection.setRequestMethod(\"GET\");\n        connection.setDoOutput(true);\n        connection.connect();\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            throw new Exception(\"HTTP error code: \" + responseCode);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    static String postRaw(Map<String, String> headers, String url, String body) throws Exception {\n        return postRaw(headers, url, body, null);\n    }\n\n    static String postRaw(Map<String, String> headers, String url, String body, String responseFormat) throws Exception {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        addHeaders(connection, headers);\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setDoInput(true);\n        connection.connect();\n        OutputStream os = connection.getOutputStream();\n        os.write(body.getBytes(\"UTF-8\"));\n        os.flush();\n        os.close();\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            throw new Exception(\"HTTP error code: \" + responseCode);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        in.close();\n        return response.toString();\n    }\n\n    static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    static String parseQueries(HashMap<String, Object> query) {\n        if (query == null || query.isEmpty()) {\n            return null;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            String key = urlEncodeUTF8(entry.getKey());\n            String value = urlEncodeUTF8(entry.getValue().toString());\n            sb.append(key).append(\"=\").append(value).append(\"&\");\n        }\n        return sb.substring(0, sb.length() - 1);\n    }\n\n    static String urlEncodeUTF8(String input) {\n        try {\n            return java.net.URLEncoder.encode(input, \"UTF-8\");\n        } catch (Exception e) {\n            return input;\n        }\n    }\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.logging.Logger;\n\npublic class RemoteServiceImpl {\n    private String repositoryServerUrl;\n    private Logger log;\n\n    public RemoteServiceImpl() {\n        this.log = Logger.getLogger(RemoteServiceImpl.class.getName());\n    }\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        String response = sendRequest(packageId, timestamp);\n        if (response == null || response.isEmpty()) {\n            log.severe(\"Failed to retrieve knowledge package for ID: \" + packageId + \" and timestamp: \" + timestamp);\n            return null;\n        }\n        return parseResponse(response);\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        try {\n            String url = repositoryServerUrl + \"/api/knowledge/\" + packageId + \"?timestamp=\" + timestamp;\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"GET\");\n            int responseCode = con.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                log.severe(\"HTTP error code: \" + responseCode + \" for request to: \" + url);\n                return null;\n            }\n        } catch (Exception e) {\n            log.severe(\"Error sending request for package ID: \" + packageId + \" and timestamp: \" + timestamp + \": \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private KnowledgePackage parseResponse(String response) {\n        // Simplified parsing logic; actual implementation would depend on the response format\n        if (response == null || response.isEmpty()) {\n            return null;\n        }\n        return new KnowledgePackage(\"SampleContent\", \"SampleAuthor\", \"2023-10-01\");\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if (resporityServerUrl == null || resporityServerUrl.isEmpty()) {\n            this.repositoryServerUrl = \"https://remote-repo.example.com\";\n        } else {\n            this.repositoryServerUrl = resporityServerUrl;\n            if (!repositoryServerUrl.endsWith(\"/\")) {\n                this.repositoryServerUrl += \"/\";\n            }\n        }\n    }\n}\n\nclass KnowledgePackage {\n    private String content;\n    private String author;\n    private String date;\n\n    public KnowledgePackage(String content, String author, String date) {\n        this.content = content;\n        this.author = author;\n        this.date = date;\n    }\n\n    // Getters and setters\n    public String getContent() { return content; }\n    public String getAuthor() { return author; }\n    public String getDate() { return date; }\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class FetchUrlMimeType {\n    private DownloadManager mDownloadManager;\n    private DownloadManager.Request mRequest;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        mDownloadManager = downloadManager;\n        mRequest = request;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public io.reactivex.Single<Result> create() {\n        return io.reactivex.Single.create(emitter -> {\n            try {\n                URL url = new URL(mUri);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(10000);\n                connection.setReadTimeout(10000);\n                connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.setRequestProperty(\"Cookie\", mCookies);\n                }\n                connection.connect();\n\n                if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                    String contentType = connection.getContentType();\n                    String contentDisposition = connection.getHeaderField(\"Content-Disposition\");\n\n                    if (contentType != null) {\n                        mRequest.setMimeType(contentType);\n                    }\n\n                    if (contentDisposition != null) {\n                        int index = contentDisposition.indexOf(\"filename=\");\n                        if (index > 0) {\n                            String fileName = contentDisposition.substring(index + 10);\n                            int endIndex = fileName.indexOf(\"\\\"\");\n                            if (endIndex > 0) {\n                                fileName = fileName.substring(0, endIndex);\n                            }\n                            mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);\n                        }\n                    }\n                } else {\n                    emitter.onError(new Exception(\"Failed to fetch MIME type: HTTP \" + connection.getResponseCode()));\n                    return;\n                }\n\n                long referenceId = mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (Exception e) {\n                emitter.onError(e);\n            }\n        });\n    }\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}"
  }
]