[
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Properties;\n\npublic class HttpClient {\n\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n\n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n\n\n    private static HttpClient me = new HttpClient();\n\n    private HttpClient(){}\n\n    public static HttpClient getInstance(){\n        return me;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            if (handler != null) {\n                if (handler.shouldRetry(e)) {\n                    try {\n                        doConnection(method, props);\n                    } catch (IOException e1) {\n                        throw new HttpClientException(\"Connection failed after retry\", e1);\n                    }\n                }\n            } else {\n                throw new HttpClientException(\"Connection failed\", e);\n            }\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL urlObj = new URL(url);\n        if(proxyHost != null && proxyPort != null) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) urlObj.openConnection(proxy);\n        } else {\n            con = (HttpURLConnection) urlObj.openConnection();\n        }\n        con.setRequestMethod(method);\n        for (String key : props.stringPropertyNames()) {\n            con.setRequestProperty(key, props.getProperty(key));\n        }\n    }\n\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL urlObj = new URL(url + \"/\" + imgName);\n        InputStream is = urlObj.openStream();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, bytesRead);\n        }\n        return baos.toByteArray();\n    }\n\n\n    public void connectForMultipart() throws Exception {\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n        os.close();\n    }\n\n    public String getResponse() throws Exception{\n        StringBuilder response = new StringBuilder();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String line;\n        while ((line = br.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n        br.close();\n        return response.toString();\n    }\n\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write(\"\\r\\n\".getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n\n\n    public interface HttpConnectionRetryHandler {\n        boolean shouldRetry(IOException e);\n    }\n\n    public static class HttpClientException extends Exception {\n        public HttpClientException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that performs an HTTP/HTTPS request with XML data and parses the XML response into a key-value map.\n\nFunction Description: This function sends an HTTP/HTTPS request (GET/POST) to a specified URL with XML data as input, then parses the XML response into a Map<String, Object> where keys are XML element names and values are their text content. The function handles connection setup, request configuration, data transmission, response parsing, and resource cleanup.\n\nInput:\n- requestUrl: String - The target URL for the HTTP request\n- requestMethod: String - The HTTP method to use (e.g., \"GET\" or \"POST\")\n- xmlStr: String - The XML data to send with the request (can be null for GET requests)\n\nOutput:\n- Map<String, Object> - A map containing key-value pairs parsed from the XML response, where keys are XML element names and values are their text content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.HashMap;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic static Map<String, Object> httpXmlRequest(String requestUrl, String requestMethod, String xmlStr) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    try {\n        HttpsURLConnection urlCon = (HttpsURLConnection) (new URL(requestUrl)).openConnection();\n        urlCon.setDoInput(true);\n        urlCon.setDoOutput(true);\n        urlCon.setRequestMethod(requestMethod);\n\n        if (\"GET\".equalsIgnoreCase(requestMethod)) {\n            urlCon.connect();\n        }\n\n        urlCon.setRequestProperty(\"Content-Length\", String.valueOf(xmlStr.getBytes().length));\n        urlCon.setUseCaches(false);\n        if (null != xmlStr) {\n            OutputStream outputStream = urlCon.getOutputStream();\n            outputStream.write(xmlStr.getBytes(\"UTF-8\"));\n            outputStream.flush();\n            outputStream.close();\n        }\n        InputStream inputStream = urlCon.getInputStream();\n        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        SAXReader reader = new SAXReader();\n        Document document = reader.read(inputStreamReader);\n        Element root = document.getRootElement();\n        List<Element> elementList = root.elements();\n        for (Element e : elementList) {\n            map.put(e.getName(), e.getText());\n        }\n        inputStreamReader.close();\n        inputStream.close();\n        inputStream = null;\n        urlCon.disconnect();\n    } catch (MalformedURLException e) {\n        LOG.error(e.getMessage());\n    } catch (IOException e) {\n        LOG.error(e.getMessage());\n    } catch (Exception e) {\n        LOG.error(e.getMessage());\n    }\n    return map;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class XMLHttpRequest {\n\n    public static Map<String, Object> execute(String requestUrl, String requestMethod, String xmlStr) throws Exception {\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(requestMethod);\n        connection.setRequestProperty(\"Content-Type\", \"application/xml\");\n        connection.setDoOutput(requestMethod.equals(\"POST\"));\n\n        if (xmlStr != null && requestMethod.equals(\"POST\")) {\n            byte[] postData = xmlStr.getBytes(StandardCharsets.UTF_8);\n            try (OutputStream os = connection.getOutputStream()) {\n                os.write(postData);\n            }\n        }\n\n        try (InputStream is = connection.getInputStream();\n             BufferedReader br = new BufferedReader(new InputStreamReader(is))) {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(is);\n            return parseXmlToMap(doc.getDocumentElement());\n        }\n    }\n\n    private static Map<String, Object> parseXmlToMap(Element element) {\n        Map<String, Object> map = new HashMap<>();\n        NodeList nodeList = element.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            Node node = nodeList.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element childElement = (Element) node;\n                map.put(childElement.getTagName(), childElement.getTextContent());\n            }\n        }\n        return map;\n    }\n}\n```\n"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    private static class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.connect();\n                InputStream inputStream = connection.getInputStream();\n                String result = ConvertInputToStringNoChange(inputStream);\n                return result;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray jsonArray = new JSONArray(progress[0]);\n                for (int i = 0; i < jsonArray.length(); i++) {\n                    JSONObject jsonObject = jsonArray.getJSONObject(i);\n                    // Process each jsonObject\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n\n        @Override\n        protected void onPostExecute(String result2) {\n            // Handle post execution\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line = null;\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                stringBuilder.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n\n    public static void getNews(String url) {\n        new MyAsyncTask().execute(url);\n    }\n}\n"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\n\npublic class HttpDownloader {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        int redirectCount = 0;\n        String nextUrl = targetUrlString;\n\n        while (redirectCount < MAXIMUM_REDIRECTS) {\n            Optional<String> redirectUrl = getDownloadedOrNextUrl(nextUrl, path, userAgent);\n\n            if (redirectUrl.isEmpty()) {\n                return; // Download successful\n            }\n\n            nextUrl = redirectUrl.get();\n            redirectCount++;\n        }\n\n        throw new IOException(\"Too many redirects\");\n    }\n\n\n    Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n\n            if (!(connection instanceof HttpURLConnection)) {\n                throw new IOException(\"Not an HTTP URL\");\n            }\n\n            HttpURLConnection httpConnection = (HttpURLConnection) connection;\n            httpConnection.setRequestMethod(\"GET\");\n            if (userAgent != null && !userAgent.isEmpty()) {\n                httpConnection.setRequestProperty(\"User-Agent\", userAgent);\n            }\n            httpConnection.setInstanceFollowRedirects(false);\n\n            int responseCode = httpConnection.getResponseCode();\n\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                try (InputStream in = httpConnection.getInputStream()) {\n                    Files.copy(in, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded {} to {}\", urlString, path);\n                }\n                return Optional.empty();\n            } else if (responseCode >= 300 && responseCode < 400) {\n                String location = httpConnection.getHeaderField(\"Location\");\n                if (location == null || location.isEmpty()) {\n                    throw new IOException(\"Redirect without Location header\");\n                }\n                logger.info(\"Redirecting to {}\", location);\n                return Optional.of(location);\n            } else {\n                throw new IOException(\"HTTP error \" + responseCode);\n            }\n\n        } catch (MalformedURLException e) {\n            throw new IOException(\"Invalid URL\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"GET\");\n        return connectionToString(con);\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        return mapper.readTree(getBody(reqURL));\n    }\n\n\n    public static void downloadFile(String reqURL, String fileLocation) throws IOException {\n        try (InputStream in = new URL(reqURL).openStream();\n             FileOutputStream out = new FileOutputStream(fileLocation)) {\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            byte[] input = postContent.getBytes(StandardCharsets.UTF_8);\n            os.write(input, 0, input.length);\n        }\n        return connectionToString(con);\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry<String, String> param : fields.entrySet()) {\n            if (postData.length() != 0) postData.append('&');\n            postData.append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8));\n            postData.append('=');\n            postData.append(URLEncoder.encode(param.getValue(), StandardCharsets.UTF_8));\n        }\n        byte[] postDataBytes = postData.toString().getBytes(StandardCharsets.UTF_8);\n\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-Length\", String.valueOf(postDataBytes.length));\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            os.write(postDataBytes);\n        }\n        return connectionToString(con);\n\n    }\n\n    public static Stream<String> getLineStream(String reqURL) throws IOException {\n        InputStream stream = new URL(reqURL).openStream();\n        return new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8)).lines();\n    }\n\n\n    public static String getUserAgent() {\n        return String.format(\"Java/%s (%s; %s; %s)\",\n                System.getProperty(\"java.version\"),\n                System.getProperty(\"os.name\"),\n                System.getProperty(\"os.arch\"),\n                System.getProperty(\"os.version\")\n        );\n    }\n\n    public static String connectionToString(HttpURLConnection con) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            return content.toString();\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Map;\n\nclass HttpConfig {\n    int connectTimeout;\n    int readTimeout;\n\n    public HttpConfig(int connectTimeout, int readTimeout) {\n        this.connectTimeout = connectTimeout;\n        this.readTimeout = readTimeout;\n    }\n}\n\nclass RealResponse {\n    int responseCode;\n    String responseMessage;\n    String responseBody;\n\n    public RealResponse(int responseCode, String responseMessage, String responseBody) {\n        this.responseCode = responseCode;\n        this.responseMessage = responseMessage;\n        this.responseBody = responseBody;\n    }\n}\n\n\npublic class RealRequest {\n\n    public static String sRequestURL = \"\";\n    private HttpConfig httpConfig = new HttpConfig(10000, 10000);\n    private static final String TAG = \"SA.HttpRequest\";\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            setHeader(conn, headerMap);\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n            setHeader(conn, headerMap);\n            conn.setRequestProperty(\"Content-Type\", bodyType);\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(body);\n            writer.flush();\n            writer.close();\n            os.close();\n            return getRealResponse(conn);\n\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setConnectTimeout(httpConfig.connectTimeout);\n        conn.setReadTimeout(httpConfig.readTimeout);\n        conn.setDoInput(true);\n        if(requestMethod.equals(\"POST\")){\n            conn.setDoOutput(true);\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        String responseMessage = conn.getResponseMessage();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        String inputLine;\n        StringBuilder response = new StringBuilder();\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        return new RealResponse(responseCode, responseMessage, response.toString());\n\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(-1, e.getMessage(), \"\");\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}\n```"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport com.google.android.exoplayer2.upstream.BaseDataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\n\npublic class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n  private final boolean allowCrossProtocolRedirects;\n  private final int connectTimeoutMillis;\n  private final int readTimeoutMillis;\n  private final RequestProperties requestProperties;\n\n  private DataSpec dataSpec;\n  private HttpURLConnection connection;\n  private InputStream inputStream;\n  private boolean opened;\n\n  public YoutubeHttpDataSource(boolean allowCrossProtocolRedirects, int connectTimeoutMillis, int readTimeoutMillis, RequestProperties requestProperties) {\n    super(true);\n    this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;\n    this.connectTimeoutMillis = connectTimeoutMillis;\n    this.readTimeoutMillis = readTimeoutMillis;\n    this.requestProperties = requestProperties;\n  }\n\n\n  @Override\n  public long open(DataSpec dataSpec) throws HttpDataSource.HttpDataSourceException {\n    this.dataSpec = dataSpec;\n    this.opened = true;\n    transferInitializing(dataSpec);\n    try {\n      connection = makeConnection(dataSpec);\n    } catch (IOException e) {\n      throw new HttpDataSource.HttpDataSourceException(\n          e, dataSpec, HttpDataSource.HttpDataSourceException.TYPE_OPEN);\n    }\n\n    int responseCode;\n    try {\n      responseCode = connection.getResponseCode();\n    } catch (IOException e) {\n      closeConnectionQuietly();\n      throw new HttpDataSource.HttpDataSourceException(\n          e, dataSpec, HttpDataSource.HttpDataSourceException.TYPE_OPEN);\n    }\n\n    if (responseCode < 200 || responseCode > 299) {\n      Map<String, java.util.List<String>> headers = connection.getHeaderFields();\n      closeConnectionQuietly();\n      throw new HttpDataSource.InvalidResponseCodeException(\n          responseCode, headers, dataSpec);\n    }\n\n    try {\n      inputStream = connection.getInputStream();\n    } catch (IOException e) {\n      closeConnectionQuietly();\n      throw new HttpDataSource.HttpDataSourceException(\n          e, dataSpec, HttpDataSource.HttpDataSourceException.TYPE_OPEN);\n    }\n\n    long contentLength = -1;\n    String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n    if (!contentLengthHeader.isEmpty()) {\n      try {\n        contentLength = Long.parseLong(contentLengthHeader);\n      } catch (NumberFormatException e) {\n        // Do nothing.\n      }\n    }\n    transferStarted(dataSpec);\n    return contentLength;\n\n  }\n\n  private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {\n    URL url = new URL(dataSpec.uri.toString());\n    int redirectCount = 0;\n    while (redirectCount++ <= 20) {\n      HttpURLConnection connection = openConnection(url);\n      int responseCode = connection.getResponseCode();\n      if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE\n          || responseCode == HttpURLConnection.HTTP_MOVED_PERM\n          || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n          || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n          || (responseCode == HttpURLConnection.HTTP_TEMP_REDIRECT\n          && dataSpec.httpMethod == DataSpec.HTTP_METHOD_POST)) {\n        String location = connection.getHeaderField(\"Location\");\n        connection.disconnect();\n        url = handleRedirect(url, location, dataSpec);\n\n      } else {\n        return connection;\n      }\n    }\n\n    throw new NoRouteToHostException(\"Too many redirects: \" + redirectCount);\n\n  }\n\n\n  private HttpURLConnection openConnection(URL url) throws IOException {\n    return (HttpURLConnection) url.openConnection();\n  }\n\n  private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpec) throws IOException{\n    if (location == null) {\n      throw new ProtocolException(\"Null location redirect\");\n    }\n    URL url = new URL(originalUrl, location);\n\n    String protocol = url.getProtocol();\n    if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n      throw new ProtocolException(\"Unsupported protocol redirect: \" + protocol);\n    }\n\n    boolean isRedirectingToDifferentProtocol = !originalUrl.getProtocol().equals(url.getProtocol());\n    if (!allowCrossProtocolRedirects && isRedirectingToDifferentProtocol) {\n      throw new ProtocolException(\"Disallowed cross-protocol redirect (\"\n          + originalUrl.getProtocol() + \" to \" + url.getProtocol() + \")\");\n    }\n    return url;\n\n  }\n\n\n  @Override\n  public void close() throws HttpDataSource.HttpDataSourceException {\n    try {\n      if (inputStream != null) {\n        maybeTerminateInputStream(connection, bytesRemaining());\n      }\n    } catch (IOException e) {\n      throw new HttpDataSource.HttpDataSourceException(\n          e, dataSpec, HttpDataSource.HttpDataSourceException.TYPE_CLOSE);\n    } finally {\n      inputStream = null;\n      closeConnectionQuietly();\n      if (opened) {\n        opened = false;\n        transferEnded();\n      }\n    }\n  }\n\n  private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining)\n      throws IOException {\n    if (Util.SDK_INT < 21) {\n      return;\n    }\n\n    try {\n      connection.getInputStream().close();\n    } catch (IOException e) {\n\n    }\n\n  }\n\n  private void closeConnectionQuietly() {\n    if (connection != null) {\n      try {\n        connection.disconnect();\n      } catch (Exception e) {\n\n      }\n      connection = null;\n    }\n  }\n\n\n  @Override\n  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource.HttpDataSourceException {\n    return 0;\n  }\n\n  @Override\n  public Map<String, List<String>> getResponseHeaders() {\n    return null;\n  }\n\n\n  @Override\n  public Uri getUri() {\n    return null;\n  }\n}\n```"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Java class that implements a RESTful client using HttpURLConnection to perform HTTP requests (GET, POST, PUT) and handle responses.\n\nClass Description: The `RestfulClient` class provides methods to execute HTTP requests (GET, POST, PUT) to a specified URL and process the responses. It handles connection setup, request parameter configuration, input/output stream management, and connection cleanup.\n\nAttributes: None\n\nMethods:\n\nMethod1: `get(String path) -> String` - Executes a GET request to the specified URL path and returns the response as a String.  \nMethod2: `post(String path, String requestBody) -> String` - Executes a POST request to the specified URL path with the provided request body and returns the response as a String.  \nMethod3: `put(String path, String requestBody) -> String` - Executes a PUT request to the specified URL path with the provided request body and returns the response as a String.  \nMethod4: `executeRequest(String method, String path, String requestBody) -> String` - Internal helper method that handles the common logic for executing HTTP requests (connection setup, request configuration, and response processing).  \nMethod5: `getVal(RestfulRequest request) -> String` - Executes a custom HTTP request based on the provided `RestfulRequest` object (containing URL, method, and parameters) and returns the response as a String.  \n\nInput:  \n- For `get`, `post`, and `put`:  \n  - `path` (String): The target URL for the HTTP request.  \n  - `requestBody` (String, optional for POST/PUT): The request payload in JSON format.  \n- For `getVal`:  \n  - `request` (RestfulRequest): An object encapsulating the request details (URL, HTTP method, and parameters).  \n\nOutput:  \n- String: The response body from the HTTP request, or `null` if an error occurs.",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody){\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(path);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes();\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            if (connection.getResponseCode() == 200) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String inputLine;\n                    StringBuilder response = new StringBuilder();\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    return response.toString();\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n    public String getVal(RestfulRequest request) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(request.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(request.getMethod());\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \" application/json\");\n            byte[] content = request.getParam().getBytes();\n            connection.setRequestProperty(\"Content-Length\", content.length + \"\");\n\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.connect();\n            OutputStream out = connection.getOutputStream();\n            out.write(content);\n            out.flush();\n            out.close();\n\n            if (connection.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n\nclass RestfulRequest {\n    public String url;\n    public String method;\n    public Map<String, String> params;\n\n    public RestfulRequest(String url, String method, Map<String, String> params) {\n        this.url = url;\n        this.method = method;\n        this.params = params;\n    }\n}\n\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n\n    private String executeRequest(String method, String path, String requestBody) {\n        try {\n            URL url = new URL(path);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                connection.setRequestProperty(\"Content-Type\", \"application/json\");\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes(StandardCharsets.UTF_8);\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            try (InputStream inputStream = connection.getInputStream();\n                 BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public String getVal(RestfulRequest request) {\n        return executeRequest(request.method, request.url, null); // Simplified for demonstration\n    }\n}\n```\n"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a WebSocket client using Java Netty framework that can establish a connection to a WebSocket server, send and receive frames, and handle connection lifecycle events.\n\nClass Description: WebSocketTestClient is a Netty-based WebSocket client implementation that handles WebSocket connections, frame transmission, and connection management. It supports different WebSocket versions and provides callback mechanisms for frame handling.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- ch: [Channel] - Active channel representing the WebSocket connection\n- uri: [URI] - Target WebSocket server URI\n- version: [WebSocketVersion] - WebSocket protocol version to use\n- closed: [boolean] - Connection status flag\n- count: [AtomicInteger] - Counter for handler naming\n\nMethods:\n- connect(): [WebSocketTestClient] - Establishes connection to WebSocket server, performs handshake, and returns self for chaining\n- send(WebSocketFrame frame, FrameListener listener): [WebSocketTestClient] - Sends WebSocket frame and registers listener for response, returns self for chaining\n- destroy(): [void] - Gracefully closes connection and releases resources\n- destroy(boolean dirty): [void] - Closes connection with option for immediate termination\n- isActive(): [boolean] - Returns connection active status\n- isOpen(): [boolean] - Returns connection open status\n- isWritable(): [boolean] - Returns channel writable status\n\nNested Interfaces:\n- FrameListener: Callback interface for frame reception and error handling\n  - onFrame(WebSocketFrame frame): [void] - Called when frame is received\n  - onError(Throwable t): [void] - Called when error occurs\n\nNested Classes:\n- WSClientHandler: [SimpleChannelInboundHandler<Object>] - Internal handler for WebSocket handshake and frame processing\n  - handshakeFuture(): [ChannelFuture] - Returns handshake completion future\n  - handlerAdded(ChannelHandlerContext ctx): [void] - Initializes handshake promise\n  - channelActive(ChannelHandlerContext ctx): [void] - Initiates handshake\n  - channelRead0(ChannelHandlerContext ctx, Object o): [void] - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext ctx, Throwable cause): [void] - Handles channel errors",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic final class WebSocketTestClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private static final AtomicInteger count = new AtomicInteger();\n\n    public WebSocketTestClient(WebSocketVersion version, URI uri) {\n        this.uri = uri;\n        this.version = version;\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        String protocol = uri.getScheme();\n        if (!\"ws\".equals(protocol)) {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + protocol);\n        }\n        final WebSocketClientHandshaker handshaker =\n                WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n        WSClientHandler handler = new WSClientHandler(handshaker);\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception {\n                        ChannelPipeline p = channel.pipeline();\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192), handler);\n                    }\n                });\n\n        ChannelFuture future =\n                bootstrap.connect(\n                        new InetSocketAddress(uri.getHost(), uri.getPort()));\n        future.syncUninterruptibly();\n        handler.handshakeFuture.syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {\n        ch.pipeline().addLast(\"responseHandler\" + count.incrementAndGet(), new SimpleChannelInboundHandler<Object>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof CloseWebSocketFrame) {\n                    closed = true;\n                }\n                listener.onFrame((WebSocketFrame) msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                cause.printStackTrace();\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ChannelFuture cf = ch.writeAndFlush(frame).syncUninterruptibly();\n        if (!cf.isSuccess()) {\n            listener.onError(cf.cause());\n        }\n        return this;\n    }\n\n    public void destroy() {\n        this.destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed && !dirty) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            send(new CloseWebSocketFrame(), new FrameListener() {\n                @Override\n                public void onFrame(WebSocketFrame frame) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    latch.countDown();\n                }\n            });\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n        }\n        try {\n            bootstrap.group().shutdownGracefully(0, 1, TimeUnit.SECONDS).get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean isActive() {\n        return this.ch != null && this.ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return this.ch != null && this.ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return this.ch != null && this.ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static final class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WSClientHandler(WebSocketClientHandshaker handshaker) {\n            super(false);\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object o) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                ReferenceCountUtil.release(o);\n                return;\n            }\n\n            if (o instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) o;\n                ReferenceCountUtil.release(o);\n                throw new Exception(\"Unexpected HttpResponse (status=\" + response.getStatus() + \", content=\"\n                        + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport java.net.URI;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class WebSocketTestClient {\n\n    private final Bootstrap bootstrap;\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    public WebSocketTestClient(URI uri, WebSocketVersion version) {\n        this.uri = uri;\n        this.version = version;\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        String protocol = uri.getScheme();\n                        if (\"wss\".equals(protocol)) {\n                            SslContext sslCtx = SslContextBuilder.forClient()\n                                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), uri.getPort()));\n                        }\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192),\n                                new WSClientHandler(WebSocketClientHandshakerFactory.newHandshaker(\n                                        uri, version, null, true, null, Integer.MAX_VALUE)));\n                    }\n                });\n    }\n\n    public WebSocketTestClient connect() {\n        try {\n            ChannelFuture future = bootstrap.connect(uri.getHost(), uri.getPort()).sync();\n            ch = future.channel();\n            WSClientHandler handler = ch.pipeline().get(WSClientHandler.class);\n            handler.handshakeFuture().sync();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, FrameListener listener) {\n        ch.pipeline().addLast(\"listener\" + count.incrementAndGet(), new SimpleChannelInboundHandler<WebSocketFrame>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame msg) {\n                listener.onFrame(msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ch.writeAndFlush(frame);\n        return this;\n    }\n\n\n    public void destroy() {\n        destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (ch != null) {\n            if (dirty) {\n                ch.close();\n            } else {\n                ch.writeAndFlush(new CloseWebSocketFrame()).addListener(ChannelFutureListener.CLOSE);\n            }\n        }\n        closed = true;\n    }\n\n    public boolean isActive() {\n        return ch != null && ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return ch != null && ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return ch != null && ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        public WSClientHandler(WebSocketClientHandshaker handshaker) {\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, Object o) {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                return;\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            handshakeFuture.setFailure(cause);\n            ctx.close();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Java class that provides functionality for interacting with files using Java NIO's FileChannel and memory-mapped file operations. The class should support opening files, mapping files to memory, accessing mapped buffers, forcing writes to disk, and properly closing resources.\n\nClass Description: The FileChannelInteractor class encapsulates operations for file channel interaction and memory-mapped file operations using Java NIO. It provides methods to open files, map file regions to memory, access mapped buffers, ensure data persistence, and clean up resources.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedBuffer: MappedByteBuffer - The buffer representing the memory-mapped file region\n\nMethods:\nopenFileChannel: openFileChannel(String filePath) -> void - Opens a FileChannel for reading the specified file. Throws IOException if the file cannot be opened.\nmapFileToMemory: mapFileToMemory(long position, long size) -> void - Maps a region of the file into memory for read-only access. Throws IOException if mapping fails.\ngetMappedBuffer: getMappedBuffer() -> MappedByteBuffer - Returns the currently mapped byte buffer.\ncloseChannel: closeChannel() -> void - Closes the FileChannel and releases associated resources. Throws IOException if closing fails.\nforceWriteToDisk: forceWriteToDisk() -> void - Forces any changes made to the mapped buffer to be written to disk (though in this implementation the buffer is read-only).",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        Path path = Paths.get(filePath);\n        this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return this.mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (this.fileChannel != null) {\n            this.fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (this.mappedBuffer != null) {\n            this.mappedBuffer.force();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n        fileChannel = file.getChannel();\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (mappedBuffer != null) {\n            mappedBuffer.force();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Implement a TCP client using Java Netty framework that can maintain persistent connections to multiple hosts and send messages to them.\n\nClass Description: This class provides functionality to initialize and manage Netty TCP client connections to multiple hosts. It maintains a connection pool using maps to store active channels and their associated event loop groups.\n\nAttributes:\n- channelMap: Map<String, Channel> - Stores active channels mapped by host address\n- groupMap: Map<String, NioEventLoopGroup> - Stores event loop groups mapped by host address\n\nMethods:\n- initSocketClientAndSendMessage(String host, String message) -> Channel - Initializes a new TCP client connection to the specified host if one doesn't exist, or reuses an existing connection. Sends the provided message to the host. Returns the Channel object for the connection.\n  - Input Parameters:\n    - host: String - The host address to connect to\n    - message: String - The message to be sent to the host\n  - Return Type: Channel - The Netty Channel object representing the connection",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic static Map<String, Channel> channelMap;\npublic static Map<String, NioEventLoopGroup> groupMap;\n\n@Override\npublic Channel initSocketClientAndSendMessage(String host, String message) throws Exception {\n    if(channelMap==null){\n        channelMap = new HashMap<>();\n    }\n    if(groupMap==null){\n        groupMap = new HashMap<>();\n    }\n\n    if(channelMap.get(host)==null){\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, 9003))\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new StringEncoder(Charset.forName(\"GBK\")));\n                        ch.pipeline().addLast(new ByteArrayEncoder());\n                        ch.pipeline().addLast(new ChunkedWriteHandler());\n                    }\n                });\n            ChannelFuture cf = b.connect();\n            channelMap.put(host, cf.channel());\n            groupMap.put(host, group);\n            return null;\n        } catch (Exception e){\n            group.shutdownGracefully().sync();\n            return null;\n        }\n    }else{\n        channelMap.get(host).writeAndFlush(StringTools.hexStringToBytes(message));\n        return channelMap.get(host);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NettyTcpClient {\n\n    private Map<String, Channel> channelMap = new HashMap<>();\n    private Map<String, NioEventLoopGroup> groupMap = new HashMap<>();\n\n    public Channel initSocketClientAndSendMessage(String host, String message) throws InterruptedException {\n        int port = 8080; // Default port\n        String[] hostParts = host.split(\":\");\n        if (hostParts.length == 2) {\n            host = hostParts[0];\n            port = Integer.parseInt(hostParts[1]);\n        }\n        String key = host + \":\" + port;\n\n        Channel channel = channelMap.get(key);\n        if (channel != null && channel.isActive()) {\n            channel.writeAndFlush(message + \"\\n\");\n            return channel;\n        }\n\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n        groupMap.put(key, workerGroup);\n\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new StringDecoder());\n                        pipeline.addLast(new StringEncoder());\n                        pipeline.addLast(new SimpleChannelInboundHandler<String>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                                System.out.println(\"Received from server: \" + msg);\n                            }\n                        });\n                    }\n                });\n\n        ChannelFuture future = bootstrap.connect(host, port).sync();\n        channel = future.channel();\n        channelMap.put(key, channel);\n        channel.writeAndFlush(message + \"\\n\");\n        return channel;\n    }\n}\n"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket client proxy using Netty framework to establish and manage WebSocket connections to a remote server.\n\nClass Description: The WebsocketProxy class implements the Proxy interface and provides functionality to connect to a WebSocket server using Netty's non-blocking I/O. It handles WebSocket protocol negotiation, connection management, and graceful shutdown of resources.\n\nAttributes: (This class doesn't have any explicit attributes as it's primarily focused on connection management)\n\nMethods:\n1: connect(String serverAddress, int port) -> void - Establishes a WebSocket connection to the specified server address and port. The method:\n   - Creates a WebSocket URI using the provided address and port\n   - Initializes Netty's event loop group and bootstrap\n   - Configures the channel pipeline with necessary handlers (idle state, HTTP codec, WebSocket protocol)\n   - Connects to the server and waits for the connection to close\n   - Ensures proper resource cleanup on shutdown\n   Throws InterruptedException if the connection is interrupted and URISyntaxException if the URI is malformed\n\nInput:\n- serverAddress: String - The IP address or hostname of the WebSocket server\n- port: int - The port number on which the WebSocket server is listening\n\nOutput: None (void) - The method establishes a persistent connection that remains open until closed by either end",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.client.handler.WebsocketTransferHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void connect(String serverAddress, int port) throws InterruptedException, URISyntaxException {\n        URI uri = new URI(\"ws://\" + serverAddress + \":\" + port + \"/ratel\");\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpClientCodec())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(new WebSocketClientProtocolHandler(uri\n                                            , WebSocketVersion.V13\n                                            , null\n                                            , true\n                                            , new DefaultHttpHeaders(), 100000))\n                                    .addLast(\"ws\", new WebsocketTransferHandler());\n                        }\n                    });\n            SimplePrinter.printNotice(\"Connecting to \" + serverAddress + \":\" + port);\n            Channel channel = bootstrap.connect(serverAddress, port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": ""
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Implement a Netty-based TCP client for tracking device communication that supports secure connections and periodic reconnection.\n\nClass Description: The TrackerClient class is an abstract implementation of a TCP client using Netty framework for communicating with tracking devices. It handles secure connections (SSL/TLS), manages connection lifecycle, and supports periodic reconnection. The class serves as a base for specific protocol implementations.\n\nAttributes:\n- secure: [boolean] - Indicates whether SSL/TLS encryption should be used\n- interval: [long] - Reconnection interval in seconds (0 means no reconnection)\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- port: [int] - Target server port number\n- address: [String] - Target server address\n- devices: [String[]] - Array of device identifiers to track\n- channelGroup: [ChannelGroup] - Manages all active channels\n\nMethods:\n- TrackerClient([Config] config, [String] protocol) -> [void] - Constructor that initializes the client with configuration and protocol settings\n- addProtocolHandlers([PipelineBuilder] pipeline, [Config] config) -> [void] - Abstract method to be implemented by subclasses for protocol-specific handlers\n- start() -> [void] - Starts the client and establishes connection to server\n- stop() -> [void] - Stops the client and closes all connections\n- isDatagram() -> [boolean] - Returns false indicating this is a TCP client\n- isSecure() -> [boolean] - Returns whether SSL/TLS is enabled\n- getDevices() -> [String[]] - Returns array of device identifiers\n- getChannelGroup() -> [ChannelGroup] - Returns the channel group managing all connections",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class TrackerClient implements TrackerConnector {\n\n    private final boolean secure;\n    private final long interval;\n    private final Bootstrap bootstrap;\n    private final int port;\n    private final String address;\n    private final String[] devices;\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    public TrackerClient(Config config, String protocol) {\n        secure = config.getBoolean(Keys.PROTOCOL_SSL.withPrefix(protocol));\n        interval = config.getLong(Keys.PROTOCOL_INTERVAL.withPrefix(protocol));\n        address = config.getString(Keys.PROTOCOL_ADDRESS.withPrefix(protocol));\n        port = config.getInteger(Keys.PROTOCOL_PORT.withPrefix(protocol), secure ? 443 : 80);\n        devices = config.getString(Keys.PROTOCOL_DEVICES.withPrefix(protocol)).split(\"[, ]\");\n\n        BasePipelineFactory pipelineFactory = new BasePipelineFactory(this, config, protocol) {\n            @Override\n            protected void addTransportHandlers(PipelineBuilder pipeline) {\n                try {\n                    if (isSecure()) {\n                        SSLEngine engine = SSLContext.getDefault().createSSLEngine();\n                        engine.setUseClientMode(true);\n                        pipeline.addLast(new SslHandler(engine));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            @Override\n            protected void addProtocolHandlers(PipelineBuilder pipeline) {\n                try {\n                    TrackerClient.this.addProtocolHandlers(pipeline, config);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n\n        bootstrap = new Bootstrap()\n                .group(EventLoopGroupFactory.getWorkerGroup())\n                .channel(NioSocketChannel.class)\n                .handler(pipelineFactory);\n    }\n\n    protected abstract void addProtocolHandlers(PipelineBuilder pipeline, Config config) throws Exception;\n\n    @Override\n    public void start() throws Exception {\n        bootstrap.connect(address, port)\n                .syncUninterruptibly().channel().closeFuture().addListener(new GenericFutureListener<>() {\n                    @Override\n                    public void operationComplete(Future<? super Void> future) {\n                        if (interval > 0) {\n                            GlobalEventExecutor.INSTANCE.schedule(() -> {\n                                bootstrap.connect(address, port)\n                                        .syncUninterruptibly().channel().closeFuture().addListener(this);\n                            }, interval, TimeUnit.SECONDS);\n                        }\n                    }\n                });\n    }\n\n    @Override\n    public void stop() {\n        channelGroup.close().awaitUninterruptibly();\n    }\n\n    @Override\n    public boolean isDatagram() {\n        return false;\n    }\n\n    @Override\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    @Override\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.concurrent.GlobalEventExecutor;\n\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class TrackerClient {\n\n    protected final boolean secure;\n    protected final long interval;\n    protected final Bootstrap bootstrap;\n    protected final int port;\n    protected final String address;\n    protected final String[] devices;\n    protected final ChannelGroup channelGroup;\n\n    public TrackerClient(Config config, String protocol) {\n        this.secure = config.getBoolean(\"secure\");\n        this.interval = config.getLong(\"interval\") * 1000;\n        this.port = config.getInt(\"port\");\n        this.address = config.getString(\"address\");\n        this.devices = config.getString(\"devices\").split(\",\");\n        this.channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class);\n\n        PipelineBuilder pipeline = new PipelineBuilder(config, protocol);\n        addProtocolHandlers(pipeline, config);\n        bootstrap.handler(pipeline.build());\n    }\n\n    public abstract void addProtocolHandlers(PipelineBuilder pipeline, Config config);\n\n    public void start() {\n        connect();\n    }\n\n    public void stop() {\n        channelGroup.close().syncUninterruptibly();\n    }\n\n    private void connect() {\n        SslContext sslCtx = null;\n        if (secure) {\n            try {\n                sslCtx = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n            } catch (Exception e) {\n                e.printStackTrace();\n                return;\n            }\n        }\n\n        ChannelFuture future = bootstrap.connect(address, port);\n        future.addListener((ChannelFutureListener) f -> {\n            if (f.isSuccess()) {\n                channelGroup.add(f.channel());\n                System.out.println(\"Connected to \" + address + \":\" + port);\n            } else {\n                System.out.println(\"Failed to connect to \" + address + \":\" + port + \", retrying in \" + interval / 1000 + \" seconds...\");\n                f.channel().eventLoop().schedule(this::connect, interval, TimeUnit.MILLISECONDS);\n            }\n        });\n    }\n\n\n    public boolean isDatagram() {\n        return false;\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n\n    // Dummy Config and PipelineBuilder classes for compilation\n    static class Config {\n        public boolean getBoolean(String key) { return false; }\n        public long getLong(String key) { return 0; }\n        public int getInt(String key) { return 0; }\n        public String getString(String key) { return \"\"; }\n    }\n    static class PipelineBuilder {\n        public PipelineBuilder(Config config, String protocol) {}\n        public Object build() { return null; }\n    }\n}\n"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.FutureResult;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport javax.net.ssl.SSLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient {\n\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group;\n    private final Bootstrap b;\n    private final Queue<HttpObject> responseParts = new LinkedList<>();\n    private final AtomicBoolean callbackInvoked = new AtomicBoolean();\n    private final CommunicationHandler communicationHandler = new CommunicationHandler();\n    private AtomicBoolean isOpen = new AtomicBoolean(false);\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n\n    public NettyClient(String hostname, int port, SslContext sslContext) {\n        this.hostname = hostname;\n        this.port = port;\n        group = new NioEventLoopGroup();\n        b = new Bootstrap();\n        b.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslContext != null) {\n                            p.addLast(sslContext.newHandler(ch.alloc(), hostname, port));\n                        }\n                        p.addLast(new HttpClientCodec());\n                        p.addLast(new HttpObjectAggregator(Integer.MAX_VALUE));\n                        p.addLast(communicationHandler);\n                    }\n                });\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        this.request = request;\n        this.content = content;\n        this.callback = callback;\n        this.responseFuture = new FutureResult<>();\n        resetState();\n        createChannel();\n        return responseFuture;\n    }\n\n    public void close() {\n        group.shutdownGracefully();\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        exception = null;\n        isKeepAlive = false;\n    }\n\n    private void createChannel() {\n        if (!isOpen.getAndSet(true)) {\n            channelConnectFuture = b.connect(hostname, port);\n            channelConnectFuture.addListener((GenericFutureListener<Future<? super Void>>) future -> {\n                if (future.isSuccess()) {\n                    Channel channel = channelConnectFuture.channel();\n                    channel.writeAndFlush(request);\n                    if (content != null) {\n                        channel.writeAndFlush(content);\n                    }\n                } else {\n                    exception = (Exception) future.cause();\n                    invokeFutureAndCallback(\"Connection Failed\");\n                }\n            });\n        }\n    }\n\n\n    private void invokeFutureAndCallback(String context) {\n        if (!callbackInvoked.getAndSet(true)) {\n            ResponseParts response = new ResponseParts(responseParts, context, exception);\n            responseFuture.setSuccess(response);\n            if (callback != null) {\n                callback.onResponse(response);\n            }\n            if (!isKeepAlive) {\n                channelConnectFuture.channel().close();\n                isOpen.set(false);\n            }\n        }\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                isKeepAlive = HttpUtil.isKeepAlive(response);\n            }\n            responseParts.add(msg);\n            if (msg instanceof LastHttpContent) {\n                invokeFutureAndCallback(\"Request Completed\");\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            exception = new Exception(cause);\n            invokeFutureAndCallback(\"Exception Caught\");\n        }\n    }\n\n    public interface Callback<T> {\n        void onResponse(T response);\n    }\n\n    public static class ResponseParts {\n        public final Queue<HttpObject> parts;\n        public final String context;\n        public final Exception exception;\n\n        public ResponseParts(Queue<HttpObject> parts, String context, Exception exception) {\n            this.parts = parts;\n            this.context = context;\n            this.exception = exception;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.nio.ByteBuffer;\n\npublic class FileChannelProcessor {\n\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Long> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        for (long i = 0; i < chunkSize; i += 4) { \n            int value = chunk.getInt((int) i);\n            ByteBuffer key = ByteBuffer.allocate(4).putInt(0);\n            key.rewind();\n            chunk.position((int)i);\n            key.put(chunk.get());\n            key.put(chunk.get());\n            key.put(chunk.get());\n            key.put(chunk.get());\n            key.rewind();\n\n\n            mins.compute(key, (k, v) -> v == null ? value : Math.min(v, value));\n            maxs.compute(key, (k, v) -> v == null ? value : Math.max(v, value));\n            sums.compute(key, (k, v) -> v == null ? (long) value : v + value);\n            counts.compute(key, (k, v) -> v == null ? 1 : v + 1);\n        }\n    }\n\n\n    public void processFile(Path filePath) throws IOException {\n        long fileSize = Files.size(filePath);\n        long chunkSize = Integer.MAX_VALUE; \n\n        try (FileChannel channel = FileChannel.open(filePath, StandardOpenOption.READ)) {\n            for (long position = 0; position < fileSize; position += chunkSize) {\n                long remaining = Math.min(chunkSize, fileSize - position);\n                MappedByteBuffer chunk = channel.map(FileChannel.MapMode.READ_ONLY, position, remaining);\n                processChunk(chunk, remaining);\n            }\n        }\n    }\n\n\n    public ConcurrentHashMap<ByteBuffer, Integer> getMins() {\n        return mins;\n    }\n\n    public ConcurrentHashMap<ByteBuffer, Integer> getMaxs() {\n        return maxs;\n    }\n\n    public ConcurrentHashMap<ByteBuffer, Long> getSums() {\n        return sums;\n    }\n\n    public ConcurrentHashMap<ByteBuffer, Integer> getCounts() {\n        return counts;\n    }\n}\n"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.ServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass = NioServerSocketChannel.class;\n    private int nettySoBacklog = 128;\n    private boolean nettySoReuseaddr = true;\n    private boolean nettyTcpNodelay = true;\n    private boolean nettySoKeepalive = true;\n    private int nettyChannelTimeoutSeconds = 10;\n\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        m_bossGroup = new NioEventLoopGroup();\n        m_workerGroup = new NioEventLoopGroup();\n        initializePlainTCPTransport(new NettyMQTTHandler(processor, props), props);\n    }\n\n\n    private void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(m_bossGroup, m_workerGroup).channel(channelClass)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                            ch.pipeline().addLast(\"decoder\", new MqttDecoder());\n                            ch.pipeline().addLast(\"encoder\", MqttEncoder.INSTANCE);\n                            ch.pipeline().addLast(\"handler\", handler);\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n                    .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n                    .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n                    .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n            ChannelFuture f = b.bind(Integer.parseInt(props.getProperty(\"port\"))).sync();\n            LOG.info(\"Server bound to port {}\", props.getProperty(\"port\"));\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            LOG.error(\"Plain TCP transport initialization interrupted.\", e);\n        }\n    }\n\n\n    public void close() {\n        if (m_workerGroup == null || m_bossGroup == null) {\n            LOG.error(\"Netty acceptor is not initialized.\");\n            return;\n        }\n        m_workerGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS);\n        m_bossGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS);\n        LOG.info(\"Netty acceptor closed.\");\n    }\n}\n\ninterface ProtocolProcessor {}\ninterface IConfig { String getProperty(String s); }\ninterface ISslContextCreator {}\nclass NettyMQTTHandler extends ChannelInboundHandlerAdapter {}\n\nimport io.netty.channel.ChannelInboundHandlerAdapter;\n\n```\n"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Java class that provides memory-mapped file access capabilities and process spawning functionality for inter-process communication scenarios.\n\nClass Description: FileChannelInteractor is a utility class that handles memory-mapped file operations and process management. It allows read-only memory mapping of files and provides functionality to spawn worker processes for IPC scenarios.\n\nAttributes:\n- fileChannel: FileChannel - The NIO FileChannel used for file operations\n- mapAddress: long - The memory address of the mapped file region\n- fileSize: long - The size of the mapped file in bytes\n\nMethods:\n- FileChannelInteractor(String filePath) -> void - Constructor that opens a file channel and maps the file into memory in read-only mode\n- getMemoryMappedAddress() -> long - Returns the memory address of the mapped file region\n- getFileSize() -> long - Returns the size of the mapped file\n- close() -> void - Closes the file channel and releases system resources\n- spawnWorkerProcess() -> void - Static method that spawns a worker process with the same command and arguments as the current process, adding a \"--worker\" flag",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mapAddress = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        fileChannel.close();\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        ProcessHandle.Info info = ProcessHandle.current().info();\n        ArrayList<String> workerCommand = new ArrayList<>();\n        info.command().ifPresent(workerCommand::add);\n        info.arguments().ifPresent(args -> workerCommand.addAll(Arrays.asList(args)));\n        workerCommand.add(\"--worker\");\n        new ProcessBuilder()\n                .command(workerCommand)\n                .inheritIO()\n                .redirectOutput(ProcessBuilder.Redirect.PIPE)\n                .start()\n                .getInputStream()\n                .transferTo(System.out);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.reflect.Field;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n        this.fileChannel = file.getChannel();\n        this.fileSize = fileChannel.size();\n        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n\n        try {\n            Field addressField = buffer.getClass().getDeclaredField(\"address\");\n            addressField.setAccessible(true);\n            this.mapAddress = addressField.getLong(buffer);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            throw new RuntimeException(\"Unable to get memory address\", e);\n        }\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        String javaExecutable = System.getProperty(\"java.home\") + java.io.File.separator + \"bin\" + java.io.File.separator + \"java\";\n        String classpath = System.getProperty(\"java.class.path\");\n        String className = System.getProperty(\"sun.java.command\");\n\n        ProcessBuilder builder = new ProcessBuilder(javaExecutable, \"-cp\", classpath, className, \"--worker\");\n\n        builder.inheritIO();\n        builder.start();\n    }\n}\n"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.DataOutput;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\npublic abstract class TransferType {\n\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n\n    public TransferType(String path, DataStream cli) throws IOException {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(remaining, bufferSize);\n    }\n\n    public boolean isSync(long position) {\n        return (position - syncPosition) >= syncSize;\n    }\n\n    public abstract List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable) throws Exception;\n\n    public abstract long write(FileChannel in, DataOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", file=\" + file +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                \", syncPosition=\" + syncPosition +\n                '}';\n    }\n\n    interface DataStream {\n        int getBufferSize();\n        long getSyncSize();\n    }\n\n    interface DataStreamReply {}\n\n    interface FileStoreClient {}\n\n    interface RoutingTable {}\n\n}\n"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a Java class that implements a UDP client using Netty framework for sending and receiving datagram packets. The client should be able to start a connection, send messages to a specified host and port, handle console input for sending messages, and gracefully shutdown the connection.\n\nClass Description: DatagramChannelEchoClient is a Netty-based UDP client that establishes a connection to a specified host and port, sends messages via UDP datagrams, and can be controlled through console input. It manages network resources efficiently and provides clean shutdown capabilities.\n\nAttributes:\n- host: String - The target host address to which messages will be sent\n- port: int - The target port number on the host\n- group: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - The Netty channel used for UDP communication\n\nMethods:\n- DatagramChannelEchoClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the UDP client by initializing Netty components and binding to the port\n- sendMessage(String message) -> void - Sends a message to the configured host and port via UDP\n- stop() -> void - Gracefully shuts down the client and releases resources\n- runConsoleInput() -> void - Reads input from console and sends it as messages until terminated",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\n\npublic final class DatagramChannelEchoClient {\n\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioDatagramChannel.class)\n         .option(ChannelOption.SO_BROADCAST, true)\n         .handler(new DatagramChannelEchoClientHandler());\n\n        ChannelFuture f = b.bind(port).sync();\n        channel = f.channel();\n        System.out.println(\"DatagramChannelEchoClient\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        io.netty.buffer.ByteBuf buf = io.netty.buffer.Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(new io.netty.channel.socket.DatagramPacket(\n            buf, new InetSocketAddress(host, port)));\n        writeBuffer.clear();\n    }\n\n    public void stop() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void runConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + host);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + host);\n            System.exit(1);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramPacket;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.util.CharsetUtil;\nimport java.net.InetSocketAddress;\nimport java.util.Scanner;\n\npublic class DatagramChannelEchoClient {\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                    .channel(NioDatagramChannel.class)\n                    .option(ChannelOption.SO_BROADCAST, true)\n                    .handler(new SimpleChannelInboundHandler<DatagramPacket>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {\n                            String response = msg.content().toString(CharsetUtil.UTF_8);\n                            System.out.println(\"Received: \" + response);\n                        }\n                    });\n            channel = b.connect(host, port).sync().channel();\n            runConsoleInput();\n        } finally {\n            stop();\n        }\n    }\n\n    public void sendMessage(String message) {\n        channel.writeAndFlush(new DatagramPacket(Unpooled.copiedBuffer(message, CharsetUtil.UTF_8), new InetSocketAddress(host, port)));\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private void runConsoleInput() {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Enter message (or 'quit' to exit): \");\n            String input = scanner.nextLine();\n            if (\"quit\".equals(input)) {\n                break;\n            }\n            sendMessage(input);\n        }\n        scanner.close();\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        String host = \"127.0.0.1\";\n        int port = 7686;\n        new DatagramChannelEchoClient(host, port).start();\n\n    }\n}\n"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class WidgetUtil {\n\n    public static final String WIDGET_URL = \"https://discord.com/api/guilds/%d/widget.json\";\n\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    public static Widget getWidget(long guildId) {\n        String url = String.format(WIDGET_URL, guildId);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(url)).GET().build();\n\n        try {\n            HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());\n            int statusCode = response.statusCode();\n\n            if (statusCode == 200) {\n                return objectMapper.readValue(response.body(), Widget.class);\n            } else if (statusCode == 404 || statusCode == 403) {\n                return null;\n            } else if (statusCode == 429) {\n                throw new RateLimitedException(\"Rate limited while fetching widget data.\");\n            } else {\n                throw new UncheckedIOException(new IOException(\"Unexpected HTTP status code: \" + statusCode));\n            }\n        } catch (IOException | InterruptedException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n\n    public static class Widget {\n        // Add necessary fields here based on the widget JSON structure\n    }\n\n    public static class RateLimitedException extends RuntimeException {\n        public RateLimitedException(String message) {\n            super(message);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.util.concurrent.TimeUnit;\n\nimport okhttp3.*;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\n\npublic class HttpClient {\n\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS = new FallBackDNS();\n\n\n    static {\n        OkHttpClient.Builder builder = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS);\n\n        OkHttpClient.Builder builderWithCache = builder.clone()\n                .cache(new Cache(null, 10 * 1024 * 1024));\n\n\n        if (System.getProperty(\"http.proxyHost\") != null && System.getProperty(\"http.proxyPort\") != null) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(System.getProperty(\"http.proxyHost\"), Integer.parseInt(System.getProperty(\"http.proxyPort\"))));\n            builder.proxy(proxy);\n            builderWithCache.proxy(proxy);\n        }\n\n\n        httpClient = builder.dns(fallbackDNS).build();\n\n        builder.dns(fallbackDNS.getDoHDns(fallbackDNS));\n        httpClientDoH = builder.build();\n\n        httpClientWithCache = builderWithCache.dns(fallbackDNS).build();\n\n        builderWithCache.dns(fallbackDNS.getDoHDns(fallbackDNS));\n        httpClientWithCacheDoH = builderWithCache.build();\n\n    }\n\n    private static OkHttpClient getHttpClient(boolean doh) {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    private static OkHttpClient getHttpClientWithCache(boolean doh) {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n\n    public static byte[] doHttpGet(String url, boolean allowCache, boolean doh) throws IOException {\n        Request.Builder requestBuilder = new Request.Builder().url(url).get();\n        if (!allowCache) {\n            requestBuilder.cacheControl(CacheControl.FORCE_NETWORK);\n        }\n        Request request = requestBuilder.build();\n        try (Response response = getHttpClientWithCache(doh).newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                checkNeedCaptchaAndroidacy(url, response.code());\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            return response.body().bytes();\n        }\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache, boolean doh) throws IOException {\n        RequestBody body = new JsonRequestBody(data);\n        Request.Builder requestBuilder = new Request.Builder().url(url).post(body);\n\n        if (!allowCache) {\n            requestBuilder.cacheControl(CacheControl.FORCE_NETWORK);\n        }\n\n        Request request = requestBuilder.build();\n\n        try (Response response = getHttpClientWithCache(doh).newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                checkNeedCaptchaAndroidacy(url, response.code());\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            return response.body().bytes();\n        }\n    }\n\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (url.contains(\"androidacy.com\") && errorCode >= 400) {\n\n        }\n    }\n\n    static class JsonRequestBody extends RequestBody {\n        private final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");\n        private final String data;\n\n        JsonRequestBody(String data) {\n            this.data = data;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON;\n        }\n\n        @Override\n        public void writeTo(BufferedSink sink) throws IOException {\n            sink.writeUtf8(data);\n        }\n    }\n\n\n}\n\nclass FallBackDNS implements Dns {\n    // Implementation for FallBackDNS, including getDoHDns method\n    // ... (Implementation details for DNS resolution and fallback logic)\n}\n```"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.*;\nimport org.apache.hadoop.conf.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class VaultClient implements KmsClient {\n\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.parse(\"application/json; charset=utf-8\");\n\n    private ObjectMapper objectMapper = new ObjectMapper();\n    private String kmsToken;\n    private Configuration hadoopConfiguration;\n    private String endPointPrefix;\n    private OkHttpClient httpClient;\n\n\n    public String getContentFromTransitEngine(String path, String payload, String masterKeyId) throws IOException {\n        String url = endPointPrefix + \"transit/encrypt/\" + masterKeyId;\n        Request request = new Request.Builder()\n                .url(url)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .post(RequestBody.create(payload, JSON_MEDIA_TYPE))\n                .build();\n\n        return executeAndGetResponse(path, request);\n    }\n\n\n    private String executeAndGetResponse(String path, Request request) throws IOException {\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response + \" for path : \" + path);\n            }\n            return response.body().string();\n        }\n    }\n\n    private String buildPayload(Map<String, String> params) throws IOException {\n        return objectMapper.writeValueAsString(params);\n    }\n\n    @Override\n    public String wrapKey(byte[] key, String masterKeyId) throws IOException {\n        Map<String, String> params = new HashMap<>();\n        params.put(\"plaintext\", java.util.Base64.getEncoder().encodeToString(key));\n\n        String payload = buildPayload(params);\n        String response = getContentFromTransitEngine(\"wrapKey\", payload, masterKeyId);\n        return parseReturn(response, \"ciphertext\");\n    }\n\n    @Override\n    public byte[] unwrapKey(String wrappedKey, String masterKeyId) throws IOException {\n        Map<String, String> params = new HashMap<>();\n        params.put(\"ciphertext\", wrappedKey);\n\n        String payload = buildPayload(params);\n        String url = endPointPrefix + \"transit/decrypt/\" + masterKeyId;\n        Request request = new Request.Builder()\n                .url(url)\n                .addHeader(\"X-Vault-Token\", kmsToken)\n                .post(RequestBody.create(payload, JSON_MEDIA_TYPE))\n                .build();\n\n        String response = executeAndGetResponse(\"unwrapKey\", request);\n        String encodedKey = parseReturn(response, \"plaintext\");\n        return java.util.Base64.getDecoder().decode(encodedKey);\n    }\n\n    private String parseReturn(String response, String key) throws IOException {\n        Map<String, Object> jsonMap = objectMapper.readValue(response, Map.class);\n        Map<String, Object> data = (Map<String, Object>) jsonMap.get(\"data\");\n        if (data == null) {\n            throw new IOException(\"Invalid response from Vault: 'data' field is missing\");\n        }\n        String value = (String) data.get(key);\n        if (value == null) {\n            throw new IOException(\"Invalid response from Vault: '\" + key + \"' field is missing in 'data'\");\n        }\n        return value;\n    }\n\n\n    public void refreshToken() {\n        // Implementation for refreshing token\n    }\n\n\n}\n\ninterface KmsClient {\n    String wrapKey(byte[] key, String masterKeyId) throws IOException;\n    byte[] unwrapKey(String wrappedKey, String masterKeyId) throws IOException;\n}\n```"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) throws Exception {\n        String endpoint = prov.getEndpoint();\n        String json = prov.toJson(rawNode);\n\n        HttpRequest.Builder builder = HttpRequest.newBuilder()\n                .uri(URI.create(\"http://localhost:\" + port + endpoint))\n                .POST(HttpRequest.BodyPublishers.ofString(json))\n                .header(\"Content-Type\", \"application/json\");\n\n        if (token != null) {\n            builder.header(\"Authorization\", \"Bearer \" + token);\n        }\n\n        HttpRequest request = builder.build();\n        HttpClient client = HttpClient.newHttpClient();\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 200 && response.statusCode() < 300) {\n            ObjectMapper mapper = new ObjectMapper();\n            return mapper.readValue(response.body(), prov.getReturnType());\n        } else if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            Optional<BeaconClientErrorResponse> clientError = parseClientError(response);\n            if (clientError.isPresent()) {\n                throw new ClientErrorException(clientError.get());\n            } else {\n                throw new Exception(\"Client Error: \" + response.statusCode() + \" - \" + response.body());\n            }\n        } else {\n            Optional<BeaconServerErrorResponse> serverError = parseServerError(response);\n            if (serverError.isPresent()) {\n                throw new ServerErrorException(serverError.get());\n            } else {\n                throw new Exception(\"Server Error: \" + response.statusCode() + \" - \" + response.body());\n            }\n        }\n    }\n\n\n    public <REQ, RES> RES performRequest(REQ req) throws Exception {\n        BeaconInterface<REQ> prov = BeaconRegistry.findProvider(req.getClass());\n        return performRequest(prov, prov.toJson(req));\n    }\n\n\n    public Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            return Optional.of(mapper.readValue(response.body(), BeaconClientErrorResponse.class));\n        } catch (JsonProcessingException e) {\n            return Optional.empty();\n        }\n    }\n\n    public Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            return Optional.of(mapper.readValue(response.body(), BeaconServerErrorResponse.class));\n        } catch (JsonProcessingException e) {\n            return Optional.empty();\n        }\n    }\n\n\n    public void setToken(String token) {\n        this.token = token;\n    }\n\n\n\n    public static class ClientErrorException extends Exception {\n        private final BeaconClientErrorResponse error;\n\n        public ClientErrorException(BeaconClientErrorResponse error) {\n            this.error = error;\n        }\n\n        public BeaconClientErrorResponse getError() {\n            return error;\n        }\n    }\n\n    public static class ServerErrorException extends Exception {\n        private final BeaconServerErrorResponse error;\n\n        public ServerErrorException(BeaconServerErrorResponse error) {\n            this.error = error;\n        }\n\n        public BeaconServerErrorResponse getError() {\n            return error;\n        }\n    }\n\n    private static class BeaconClientErrorResponse {\n        private String errorCode;\n        private String message;\n        // Getters and setters\n        public String getErrorCode(){ return errorCode;}\n        public String getMessage(){return message;}\n        public void setErrorCode(String errorCode){this.errorCode = errorCode;}\n        public void setMessage(String message){this.message = message;}\n    }\n\n    private static class BeaconServerErrorResponse {\n        private String errorCode;\n        private String message;\n        // Getters and setters\n        public String getErrorCode(){ return errorCode;}\n        public String getMessage(){return message;}\n        public void setErrorCode(String errorCode){this.errorCode = errorCode;}\n        public void setMessage(String message){this.message = message;}\n    }\n\n\n    private interface BeaconInterface<T> {\n        String getEndpoint();\n        Class<?> getReturnType();\n        String toJson(T obj) throws JsonProcessingException;\n        String toJson(String raw) throws JsonProcessingException;\n    }\n\n    private static class BeaconRegistry {\n        public static <T> BeaconInterface<T> findProvider(Class<T> requestClass) {\n            return null; // Implementation for registering and retrieving providers\n        }\n    }\n}\n"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.TimeUnit;\n\npublic class GraphHopperGeocoding {\n\n    private ObjectMapper objectMapper = new ObjectMapper();\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).build();\n    }\n\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) throws IOException {\n        String url = buildUrl(request);\n\n        OkHttpClient client = getClientForRequest(request);\n\n        Request okRequest = new Request.Builder().url(url).build();\n\n        Response response = client.newCall(okRequest).execute();\n        if (!response.isSuccessful()) {\n            throw new IOException(\"Unexpected code \" + response);\n        }\n        return objectMapper.readValue(response.body().string(), GHGeocodingResponse.class);\n\n    }\n\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.getTimeoutInMillis() != null)\n            client = client.newBuilder().connectTimeout(request.getTimeoutInMillis(), TimeUnit.MILLISECONDS).build();\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(routeServiceUrl).append(\"?\");\n\n        if (request.getQuery() != null)\n            builder.append(\"&q=\").append(encodeURL(request.getQuery()));\n\n        if (request.getLocale() != null)\n            builder.append(\"&locale=\").append(encodeURL(request.getLocale()));\n\n        if (request.getLimit() != null)\n            builder.append(\"&limit=\").append(request.getLimit());\n\n        if (request.getReverse() != null)\n            builder.append(\"&reverse=\").append(request.getReverse());\n\n        if (request.getPoint() != null)\n            builder.append(\"&point=\").append(request.getPoint());\n\n        if (request.getProvider() != null)\n            builder.append(\"&provider=\").append(encodeURL(request.getProvider()));\n\n\n        builder.append(\"&key=\").append(encodeURL(key));\n\n        return builder.toString();\n    }\n\n    private String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, StandardCharsets.UTF_8.toString());\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n\n}\n\nclass GHGeocodingRequest {\n    private String query;\n    private String locale;\n    private Integer limit;\n    private Boolean reverse;\n    private String point;\n    private String provider;\n    private Long timeoutInMillis;\n\n    public String getQuery() {\n        return query;\n    }\n\n    public void setQuery(String query) {\n        this.query = query;\n    }\n\n    public String getLocale() {\n        return locale;\n    }\n\n    public void setLocale(String locale) {\n        this.locale = locale;\n    }\n\n    public Integer getLimit() {\n        return limit;\n    }\n\n    public void setLimit(Integer limit) {\n        this.limit = limit;\n    }\n\n    public Boolean getReverse() {\n        return reverse;\n    }\n\n    public void setReverse(Boolean reverse) {\n        this.reverse = reverse;\n    }\n\n    public String getPoint() {\n        return point;\n    }\n\n    public void setPoint(String point) {\n        this.point = point;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public void setProvider(String provider) {\n        this.provider = provider;\n    }\n\n    public Long getTimeoutInMillis() {\n        return timeoutInMillis;\n    }\n\n    public void setTimeoutInMillis(Long timeoutInMillis) {\n        this.timeoutInMillis = timeoutInMillis;\n    }\n}\n\n\nclass GHGeocodingResponse {\n    // Define fields to match the GraphHopper Geocoding API response structure\n}\n```"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n\n    private final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private final Pattern gidPattern = Pattern.compile(\"posts/(\\\\d+)\");\n    private int currentPageNum = 1;\n\n\n    public DanbooruApiClient() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(15, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws IOException {\n        currentPageNum = pageNum;\n\n        String url = String.format(\"https://%s/posts.json?page=%d&limit=100&tags=ordfav:%d..%d\", DOMAIN, pageNum, (pageNum-1)*100+1, pageNum*100);\n\n        Request request = new Request.Builder()\n                .url(url)\n                .get()\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n            String jsonData = response.body().string();\n            JSONArray jsonArray = new JSONArray(jsonData);\n            JSONObject json = new JSONObject();\n            json.put(\"posts\", jsonArray);\n            return json;\n\n        }\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            String fileUrl = post.getString(\"file_url\");\n            urls.add(fileUrl);\n        }\n        return urls;\n    }\n\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        if (!url.getHost().equals(DOMAIN)) {\n            throw new MalformedURLException(\"Invalid domain\");\n        }\n\n        String path = url.getPath();\n        Matcher matcher = gidPattern.matcher(path);\n\n        if (matcher.matches()) {\n            return matcher.group(1);\n        } else {\n            throw new MalformedURLException(\"Invalid URL format\");\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.apache.commons.validator.routines.UrlValidator;\n\nimport java.io.IOException;\n\npublic class TerminologyServiceClient {\n\n    private final OkHttpClient client;\n    private final UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient(OkHttpClient client) {\n        this.client = client;\n        String[] schemes = {\"http\", \"https\"};\n        this.urlValidator = new UrlValidator(schemes, UrlValidator.ALLOW_2_SLASHES);\n    }\n\n    public void setBaseUrl(String url) {\n        this.expandBaseUrl = url + \"/ValueSet/$expand\";\n    }\n\n    public Response expandValueSet(String valueSetUri) throws IOException, IllegalArgumentException {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid Value Set URI: \" + valueSetUri);\n        }\n\n        String url = this.expandBaseUrl + \"?url=\" + valueSetUri;\n\n        Request request = new Request.Builder()\n                .url(url)\n                .get()\n                .build();\n\n        return client.newCall(request).execute();\n    }\n}\n```\n"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport okhttp3.*;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(30, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        // Implementation for retrieving Copilot token (replace with actual logic)\n        return \"\"; \n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        // Implementation for retrieving CoCoPilot token (replace with actual logic)\n        return \"\";\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, body != null ? RequestBody.create(MediaType.parse(\"application/json\"), body) : null);\n\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.addHeader(entry.getKey(), entry.getValue());\n            }\n        }\n\n        Request request = requestBuilder.build();\n        return client.newCall(request).execute();\n    }\n\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Content-Type\", \"application/json\");\n        headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        headers.put(\"x-request-id\", UUID.randomUUID().toString());\n        headers.put(\"client-machine-id\", machineId);\n        return headers;\n    }\n}\n```\n"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "```java\nimport com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\nclass GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(GHMatrixBatchRequester.class);\n    private final OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n\n    public JsonResult getJson(String url) throws IOException {\n        Request request = new Request.Builder()\n                .url(url)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            return processResponse(response);\n        }\n    }\n\n    public JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody body = RequestBody.create(requestJson.toString(), JSON);\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            return processResponse(response);\n        }\n    }\n\n\n    private JsonResult processResponse(Response response) throws IOException {\n        ResponseBody responseBody = response.body();\n        String responseBodyString = responseBody != null ? responseBody.string() : null;\n\n        JsonResult jsonResult = new JsonResult();\n        jsonResult.setStatus(response.code());\n        jsonResult.setHeaders(response.headers());\n\n        if (responseBodyString != null) {\n            jsonResult.setBody(responseBodyString);\n        }\n        return jsonResult;\n    }\n\n\n    public static class JsonResult {\n        private String body;\n        private int status;\n        private Headers headers;\n\n        public String getBody() {\n            return body;\n        }\n\n        public void setBody(String body) {\n            this.body = body;\n        }\n\n        public int getStatus() {\n            return status;\n        }\n\n        public void setStatus(int status) {\n            this.status = status;\n        }\n\n        public Headers getHeaders() {\n            return headers;\n        }\n\n        public void setHeaders(Headers headers) {\n            this.headers = headers;\n        }\n    }\n}\n\n```"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "import org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ItemStreamException;\nimport org.springframework.batch.item.ItemStreamReader;\n\nimport java.time.Duration;\nimport java.util.*;\n\npublic class KafkaItemReader<K, V> implements ItemStreamReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30000L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private final KafkaConsumer<K, V> kafkaConsumer;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private final Duration pollTimeout;\n    private boolean saveState = true;\n\n\n    public KafkaItemReader(Properties consumerProperties, String topic, Integer... partitions) {\n        this(consumerProperties, topic, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topic, List<Integer> partitions) {\n        this.kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topic, partition));\n        }\n        this.pollTimeout = Duration.ofMillis(DEFAULT_POLL_TIMEOUT);\n        this.partitionOffsets = new HashMap<>();\n\n    }\n\n\n    @Override\n    public void open(ExecutionContext executionContext) throws ItemStreamException {\n        if (executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            this.partitionOffsets = (Map<TopicPartition, Long>) executionContext.get(TOPIC_PARTITION_OFFSETS);\n        } else {\n            for (TopicPartition topicPartition : topicPartitions) {\n                partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n\n        kafkaConsumer.assign(topicPartitions);\n        partitionOffsets.forEach((tp, offset) -> kafkaConsumer.seek(tp, offset));\n\n    }\n\n    @Override\n    public V read() {\n        if (consumerRecords == null || !consumerRecords.hasNext()) {\n            ConsumerRecords<K, V> polledRecords = kafkaConsumer.poll(pollTimeout);\n            if (polledRecords.isEmpty()) {\n                return null;\n            }\n            consumerRecords = polledRecords.iterator();\n        }\n\n        ConsumerRecord<K, V> record = consumerRecords.next();\n        partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset() + 1);\n        return record.value();\n    }\n\n\n    @Override\n    public void update(ExecutionContext executionContext) throws ItemStreamException {\n        if (saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, partitionOffsets);\n            kafkaConsumer.commitSync();\n        }\n    }\n\n    @Override\n    public void close() throws ItemStreamException {\n        kafkaConsumer.close();\n    }\n}\n"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "import kafka.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.serialization.ByteArrayDeserializer;\nimport org.apache.kafka.common.serialization.Serializer;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n    private final String topic;\n    private final TopicPartition topicPartition;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n\n    private final ReentrantLock offsetUpdateLock;\n    private final Condition offsetReachedThreshold;\n\n    private Consumer<byte[], byte[]> consumer;\n    private long offsetInSchemasTopic;\n\n    private Properties consumerProps;\n\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId,\n                                 StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) {\n        super(\"KafkaStoreReaderThread-\" + topic, false);\n        this.topic = topic;\n        this.topicPartition = new TopicPartition(topic, 0);\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n\n        this.offsetUpdateLock = new ReentrantLock();\n        this.offsetReachedThreshold = offsetUpdateLock.newCondition();\n\n        consumerProps = new Properties();\n        consumerProps.put(\"bootstrap.servers\", bootstrapBrokers);\n        consumerProps.put(\"group.id\", groupId);\n        consumerProps.put(\"key.deserializer\", ByteArrayDeserializer.class.getName());\n        consumerProps.put(\"value.deserializer\", ByteArrayDeserializer.class.getName());\n        consumerProps.put(\"enable.auto.commit\", \"false\");\n    }\n\n    @Override\n    public void doWork() {\n        consumer = new KafkaConsumer<>(consumerProps);\n        consumer.assign(Collections.singletonList(topicPartition));\n\n        while (!isInterrupted()) {\n            ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(100));\n            for (ConsumerRecord<byte[], byte[]> record : records) {\n                K key = serializer.deserialize(topic, record.key());\n                V value = serializer.deserialize(topic, record.value());\n\n                if (storeUpdateHandler.validateMessage(key, value)) {\n                    localStore.put(key, value);\n                }\n\n                offsetInSchemasTopic = record.offset();\n\n                offsetUpdateLock.lock();\n                try {\n                    offsetReachedThreshold.signalAll();\n                } finally {\n                    offsetUpdateLock.unlock();\n                }\n            }\n        }\n    }\n\n\n    public void shutdown() {\n        initiateShutdown();\n        if (consumer != null) {\n            consumer.wakeup();\n        }\n        awaitShutdown();\n    }\n\n\n    public interface StoreUpdateHandler<K, V> {\n        boolean validateMessage(K key, V value);\n    }\n\n    public interface Store<K, V> {\n        void put(K key, V value);\n    }\n}\n"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.TimeoutException;\nimport org.apache.kafka.common.serialization.Serializer;\n\nimport java.time.Duration;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapBrokers);\n        props.putAll(configProps);\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) {\n        try {\n            byte[] serializedKey = serializer.serialize(topic, key);\n            byte[] serializedValue = serializer.serialize(topic, value);\n\n            Future<RecordMetadata> future = producer.send(new ProducerRecord<>(topic, serializedKey, serializedValue));\n            future.get(timeout, java.util.concurrent.TimeUnit.MILLISECONDS);\n            return value;\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\"Timeout while sending message to Kafka\", e);\n        } catch (InterruptedException | ExecutionException e) {\n            throw new StoreException(\"Error sending message to Kafka\", e);\n        }\n    }\n\n\n    public void close() {\n        producer.close();\n    }\n\n    public static class StoreException extends RuntimeException {\n        public StoreException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public static class StoreTimeoutException extends StoreException {\n        public StoreTimeoutException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n\n}\n"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import io.micrometer.core.instrument.Registry;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport reactor.core.Disposable;\nimport reactor.core.publisher.Observable;\nimport uk.gov.gchq.magmacore.hqdm.model.Thing;\nimport uk.gov.gchq.syntheticdatagenerator.serialise.AvroSerialiser;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\n\npublic class KafkaSink<T> implements Sink<T> {\n\n    private Function<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>();\n    private Disposable subscription;\n    private String topic;\n    private Map<String, Object> kafkaConfig;\n\n\n    public KafkaSink(Registry registry) {\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            Properties props = new Properties();\n            props.putAll(kafkaConfig);\n            kafkaProducerAtomicRef.set(new KafkaProducer<>(props));\n        }\n\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n\n        subscription = dataO.subscribe(data -> {\n            byte[] encodedData = encoder.apply(data);\n            kafkaProducer.send(new ProducerRecord<>(topic, encodedData));\n        });\n    }\n\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        return List.of(\n                ParameterDefinition.builder()\n                        .name(\"kafkaConfig\")\n                        .description(\"Kafka producer configuration properties.\")\n                        .type(Map.class)\n                        .required(true)\n                        .build(),\n                ParameterDefinition.builder()\n                        .name(\"topic\")\n                        .description(\"Kafka topic name.\")\n                        .type(String.class)\n                        .required(true)\n                        .build(),\n                ParameterDefinition.builder()\n                        .name(\"encoder\")\n                        .description(\"Encoder function to serialize objects to byte arrays.\")\n                        .type(Function.class)\n                        .required(true)\n                        .build()\n        );\n    }\n\n    @Override\n    public Metadata metadata() {\n        return new Metadata(\"Kafka Sink\", \"Writes data to a Kafka topic.\");\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (subscription != null && !subscription.isDisposed()) {\n            subscription.dispose();\n        }\n        if (kafkaProducerAtomicRef.get() != null) {\n            kafkaProducerAtomicRef.get().close();\n        }\n    }\n\n    public void setEncoder(Function<T, byte[]> encoder) {\n        this.encoder = encoder;\n    }\n\n    public void setTopic(String topic) {\n        this.topic = topic;\n    }\n\n    public void setKafkaConfig(Map<String, Object> kafkaConfig) {\n        this.kafkaConfig = kafkaConfig;\n    }\n}\n"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "```java\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class KafkaSampleProducer {\n\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(30);\n    private volatile boolean _shutdown = false;\n    private Producer<byte[], byte[]> _producer;\n\n\n    public void createProducer(Map<String, ?> config, String producerClientId) {\n        _producer = new KafkaProducer<>(config, new ByteArraySerializer(), new ByteArraySerializer());\n    }\n\n    public AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log) {\n        AtomicInteger samplesStored = new AtomicInteger(0);\n        for (MetricSampler.Sample sample : samples.samples()) {\n            if (_shutdown) {\n                break;\n            }\n            byte[] key = sample.key();\n            byte[] value = sample.value();\n\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, key, value);\n            Future<RecordMetadata> future = producer.send(record);\n            try {\n                future.get();\n                samplesStored.incrementAndGet();\n            } catch (Exception e) {\n                log.error(\"Error sending partition metric sample to Kafka: \", e);\n            }\n        }\n        return samplesStored;\n    }\n\n\n    public void close() {\n        _shutdown = true;\n        if (_producer != null) {\n            try {\n                _producer.close(PRODUCER_CLOSE_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n            } catch (Exception e) {\n                // Handle or log the exception as needed\n            }\n        }\n    }\n\n    // Dummy class for MetricSampler and Sample\n    static class MetricSampler {\n        static class Samples {\n            Iterable<Sample> samples() {\n                return null;\n            }\n        }\n        static class Sample {\n            byte[] key() { return null; }\n            byte[] value() { return null; }\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.kafka.support.TransactionSupport;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\nimport org.springframework.util.concurrent.ListenableFuture;\nimport org.springframework.util.concurrent.SettableListenableFuture;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n\n    private final boolean autoFlush;\n\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = producerFactory.transactionCapable();\n    }\n\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return send(topic, null, data);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return send(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return send(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> producerRecord) {\n        Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        SettableListenableFuture<SendResult<K, V>> future = new SettableListenableFuture<>();\n        producer.send(producerRecord,\n                (metadata, exception) -> {\n                    if (exception == null) {\n                        future.set(new SendResult<>(producerRecord, metadata));\n                    }\n                    else {\n                        future.setException(exception);\n                    }\n                    if (this.autoFlush) {\n                        producer.flush();\n                    }\n                });\n        closeProducer(producer, inTransaction());\n        return future.completable();\n    }\n\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer(topic);\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    private void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    public Producer<K, V> getTheProducer() {\n        return this.producerFactory.createProducer();\n    }\n\n    public Producer<K, V> getTheProducer(String topic) {\n        return this.producerFactory.createProducer(topic);\n    }\n\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.isActualTransactionActive();\n    }\n\n}\n"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.UUID;\n\npublic class JobPrefixFile implements AutoCloseable {\n\n    private final String prefix;\n    private final Path file;\n    private final FileChannel channel;\n    private final FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file, FileChannel channel, FileLock lock) {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = channel;\n        this.lock = lock;\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        return create(UUID.randomUUID().toString(), directory);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        Path file = Files.createTempFile(directory, prefix, null);\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE, StandardOpenOption.READ);\n        FileLock lock = channel.tryLock();\n        if (lock == null) {\n            close(channel);\n            throw new IOException(\"Failed to acquire lock on file: \" + file);\n        }\n        return new JobPrefixFile(prefix, file, channel, lock);\n    }\n\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        try {\n            FileChannel channel = FileChannel.open(file, StandardOpenOption.WRITE, StandardOpenOption.READ);\n            FileLock lock = channel.tryLock();\n\n            if (lock != null) {\n                String fileName = file.getFileName().toString();\n                int lastIndexOfDot = fileName.lastIndexOf('.');\n                String prefix = lastIndexOfDot > 0 ? fileName.substring(0, lastIndexOfDot) : fileName;\n\n                return new JobPrefixFile(prefix, file, channel, lock);\n            } else {\n                close(channel);\n                throw new IOException(\"Failed to acquire lock on existing file: \" + file);\n            }\n\n        } catch (OverlappingFileLockException e) {\n            throw new IOException(\"File is already locked: \" + file, e);\n        }\n    }\n\n    public void delete() throws IOException {\n        release();\n        deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() {\n        close(lock);\n        close(channel);\n    }\n\n    @Override\n    public void close() {\n        release();\n    }\n\n    private static void deleteIfExists(Path file) throws IOException {\n        if (Files.exists(file)) {\n            Files.delete(file);\n        }\n    }\n\n    private static void close(AutoCloseable closeable) {\n        try {\n            if (closeable != null) {\n                closeable.close();\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n}\n"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.IOException;\n\npublic class MaintenancePlanProducer {\n\n    private Producer<String, byte[]> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        props.put(\"key.serializer\", StringSerializer.class.getName());\n        props.put(\"value.serializer\", ByteArraySerializer.class.getName());\n\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(maintenancePlan);\n            byte[] data = baos.toByteArray();\n            _producer.send(new ProducerRecord<>(topic, maintenancePlan.getId(), data));\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error serializing MaintenancePlan\", e);\n        }\n    }\n\n\n    public void close() {\n        _producer.close();\n    }\n}\n"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.Serializer;\n\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}\n"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a Java class that manages non-blocking HTTP connections using Java NIO (New I/O) capabilities. The class should handle connection establishment, connection queue management, and distribute connections across multiple processors for load balancing.\n\nClass Description: NIOConnector is a thread-based class that manages asynchronous HTTP connections using Java NIO. It maintains a queue of pending connections, establishes them asynchronously, and distributes successfully established connections to a pool of NIOProcessor instances for further processing.\n\nAttributes:\n- name: String - The name identifier for this connector thread\n- selector: Selector - The NIO selector used for monitoring connection events\n- connectQueue: BlockingQueue<BackendConnection> - Queue holding pending connection requests\n- processors: NIOProcessor[] - Array of processors for handling established connections\n- nextProcessor: int - Index for round-robin processor selection\n- connectCount: long - Counter for tracking connection attempts\n\nMethods:\n- NIOConnector(String name) -> void - Constructor that initializes the connector with a name and opens a new selector\n- setProcessors(NIOProcessor[] processors) -> void - Sets the array of processors for connection distribution\n- postConnect(BackendConnection c) -> void - Adds a new connection request to the queue and wakes up the selector\n- run() -> void - Main thread loop that handles connection establishment and event processing\n- connect(Selector selector) -> void - Processes pending connections from the queue\n- finishConnect(SelectionKey key, Object att) -> void - Completes the connection process for a channel\n- clearSelectionKey(SelectionKey key) -> void - Cleans up a selection key after processing\n- nextProcessor() -> NIOProcessor - Selects the next processor in round-robin fashion\n\nInner Class:\n- ConnectIdGenerator - Generates unique IDs for established connections with thread-safe incrementing",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOConnector extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOConnector.class);\n    private static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();\n\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) throws IOException {\n        super.setName(name);\n        this.name = name;\n        this.selector = Selector.open();\n        this.connectQueue = new LinkedBlockingQueue<BackendConnection>();\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++connectCount;\n            try {\n                selector.select(1000L);\n                connect(selector);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        Object att = key.attachment();\n                        if (att != null && key.isValid() && key.isConnectable()) {\n                            finishConnect(key, att);\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(name, e);\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection c = null;\n        while ((c = connectQueue.poll()) != null) {\n            try {\n                c.connect(selector);\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_CONNECT_SOCKET, e);\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        try {\n            if (c.finishConnect()) {\n                clearSelectionKey(key);\n                c.setId(ID_GENERATOR.getId());\n                NIOProcessor processor = nextProcessor();\n                c.setProcessor(processor);\n                processor.postRegister(c);\n            }\n        } catch (Throwable e) {\n            clearSelectionKey(key);\n            c.error(ErrorCode.ERR_FINISH_CONNECT, e);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key.isValid()) {\n            key.attach(null);\n            key.cancel();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static class ConnectIdGenerator {\n        private static final long MAX_VALUE = Long.MAX_VALUE;\n        private long connectId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (connectId >= MAX_VALUE) {\n                    connectId = 0L;\n                }\n                return ++connectId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 20,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NIOConnector extends Thread {\n\n    private String name;\n    private Selector selector;\n    private BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n\n    public NIOConnector(String name) throws IOException {\n        this.name = name;\n        selector = SelectorProvider.provider().openSelector();\n        connectQueue = new LinkedBlockingQueue<>();\n        this.setName(name);\n        this.setDaemon(true);\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                selector.select(1000);\n                connect(selector);\n\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                Iterator<SelectionKey> iter = selectedKeys.iterator();\n\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (!key.isValid()) {\n                        continue;\n                    }\n                    if (key.isConnectable()) {\n                        finishConnect(key, key.attachment());\n                    }\n                }\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection c = null;\n        while ((c = connectQueue.poll()) != null) {\n            try {\n                SocketChannel channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                boolean connected = channel.connect(new InetSocketAddress(c.getHost(), c.getPort()));\n                c.setChannel(channel);\n                channel.register(selector, SelectionKey.OP_CONNECT, c);\n                connectCount++;\n                if (connected) {\n                    finishConnect(null, c);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        try {\n            if (key != null) {\n                SocketChannel channel = (SocketChannel) key.channel();\n                channel.finishConnect();\n                clearSelectionKey(key);\n            }\n            NIOProcessor processor = nextProcessor();\n            processor.postRegister(c);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key.isValid()) {\n            key.cancel();\n            try {\n                key.channel().close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n\n    static class ConnectIdGenerator {\n        private static final AtomicLong id = new AtomicLong(0);\n\n        public static long nextId() {\n            return id.incrementAndGet();\n        }\n    }\n\n\n}\n\nclass BackendConnection {\n    private String host;\n    private int port;\n    private SocketChannel channel;\n    private long id;\n\n    public BackendConnection(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.id = NIOConnector.ConnectIdGenerator.nextId();\n    }\n\n\n    public String getHost() {\n        return host;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public SocketChannel getChannel() {\n        return channel;\n    }\n\n    public void setChannel(SocketChannel channel) {\n        this.channel = channel;\n    }\n\n    public long getId() {\n        return id;\n    }\n}\n\nclass NIOProcessor {\n\n    public void postRegister(BackendConnection c) {\n        // Process the registered connection\n        System.out.println(\"Connection \" + c.getId() + \" registered to processor.\");\n    }\n}\n"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a class for memory-mapped file reading with random access capabilities using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: RandomAccessReadMemoryMappedFile is a class that provides random access reading functionality for files using memory-mapped I/O. It maps a file into memory for efficient reading operations and implements common random access operations like seek, read, and position tracking.\n\nAttributes:\n- mappedByteBuffer: ByteBuffer - The memory-mapped buffer containing the file contents\n- size: long - The size of the file in bytes\n- fileChannel: FileChannel - The file channel used for memory mapping\n- unmapper: Consumer<? super ByteBuffer> - A consumer for properly unmapping the buffer when closing\n\nMethods:\n- Constructor(filename: String) -> void - Creates an instance by opening the specified file\n- Constructor(file: File) -> void - Creates an instance using the specified File object\n- Constructor(path: Path) -> void - Creates an instance using the specified Path object\n- close() -> void - Closes the file channel and unmaps the buffer\n- seek(position: long) -> void - Sets the reading position in the file\n- getPosition() -> long - Returns the current reading position\n- read() -> int - Reads a single byte from the current position\n- read(b: byte[], offset: int, length: int) -> int - Reads bytes into an array\n- length() -> long - Returns the file size\n- isClosed() -> boolean - Checks if the reader is closed\n- isEOF() -> boolean - Checks if the current position is at end of file\n- checkClosed() -> void - Internal method to verify the reader isn't closed (throws IOException if closed)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.EnumSet;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile implements RandomAccessRead\n{\n    private ByteBuffer mappedByteBuffer;\n    private final long size;\n    private final FileChannel fileChannel;\n    private final Consumer<? super ByteBuffer> unmapper;\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException\n    {\n        this(new File(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException\n    {\n        this(file.toPath());\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException\n    {\n        fileChannel = FileChannel.open(path, EnumSet.of(StandardOpenOption.READ));\n        size = fileChannel.size();\n        if (size > Integer.MAX_VALUE)\n        {\n            throw new IOException(getClass().getName() + \" doesn't yet support files bigger than \"\n                    + Integer.MAX_VALUE);\n        }\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = IOUtils::unmap;\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        if (fileChannel != null)\n        {\n            fileChannel.close();\n        }\n        if (mappedByteBuffer != null)\n        {\n            Optional.ofNullable(unmapper).ifPresent(u -> u.accept(mappedByteBuffer));\n            mappedByteBuffer = null;\n        }\n    }\n\n    @Override\n    public void seek(long position) throws IOException\n    {\n        checkClosed();\n        if (position < 0)\n        {\n            throw new IOException(\"Invalid position \"+position);\n        }\n        mappedByteBuffer.position((int) Math.min(position, size));\n    }\n\n    @Override\n    public long getPosition() throws IOException\n    {\n       checkClosed();\n       return mappedByteBuffer.position();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        return mappedByteBuffer.get() & 0xff;\n    }\n\n    @Override\n    public int read(byte[] b, int offset, int length) throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        int remainingBytes = (int)size - mappedByteBuffer.position();\n        remainingBytes = Math.min(remainingBytes, length);\n        mappedByteBuffer.get(b, offset, remainingBytes);\n        return remainingBytes;\n    }\n\n    @Override\n    public long length() throws IOException\n    {\n        checkClosed();\n        return size;\n    }\n\n    private void checkClosed() throws IOException\n    {\n        if (isClosed())\n        {\n            throw new IOException(getClass().getSimpleName() + \" already closed\");\n        }\n    }\n\n    @Override\n    public boolean isClosed()\n    {\n        return mappedByteBuffer == null;\n    }\n\n    @Override\n    public boolean isEOF() throws IOException\n    {\n        checkClosed();\n        return mappedByteBuffer.position() >= size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile implements Closeable {\n\n    private MappedByteBuffer mappedByteBuffer;\n    private long size;\n    private FileChannel fileChannel;\n    private Consumer<? super ByteBuffer> unmapper;\n    private boolean closed = false;\n\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException {\n        this(new File(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException {\n        this(file.toPath());\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException {\n         try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"r\")) {\n            this.fileChannel = raf.getChannel();\n            this.size = fileChannel.size();\n            this.mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            this.unmapper = CleanerHelper.getCleaner().register(this, () -> {\n                try {\n                    if (mappedByteBuffer != null) {\n                        CleanerHelper.clean(mappedByteBuffer);\n                    }\n                } catch (Exception e) {\n                    // Ignore exceptions during cleanup\n                }\n            });\n        }\n    }\n\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n\n        if (unmapper != null) {\n            unmapper.accept(mappedByteBuffer);\n            unmapper = null;\n        }\n\n        if (fileChannel != null) {\n            fileChannel.close();\n            fileChannel = null;\n        }\n\n        mappedByteBuffer = null;\n\n    }\n\n    public void seek(long position) throws IOException {\n        checkClosed();\n        if (position < 0 || position > size) {\n            throw new IOException(\"Position out of bounds: \" + position);\n        }\n        mappedByteBuffer.position((int) position);\n    }\n\n    public long getPosition() throws IOException {\n        checkClosed();\n        return mappedByteBuffer.position();\n    }\n\n    public int read() throws IOException {\n        checkClosed();\n        if (isEOF()) {\n            return -1;\n        }\n        return mappedByteBuffer.get() & 0xFF;\n    }\n\n    public int read(byte[] b, int offset, int length) throws IOException {\n        checkClosed();\n        if (isEOF()) {\n            return -1;\n        }\n        int remaining = (int) (size - mappedByteBuffer.position());\n        int toRead = Math.min(length, remaining);\n        mappedByteBuffer.get(b, offset, toRead);\n        return toRead;\n    }\n\n    public long length() {\n        return size;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    public boolean isEOF() throws IOException {\n        checkClosed();\n        return mappedByteBuffer.position() >= size;\n    }\n\n    private void checkClosed() throws IOException {\n        if (closed) {\n            throw new IOException(\"Reader is closed\");\n        }\n    }\n\n\n    private static class CleanerHelper {\n        private static final sun.misc.Cleaner cleaner = sun.misc.Cleaner.create();\n\n        public static sun.misc.Cleaner getCleaner() {\n            return cleaner;\n        }\n\n        public static void clean(ByteBuffer buffer) {\n            ((sun.nio.ch.DirectBuffer) buffer).cleaner().clean();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.util.Arrays;\n\npublic class StackTraceDeobfuscator {\n\n    private static final String MAPPING_FILE_PATH = System.getenv(\"XPIPE_MAPPING\");\n    private static final String RETRACE_BAT = \"retrace.bat\";\n    private static final String RETRACE_SH = \"retrace.sh\";\n\n    public String deobfuscate(Throwable t) {\n        if (!canDeobfuscate()) {\n            return Arrays.toString(t.getStackTrace());\n        }\n\n        try {\n            File inputFile = createTempFile(\"stacktrace\", \".txt\");\n            File outputFile = createTempFile(\"deobfuscated\", \".txt\");\n\n            try (PrintWriter writer = new PrintWriter(inputFile)) {\n                t.printStackTrace(writer);\n            }\n\n            String retraceScript = System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\") ? RETRACE_BAT : RETRACE_SH;\n            ProcessBuilder pb = new ProcessBuilder(retraceScript, MAPPING_FILE_PATH, inputFile.getAbsolutePath());\n            pb.redirectOutput(outputFile);\n            Process process = pb.start();\n            int exitCode = process.waitFor();\n\n            if (exitCode == 0) {\n                return Files.readString(outputFile.toPath());\n            } else {\n                return Arrays.toString(t.getStackTrace());\n            }\n\n        } catch (IOException | InterruptedException e) {\n            return Arrays.toString(t.getStackTrace());\n        }\n    }\n\n\n    private boolean canDeobfuscate() {\n        return MAPPING_FILE_PATH != null && !MAPPING_FILE_PATH.isEmpty() &&\n                (new File(RETRACE_BAT).exists() || new File(RETRACE_SH).exists());\n    }\n\n    private File createTempFile(String prefix, String suffix) throws IOException {\n        return File.createTempFile(prefix, suffix);\n    }\n}\n```\n"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ProcessRunner {\n\n    private final File processRoot;\n    private final ExecutorService executor = Executors.newCachedThreadPool();\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n\n        executor.submit(new AsyncPipe(process.getInputStream(), System.out));\n        executor.submit(new AsyncPipe(process.getErrorStream(), System.out));\n\n        process.waitFor();\n    }\n\n    private static class AsyncPipe implements Runnable {\n\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    writer.write(line);\n                    writer.newLine();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\n\npublic class FileReader extends Reader {\n\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        try {\n            mStream = new InputStreamReader(new java.io.FileInputStream(file));\n        } catch (FileNotFoundException e) {\n            String command = \"cat \" + file;\n            if (shell != null) {\n                String cat = shell.which(\"cat\");\n                if (cat == null) {\n                    cat = shell.which(\"toolbox\");\n                    if (cat != null) {\n                        cat += \" cat\";\n                    }\n                }\n                if (cat != null) {\n                    command = \"su -c \\\"\" + cat + \" \" + file + \"\\\"\";\n                }\n            }\n\n            try {\n                Process process = Runtime.getRuntime().exec(command);\n                InputStream inputStream = process.getInputStream();\n                mStream = new InputStreamReader(inputStream);\n            } catch (IOException e2) {\n                throw new FileNotFoundException(\"Could not open file: \" + file);\n            }\n        }\n    }\n\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        if (mStream == null) {\n            return -1;\n        }\n        return mStream.read(buffer, offset, count);\n    }\n\n    public static class Shell {\n        public String which(String command) {\n            return null; // Replace with actual implementation if needed\n        }\n    }\n}\n"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.concurrent.TimeoutException;\n\npublic class ProcessShell extends AbstractShell {\n\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n\n    public void init(String initialCommand) throws IOException {\n        mProcess = Runtime.getRuntime().exec(initialCommand);\n        mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n        mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n        mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        mSucceedOutput = new StringBuilder();\n        mErrorOutput = new StringBuilder();\n    }\n\n\n    public void exec(String command) throws IOException {\n        mCommandOutputStream.writeBytes(command + \"\\n\");\n        mCommandOutputStream.flush();\n    }\n\n\n    public void exit() throws IOException {\n        mCommandOutputStream.close();\n        try {\n            mProcess.destroy();\n        } catch (Exception ignored) {}\n    }\n\n\n    public void exitAndWaitFor() throws IOException, InterruptedException {\n        exec(\"exit\");\n        waitFor();\n        exit();\n    }\n\n\n    public int waitFor() throws InterruptedException {\n        return mProcess.waitFor();\n    }\n\n\n    public ProcessShell readAll() throws IOException {\n        readSucceedOutput();\n        readErrorOutput();\n        return this;\n    }\n\n\n    public ProcessShell readSucceedOutput() throws IOException {\n        String line;\n        while (mSucceedReader.ready() && (line = mSucceedReader.readLine()) != null) {\n            mSucceedOutput.append(line).append(\"\\n\");\n        }\n        return this;\n    }\n\n\n    public ProcessShell readErrorOutput() throws IOException {\n        String line;\n        while (mErrorReader.ready() && (line = mErrorReader.readLine()) != null) {\n            mErrorOutput.append(line).append(\"\\n\");\n        }\n        return this;\n    }\n\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n\n    static abstract class AbstractShell {}\n}\n"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport com.coremedia.iso.boxes.Container;\nimport com.googlecode.mp4parser.DataSource;\nimport com.googlecode.mp4parser.FileDataSourceImpl;\nimport com.googlecode.mp4parser.authoring.Movie;\nimport com.googlecode.mp4parser.authoring.builder.DefaultMp4Builder;\nimport com.googlecode.mp4parser.authoring.tracks.H264TrackImpl;\nimport org.jcodec.codecs.h264.H264Decoder;\nimport org.jcodec.codecs.h264.H264Utils;\nimport org.jcodec.codecs.h264.io.model.SeqParameterSet;\nimport org.jcodec.common.io.IOUtils;\nimport org.jcodec.common.io.NIOUtils;\nimport org.jcodec.containers.mp4.boxes.SampleEntry;\n\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.SourceDataLine;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class NutReaderTest {\n\n    public void testNutReader() throws IOException, InterruptedException, ExecutionException, LineUnavailableException {\n        File tempNut = File.createTempFile(\"temp\", \".nut\");\n        ExecutorService pool = Executors.newSingleThreadExecutor();\n        Future<?> ffmpeg = pool.submit(() -> {\n            try {\n                ProcessBuilder pb = new ProcessBuilder(\"ffmpeg\", \"-i\", new File(\"Samples.big_buck_bunny_720p_1mb\").getAbsolutePath(),\n                        \"-vcodec\", \"rawvideo\", \"-acodec\", \"pcm_s32le\", \"-f\", \"nut\", tempNut.getAbsolutePath());\n                Process process = pb.start();\n                assertEquals(0, process.waitFor());\n            } catch (IOException | InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n        ffmpeg.get();\n        ReadableByteChannel nut = NIOUtils.readableChannel(tempNut);\n        NutReader reader = new NutReader(nut);\n        reader.readHeaders();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        reader.handleStream(Channels.newChannel(baos));\n        reader.readFooter();\n        nut.close();\n        tempNut.delete();\n    }\n\n    class NutReader {\n        private final ReadableByteChannel channel;\n\n        public NutReader(ReadableByteChannel channel) {\n            this.channel = channel;\n        }\n\n        public void readHeaders() {\n            // Implementation for reading NUT headers\n        }\n\n        public void handleStream(ReadableByteChannel channel) {\n            // Implementation for handling stream data\n        }\n\n        public void readFooter() {\n            // Implementation for reading NUT footer\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Java class that facilitates interaction with external processes through command execution, providing methods for writing input, executing commands, and retrieving results, with support for timeout handling and resource cleanup.\n\nClass Description: The Command class encapsulates functionality for executing and interacting with external processes. It handles process creation, input/output stream management, command execution, and result collection, with features for line-based input, process termination, and timeout control.\n\nAttributes:\n\nprocess: [Process] - The running external process instance\nstdIn: [OutputStream] - Stream for writing input to the process\nstdOut: [File] - Temporary file storing the process's standard output\nstdErr: [File] - Temporary file storing the process's error output\nnextLine: [String] - Line separator string for command input\nexit: [String] - Command string to terminate the process\ncharset: [Charset] - Character encoding for input/output\nstartTime: [LocalDateTime] - Timestamp when the process was started\n\nMethods:\n\nof: [of(String init)] -> [Command] - Creates a Command instance with default settings\nof: [of(String init, Charset charset)] -> [Command] - Creates a Command instance with specified charset\nof: [of(String init, String nextLine, String exit, Charset charset)] -> [Command] - Creates a Command instance with custom settings\nwrite: [write(String str)] -> [Command] - Writes a string to the process's input stream\nline: [line()] -> [Command] - Writes a line separator to the process's input stream\nexit: [exit()] -> [Command] - Sends the exit command to terminate the process\nexec: [exec(String str)] -> [Command] - Executes a command string (writes input and adds line separator)\nresult: [result()] -> [CommandResult] - Waits for process completion and returns results\nresult: [result(long millis)] -> [CommandResult] - Waits with timeout for process completion\nclose: [close()] -> [void] - Terminates the process and releases resources",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.time.LocalDateTime;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Command {\n\n    public static final String NEXT_LINE = SystemUtils.lineSeparator();\n    public static final String EXIT_COMMAND = \"exit\";\n\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String init, String nextLine, String exit, Charset charset) throws IOException {\n        if (!StringUtils.hasText(init)) {\n            throw new IllegalArgumentException(\"Empty init\");\n        }\n        StringTokenizer st = new StringTokenizer(init);\n        String[] cmdArray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++) {\n            cmdArray[i] = st.nextToken();\n        }\n\n        this.stdOut = FileUtils.createTemp();\n        this.stdErr = FileUtils.createTemp();\n\n        ProcessBuilder builder = new ProcessBuilder(cmdArray).redirectError(this.stdErr).redirectOutput(this.stdOut);\n        this.process = builder.start();\n        this.stdIn = this.process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return of(init, SystemUtils.charset());\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return of(init, NEXT_LINE, EXIT_COMMAND, charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) throws IOException {\n        this.stdIn.write(str.getBytes(this.charset));\n        this.stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        return write(this.nextLine);\n    }\n\n    public Command exit() throws IOException {\n        write(this.exit);\n        return line();\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        return line();\n    }\n\n    public CommandResult result() throws InterruptedException {\n        this.process.waitFor();\n        return CommandResult.of(this.stdOut, this.stdErr, this.startTime, LocalDateTime.now(), this.charset);\n    }\n\n    public CommandResult result(long millis) throws InterruptedException, CommandTimeoutException {\n        if (this.process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n            return result();\n        }\n        this.process.destroyForcibly();\n        throw new CommandTimeoutException();\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.time.Duration;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport java.util.concurrent.*;\n\nclass Command {\n    Process process;\n    OutputStream stdIn;\n    File stdOut;\n    File stdErr;\n    String nextLine = System.lineSeparator();\n    String exit = \"exit\" + nextLine;\n    Charset charset = StandardCharsets.UTF_8;\n    LocalDateTime startTime;\n\n    public static Command of(String init) {\n        return of(init, StandardCharsets.UTF_8);\n    }\n\n    public static Command of(String init, Charset charset) {\n        return of(init, System.lineSeparator(), \"exit\" + System.lineSeparator(), charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) {\n        try {\n            Command cmd = new Command();\n            cmd.nextLine = nextLine;\n            cmd.exit = exit;\n            cmd.charset = charset;\n            cmd.process = Runtime.getRuntime().exec(init);\n            cmd.stdIn = cmd.process.getOutputStream();\n            cmd.stdOut = Files.createTempFile(\"stdout\", \".txt\").toFile();\n            cmd.stdErr = Files.createTempFile(\"stderr\", \".txt\").toFile();\n            cmd.startTime = LocalDateTime.now();\n            return cmd;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Command write(String str) {\n        try {\n            stdIn.write(str.getBytes(charset));\n            stdIn.flush();\n            return this;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Command line() {\n        return write(nextLine);\n    }\n\n    public Command exit() {\n        return write(exit);\n    }\n\n    public Command exec(String str) {\n        return write(str).line();\n    }\n\n    public CommandResult result() {\n        try {\n            process.waitFor();\n            return createResult();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public CommandResult result(long millis) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        try {\n            Future<CommandResult> future = executor.submit(this::result);\n            return future.get(millis, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n            throw new RuntimeException(e.getCause());\n        } catch (TimeoutException e) {\n            process.destroyForcibly();\n            return createResult(e);\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n\n\n    private CommandResult createResult() {\n        return createResult(null);\n    }\n\n    private CommandResult createResult(Throwable error) {\n        try {\n            Duration duration = Duration.between(startTime, LocalDateTime.now());\n            String out = Files.readString(stdOut.toPath(), charset);\n            String err = Files.readString(stdErr.toPath(), charset);\n            int exitCode = error != null ? -1 : process.exitValue();\n            return new CommandResult(exitCode, out, err, duration, error);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        try {\n            stdIn.close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        try {\n            process.getInputStream().close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        try {\n            process.getErrorStream().close();\n        } catch (IOException e) {\n            // Ignore\n        }\n        stdOut.delete();\n        stdErr.delete();\n    }\n\n\n    public static class CommandResult {\n        public final int exitCode;\n        public final String stdOut;\n        public final String stdErr;\n        public final Duration duration;\n        public final Throwable error;\n\n        public CommandResult(int exitCode, String stdOut, String stdErr, Duration duration, Throwable error) {\n            this.exitCode = exitCode;\n            this.stdOut = stdOut;\n            this.stdErr = stdErr;\n            this.duration = duration;\n            this.error = error;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class JavaVersionChecker {\n\n    public static String getJavaVersion() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"javac\", \"-version\");\n            processBuilder.redirectErrorStream(true); // Redirect stderr to stdout\n            Process process = processBuilder.start();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String version = reader.readLine();\n\n            return version != null ? version : \"unknown\";\n        } catch (IOException e) {\n            return \"unknown\";\n        }\n    }\n\n    public static void main(String[] args) {\n        String javaVersion = getJavaVersion();\n        System.out.println(javaVersion); \n    }\n}\n```"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: The task involves creating a Java utility class that manages environment variables for a Java Runtime Environment (JRE) and handles log redirection from an external process. The class should provide methods to configure the JRE environment and redirect logs from the Android `logcat` command to a custom logger.\n\nClass Description: This utility class is designed to set up the JRE environment by configuring various system environment variables and redirecting logs from an external process (`logcat`) to a custom logger. It is particularly useful for Android applications that need to manage JRE environments and log outputs dynamically.\n\nAttributes:\n\n- `NATIVE_LIB_DIR`: String - The directory path for native libraries.\n- `LD_LIBRARY_PATH`: String - The library path for dynamic linking.\n- `LOCAL_RENDERER`: String - The renderer type for graphics (e.g., \"opengles3_desktopgl_angle_vulkan\").\n- `jvmLibraryPath`: String - The path to the JVM library (e.g., \"server/libjvm.so\" or \"client/libjvm.so\").\n- `logcatPb`: ProcessBuilder - A ProcessBuilder instance for executing the `logcat` command.\n- `failTime`: int - A counter to track the number of failed attempts to start the `logcat` process.\n\nMethods:\n\n- `redirectAndPrintJRELog()`: void - Starts a new thread to redirect and print JRE logs from the `logcat` command. The method configures the `logcat` command to filter specific log tags and redirects the output to a custom logger. If the process fails, it retries up to 10 times.\n- `setJavaEnvironment(Activity activity, String jreHome)`: void - Configures the JRE environment by setting various system environment variables. The method reads additional environment variables from a custom file (`custom_env.txt`) and applies them. It also sets the `LD_LIBRARY_PATH` and `PATH` variables to include the JRE binaries and native libraries.\n  - Input:\n    - `activity`: Activity - The Android activity context.\n    - `jreHome`: String - The home directory of the JRE.\n  - Output: None (void).\n- `setLdLibraryPath(String path)`: void - Sets the `LD_LIBRARY_PATH` environment variable to the specified path.\n  - Input:\n    - `path`: String - The new library path.\n  - Output: None (void).\n\nNote: The class assumes the presence of helper classes like `Logger`, `Tools`, `LauncherPreferences`, and `ExtraCore` for logging, file operations, and preference management. These dependencies should be handled appropriately in the implementation.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport android.system.Os;\nimport android.system.ErrnoException;\n\npublic static void redirectAndPrintJRELog() {\n    new Thread(new Runnable(){\n        int failTime = 0;\n        ProcessBuilder logcatPb;\n        @Override\n        public void run() {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder().command(\"logcat\", \"-v\", \"brief\", \"-s\", \"jrelog:I\", \"LIBGL:I\", \"NativeInput\").redirectErrorStream(true);\n                }\n\n                new ProcessBuilder().command(\"logcat\", \"-c\").redirectErrorStream(true).start();\n                java.lang.Process p = logcatPb.start();\n\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = p.getInputStream().read(buf)) != -1) {\n                    String currStr = new String(buf, 0, len);\n                    Logger.appendToLog(currStr);\n                }\n\n                if (p.waitFor() != 0) {\n                    failTime++;\n                    if (failTime <= 10) {\n                        run();\n                    } else {\n                        Logger.appendToLog(\"ERROR: Unable to get more log.\");\n                    }\n                }\n            } catch (Throwable e) {\n                Logger.appendToLog(\"Exception on logging thread:\\n\" + Log.getStackTraceString(e));\n            }\n        }\n    }).start();\n}\n\npublic static void setJavaEnvironment(Activity activity, String jreHome) throws Throwable {\n    Map<String, String> envMap = new ArrayMap<>();\n    envMap.put(\"POJAV_NATIVEDIR\", NATIVE_LIB_DIR);\n    envMap.put(\"JAVA_HOME\", jreHome);\n    envMap.put(\"HOME\", Tools.DIR_GAME_HOME);\n    envMap.put(\"TMPDIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"LIBGL_MIPMAP\", \"3\");\n    envMap.put(\"LIBGL_NOERROR\", \"1\");\n    envMap.put(\"LIBGL_NOINTOVLHACK\", \"1\");\n    envMap.put(\"LIBGL_NORMALIZE\", \"1\");\n\n    if(PREF_DUMP_SHADERS)\n        envMap.put(\"LIBGL_VGPU_DUMP\", \"1\");\n    if(PREF_ZINK_PREFER_SYSTEM_DRIVER)\n        envMap.put(\"POJAV_ZINK_PREFER_SYSTEM_DRIVER\", \"1\");\n    if(PREF_VSYNC_IN_ZINK)\n        envMap.put(\"POJAV_VSYNC_IN_ZINK\", \"1\");\n    if(Tools.deviceHasHangingLinker())\n        envMap.put(\"POJAV_EMUI_ITERATOR_MITIGATE\", \"1\");\n\n    envMap.put(\"LIBGL_ES\", (String) ExtraCore.getValue(ExtraConstants.OPEN_GL_VERSION));\n    envMap.put(\"FORCE_VSYNC\", String.valueOf(LauncherPreferences.PREF_FORCE_VSYNC));\n    envMap.put(\"MESA_GLSL_CACHE_DIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"force_glsl_extensions_warn\", \"true\");\n    envMap.put(\"allow_higher_compat_version\", \"true\");\n    envMap.put(\"allow_glsl_extension_directive_midshader\", \"true\");\n    envMap.put(\"MESA_LOADER_DRIVER_OVERRIDE\", \"zink\");\n    envMap.put(\"VTEST_SOCKET_NAME\", new File(Tools.DIR_CACHE, \".virgl_test\").getAbsolutePath());\n\n    envMap.put(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n    envMap.put(\"PATH\", jreHome + \"/bin:\" + Os.getenv(\"PATH\"));\n    if(FFmpegPlugin.isAvailable) {\n        envMap.put(\"PATH\", FFmpegPlugin.libraryPath+\":\"+envMap.get(\"PATH\"));\n    }\n\n    if(LOCAL_RENDERER != null) {\n        envMap.put(\"POJAV_RENDERER\", LOCAL_RENDERER);\n        if(LOCAL_RENDERER.equals(\"opengles3_desktopgl_angle_vulkan\")) {\n            envMap.put(\"LIBGL_ES\", \"3\");\n            envMap.put(\"POJAVEXEC_EGL\",\"libEGL_angle.so\");\n        }\n    }\n\n    File customEnvFile = new File(Tools.DIR_GAME_HOME, \"custom_env.txt\");\n    if (customEnvFile.exists() && customEnvFile.isFile()) {\n        BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            int index = line.indexOf(\"=\");\n            envMap.put(line.substring(0, index), line.substring(index + 1));\n        }\n        reader.close();\n    }\n\n    for (Map.Entry<String, String> env : envMap.entrySet()) {\n        try {\n            Os.setenv(env.getKey(), env.getValue(), true);\n        }catch (NullPointerException exception){\n            Log.e(\"JREUtils\", exception.toString());\n        }\n    }\n\n    File serverFile = new File(jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/server/libjvm.so\");\n    jvmLibraryPath = jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/\" + (serverFile.exists() ? \"server\" : \"client\");\n    setLdLibraryPath(jvmLibraryPath+\":\"+LD_LIBRARY_PATH);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport android.app.Activity;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class JREEnvironmentManager {\n\n    private String NATIVE_LIB_DIR;\n    private String LD_LIBRARY_PATH;\n    private String LOCAL_RENDERER;\n    private String jvmLibraryPath;\n    private ProcessBuilder logcatPb;\n    private int failTime = 0;\n\n    public void redirectAndPrintJRELog() {\n        new Thread(() -> {\n            while (failTime < 10) {\n                try {\n                    Process logcatProcess = logcatPb.start();\n                    BufferedReader reader = new BufferedReader(new java.io.InputStreamReader(logcatProcess.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (line.contains(\"JRE\") || line.contains(\"Launcher\") || line.contains(\"PojavLauncher\")) {\n                            Logger.d(line);\n                        }\n                    }\n                    failTime = 0;\n                    break;\n                } catch (IOException e) {\n                    failTime++;\n                    Logger.e(\"Failed to start logcat process\", e);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException ignored) {}\n                }\n            }\n        }).start();\n    }\n\n\n    public void setJavaEnvironment(Activity activity, String jreHome) {\n        NATIVE_LIB_DIR = jreHome + \"/lib/arm64/\";\n        jvmLibraryPath = jreHome + \"/lib/server/libjvm.so\";\n\n        if (!new File(jvmLibraryPath).exists()) {\n            jvmLibraryPath = jreHome + \"/lib/client/libjvm.so\";\n        }\n\n        LOCAL_RENDERER = LauncherPreferences.getString(\"localRenderer\", \"opengles3_desktopgl_angle_vulkan\");\n\n        Map<String, String> env = System.getenv();\n        String path = env.get(\"PATH\");\n        LD_LIBRARY_PATH = NATIVE_LIB_DIR;\n\n        try {\n            File customEnvFile = new File(activity.getFilesDir(), \"custom_env.txt\");\n            if (customEnvFile.exists()) {\n                BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    String[] parts = line.split(\"=\");\n                    if (parts.length == 2) {\n                        System.setProperty(parts[0], parts[1]);\n                    }\n                }\n                reader.close();\n            }\n        } catch (IOException e) {\n            Logger.e(\"Failed to read custom environment variables\", e);\n        }\n\n        setLdLibraryPath(LD_LIBRARY_PATH);\n        System.setProperty(\"PATH\", jreHome + \"/bin:\" + path);\n        System.setProperty(\"localRenderer\", LOCAL_RENDERER);\n\n        logcatPb = new ProcessBuilder(\"logcat\", \"-s\", \"JRE:V\", \"Launcher:V\", \"PojavLauncher:V\", \"System.out:V\", \"PojavLauncherMain:V\");\n        logcatPb.redirectErrorStream(true);\n\n        ExtraCore.setJrePath(jreHome);\n    }\n\n    public void setLdLibraryPath(String path) {\n        LD_LIBRARY_PATH = path;\n        System.setProperty(\"LD_LIBRARY_PATH\", path);\n    }\n}\n```\n"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport android.util.Log;\n\npublic class ShellCommand {\n\n    Runtime rt;\n    String[] command;\n    String tag = null;\n    Process process = null;\n    BufferedReader stdout = null;\n    String error = null;\n    int exitval = -1;\n\n    public ShellCommand(String[] command) {\n        this.rt = Runtime.getRuntime();\n        this.command = command;\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = rt.exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            if (waitForExit) {\n                waitForExit();\n            }\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, error);\n        }\n    }\n\n    public void waitForExit() {\n        if (process != null) {\n            try {\n                while (stdoutAvailable()) {\n                    String line = readStdoutBlocking();\n                    if (line != null && tag != null) {\n                        Log.d(tag, line);\n                    }\n                }\n                exitval = process.waitFor();\n            } catch (InterruptedException e) {\n                error = e.getMessage();\n                Log.e(tag, error);\n            } catch (IOException e) {\n                error = e.getMessage();\n                Log.e(tag, error);\n            }\n        }\n    }\n\n\n    public void finish() {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n\n    public boolean checkForExit() {\n        if (process != null) {\n            try {\n                exitval = process.exitValue();\n                return true;\n            } catch (IllegalThreadStateException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout != null && stdout.ready();\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, error);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            error = e.getMessage();\n            Log.e(tag, error);\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (stdoutAvailable()) {\n            return readStdoutBlocking();\n        }\n        return null;\n    }\n}\n"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map;\n\npublic class SystemInfoUtil {\n\n    public static String getHostName() {\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        if (osName.contains(\"linux\")) {\n            return getUname(\"-n\");\n        } else if (osName.contains(\"windows\")) {\n            Map<String, String> env = System.getenv();\n            if (env.containsKey(\"COMPUTERNAME\")) {\n                return env.get(\"COMPUTERNAME\");\n            } else {\n                return executeCommand(\"hostname\");\n            }\n        }\n        return \"\";\n    }\n\n\n    public static String getUname(String param) {\n        return executeCommand(\"uname \" + param);\n    }\n\n    private static String executeCommand(String command) {\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            StringBuilder output = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(System.lineSeparator());\n            }\n            int exitCode = process.waitFor();\n            if (exitCode == 0) {\n                return output.toString().trim();\n            }\n        } catch (IOException | InterruptedException e) {\n            // Handle exceptions (e.g., log the error)\n        }\n        return \"\";\n    }\n}\n"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TemporaryPorts {\n\n    public static final Path DEFAULT_LOCK_DIRECTORY = Path.of(\"/tmp/helios-test/ports/\");\n\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts(Path lockDirectory) throws IOException {\n        this.lockDirectory = lockDirectory;\n        Files.createDirectories(this.lockDirectory);\n    }\n\n\n    public AllocatedPort tryAcquire(String name, int port) throws IOException {\n        if (port <= 0) {\n            throw new IllegalArgumentException(\"Port must be positive\");\n        }\n        return lock(port, name);\n    }\n\n\n    private synchronized AllocatedPort lock(int port, String name) throws IOException {\n        Path lockFile = lockDirectory.resolve(name + \"-\" + port + \".lock\");\n\n        if (Files.exists(lockFile)) {\n            return null; \n        }\n\n        try (FileChannel channel = FileChannel.open(lockFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n             FileLock lock = channel.tryLock()) {\n            if (lock == null) {\n                return null;\n            }\n            AllocatedPort allocatedPort = new AllocatedPort(port, lockFile, channel, lock);\n            ports.add(allocatedPort);\n            return allocatedPort;\n        } catch (IOException e) {\n            throw new IOException(\"Failed to acquire lock on port \" + port, e);\n        }\n    }\n\n    public class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        private AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n\n        public void release() throws IOException {\n            try {\n                lock.release();\n                file.close();\n                Files.deleteIfExists(path);\n                ports.remove(this);\n            } catch (IOException e) {\n                throw new IOException(\"Failed to release lock on port \" + port, e);\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableMap;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\n\npublic class CliDockerClient {\n\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"/usr/bin/docker\");\n    private static final long DOCKER_OUTPUT_TIMEOUT = Duration.ofMinutes(10).toMillis();\n\n    public CliDockerClient(Path dockerClientPath, Map<String, String> env) {\n        this(defaultProcessBuilderFactory(dockerClientPath.toString(), ImmutableMap.copyOf(env)));\n    }\n\n    CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n        this.processBuilderFactory = processBuilderFactory;\n    }\n\n    private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n            String dockerClientPath, ImmutableMap<String, String> env) {\n        return command -> {\n            ProcessBuilder processBuilder = new ProcessBuilder(command);\n            processBuilder.environment().putAll(env);\n            return processBuilder;\n        };\n    }\n\n\n    private String getStderrOutput(Process process) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) {\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error reading stderr\", e);\n        }\n    }\n\n    public Process docker(String... subCommand) {\n        List<String> command = new java.util.ArrayList<>(List.of(DEFAULT_DOCKER_CLIENT.toString()));\n        command.addAll(List.of(subCommand));\n        ProcessBuilder processBuilder = processBuilderFactory.apply(command);\n        try {\n            Process process = processBuilder.start();\n            if (!process.waitFor(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS)) {\n                process.destroyForcibly();\n                throw new RuntimeException(\"Timeout waiting for docker output\");\n            }\n            if (process.exitValue() != 0) {\n                String stderr = getStderrOutput(process);\n                throw new RuntimeException(String.format(\"Docker command failed with exit code %d: %s\", process.exitValue(), stderr));\n            }\n            return process;\n        } catch (IOException | InterruptedException e) {\n            throw new RuntimeException(\"Error executing docker command\", e);\n        }\n    }\n\n    public DockerInfoDetails info() {\n        try {\n            return fetchInfoDetails();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error fetching docker info\", e);\n        }\n    }\n\n    private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n        Process process = docker(\"info\", \"--format\", \"{{json .}}\");\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {\n            String json = reader.readLine();\n            Preconditions.checkNotNull(json, \"Docker info returned null\");\n            return com.google.gson.GsonUtil.GSON.fromJson(json, DockerInfoDetails.class);\n        }\n    }\n\n\n    private static class DockerInfoDetails {\n        // Add fields as needed to parse Docker info output\n    }\n\n    private static class GsonUtil {\n        private static final com.google.gson.Gson GSON = new com.google.gson.Gson();\n    }\n}\n"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a utility class for executing external processes in Java, handling both command execution and process stream management.\n\nClass Description: A ProcessExecutor utility class that provides methods to execute system commands and external processes, capturing their output and error streams, with proper resource cleanup.\n\nMethods:\n\nMethod1: runCmd(String... cmd) -> String - Executes a command using ProcessBuilder, captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: cmd - Varargs parameter representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod2: runExec(String[] argv) -> String - Executes a command using Runtime.exec(), captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: argv - String array representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod3: processOutputStreamInThread(Process process) -> void - Helper method that reads and discards process output in a separate thread to prevent stream blocking.\nInput: process - The Process object whose output stream needs to be processed\nOutput: None (void)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\n\npublic static String runCmd(String... cmd) throws IOException, InterruptedException {\n    String output;\n    Process process = null;\n    try {\n        process = new ProcessBuilder(cmd).start();\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", cmd[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\npublic static String runExec(String[] argv) throws IOException, InterruptedException {\n    Process process = null;\n    String output;\n    try {\n        process = Runtime.getRuntime().exec(argv);\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", argv[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\nprivate static void processOutputStreamInThread(Process process) throws IOException {\n    InputStreamReader ir = new InputStreamReader(process.getInputStream());\n    LineNumberReader input = new LineNumberReader(ir);\n    while (input.readLine() != null) {\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class ProcessExecutor {\n\n    public String runCmd(String... cmd) throws IOException, InterruptedException {\n        ProcessBuilder builder = new ProcessBuilder(cmd);\n        Process process = builder.start();\n        processOutputStreamInThread(process);\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed with exit code: \" + exitCode + \". Command: \" + Arrays.toString(cmd));\n        }\n        return getOutputFromProcess(process);\n    }\n\n    public String runExec(String[] argv) throws IOException, InterruptedException {\n        Process process = Runtime.getRuntime().exec(argv);\n        processOutputStreamInThread(process);\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed with exit code: \" + exitCode + \". Command: \" + Arrays.toString(argv));\n        }\n        return getOutputFromProcess(process);\n\n    }\n\n    private String getOutputFromProcess(Process process) throws IOException {\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(System.lineSeparator());\n            }\n        }\n        return output.toString();\n    }\n\n\n    public void processOutputStreamInThread(Process process) {\n        new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Process or discard the output\n                }\n            } catch (IOException e) {\n                // Handle exception appropriately, e.g., log the error\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Process or discard the error output\n                    System.err.println(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: The task involves creating utility functions for executing system commands and retrieving information about the Magisk tool using Java's ProcessBuilder for inter-process communication.\n\nFunction Description: The provided code consists of three utility functions that work with system processes to execute commands and retrieve Magisk-related information. These functions demonstrate proper process handling, stream management, and error handling in Java.\n\nMethods:\n\nMethod1: exec(String... command) -> void - Executes a system command using ProcessBuilder. Takes a variable number of strings representing the command and its arguments. Logs the exit code or any errors encountered during execution.\n\nMethod2: getMagiskVersionCode() -> int - Retrieves the version code of Magisk by executing 'magisk -V' command. Returns the version code as an integer, or -1 if an error occurs. Caches the result for subsequent calls.\n\nMethod3: getMagiskTmpfsPath() -> String - Retrieves the tmpfs path used by Magisk by executing 'magisk --path' command. Returns the path as a string, or an empty string if an error occurs. Checks Magisk version first and returns '/sbin' for older versions (<21000). Caches the result for subsequent calls.\n\nAttributes:\nmagiskVersionCode: int - Caches the Magisk version code to avoid repeated process execution\nmagiskTmpfsPath: String - Caches the Magisk tmpfs path to avoid repeated process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.Executors;\n\npublic static void exec(String... command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    try {\n        Process process = pb.start();\n        int code = process.waitFor();\n        Log.i(TAG, \"Exec \" + command[0] + \" exited with \" + code);\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec \" + command[0], e);\n    }\n}\n\npublic static int getMagiskVersionCode() {\n    if (magiskVersionCode != -1) {\n        return magiskVersionCode;\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"-V\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        String line = in.readLine();\n        Log.i(TAG, \"Exec magisk -V: \" + line);\n        magiskVersionCode = Integer.parseInt(line);\n        pr.waitFor();\n        in.close();\n        return magiskVersionCode;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk -V\", e);\n        return -1;\n    }\n}\n\npublic static String getMagiskTmpfsPath() {\n    if (magiskTmpfsPath != null) {\n        return magiskTmpfsPath;\n    }\n\n    if (getMagiskVersionCode() < 21000) {\n        return \"/sbin\";\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"--path\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        magiskTmpfsPath = in.readLine();\n        Log.i(TAG, \"Exec magisk --path: \" + magiskTmpfsPath);\n        pr.waitFor();\n        in.close();\n        return magiskTmpfsPath;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk --path\", e);\n        return \"\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class MagiskUtil {\n\n    private int magiskVersionCode = -1;\n    private String magiskTmpfsPath = null;\n\n    public void exec(String... command) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            Process process = pb.start();\n            int exitCode = process.waitFor();\n\n            if (exitCode != 0) {\n                System.err.println(\"Error executing command: \" + String.join(\" \", command));\n                BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n                String line;\n                while ((line = errorReader.readLine()) != null) {\n                    System.err.println(line);\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Exception executing command: \" + e.getMessage());\n        }\n    }\n\n    public int getMagiskVersionCode() {\n        if (magiskVersionCode != -1) {\n            return magiskVersionCode;\n        }\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"magisk\", \"-V\");\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line = reader.readLine();\n            if (line != null && line.startsWith(\"Magisk v\")) {\n                String versionStr = line.substring(8); // Extract version string\n                magiskVersionCode = Integer.parseInt(versionStr.replace(\".\", \"\"));\n            }\n        } catch (IOException | NumberFormatException e) {\n            System.err.println(\"Error getting Magisk version code: \" + e.getMessage());\n            return -1;\n        }\n        return magiskVersionCode;\n    }\n\n    public String getMagiskTmpfsPath() {\n        if (magiskTmpfsPath != null) {\n            return magiskTmpfsPath;\n        }\n\n        if (getMagiskVersionCode() != -1 && getMagiskVersionCode() < 21000) {\n            magiskTmpfsPath = \"/sbin\";\n            return magiskTmpfsPath;\n        }\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"magisk\", \"--path\");\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            magiskTmpfsPath = reader.readLine();\n        } catch (IOException e) {\n            System.err.println(\"Error getting Magisk tmpfs path: \" + e.getMessage());\n            return \"\";\n        }\n        return magiskTmpfsPath != null ? magiskTmpfsPath : \"\";\n    }\n}\n```\n"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.util.List;\n\npublic class ProcessRunner {\n\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.directory(processRoot);\n        Process process = pb.start();\n        new AsyncPipe(process.getInputStream(), System.out);\n        new AsyncPipe(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        if (builders.length == 0) {\n            return;\n        }\n\n        List<Process> processes = new java.util.ArrayList<>();\n\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder pb = builders[i];\n            pb.directory(processRoot);\n\n            if (i > 0) {\n                pb.redirectInput(ProcessBuilder.Redirect.PIPE);\n            }\n            if (i < builders.length - 1) {\n                pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n            }\n\n            Process p = pb.start();\n            processes.add(p);\n\n            if (i == 0) {\n                new AsyncPipe(is, p.getOutputStream());\n            } else {\n                new AsyncPipe(processes.get(i - 1).getInputStream(), p.getOutputStream());\n            }\n        }\n        new AsyncPipe(processes.get(processes.size() - 1).getInputStream(), os);\n\n\n        for (Process p : processes) {\n            new AsyncPipe(p.getErrorStream(), System.err);\n            p.waitFor();\n        }\n    }\n\n\n    class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n            start();\n        }\n\n        @Override\n        public void run() {\n            try (InputStream input = is; OutputStream output = os) {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = input.read(buffer)) != -1) {\n                    output.write(buffer, 0, len);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "```java\nimport java.io.*;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProcessExecutor {\n\n    private static class BenchmarkException extends Exception {\n        public BenchmarkException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n\n    private static class IterationResult {}\n\n    private static class BinaryLinkServer {}\n\n\n    public static List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(commandString);\n            pb.redirectOutput(stdOut);\n            pb.redirectError(stdErr);\n\n            Process p = pb.start();\n\n            try (BufferedReader outReader = new BufferedReader(new FileReader(stdOut));\n                 BufferedReader errReader = new BufferedReader(new FileReader(stdErr))) {\n\n                if (printOut) {\n                    outReader.lines().forEach(System.out::println);\n                }\n                if (printErr) {\n                    errReader.lines().forEach(System.err::println);\n                }\n            }\n\n\n            if (!p.waitFor(1, TimeUnit.HOURS)) {\n                throw new BenchmarkException(\"Timeout waiting for process\", null);\n            }\n\n            if (p.exitValue() != 0) {\n                throw new BenchmarkException(\"Process exited with code \" + p.exitValue(), null);\n            }\n\n            return reader.readResults();\n\n\n        } catch (IOException | InterruptedException e) {\n            throw new BenchmarkException(\"Error executing process\", e);\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "wrong_result": "import com.rabbitmq.client.*;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.TimeoutException;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"my_queue\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n    }\n\n    public void initializeConnection() throws IOException, TimeoutException {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws IOException {\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            System.out.println(\"Received message: \" + message);\n        };\n        channel.basicConsume(ROUTING_KEY, true, deliverCallback, consumerTag -> {});\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null) {\n            channel.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MessageConsumer consumer = new MessageConsumer();\n        consumer.initializeConnection();\n        consumer.startConsuming();\n    }\n}\n"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.sync.RedisCommands;\n\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\n\npublic class LettuceRedisUtils {\n\n    private static final String REDIS_HOST = \"localhost\";\n    private static final int REDIS_PORT = 6379;\n    private static final String REDIS_PASSWORD = \"\"; // Replace with your password if needed\n\n    private static final RedisClient REDIS_CLIENT = RedisClient.create(\"redis://\" + REDIS_PASSWORD + \"@\" + REDIS_HOST + \":\" + REDIS_PORT);\n\n    private static StatefulRedisConnection<String, String> connect() {\n        return REDIS_CLIENT.connect();\n    }\n\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        try (StatefulRedisConnection<String, String> connection = connect()) {\n            RedisAsyncCommands<String, String> asyncCommands = connection.async();\n            asyncCommands.setAutoFlushCommands(false);\n\n            List<RedisFuture<?>> futures = pipelineCallBack.doInPipeline(asyncCommands);\n\n            asyncCommands.flushCommands();\n\n            for (RedisFuture<?> future : futures) {\n                try {\n                    future.get();\n                } catch (InterruptedException | ExecutionException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Error executing Redis command in pipeline\", e);\n                }\n            }\n\n        }\n    }\n\n\n    @FunctionalInterface\n    public interface RedisPipelineCallBack {\n        List<RedisFuture<?>> doInPipeline(RedisAsyncCommands<String, String> asyncCommands);\n    }\n\n    public static void main(String[] args) {\n        LettuceRedisUtils.pipeline(asyncCommands -> {\n            RedisFuture<String> future1 = asyncCommands.set(\"key1\", \"value1\");\n            RedisFuture<String> future2 = asyncCommands.get(\"key1\");\n            return List.of(future1, future2);\n        });\n\n    }\n}\n\n```\n"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "```java\nimport io.undertow.server.HttpServerExchange;\nimport org.xnio.channels.StreamSinkChannel;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.concurrent.TimeUnit;\n\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\n\n\npublic class FileConduitTarget implements StreamSinkConduit {\n\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private volatile boolean writesResumed;\n\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel src, long position, long count) throws IOException {\n        return fileChannel.transferFrom(src, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long count, ByteBuffer throughBuffer) throws IOException {\n        return source.transferTo(count, throughBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer src) throws IOException {\n        return fileChannel.write(src);\n    }\n\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return fileChannel.write(srcs, offset, length);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return write(src); // No specific final write operation for FileChannel\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return write(srcs, offset, length); // No specific final write operation for FileChannel\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n        if (writeReadyHandler != null) {\n            getWriteThread().execute(writeReadyHandler);\n        }\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null && writesResumed) {\n            getWriteThread().execute(writeReadyHandler);\n        }\n    }\n\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() {\n        // No-op for FileChannel\n    }\n\n    @Override\n    public void awaitWritable(long time, TimeUnit timeUnit) {\n        // No-op for FileChannel\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getConnection().getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close(); // Effectively truncates by closing\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true; // FileChannel doesn't buffer, so flush is always successful\n    }\n\n    private XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}\n```"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class ReliableTransaction<T> {\n\n    private Queue<Response<?>> pipelinedResponses = new LinkedBlockingQueue<>();\n    private Connection connection;\n    private boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private CommandObjects commandObjects;\n\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean pipelined, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n    }\n\n    public void multi() {\n        if (inMulti) {\n            throw new IllegalStateException(\"Already in MULTI\");\n        }\n        connection.multi();\n        inMulti = true;\n    }\n\n    public String watch(String... keys) {\n        if (inMulti) {\n            throw new IllegalStateException(\"WATCH inside MULTI is not allowed\");\n        }\n        String status = connection.watch(keys);\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        String status = connection.unwatch();\n        inWatch = false;\n        return status;\n    }\n\n\n    public <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        Response<T> response = commandObject.execute(connection);\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n\n    public void close() {\n        clear();\n        if (closeConnection) {\n            connection.close();\n        }\n    }\n\n    public void clear() {\n        if (inMulti) {\n            discard();\n        }\n        if (inWatch) {\n            unwatch();\n        }\n        pipelinedResponses.clear();\n        broken = false;\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"Not in MULTI\");\n        }\n        List<Object> unformatted = connection.exec();\n        inMulti = false;\n        inWatch = false;\n        List<Object> formatted = new ArrayList<>();\n        if (unformatted != null) {\n            for (int i = 0; i < unformatted.size(); ++i) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    if (response != null) {\n                        Object object = response.get();\n                        formatted.add(object);\n                    }\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n        } else {\n            broken = true;\n        }\n        return formatted;\n    }\n\n    public String discard() {\n        String status = connection.discard();\n        inMulti = false;\n        inWatch = false;\n        pipelinedResponses.clear();\n        return status;\n    }\n\n\n    interface CommandObjects {\n        <T> CommandObject<T> get(String name, byte[]... args);\n    }\n\n    interface CommandObject<T> {\n        Response<T> execute(Connection connection);\n    }\n}\n"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class RedisRegistry {\n\n    private ConcurrentHashMap<String, JedisPool> jedisPools = new ConcurrentHashMap<>();\n    private String clusterName;\n    private boolean replicate;\n    private ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<>();\n\n    public RedisRegistry(AppContext appContext) {\n        // Initialization logic using appContext (omitted for brevity)\n        this.clusterName = appContext.getClusterName();\n        this.replicate = appContext.isReplicate();\n        // ... (JedisPool creation and configuration based on appContext)\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        try (Jedis jedis = jedisPools.get(\"default\").getResource()) { // Example using a \"default\" pool\n            // Registration logic using jedis (e.g., jedis.set(...))\n        } catch (Exception e) {\n            throw new NodeRegistryException(\"Failed to register node\", e);\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        String path = node.getPath();\n        Notifier notifier = notifiers.computeIfAbsent(path, k -> new Notifier(path, listener));\n        notifier.start();\n    }\n\n\n    private class NotifySub extends JedisPubSub {\n        private final NotifyListener listener;\n\n        public NotifySub(NotifyListener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            listener.notify(key, msg);\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String path;\n        private final NotifyListener listener;\n        private final JedisPool jedisPool; // Use a specific pool or the default one\n        private volatile boolean running = true;\n        private final NotifySub notifySub;\n\n\n        public Notifier(String path, NotifyListener listener) {\n            this.path = path;\n            this.listener = listener;\n            this.jedisPool = jedisPools.get(\"default\"); // Example using \"default\" pool\n            this.notifySub = new NotifySub(listener);\n        }\n\n        @Override\n        public void run() {\n            try (Jedis jedis = jedisPool.getResource()) {\n                while (running) {\n                    jedis.subscribe(notifySub, path);\n                }\n            } catch (Exception e) {\n                // Handle exceptions (e.g., reconnect logic)\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n            notifySub.unsubscribe();\n        }\n    }\n\n\n    public interface NotifyListener {\n        void notify(String key, String msg);\n    }\n\n    public static class Node {\n        private String path;\n\n        public Node(String path) {\n            this.path = path;\n        }\n\n        public String getPath() {\n            return path;\n        }\n    }\n\n    public static class AppContext {\n        public String getClusterName() { return \"defaultCluster\"; }\n        public boolean isReplicate() { return true; }\n        // ... other methods for configuration retrieval\n    }\n\n    public static class NodeRegistryException extends Exception {\n        public NodeRegistryException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n}\n```"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, management, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Lettuce client. It provides methods to establish a connection with configurable timeout options, retrieve the active connection, and properly close the connection when no longer needed.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte array codec\n\nMethods:\n- setupConnection(String host, int port) -> void - Initializes the Redis client and establishes a connection to the specified Redis server with a 10-second timeout configuration\n- closeConnection() -> void - Properly closes the active connection and shuts down the Redis client\n- getConnection() -> StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection instance",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(RedisURI.create(host, port));\n        redisClient.setOptions(ClientOptions.builder()\n                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown(0, 0, TimeUnit.SECONDS);\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport java.time.Duration;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        RedisURI redisURI = RedisURI.builder()\n                .withHost(host)\n                .withPort(port)\n                .withTimeout(Duration.ofSeconds(10))\n                .build();\n\n        redisClient = RedisClient.create(redisURI);\n        connection = redisClient.connect(new ByteArrayCodec());\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}\n"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.security.TokenBasedRedisCredentialsProvider;\n\nimport java.time.Duration;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        this.credentialsUser1 = new TokenBasedRedisCredentialsProvider(authority, scopes, user1ClientId, user1Secret.getBytes());\n        this.credentialsUser2 = new TokenBasedRedisCredentialsProvider(authority, scopes, user2ClientId, user2Secret.getBytes());\n\n        RedisURI redisURI = RedisURI.create(redisUri);\n        redisURI.setVerifyPeer(false);\n\n        ClientResources clientResources = ClientResources.builder()\n                .reconnectDelay(Duration.ofSeconds(5))\n                .build();\n\n        this.redisClient = RedisClient.create(clientResources, redisURI);\n        this.redisClusterClient = RedisClusterClient.create(clientResources, redisURI);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(String.class, credentialsUser1);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        return redisClient.connect(String.class, credentialsUser2);\n    }\n\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return redisClusterClient.connect(String.class, credentialsUser1);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.lucene.store.AlreadyClosedException;\n\npublic final class TranslogReader extends BaseTranslogReader {\n\n    private final long length;\n    private final int totalOperations;\n    protected final Checkpoint checkpoint;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n\n    private TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.checkpoint = checkpoint;\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n    }\n\n    public static TranslogReader open(final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    public TranslogReader closeIntoTrimmedReader(final long offset, final ChannelFactory channelFactory) throws IOException {\n        // Ensures that no operations can be performed against this reader after it's been closed\n        if (closed.compareAndSet(false, true)) {\n            try {\n                channel.close();\n            } catch (final Exception e) {\n                // ignore\n            }\n            if (offset >= length) {\n                return this;\n            } else {\n                final Checkpoint cp = new Checkpoint(checkpoint.generation, offset, totalOperations);\n                return open(channelFactory.open(path), path, cp, getHeader().getTranslogUUID());\n            }\n        }\n        throw new AlreadyClosedException(\"translog reader already closed\");\n    }\n\n\n    @Override\n    public long sizeInBytes() {\n        return length;\n    }\n\n    @Override\n    public int totalOperations() {\n        return totalOperations;\n    }\n\n    @Override\n    public Checkpoint getCheckpoint() {\n        return checkpoint;\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos: \" + position + \", limit: \" + length);\n        }\n        channel.read(buffer, position);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    @Override\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(\"translog reader already closed\");\n        }\n    }\n\n    protected static class ChannelFactory {\n        public FileChannel open(Path path) throws IOException {\n            return FileChannel.open(path);\n        }\n    }\n\n    static final class Checkpoint {\n        final long generation;\n        final long offset;\n        final int numOps;\n\n        Checkpoint(long generation, long offset, int numOps) {\n            this.generation = generation;\n            this.offset = offset;\n            this.numOps = numOps;\n        }\n    }\n\n    static final class TranslogHeader {\n        public static TranslogHeader read(String translogUUID, FileChannel channel) {\n            return new TranslogHeader(translogUUID);\n        }\n\n        private final String translogUUID;\n\n        TranslogHeader(String translogUUID) {\n            this.translogUUID = translogUUID;\n        }\n\n        String getTranslogUUID() {\n            return translogUUID;\n        }\n    }\n\n    static class BaseTranslogReader {\n        protected final long generation;\n        protected final FileChannel channel;\n        protected final Path path;\n        protected final TranslogHeader header;\n\n        BaseTranslogReader(long generation, FileChannel channel, Path path, TranslogHeader header) {\n            this.generation = generation;\n            this.channel = channel;\n            this.path = path;\n            this.header = header;\n        }\n\n        public TranslogHeader getHeader() {\n            return header;\n        }\n\n        protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        }\n\n        public long sizeInBytes() {\n            return 0;\n        }\n\n        public int totalOperations() {\n            return 0;\n        }\n\n        public Checkpoint getCheckpoint() {\n            return null;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Create a Java class that manages authentication and operations for a Redis cluster using Jedis client library, with support for token-based authentication and connection pooling.\n\nClass Description: RedisClusterAuthManager is a class that handles Redis cluster authentication and operations. It provides methods to execute basic Redis operations and test re-authentication functionality in a multi-threaded environment.\n\nAttributes:\n- idpConfig: [IdentityProviderConfig] - Configuration for the identity provider that generates authentication tokens\n- authXManager: [AuthXManager] - Manager responsible for handling authentication processes\n- config: [JedisClientConfig] - Configuration for the Jedis client\n- poolConfig: [ConnectionPoolConfig] - Configuration for the connection pool\n- hostAndPort: [HostAndPort] - Redis cluster endpoint information\n\nMethods:\n- RedisClusterAuthManager([HostAndPort hostAndPort]) -> [void] - Constructor that initializes the authentication manager with Redis cluster endpoint\n- executeRedisOperations() -> [void] - Executes basic Redis operations (set, get, delete) on the cluster\n- testReAuthentication() -> [void] - Tests re-authentication functionality in a multi-threaded environment, verifying that connections properly re-authenticate",
    "Canonical_solution": "import redis.clients.authentication.core.IdentityProvider;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.SimpleToken;\nimport redis.clients.authentication.core.Token;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPoolConfig;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.EndpointConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisCluster;\n\npublic class RedisClusterAuthManager {\n\n    private final IdentityProviderConfig idpConfig;\n    private final AuthXManager authXManager;\n    private final JedisClientConfig config;\n    private final ConnectionPoolConfig poolConfig;\n    private final HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig() {\n            @Override\n            public IdentityProvider getProvider() {\n                return new IdentityProvider() {\n                    @Override\n                    public Token requestToken() {\n                        return new SimpleToken(\"default\", \"cluster\",\n                                System.currentTimeMillis() + 5 * 1000, System.currentTimeMillis(),\n                                null);\n                    }\n                };\n            }\n        };\n        this.authXManager = new AuthXManager(EntraIDTokenAuthConfigBuilder.builder()\n                .lowerRefreshBoundMillis(1000).identityProviderConfig(idpConfig).build());\n        this.config = DefaultJedisClientConfig.builder().authXManager(authXManager).build();\n        this.poolConfig = new ConnectionPoolConfig();\n    }\n\n    public void executeRedisOperations() {\n        try (JedisCluster jc = new JedisCluster(hostAndPort, config, 5, poolConfig)) {\n            jc.set(\"foo\", \"bar\");\n            jc.get(\"foo\");\n            jc.del(\"foo\");\n        }\n    }\n\n    public void testReAuthentication() throws InterruptedException, ExecutionException {\n        AuthXManager spyManager = spy(authXManager);\n        List<Connection> connections = new ArrayList<>();\n        \n        doAnswer(invocation -> {\n            Connection connection = spy((Connection) invocation.getArgument(0));\n            invocation.getArguments()[0] = connection;\n            connections.add(connection);\n            Object result = invocation.callRealMethod();\n            return result;\n        }).when(spyManager).addConnection(any(Connection.class));\n\n        JedisClientConfig spyConfig = DefaultJedisClientConfig.builder().authXManager(spyManager).build();\n        \n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch latch = new CountDownLatch(1);\n        \n        try (JedisCluster jc = new JedisCluster(Collections.singleton(hostAndPort), spyConfig)) {\n            Runnable task = () -> {\n                while (latch.getCount() > 0) {\n                    jc.set(\"foo\", \"bar\");\n                }\n            };\n            Future task1 = executorService.submit(task);\n            Future task2 = executorService.submit(task);\n\n            await().pollInterval(ONE_HUNDRED_MILLISECONDS).atMost(ONE_SECOND)\n                    .until(connections::size, greaterThanOrEqualTo(2));\n\n            connections.forEach(conn -> {\n                verify(conn, atLeast(2)).reAuthenticate();\n            });\n            \n            latch.countDown();\n            task1.get();\n            task2.get();\n        } finally {\n            latch.countDown();\n            executorService.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.*;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class RedisClusterAuthManager {\n\n    private IdentityProviderConfig idpConfig; // Assume this class exists\n    private AuthXManager authXManager; // Assume this class exists\n    private JedisClientConfig config; // Assume this class exists\n    private GenericObjectPoolConfig poolConfig;\n    private HostAndPort hostAndPort;\n\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig(); // Replace with actual initialization\n        this.authXManager = new AuthXManager(idpConfig); // Replace with actual initialization\n        this.config = new JedisClientConfig(); // Replace with actual initialization\n        this.poolConfig = new GenericObjectPoolConfig();\n\n    }\n\n    public void executeRedisOperations() {\n        Set<HostAndPort> jedisClusterNodes = new HashSet<>(Arrays.asList(hostAndPort));\n        try (JedisCluster jedisCluster = new JedisCluster(jedisClusterNodes, config.getTimeout(), config.getTimeout(), config.getMaxRedirections(), authXManager.getToken(), poolConfig)) {\n            jedisCluster.set(\"foo\", \"bar\");\n            String value = jedisCluster.get(\"foo\");\n            jedisCluster.del(\"foo\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public void testReAuthentication() {\n        Runnable runnable = () -> {\n            try (JedisCluster jedisCluster = new JedisCluster(new HashSet<>(Arrays.asList(hostAndPort)), config.getTimeout(), config.getTimeout(), config.getMaxRedirections(), authXManager.getToken(), poolConfig)) {\n                for (int i = 0; i < 10; i++) {\n                    jedisCluster.set(\"key\" + i, \"value\" + i);\n                    System.out.println(Thread.currentThread().getName() + \": \" + jedisCluster.get(\"key\" + i));\n                    Thread.sleep(100); // Simulate some work\n                }\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        };\n\n        Thread thread1 = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n\n        thread1.start();\n        thread2.start();\n\n        try {\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    // Assume these classes exist and are properly implemented\n    private static class IdentityProviderConfig {}\n    private static class AuthXManager {\n        public AuthXManager(IdentityProviderConfig config) {}\n        public String getToken() { return \"dummy-token\"; } // Replace with actual token retrieval\n    }\n    private static class JedisClientConfig {\n        public int getTimeout() { return 10000; }\n        public int getMaxRedirections() { return 5; }\n    }\n\n}\n```"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport io.lettuce.core.Connection;\nimport io.lettuce.core.cluster.ClusterConnectionProvider;\nimport io.lettuce.core.protocol.CommandObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.Instant;\n\npublic class ClusterCommandExecutor<T> {\n\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log = LoggerFactory.getLogger(ClusterCommandExecutor.class);\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public T broadcastCommand(CommandObject<T> commandObject) {\n        return provider.broadcast(commandObject);\n    }\n\n    public T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attemptsLeft = maxAttempts;\n        int consecutiveConnectionFailures = 0;\n        Instant doneDeadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        while (attemptsLeft > 0 && Instant.now().isBefore(doneDeadline)) {\n            try (Connection connection = toReplica ? provider.getConnection(ClusterConnectionProvider.Intent.READ) : provider.getConnection(ClusterConnectionProvider.Intent.WRITE)) {\n                return execute(connection, commandObject);\n            } catch (Exception e) {\n                attemptsLeft--;\n                consecutiveConnectionFailures++;\n                if (!handleConnectionProblem(attemptsLeft, consecutiveConnectionFailures, doneDeadline)) {\n                    throw e; // Re-throw if handling failed\n                }\n            }\n        }\n        throw new RuntimeException(\"Failed to execute command after multiple retries\");\n    }\n\n\n    private T execute(Connection connection, CommandObject<T> commandObject) {\n        return connection.dispatch(commandObject);\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n        if (attemptsLeft <= 0 || Instant.now().isAfter(doneDeadline)) {\n            return false;\n        }\n        long sleepMillis = getBackoffSleepMillis(attemptsLeft, doneDeadline);\n        log.warn(\"Connection problem, retrying in {}ms ({} attempts left)\", sleepMillis, attemptsLeft);\n        provider.reset(); // Reset slot cache\n        sleep(sleepMillis);\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long maxSleep = Duration.between(Instant.now(), deadline).toMillis();\n        long backoff = (long) Math.pow(2, maxAttempts - attemptsLeft);\n        return Math.min(backoff * 10, maxSleep);\n    }\n\n    private void sleep(long sleepMillis) {\n        try {\n            Thread.sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Interrupted while waiting to retry\", e);\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.params.SetParams;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\n\npublic class RedisDao {\n\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(50);\n        poolConfig.setMaxIdle(10);\n        this.jedisPool = new JedisPool(poolConfig, ip, port, 3000);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return getSeckill(seckillId, jedis);\n        }\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        String key = getSeckillRedisKey(seckillId);\n        byte[] bytes = jedis.get(key.getBytes());\n        if (bytes != null) {\n            Seckill seckill = schema.newMessage();\n            ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n            return seckill;\n        }\n        return null;\n    }\n\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            String lockKey = \"lock:\" + seckillId;\n            String lockValue = String.valueOf(System.nanoTime() + 10000); // Lock timeout 10 seconds\n\n            if (jedis.set(lockKey, lockValue, SetParams.setParams().nx().px(10000)) != null) { // Acquire lock\n                try {\n                    Seckill seckill = getSeckill(seckillId, jedis);\n                    if (seckill == null) {\n                        seckill = getDataFromDb.apply(seckillId);\n                        if (seckill != null) {\n                            putSeckill(seckill, jedis);\n                        }\n                    }\n                    return seckill;\n                } finally {\n                    if (lockValue.equals(jedis.get(lockKey))) { // Release lock only if held by current thread\n                        jedis.del(lockKey);\n                    }\n                }\n            } else {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(50); // Retry after a short delay\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                return getOrPutSeckill(seckillId, getDataFromDb); // Recursive call for retry\n            }\n        }\n    }\n\n\n    public String putSeckill(Seckill seckill) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            return putSeckill(seckill, jedis);\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        String key = getSeckillRedisKey(seckill.getSeckillId());\n        byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n        int timeout = 60 * 60; // 1 hour\n        String result = jedis.setex(key.getBytes(), timeout, bytes);\n        return result;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}\n```"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.HostAndPortMapper;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n    private final HostAndPort hostAndPort;\n    private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n    private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n    private boolean ssl;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper = HostAndPortMapper.NO_OP_MAPPER;\n\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n    }\n\n    public DefaultJedisSocketFactory() {\n        this(new HostAndPort(Protocol.DEFAULT_HOST, Protocol.DEFAULT_PORT));\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this(new HostAndPort(config.getHost(), config.getPort()), config);\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this(hostAndPort);\n        this.connectionTimeout = config.getConnectionTimeoutMillis();\n        this.socketTimeout = config.getSocketTimeoutMillis();\n        this.ssl = config.isSsl();\n        this.sslSocketFactory = config.getSslSocketFactory();\n        this.sslParameters = config.getSslParameters();\n        this.hostnameVerifier = config.getHostnameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n\n    private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws IOException {\n        List<HostAndPort> hostAndPorts = Arrays.asList(hostAndPort);\n        if (hostAndPortMapper != null) {\n            hostAndPorts = hostAndPortMapper.mapToHostAndPorts(hostAndPort);\n        }\n\n        IOException ex = null;\n        for (HostAndPort hnp : hostAndPorts) {\n            try {\n                Socket socket = _createSocket(hnp.getHost(), hnp.getPort());\n                return socket;\n            } catch (IOException e) {\n                ex = e;\n            }\n        }\n        throw ex;\n    }\n\n    private Socket _createSocket(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        try {\n            socket.connect(new java.net.InetSocketAddress(host, port), connectionTimeout);\n            socket.setSoTimeout(socketTimeout);\n            return socket;\n        } catch (IOException ex) {\n            socket.close();\n            throw ex;\n        }\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        HostAndPort hostAndPort = getSocketHostAndPort();\n        Socket socket = connectToFirstSuccessfulHost(hostAndPort);\n\n        if (ssl) {\n            try {\n                SSLSocketFactory sslSocketFactory = this.sslSocketFactory != null ? this.sslSocketFactory : (SSLSocketFactory) SSLSocketFactory.getDefault();\n                SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(socket, hostAndPort.getHost(), hostAndPort.getPort(), true);\n                if (sslParameters != null) {\n                    sslSocket.setSSLParameters(sslParameters);\n                }\n\n                if (hostnameVerifier != null) {\n                    if (!hostnameVerifier.verify(hostAndPort.getHost(), sslSocket.getSession())) {\n                        throw new JedisConnectionException(\"The connection to '\" + hostAndPort + \"' failed ssl/tls hostname verification.\");\n                    }\n                }\n                socket = sslSocket;\n            } catch (IOException ex) {\n                socket.close();\n                throw ex;\n            }\n        }\n        return socket;\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        return hostAndPort;\n    }\n}\n```"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Java class that utilizes Java NIO's FileChannel to map a file into memory for read-only access, providing methods to access the mapped memory address and file size, and properly closing the channel when done.\n\nClass Description: The FileChannelProcessor class provides functionality to open a file using FileChannel, map it into memory in read-only mode, and expose the memory address and file size. It ensures proper resource cleanup by implementing a close method.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedAddress: long - The memory address where the file is mapped\nfileSize: long - The size of the mapped file in bytes\n\nMethods:\nFileChannelProcessor: [Constructor](String filePath) throws IOException - Initializes the FileChannel, maps the file into memory in read-only mode, and stores the memory address and file size\ngetMappedAddress: () -> long - Returns the memory address where the file is mapped\ngetFileSize: () -> long - Returns the size of the mapped file\nclose: () throws IOException - Closes the FileChannel to release system resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mappedAddress = fileChannel.map(MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class FileChannelProcessor {\n\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        RandomAccessFile file = new RandomAccessFile(filePath, \"r\");\n        this.fileChannel = file.getChannel();\n        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());\n        this.mappedAddress = buffer.addressOffset(); // Use addressOffset for memory address\n        this.fileSize = fileChannel.size();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Flux;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(\"redis://localhost:6379\");\n        connection = client.connect();\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.flushall();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        RedisCommands<String, String> syncCommands = connection.sync();\n        for (long i = 0; i < elements; i++) {\n            syncCommands.set(\"key\" + i, \"value\" + i);\n        }\n\n        return Flux.create(sink -> {\n            for (long i = 0; i < elements; i++) {\n                sink.next(\"key\" + i);\n            }\n            sink.complete();\n        });\n    }\n}\n"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Create a Java class that implements a Redis Sentinel connection pool for managing connections to a Redis master server, with automatic failover handling when the master changes.\n\nClass Description: JedisSentinelPool is a connection pool implementation that maintains connections to a Redis master server discovered through Redis Sentinel. It automatically handles master failover by monitoring Sentinel notifications and reconfiguring the connection pool when the master changes.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- factory: JedisFactory - Factory for creating Jedis instances\n- sentinelClientConfig: JedisClientConfig - Configuration for connecting to Sentinels\n- masterListeners: Collection<MasterListener> - Collection of threads monitoring Sentinel servers\n- currentHostMaster: HostAndPort - Current master server address (volatile)\n- initPoolLock: Lock - Lock for thread-safe pool initialization\n\nMethods:\n- JedisSentinelPool(String, Set<HostAndPort>, JedisFactory, JedisClientConfig) -> void - Constructor that initializes the Sentinel pool with master name, Sentinel addresses, factory, and client config\n- initMaster(HostAndPort) -> void - Initializes or updates the master connection pool\n- initSentinels(Set<HostAndPort>, String) -> HostAndPort - Discovers the current master from Sentinels and starts listeners\n- toHostAndPort(List<String>) -> HostAndPort - Converts Sentinel response to HostAndPort object\n- getResource() -> Jedis - Gets a Jedis resource from the pool (overrides parent method)\n- returnResource(Jedis) -> void - Returns a Jedis resource to the pool (overrides parent method)\n\nNested Class MasterListener:\n- masterName: String - Name of the monitored master\n- host: String - Sentinel host address\n- port: int - Sentinel port number\n- subscribeRetryWaitTimeMillis: long - Retry wait time for subscription\n- j: Jedis - Jedis instance for Sentinel connection\n- running: AtomicBoolean - Flag controlling listener thread\n\nMasterListener Methods:\n- MasterListener(String, String, int) -> void - Constructor for Sentinel listener\n- run() -> void - Main listener thread that monitors Sentinel for master changes\n- shutdown() -> void - Gracefully shuts down the listener thread",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPool extends Pool<Jedis> {\n\n  private static final Logger LOG = LoggerFactory.getLogger(JedisSentinelPool.class);\n  private final JedisFactory factory;\n  private final JedisClientConfig sentinelClientConfig;\n  protected final Collection<MasterListener> masterListeners = new ArrayList<>();\n  private volatile HostAndPort currentHostMaster;\n  private final Lock initPoolLock = new ReentrantLock(true);\n\n  public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,\n      final JedisFactory factory, final JedisClientConfig sentinelClientConfig) {\n    super(factory);\n    this.factory = factory;\n    this.sentinelClientConfig = sentinelClientConfig;\n    HostAndPort master = initSentinels(sentinels, masterName);\n    initMaster(master);\n  }\n\n  private void initMaster(HostAndPort master) {\n    initPoolLock.lock();\n    try {\n      if (!master.equals(currentHostMaster)) {\n        currentHostMaster = master;\n        factory.setHostAndPort(currentHostMaster);\n        super.clear();\n        LOG.info(\"Created JedisSentinelPool to master at {}\", master);\n      }\n    } finally {\n      initPoolLock.unlock();\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels, final String masterName) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n    LOG.info(\"Trying to find master from available Sentinels...\");\n\n    for (HostAndPort sentinel : sentinels) {\n      LOG.debug(\"Connecting to Sentinel {}\", sentinel);\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n        if (masterAddr == null || masterAddr.size() != 2) {\n          LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}\", masterName, sentinel);\n          continue;\n        }\n        master = toHostAndPort(masterAddr);\n        LOG.debug(\"Found Redis master at {}\", master);\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Cannot get master address from sentinel running @ {}. Reason: {}. Trying next one.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored...\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where is \" + masterName + \" master is running...\");\n      }\n    }\n\n    LOG.info(\"Redis master running at {}, starting Sentinel listeners...\", master);\n    for (HostAndPort sentinel : sentinels) {\n      MasterListener masterListener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());\n      masterListener.setDaemon(true);\n      masterListeners.add(masterListener);\n      masterListener.start();\n    }\n    return master;\n  }\n\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n  @Override\n  public Jedis getResource() {\n    while (true) {\n      Jedis jedis = super.getResource();\n      jedis.setDataSource(this);\n      final HostAndPort master = currentHostMaster;\n      final HostAndPort connection = jedis.getClient().getHostAndPort();\n      if (master.equals(connection)) {\n        return jedis;\n      } else {\n        returnBrokenResource(jedis);\n      }\n    }\n  }\n\n  @Override\n  public void returnResource(final Jedis resource) {\n    if (resource != null) {\n      try {\n        resource.resetState();\n        super.returnResource(resource);\n      } catch (RuntimeException e) {\n        returnBrokenResource(resource);\n        LOG.debug(\"Resource is returned to the pool as broken\", e);\n      }\n    }\n  }\n\n  protected class MasterListener extends Thread {\n    protected String masterName;\n    protected String host;\n    protected int port;\n    protected long subscribeRetryWaitTimeMillis = 5000;\n    protected volatile Jedis j;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public MasterListener(String masterName, String host, int port) {\n      super(String.format(\"MasterListener-%s-[%s:%d]\", masterName, host, port));\n      this.masterName = masterName;\n      this.host = host;\n      this.port = port;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        try {\n          if (!running.get()) break;\n          final HostAndPort hostPort = new HostAndPort(host, port);\n          j = new Jedis(hostPort, sentinelClientConfig);\n          List<String> masterAddr = j.sentinelGetMasterAddrByName(masterName);\n          if (masterAddr == null || masterAddr.size() != 2) {\n            LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}.\", masterName, hostPort);\n          } else {\n            initMaster(toHostAndPort(masterAddr));\n          }\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              LOG.debug(\"Sentinel {} published: {}.\", hostPort, message);\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  initMaster(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  LOG.debug(\"Ignoring message on +switch-master for master name {}, our master name is {}\",\n                      switchMasterMsg[0], masterName);\n                }\n              } else {\n                LOG.error(\"Invalid message received on Sentinel {} on channel +switch-master: {}\",\n                    hostPort, message);\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            LOG.error(\"Lost connection to Sentinel at {}:{}. Sleeping 5000ms and retrying.\", host, port, e);\n            try {\n              Thread.sleep(subscribeRetryWaitTimeMillis);\n            } catch (InterruptedException e1) {\n              LOG.error(\"Sleep interrupted: \", e1);\n            }\n          } else {\n            LOG.debug(\"Unsubscribing from Sentinel at {}:{}\", host, port);\n          }\n        } finally {\n          if (j != null) {\n            j.close();\n          }\n        }\n      }\n    }\n\n    public void shutdown() {\n      try {\n        LOG.debug(\"Shutting down listener on {}:{}\", host, port);\n        running.set(false);\n        if (j != null) {\n          j.close();\n        }\n      } catch (RuntimeException e) {\n        LOG.error(\"Caught exception while shutting down: \", e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": ""
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.cache.interceptor.KeyGenerator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport com.alibaba.fastjson2.support.spring.data.redis.GenericFastJsonRedisSerializer;\n\nimport java.lang.reflect.Method;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n@Configuration\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n\n        GenericFastJsonRedisSerializer fastJsonRedisSerializer = new GenericFastJsonRedisSerializer();\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        redisTemplate.setKeySerializer(stringRedisSerializer);\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n\n        redisTemplate.setValueSerializer(fastJsonRedisSerializer);\n        redisTemplate.setHashValueSerializer(fastJsonRedisSerializer);\n        return redisTemplate;\n    }\n\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        String url = REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort();\n        SingleServerConfig singleServerConfig = config.useSingleServer()\n                .setAddress(url)\n                .setPassword(redisProperties.getPassword())\n                .setDatabase(redisProperties.getDatabase());\n        if (redisProperties.getTimeout() != null) {\n            singleServerConfig.setConnectTimeout((int) redisProperties.getTimeout().toMillis());\n        }\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return new KeyGenerator() {\n            @Override\n            public Object generate(Object target, Method method, Object... params) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(target.getClass().getName());\n                sb.append(method.getName());\n                for (Object obj : params) {\n                    sb.append(obj.toString());\n                }\n                try {\n                    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n                    byte[] hash = digest.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n                    StringBuilder hexString = new StringBuilder();\n                    for (byte b : hash) {\n                        String hex = Integer.toHexString(0xff & b);\n                        if (hex.length() == 1) hexString.append('0');\n                        hexString.append(hex);\n                    }\n                    return hexString.toString();\n                } catch (NoSuchAlgorithmException e) {\n                    e.printStackTrace();\n                }\n                return sb.toString();\n\n            }\n        };\n    }\n}\n```"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Create a Java utility class for interacting with Redis using sharded connections, providing thread-safe initialization, connection pooling, and basic CRUD operations for both string and object values.\n\nClass Description: JedisUtil is a utility class that manages Redis connections using Jedis sharding with connection pooling. It provides methods for storing and retrieving both string and serialized object values with expiration support.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging messages\n- address: String - Comma-separated Redis server addresses\n- shardedJedisPool: ShardedJedisPool - Pool of sharded Redis connections\n- INSTANCE_INIT_LOCL: ReentrantLock - Lock for thread-safe initialization\n\nMethods:\n- init(String address) -> void - Initializes the Redis connection pool with the given addresses\n- getInstance() -> ShardedJedis - Returns a sharded Redis connection instance (thread-safe initialization)\n- close() -> void - Closes the Redis connection pool and releases resources\n- serialize(Object object) -> byte[] - Serializes a Java object to byte array\n- unserialize(byte[] bytes) -> Object - Deserializes a byte array back to a Java object\n- setStringValue(String key, String value, int seconds) -> String - Stores a string value in Redis with expiration time\n- setObjectValue(String key, Object obj, int seconds) -> String - Stores a serialized object in Redis with expiration time\n- getStringValue(String key) -> String - Retrieves a string value from Redis\n- getObjectValue(String key) -> Object - Retrieves and deserializes an object from Redis",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.JedisShardInfo;\nimport redis.clients.jedis.ShardedJedis;\nimport redis.clients.jedis.ShardedJedisPool;\n\nimport java.io.*;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JedisUtil {\n    private static Logger logger = LoggerFactory.getLogger(JedisUtil.class);\n    private static String address;\n    private static ShardedJedisPool shardedJedisPool;\n    private static ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock(false);\n\n    public static void init(String address) {\n        JedisUtil.address = address;\n        getInstance();\n    }\n\n    private static ShardedJedis getInstance() {\n        if (shardedJedisPool == null) {\n            try {\n                if (INSTANCE_INIT_LOCL.tryLock(2, TimeUnit.SECONDS)) {\n                    try {\n                        if (shardedJedisPool == null) {\n                            JedisPoolConfig config = new JedisPoolConfig();\n                            config.setMaxTotal(200);\n                            config.setMaxIdle(50);\n                            config.setMinIdle(8);\n                            config.setMaxWaitMillis(10000);\n                            config.setTestOnBorrow(true);\n                            config.setTestOnReturn(false);\n                            config.setTestWhileIdle(true);\n                            config.setTimeBetweenEvictionRunsMillis(30000);\n                            config.setNumTestsPerEvictionRun(10);\n                            config.setMinEvictableIdleTimeMillis(60000);\n\n                            List<JedisShardInfo> jedisShardInfos = new LinkedList<JedisShardInfo>();\n                            String[] addressArr = address.split(\",\");\n                            for (int i = 0; i < addressArr.length; i++) {\n                                JedisShardInfo jedisShardInfo = new JedisShardInfo(addressArr[i]);\n                                jedisShardInfos.add(jedisShardInfo);\n                            }\n                            shardedJedisPool = new ShardedJedisPool(config, jedisShardInfos);\n                            logger.info(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool init success.\");\n                        }\n                    } finally {\n                        INSTANCE_INIT_LOCL.unlock();\n                    }\n                }\n            } catch (InterruptedException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n\n        if (shardedJedisPool == null) {\n            throw new NullPointerException(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool is null.\");\n        }\n\n        return shardedJedisPool.getResource();\n    }\n\n    public static void close() throws IOException {\n        if(shardedJedisPool != null) {\n            shardedJedisPool.close();\n        }\n    }\n\n    private static byte[] serialize(Object object) {\n        ObjectOutputStream oos = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            baos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream(baos);\n            oos.writeObject(object);\n            return baos.toByteArray();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (oos != null) oos.close();\n                if (baos != null) baos.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    private static Object unserialize(byte[] bytes) {\n        ByteArrayInputStream bais = null;\n        try {\n            bais = new ByteArrayInputStream(bytes);\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            return ois.readObject();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (bais != null) bais.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    public static String setStringValue(String key, String value, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key, seconds, value);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String setObjectValue(String key, Object obj, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key.getBytes(), seconds, serialize(obj));\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String getStringValue(String key) {\n        String value = null;\n        ShardedJedis client = getInstance();\n        try {\n            value = client.get(key);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return value;\n    }\n\n    public static Object getObjectValue(String key) {\n        Object obj = null;\n        ShardedJedis client = getInstance();\n        try {\n            byte[] bytes = client.get(key.getBytes());\n            if (bytes != null && bytes.length > 0) {\n                obj = unserialize(bytes);\n            }\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return obj;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JedisUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisUtil.class);\n    private String address;\n    private ShardedJedisPool shardedJedisPool;\n    private static JedisUtil instance;\n    private static final ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock();\n\n    private JedisUtil() {}\n\n    public static JedisUtil getInstance() {\n        if (instance == null) {\n            INSTANCE_INIT_LOCL.lock();\n            try {\n                if (instance == null) {\n                    instance = new JedisUtil();\n                }\n            } finally {\n                INSTANCE_INIT_LOCL.unlock();\n            }\n        }\n        return instance;\n    }\n\n\n    public void init(String address) {\n        this.address = address;\n        List<JedisShardInfo> shards = Arrays.stream(address.split(\",\"))\n                .map(addr -> new JedisShardInfo(addr)).toList();\n        this.shardedJedisPool = new ShardedJedisPool(new JedisPoolConfig(), shards);\n    }\n\n    public void close() {\n        if (shardedJedisPool != null) {\n            shardedJedisPool.close();\n        }\n    }\n\n    private ShardedJedis getConnection() {\n        return shardedJedisPool.getResource();\n    }\n\n    public byte[] serialize(Object object) {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n            oos.writeObject(object);\n            return bos.toByteArray();\n        } catch (IOException e) {\n            logger.error(\"Serialization error:\", e);\n            return null;\n        }\n    }\n\n    public Object unserialize(byte[] bytes) {\n        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n             ObjectInputStream ois = new ObjectInputStream(bis)) {\n            return ois.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            logger.error(\"Deserialization error:\", e);\n            return null;\n        }\n    }\n\n    public String setStringValue(String key, String value, int seconds) {\n        try (ShardedJedis jedis = getConnection()) {\n            return jedis.setex(key, seconds, value);\n        }\n    }\n\n\n    public String setObjectValue(String key, Object obj, int seconds) {\n        try (ShardedJedis jedis = getConnection()) {\n            byte[] serializedObj = serialize(obj);\n            if (serializedObj != null) {\n                return jedis.setex(key.getBytes(), seconds, serializedObj);\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public String getStringValue(String key) {\n        try (ShardedJedis jedis = getConnection()) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object getObjectValue(String key) {\n        try (ShardedJedis jedis = getConnection()) {\n            byte[] result = jedis.get(key.getBytes());\n            return result != null ? unserialize(result) : null;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Create a Java class that establishes and manages connections to a Redis master-replica setup using Lettuce client, with support for read operations from replicas and secure connection handling.\n\nClass Description: RedisMasterReplicaConnector is a utility class that provides methods to create, manage, and close connections to a Redis master-replica cluster. It supports read scaling by allowing read operations from replicas and includes secure connection handling with custom DNS resolution.\n\nAttributes:\n- clientResources: ClientResources - The Lettuce client resources configuration including custom socket address resolver\n\nMethods:\n- RedisMasterReplicaConnector(ClientResources) -> void - Constructor that initializes client resources with custom DNS resolution\n- createConnection(String host, String masterId) -> StatefulRedisMasterReplicaConnection<String, String> - Creates a connection to Redis master-replica setup with specified host and master ID\n- closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) -> void - Properly closes the Redis connection and shuts down the client\n- performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) -> void - Demonstrates basic Redis operations (set and get) using the established connection",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient client = RedisClient.create(clientResources);\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":26379?sentinelMasterId=\" + masterId);\n        redisURI.setVerifyPeer(false);\n        \n        StatefulRedisMasterReplicaConnection<String, String> connection = \n            MasterReplica.connect(client, StringCodec.UTF8, redisURI);\n        connection.setReadFrom(ReadFrom.REPLICA);\n        \n        return connection;\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n            FastShutdown.shutdown(connection.getRedisClient());\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        connection.sync().set(key, value);\n        connection.sync().get(key);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DefaultClientResources;\nimport java.time.Duration;\nimport java.util.List;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n\n    public StatefulRedisClusterConnection<String, String> createConnection(List<String> nodes, String masterId) {\n        RedisURI.Builder builder = RedisURI.builder();\n        for (String node : nodes) {\n            String[] parts = node.split(\":\");\n            builder.withHost(parts[0]).withPort(Integer.parseInt(parts[1]));\n        }\n\n        RedisClusterClient clusterClient = RedisClusterClient.create(clientResources, builder.build());\n\n        ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(30))\n                .enableAllAdaptiveRefreshTriggers()\n                .build();\n\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .topologyRefreshOptions(topologyRefreshOptions)\n                .readFrom(ReadFrom.REPLICA_PREFERRED)\n                .build();\n\n        clusterClient.setOptions(clusterClientOptions);\n\n        return clusterClient.connect();\n    }\n\n\n    public void closeConnection(StatefulRedisClusterConnection<String, String> connection) {\n        connection.close();\n        connection.getApi().getStatefulConnection().close();\n    }\n\n    public void performOperations(StatefulRedisClusterConnection<String, String> connection, String key, String value) {\n        RedisAdvancedClusterCommands<String, String> commands = connection.sync();\n        commands.set(key, value);\n        String retrievedValue = commands.get(key);\n        System.out.println(\"Retrieved value: \" + retrievedValue);\n    }\n\n\n    public static void main(String[] args) {\n        ClientResources clientResources = DefaultClientResources.create();\n        RedisMasterReplicaConnector connector = new RedisMasterReplicaConnector(clientResources);\n\n        List<String> nodes = List.of(\"localhost:7000\", \"localhost:7001\", \"localhost:7002\");\n        StatefulRedisClusterConnection<String, String> connection = connector.createConnection(nodes, \"masterId\");\n\n        connector.performOperations(connection, \"testkey\", \"testvalue\");\n\n        connector.closeConnection(connection);\n        clientResources.shutdown();\n\n    }\n}\n"
  },
  {
    "Task_id": 339,
    "Instruction": "Task Description: Implement a Redis client class in Java that supports read-write operations with master-slave architecture, connection pooling, and proper resource management.\n\nClass Description: ReadWriteRedisClient is a Java class that provides a Redis client implementation with support for master-slave architecture. It uses connection pooling (via JedisPool) for efficient resource management and implements basic CRUD operations with automatic routing of read operations to slaves and write operations to the master.\n\nAttributes:\n- master: JedisPool - Connection pool for the master Redis instance\n- slaves: List<JedisPool> - List of connection pools for slave Redis instances\n- jedisPoolConfig: JedisPoolConfig - Configuration for the connection pools\n- address: String - Comma-separated list of Redis server addresses (master first)\n- timeout: int - Connection timeout in milliseconds\n- random: Random - Random number generator for slave selection\n\nMethods:\n- initialize() -> void - Initializes the Redis connection pools based on the configured addresses\n- destroy() -> void - Closes all connection pools and releases resources\n- get(String key) -> String - Retrieves a value from Redis (reads from a random slave)\n- set(String key, String value) -> String - Stores a value in Redis (writes to master)\n- fetchResource(boolean read) -> Jedis - Internal method to get a Redis connection (selects master or random slave)\n- setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) -> void - Sets the connection pool configuration\n- setTimeout(int timeout) -> void - Sets the connection timeout\n- setAddress(String address) -> void - Sets the Redis server addresses",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class ReadWriteRedisClient {\n\n    private JedisPool master;\n    private List<JedisPool> slaves = new ArrayList<JedisPool>();\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout = 3000;\n    private Random random = new Random();\n\n    public void initialize() throws Exception {\n        String[] hostAndPorts = address.split(\",\");\n        String masterHP = hostAndPorts[0];\n        String[] ms = masterHP.split(\":\");\n        master = new JedisPool(jedisPoolConfig, ms[0], Integer.valueOf(ms[1]), timeout);\n        if (hostAndPorts.length > 1) {\n            for (int i = 1; i < hostAndPorts.length; i++) {\n                String[] ss = hostAndPorts[i].split(\":\");\n                JedisPool slave = new JedisPool(jedisPoolConfig, ss[0], Integer.valueOf(ss[1]), timeout);\n                slaves.add(slave);\n            }\n        }\n        slaves.add(master);\n    }\n\n    public void destroy() throws Exception {\n        if (master != null) {\n            master.close();\n        }\n        for (JedisPool slave : slaves) {\n            if (slave != null) {\n                slave.close();\n            }\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = fetchResource(true);\n        try {\n            return jedis.get(key);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = fetchResource(false);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if(slaves.isEmpty() || !read) {\n            return master.getResource();\n        }\n        int size = slaves.size();\n        int i = random.nextInt(size);\n        return slaves.get(i).getResource();\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\npublic class ReadWriteRedisClient {\n\n    private JedisPool master;\n    private List<JedisPool> slaves = new ArrayList<>();\n    private JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n    private String address;\n    private int timeout = 2000;\n    private Random random = new Random();\n\n    public void initialize() {\n        String[] addresses = address.split(\",\");\n        String masterAddress = addresses[0];\n        master = new JedisPool(jedisPoolConfig, masterAddress.split(\":\")[0], Integer.parseInt(masterAddress.split(\":\")[1]), timeout);\n        for (int i = 1; i < addresses.length; i++) {\n            String slaveAddress = addresses[i];\n            slaves.add(new JedisPool(jedisPoolConfig, slaveAddress.split(\":\")[0], Integer.parseInt(slaveAddress.split(\":\")[1]), timeout));\n        }\n    }\n\n    public void destroy() {\n        if (master != null) {\n            master.destroy();\n        }\n        for (JedisPool slave : slaves) {\n            slave.destroy();\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = fetchResource(true)) {\n            return jedis.get(key);\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = fetchResource(false)) {\n            return jedis.set(key, value);\n        }\n    }\n\n\n    private Jedis fetchResource(boolean read) {\n        if (read && !slaves.isEmpty()) {\n            int index = random.nextInt(slaves.size());\n            return slaves.get(index).getResource();\n        }\n        return master.getResource();\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a Java class that implements Redis client functionality using Jedis for basic key-value operations, hash operations, and key expiration management.\n\nClass Description: JedisClientSingle is a Redis client wrapper class that provides simplified access to common Redis operations using connection pooling. It handles connection management, authentication, and resource cleanup automatically.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- password: String - The password for Redis authentication (optional)\n- port: int - The port number of the Redis server\n- host: String - The host address of the Redis server\n- logger: Logger - SLF4J logger instance for logging operations\n\nMethods:\n- getResource() -> Jedis - Internal method to get a Jedis instance from the pool and authenticate if needed\n- get(String key) -> String - Retrieves the value associated with the given key\n- set(String key, String value) -> String - Sets the value for the given key\n- hget(String hkey, String key) -> String - Gets the value of a field in a hash\n- hset(String hkey, String key, String value) -> long - Sets the value of a field in a hash\n- incr(String key) -> long - Increments the integer value of a key by 1\n- expire(String key, Integer second) -> long - Sets a timeout on a key\n- ttl(String key) -> long - Gets the remaining time to live of a key\n- del(String key) -> long - Deletes a key\n- hdel(String hkey, String key) -> long - Deletes a field from a hash",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisClientSingle {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    private Jedis getResource() {\n        if(jedisPool==null) {\n            jedisPool = new JedisPool(host, port);\n        }\n        Jedis resource = jedisPool.getResource();\n        if (StringUtils.isBlank(password)) {\n            return resource;\n        } else {\n            resource.auth(password);\n            return resource;\n        }\n    }\n\n    public String get(String key) {\n        Jedis resource = getResource();\n        String string = resource.get(key);\n        resource.close();\n        return string;\n    }\n\n    public String set(String key, String value) {\n        Jedis resource = getResource();\n        String string = resource.set(key, value);\n        resource.close();\n        return string;\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis resource = getResource();\n        String string = resource.hget(hkey, key);\n        resource.close();\n        return string;\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis resource = getResource();\n        Long hset = resource.hset(hkey, key, value);\n        resource.close();\n        return hset;\n    }\n\n    public long incr(String key) {\n        Jedis resource = getResource();\n        Long incr = resource.incr(key);\n        resource.close();\n        return incr;\n    }\n\n    public long expire(String key, Integer second) {\n        Jedis resource = getResource();\n        Long expire = resource.expire(key, second);\n        resource.close();\n        return expire;\n    }\n\n    public long ttl(String key) {\n        Jedis resource = getResource();\n        Long ttl = resource.ttl(key);\n        resource.close();\n        return ttl;\n    }\n\n    public long del(String key) {\n        Jedis resource = getResource();\n        Long del = resource.del(key);\n        resource.close();\n        return del;\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis resource = getResource();\n        Long hdel = resource.hdel(hkey, key);\n        resource.close();\n        return hdel;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class JedisClientSingle {\n\n    private final JedisPool jedisPool;\n    private final String password;\n    private final int port;\n    private final String host;\n\n    private final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n\n    public JedisClientSingle(String host, int port, String password) {\n        this.host = host;\n        this.port = port;\n        this.password = password;\n\n        JedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxTotal(8);\n        config.setMaxIdle(8);\n        config.setMinIdle(0);\n        config.setMaxWaitMillis(10000);\n        config.setTestOnBorrow(true);\n\n        if (password != null && !password.isEmpty()) {\n            jedisPool = new JedisPool(config, host, port, 10000, password);\n        } else {\n            jedisPool = new JedisPool(config, host, port, 10000);\n        }\n    }\n\n    private Jedis getResource() {\n        Jedis jedis = jedisPool.getResource();\n        if (password != null && !password.isEmpty()) {\n            jedis.auth(password);\n        }\n        return jedis;\n    }\n\n\n    public String get(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.get(key);\n        }\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String hget(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hget(hkey, key);\n        }\n    }\n\n    public long hset(String hkey, String key, String value) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hset(hkey, key, value);\n        }\n    }\n\n    public long incr(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.incr(key);\n        }\n    }\n\n    public long expire(String key, Integer second) {\n        try (Jedis jedis = getResource()) {\n            return jedis.expire(key, second);\n        }\n    }\n\n    public long ttl(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.ttl(key);\n        }\n    }\n\n    public long del(String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.del(key);\n        }\n    }\n\n    public long hdel(String hkey, String key) {\n        try (Jedis jedis = getResource()) {\n            return jedis.hdel(hkey, key);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.JedisCluster;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private final JedisCluster redis;\n    private final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n\n    public JedisClusterCacheManager(JedisCluster redis, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = redis;\n    }\n\n\n    @Override\n    protected IRedis getRedis() {\n        return new JedisClusterClient(redis);\n    }\n\n    public static class JedisClusterClient implements IRedis {\n        private final JedisCluster jedisCluster;\n\n        public JedisClusterClient(JedisCluster jedisCluster) {\n            this.jedisCluster = jedisCluster;\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            jedisCluster.hset(key, field, value);\n            jedisCluster.expire(key, seconds);\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            params.forEach(param -> jedisCluster.set(param.getKey(), param.getValue()));\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public void del(byte[] key) {\n            jedisCluster.del(key);\n        }\n    }\n\n\n    @Override\n    public <T> Map<CacheKeyTO, CacheWrapper<Object>> mget(Type type, Set<CacheKeyTO> keys) {\n        return super.mget(type, keys);\n    }\n\n    @Override\n    public void delete(Set<CacheKeyTO> keys) {\n        super.delete(keys);\n    }\n}\n```"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message consumer using the push model. The class should handle message consumption from a specified topic, with configurable NameServer address and consumer group settings.\n\nClass Description: The Consumer class is a RocketMQ message consumer implementation that subscribes to a topic and processes incoming messages asynchronously. It uses DefaultMQPushConsumer for push-based consumption and provides methods to start, shutdown, and configure the consumer.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address if none is provided\n- TOPIC: [String] - The topic to subscribe to for messages\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- Consumer() - [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers a message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer gracefully\n- setNamesrvAddr(String namesrvAddr) -> [void] - Sets the NameServer address for the consumer",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\n\npublic class Consumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_4\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msg);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": ""
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to monitor and handle offset moved events in a message queue system.\n\nClass Description: The RocketMQConsumer class is designed to consume messages from a RocketMQ broker, specifically monitoring for offset moved events. It uses a push-based consumption model with a single-threaded listener to process messages. The class handles message subscription, listener configuration, and consumer lifecycle management.\n\nAttributes:\n- defaultMQPushConsumer: DefaultMQPushConsumer - The main consumer instance that connects to RocketMQ and handles message consumption\n- monitorListener: MonitorListener - (Assumed from context) Listener interface for reporting delete message events\n\nMethods:\n- RocketMQConsumer(RPCHook, String) -> void - Constructor that initializes the consumer with RPC hook and NameServer address\n- generateInstanceName(String) -> String - Generates a unique instance name for the consumer\n- configureMessageListener() -> void - Configures the message listener to handle incoming messages\n- subscribeToTopic() -> void - Subscribes to the offset moved event topic\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n\n    public RocketMQConsumer(RPCHook rpcHook, String namesrvAddr) throws MQClientException {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(MixAll.MONITOR_CONSUMER_GROUP, rpcHook);\n        this.defaultMQPushConsumer.setNamesrvAddr(namesrvAddr);\n        this.defaultMQPushConsumer.setInstanceName(generateInstanceName(namesrvAddr));\n        this.defaultMQPushConsumer.setConsumeThreadMin(1);\n        this.defaultMQPushConsumer.setConsumeThreadMax(1);\n        \n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String namesrvAddr) {\n        return \"MonitorService_\" + (System.currentTimeMillis() + RandomUtils.nextInt(0, Integer.MAX_VALUE) + namesrvAddr).hashCode();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                try {\n                    OffsetMovedEvent ome =\n                        OffsetMovedEvent.decode(msgs.get(0).getBody(), OffsetMovedEvent.class);\n\n                    DeleteMsgsEvent deleteMsgsEvent = new DeleteMsgsEvent();\n                    deleteMsgsEvent.setOffsetMovedEvent(ome);\n                    deleteMsgsEvent.setEventTimestamp(msgs.get(0).getStoreTimestamp());\n\n                    MonitorService.this.monitorListener.reportDeleteMsgsEvent(deleteMsgsEvent);\n                } catch (Exception e) {\n                }\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    private void subscribeToTopic() throws MQClientException {\n        this.defaultMQPushConsumer.subscribe(TopicValidator.RMQ_SYS_OFFSET_MOVED_EVENT, \"*\");\n    }\n\n    public void start() throws MQClientException {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.hook.RPCHook;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.List;\nimport java.util.UUID;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private MonitorListener monitorListener;\n\n\n    public RocketMQConsumer(RPCHook rpcHook, String nameSrvAddr) {\n        defaultMQPushConsumer = new DefaultMQPushConsumer(\"CID_OFFSET_MOVED\", rpcHook);\n        defaultMQPushConsumer.setNamesrvAddr(nameSrvAddr);\n        defaultMQPushConsumer.setInstanceName(generateInstanceName(\"CID_OFFSET_MOVED\"));\n        defaultMQPushConsumer.setMessageModel(MessageModel.CLUSTERING);\n        defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        configureMessageListener();\n    }\n\n    private String generateInstanceName(String cid) {\n        return cid + \"_\" + UUID.randomUUID().toString().replace(\"-\", \"\");\n    }\n\n    private void configureMessageListener() {\n        defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    if (monitorListener != null) {\n                        monitorListener.onMessageDelete(msg.getTopic(), msg.getQueueId(), msg.getQueueOffset());\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n\n    public void subscribeToTopic() throws MQClientException {\n        defaultMQPushConsumer.subscribe(\"OFFSET_MOVED_EVENT\", \"*\");\n    }\n\n    public void start() throws MQClientException {\n        defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        defaultMQPushConsumer.shutdown();\n    }\n\n    public void setMonitorListener(MonitorListener monitorListener) {\n        this.monitorListener = monitorListener;\n    }\n\n\n    public interface MonitorListener {\n        void onMessageDelete(String topic, int queueId, long queueOffset);\n    }\n}\n"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\nimport java.util.Random;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subscription);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    try {\n                        if (returnFailedHalf && new Random().nextInt(100) < 50) {\n                            throw new RuntimeException(\"Simulate processing failure for half of the messages.\");\n                        }\n                        // Process message\n                        System.out.printf(\"Consume message: %s%n\", new String(msg.getBody()));\n\n                    } catch (Exception e) {\n                        System.err.printf(\"Failed to process message: %s, Error: %s%n\", new String(msg.getBody()), e.getMessage());\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}\n```\n"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport com.aliyun.openservices.ons.api.Consumer;\nimport com.aliyun.openservices.ons.api.ONSFactory;\nimport com.aliyun.openservices.ons.api.PropertyKeyConst;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.core.config.AliyunMqConfigurationProperties;\nimport com.paascloud.listener.UacPushMessageListener;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.task.TaskExecutor;\n\nimport java.util.Properties;\n\n@Slf4j\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean(initMethod = \"start\", destroyMethod = \"shutdown\")\n    public Consumer defaultMQPushConsumer() {\n\n        AliyunMqConfigurationProperties rocketProperties = paascloudProperties.getRocketMq();\n        Properties properties = new Properties();\n        properties.setProperty(PropertyKeyConst.ConsumerId, rocketProperties.getConsumerGroup());\n        properties.setProperty(PropertyKeyConst.AccessKey, rocketProperties.getAccessKey());\n        properties.setProperty(PropertyKeyConst.SecretKey, rocketProperties.getSecretKey());\n        properties.setProperty(PropertyKeyConst.NAMESRV_ADDR, rocketProperties.getNamesrvAddr());\n        properties.put(PropertyKeyConst.ConsumeThreadNums, rocketProperties.getConsumeThreadNums());\n        properties.put(PropertyKeyConst.MaxReconsumeTimes, rocketProperties.getMaxReconsumeTimes());\n        properties.put(PropertyKeyConst.SuspendTimeMillis, rocketProperties.getSuspendTimeMillis());\n\n        Consumer consumer = ONSFactory.createPushConsumer(properties);\n        consumer.subscribe(rocketProperties.getTopic(), rocketProperties.getTag(), uacPushMessageListener);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                log.error(\"error.\", e);\n                Thread.currentThread().interrupt();\n            }\n            consumer.start();\n\n        });\n\n        return consumer;\n    }\n}\n```"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a Java class that manages a mark file for inter-process communication, allowing processes to check the status of another process through a shared memory-mapped file. The class should handle file creation, version checking, timestamp validation, and resource cleanup.\n\nClass Description: The MarkFile class provides a mechanism for processes to communicate their liveness status via a memory-mapped file. It supports checking version compatibility, monitoring heartbeat timestamps, and ensuring proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- markFile: File - The physical file used for marking process status\n- mappedBuffer: MappedByteBuffer - The memory-mapped buffer for file operations\n- buffer: UnsafeBuffer - Wrapper around mappedBuffer for atomic operations\n- isClosed: AtomicBoolean - Flag indicating whether resources have been released\n\nMethods:\n- MarkFile(File, boolean, int, int, int, long, EpochClock, IntConsumer, Consumer<String>) -> void - Constructor that initializes the mark file with version and timestamp fields\n- close() -> void - Releases resources and closes the file channel\n- mapNewOrExistingMarkFile(File, boolean, int, int, long, long, EpochClock, IntConsumer, Consumer<String>) -> MappedByteBuffer - Static method that maps the file into memory and performs version/timestamp validation\n- ensureMarkFileLink(File, File, String) -> void - Static method that manages symbolic links to the mark file directory",
    "Canonical_solution": "import org.agrona.concurrent.UnsafeBuffer;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.function.IntConsumer;\nimport static java.nio.channels.FileChannel.MapMode.READ_WRITE;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.nio.file.StandardOpenOption.WRITE;\n\npublic class MarkFile implements AutoCloseable\n{\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean();\n\n    public MarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final int totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(\n            markFile,\n            shouldPreExist,\n            versionFieldOffset,\n            timestampFieldOffset,\n            totalFileLength,\n            timeoutMs,\n            epochClock,\n            versionCheck,\n            logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    public void close()\n    {\n        if (isClosed.compareAndSet(false, true))\n        {\n            BufferUtil.free(mappedBuffer);\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final long totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        MappedByteBuffer byteBuffer = null;\n\n        try (FileChannel channel = FileChannel.open(markFile.toPath(), CREATE, READ, WRITE))\n        {\n            byteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, totalFileLength);\n            final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);\n\n            if (shouldPreExist)\n            {\n                if (buffer.capacity() < (timestampFieldOffset + SIZE_OF_LONG))\n                {\n                    throw new IllegalStateException(\"active MarkFile too short capacity=\" + buffer.capacity() +\n                        \" < \" + (timestampFieldOffset + SIZE_OF_LONG));\n                }\n\n                final int version = buffer.getIntVolatile(versionFieldOffset);\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: Mark file exists: \" + markFile);\n                }\n\n                versionCheck.accept(version);\n\n                final long timestampMs = buffer.getLongVolatile(timestampFieldOffset);\n                final long timestampAgeMs = epochClock.time() - timestampMs;\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: heartbeat timestampMs=\" + timestampMs + \" ageMs=\" + timestampAgeMs);\n                }\n\n                if (timestampAgeMs < timeoutMs)\n                {\n                    throw new IllegalStateException(\"active Mark file detected\");\n                }\n            }\n        }\n        catch (final Exception ex)\n        {\n            if (null != byteBuffer)\n            {\n                BufferUtil.free(byteBuffer);\n            }\n\n            throw new RuntimeException(ex);\n        }\n\n        return byteBuffer;\n    }\n\n    public static void ensureMarkFileLink(final File serviceDir, final File actualFile, final String linkFilename)\n    {\n        final Path linkFile = new File(serviceDir, linkFilename).toPath();\n        if (serviceDir.equals(actualFile.getParentFile()))\n        {\n            try\n            {\n                Files.deleteIfExists(linkFile);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to remove old link file\", ex);\n            }\n        }\n        else\n        {\n            try\n            {\n                Files.write(\n                    linkFile,\n                    actualFile.getParent().getBytes(US_ASCII),\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.TRUNCATE_EXISTING);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to create link for mark file directory\", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.Files;\nimport java.time.Instant;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.function.IntConsumer;\nimport org.agrona.UnsafeAccess;\nimport org.agrona.concurrent.EpochClock;\nimport org.agrona.concurrent.UnsafeBuffer;\n\n\npublic class MarkFile implements AutoCloseable {\n\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean();\n\n    public MarkFile(\n            final File markFile,\n            final boolean createIfMissing,\n            final int versionFieldOffset,\n            final int timestampFieldOffset,\n            final int version,\n            final long timestamp,\n            final EpochClock clock,\n            final IntConsumer versionErrorHandler,\n            final Consumer<String> logger) throws IOException\n    {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(\n            markFile, createIfMissing, versionFieldOffset, timestampFieldOffset, version, timestamp, clock,\n            versionErrorHandler, logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n        final File markFile,\n        final boolean createIfMissing,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final int version,\n        final long timestamp,\n        final EpochClock clock,\n        final IntConsumer versionErrorHandler,\n        final Consumer<String> logger) throws IOException\n    {\n        if (markFile.exists())\n        {\n            try (RandomAccessFile raf = new RandomAccessFile(markFile, \"rw\");\n                FileChannel channel = raf.getChannel();\n                FileLock lock = channel.lock())\n            {\n                final long size = channel.size();\n                if (size < timestampFieldOffset + Long.BYTES)\n                {\n                    logger.accept(\"Existing Mark file is too short. Truncating and rewriting.\");\n                    channel.truncate(timestampFieldOffset + Long.BYTES);\n                }\n\n                final MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());\n                final int existingVersion = buffer.getInt(versionFieldOffset);\n                if (existingVersion != version)\n                {\n                    versionErrorHandler.accept(existingVersion);\n                }\n\n                buffer.putLong(timestampFieldOffset, timestamp);\n                return buffer;\n            }\n        }\n        else if (createIfMissing)\n        {\n            final File parentDir = markFile.getParentFile();\n            if (parentDir != null && !parentDir.mkdirs() && !parentDir.isDirectory())\n            {\n                throw new IOException(\"Failed to create directory: \" + parentDir);\n            }\n\n            try (RandomAccessFile raf = new RandomAccessFile(markFile, \"rw\");\n                FileChannel channel = raf.getChannel();\n                FileLock lock = channel.lock())\n            {\n                channel.truncate(timestampFieldOffset + Long.BYTES);\n                final MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());\n                buffer.putInt(versionFieldOffset, version);\n                buffer.putLong(timestampFieldOffset, timestamp);\n                return buffer;\n            }\n        }\n\n        return null;\n    }\n\n    public static void ensureMarkFileLink(final File markFileDir, final File markFileLink, final String linkName)\n        throws IOException\n    {\n        final File targetAsFile = new File(markFileDir, linkName);\n        if (!Files.exists(markFileLink.toPath()))\n        {\n            Files.createSymbolicLink(markFileLink.toPath(), targetAsFile.toPath());\n        }\n    }\n\n    public void close()\n    {\n        if (isClosed.compareAndSet(false, true))\n        {\n            UnsafeAccess.UNSAFE.invokeCleaner(mappedBuffer);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class that sets up a RocketMQ push consumer (`DefaultMQPushConsumer`). It configures the consumer with NameServer address, consumption strategy, topic subscriptions with tags, and registers a message listener. The consumer is started asynchronously after a delay.\n\nAttributes:\n- `paascloudProperties`: [PaascloudProperties] - Contains configuration properties for the RocketMQ consumer, including NameServer address and consumer group.\n- `optPushConsumer`: [OptPushMessageListener] - The message listener implementation that handles incoming messages.\n- `taskExecutor`: [TaskExecutor] - Executor service used to start the consumer asynchronously.\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer. Sets the NameServer address, consumption strategy, subscribes to topics with tags, registers the message listener, and starts the consumer asynchronously after a delay. Throws `MQClientException` if there's an error in consumer configuration.\n\nThe class follows Spring's dependency injection pattern and uses `@Bean` to expose the consumer instance to the Spring context. The consumer is started in a separate thread to avoid blocking the main application startup.",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.consumer.listener.OptPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.task.TaskExecutor;\n\nimport javax.annotation.Resource;\n\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private OptPushMessageListener optPushConsumer;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.OPT.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(optPushConsumer);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                e.printStackTrace();\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport com.aliyun.openservices.ons.api.Consumer;\nimport com.aliyun.openservices.ons.api.MessageListener;\nimport com.aliyun.openservices.ons.api.ONSFactory;\nimport com.aliyun.openservices.ons.api.PropertyKeyConst;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.listener.OptPushMessageListener;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.task.TaskExecutor;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Properties;\n\n@Slf4j\n@Component\npublic class AliyunMqConfiguration {\n\n    private final PaascloudProperties paascloudProperties;\n    private final OptPushMessageListener optPushConsumer;\n    private final TaskExecutor taskExecutor;\n\n    @Autowired\n    public AliyunMqConfiguration(PaascloudProperties paascloudProperties, OptPushMessageListener optPushConsumer, TaskExecutor taskExecutor) {\n        this.paascloudProperties = paascloudProperties;\n        this.optPushConsumer = optPushConsumer;\n        this.taskExecutor = taskExecutor;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public Consumer defaultMQPushConsumer() throws Exception {\n        final Properties properties = new Properties();\n        properties.setProperty(PropertyKeyConst.AccessKey, paascloudProperties.getAliyun().getAccessKey());\n        properties.setProperty(PropertyKeyConst.SecretKey, paascloudProperties.getAliyun().getSecretKey());\n        properties.setProperty(PropertyKeyConst.NAMESRV_ADDR, paascloudProperties.getAliyun().getMq().getServers());\n        properties.setProperty(PropertyKeyConst.ConsumeThreadNums, paascloudProperties.getAliyun().getMq().getConsumerThreads());\n        properties.put(PropertyKeyConst.GROUP_ID, paascloudProperties.getAliyun().getMq().getConsumerGroup());\n        properties.setProperty(PropertyKeyConst.MessageModel, paascloudProperties.getAliyun().getMq().getMessageModel());\n        Consumer consumer = ONSFactory.createPushConsumer(properties);\n\n        consumer.subscribe(paascloudProperties.getAliyun().getMq().getTopic(), paascloudProperties.getAliyun().getMq().getTag(), (message, context) -> {\n            log.info(\"Receive: \" + message);\n            optPushConsumer.consumeMessage(message.getBody(), message.getTag());\n            return MessageListener.Action.CommitMessage;\n        });\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n                log.info(\"RocketMQ push consumer started.\");\n\n            } catch (final Exception e) {\n                log.error(\"RocketMQ push consumer start failed.\", e);\n                throw new RuntimeException(e);\n            }\n        });\n\n        return consumer;\n    }\n}\n```\n"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.hook.RPCHook;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n\n    private static final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n    private final RPCHook rpcHook;\n    private final String topicName;\n    private final String consumerGroup;\n\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup, rpcHook);\n    }\n\n    public void startConsumer() throws Exception {\n        defaultMQPushConsumer.subscribe(topicName, \"*\");\n        defaultMQPushConsumer.registerMessageListener(this);\n        defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        defaultMQPushConsumer.shutdown();\n    }\n\n\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n        for (MessageExt msg : msgs) {\n            try {\n                String messageBody = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);\n                log.info(\"Received message: {}\", messageBody);\n                // Process the message here\n            } catch (UnsupportedEncodingException e) {\n                log.error(\"Error decoding message\", e);\n                return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n            }\n        }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n\n\n}\n```\n"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "```java\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.commons.cli.*;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n    }\n\n    public void start() throws Exception {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(topic, tags, keys, messageContent.getBytes());\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n\n    public static CommandLine buildCommandline(String[] args) {\n        Options options = new Options();\n        Option group = new Option(\"g\", \"group\", true, \"Producer group name\");\n        group.setRequired(true);\n        options.addOption(group);\n\n        Option topic = new Option(\"t\", \"topic\", true, \"Topic to send messages to\");\n        topic.setRequired(true);\n        options.addOption(topic);\n\n        Option tags = new Option(\"a\", \"tags\", true, \"Message tags\");\n        tags.setRequired(false);\n        options.addOption(tags);\n\n        Option keys = new Option(\"k\", \"keys\", true, \"Message keys\");\n        keys.setRequired(false);\n        options.addOption(keys);\n\n\n        CommandLineParser parser = new DefaultParser();\n        HelpFormatter formatter = new HelpFormatter();\n        CommandLine cmd = null;\n\n        try {\n            cmd = parser.parse(options, args);\n        } catch (ParseException e) {\n            System.out.println(e.getMessage());\n            formatter.printHelp(\"producer\", options);\n            System.exit(1);\n        }\n        return cmd;\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        CommandLine cmd = buildCommandline(args);\n        Producer producer = new Producer(cmd.getOptionValue(\"group\"), cmd.getOptionValue(\"topic\"), cmd.getOptionValue(\"tags\", \"\"), cmd.getOptionValue(\"keys\", \"\"));\n        producer.start();\n        SendResult sendResult = producer.sendMessage(\"Hello RocketMQ\");\n        System.out.printf(\"%s%n\", sendResult);\n        producer.shutdown();\n\n    }\n}\n```"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "import java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private final Logger mLog;\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = TimeUnit.SECONDS.toMillis(30);\n    private final NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private final AtomicBoolean mConnecting = new AtomicBoolean(false);\n    private long mLastConnectionAttempt;\n    private final IcecastHTTPConfiguration mConfiguration;\n    private BroadcastState mBroadcastState = BroadcastState.DISCONNECTED;\n\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        mLog = org.slf4j.LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n        mConfiguration = configuration;\n        mSocketConnector = new NioSocketConnector();\n        mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n    }\n\n    public synchronized boolean connect() {\n        if (!canConnect()) {\n            return false;\n        }\n        mConnecting.set(true);\n        mLastConnectionAttempt = System.currentTimeMillis();\n\n        try {\n            ConnectFuture future = mSocketConnector.connect(new InetSocketAddress(mConfiguration.getHost(), mConfiguration.getPort()));\n            future.awaitUninterruptibly();\n            mStreamingSession = future.getSession();\n            if (mStreamingSession != null) {\n                setBroadcastState(BroadcastState.CONNECTING);\n                return true;\n            } else {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n                mConnecting.set(false);\n                return false;\n            }\n        } catch (Exception e) {\n            mLog.error(\"Error connecting to Icecast server\", e);\n            setBroadcastState(BroadcastState.DISCONNECTED);\n            mConnecting.set(false);\n            return false;\n        }\n    }\n\n    public synchronized void disconnect() {\n        if (mStreamingSession != null) {\n            mStreamingSession.closeNow();\n            mStreamingSession = null;\n        }\n        setBroadcastState(BroadcastState.DISCONNECTED);\n        mConnecting.set(false);\n    }\n\n    public synchronized boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public synchronized boolean canConnect() {\n        return !mConnecting.get() && (System.currentTimeMillis() - mLastConnectionAttempt) > RECONNECT_INTERVAL_MILLISECONDS && mBroadcastState != BroadcastState.CONNECTING;\n    }\n\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return mConfiguration;\n    }\n\n    private synchronized void setBroadcastState(BroadcastState state) {\n        mBroadcastState = state;\n    }\n\n    public synchronized BroadcastState getBroadcastState() {\n        return mBroadcastState;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        return mConfiguration.getHttpHeaders();\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return mConfiguration;\n    }\n\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            // Send HTTP PUT request here with headers\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            disconnect();\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            mLog.error(\"Exception in Icecast connection\", throwable);\n            disconnect();\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            // Process server responses, e.g., HTTP response codes\n        }\n    }\n\n    public enum BroadcastState {\n        DISCONNECTED,\n        CONNECTING,\n        CONNECTED,\n        ERROR\n    }\n\n    public static class IcecastHTTPConfiguration {\n        private String host;\n        private int port;\n        private Map<String, String> httpHeaders;\n\n        public String getHost() { return host;}\n        public int getPort() { return port;}\n        public Map<String, String> getHttpHeaders() {return httpHeaders;}\n\n        public  IcecastHTTPConfiguration(String host, int port, Map<String, String> httpHeaders) {\n            this.host = host;\n            this.port = port;\n            this.httpHeaders = httpHeaders;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    public static void sendString(String message, String serverAddress, int serverPort) {\n        try (Socket socket = new Socket(serverAddress, serverPort);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n            out.println(message);\n        } catch (IOException e) {\n            System.err.println(\"Error communicating with server: \" + e.getMessage());\n            e.printStackTrace(System.err); // Print stack trace for debugging\n        }\n    }\n}\n\n```"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Enumeration;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\nimport io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\n\npublic class Graphite {\n    private final String host;\n    private final int port;\n    private final Logger logger = Logger.getLogger(getClass().getName());\n    private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n\n    public Graphite(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void push(CollectorRegistry registry) throws IOException {\n        try (Socket socket = new Socket(host, port);\n             Writer writer = new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8)) {\n            long timestamp = System.currentTimeMillis() / 1000L;\n            for (Enumeration<Collector.MetricFamilySamples> mfs = registry.metricFamilySamples(); mfs.hasMoreElements(); ) {\n                Collector.MetricFamilySamples metricFamilySamples = mfs.nextElement();\n                for (Collector.MetricFamilySamples.Sample sample : metricFamilySamples.samples) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(sanitize(metricFamilySamples.name)).append('.');\n                    for (int i = 0; i < sample.labelNames.size(); i++) {\n                        sb.append(sanitize(sample.labelValues.get(i))).append('.');\n                    }\n                    sb.setLength(sb.length() - 1);\n                    sb.append(' ').append(sample.value).append(' ').append(timestamp).append('\\n');\n                    writer.write(sb.toString());\n                }\n            }\n        }\n    }\n\n\n    public Thread start(CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public Thread start(CollectorRegistry registry, int intervalSeconds) {\n        Thread thread = new Thread(new PushThread(registry, intervalSeconds));\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private String sanitize(String s) {\n        return INVALID_GRAPHITE_CHARS.matcher(s).replaceAll(\"_\");\n    }\n\n    private class PushThread implements Runnable {\n        private final CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        PushThread(CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    push(registry);\n                } catch (IOException e) {\n                    logger.log(Level.SEVERE, \"Failed to push metrics to Graphite\", e);\n                }\n                try {\n                    TimeUnit.SECONDS.sleep(intervalSeconds);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    break;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with the OpenMHz API, including methods for testing connection authorization and uploading audio recordings with metadata.\n\nClass Description: OpenMHzHttpClient is a utility class that provides HTTP client operations for the OpenMHz API. It handles both synchronous and asynchronous requests, manages connection settings, and processes API responses. The class includes error handling and logging capabilities.\n\nAttributes:\n- mLog: Logger - SLF4J logger instance for error and debug logging\n- mHttpClient: HttpClient - Configured HTTP client instance with HTTP/2 support, redirect policy, and timeout settings\n\nMethods:\n- testConnection(String host, String systemName, String apiKey) -> String - Tests API connection and authorization by sending a POST request to the authorize endpoint. Returns status messages based on response code.\n  Input:\n    - host: String - Base URL of the OpenMHz server\n    - systemName: String - Name of the target system\n    - apiKey: String - API key for authentication\n  Output:\n    - String - Status message (\"OK\", \"Invalid API Key\", \"Invalid System Name\", \"No Response\", or \"Unknown Exception\")\n\n- sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) -> void - Asynchronously uploads an audio recording with metadata to the OpenMHz API using multipart/form-data format.\n  Input:\n    - uri: String - Target endpoint URL\n    - audioBytes: byte[] - Audio file data to upload\n    - boundary: String - Multipart boundary string\n    - apiKey: String - API key for authentication\n    - frequency: long - Frequency value in Hz\n    - timestampSeconds: long - Recording start time in seconds\n    - durationSeconds: int - Recording duration in seconds\n    - talkgroup: String - Talkgroup identifier\n    - radioId: String - Radio source identifier\n  Output: None (asynchronous operation with error logging)",
    "Canonical_solution": "import com.google.common.net.HttpHeaders;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OpenMHzHttpClient {\n\n    private final static Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String uri = host + \"/\" + systemName + \"/authorize\";\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + apiKey))\n            .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                return \"OK\";\n            } else if(response.statusCode() == 403) {\n                return \"Invalid API Key\";\n            } else if(response.statusCode() == 500) {\n                return \"Invalid System Name\";\n            }\n\n            return \"No Response\";\n        }\n        catch(Exception e) {  \n            Throwable throwableCause = e.getCause();\n\n            if(throwableCause instanceof ConnectException) {\n                return \"No Response\";\n            }\n\n            mLog.error(\"Exception connecting to OpenMHz server [\" + e.toString() + \"]\");\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, \n                                  long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        OpenMHzBuilder bodyBuilder = new OpenMHzBuilder();\n        bodyBuilder\n            .addFile(audioBytes)\n            .addPart(FormField.FREQ, frequency)\n            .addPart(FormField.START_TIME, timestampSeconds)\n            .addPart(FormField.STOP_TIME, timestampSeconds)\n            .addPart(FormField.CALL_LENGTH, durationSeconds)\n            .addPart(FormField.TALKGROUP_NUM, talkgroup)\n            .addPart(FormField.EMERGENCY, 0)\n            .addPart(FormField.API_KEY, apiKey)\n            .addPart(FormField.SOURCE_LIST, \"[{ \\\"pos\\\": 0.00, \\\"src\\\": \" + radioId + \"}]\");\n\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"multipart/form-data; boundary=\" + boundary)\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                    else {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport org.apache.hc.client5.http.classic.methods.HttpPost;\nimport org.apache.hc.client5.http.entity.mime.MultipartEntityBuilder;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\nimport org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;\nimport org.apache.hc.client5.http.impl.classic.HttpClients;\nimport org.apache.hc.core5.http.ContentType;\nimport org.apache.hc.core5.http.HttpEntity;\nimport org.apache.hc.core5.http.io.entity.ByteArrayEntity;\nimport org.apache.hc.core5.http.io.entity.StringEntity;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class OpenMHzHttpClient {\n\n    private final Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private final CloseableHttpClient mHttpClient;\n    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();\n\n    public OpenMHzHttpClient() {\n        mHttpClient = HttpClients.createDefault();\n    }\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String url = host + \"/authorize\";\n        HttpPost request = new HttpPost(url);\n        request.addHeader(\"Content-Type\", \"application/json\");\n\n        String json = String.format(\"{\\\"systemName\\\": \\\"%s\\\", \\\"apiKey\\\": \\\"%s\\\"}\", systemName, apiKey);\n        request.setEntity(new StringEntity(json));\n\n        try (CloseableHttpResponse response = mHttpClient.execute(request)) {\n            int statusCode = response.getCode();\n            switch (statusCode) {\n                case 200:\n                    return \"OK\";\n                case 401:\n                    return \"Invalid API Key\";\n                case 404:\n                    return \"Invalid System Name\";\n                default:\n                    mLog.error(\"Unexpected status code: {}\", statusCode);\n                    return \"No Response\";\n            }\n        } catch (IOException e) {\n            mLog.error(\"Error testing connection\", e);\n            return \"Unknown Exception\";\n        }\n    }\n\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency,\n                                   long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n\n        mExecutor.submit(() -> {\n            HttpPost request = new HttpPost(uri);\n            request.addHeader(\"api_key\", apiKey);\n\n            HttpEntity entity = MultipartEntityBuilder.create()\n                    .setBoundary(boundary)\n                    .addBinaryBody(\"audio\", audioBytes, ContentType.DEFAULT_BINARY, \"recording.mp3\")\n                    .addTextBody(\"freq\", String.valueOf(frequency))\n                    .addTextBody(\"time\", String.valueOf(timestampSeconds))\n                    .addTextBody(\"duration\", String.valueOf(durationSeconds))\n                    .addTextBody(\"talkgroup\", talkgroup)\n                    .addTextBody(\"radio\", radioId)\n                    .build();\n\n            request.setEntity(entity);\n\n            try (CloseableHttpResponse response = mHttpClient.execute(request)) {\n                if (response.getCode() != 200) {\n                    mLog.error(\"Error uploading audio: {}\", response.getCode());\n                }\n            } catch (IOException e) {\n                mLog.error(\"Error sending audio recording\", e);\n            }\n        });\n    }\n}\n```\n"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TProfilerClient {\n\n    public void start(String server, int port) {\n        doSend(\"START\", server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(\"STOP\", server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(\"STATUS\", server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(\"FLUSHMETHOD\", server, port);\n    }\n\n    private void doSend(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n            out.println(command);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n             InputStream in = socket.getInputStream()) {\n            out.println(command);\n            return read(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"ERROR\";\n        }\n    }\n\n\n    private String read(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null && !line.isEmpty()) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n}\n"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "import com.android.ddmlib.*;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() throws TimeoutException, AdbCommandRejectedException, ShellCommandUnresponsiveException, IOException, SyncException {\n        forward = createForward();\n        startInitialThread(forward.getLocalAddress().getHostString(), forward.getLocalAddress().getPort());\n    }\n\n    public void kill() {\n        try {\n            if (minitouchSocket != null) {\n                minitouchSocket.close();\n            }\n            removeForward(forward);\n        } catch (IOException | TimeoutException | AdbCommandRejectedException | ShellCommandUnresponsiveException | SyncException e) {\n            e.printStackTrace();\n        } finally {\n            onClose();\n        }\n    }\n\n    public void sendEvent(String str) throws IOException {\n        if (minitouchOutputStream != null) {\n            minitouchOutputStream.write(str.getBytes());\n            minitouchOutputStream.flush();\n        }\n    }\n\n\n    private AdbForward createForward() throws TimeoutException, AdbCommandRejectedException, IOException {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) throws TimeoutException, AdbCommandRejectedException, IOException {\n        if (forward != null) {\n            device.removeForward(forward);\n        }\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(host, port);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (IOException e) {\n                onStartup(false);\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose();\n        }\n        minitouchSocket = null;\n        minitouchOutputStream = null;\n    }\n\n    private AdbForward generateForwardInfo() throws TimeoutException, AdbCommandRejectedException, IOException {\n        device.executeShellCommand(\"chmod 777 \" + REMOTE_PATH + \"/\" + MINITOUCH_BIN, new NullOutputReceiver());\n        device.executeShellCommand(REMOTE_PATH + \"/\" + MINITOUCH_BIN, new NullOutputReceiver());\n        return device.createForward(0, \"minitouch\");\n    }\n\n\n    public interface MinitouchListener {\n        void onStartup(boolean success);\n        void onClose();\n    }\n}\n"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    public static void sendString(String message, String serverAddress, int serverPort) {\n        try (Socket socket = new Socket(serverAddress, serverPort);\n             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n            out.println(message);\n        } catch (IOException e) {\n            System.err.println(\"Error communicating with server: \" + e.getMessage());\n            e.printStackTrace(System.err); // Print stack trace for debugging\n        }\n    }\n}\n\n```"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "```java\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.StandardCharsets;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class TcpClient {\n\n    private static final String HOST = DefaultServer.HOST;\n    private static final int PORT = DefaultServer.PORT;\n\n    public void connectAndEcho(String url) throws IOException, URISyntaxException {\n        try (Socket socket = new Socket(HOST, PORT)) {\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n            // Send HTTP Upgrade Request\n            String request = \"GET \" + url + \" HTTP/1.1\\r\\n\" +\n                    \"Host: \" + HOST + \":\" + PORT + \"\\r\\n\" +\n                    \"Upgrade: echo\\r\\n\" +\n                    \"Connection: Upgrade\\r\\n\" +\n                    \"\\r\\n\";\n            out.write(request.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n\n\n            // Read HTTP Upgrade Response\n            String responseLine = readLine(in);\n            assertEquals(\"HTTP/1.1 101 Switching Protocols\", responseLine);\n\n            String upgradeHeader = readLine(in);\n            assertEquals(\"Upgrade: echo\", upgradeHeader);\n\n            String connectionHeader = readLine(in);\n            assertEquals(\"Connection: Upgrade\", connectionHeader);\n\n            readLine(in); // Read the empty line\n\n\n            // Echo Test 1\n            String message1 = \"Hello\";\n            out.write(message1.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n            byte[] echo1 = readBytes(in, message1.length());\n            assertArrayEquals(message1.getBytes(StandardCharsets.UTF_8), echo1);\n\n            // Echo Test 2\n            String message2 = \"World!\";\n            out.write(message2.getBytes(StandardCharsets.UTF_8));\n            out.flush();\n            byte[] echo2 = readBytes(in, message2.length());\n            assertArrayEquals(message2.getBytes(StandardCharsets.UTF_8), echo2);\n        }\n    }\n\n\n    private String readLine(DataInputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                c = in.read();\n                if (c == '\\n') {\n                    break;\n                }\n                sb.append('\\r');\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private byte[] readBytes(DataInputStream in, int length) throws IOException {\n        byte[] buffer = new byte[length];\n        in.readFully(buffer);\n        return buffer;\n    }\n\n    private static class DefaultServer {\n        static final String HOST = \"localhost\";\n        static final int PORT = 8080; // Example port, adjust as needed\n    }\n}\n```"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.function.Consumer;\n\n\nclass StreamBuffer {\n    ByteBuffer buffer;\n\n    void write(ByteBuffer src) { /* Implementation omitted for brevity */ }\n    int read(ByteBuffer dst) { return 0; /* Implementation omitted for brevity */ }\n    boolean hasRemaining() { return true; /* Implementation omitted for brevity */ }\n}\n\nclass Packetizer {\n    ByteBuffer buffer;\n    Packetizer(ByteBuffer buffer) { this.buffer = buffer; }\n    IPv4Packet nextPacket() { return null; /* Implementation omitted for brevity */ }\n    boolean hasRemaining() { return true; /* Implementation omitted for brevity */ }\n}\n\nclass IPv4Packet {\n    ByteBuffer backingBuffer;\n    IPv4Packet(ByteBuffer buffer) { this.backingBuffer = buffer; }\n    int getPayloadSize() { return 0; /* Implementation omitted for brevity */ }\n    ByteBuffer getPayload() { return ByteBuffer.allocate(0); /* Implementation omitted for brevity */ }\n}\n\nclass IPv4Header {}\nclass TCPHeader {}\nclass ConnectionId {}\nclass Client {}\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 16384;\n    private static final int MAX_PAYLOAD_SIZE = MTU - IPv4Header.MIN_HEADER_LENGTH - TCPHeader.MIN_HEADER_LENGTH;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer();\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private final SocketChannel channel;\n    private SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        this.channel = createChannel();\n        this.networkToClient = new Packetizer(ByteBuffer.allocate(MTU));\n        this.selectionKey = channel.register(selector, SelectionKey.OP_CONNECT);\n        // ... other initialization ...\n    }\n\n    public void disconnect() {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        }\n        // ... other cleanup ...\n    }\n\n\n    public void processReceive() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(MTU);\n        int bytesRead = channel.read(buffer);\n        if (bytesRead < 0) {\n            disconnect();\n            return;\n        }\n        // ... process received data ...\n    }\n\n    public void processSend() throws IOException {\n        // ... send data from clientToNetwork buffer ...\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        // ... other channel configuration ...\n        return channel;\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        clientToNetwork.write(packet.backingBuffer);\n        updateInterests();\n    }\n\n    private void updateInterests() {\n        int newInterests = 0;\n        if (mayRead()) {\n            newInterests |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            newInterests |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            newInterests |= SelectionKey.OP_CONNECT;\n        }\n\n        if (newInterests != interests) {\n            interests = newInterests;\n            selectionKey.interestOps(interests);\n        }\n    }\n\n    private boolean mayRead() {\n        return true; // Replace with actual logic\n    }\n\n    private boolean mayWrite() {\n        return clientToNetwork.hasRemaining();\n    }\n\n    private boolean mayConnect() {\n        return channel.isConnectionPending();\n    }\n\n    @Override\n    public void get(Consumer<IPv4Packet> callback) {\n        // ... implementation for PacketSource interface ...\n    }\n}\n\nabstract class AbstractConnection {}\n\ninterface PacketSource {\n    void get(Consumer<IPv4Packet> callback);\n}\n"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class ReadSocketService implements Runnable {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private Selector selector;\n    private SocketChannel socketChannel;\n    private ByteBuffer byteBufferRead;\n    private AbstractHAReader haReader;\n    private int processPosition = 0;\n    private long lastReadTimestamp;\n\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.socketChannel = socketChannel;\n        this.selector = Selector.open();\n        this.socketChannel.configureBlocking(false);\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new HAServerReader(); // Replace with actual implementation\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                int readyChannels = selector.select(1000);\n                if (readyChannels == 0) {\n                    continue;\n                }\n\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    keyIterator.remove();\n\n                    if (key.isReadable()) {\n                        int bytesRead = socketChannel.read(byteBufferRead);\n                        if (bytesRead == -1) {\n                            // Connection closed by remote peer\n                            socketChannel.close();\n                            break;\n                        } else if (bytesRead > 0) {\n                            lastReadTimestamp = System.currentTimeMillis();\n                            byteBufferRead.flip();\n                            if (haReader.processReadResult(byteBufferRead)) {\n                                byteBufferRead.compact();\n                            }\n                        }\n                    }\n                }\n\n            } catch (SocketTimeoutException e) {\n                // Handle connection timeout\n            } catch (IOException e) {\n                // Handle other IO exceptions\n                break;\n            }\n        }\n\n        try {\n            selector.close();\n            if (socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n        } catch (IOException e) {\n            // Handle close exception\n        }\n    }\n\n    public String getServiceName() {\n        return \"ReadSocketService\"; // Add broker identifier if needed\n    }\n\n\n    interface AbstractHAReader {\n        boolean processReadResult(ByteBuffer byteBufferRead);\n    }\n\n    class HAServerReader implements AbstractHAReader {\n        @Override\n        public boolean processReadResult(ByteBuffer byteBufferRead) {\n            // Implement HA protocol processing (handshake and transfer states)\n            // Return true if buffer was fully processed and can be cleared, false otherwise\n            processPosition += byteBufferRead.position() - processPosition;\n            byteBufferRead.position(processPosition);\n            return byteBufferRead.remaining() == 0;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\nclass ReceivedKey {}\nclass HubConfig {\n    String getApiConfigUri() { return \"\"; }\n    String getDeviceDataUri() { return \"\"; }\n    String getVaultMasterkeyUri() { return \"\"; }\n    String getLegacyAccessTokenUri() { return \"\"; }\n\n}\n\npublic class HubHttpClient {\n\n    private final HttpClient httpClient;\n    private final String bearerToken;\n    private final HubConfig hubConfig;\n    private final String deviceId;\n    private final String vaultId;\n\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n        this.httpClient = HttpClient.newBuilder().executor(executor).build();\n        this.bearerToken = bearerToken;\n        this.hubConfig = hubConfig;\n        this.deviceId = deviceId;\n        this.vaultId = vaultId;\n    }\n\n    public CompletableFuture<ReceivedKey> requestApiConfig() {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(hubConfig.getApiConfigUri()))\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenCompose(this::handleApiConfigResponse);\n    }\n\n    public CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n        return requestDeviceData();\n    }\n\n\n    public CompletableFuture<ReceivedKey> requestDeviceData() {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(hubConfig.getDeviceDataUri().replace(\"{deviceId}\", deviceId)))\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .build();\n\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenCompose(this::handleDeviceDataResponse);\n    }\n\n    public CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n        String encryptedUserKey = \"\"; // Placeholder, extract from response\n        return requestVaultMasterkey(encryptedUserKey);\n    }\n\n    public CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(hubConfig.getVaultMasterkeyUri().replace(\"{vaultId}\", vaultId)))\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .build();\n\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response));\n\n    }\n\n    public ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n        return new ReceivedKey();\n    }\n\n\n    public CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(hubConfig.getLegacyAccessTokenUri()))\n                .build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenApply(this::handleLegacyAccessTokenResponse);\n    }\n\n    public ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n        return new ReceivedKey();\n    }\n\n    public ReceivedKey retrievalFailed(Throwable cause) {\n        return new ReceivedKey();\n    }\n}\n"
  },
  {
    "Task_id": 430,
    "Instruction": "Task Description: Implement a Java class that establishes and manages a non-blocking TCP client connection to a Redis server using Java NIO (New I/O) techniques. The class should handle connection establishment, data writing, reading, and resource cleanup.\n\nClass Description: PassiveRedisIndexer is a TCP client that connects to a Redis server using non-blocking I/O operations. It manages connection state, handles write operations through a queue, and reads server responses while efficiently managing system resources.\n\nAttributes:\n- writeQueue: Queue<ByteBuffer> - A thread-safe queue holding data buffers to be written to the server\n- ref: AtomicReference<SocketHandler> - Atomic reference to the current socket handler instance\n- conMan: NIOConnectionManager - Manages NIO channel registration and event selection\n- config: ConfigReader - Reads configuration data for server connection details\n- namespaces: Map<String,String> - Static map containing XML namespace definitions for configuration parsing\n\nMethods:\n- getAddress() -> InetAddress - Retrieves the Redis server address from configuration\n  - Input: None\n  - Output: InetAddress - The server address to connect to\n\nSocketHandler Inner Class:\n- chan: SocketChannel - The NIO channel for the TCP connection\n- awaitingWriteNotification: boolean - Flag indicating if write operations are pending\n- toWrite: ByteBuffer - Current buffer being written to the channel\n- oblivion: ByteBuffer - Buffer for reading server responses (discarded in this implementation)\n\nSocketHandler Methods:\n- open() -> void - Initializes and opens the socket channel in non-blocking mode\n  - Input: None\n  - Output: None\n- close() -> void - Cleans up resources and closes the connection\n  - Input: None\n  - Output: None\n- getChannel() -> SocketChannel - Returns the socket channel\n  - Input: None\n  - Output: SocketChannel - The managed socket channel\n- registrationEvent(NIOConnectionManager, SelectionKey) -> void - Handles channel registration events\n  - Input: manager (NIOConnectionManager), key (SelectionKey)\n  - Output: None\n- selectionEvent(SelectionKey) -> void - Handles channel I/O events (connect, read, write)\n  - Input: key (SelectionKey)\n  - Output: None\n- read() -> void - Reads data from the channel (into oblivion buffer)\n  - Input: None\n  - Output: None\n- doStateChecks(long) -> void - Performs periodic connection state checks\n  - Input: now (long) - current timestamp\n  - Output: None\n- calcInterestOps() -> int - Calculates current interest operations for the selector\n  - Input: None\n  - Output: int - Bitmask of interest operations (READ, WRITE, CONNECT)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.utils.ConfigReader;\nimport the8472.utils.XMLUtils;\nimport the8472.utils.concurrent.SerializedTaskExecutor;\n\npublic class PassiveRedisIndexer {\n\n    private Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();\n    private AtomicReference<SocketHandler> ref = new AtomicReference<>();\n    private NIOConnectionManager conMan;\n    private ConfigReader config;\n    private static final Map<String,String> namespaces = Map.of(\"xsi\",\"http://www.w3.org/2001/XMLSchema-instance\");\n\n    class SocketHandler implements Selectable {\n        \n        SocketChannel chan;\n        volatile boolean awaitingWriteNotification = true;\n        ByteBuffer toWrite;\n        ByteBuffer oblivion = ByteBuffer.allocateDirect(4*1024);\n        \n        void open() {\n            try {\n                chan = SocketChannel.open();\n                chan.configureBlocking(false);\n                chan.connect(new InetSocketAddress(getAddress(),6379));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            \n            conMan.register(this);\n        }\n        \n        void close() {\n            writeQueue.clear();\n            ref.compareAndSet(this, null);\n            try {\n                chan.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    \n        @Override\n        public SocketChannel getChannel() {\n            return chan;\n        }\n    \n        @Override\n        public void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n        \n        @Override\n        public void selectionEvent(SelectionKey key) throws IOException {\n            if(key.isValid() && key.isConnectable()) {\n                chan.finishConnect();\n                conMan.interestOpsChanged(this);\n            }\n                \n            if(key.isValid() && key.isReadable())\n                read();\n            if(key.isValid() && key.isWritable()) {\n                awaitingWriteNotification = false;\n                tryWrite.run();\n                conMan.interestOpsChanged(this);\n            }\n        }\n        \n        Runnable tryWrite = SerializedTaskExecutor.onceMore(() -> {\n            while(!awaitingWriteNotification && !writeQueue.isEmpty()) {\n                if(toWrite == null)\n                    toWrite = writeQueue.poll();\n                if(toWrite == null)\n                    continue;\n                \n                int written = 0;\n                try {\n                    written = chan.write(toWrite);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                \n                if(written < 0) {\n                    awaitingWriteNotification = true;\n                    close();\n                    continue;\n                }\n                \n                if(toWrite.remaining() > 0) {\n                    awaitingWriteNotification = true;\n                    conMan.interestOpsChanged(this);\n                } else {\n                    toWrite = null;\n                }\n            }\n        });\n        \n        void read() throws IOException {\n            while(true) {\n                oblivion.clear();\n                int read = chan.read(oblivion);\n                if(read < 0)\n                    close();\n                if(read <= 0)\n                    break;\n            }\n        }\n    \n        @Override\n        public void doStateChecks(long now) throws IOException {\n            if(!chan.isOpen()) {\n                close();\n                conMan.deRegister(this);\n            }\n        }\n    \n        @Override\n        public int calcInterestOps() {\n            int ops = SelectionKey.OP_READ;\n            \n            if(chan.isConnectionPending())\n                ops |= SelectionKey.OP_CONNECT;\n            \n            if(awaitingWriteNotification)\n                ops |= SelectionKey.OP_WRITE;\n                \n            return ops;\n        }\n    }\n\n    private InetAddress getAddress() {\n        return config.get(XMLUtils.buildXPath(\"//components/component[@xsi:type='mldht:redisIndexerType']/address\",namespaces))\n                   .flatMap(str -> Optional.ofNullable(str))\n                   .map(str -> {\n                       try {\n                           return InetAddress.getByName(str);\n                       } catch (Exception e) {\n                           throw new RuntimeException(e);\n                       }\n                   })\n                   .get();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class PassiveRedisIndexer {\n\n    private final Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();\n    private final AtomicReference<SocketHandler> ref = new AtomicReference<>();\n    private final NIOConnectionManager conMan;\n    private final ConfigReader config;\n    private static final Map<String, String> namespaces;\n\n    // ... (ConfigReader, NIOConnectionManager, and namespaces initialization)\n\n    public InetAddress getAddress() throws IOException {\n        // ... (Implementation to retrieve Redis server address from config)\n        return null; // Placeholder\n    }\n\n\n    private class SocketHandler {\n        private SocketChannel chan;\n        private boolean awaitingWriteNotification;\n        private ByteBuffer toWrite;\n        private final ByteBuffer oblivion = ByteBuffer.allocate(1024);\n\n\n        public void open() throws IOException {\n            chan = SocketChannel.open();\n            chan.configureBlocking(false);\n            chan.connect(new InetSocketAddress(getAddress(), 6379)); // Example port\n            conMan.register(this);\n        }\n\n        public void close() {\n            try {\n                if (chan != null) {\n                    chan.close();\n                }\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n\n        public SocketChannel getChannel() {\n            return chan;\n        }\n\n        public void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n            // ... (Handle registration event)\n        }\n\n        public void selectionEvent(SelectionKey key) throws IOException {\n            if (key.isConnectable()) {\n                if (chan.finishConnect()) {\n                    key.interestOps(SelectionKey.OP_READ);\n                }\n            }\n            if (key.isWritable()) {\n                write();\n            }\n            if (key.isReadable()) {\n                read();\n            }\n        }\n\n        public void read() throws IOException {\n            oblivion.clear();\n            chan.read(oblivion);\n            // ... (Discard or process read data)\n        }\n\n        public void doStateChecks(long now) {\n            // ... (Implement connection state checks)\n        }\n\n        public int calcInterestOps() {\n            int ops = SelectionKey.OP_READ;\n            if (!writeQueue.isEmpty() || toWrite != null) {\n                ops |= SelectionKey.OP_WRITE;\n            }\n            return ops;\n        }\n\n        private void write() throws IOException {\n            if (toWrite == null) {\n                toWrite = writeQueue.poll();\n                if (toWrite == null) {\n                    return;\n                }\n                toWrite.flip();\n            }\n\n            chan.write(toWrite);\n            if (toWrite.remaining() == 0) {\n                toWrite = null;\n            }\n        }\n    }\n}\n\n```"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a Java class for a High Availability (HA) client that manages communication with a master server using non-blocking I/O (NIO) techniques. The client should handle connection management, data reporting, and read event processing.\n\nClass Description: DefaultHAClient is a service thread that maintains a connection to a master server for high availability purposes. It uses Java NIO's SocketChannel and Selector for non-blocking communication, manages buffer operations for data transfer, and handles connection lifecycle events.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Maximum buffer size for reading data (4MB)\n- masterHaAddress: [AtomicReference<String>] - Atomic reference to the master server's address\n- reportOffset: [ByteBuffer] - Buffer for reporting slave offset to master (8 bytes)\n- socketChannel: [SocketChannel] - Channel for communication with master\n- selector: [Selector] - Selector for non-blocking I/O operations\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n- lastWriteTimestamp: [long] - Timestamp of last successful write operation\n- currentReportedOffset: [long] - Current offset reported to master\n- dispatchPosition: [int] - Position in read buffer for dispatching data\n- byteBufferRead: [ByteBuffer] - Primary buffer for reading data\n- byteBufferBackup: [ByteBuffer] - Backup buffer for buffer reallocation\n- defaultMessageStore: [DefaultMessageStore] - Reference to the message store for offset information\n\nMethods:\n- DefaultHAClient([DefaultMessageStore defaultMessageStore]) -> [void] - Constructor that initializes selector and message store reference\n- updateHaMasterAddress([String newAddr]) -> [void] - Updates the master server address atomically\n- reportSlaveMaxOffset([long maxOffset]) -> [boolean] - Reports the slave's maximum offset to master, returns success status\n- reallocateByteBuffer() -> [void] - Reallocates and swaps read buffers when needed\n- swapByteBuffer() -> [void] - Swaps primary and backup byte buffers\n- processReadEvent() -> [boolean] - Processes read events from socket channel, returns success status\n- connectMaster() -> [boolean] - Connects to master server, returns connection status\n- closeMaster() -> [void] - Closes connection with master and cleans up resources\n- shutdown() -> [void] - Shuts down the client by closing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.store.DefaultMessageStore;\n\npublic class DefaultHAClient extends ServiceThread implements HAClient {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        String currentAddr = this.masterHaAddress.get();\n        if (masterHaAddress.compareAndSet(currentAddr, newAddr)) {\n            log.info(\"update master ha address, OLD: \" + currentAddr + \" NEW: \" + newAddr);\n        }\n    }\n\n    private boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n\n        for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n            try {\n                this.socketChannel.write(this.reportOffset);\n            } catch (IOException e) {\n                log.error(this.getServiceName()\n                    + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n                return false;\n            }\n        }\n        lastWriteTimestamp = this.defaultMessageStore.getSystemClock().now();\n        return !this.reportOffset.hasRemaining();\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    readSizeZeroTimes = 0;\n                    boolean result = this.dispatchReadRequest();\n                    if (!result) {\n                        log.error(\"HAClient, dispatchReadRequest error\");\n                        return false;\n                    }\n                    lastReadTimestamp = System.currentTimeMillis();\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else {\n                    log.info(\"HAClient, processReadEvent read socket < 0\");\n                    return false;\n                }\n            } catch (IOException e) {\n                log.info(\"HAClient, processReadEvent read socket exception\", e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws ClosedChannelException {\n        if (null == socketChannel) {\n            String addr = this.masterHaAddress.get();\n            if (addr != null) {\n                SocketAddress socketAddress = NetworkUtil.string2SocketAddress(addr);\n                this.socketChannel = RemotingHelper.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                    log.info(\"HAClient connect to master {}\", addr);\n                }\n            }\n            this.currentReportedOffset = this.defaultMessageStore.getMaxPhyOffset();\n            this.lastReadTimestamp = System.currentTimeMillis();\n        }\n        return this.socketChannel != null;\n    }\n\n    public void closeMaster() {\n        if (null != this.socketChannel) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n                log.info(\"HAClient close connection with master {}\", this.masterHaAddress.get());\n            } catch (IOException e) {\n                log.warn(\"closeMaster exception. \", e);\n            }\n            this.lastReadTimestamp = 0;\n            this.dispatchPosition = 0;\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferRead.position(0);\n            this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException e) {\n            log.warn(\"Close the selector of AutoRecoverHAClient error, \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class DefaultHAClient {\n    static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(final DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = Selector.open();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        this.masterHaAddress.set(newAddr);\n    }\n\n    public boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        return true;\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    lastReadTimestamp = System.currentTimeMillis();\n                    readSizeZeroTimes = 0;\n                    // Process data... Placeholder for actual data processing logic\n                    return true;\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else if (readSize < 0) {\n                    return false;\n                }\n            } catch (IOException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws IOException {\n        if (masterHaAddress.get() == null || masterHaAddress.get().isEmpty()) {\n            return false;\n        }\n\n        String addr = this.masterHaAddress.get();\n        String[] hostAndPort = addr.split(\":\");\n        if (hostAndPort.length != 2) {\n            return false;\n        }\n\n        try {\n            this.socketChannel = SocketChannel.open(new InetSocketAddress(hostAndPort[0], Integer.parseInt(hostAndPort[1])));\n            this.socketChannel.configureBlocking(false);\n            this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n            this.lastReadTimestamp = System.currentTimeMillis();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public void closeMaster() {\n        if (this.socketChannel != null) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    public void shutdown() {\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException ignored) {\n        }\n    }\n}\n"
  },
  {
    "Task_id": 433,
    "Instruction": "Task Description: Implement a Java class that facilitates TCP-based communication using Java NIO (Non-blocking I/O) techniques, supporting both client and server modes with configurable options.\n\nClass Description: NioTransport is a class that provides TCP communication capabilities using Java NIO. It can operate in either server or client mode, supports direct buffers for performance optimization, and includes methods for starting/stopping communication, sending data, and receiving data through a callback mechanism.\n\nAttributes:\n- srv_channel: [ServerSocketChannel] - Server socket channel used in server mode\n- client_channel: [SocketChannel] - Client socket channel for communication\n- receiver_thread: [Receiver] - Thread handling incoming data reception\n- receiver: [RtReceiver] - Callback interface for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- server: [boolean] - Flag indicating if operating in server mode\n- direct_buffers: [boolean] - Flag indicating whether to use direct buffers\n- log: [Log] - Logger instance for logging messages\n\nMethods:\n- options(String... options) -> [void] - Configures transport options including server/client mode, host, port, and buffer type\n- receiver(RtReceiver receiver) -> [void] - Sets the receiver callback for incoming data\n- start(String... options) -> [void] - Starts the transport in either server or client mode based on configuration\n- stop() -> [void] - Stops the transport and releases resources\n- send(Object dest, byte[] buf, int offset, int length) -> [void] - Sends data through the established channel\n- Receiver.run() -> [void] - (Inner class method) Continuously receives data and forwards it to the registered receiver",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\n\npublic class NioTransport implements RtTransport {\n    protected ServerSocketChannel srv_channel;\n    protected SocketChannel       client_channel;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server, direct_buffers;\n    protected final Log           log=LogFactory.getLog(NioTransport.class);\n\n    public NioTransport() {\n    }\n\n    public void options(String... options) throws Exception {\n        if(options == null)\n            return;\n        for(int i=0; i < options.length; i++) {\n            if(options[i].equals(\"-server\")) {\n                server=true;\n                continue;\n            }\n            if(options[i].equals(\"-host\")) {\n                host=InetAddress.getByName(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-port\")) {\n                port=Integer.parseInt(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-direct\")) {\n                direct_buffers=Boolean.parseBoolean(options[++i]);\n            }\n        }\n        if(host == null)\n            host=InetAddress.getLocalHost();\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            srv_channel=ServerSocketChannel.open();\n            srv_channel.bind(new InetSocketAddress(host, port), 50);\n            System.out.println(\"server started (ctrl-c to kill)\");\n            for(;;) {\n                client_channel=srv_channel.accept();\n                receiver_thread=new Receiver();\n                receiver_thread.start();\n            }\n        }\n        else {\n            client_channel=SocketChannel.open();\n            client_channel.connect(new InetSocketAddress(host, port));\n            receiver_thread=new Receiver();\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(srv_channel, client_channel);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        ByteBuffer sbuf=ByteBuffer.wrap(buf, offset, length);\n        client_channel.write(sbuf);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            ByteBuffer buf=direct_buffers? ByteBuffer.allocateDirect(RoundTrip.PAYLOAD) : ByteBuffer.allocate(RoundTrip.PAYLOAD);\n            for(;;) {\n                try {\n                    buf.position(0);\n                    int num=client_channel.read(buf);\n                    if(num == -1)\n                        break;\n                    if(num != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + num);\n                    if(receiver != null) {\n                        buf.flip();\n                        int offset=buf.hasArray()? buf.arrayOffset() + buf.position() : buf.position(), len=buf.remaining();\n                        if(!buf.isDirect())\n                            receiver.receive(null, buf.array(), offset, len);\n                        else {\n                            byte[] tmp=new byte[len];\n                            buf.get(tmp, 0, len);\n                            receiver.receive(null, tmp, 0, len);\n                        }\n                    }\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(client_channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\n\npublic class NioTransport {\n\n    private ServerSocketChannel srv_channel;\n    private SocketChannel client_channel;\n    private Receiver receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private boolean direct_buffers;\n    private Logger log = Logger.getLogger(\"NioTransport\");\n\n    public interface RtReceiver {\n        void receive(Object src, byte[] data, int offset, int length);\n    }\n\n    public void options(String... options) {\n        for (int i = 0; i < options.length; i++) {\n            if (options[i].equals(\"-server\")) {\n                server = true;\n            } else if (options[i].equals(\"-client\")) {\n                server = false;\n            } else if (options[i].equals(\"-host\") && i + 1 < options.length) {\n                try {\n                    host = InetAddress.getByName(options[++i]);\n                } catch (Exception e) {\n                    log.log(Level.SEVERE, \"Invalid host: \" + options[i], e);\n                }\n            } else if (options[i].equals(\"-port\") && i + 1 < options.length) {\n                port = Integer.parseInt(options[++i]);\n            } else if (options[i].equals(\"-direct\")) {\n                direct_buffers = true;\n            }\n        }\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void start(String... options) {\n        options(options);\n        try {\n            if (server) {\n                srv_channel = ServerSocketChannel.open();\n                srv_channel.socket().bind(new InetSocketAddress(port));\n                client_channel = srv_channel.accept();\n            } else {\n                client_channel = SocketChannel.open(new InetSocketAddress(host, port));\n            }\n            client_channel.configureBlocking(false);\n            receiver_thread = new Receiver(client_channel);\n            receiver_thread.start();\n        } catch (IOException e) {\n            log.log(Level.SEVERE, \"Failed to start transport\", e);\n        }\n    }\n\n    public void stop() {\n        try {\n            if (receiver_thread != null) {\n                receiver_thread.interrupt();\n            }\n            if (client_channel != null) {\n                client_channel.close();\n            }\n            if (srv_channel != null) {\n                srv_channel.close();\n            }\n        } catch (IOException e) {\n            log.log(Level.SEVERE, \"Failed to stop transport\", e);\n        }\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) {\n        try {\n            ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length);\n            buffer.put(buf, offset, length);\n            buffer.flip();\n            client_channel.write(buffer);\n        } catch (IOException e) {\n            log.log(Level.SEVERE, \"Failed to send data\", e);\n        }\n    }\n\n    private class Receiver extends Thread {\n        private SocketChannel channel;\n\n        Receiver(SocketChannel channel) {\n            this.channel = channel;\n        }\n\n        public void run() {\n            ByteBuffer buffer = direct_buffers ? ByteBuffer.allocateDirect(1024) : ByteBuffer.allocate(1024);\n            try {\n                while (!Thread.interrupted()) {\n                    buffer.clear();\n                    int bytesRead = channel.read(buffer);\n                    if (bytesRead > 0) {\n                        buffer.flip();\n                        byte[] data = new byte[bytesRead];\n                        buffer.get(data);\n                        if (receiver != null) {\n                            receiver.receive(channel.socket().getInetAddress(), data, 0, bytesRead);\n                        }\n                    } else if (bytesRead == -1) {\n                        break; \n                    }\n                }\n            } catch (IOException e) {\n                log.log(Level.SEVERE, \"Error receiving data\", e);\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NIOAcceptor extends Thread {\n    private final int port;\n    private Selector selector;\n    private ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private final NIOProcessor[] processors;\n    private int nextProcessor;\n    private final AtomicLong acceptCount = new AtomicLong(0);\n\n    public NIOAcceptor(int port, FrontendConnectionFactory factory, NIOProcessor[] processors) throws IOException {\n        this.port = port;\n        this.factory = factory;\n        this.processors = processors;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                selector.select(1000);\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                Iterator<SelectionKey> iter = selectedKeys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (key.isAcceptable()) {\n                        accept();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void accept() throws IOException {\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            NIOProcessor processor = nextProcessor();\n            processor.register(clientChannel);\n            acceptCount.incrementAndGet();\n        }\n    }\n\n\n    private NIOProcessor nextProcessor() {\n        NIOProcessor processor = processors[nextProcessor];\n        nextProcessor = (nextProcessor + 1) % processors.length;\n        return processor;\n    }\n\n\n    public void closeChannel(SocketChannel channel) {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public static class AcceptIdGenerator {\n        private static long acceptId = 0;\n        private static final Object lock = new Object();\n\n        public static long getId() {\n            synchronized (lock) {\n                return ++acceptId;\n            }\n        }\n    }\n\n    interface FrontendConnectionFactory {\n        FrontendConnection create(SocketChannel channel);\n    }\n\n    interface FrontendConnection {\n    }\n}\n"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "import java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Enumeration;\nimport java.util.List;\n\nenum ProtocolFamily {\n    INET,\n    INET6\n}\n\npublic class MulticastSender {\n\n    private DatagramChannel sock;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n    private ProtocolFamily prot_family;\n\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) throws IOException {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n\n        if (mcast_addr instanceof Inet6Address) {\n            this.prot_family = ProtocolFamily.INET6;\n        } else {\n            this.prot_family = ProtocolFamily.INET;\n        }\n        sock = DatagramChannel.open();\n        sock.socket().bind(new InetSocketAddress(this.bind_addr, this.local_port));\n        sock.setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl);\n\n    }\n\n\n    public void start() throws IOException {\n\n        while (true) {\n            try {\n                String message = System.console().readLine();\n                byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);\n\n                ByteBuffer buffer = ByteBuffer.wrap(messageBytes);\n                sock.send(buffer, new InetSocketAddress(mcast_addr, mcast_port));\n\n            } catch (IOException e) {\n                System.err.println(\"Error sending message: \" + e.getMessage());\n            }\n        }\n\n    }\n\n\n    public static void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) throws IOException {\n        if (interfaces != null) {\n            for (NetworkInterface ni : interfaces) {\n                s.joinGroup(new InetSocketAddress(s.getInetAddress(), s.getPort()), ni);\n            }\n        } else {\n            Enumeration<NetworkInterface> nis = NetworkInterface.getNetworkInterfaces();\n            while (nis.hasMoreElements()) {\n                NetworkInterface ni = nis.nextElement();\n                if (ni.isUp() && !ni.isLoopback()) {\n                    s.joinGroup(new InetSocketAddress(s.getInetAddress(), s.getPort()), ni);\n                }\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        String bind_addr_str = (args.length > 0) ? args[0] : \"0.0.0.0\";\n        int local_port = (args.length > 1) ? Integer.parseInt(args[1]) : 0;\n        String mcast_addr_str = (args.length > 2) ? args[2] : \"230.0.0.1\";\n        int mcast_port = (args.length > 3) ? Integer.parseInt(args[3]) : 4446;\n        int ttl = (args.length > 4) ? Integer.parseInt(args[4]) : 1;\n\n\n        InetAddress bind_addr = InetAddress.getByName(bind_addr_str);\n        InetAddress mcast_addr = InetAddress.getByName(mcast_addr_str);\n\n\n        MulticastSender sender = new MulticastSender(bind_addr, local_port, mcast_addr, mcast_port, ttl);\n        sender.start();\n    }\n}\n"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a TCP proxy server using Vert.x that forwards incoming connections to a remote server after writing a custom header.\n\nClass Description: The HAProxy class acts as a TCP proxy server that listens for incoming connections, establishes connections to a remote server, writes a specified header to the remote connection, and then pipes data bidirectionally between the client and server.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and error messages\n- HOST: String - The host address where the proxy server will listen (default: \"localhost\")\n- PORT: int - The port number where the proxy server will listen (default: 11080)\n- remoteAddress: SocketAddress - The address of the remote server to forward connections to\n- header: Buffer - The header data to write to the remote connection\n- server: NetServer - The Vert.x TCP server instance\n- client: NetClient - The Vert.x TCP client instance for connecting to remote server\n- connectionRemoteAddress: SocketAddress - Stores the remote address of the established connection\n- connectionLocalAddress: SocketAddress - Stores the local address of the established connection\n\nMethods:\n- HAProxy(SocketAddress remoteAddress, Buffer header) -> HAProxy - Constructor that initializes the proxy with remote server address and header data\n- start(Vertx vertx) -> HAProxy - Starts the proxy server, configures connection handling, and returns the instance (throws Exception if startup fails)\n- stop() -> void - Stops the proxy server and cleans up resources\n- getConnectionRemoteAddress() -> SocketAddress - Returns the remote address of the established connection\n- getConnectionLocalAddress() -> SocketAddress - Returns the local address of the established connection",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class HAProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        NetServerOptions options = new NetServerOptions();\n        options.setHost(HOST).setPort(PORT);\n        server = vertx.createNetServer(options);\n        client = vertx.createNetClient();\n\n        server.connectHandler(socket -> {\n            socket.pause();\n            client.connect(remoteAddress).onComplete(result -> {\n                if (result.succeeded()) {\n                    log.debug(\"connected, writing header\");\n                    NetSocket clientSocket = result.result();\n                    connectionRemoteAddress = clientSocket.remoteAddress();\n                    connectionLocalAddress = clientSocket.localAddress();\n                    clientSocket.write(header).onSuccess(u -> {\n                        log.debug(\"starting pump\");\n                        socket.closeHandler(v -> clientSocket.close());\n                        clientSocket.closeHandler(v -> socket.close());\n                        socket.pipeTo(clientSocket);\n                        clientSocket.pipeTo(socket);\n                        socket.resume();\n                    }).onFailure(u -> {\n                        log.error(\"exception writing header\", result.cause());\n                        socket.close();\n                    });\n                } else {\n                    log.error(\"exception\", result.cause());\n                    socket.close();\n                }\n            });\n        });\n\n        CompletableFuture<Void> fut = new CompletableFuture<>();\n        server.listen().onComplete(ar -> {\n            if (ar.succeeded()) {\n                fut.complete(null);\n            } else {\n                fut.completeExceptionally(ar.cause());\n            }\n        });\n        fut.get(10, TimeUnit.SECONDS);\n        log.debug(\"HAProxy server started\");\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n            server = null;\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.logging.Logger;\nimport io.vertx.core.logging.LoggerFactory;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\npublic class HAProxy {\n\n    private final Logger log = LoggerFactory.getLogger(HAProxy.class);\n\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n\n    private NetServer server;\n    private NetClient client;\n\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        client = vertx.createNetClient();\n        server = vertx.createNetServer();\n\n        server.connectHandler(clientSocket -> {\n            this.connectionLocalAddress = clientSocket.localAddress();\n            this.connectionRemoteAddress = clientSocket.remoteAddress();\n            client.connect(remoteAddress.port(), remoteAddress.host(), res -> {\n                if (res.succeeded()) {\n                    NetSocket serverSocket = res.result();\n                    serverSocket.write(header);\n                    serverSocket.pipe().to(clientSocket).pipe().to(serverSocket);\n                } else {\n                    log.error(\"Failed to connect to remote server: \" + res.cause().getMessage());\n                    clientSocket.close();\n                }\n            });\n        }).listen(PORT, HOST, ar -> {\n            if (ar.failed()) {\n                throw new Exception(\"Failed to start proxy server\", ar.cause());\n            }\n        });\n        return this;\n    }\n\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}\n```\n"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "```java\nimport io.vertx.core.*;\nimport io.vertx.core.eventbus.EventBusOptions;\nimport io.vertx.core.eventbus.impl.EventBusImpl;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n    private final EventBusOptions options;\n    private NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        super(vertx, options);\n        this.options = options.getEventBusOptions();\n    }\n\n    private NetServerOptions getServerOptions() {\n        NetServerOptions serverOptions = new NetServerOptions();\n        serverOptions.setPort(getClusterPort());\n        serverOptions.setHost(getClusterHost());\n        return serverOptions;\n    }\n\n\n    public void start(Promise<Void> promise) {\n        server = vertx.createNetServer(getServerOptions());\n        server.connectHandler(getServerHandler());\n        server.listen(ar -> {\n            if (ar.succeeded()) {\n                super.start(promise);\n            } else {\n                promise.fail(ar.cause());\n            }\n        });\n    }\n\n\n    private Handler<NetSocket> getServerHandler() {\n        return socket -> {\n            // Handle incoming messages from other nodes in the cluster\n            socket.handler(buffer -> {\n                // Process received buffer and deliver message locally\n                // ... implementation for message deserialization and delivery ...\n            });\n\n            socket.closeHandler(v -> {\n                // Handle socket close events\n            });\n        };\n    }\n\n\n    private int getClusterPort() {\n        return options.getClusterPort();\n    }\n\n    private String getClusterHost() {\n        return options.getClusterHost() != null ? options.getClusterHost() : \"localhost\";\n    }\n\n}\n```"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "```java\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.logging.Logger;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpRequest;\nimport org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\nimport org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\nimport org.apache.hc.client5.http.impl.async.HttpAsyncClients;\nimport org.apache.hc.core5.http.HttpHeaders;\nimport org.apache.hc.core5.net.URIBuilder;\n\ninterface IBroadcastMetadataUpdater {\n    void update(IdentifierCollection identifierCollection);\n}\n\nclass IdentifierCollection {\n    // Dummy class representing metadata\n}\n\nclass IcecastConfiguration {\n    String host;\n    int port;\n    String mount;\n    String username;\n    String password;\n\n    public IcecastConfiguration(String host, int port, String mount, String username, String password) {\n        this.host = host;\n        this.port = port;\n        this.mount = mount;\n        this.username = username;\n        this.password = password;\n    }\n}\n\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n\n    private final Logger mLog = Logger.getLogger(IcecastBroadcastMetadataUpdater.class.getName());\n    private final CloseableHttpAsyncClient mHttpClient = HttpAsyncClients.createDefault();\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        this.mIcecastConfiguration = icecastConfiguration;\n        mHttpClient.start();\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        try {\n            String metadata = \"artist=Artist&title=Title\"; // Replace with actual metadata generation\n            String encodedMetadata = URLEncoder.encode(metadata, StandardCharsets.UTF_8);\n            URI uri = new URIBuilder()\n                    .setScheme(\"http\")\n                    .setHost(mIcecastConfiguration.host)\n                    .setPort(mIcecastConfiguration.port)\n                    .setPath(\"/admin/metadata\")\n                    .setParameter(\"mount\", mIcecastConfiguration.mount)\n                    .setParameter(\"mode\", \"updinfo\")\n                    .setParameter(\"song\", encodedMetadata)\n                    .build();\n\n            SimpleHttpRequest request = SimpleHttpRequest.put(uri);\n            String auth = mIcecastConfiguration.username + \":\" + mIcecastConfiguration.password;\n            String encodedAuth = java.util.Base64.getEncoder().encodeToString(auth.getBytes());\n            request.setHeader(HttpHeaders.AUTHORIZATION, \"Basic \" + encodedAuth);\n\n            CompletableFuture<SimpleHttpResponse> future = mHttpClient.execute(request, null);\n            future.whenComplete((response, ex) -> {\n                if (ex != null) {\n                    if (!mConnectionLoggingSuppressed) {\n                        mLog.severe(\"Error updating metadata: \" + ex.getMessage());\n                        mConnectionLoggingSuppressed = true;\n                    }\n                } else {\n                    mConnectionLoggingSuppressed = false;\n                    mLog.info(\"Metadata updated successfully. Status code: \" + response.getCode());\n                }\n            });\n\n        } catch (Exception e) {\n            mLog.severe(\"Error updating metadata: \" + e.getMessage());\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.function.Supplier;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) {\n        return unchecked(() -> httpClient.send(buildRequest(url, \"GET\"), HttpResponse.BodyHandlers.ofString()));\n    }\n\n\n    public HttpResponse<String> get(String url, Object... params) {\n        return get(String.format(url, params));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        return unchecked(() -> httpClient.send(buildRequest(String.format(url, params), \"DELETE\"), HttpResponse.BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        return unchecked(() -> httpClient.send(buildRequest(String.format(url, params), \"POST\"), HttpResponse.BodyHandlers.ofString()));\n    }\n\n\n    private HttpRequest buildRequest(String url, String method) {\n        return HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .method(method, HttpRequest.BodyPublishers.noBody())\n                .build();\n    }\n\n\n    private static <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n    private interface Exceptions {\n        interface ThrowingSupplier<T> extends Supplier<T> {\n            T get() throws Exception;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\nimport java.security.cert.X509Certificate;\nimport java.util.Map;\n\npublic class HttpUtil {\n\n    private static int Timeout = 5000;\n    private static String DefalutEncoding = \"UTF-8\";\n    private static Map<String, String> currentProxy;\n    private static final HostnameVerifier allHostsValid = (hostname, session) -> true;\n\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) {\n        StringBuilder response = new StringBuilder();\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n            connection.setConnectTimeout(timeOut);\n            connection.setReadTimeout(timeOut);\n            connection.setRequestMethod(requestMethod);\n            connection.setDoInput(true);\n            connection.setDoOutput(!\"GET\".equals(requestMethod));\n\n            if (contentType != null) {\n                connection.setRequestProperty(\"Content-Type\", contentType);\n            }\n            if (postString != null && !\"GET\".equals(requestMethod)) {\n                try (OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(), encoding != null ? encoding : DefalutEncoding)) {\n                    writer.write(postString);\n                    writer.flush();\n                }\n            }\n\n            if (\"https\".equalsIgnoreCase(url.getProtocol())) {\n                ((HttpsURLConnection) connection).setSSLSocketFactory(createSSLSocketFactory());\n                ((HttpsURLConnection) connection).setHostnameVerifier(allHostsValid);\n            }\n\n            try (InputStream inputStream = connection.getResponseCode() < 400 ? connection.getInputStream() : connection.getErrorStream()) {\n                response.append(readString(inputStream, encoding));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"Error: \" + e.getMessage();\n        }\n        return response.toString();\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws Exception {\n        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustUtiil()};\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n        return sslContext.getSocketFactory();\n    }\n\n    private static String readString(InputStream inputStream, String encoding) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, encoding != null ? encoding : DefalutEncoding))) {\n            String line;\n            StringBuilder result = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n            return result.toString();\n        }\n    }\n\n    private static class X509TrustUtiil implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.*;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.StreamObserver;\nimport org.apache.commons.lang3.tuple.KVPair;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.Predicate;\n\npublic abstract class AbstractClient<StubT extends AbstractStub<StubT>, BlockingStubT extends AbstractBlockingStub<BlockingStubT>> {\n\n    protected final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy<StubT, BlockingStubT> stubProxy;\n    protected final PDConfig config;\n\n    protected ManagedChannel channel;\n    protected ConcurrentMap<String, BlockingStubT> stubs = new ConcurrentHashMap<>();\n\n\n    public AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy<>(this);\n    }\n\n\n    public BlockingStubT getBlockingStub() {\n        return stubProxy.getBlockingStub();\n    }\n\n    public StubT getStub() {\n        return stubProxy.getStub();\n    }\n\n    protected abstract StubT createStub();\n\n    protected abstract BlockingStubT createBlockingStub();\n\n    public String resetStub() {\n        // Implementation for resetting connection and finding leader\n        return null;\n    }\n\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, config.getRetryTimes());\n    }\n\n    public <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        // Implementation for blocking unary call with retry logic\n        return null;\n    }\n\n    public <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method,\n                                                                           ReqT req, Predicate<RespT> predicate) {\n        // Implementation for concurrent calls to multiple hosts\n        return null;\n    }\n\n    public <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                            StreamObserver<RespT> responseObserver, int retry) {\n        // Implementation for server streaming call\n    }\n\n\n    public void close() {\n        chs.values().forEach(this::closeChannel);\n        chs.clear();\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        if (channel != null && !channel.isShutdown()) {\n            try {\n                channel.shutdownNow().awaitTermination(5, java.util.concurrent.TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n\n    static class PDConfig {\n        // Placeholder for configuration settings\n        public int getRetryTimes() {\n            return 3;\n        }\n    }\n\n    static class AbstractClientStubProxy<StubT extends AbstractStub<StubT>, BlockingStubT extends AbstractBlockingStub<BlockingStubT>> {\n        private final AbstractClient<StubT, BlockingStubT> client;\n\n        public AbstractClientStubProxy(AbstractClient<StubT, BlockingStubT> client) {\n            this.client = client;\n        }\n\n        public BlockingStubT getBlockingStub() {\n            // Implementation for getting or creating blocking stub\n            return null;\n        }\n\n        public StubT getStub() {\n            // Implementation for getting or creating async stub\n            return null;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 504,
    "Instruction": "Task Description: Implement a function to test the gRPC Server Reflection service by establishing a connection to a gRPC server, sending a reflection request, and processing the response.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 9090 using plaintext communication. It creates an asynchronous stub for the Server Reflection service, sends a request to list all available services, and processes the response. The function ensures proper cleanup by shutting down the channel after completion.\n\nInput: None (The target server address is hardcoded as \"localhost:9090\")\n\nOutput: None (The function processes the reflection response internally via the checkResult method, which is not shown in the reference code)",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc.ServerReflectionStub;\nimport io.grpc.reflection.v1alpha.ServerReflectionRequest;\nimport io.grpc.reflection.v1alpha.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\n\nvoid testReflectionService() {\n    final ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:9090\").usePlaintext().build();\n    try {\n        final ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n\n        final AwaitableStreamObserver<ServerReflectionResponse> resultObserver = new AwaitableStreamObserver<>();\n        final StreamObserver<ServerReflectionRequest> requestObserver = stub.serverReflectionInfo(resultObserver);\n        requestObserver.onNext(ServerReflectionRequest.newBuilder()\n                .setListServices(\"\")\n                .build());\n        requestObserver.onCompleted();\n        checkResult(resultObserver);\n    } finally {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 23,
    "wrong_result": "```java\nimport io.grpc.*;\nimport io.grpc.reflection.v1alpha.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\n\npublic class GrpcReflectionClient {\n\n    private static final Logger logger = Logger.getLogger(GrpcReflectionClient.class.getName());\n\n    private final ManagedChannel channel;\n    private final ServerReflectionStub asyncStub;\n\n    public GrpcReflectionClient(String target) {\n        this.channel = ManagedChannelBuilder.forTarget(target)\n                .usePlaintext()\n                .build();\n        this.asyncStub = ServerReflectionGrpc.newStub(channel);\n    }\n\n    public void shutdown() throws InterruptedException {\n        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n\n    public void listServices() {\n        ServerReflectionRequest request = ServerReflectionRequest.newBuilder()\n                .setListServices(ListServiceRequest.newBuilder().build())\n                .build();\n\n        asyncStub.serverReflectionInfo(new StreamObserver<ServerReflectionResponse>() {\n            @Override\n            public void onNext(ServerReflectionResponse value) {\n                checkResult(value);\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                logger.severe(\"Encountered error:\" + t.getMessage());\n            }\n\n            @Override\n            public void onCompleted() {\n                logger.info(\"Completed\");\n            }\n        }).onNext(request);\n    }\n\n\n    private void checkResult(ServerReflectionResponse response) {\n        // Implementation for processing the response (not provided in the reference code)\n        if (response.hasListServicesResponse()) {\n            for (ServiceResponse service : response.getListServicesResponse().getServiceList()) {\n                logger.info(\"Service: \" + service.getName());\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        GrpcReflectionClient client = new GrpcReflectionClient(\"localhost:9090\");\n        try {\n            client.listServices();\n            Thread.sleep(5000); // Allow time for the asynchronous call to complete\n        } finally {\n            client.shutdown();\n        }\n    }\n}\n\n```\n"
  },
  {
    "Task_id": 506,
    "Instruction": "Task Description: Implement a gRPC server in Java that handles streaming requests and responses, following the structure and functionality of the provided reference code.\n\nClass Description: The HelloWorldServer class represents a gRPC server that listens on a specified port and provides a streaming greeting service. It manages server lifecycle operations (start, stop, await termination) and implements the gRPC service interface for handling client requests.\n\nAttributes:\n- server: [Server] - The gRPC server instance that handles incoming requests\n- logger: [Logger] - Logger instance for server activity logging\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50051 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting.\n\nNested Class:\n- GreeterImpl: [StreamingGreeterGrpc.StreamingGreeterImplBase] - Implements the gRPC service interface with streaming capabilities\n  Methods:\n  - sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Handles client requests by sending multiple greeting responses in a stream. Takes a HelloRequest containing the client's name and a StreamObserver for sending responses. Sends three greeting messages with increasing excitement, then completes the stream.",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.streaming.HelloReply;\nimport io.grpc.examples.streaming.HelloRequest;\nimport io.grpc.examples.streaming.StreamingGreeterGrpc;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n  private Server server;\n\n  public void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  public void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  public void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n    @Override\n    public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      try {\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!\").build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!!\").build());\n      } catch (InterruptedException e) {\n        responseObserver.onError(e);\n      } finally {\n        responseObserver.onCompleted();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n    private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n    private Server server;\n\n    private void start() throws IOException {\n        /* The port on which the server should run */\n        int port = 50051;\n        server = ServerBuilder.forPort(port)\n                .addService(new GreeterImpl())\n                .build()\n                .start();\n        logger.info(\"Server started, listening on \" + port);\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                // Use stderr here since the logger may have been reset by its JVM shutdown hook.\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                try {\n                    HelloWorldServer.this.stop();\n                } catch (InterruptedException e) {\n                    e.printStackTrace(System.err);\n                }\n                System.err.println(\"*** server shut down\");\n            }\n        });\n    }\n\n    private void stop() throws InterruptedException {\n        if (server != null) {\n            server.shutdown().awaitTermination(30, TimeUnit.SECONDS);\n        }\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n\n        @Override\n        public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n            String name = req.getName();\n            try {\n                responseObserver.onNext(HelloReply.newBuilder().setMessage(\"Hello \" + name + \"!\").build());\n                Thread.sleep(1000);\n                responseObserver.onNext(HelloReply.newBuilder().setMessage(\"Hello again \" + name + \"!!\").build());\n                Thread.sleep(1000);\n                responseObserver.onNext(HelloReply.newBuilder().setMessage(\"Hello for the third time \" + name + \"!!!\").build());\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                responseObserver.onCompleted();\n            }\n\n        }\n    }\n\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        final HelloWorldServer server = new HelloWorldServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n}\n"
  },
  {
    "Task_id": 507,
    "Instruction": "Task Description: Create a gRPC server in Java that can handle multiple services, manage interceptors, and provide service discovery capabilities.\n\nClass Description: The GrpcServer class is responsible for initializing and managing a gRPC server instance. It handles server configuration, service registration, interceptor management, and provides methods for service discovery. The server can be started and stopped gracefully, and it maintains mappings of services and methods for lookup purposes.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- serviceNameMap: [Map<String, Class<? extends BindableService>>] - Mapping of service names to their implementation classes\n- fullMethodNameMap: [Map<String, Method>] - Mapping of full method names to their corresponding Method objects\n\nMethods:\n- GrpcServer: [Constructor](GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Initializes the server with given properties, interceptors and services\n- GrpcServer: [Constructor](ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Alternative constructor accepting a pre-configured ServerBuilder\n- isRunning: [isRunning]() -> [boolean] - Checks if the server is currently running\n- port: [port]() -> [int] - Returns the port number the server is listening on\n- findClass: [findClass](ServiceDescriptor descriptor) -> [Class<? extends BindableService>] - Finds the implementation class for a given service descriptor\n- findMethod: [findMethod](MethodDescriptor<?, ?> descriptor) -> [Method] - Finds the Method object for a given method descriptor\n- resolve: [resolve](MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) -> [Method] - Resolves the Method object for a given method descriptor within a service class\n- onApplicationStart: [onApplicationStart]() -> [void] - Starts the server and begins awaiting termination\n- onApplicationStop: [onApplicationStop]() -> [void] - Shuts down the server gracefully",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerMethodDefinition;\nimport io.grpc.ServerServiceDefinition;\nimport io.grpc.ServiceDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport org.ballcat.common.core.compose.ContextComponent;\nimport org.ballcat.common.thread.ThreadPool;\nimport org.ballcat.common.util.ClassUtils;\nimport org.ballcat.grpc.server.properties.GrpcServerProperties;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\n\npublic class GrpcServer implements ContextComponent {\n\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap;\n    private final Map<String, Method> fullMethodNameMap;\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        this(ServerBuilder.forPort(properties.getPort()), properties, interceptors, services);\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        builder\n            .maxInboundMessageSize((int) properties.getMessageSize().toBytes())\n            .keepAliveTime(properties.getKeepAliveTime(), TimeUnit.MILLISECONDS)\n            .keepAliveTimeout(properties.getKeepAliveTimeout(), TimeUnit.MILLISECONDS);\n\n        interceptors.sort(AnnotationAwareOrderComparator.INSTANCE);\n        ListIterator<ServerInterceptor> iterator = interceptors.listIterator(interceptors.size());\n        while (iterator.hasPrevious()) {\n            builder.intercept(iterator.previous());\n        }\n\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n\n        for (BindableService service : services) {\n            builder.addService(service);\n            Class<? extends BindableService> cls = service.getClass();\n            ServerServiceDefinition serverServiceDefinition = service.bindService();\n            ServiceDescriptor serviceDescriptor = serverServiceDefinition.getServiceDescriptor();\n\n            this.serviceNameMap.put(serviceDescriptor.getName(), cls);\n\n            for (ServerMethodDefinition<?, ?> serverMethodDefinition : serverServiceDefinition.getMethods()) {\n                MethodDescriptor<?, ?> methodDescriptor = serverMethodDefinition.getMethodDescriptor();\n                String fullMethodName = methodDescriptor.getFullMethodName();\n                this.fullMethodNameMap.put(fullMethodName, resolve(methodDescriptor, cls));\n            }\n        }\n\n        this.server = builder.build();\n    }\n\n    public boolean isRunning() {\n        return !this.server.isShutdown() && !this.server.isTerminated();\n    }\n\n    public int port() {\n        return this.server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return this.serviceNameMap.get(descriptor.getName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return this.fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    protected Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        String bareMethodName = descriptor.getBareMethodName();\n        for (Method method : ClassUtils.methods(cls)) {\n            if (Objects.equals(method.getName(), bareMethodName)) {\n                return method;\n            }\n        }\n        return null;\n    }\n\n    public void onApplicationStart() {\n        this.server.start();\n        ThreadPool.instance().execute(\"GrpcServer\", this.server::awaitTermination);\n    }\n\n    public void onApplicationStop() {\n        this.server.shutdownNow();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "```java\nimport io.grpc.*;\nimport io.grpc.protobuf.services.ProtoReflectionService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class GrpcServer {\n\n    private Server server;\n    private Map<String, Class<? extends BindableService>> serviceNameMap = new HashMap<>();\n    private Map<String, Method> fullMethodNameMap = new HashMap<>();\n\n    @Autowired\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        this(ServerBuilder.forPort(properties.getPort()), properties, interceptors, services);\n    }\n\n    @Autowired\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        interceptors.forEach(builder::intercept);\n        if (properties.isEnableReflection()) {\n            builder.addService(ProtoReflectionService.newInstance());\n        }\n        for (BindableService service : services) {\n            builder.addService(service);\n            registerService(service);\n        }\n        this.server = builder.build();\n    }\n\n    public boolean isRunning() {\n        return server != null && !server.isShutdown() && !server.isTerminated();\n    }\n\n    public int port() {\n        return server.getPort();\n    }\n\n    private void registerService(BindableService service) {\n        ServerServiceDefinition definition = service.bindService();\n        serviceNameMap.put(definition.getServiceDescriptor().getName(), service.getClass());\n        for (ServerMethodDefinition<?, ?> method : definition.getMethods()) {\n            fullMethodNameMap.put(method.getMethodDescriptor().getFullMethodName(), resolve(method.getMethodDescriptor(), service.getClass()));\n        }\n    }\n\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return serviceNameMap.get(descriptor.getName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    public Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        try {\n            return cls.getMethod(descriptor.getBareMethodName(), descriptor.getInputType().getClass(), descriptor.getOutputType().getClass());\n        } catch (NoSuchMethodException e) {\n            return null;\n        }\n    }\n\n\n    public void onApplicationStart() throws Exception {\n        server.start();\n        server.awaitTermination();\n    }\n\n    public void onApplicationStop() throws Exception {\n        if (server != null) {\n            server.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n\n\n    public static class GrpcServerProperties {\n        private int port = 6565;\n        private boolean enableReflection = true;\n\n        public int getPort() {\n            return port;\n        }\n\n        public void setPort(int port) {\n            this.port = port;\n        }\n\n        public boolean isEnableReflection() {\n            return enableReflection;\n        }\n\n        public void setEnableReflection(boolean enableReflection) {\n            this.enableReflection = enableReflection;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function to test if a given URL is reachable by making an HTTP GET request and verifying the response code.\n\nFunction Description: The function attempts to connect to a specified URL using an HTTP GET request. It checks if the response code is HTTP_OK (200) to determine if the URL is reachable. The connection is properly closed after the check.\n\nInput: \n- strUrl: String - The URL to be tested for reachability\n\nOutput: \n- None (The function throws an exception if the URL is unreachable or if the response code is not HTTP_OK)",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic void testUrlReachable(String strUtl) throws Exception {\n    URL url = new URL(strUtl);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"GET\");\n    conn.connect();\n    int rc = conn.getResponseCode();\n    assertEquals(HttpURLConnection.HTTP_OK, rc);\n    conn.disconnect();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": ""
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\n\ninterface VirtualCheckCallback {\n    void onSuspectFound(String suspect);\n}\n\npublic class SocketCommunication {\n    private final String TAG = \"SocketCommunication\";\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList = new ArrayList<>();\n\n    public SocketCommunication(String secret, VirtualCheckCallback callback) {\n        this.secret = secret;\n        this.callback = callback;\n    }\n\n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        this.secret = secret;\n        this.callback = callback;\n        startServer(secret, callback);\n        startClient(secret);\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        new Thread(new ServerThread(secret, callback)).start();\n    }\n\n    private void startClient(String secret) {\n        new Thread(() -> {\n            for (int port = 1; port <= 65535; port++) {\n                new Thread(new ClientThread(secret, port)).start();\n            }\n        }).start();\n    }\n\n    private class ServerThread implements Runnable {\n        private String secret;\n        private VirtualCheckCallback callback;\n\n        ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(0)) {\n                portList.add(serverSocket.getLocalPort());\n                while (true) {\n                    Socket clientSocket = serverSocket.accept();\n                    new Thread(new ReadThread(secret, clientSocket, callback)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ReadThread implements Runnable {\n        private String secret;\n        private Socket clientSocket;\n        private VirtualCheckCallback callback;\n\n        ReadThread(String secret, Socket clientSocket, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.clientSocket = clientSocket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    if (inputLine.equals(secret)) {\n                        callback.onSuspectFound(clientSocket.getInetAddress().getHostAddress());\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ClientThread implements Runnable {\n        private String secret;\n        private int port;\n\n        ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try (Socket socket = new Socket(\"localhost\", port);\n                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n                out.println(secret);\n            } catch (IOException ignored) {}\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 521,
    "Instruction": "Task Description: Create a Java class that implements Kubernetes port forwarding functionality, allowing local ports to be forwarded to target ports in a Kubernetes pod. The class should handle multiple port forwards simultaneously and provide error handling capabilities.\n\nClass Description: KubectlPortForward is a Kubernetes client utility that establishes TCP port forwarding between local ports and target ports in a specified pod. It extends Kubectl's ResourceAndContainerBuilder and implements Executable<Boolean> interface. The class manages multiple port forwarding connections in separate threads and provides shutdown capability.\n\nAttributes:\n- localPorts: List<Integer> - Stores local port numbers to be forwarded\n- targetPorts: List<Integer> - Stores target port numbers in the pod\n- running: boolean - Flag indicating whether port forwarding is active\n- onUnhandledError: Consumer<Throwable> - Callback for handling uncaught exceptions\n\nMethods:\n- ports(int localPort, int targetPort) -> KubectlPortForward - Adds a port forwarding pair (local and target ports)\n- onUnhandledError(Consumer<Throwable> onUnhandledError) -> KubectlPortForward - Sets the error handler callback\n- execute() -> Boolean - Starts the port forwarding operation (implements Kubectl.Executable)\n- shutdown() -> void - Stops all port forwarding operations\n- executeInternal() -> void - Internal implementation of port forwarding (throws ApiException, KubectlException, IOException, InterruptedException)\n- portForward(PortForward pf, ServerSocket server, int targetPort) -> Thread - Creates and starts a thread for a single port forwarding connection\n- copyAsync(InputStream, OutputStream, Consumer<Throwable>) -> Thread - Helper method for asynchronous stream copying (not shown in reference code)",
    "Canonical_solution": "import io.kubernetes.client.PortForward;\nimport io.kubernetes.client.extended.kubectl.Kubectl;\nimport io.kubernetes.client.extended.kubectl.exception.KubectlException;\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward\n    extends Kubectl.ResourceAndContainerBuilder<V1Pod, KubectlPortForward>\n    implements Kubectl.Executable<Boolean> {\n  private List<Integer> localPorts;\n  private List<Integer> targetPorts;\n  private boolean running;\n  private Consumer<Throwable> onUnhandledError = Throwable::printStackTrace;\n\n  public KubectlPortForward() {\n    super(V1Pod.class);\n    localPorts = new ArrayList<>();\n    targetPorts = new ArrayList<>();\n  }\n\n  public KubectlPortForward ports(int localPort, int targetPort) {\n    localPorts.add(localPort);\n    targetPorts.add(targetPort);\n    return this;\n  }\n\n  public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n    this.onUnhandledError = onUnhandledError;\n    return this;\n  }\n\n  @Override\n  public Boolean execute() throws KubectlException {\n    running = true;\n    try {\n      executeInternal();\n      return true;\n    } catch (ApiException | IOException | InterruptedException ex) {\n      throw new KubectlException(ex);\n    }\n  }\n\n  public void shutdown() {\n    running = false;\n  }\n\n  private void executeInternal()\n      throws ApiException, KubectlException, IOException, InterruptedException {\n    PortForward pf = new PortForward(apiClient);\n    List<Thread> threads = new ArrayList<>();\n    for (int i = 0; i < localPorts.size(); i++) {\n      int targetPort = targetPorts.get(i);\n      threads.add(portForward(pf, new ServerSocket(localPorts.get(i)), targetPort));\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n  }\n\n  private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n    Thread t = new Thread(\n        () -> {\n          while (running) {\n            try (Socket sock = server.accept()) {\n              PortForward.PortForwardResult result = pf.forward(namespace, name, Arrays.asList(targetPort));\n              if (result == null) {\n                throw new KubectlException(\"PortForward failed!\");\n              }\n              InputStream in = result.getInputStream(targetPort);\n              OutputStream out = result.getOutboundStream(targetPort);\n              Thread t1 = copyAsync(sock.getInputStream(), out, onUnhandledError);\n              Thread t2 = copyAsync(in, sock.getOutputStream(), onUnhandledError);\n\n              t1.join();\n              in.close();\n              t2.join();\n            } catch (Exception ex) {\n              Optional.ofNullable(onUnhandledError)\n                  .orElse(Throwable::printStackTrace)\n                  .accept(ex);\n            }\n          }\n        });\n    t.start();\n    return t;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport io.kubernetes.client.ApiException;\nimport io.kubernetes.client.Exec;\nimport io.kubernetes.client.custom.PortForward;\nimport io.kubernetes.client.openapi.ApiClient;\nimport io.kubernetes.client.util.Kubectl;\nimport io.kubernetes.client.util.Streams;\nimport io.kubernetes.client.util.exception.KubectlException;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward extends Kubectl.ResourceAndContainerBuilder<Boolean> implements Kubectl.Executable<Boolean> {\n\n    private List<Integer> localPorts = new ArrayList<>();\n    private List<Integer> targetPorts = new ArrayList<>();\n    private boolean running = false;\n    private Consumer<Throwable> onUnhandledError;\n\n    public KubectlPortForward(ApiClient client) {\n        super(client);\n    }\n\n\n    public KubectlPortForward ports(int localPort, int targetPort) {\n        this.localPorts.add(localPort);\n        this.targetPorts.add(targetPort);\n        return this;\n    }\n\n    public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n        this.onUnhandledError = onUnhandledError;\n        return this;\n    }\n\n    @Override\n    public Boolean execute() throws KubectlException, ApiException, IOException, InterruptedException {\n        running = true;\n        executeInternal();\n        return true;\n    }\n\n    public void shutdown() {\n        running = false;\n    }\n\n    private void executeInternal() throws ApiException, KubectlException, IOException, InterruptedException {\n        final PortForward.PortForwardResult result = new PortForward(client).forward(namespace, name, container, localPorts.stream().mapToInt(Integer::intValue).toArray());\n\n        ExecutorService executor = Executors.newFixedThreadPool(localPorts.size());\n\n        for (int i = 0; i < localPorts.size(); i++) {\n            final int targetPort = targetPorts.get(i);\n            final ServerSocket server = result.getPortForwardSockets()[i];\n            executor.submit(() -> portForward(result, server, targetPort));\n        }\n\n        while (running) {\n            Thread.sleep(1000);\n        }\n\n        result.close();\n        executor.shutdownNow();\n    }\n\n    private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n        return new Thread(() -> {\n            try {\n                while (running) {\n                    try (Socket client = server.accept();\n                         InputStream clientIn = client.getInputStream();\n                         OutputStream clientOut = client.getOutputStream()) {\n\n                        pf.forward(clientIn, clientOut, targetPort);\n                    }\n                }\n            } catch (IOException ex) {\n                if (running && onUnhandledError != null) {\n                    onUnhandledError.accept(ex);\n                }\n            }\n        });\n    }\n\n\n}\n```\n"
  },
  {
    "Task_id": 522,
    "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newCachedThreadPool();\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new HashMap<>();\n    private ServerSocket serverSocket;\n    private final int port;\n    private Thread waitConnectionThread;\n    private final Config config;\n\n\n    public HttpProxyCacheServer(Config config) {\n        this.port = config.getPort();\n        this.config = config;\n    }\n\n    public void waitForRequest() {\n        try {\n            serverSocket = new ServerSocket(port);\n            waitConnectionThread = new Thread(new WaitRequestsRunnable());\n            waitConnectionThread.start();\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n\n    private void processSocket(Socket socket) {\n        socketProcessor.submit(new SocketProcessorRunnable(socket));\n    }\n\n    public synchronized HttpProxyCacheServerClients getClients(String url) {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (socket != null && !socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (socket != null && !socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    protected void onError(Throwable e) {\n        e.printStackTrace();\n    }\n\n\n    private class WaitRequestsRunnable implements Runnable {\n        @Override\n        public void run() {\n            while (!Thread.currentThread().isInterrupted()) {\n                try {\n                    Socket socket = serverSocket.accept();\n                    processSocket(socket);\n                } catch (IOException e) {\n                    onError(e);\n                }\n            }\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                // Implement request handling and caching logic here\n            } finally {\n                releaseSocket(socket);\n            }\n        }\n    }\n\n    public static class Config {\n        private int port = 8080;\n\n        public int getPort() {\n            return port;\n        }\n\n        public void setPort(int port) {\n            this.port = port;\n        }\n    }\n\n    public static class HttpProxyCacheServerClients {\n        private final String url;\n        private final Config config;\n\n        public HttpProxyCacheServerClients(String url, Config config) {\n            this.url = url;\n            this.config = config;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that retrieves content from a given HTTP/HTTPS URL and handles redirects with proper cookie management.\n\nFunction Description: The function establishes an HTTP connection to the specified URL, follows redirects (up to 10 times), maintains cookies during redirects, and returns the input stream of the final response. It handles standard HTTP response codes and supports common request headers.\n\nInput: \n- urlStr: String - The URL string to fetch content from (must start with \"http://\" or \"https://\")\n\nOutput: \n- InputStream - The input stream containing the response data from the final URL after following redirects, or null if:\n  - The URL scheme is not HTTP/HTTPS\n  - An exception occurs during the process\n  - Maximum redirect count (10) is exceeded",
    "Canonical_solution": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate InputStream getKmlContents(String urlStr) {\n    InputStream inputStream;\n    try {\n        if (urlStr.startsWith(\"http://\") || urlStr.startsWith(\"https://\")) {\n            URL url = new URL(urlStr);\n            boolean redirect = true;\n            HttpURLConnection http = null;\n            String cookies = null;\n            int redirectCnt = 0;\n            while(redirect && redirectCnt < 10) {\n                redirect = false;\n                http = (HttpURLConnection)url.openConnection();\n                http.setRequestMethod(\"GET\");\n                if (cookies != null) {\n                    http.setRequestProperty(\"Cookie\", cookies);\n                }\n                http.addRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                http.addRequestProperty(\"User-Agent\", \"Mozilla\");\n                http.setInstanceFollowRedirects(true);\n                HttpURLConnection.setFollowRedirects(true);\n\n                int status = http.getResponseCode();\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP\n                        || status == HttpURLConnection.HTTP_MOVED_PERM\n                        || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        redirect = true;\n                }\n                if (redirect) {\n                    url = new URL(http.getHeaderField(\"Location\"));\n                    cookies = http.getHeaderField(\"Set-Cookie\");\n                    http.disconnect();\n                    redirectCnt++;\n                }\n            }\n            inputStream = http.getInputStream();\n        } else {\n            // Handle other URL types (file://, etc)\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return inputStream;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.List;\nimport java.util.Map;\n\npublic class URLFetcher {\n\n    public static InputStream fetchURL(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            if (!url.getProtocol().startsWith(\"http\")) {\n                return null;\n            }\n\n            int redirectCount = 0;\n            String cookies = \"\";\n\n            while (redirectCount < 10) {\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n                if (!cookies.isEmpty()) {\n                    connection.setRequestProperty(\"Cookie\", cookies);\n                }\n\n                connection.connect();\n\n                int responseCode = connection.getResponseCode();\n\n                if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\n                    String location = connection.getHeaderField(\"Location\");\n                    if (location != null) {\n                        url = new URL(location);\n\n                        Map<String, List<String>> headerFields = connection.getHeaderFields();\n                        List<String> cookieList = headerFields.get(\"Set-Cookie\");\n                        if (cookieList != null) {\n                            for (String cookie : cookieList) {\n                                cookies += cookie + \"; \";\n                            }\n                        }\n\n                        redirectCount++;\n                        continue;\n                    }\n                }\n\n                if (responseCode >= 200 && responseCode < 300) {\n                    return connection.getInputStream();\n                }\n                return null;\n\n            }\n            return null;\n\n\n        } catch (MalformedURLException e) {\n            return null;\n        } catch (IOException e) {\n            return null;\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 533,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to handle client connections, process incoming requests, and send responses. The server should integrate with Eureka service discovery and manage its lifecycle through initialization and cleanup.\n\nClass Description: ExampleServiceBase is a singleton class that acts as a TCP server, listening on a specified port for client connections. It processes incoming requests by reading input from clients and sending back responses with a timestamp. The class integrates with Eureka service discovery to register its availability.\n\nAttributes:\n- applicationInfoManager: [ApplicationInfoManager] - Manages the service instance information for Eureka registration\n- eurekaClient: [EurekaClient] - Handles communication with the Eureka service discovery server\n\nMethods:\n- ExampleServiceBase([ApplicationInfoManager, EurekaClient]) -> [void] - Constructor that initializes the Eureka-related dependencies\n- start() -> [void] - Initializes the service by setting its status to UP in Eureka and starts listening for client connections on the registered port\n- processRequest([Socket]) -> [void] - Processes an incoming client connection by reading the request, generating a response with current timestamp, and sending it back to the client",
    "Canonical_solution": "import com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\n@Singleton\npublic class ExampleServiceBase {\n\n    private final ApplicationInfoManager applicationInfoManager;\n    private final EurekaClient eurekaClient;\n\n    @Inject\n    public ExampleServiceBase(ApplicationInfoManager applicationInfoManager,\n                            EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n    }\n\n    @PostConstruct\n    public void start() {\n        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n        \n        try {\n            int myServingPort = applicationInfoManager.getInfo().getPort();\n            ServerSocket serverSocket = new ServerSocket(myServingPort);\n            final Socket s = serverSocket.accept();\n            processRequest(s);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(final Socket s) {\n        try {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n            String line = rd.readLine();\n            if (line != null) {\n                System.out.println(\"Received a request from the example client: \" + line);\n            }\n            String response = \"BAR \" + new Date();\n            System.out.println(\"Sending the response to the client: \" + response);\n\n            PrintStream out = new PrintStream(s.getOutputStream());\n            out.println(response);\n\n        } catch (Throwable e) {\n            System.err.println(\"Error processing requests\");\n        } finally {\n            if (s != null) {\n                try {\n                    s.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class ExampleServiceBase {\n\n    private static ExampleServiceBase instance;\n    private final ApplicationInfoManager applicationInfoManager;\n    private final EurekaClient eurekaClient;\n    private int port = 8080; // Default port\n\n    private ExampleServiceBase(ApplicationInfoManager applicationInfoManager, EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n    }\n\n    public static ExampleServiceBase getInstance(ApplicationInfoManager applicationInfoManager, EurekaClient eurekaClient) {\n        if (instance == null) {\n            instance = new ExampleServiceBase(applicationInfoManager, eurekaClient);\n        }\n        return instance;\n    }\n\n\n    public void start() {\n        applicationInfoManager.setInstanceStatus(com.netflix.appinfo.InstanceInfo.InstanceStatus.UP);\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Server started on port \" + port);\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    processRequest(clientSocket);\n                } catch (IOException e) {\n                    System.err.println(\"Error handling client: \" + e.getMessage());\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Could not start server: \" + e.getMessage());\n        }\n    }\n\n    private void processRequest(Socket clientSocket) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n            String request = in.readLine();\n            System.out.println(\"Received: \" + request);\n\n            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);\n            String response = \"Response at \" + timestamp;\n            out.println(response);\n\n            System.out.println(\"Sent: \" + response);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport android.app.Activity;\nimport android.widget.Toast;\nimport java.io.*;\nimport java.net.*;\n\npublic class EvdevCaptureProvider implements Runnable {\n\n    public interface EvdevListener {\n        void onInputEvent(byte[] event);\n    }\n\n    private EvdevListener listener;\n    private String libraryPath;\n    private volatile boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n    private Thread handlerThread;\n\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    public void destroy() {\n        shutdown = true;\n        try {\n            if (evdevSock != null) evdevSock.close();\n            if (servSock != null) servSock.close();\n            if (su != null) su.destroy();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(() -> Toast.makeText(activity, \"Device not rooted or su not accessible\", Toast.LENGTH_LONG).show());\n    }\n\n    @Override\n    public void run() {\n        try {\n            servSock = new ServerSocket(0);\n\n            ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", libraryPath + \"/libevdevreader.so \" + servSock.getLocalPort());\n            pb.redirectErrorStream(true);\n            su = pb.start();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(su.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null && !shutdown) {\n                System.out.println(\"Native process output: \" + line); // Log native process output\n            }\n\n            if (shutdown) return;\n\n            evdevSock = servSock.accept();\n            evdevIn = evdevSock.getInputStream();\n            evdevOut = evdevSock.getOutputStream();\n\n            byte[] buffer = new byte[128];\n            int bytesRead;\n            while ((bytesRead = evdevIn.read(buffer)) != -1 && !shutdown) {\n                if (listener != null) {\n                    byte[] event = new byte[bytesRead];\n                    System.arraycopy(buffer, 0, event, 0, bytesRead);\n                    listener.onInputEvent(event);\n                }\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            reportDeviceNotRooted();\n        } finally {\n            destroy();\n        }\n    }\n\n\n    public void start() {\n        if (!started) {\n            started = true;\n            handlerThread = new Thread(this);\n            handlerThread.start();\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TcpEchoTest {\n    public void testTcpEcho() throws Exception {\n        String testMessage = \"Hello, server!\";\n        final String[] receivedMessage = {null};\n\n        Thread serverThread = new Thread(() -> {\n            try (ServerSocket serverSocket = new ServerSocket(5678);\n                 Socket clientSocket = serverSocket.accept();\n                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {\n\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    out.println(inputLine);\n                }\n            } catch (IOException e) {\n                fail(\"Server error: \" + e.getMessage());\n            }\n        });\n\n        serverThread.start();\n\n        Thread clientThread = new Thread(() -> {\n            try (Socket socket = new Socket(\"localhost\", 5678);\n                 PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\n                out.println(testMessage);\n                receivedMessage[0] = in.readLine();\n            } catch (IOException e) {\n                fail(\"Client error: \" + e.getMessage());\n            }\n        });\n\n        clientThread.start();\n\n        serverThread.join();\n        clientThread.join();\n\n        assertEquals(testMessage, receivedMessage[0]);\n    }\n}\n\n```"
  },
  {
    "Task_id": 539,
    "Instruction": "Task Description: Create a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections.\n\nClass Description: The ConnectionManipulationProxyServer class implements a TCP proxy server that listens on a local port, accepts client connections, and forwards traffic to a specified remote server. It provides thread-safe control over the proxy operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port number the proxy listens on\n- host: [String] - The hostname or IP address of the remote server\n- remotePort: [int] - The port number of the remote server\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization object for thread-safe control\n- enableProxy: [boolean] - Flag indicating whether proxy is enabled\n- running: [boolean] - Flag indicating whether proxy thread should continue running\n- client: [Socket] - Socket for client connection\n- server: [Socket] - Socket for server connection\n- serverSocket: [ServerSocket] - Server socket for accepting client connections\n\nMethods:\n- ConnectionManipulationProxyServer(String host, int remotePort, int localPort) -> [void] - Constructor that initializes the proxy server with target host and ports\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread implementation that handles connection forwarding\n- getLocalPort() -> [int] - Returns the local port number the proxy is listening on",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    Socket client = null, server = null;\n    ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            boolean canIrun = true;\n            \n            while (running) {\n                synchronized (enableLock) {\n                    canIrun = enableProxy;\n                }\n                \n                while (canIrun) {\n                    synchronized (enableLock) {\n                        canIrun = enableProxy;\n                        if (!enableProxy) {\n                            break;\n                        }\n                    }\n                    \n                    if (serverSocket == null || serverSocket.isClosed()) {\n                        serverSocket = new ServerSocket(localPort);\n                        localPort = serverSocket.getLocalPort();\n                    }\n                    \n                    log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    \n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private volatile boolean running = false;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                proxyThread = new Thread(this);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                enableProxy = false;\n                running = false;\n                killOpenSockets();\n            }\n        }\n    }\n\n    private synchronized void killOpenSockets() {\n        try {\n            if (client != null) {\n                client.close();\n                client = null;\n            }\n        } catch (IOException e) {\n            // Handle or log exception\n        }\n        try {\n            if (server != null) {\n                server.close();\n                server = null;\n            }\n        } catch (IOException e) {\n            // Handle or log exception\n        }\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n                serverSocket = null;\n            }\n        } catch (IOException e) {\n            // Handle or log exception\n        }\n    }\n\n    @Override\n    public void run() {\n        running = true;\n        try {\n            serverSocket = new ServerSocket(localPort);\n        } catch (IOException e) {\n            // Handle or log exception\n            return;\n        }\n\n        while (running) {\n            try {\n                client = serverSocket.accept();\n                if (!enableProxy) {\n                    client.close();\n                    continue;\n                }\n                server = new Socket(host, remotePort);\n\n                // Implement traffic forwarding between client and server here\n                // Example using separate threads for each direction:\n                Thread clientToServer = new Thread(new ClientToServer(client, server));\n                Thread serverToClient = new Thread(new ServerToClient(server, client));\n                clientToServer.start();\n                serverToClient.start();\n\n            } catch (SocketException se) {\n                if (!running) {\n                    // Expected exception due to socket closing\n                } else {\n                    // Handle or log unexpected SocketException\n                }\n            } catch (IOException e) {\n                // Handle or log exception\n            }\n        }\n    }\n\n\n    public int getLocalPort() {\n        return localPort;\n    }\n\n    private static class ClientToServer implements Runnable {\n        private final Socket client;\n        private final Socket server;\n\n        public ClientToServer(Socket client, Socket server) {\n            this.client = client;\n            this.server = server;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = client.getInputStream().read(buffer)) != -1) {\n                    server.getOutputStream().write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                // Handle or log exception\n            }\n        }\n    }\n\n    private static class ServerToClient implements Runnable {\n        private final Socket server;\n        private final Socket client;\n\n        public ServerToClient(Socket server, Socket client) {\n            this.server = server;\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = server.getInputStream().read(buffer)) != -1) {\n                    client.getOutputStream().write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                // Handle or log exception\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class HttpUrlSource {\n\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() throws IOException {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws IOException {\n        close();\n        connection = openConnection(offset, -1);\n        int responseCode = connection.getResponseCode();\n        sourceInfo.length = readSourceAvailableBytes(connection, offset, responseCode);\n\n        if (responseCode >= 200 && responseCode <= 299) {\n            inputStream = connection.getInputStream();\n        } else if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP) {\n            String location = connection.getHeaderField(\"Location\");\n            sourceInfo = new SourceInfo(location, sourceInfo.length, sourceInfo.mime);\n            open(offset);\n        } else {\n            throw new IOException(\"HTTP error \" + responseCode);\n        }\n\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.disconnect();\n            connection = null;\n        }\n        inputStream = null;\n    }\n\n    public int read(byte[] buffer) throws IOException {\n        if (inputStream == null) {\n            return -1;\n        }\n        return inputStream.read(buffer);\n    }\n\n    public String getMime() throws IOException {\n        if (sourceInfo == null) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo == null ? null : sourceInfo.url;\n    }\n\n    private void fetchContentInfo() throws IOException {\n        sourceInfo = sourceInfoStorage.get(sourceInfo.url);\n        if (sourceInfo == null) {\n            HttpURLConnection connection = openConnection(0, 5000);\n            int responseCode = connection.getResponseCode();\n            long length = readSourceAvailableBytes(connection, 0, responseCode);\n            String mime = connection.getContentType();\n            sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n            connection.disconnect();\n        }\n    }\n\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(sourceInfo.url).openConnection();\n        if (offset > 0) {\n            connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n        }\n        injectCustomHeaders(connection, sourceInfo.url);\n        connection.connect();\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> headers = headerInjector.getHeaders(url);\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        long contentLength = getContentLength(connection);\n        if ((responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_PARTIAL) && contentLength > 0) {\n            return responseCode == HttpURLConnection.HTTP_PARTIAL ? contentLength : offset + contentLength;\n        }\n        return contentLength;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        return contentLengthHeader != null ? Long.parseLong(contentLengthHeader) : -1;\n    }\n\n\n    static class SourceInfo {\n        String url;\n        long length;\n        String mime;\n\n        public SourceInfo(String url, long length, String mime) {\n            this.url = url;\n            this.length = length;\n            this.mime = mime;\n        }\n    }\n\n    interface SourceInfoStorage {\n        HttpUrlSource.SourceInfo get(String url);\n        void put(String url, HttpUrlSource.SourceInfo sourceInfo);\n    }\n\n    interface HeaderInjector {\n        Map<String, String> getHeaders(String url);\n    }\n}\n```"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private volatile boolean running = false;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                proxyThread = new Thread(this);\n                proxyThread.start();\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                enableProxy = false;\n                running = false;\n                killOpenSockets();\n            }\n        }\n    }\n\n    private synchronized void killOpenSockets() {\n        try {\n            if (serverSocket != null) serverSocket.close();\n            if (client != null) client.close();\n            if (server != null) server.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            serverSocket = null;\n            client = null;\n            server = null;\n        }\n    }\n\n    @Override\n    public void run() {\n        running = true;\n        try {\n            serverSocket = new ServerSocket(localPort);\n        } catch (IOException e) {\n            e.printStackTrace();\n            running = false;\n            return;\n        }\n\n        while (running) {\n            try {\n                client = serverSocket.accept();\n                if (!enableProxy) {\n                    client.close();\n                    continue;\n                }\n                server = new Socket(host, remotePort);\n\n                Thread clientToServer = new Thread(() -> forwardData(client, server));\n                clientToServer.start();\n\n                Thread serverToClient = new Thread(() -> forwardData(server, client));\n                serverToClient.start();\n\n                clientToServer.join();\n                serverToClient.join();\n\n            } catch (IOException | InterruptedException e) {\n                if (running) e.printStackTrace(); // Only print if not intentionally stopped\n            } finally {\n                killOpenSockets();\n            }\n        }\n    }\n\n    private void forwardData(Socket inputSocket, Socket outputSocket) {\n        try (InputStream inputStream = inputSocket.getInputStream();\n             OutputStream outputStream = outputSocket.getOutputStream()) {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                if (!running || !enableProxy) break; // Check for stop signal\n                outputStream.write(buffer, 0, bytesRead);\n                outputStream.flush();\n            }\n        } catch (IOException e) {\n            if (running) e.printStackTrace(); // Only print if not intentionally stopped\n        }\n    }\n\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}\n"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\nclass TcpServer extends Thread {\n\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    interface IAppFrame {\n        String[] getWindowTitles();\n        void activateWindow(String title);\n        void openFile(String filePath);\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n\n    public static boolean checkExistInstance(int port) {\n        return ask(\"localhost\", \"ping\", port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try (Socket socket = new Socket(host, port);\n             OutputStream out = socket.getOutputStream();\n             InputStream in = socket.getInputStream()) {\n            out.write(cmd.getBytes(StandardCharsets.UTF_8));\n            return in.read() == 1;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept();\n                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream(), StandardCharsets.UTF_8));\n                     OutputStream out = clientSocket.getOutputStream()) {\n\n                    String command = in.readLine();\n\n                    if (command == null) continue;\n\n                    if (\"ping\".equals(command)) {\n                        out.write(1);\n                    } else if (\"getTitles\".equals(command)) {\n                        String[] titles = frame.getWindowTitles();\n                        String response = String.join(\"\\n\", titles);\n                        out.write(response.getBytes(StandardCharsets.UTF_8));\n                    } else if (command.startsWith(\"activate:\")) {\n                        String title = command.substring(\"activate:\".length());\n                        frame.activateWindow(title);\n                        out.write(\"Activated\".getBytes(StandardCharsets.UTF_8));\n                    } else if (\"openFile\".equals(command) && file != null) {\n                        frame.openFile(file);\n                        out.write(\"File opened\".getBytes(StandardCharsets.UTF_8));\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\npublic class JavaHttpUtility {\n\n    public static final int CONNECT_TIMEOUT = 10000;\n    public static final int READ_TIMEOUT = 10000;\n\n    public static Proxy getProxy() {\n        System.setProperty(\"java.net.useSystemProxies\", \"true\");\n        return ProxySelector.getDefault().select(new URI(\"http://example.com/\")).get(0);\n    }\n\n\n    public static String doPost(String urlAddress, Map<String, String> param) throws IOException {\n        URL url = new URL(urlAddress);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(getProxy());\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoOutput(true);\n        urlConnection.setConnectTimeout(CONNECT_TIMEOUT);\n        urlConnection.setReadTimeout(READ_TIMEOUT);\n\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry<String, String> entry : param.entrySet()) {\n            if (postData.length() != 0) postData.append('&');\n            postData.append(URLEncoder.encode(entry.getKey(), \"UTF-8\"));\n            postData.append('=');\n            postData.append(URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n        }\n\n        try (DataOutputStream wr = new DataOutputStream(urlConnection.getOutputStream())) {\n            wr.writeBytes(postData.toString());\n            wr.flush();\n        }\n        return handleResponse(urlConnection);\n    }\n\n    public static String handleResponse(HttpURLConnection httpURLConnection) throws IOException {\n        int responseCode = httpURLConnection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return readResult(httpURLConnection);\n        } else {\n            return handleError(httpURLConnection);\n        }\n    }\n\n    public static String readResult(HttpURLConnection urlConnection) throws IOException {\n        StringBuilder result = new StringBuilder();\n        try (InputStream inputStream = urlConnection.getInputStream()) {\n            String encoding = urlConnection.getContentEncoding();\n            InputStream is = encoding != null && encoding.equalsIgnoreCase(\"gzip\") ? new GZIPInputStream(inputStream) : inputStream;\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n            }\n        }\n        return result.toString();\n    }\n\n    public static String handleError(HttpURLConnection urlConnection) throws IOException {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(urlConnection.getErrorStream()))) {\n            StringBuilder error = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                error.append(line);\n            }\n            throw new IOException(\"HTTP error code : \" + urlConnection.getResponseCode() + \" \" + urlConnection.getResponseMessage() + \"\\n\" + error);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n    public String uploadMedia(String type, String mediaFileUrl) throws IOException {\n        String accessToken = wechatAccessTokenUtil.getToken();\n        String url = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n\n        try {\n            byte[] fileBytes = Files.readAllBytes(Paths.get(new URL(mediaFileUrl).toURI()));\n            String contentType = Files.probeContentType(Paths.get(new URL(mediaFileUrl).toURI()));\n            String fileExt = judgeType(contentType);\n\n            MultipartFile multipartFile = new MultipartFileMock(fileBytes, \"file\" + fileExt, contentType, fileBytes.length);\n\n            // Assuming you have a suitable HTTP client library (e.g., Apache HttpClient, OkHttp)\n            // Replace this with your actual HTTP request logic\n            String response = HttpClientUtil.postMultipart(url, multipartFile);\n\n            // Parse JSON response to extract media_id\n            // ... (Implementation for parsing JSON response)\n\n            return \"media_id_from_response\"; // Replace with actual extracted media_id\n\n        } catch (Exception e) {\n            throw new IOException(\"Error uploading media: \" + e.getMessage(), e);\n        }\n    }\n\n\n    private String judgeType(String contentType) {\n        if (contentType.startsWith(\"image/jpeg\") || contentType.startsWith(\"image/jpg\")) {\n            return \".jpg\";\n        } else if (contentType.startsWith(\"image/png\")) {\n            return \".png\";\n        } else if (contentType.startsWith(\"image/gif\")) {\n            return \".gif\";\n        } else if (contentType.startsWith(\"video/mp4\")) {\n            return \".mp4\";\n        } else {\n            throw new IllegalArgumentException(\"Unsupported media type: \" + contentType);\n        }\n    }\n\n    // Mock MultipartFile implementation for demonstration\n    private static class MultipartFileMock implements MultipartFile {\n        // ... (Implementation of MultipartFile interface methods)\n    }\n\n    // Placeholder HttpClientUtil class\n    private static class HttpClientUtil {\n        public static String postMultipart(String url, MultipartFile file) {\n            // Placeholder implementation - replace with actual HTTP client logic\n            return \"mock_response\";\n        }\n    }\n\n}\n```"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SocketClient {\n\n    private final SSLContext clientSslContext;\n    private final InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory().createSocket();\n        sslSocket.connect(address);\n\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(sslSocket.getOutputStream()));\n        out.write(\"GET / HTTP/1.1\\r\\n\");\n        out.write(\"Host: \" + address.getHostName() + \":\" + address.getPort() + \"\\r\\n\");\n        out.write(\"Connection: close\\r\\n\");\n        out.write(\"\\r\\n\");\n        out.flush();\n\n        readResponse(sslSocket);\n\n        sslSocket.close();\n    }\n\n\n    private String readLine(InputStream is) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n        return reader.readLine();\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream input = sslSocket.getInputStream();\n        String line;\n        Map<String, String> headers = new HashMap<>();\n\n        // Read and parse headers\n        while (!(line = readLine(input)).isEmpty()) {\n            String[] parts = line.split(\":\", 2);\n            if (parts.length == 2) {\n                headers.put(parts[0].trim(), parts[1].trim());\n            }\n        }\n\n\n        // Read and process the response body\n        int contentLength = -1;\n        if (headers.containsKey(\"Content-Length\")) {\n            contentLength = Integer.parseInt(headers.get(\"Content-Length\"));\n        }\n\n\n        if (contentLength > 0) {\n            char[] buffer = new char[contentLength];\n            int charsRead = new InputStreamReader(input).read(buffer);\n            String body = new String(buffer, 0, charsRead);\n            System.out.print(body);\n        } else { // Handle chunked encoding or other cases if needed\n            while ((line = readLine(input)) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.Network;\nimport android.net.ProxyInfo;\nimport android.net.Uri;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport android.os.Handler;\n\n\npublic class RouterSocketClient {\n\n    private static final String TAG = \"RouterSocketClient\";\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20 * 1000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5 * 1000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20 * 1000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler = new Handler();\n\n    private Socket mSocket;\n    private Thread mThread;\n\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        mContext = context;\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    }\n\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n\n        Socket socket = connectSocketNoProxy(host, port);\n        return socket;\n    }\n\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        return socket;\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(String host, int port,\n                                                                SocketAddress proxyAddress) throws IOException {\n        Socket proxySocket = new Socket();\n        proxySocket.connect(proxyAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n\n        return proxySocket;\n    }\n\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) {\n        try {\n            socket.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n        } catch (IllegalArgumentException e) {\n        }\n    }\n\n\n    private static void tryEnableSessionTickets(SSLSocket socket) {\n        try {\n\n        } catch (Throwable e) {\n\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javax.swing.*;\nimport org.apache.commons.net.smtp.*;\n\nclass SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n\n    public SendMailJob(ProgressDialog progressDialog, JFrame mainFrame, FileSet fileset, String mailServer, String fromAddress, String recipientString, String mailSubject, String mailBody) {\n        this.mailServer = mailServer;\n        this.fromAddress = fromAddress;\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody;\n        this.boundary = \"==\" + new Random().nextInt();\n        this.errorDialogTitle = \"SMTP Error\";\n    }\n\n    public void openConnection() throws IOException {\n        socket = new Socket(mailServer, 25);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        out = socket.getOutputStream();\n        readWriteLine(null);\n        connectedToMailServer = true;\n    }\n\n    public void sendBody() throws IOException {\n        List<String> recipients = new ArrayList<>();\n        String remainingRecipients = splitRecipientString(recipientString, recipients);\n\n        readWriteLine(\"HELO \" + InetAddress.getLocalHost().getHostName());\n        readWriteLine(\"MAIL FROM: <\" + fromAddress + \">\");\n        for (String recipient : recipients) {\n            readWriteLine(\"RCPT TO: <\" + recipient + \">\");\n        }\n        if (remainingRecipients != null) {\n            readWriteLine(\"RCPT TO: <\" + remainingRecipients + \">\");\n        }\n        writeLine(\"DATA\");\n        readWriteLine(null);\n\n        writeLine(\"From: \" + fromAddress);\n        for (String recipient : recipients) {\n            writeLine(\"To: \" + recipient);\n        }\n        if (remainingRecipients != null) {\n            writeLine(\"To: \" + remainingRecipients);\n        }\n        writeLine(\"Subject: \" + mailSubject);\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\");\n        writeLine(\"--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"us-ascii\\\"\");\n        writeLine(\"Content-Transfer-Encoding: 7bit\");\n        writeLine(\"\");\n        writeLine(mailBody);\n    }\n\n    public void sendAttachment(AbstractFile file) throws IOException {\n        writeLine(\"--\" + boundary);\n        writeLine(\"Content-Type: application/octet-stream; name=\\\"\" + file.getName() + \"\\\"\");\n        writeLine(\"Content-Transfer-Encoding: base64\");\n        writeLine(\"Content-Disposition: attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n        writeLine(\"\");\n        out64 = new Base64OutputStream(out, true);\n        FileInputStream fis = new FileInputStream(file);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            out64.write(buffer, 0, bytesRead);\n        }\n        out64.flush();\n        fis.close();\n        writeLine(\"\");\n    }\n\n    public void closeConnection() throws IOException {\n        if (connectedToMailServer) {\n            writeLine(\"--\" + boundary + \"--\");\n            writeLine(\".\");\n            readWriteLine(null);\n            readWriteLine(\"QUIT\");\n            out.close();\n            in.close();\n            socket.close();\n            connectedToMailServer = false;\n        }\n    }\n\n    private void readWriteLine(String cmd) throws IOException {\n        if (cmd != null) {\n            out.write((cmd + \"\\r\\n\").getBytes());\n            out.flush();\n        }\n        String response = in.readLine();\n        if (!response.startsWith(\"2\") && !response.startsWith(\"3\")) {\n            throw new IOException(\"SMTP error: \" + response);\n        }\n    }\n\n    private void writeLine(String line) throws IOException {\n        out.write((line + \"\\r\\n\").getBytes());\n    }\n\n    private String splitRecipientString(String recipientString, List<String> recipients) {\n        StringTokenizer tokenizer = new StringTokenizer(recipientString, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            recipients.add(tokenizer.nextToken().trim());\n        }\n        return null;\n    }\n\n\n    // Dummy AbstractFile class for compilation\n    static class AbstractFile extends File {\n        public AbstractFile(String pathname) {\n            super(pathname);\n        }\n    }\n\n    // Dummy FileSet class for compilation\n    static class FileSet {\n    }\n\n    // Dummy ProgressDialog class for compilation\n    static class ProgressDialog extends JDialog {\n        public ProgressDialog(JFrame parent, String title, boolean modal) {\n            super(parent, title, modal);\n        }\n    }\n\n    // Dummy MainFrame class for compilation\n    static class MainFrame extends JFrame {\n    }\n}\n```"
  },
  {
    "Task_id": 565,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP connection to a database server using socket programming, including authentication and basic query functionality.\n\nClass Description: The UrlConnection class provides functionality to connect to a database server, authenticate, execute queries, and manage the connection lifecycle. It handles MySQL protocol communication including handshake, authentication, and basic command execution.\n\nAttributes:\n- host: String - The hostname or IP address of the database server\n- port: int - The port number of the database server\n- user: String - The username for authentication\n- password: String - The password for authentication\n- database: String - The name of the database to connect to\n- socket: Socket - The TCP socket connection to the server\n- in: InputStream - Input stream for reading data from the server\n- out: OutputStream - Output stream for writing data to the server\n- charsetIndex: int - The character set index used for communication\n- isClosed: AtomicBoolean - Flag indicating whether the connection is closed\n\nMethods:\n- UrlConnection(String, int, String, String, String) -> void - Constructor that initializes connection parameters\n- connect(int) -> void - Establishes a connection to the server with specified timeout\n- getServerList() -> List<CobarNode> - Executes a query to retrieve server list information\n- close() -> void - Closes the connection and releases resources\n- getRowList(int) -> List<CobarNode> - Helper method to process query result rows\n- auth411(HandshakePacket) -> BinaryPacket - Handles MySQL 4.1 authentication protocol\n- auth323(byte, byte[]) -> void - Handles MySQL 3.23 authentication protocol\n- getClientFlags() -> long - Returns client capability flags for MySQL protocol",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed;\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(int timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n\n        BinaryPacket initPacket = new BinaryPacket();\n        initPacket.read(in);\n        HandshakePacket hsp = new HandshakePacket();\n        hsp.read(initPacket);\n\n        this.charsetIndex = hsp.serverCharsetIndex & 0xff;\n\n        BinaryPacket bin = null;\n        try {\n            bin = auth411(hsp);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        case EOFPacket.FIELD_COUNT:\n            auth323(bin.packetId, hsp.seed);\n            break;\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        CommandPacket cmd = new CommandPacket();\n        cmd.packetId = 0;\n        cmd.command = 3;\n        cmd.arg = \"SHOW COBAR_CLUSTER\".getBytes();\n        cmd.write(out);\n        out.flush();\n\n        int fieldCount = 0;\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case ErrorPacket.FIELD_COUNT: {\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        }\n        default:\n            ResultSetHeaderPacket rsh = new ResultSetHeaderPacket();\n            rsh.read(bin);\n            fieldCount = rsh.fieldCount;\n        }\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return getRowList(fieldCount);\n            }\n            default:\n                continue;\n            }\n        }\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                }\n            }\n        }\n    }\n\n    private List<CobarNode> getRowList(int fieldCount) throws IOException {\n        List<CobarNode> list = new LinkedList<CobarNode>();\n        BinaryPacket bin = null;\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return list;\n            }\n            default:\n                RowDataPacket row = new RowDataPacket(fieldCount);\n                row.read(bin);\n                String host = new String(row.fieldValues.get(0));\n                int weight = Integer.parseInt(new String(row.fieldValues.get(1)));\n                list.add(new CobarNode(host, weight));\n            }\n        }\n    }\n\n    private BinaryPacket auth411(HandshakePacket hsp) throws IOException, NoSuchAlgorithmException {\n        AuthPacket ap = new AuthPacket();\n        ap.packetId = 1;\n        ap.clientFlags = getClientFlags();\n        ap.maxPacketSize = 1024 * 1024 * 16;\n        ap.charsetIndex = charsetIndex;\n        ap.user = user;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            byte[] password = passwd.getBytes();\n            byte[] seed = hsp.seed;\n            byte[] restOfScramble = hsp.restOfScrambleBuff;\n            byte[] authSeed = new byte[seed.length + restOfScramble.length];\n            System.arraycopy(seed, 0, authSeed, 0, seed.length);\n            System.arraycopy(restOfScramble, 0, authSeed, seed.length, restOfScramble.length);\n            ap.password = SecurityUtil.scramble411(password, authSeed);\n        }\n        ap.database = database;\n        ap.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    private void auth323(byte packetId, byte[] seed) throws IOException {\n        Reply323Packet r323 = new Reply323Packet();\n        r323.packetId = ++packetId;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            r323.seed = SecurityUtil.scramble323(passwd, new String(seed)).getBytes();\n        }\n        r323.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    private static long getClientFlags() {\n        int flag = 0;\n        flag |= Capabilities.CLIENT_LONG_PASSWORD;\n        flag |= Capabilities.CLIENT_FOUND_ROWS;\n        flag |= Capabilities.CLIENT_LONG_FLAG;\n        flag |= Capabilities.CLIENT_CONNECT_WITH_DB;\n        flag |= Capabilities.CLIENT_ODBC;\n        flag |= Capabilities.CLIENT_IGNORE_SPACE;\n        flag |= Capabilities.CLIENT_PROTOCOL_41;\n        flag |= Capabilities.CLIENT_INTERACTIVE;\n        flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;\n        flag |= Capabilities.CLIENT_TRANSACTIONS;\n        flag |= Capabilities.CLIENT_SECURE_CONNECTION;\n        return flag;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed = new AtomicBoolean(false);\n\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n    }\n\n    public void connect(int timeout) throws IOException {\n        socket = new Socket(host, port);\n        socket.setSoTimeout(timeout);\n        in = socket.getInputStream();\n        out = socket.getOutputStream();\n    }\n\n\n    public List<CobarNode> getServerList() throws IOException {\n        return new ArrayList<>(); // Placeholder - Actual implementation requires MySQL protocol interaction\n    }\n\n\n    public void close() throws IOException {\n        if (isClosed.compareAndSet(false, true)) {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n\n\n    private List<CobarNode> getRowList(int fieldCount) {\n        return new ArrayList<>(); // Placeholder\n    }\n\n    private BinaryPacket auth411(HandshakePacket hs) throws IOException {\n        return new BinaryPacket(); // Placeholder\n    }\n\n    private void auth323(byte packetId, byte[] seed) throws IOException {\n        // Placeholder\n    }\n\n    private long getClientFlags() {\n        return 0; // Placeholder\n    }\n\n\n    private static class CobarNode {\n        // Placeholder class definition\n    }\n\n    private static class HandshakePacket {\n        // Placeholder class definition\n    }\n\n    private static class BinaryPacket {\n        // Placeholder class definition\n    }\n}\n"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import android.net.TrafficStats;\nimport com.facebook.stetho.inspector.network.DefaultResponseHandler;\nimport com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.RequestBodyHelper;\n\nimport java.io.*;\nimport java.net.Socket;\n\npublic class IRCClientConnection implements Closeable {\n\n    private final StethoReporter mReporter;\n    private Socket mSocket;\n    private BufferedReader mInput;\n    private BufferedWriter mOutput;\n\n    private IRCClientConnection(Socket socket, StethoReporter reporter) throws IOException {\n        mSocket = socket;\n        mReporter = reporter;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n    }\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        TrafficStats.setThreadStatsTag(0);\n        Socket socket = new Socket(host, port);\n        StethoReporter reporter = new StethoReporter();\n        reporter.reportRequestWillBeSent(socket);\n        return new IRCClientConnection(socket, reporter);\n    }\n\n    public String read() throws IOException {\n        String line = mInput.readLine();\n        if (line != null && maybeHandleIncomingMessage(line)) {\n            return read();\n        }\n        return line;\n    }\n\n    public void send(String message) throws IOException {\n        mOutput.write(message + \"\\r\\n\");\n        mOutput.flush();\n    }\n\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(5));\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mInput != null) mInput.close();\n        if (mOutput != null) mOutput.close();\n        if (mSocket != null) mSocket.close();\n        mReporter.reportResponseReceived(mSocket);\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mEventReporter = NetworkEventReporterImpl.get();\n        private final RequestBodyHelper mRequestBodyHelper = new RequestBodyHelper();\n\n\n        void reportRequestWillBeSent(Socket socket) {\n            mEventReporter.requestWillBeSent(new StethoNetworkEvent(socket));\n        }\n\n        void reportResponseReceived(Socket socket) {\n            mEventReporter.responseReceived(new StethoNetworkEvent(socket), new DefaultResponseHandler(mRequestBodyHelper, null));\n        }\n    }\n\n    private static class StethoNetworkEvent extends com.facebook.stetho.inspector.network.NetworkEvent {\n        private final Socket mSocket;\n        public StethoNetworkEvent(Socket socket) {\n            mSocket = socket;\n        }\n        @Override\n        public String requestId() {\n            return String.valueOf(mSocket.hashCode());\n        }\n\n        @Override\n        public String friendlyName() {\n            return \"IRC Connection\";\n        }\n    }\n}\n"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n        outputStream.flush();\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            destination.write(buffer, 0, bytesRead);\n            if (bufferContainsEOT(buffer, bytesRead)) {\n                break;\n            }\n        }\n        destination.flush();\n    }\n\n\n    private boolean bufferContainsEOT(byte[] buffer, int bytesRead) {\n        for (int i = 0; i < bytesRead; i++) {\n            if (buffer[i] == 0x04) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) inputStream.close();\n        } catch (IOException ignored) {}\n        try {\n            if (outputStream != null) outputStream.close();\n        } catch (IOException ignored) {}\n        try {\n            if (socket != null) socket.close();\n        } catch (IOException ignored) {}\n    }\n}\n"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class EurekaTcpClient {\n\n    private static final String VIP_ADDRESS = \"sampleservice.mydomain.net\";\n    private static final int READ_TIMEOUT_MS = 5000;\n\n    public void connectAndSend(EurekaClient eurekaClient) {\n        InstanceInfo instanceInfo = eurekaClient.getNextServerFromEureka(VIP_ADDRESS, false);\n        if (instanceInfo == null) {\n            System.err.println(\"Service not found in Eureka: \" + VIP_ADDRESS);\n            return;\n        }\n\n        String hostname = instanceInfo.getHostName();\n        int port = instanceInfo.getPort();\n\n        try (Socket clientSocket = new Socket(hostname, port)) {\n            clientSocket.setSoTimeout(READ_TIMEOUT_MS);\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n\n            String request = \"Request from Java client at \" + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n            out.println(request);\n\n            String response;\n            while ((response = in.readLine()) != null) {\n                System.out.println(\"Server response: \" + response);\n            }\n\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + hostname);\n        } catch (IOException e) {\n            System.err.println(\"IO error: \" + e.getMessage());\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket client = null;\n        PrintWriter out = null;\n        String response = null;\n\n        try {\n            client = new Socket(host, port);\n            out = new PrintWriter(client.getOutputStream(), true);\n            out.print(command + \"\\r\\n\");\n            out.flush();\n            response = response(client);\n\n        } catch (IOException e) {\n            // Handle exceptions as needed\n        } finally {\n            cleanup(out);\n            cleanup(client);\n        }\n        return response;\n    }\n\n\n    private String response(Socket client) {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader in = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            String line;\n            while ((line = in.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            // Handle exceptions as needed\n        } finally {\n            cleanup(in);\n        }\n        return sb.toString().trim();\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.websocket.Session;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private static final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024;\n    private static final int READ_BUFFER_SIZE = 5 * 1024;\n\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final Session session;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        try {\n            int localPort = scrcpyLocalThread.getPort();\n            iDevice.forwardPort(localPort, scrcpyLocalThread.getScrcpyPort());\n\n            try (Socket socket = new Socket(\"localhost\", localPort);\n                 InputStream inputStream = socket.getInputStream()) {\n\n                if (session != null && session.isOpen()) {\n                    String deviceScreenDimension = iDevice.getDeviceScreenDimension();\n                    session.getAsyncRemote().sendText(deviceScreenDimension);\n                }\n\n                byte[] buffer = new byte[BUFFER_SIZE];\n                int offset = 0;\n                byte[] readBuffer = new byte[READ_BUFFER_SIZE];\n                while (!isInterrupted()) {\n                    int bytesRead = inputStream.read(readBuffer);\n                    if (bytesRead == -1) {\n                        break;\n                    }\n                    System.arraycopy(readBuffer, 0, buffer, offset, bytesRead);\n                    offset += bytesRead;\n\n                    while (true) {\n                        int nalStart = findNalStart(buffer, 0, offset);\n                        if (nalStart == -1) {\n                            break;\n                        }\n                        int nalEnd = findNalStart(buffer, nalStart + 4, offset);\n                        if (nalEnd == -1) {\n                            break;\n                        }\n\n                        byte[] nalUnit = new byte[nalEnd - nalStart];\n                        System.arraycopy(buffer, nalStart, nalUnit, 0, nalUnit.length);\n                        dataQueue.offer(nalUnit, 1, TimeUnit.SECONDS);\n\n                        int remaining = offset - nalEnd;\n                        System.arraycopy(buffer, nalEnd, buffer, 0, remaining);\n                        offset = remaining;\n                    }\n\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            log.error(\"Error in ScrcpyInputSocketThread\", e);\n        } finally {\n            try {\n                iDevice.removeForwardPort(scrcpyLocalThread.getPort());\n            } catch (Exception e) {\n                log.error(\"Error removing port forwarding\", e);\n            }\n            if (scrcpyLocalThread != null) {\n                scrcpyLocalThread.interrupt();\n            }\n        }\n    }\n\n    private int findNalStart(byte[] buffer, int start, int end) {\n        for (int i = start; i < end - 3; i++) {\n            if (buffer[i] == 0 && buffer[i + 1] == 0 && buffer[i + 2] == 0 && buffer[i + 3] == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n\n    interface IDevice {\n        void forwardPort(int localPort, int remotePort) throws IOException;\n        void removeForwardPort(int localPort) throws IOException;\n        String getDeviceScreenDimension();\n    }\n\n    static class ScrcpyLocalThread extends Thread {\n        private final int port;\n        private final int scrcpyPort;\n\n        public ScrcpyLocalThread(int port, int scrcpyPort) {\n            this.port = port;\n            this.scrcpyPort = scrcpyPort;\n        }\n\n        public int getPort() {\n            return port;\n        }\n\n        public int getScrcpyPort() {\n            return scrcpyPort;\n        }\n    }\n\n    static class AndroidTestTaskBootThread extends Thread {\n    }\n}\n```"
  },
  {
    "Task_id": 577,
    "Instruction": "Task Description: Implement a MySQL client channel class in Java that handles TCP socket communication with a MySQL server, including connection management, query execution, and packet handling.\n\nClass Description: MySQLChannel is a final class that provides a TCP-based communication channel to interact with a MySQL server. It manages socket connections, executes SQL queries, and handles MySQL protocol packets. The class includes connection configuration, buffer management, and proper resource cleanup.\n\nAttributes:\n- dsc: [DataSourceConfig] - Configuration object containing host, port and other connection parameters\n- socket: [Socket] - TCP socket connection to the MySQL server\n- in: [InputStream] - Buffered input stream for reading server responses\n- out: [OutputStream] - Buffered output stream for sending commands to server\n- isClosed: [AtomicBoolean] - Thread-safe flag indicating whether the channel is closed\n\nMethods:\n- connect(long timeout) -> [void] - Establishes a TCP connection to the MySQL server with specified timeout and configures socket parameters\n- execute(String statement) -> [BinaryPacket] - Executes a SQL query statement and returns the server response as a binary packet\n- receive() -> [BinaryPacket] - Reads and returns a binary packet from the server\n- close() -> [void] - Closes the connection by sending a QUIT command and releasing resources\n- BinaryPacket: [static class] - Represents a MySQL binary packet with data and packet ID\n- CommandPacket: [static class] - Represents a MySQL command packet with packet ID, command type, and arguments\n- MySQLPacket: [static class] - Contains MySQL protocol constants\n- QuitPacket: [static class] - Contains the QUIT command packet data",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic final class MySQLChannel {\n\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(long timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setTrafficClass(0x04 | 0x10);\n        socket.setPerformancePreferences(0, 2, 1);\n        socket.setReceiveBufferSize(16 * 1024);\n        socket.setSendBufferSize(8 * 1024);\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), 10 * 1000);\n\n        in = new BufferedInputStream(socket.getInputStream(), 16 * 1024);\n        out = new BufferedOutputStream(socket.getOutputStream(), 8 * 1024);\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket packet = new CommandPacket();\n        packet.packetId = 0;\n        packet.command = MySQLPacket.COM_QUERY;\n        packet.arg = statement.getBytes();\n\n        packet.write(out);\n        out.flush();\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n                // Log error if needed\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                    // Log error if needed\n                }\n            }\n        }\n    }\n\n    private static class BinaryPacket {\n        public byte[] data;\n        public int packetId;\n\n        public void read(InputStream in) throws IOException {\n            // Implementation of packet reading\n        }\n    }\n\n    private static class CommandPacket {\n        public int packetId;\n        public byte command;\n        public byte[] arg;\n\n        public void write(OutputStream out) throws IOException {\n            // Implementation of packet writing\n        }\n    }\n\n    private static class MySQLPacket {\n        public static final byte COM_QUERY = 0x03;\n    }\n\n    private static class QuitPacket {\n        public static final byte[] QUIT = new byte[]{0x01, 0x00, 0x00, 0x00, 0x01};\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nfinal class MySQLChannel {\n\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n    }\n\n    public void connect(long timeout) throws IOException {\n        socket = new Socket(dsc.getHost(), dsc.getPort());\n        socket.setSoTimeout((int) timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        out.write(new CommandPacket(1, MySQLPacket.COM_QUERY, statement.getBytes()).getBytes());\n        out.flush();\n        return receive();\n    }\n\n\n    public BinaryPacket receive() throws IOException {\n        int packetLength = readInt3(in);\n        int packetId = in.read();\n        byte[] data = new byte[packetLength];\n        in.read(data);\n        return new BinaryPacket(packetId, data);\n    }\n\n    private int readInt3(InputStream in) throws IOException {\n        int b1 = in.read();\n        int b2 = in.read();\n        int b3 = in.read();\n        return (b1 & 0xff) | ((b2 & 0xff) << 8) | ((b3 & 0xff) << 16);\n    }\n\n\n    public void close() throws IOException {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                out.write(QuitPacket.QUIT.getBytes());\n                out.flush();\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } finally {\n                    if (out != null) out.close();\n                }\n                if (socket != null) socket.close();\n            }\n        }\n    }\n\n\n    static class BinaryPacket {\n        int id;\n        byte[] data;\n\n        BinaryPacket(int id, byte[] data) {\n            this.id = id;\n            this.data = data;\n        }\n    }\n\n    static class CommandPacket {\n        byte[] bytes;\n\n        CommandPacket(int id, byte command, byte[] arg) {\n            bytes = new byte[4 + 1 + arg.length];\n            writeInt3(arg.length, bytes, 0);\n            bytes[3] = (byte) id;\n            bytes[4] = command;\n            System.arraycopy(arg, 0, bytes, 5, arg.length);\n        }\n\n        private void writeInt3(int value, byte[] dest, int offset) {\n            dest[offset] = (byte) (value & 0xff);\n            dest[offset + 1] = (byte) ((value >> 8) & 0xff);\n            dest[offset + 2] = (byte) ((value >> 16) & 0xff);\n        }\n\n        byte[] getBytes() {\n            return bytes;\n        }\n    }\n\n    static class MySQLPacket {\n        static final byte COM_QUERY = 3;\n    }\n\n    static class QuitPacket {\n        static final byte[] QUIT = new byte[]{1, 0, 0, 0, 1};\n    }\n\n\n    static class DataSourceConfig {\n        private String host;\n        private int port;\n\n        public DataSourceConfig(String host, int port) {\n            this.host = host;\n            this.port = port;\n        }\n\n\n        public String getHost() {\n            return host;\n        }\n\n        public int getPort() {\n            return port;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\nclass HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        OutputStream out = postSocket.getOutputStream();\n        String request = formatRequest(host, isKeepAlive);\n        out.write(request.getBytes());\n        InputStream in = postSocket.getInputStream();\n        HTTPResponse response = processResponse(in);\n\n        if (!isKeepAlive) {\n            postSocket.close();\n        }\n        return response;\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n\n\n    private String formatRequest(String host, boolean isKeepAlive) {\n\n        StringBuilder request = new StringBuilder();\n        request.append(\"POST / HTTP/1.1\\r\\n\");\n        request.append(\"Host: \").append(host).append(\"\\r\\n\");\n\n        if (isKeepAlive) {\n            request.append(\"Connection: keep-alive\\r\\n\");\n        } else {\n            request.append(\"Connection: close\\r\\n\");\n        }\n\n        request.append(\"Transfer-Encoding: chunked\\r\\n\");\n        request.append(\"\\r\\n\");\n\n        String body = \"Hello, server!\";\n        String chunkedBody = Integer.toHexString(body.length()) + \"\\r\\n\" + body + \"\\r\\n\";\n        chunkedBody += \"0\\r\\n\\r\\n\";\n\n        request.append(chunkedBody);\n        return request.toString();\n\n    }\n\n\n    private HTTPResponse processResponse(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        StringBuilder responseBuilder = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            responseBuilder.append(line).append(\"\\r\\n\");\n            if (line.isEmpty()) {\n                break;\n            }\n        }\n\n        StringBuilder bodyBuilder = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            bodyBuilder.append(line).append(\"\\r\\n\");\n        }\n\n        return new HTTPResponse(responseBuilder.toString(), bodyBuilder.toString());\n    }\n\n}\n\nclass HTTPPacket {\n\n}\n\nclass HTTPResponse {\n    String headers;\n    String body;\n\n    public HTTPResponse(String headers, String body) {\n        this.headers = headers;\n        this.body = body;\n    }\n}\n"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n\n            Thread receiverThread = new Thread(() -> {\n                try {\n                    String message;\n                    while ((message = mBufferedReader.readLine()) != null) {\n                        System.out.println(\"Server: \" + message);\n                    }\n                } catch (IOException e) {\n                    // Handle exception, e.g., print stack trace or log the error\n                    e.printStackTrace();\n                }\n            });\n            receiverThread.start();\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n            if (mClientSocket != null) {\n                mClientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\nenum HttpMethod {GET, POST, PUT, DELETE}\n\ninterface Callback {\n    void onResponse(HttpResponse result);\n    void onFailure(IOException e);\n}\n\npublic class Networker {\n\n    private static final Networker sInstance = new Networker();\n    private static final Executor sExecutor = Executors.newFixedThreadPool(4);\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    public static Networker get() {\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.execute(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest mRequest;\n        private final Callback mCallback;\n\n        HttpRequestTask(HttpRequest request, Callback callback) {\n            mRequest = request;\n            mCallback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                mCallback.onResponse(response);\n            } catch (IOException e) {\n                mCallback.onFailure(e);\n            }\n        }\n\n        private HttpResponse doFetch() throws IOException {\n            HttpURLConnection conn = configureAndConnectRequest();\n            requestDecompression(conn);\n            conn.connect();\n\n            int statusCode = conn.getResponseCode();\n            InputStream in = statusCode >= 400 ? conn.getErrorStream() : conn.getInputStream();\n            in = applyDecompressionIfApplicable(conn, in);\n\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            copy(in, out, new byte[4096]);\n            return new HttpResponse(statusCode, out.toByteArray());\n        }\n\n\n        private HttpURLConnection configureAndConnectRequest() throws IOException {\n            URL url = new URL(mRequest.url);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(mRequest.method.name());\n            conn.setReadTimeout(READ_TIMEOUT_MS);\n            conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n            if (mRequest.body != null) {\n                conn.setDoOutput(true);\n                OutputStream os = conn.getOutputStream();\n                os.write(mRequest.body);\n                os.close();\n            }\n            return conn;\n        }\n\n        private void requestDecompression(HttpURLConnection conn) {\n            conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        }\n\n        private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n            String encoding = conn.getContentEncoding();\n            if (GZIP_ENCODING.equals(encoding)) {\n                return new GZIPInputStream(in);\n            }\n            return in;\n        }\n\n        private void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n            int n;\n            while ((n = in.read(buf)) != -1) {\n                out.write(buf, 0, n);\n            }\n            in.close();\n            out.close();\n        }\n    }\n\n\n    public static class HttpRequest {\n        final String friendlyName;\n        final HttpMethod method;\n        final String url;\n        final byte[] body;\n\n        HttpRequest(Builder b) {\n            this.friendlyName = b.friendlyName;\n            this.method = b.method;\n            this.url = b.url;\n            this.body = b.body;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public static class Builder {\n            String friendlyName;\n            HttpMethod method;\n            String url;\n            byte[] body;\n\n            Builder() {}\n\n            public Builder friendlyName(String friendlyName) {\n                this.friendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method;\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        public final int statusCode;\n        public final byte[] body;\n\n        public HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport javax.net.SocketFactory;\n\npublic class QmpClient {\n    private static final String TAG = \"QmpClient\";\n    private final String requestCommandMode = \"{\\\"execute\\\":\\\"qmp_capabilities\\\"}\";\n    private boolean external = false;\n\n    public void setExternal(boolean value) {\n        external = value;\n    }\n\n    public String sendCommand(String command) {\n        try {\n            if (external) {\n                SocketFactory socketFactory = SocketFactory.getDefault();\n                Socket socket = socketFactory.createSocket(\"127.0.0.1\", 5555); // Example IP and port\n                return communicate(socket, command);\n            } else {\n                Process process = Runtime.getRuntime().exec(new String[]{\"qemu-system-x86_64\", \"-monitor\", \"unix:/tmp/qmp-socket,server,nowait\"}); // Example QEMU command\n                return communicate(new Socket(\"localhost\", 0), command); // Dummy socket, not used\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n\n    private String communicate(Socket socket, String command) throws IOException {\n        try (\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))\n        ) {\n            sendRequest(out, requestCommandMode);\n            tryGetResponse(in); // Consume initial response\n            sendRequest(out, command);\n            return getResponse(in);\n        }\n    }\n\n    private String tryGetResponse(BufferedReader in) throws IOException {\n        int retries = 3;\n        while (retries > 0) {\n            String response = in.readLine();\n            if (response != null) {\n                return response;\n            }\n            retries--;\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n    }\n\n    private String getResponse(BufferedReader in) throws IOException {\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            response.append(line);\n        }\n        return response.toString();\n    }\n}\n"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost;\n    private int proxyPort;\n    private String proxyUser;\n    private String proxyPass;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    public CustomSocketFactory() {}\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException {\n        Socket socket = createSocket();\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Socket socket = createSocket();\n        socket.bind(new InetSocketAddress(localHost, localPort));\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        Socket socket = createSocket();\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = createSocket();\n        socket.bind(new InetSocketAddress(localAddress, localPort));\n        socket.connect(new InetSocketAddress(address, port));\n        return socket;\n\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        if (proxyHost != null && proxyPort > 0) {\n            Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));\n            Socket socket = new Socket(proxy);\n            if (proxyType == Proxy.Type.HTTP) {\n                connectToProxy(socket);\n            }\n            return socket;\n        } else {\n            return new Socket();\n        }\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        OutputStream out = socket.getOutputStream();\n        String connectStr = \"CONNECT \" + socket.getInetAddress().getHostName() + \":\" + socket.getPort() + \" HTTP/1.1\\r\\n\";\n        if (proxyUser != null && proxyPass != null) {\n            connectStr += \"Proxy-Authorization: Basic \" + getBasicAuthStr() + \"\\r\\n\";\n        }\n        connectStr += \"\\r\\n\";\n        out.write(connectStr.getBytes());\n        out.flush();\n\n        InputStream in = socket.getInputStream();\n        String statusLine = readLine(in);\n        int responseCode = getResponseCode(statusLine);\n\n        if (responseCode != 200) {\n            throw new IOException(\"Proxy connection failed: \" + statusLine);\n        }\n\n        // Read remaining headers\n        while (!readLine(in).isEmpty()) {}\n    }\n\n\n    private String getBasicAuthStr() {\n        String auth = proxyUser + \":\" + proxyPass;\n        return Base64.getEncoder().encodeToString(auth.getBytes());\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        return reader.readLine();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        try {\n            return Integer.parseInt(statusLine.split(\" \")[1]);\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class UrlTemplateResource {\n\n    private URL url;\n    private String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) throws MalformedURLException {\n        this(new URL(path), characterEncoding);\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        if (characterEncoding != null) {\n            return new InputStreamReader(inputStream(), characterEncoding);\n        } else {\n            return new InputStreamReader(inputStream());\n        }\n    }\n\n    private InputStream inputStream() throws IOException {\n        URLConnection con = url.openConnection();\n        con.setUseCaches(false);\n        return con.getInputStream();\n    }\n\n    public boolean exists() {\n        try {\n            URLConnection con = url.openConnection();\n            con.setUseCaches(false);\n            con.getInputStream().close();\n            return true;\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "```java\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.io.IOException;\nimport java.net.Socket;\n\nimport static org.junit.Assert.fail;\n\n@RunWith(JUnit4.class)\npublic class ServletInputStreamEarlyCloseTest {\n\n    private static final String SERVLET_PATH = \"/earlyClose\";\n\n    @Test\n    public void testServletInputStreamEarlyClose() throws Exception {\n        DefaultServer server = new DefaultServer(EarlyCloseClientServlet.class, SERVLET_PATH);\n        try {\n            int port = server.getPort();\n            TestHttpClient client = new TestHttpClient(port);\n\n            Socket socket = new Socket(\"localhost\", port);\n            String request = \"POST \" + SERVLET_PATH + \" HTTP/1.1\\r\\n\" +\n                    \"Host: localhost:\" + port + \"\\r\\n\" +\n                    \"Content-Length: 1000000\\r\\n\" +\n                    \"Connection: close\\r\\n\" +\n                    \"\\r\\n\";\n            socket.getOutputStream().write(request.getBytes());\n            socket.close();\n\n            try {\n                client.connect(SERVLET_PATH, \"POST\");\n                fail(\"Expected IOException due to early client socket closure\");\n            } catch (IOException e) {\n                // Expected exception due to early closure\n            }\n\n        } finally {\n            server.stop();\n        }\n    }\n\n\n    public static class EarlyCloseClientServlet extends TestServlet {\n        @Override\n        protected void doPost(javax.servlet.http.HttpServletRequest req, javax.servlet.http.HttpServletResponse resp) throws javax.servlet.ServletException, IOException {\n            try {\n                byte[] buffer = new byte[1024];\n                while (req.getInputStream().read(buffer) != -1);\n                resp.setStatus(200);\n            } catch (IOException e) {\n                // Expected exception due to client closing the connection\n                resp.setStatus(500);\n            }\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 598,
    "Instruction": "Task Description: Create a Java class that implements a StatsD client using UDP protocol for sending metrics to a StatsD server. The class should handle metric batching and asynchronous sending to avoid blocking the main application thread.\n\nClass Description: The Statsd class is a singleton that provides asynchronous metric sending capability to a StatsD server via UDP. It uses a background thread to batch metrics and send them efficiently. The class handles connection setup, error cases, and metric aggregation.\n\nAttributes:\n- CHARSET: [Charset] - The character encoding used for sending metrics (US_ASCII)\n- e: [ExecutorService] - Single thread executor for asynchronous metric processing\n- qManager: [Implicit Queue Manager] - Manages the queue of metrics to be sent (implied by usage but not shown in attributes)\n\nMethods:\n- getInstance(): () -> [Statsd] - Returns the singleton instance of the StatsD client\n- <constructor>: () -> [Statsd] - Private constructor that initializes the background thread for metric processing\n- <background thread>: () -> [void] - Internal method that continuously processes metrics from the queue, batches them, and sends to the StatsD server via UDP\n\nNote: The actual queue management implementation (qManager) is not shown in the provided code but is implied by the usage of getQ() and drainTo() methods. The class handles UDP socket creation, packet preparation, and error cases for host resolution and socket operations.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.openjdk.btrace.core.BTraceRuntime;\nimport org.openjdk.btrace.core.SharedSettings;\n\npublic final class Statsd {\n  private static final Charset CHARSET = StandardCharsets.US_ASCII;\n  private final ExecutorService e = Executors.newSingleThreadExecutor(\n      r -> {\n        Thread t = new Thread(r, \"jStatsD Client Submitter\");\n        t.setDaemon(true);\n        return t;\n      });\n\n  @SuppressWarnings(\"FutureReturnValueIgnored\")\n  private Statsd() {\n    e.submit(\n        () -> {\n          DatagramSocket ds = null;\n          boolean entered = BTraceRuntime.enter();\n          try {\n            ds = new DatagramSocket();\n            DatagramPacket dp = new DatagramPacket(new byte[0], 0);\n            try {\n              dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));\n            } catch (UnknownHostException ex) {\n              System.err.println(\n                  \"[statsd] invalid host defined: \" + SharedSettings.GLOBAL.getStatsdHost());\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            } catch (SecurityException ex) {\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            }\n            dp.setPort(SharedSettings.GLOBAL.getStatsdPort());\n\n            while (true) {\n              Collection<String> msgs = new ArrayList<>();\n              msgs.add(qManager.getQ().take());\n              qManager.getQ().drainTo(msgs);\n\n              StringBuilder sb = new StringBuilder();\n              for (String m : msgs) {\n                if (sb.length() + m.length() < 511) {\n                  sb.append(m).append('\\n');\n                } else {\n                  dp.setData(sb.toString().getBytes(CHARSET));\n                  ds.send(dp);\n                  sb.setLength(0);\n                }\n              }\n              if (sb.length() > 0) {\n                dp.setData(sb.toString().getBytes(CHARSET));\n                ds.send(dp);\n              }\n            }\n          } catch (IOException | InterruptedException ex) {\n            ex.printStackTrace();\n          } finally {\n            if (entered) {\n              BTraceRuntime.leave();\n            }\n          }\n        });\n  }\n\n  public static Statsd getInstance() {\n    return Singleton.INSTANCE;\n  }\n\n  private static final class Singleton {\n    private static final Statsd INSTANCE = new Statsd();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\n\n\npublic class Statsd {\n\n    private static final Charset CHARSET = Charset.forName(\"US-ASCII\");\n    private static final Statsd INSTANCE = new Statsd();\n\n    private final ExecutorService e;\n    private final LinkedBlockingQueue<String> q = new LinkedBlockingQueue<>();\n    private DatagramChannel channel;\n\n    private Statsd() {\n        e = Executors.newSingleThreadExecutor();\n        e.execute(() -> {\n            try {\n                channel = DatagramChannel.open();\n                channel.configureBlocking(false);\n            } catch (IOException ex) {\n                ex.printStackTrace();\n                return;\n            }\n\n            while (!Thread.interrupted()) {\n                try {\n                    StringBuilder batch = new StringBuilder();\n                    q.drainTo(new java.util.ArrayList<>()); // Placeholder for actual queue processing\n                    if (batch.length() > 0) {\n                        byte[] bytes = batch.toString().getBytes(CHARSET);\n                        ByteBuffer packet = ByteBuffer.wrap(bytes);\n                        channel.send(packet, new InetSocketAddress(\"localhost\", 8125)); // Placeholder host/port\n                    }\n                    Thread.sleep(100); // Placeholder batching interval\n                } catch (IOException | InterruptedException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n        });\n    }\n\n    public static Statsd getInstance() {\n        return INSTANCE;\n    }\n\n\n    private LinkedBlockingQueue<String> getQ() {\n        return q;\n    }\n\n}\n"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class HttpClient {\n\n    String url;\n    HttpURLConnection con;\n    OutputStream os;\n    String delimiter = \"--\";\n    String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {\n        this.url = url;\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        URL urlObj = new URL(this.url);\n        con = (HttpURLConnection) urlObj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        os = con.getOutputStream();\n        writeParamData(\"imgName\", imgName);\n        os.flush();\n        os.close();\n\n        InputStream is = con.getInputStream();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, bytesRead);\n        }\n        return baos.toByteArray();\n    }\n\n\n    public void connectForMultipart() throws IOException {\n        URL urlObj = new URL(this.url);\n        con = (HttpURLConnection) urlObj.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.setDoOutput(true);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\\r\\n\").getBytes());\n        os.write(value.getBytes());\n        os.write((\"\\r\\n\").getBytes());\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\\r\\n\").getBytes());\n        os.write(data);\n        os.write((\"\\r\\n\").getBytes());\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws IOException {\n        StringBuilder response = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n        }\n        reader.close();\n        return response.toString();\n    }\n\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((paramName + \"=\" + URLEncoder.encode(value, \"UTF-8\")).getBytes());\n    }\n}\n```\n"
  },
  {
    "Task_id": 604,
    "Instruction": "Task Description: Implement a UDP client class in Java that can send UDP packets to a specified target address and port, with optional response waiting functionality.\n\nClass Description: The UDPClient class provides functionality to send UDP packets to a network target. It supports both fire-and-forget mode and request-response mode. The class manages its own socket and thread for asynchronous operation, and includes cleanup mechanisms.\n\nAttributes:\n- mUdpSocket: DatagramSocket - The UDP socket used for communication\n- mRunning: boolean - Flag indicating whether the client is currently active\n- mThread: Thread - The thread handling the UDP communication\n\nMethods:\n- sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) -> void - \n  Sends a UDP packet to the specified address and port. If waitResponse is true, it will wait for and deliver any response.\n  Parameters:\n    - targetAddress: String - The IP address or hostname of the target\n    - port: int - The destination port number\n    - data: String - The message to send\n    - waitResponse: boolean - Whether to wait for a response\n    - handler: ResponseHandler - Callback interface for handling responses or errors\n\n- stop() -> void - \n  Stops any ongoing UDP communication and cleans up resources. Closes the socket and interrupts the thread if active.\n\n- interface ResponseHandler - \n  Callback interface for handling responses or errors\n  Methods:\n    - onResponse(String response) -> void - Called when a response is received\n    - onError(String errorMessage) -> void - Called when an error occurs",
    "Canonical_solution": "import android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport org.csploit.android.R;\nimport org.csploit.android.core.Plugin;\nimport org.csploit.android.core.System;\nimport org.csploit.android.net.Target;\nimport org.csploit.android.net.Target.Type;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPClient {\n\n    private DatagramSocket mUdpSocket = null;\n    private boolean mRunning = false;\n    private Thread mThread = null;\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, final ResponseHandler handler) {\n        if (!mRunning) {\n            mRunning = true;\n\n            mThread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    String error = null;\n                    try {\n                        mUdpSocket = new DatagramSocket();\n                        DatagramPacket packet = new DatagramPacket(\n                                data.getBytes(), data.length(),\n                                System.getCurrentTarget().getAddress(), port);\n\n                        mUdpSocket.send(packet);\n\n                        if (waitResponse) {\n                            byte[] buffer = new byte[1024];\n                            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n                            mUdpSocket.receive(response);\n                            final String responseText = new String(buffer);\n                            handler.onResponse(responseText);\n                        }\n                    } catch (Exception e) {\n                        error = e.getMessage();\n                    } finally {\n                        if (mUdpSocket != null) {\n                            mUdpSocket.close();\n                        }\n                        mRunning = false;\n                        if (error != null) {\n                            handler.onError(error);\n                        }\n                    }\n                }\n            });\n\n            mThread.start();\n        }\n    }\n\n    public void stop() {\n        mRunning = false;\n        try {\n            if (mThread != null && mThread.isAlive()) {\n                if (mUdpSocket != null)\n                    mUdpSocket.close();\n                mThread.interrupt();\n                mThread = null;\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "import java.io.IOException;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class UDPClient {\n\n    private DatagramSocket mUdpSocket;\n    private boolean mRunning;\n    private Thread mThread;\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) {\n        if (mUdpSocket == null || mUdpSocket.isClosed()) {\n            if (handler != null) {\n                handler.onError(\"Socket is closed or not initialized.\");\n            }\n            return;\n        }\n\n        mThread = new Thread(() -> {\n            try {\n                InetAddress address = InetAddress.getByName(targetAddress);\n                byte[] sendData = data.getBytes(StandardCharsets.UTF_8);\n                DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, port);\n                mUdpSocket.send(sendPacket);\n\n                if (waitResponse) {\n                    byte[] receiveData = new byte[1024];\n                    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n                    mUdpSocket.receive(receivePacket);\n                    String response = new String(receivePacket.getData(), 0, receivePacket.getLength(), StandardCharsets.UTF_8);\n                    if (handler != null) {\n                        handler.onResponse(response);\n                    }\n                }\n            } catch (IOException e) {\n                if (handler != null) {\n                    handler.onError(\"Error sending/receiving UDP packet: \" + e.getMessage());\n                }\n            }\n        });\n        mThread.start();\n    }\n\n\n    public void stop() {\n        mRunning = false;\n        if (mUdpSocket != null) {\n            mUdpSocket.close();\n        }\n        if (mThread != null && mThread.isAlive()) {\n            mThread.interrupt();\n        }\n    }\n\n    public boolean init() {\n        try {\n            mUdpSocket = new DatagramSocket();\n            mRunning = true;\n            return true;\n        } catch (SocketException e) {\n            return false;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_client():\n    server_address = ('localhost', 9876)\n    message = b\"hello world\"\n\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.sendto(message, server_address)\n\n        data, server = sock.recvfrom(4096)\n        print(data.decode())\n\n    finally:\n        sock.close()\n\nudp_client()\n```"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpUtils {\n\n    public static class Error {\n        public int responseCode;\n        public String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"HTTP Error \" + responseCode + \": \" + output;\n        }\n    }\n\n    public interface IOUtils {\n        interface LineRead {\n            void readLine(String line) throws IOException;\n        }\n    }\n\n\n    public static String post(String request) throws IOException {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n\n        if (!body.isEmpty()) {\n            try (DataOutputStream wr = new DataOutputStream(connection.getOutputStream())) {\n                wr.write(body.getBytes(StandardCharsets.UTF_8));\n            }\n        }\n        return handleResponse(connection, null);\n    }\n\n\n    public static String get(String request) throws IOException {\n        return get(request, null, 5000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws IOException {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        return handleResponse(connection, callback);\n    }\n\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws IOException {\n        try (InputStream is = connection.getResponseCode() < 400 ? connection.getInputStream() : connection.getErrorStream()) {\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(is))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                    if (callback != null) {\n                        callback.readLine(inputLine);\n                    }\n                }\n            }\n            return response.toString();\n\n        } catch (IOException e) {\n            String errorOutput = \"\";\n            try (InputStream errorStream = connection.getErrorStream();\n                 BufferedReader errorReader = new BufferedReader(new InputStreamReader(errorStream))) {\n                String line;\n                while ((line = errorReader.readLine()) != null) {\n                    errorOutput += line;\n                }\n            } catch (Exception ex) {\n                // Ignore inner exception\n            }\n            throw new IOException(new Error(connection.getResponseCode(), errorOutput).toString(), e);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 614,
    "Instruction": "Task Description: Implement a UDP server function that continuously listens for incoming packets, processes the received data by converting it to uppercase, and sends the modified data back to the client.\n\nFunction Description: The function sets up a UDP server that binds to a specific port (9876) and enters an infinite loop to receive incoming packets. Upon receiving a packet, it extracts the data, converts it to uppercase, and sends the modified data back to the client's address and port. The function handles all necessary UDP communication steps including socket creation, packet reception, data processing, and response transmission.\n\nInput: None (The function takes no parameters as it binds to a fixed port and processes incoming UDP packets)\n\nOutput: None (The function does not return any value but prints received messages to the console and sends responses back to clients)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\nprivate void receiveServerUdpInfo() throws Exception {\n    DatagramSocket serverSocket = new DatagramSocket(9876);\n    byte[] receiveData = new byte[1024];\n    byte[] sendData = new byte[1024];\n    while(true) {\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.receive(receivePacket);\n        String sentence = new String(receivePacket.getData());\n        System.out.println(\"RECEIVED: \" + sentence);\n        InetAddress IPAddress = receivePacket.getAddress();\n        int port = receivePacket.getPort();\n        String capitalizedSentence = sentence.toUpperCase();\n        sendData = capitalizedSentence.getBytes();\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n        serverSocket.send(sendPacket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "```python\nimport socket\n\ndef udp_server():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_address = ('', 9876)\n    sock.bind(server_address)\n    print(\"UDP server listening on port 9876...\")\n\n    while True:\n        data, address = sock.recvfrom(4096)\n        print(f\"Received message: {data.decode()}\")\n        modified_data = data.decode().upper().encode()\n        sock.sendto(modified_data, address)\n\n```\n"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.IOException;\n\nclass Solution {\n    /**\n     * Checks the accessibility of a URL by sending a HEAD request.\n     *\n     * @param url The URL to check.\n     * @return True if the URL is accessible (HTTP status code 200), false otherwise.\n     */\n    public boolean isUrlAccessible(String url) {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setRequestMethod(\"HEAD\");\n            int statusCode = connection.getResponseCode();\n            return statusCode == HttpURLConnection.HTTP_OK;\n        } catch (IOException | IllegalArgumentException e) {\n            return false;\n        }\n    }\n}\n```"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"YOUR_SERVER_ENDPOINT_HERE\"); // Replace with your server URL\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n\n            String urlParameters = \"content=\" + URLEncoder.encode(content, \"UTF-8\") +\n                    \"&env=\" + URLEncoder.encode(env, \"UTF-8\");\n\n            DataOutputStream wr = new DataOutputStream(con.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n\n            int responseCode = con.getResponseCode();\n\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                if (callback != null) {\n                    callback.onSuccess();\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFailure(new Exception(\"HTTP error code : \" + responseCode));\n                }\n            }\n\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFailure(e);\n            }\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}\n\n```\n"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\n\npublic class HttpClient {\n\n    public String request(String url) {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(3000);\n            connection.setReadTimeout(90000);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Accept-Charset\", StandardCharsets.UTF_8.name());\n\n\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                return response.toString();\n            } else {\n                return null;\n            }\n\n        } catch (IOException e) {\n            return null;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
    "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.logging.Log;\nimport java.util.logging.Logger;\n\n\npublic class SimpleHttpUtils {\n\n    private static final Log logger = Logger.getLogger(SimpleHttpUtils.class.getName());\n\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n\n\n    public static final int DEFAULT_READ_TIMEOUT = 120000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 30000;\n\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n\n    private static final int MAX_FETCHSIZE = 5000000;\n\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n\n    public static String httpPost(String url, Map<String, String> params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map<String, String> params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String, String> params, String method, String charSet, Map<String, String> headers) {\n        SimpleHttpParam httpParam = new SimpleHttpParam();\n        httpParam.setUrl(url);\n        httpParam.setParams(params);\n        httpParam.setMethod(method);\n        httpParam.setCharSet(charSet);\n        httpParam.setHeaders(headers);\n        SimpleHttpResult result = httpRequest(httpParam);\n        return result.getContent();\n    }\n\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String, String> params = httpParam.getParams();\n        String method = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        Map<String, String> headers = httpParam.getHeaders();\n        int connectTimeout = httpParam.getConnectTimeout();\n        int readTimeout = httpParam.getReadTimeout();\n        boolean sslVerify = httpParam.isSslVerify();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n\n        SimpleHttpResult result = new SimpleHttpResult();\n\n        try {\n            String parameters = mapToQueryString(params, charSet);\n            if (HTTP_METHOD_GET.equalsIgnoreCase(method)) {\n                if (url.contains(\"?\")) {\n                    url = url + \"&\" + parameters;\n                } else {\n                    url = url + \"?\" + parameters;\n                }\n                parameters = null;\n            }\n\n            HttpURLConnection urlConn = (HttpURLConnection) new URL(url).openConnection();\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            urlConn.setRequestMethod(method);\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setUseCaches(false);\n\n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    urlConn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (parameters != null) {\n                OutputStreamWriter out = new OutputStreamWriter(urlConn.getOutputStream(), charSet);\n                out.write(parameters);\n                out.flush();\n                out.close();\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            result.setResponseCode(responseCode);\n\n            if (responseCode >= 200 && responseCode < 300) {\n                StringBuilder sb = new StringBuilder();\n                BufferedReader in = new BufferedReader(new InputStreamReader(urlConn.getInputStream(), charSet));\n                String line;\n                while ((line = in.readLine()) != null) {\n                    sb.append(line);\n                }\n                in.close();\n                result.setContent(sb.toString());\n            } else {\n                result.setContent(urlConn.getResponseMessage());\n                Map<String, String> errorMap = new HashMap<>();\n                errorMap.put(HTTP_ERROR_MESSAGE, urlConn.getResponseMessage());\n                result.setHeaders(errorMap);\n            }\n\n        } catch (Exception e) {\n            logger.severe(\"HTTP request error: \" + e.getMessage());\n            result.setException(e);\n        }\n        return result;\n    }\n\n\n    public static String mapToQueryString(Map<String, String> parameters, String charSet) throws UnsupportedEncodingException {\n        if (parameters == null || parameters.isEmpty()) {\n            return null;\n        }\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(\"&\");\n            }\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (value == null) {\n                continue;\n            }\n            sb.append(URLEncoder.encode(key, charSet)).append(\"=\").append(URLEncoder.encode(value, charSet));\n        }\n        return sb.toString();\n    }\n\n    public static String urlEncode(String url, String charSet) throws UnsupportedEncodingException {\n        return URLEncoder.encode(url, charSet);\n    }\n\n\n    public static void setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) throws Exception {\n        if (urlConn instanceof HttpsURLConnection) {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            if (!sslVerify) {\n                sslContext.init(null, trustAnyManagers, new java.security.SecureRandom());\n                ((HttpsURLConnection) urlConn).setSSLSocketFactory(sslContext.getSocketFactory());\n                if (!hostnameVerify) {\n                    ((HttpsURLConnection) urlConn).setHostnameVerifier(new TrustAnyHostnameVerifier());\n                }\n            }\n\n\n        }\n    }\n\n\n    public static List<String> makeStringList(Object value) {\n        if (value == null) {\n            return new ArrayList<>();\n        }\n        if (value instanceof String) {\n            return Collections.singletonList((String) value);\n        }\n        if (value instanceof Collection) {\n            List<String> result = new ArrayList<>();\n            for (Object element : (Collection) value) {\n                if (element != null) {\n                    result.add(element.toString());\n                }\n            }\n            return result;\n        }\n        return Collections.singletonList(value.toString());\n    }\n\n\n    public static class TrustAnyTrustManager implements X509TrustManager {\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n\n\n    public static class TrustAnyHostnameVerifier implements HostnameVerifier {\n\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n\n\n    public static class SimpleHttpParam {\n        private String url;\n        private Map<String, String> params;\n        private String method = HTTP_METHOD_GET;\n        private String charSet = DEFAULT_CHARSET;\n        private Map<String, String> headers;\n        private int connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n        private int readTimeout = DEFAULT_READ_TIMEOUT;\n        private boolean sslVerify = true;\n        private boolean hostnameVerify = true;\n        private TrustKeyStore trustKeyStore;\n        private ClientKeyStore clientKeyStore;\n\n        // Getters and setters for all fields\n\n        public String getUrl() {\n            return url;\n        }\n\n        public void setUrl(String url) {\n            this.url = url;\n        }\n\n        public Map<String, String> getParams() {\n            return params;\n        }\n\n        public void setParams(Map<String, String> params) {\n            this.params = params;\n        }\n\n        public String getMethod() {\n            return method;\n        }\n\n        public void setMethod(String method) {\n            this.method = method;\n        }\n\n        public String getCharSet() {\n            return charSet;\n        }\n\n        public void setCharSet(String charSet) {\n            this.charSet = charSet;\n        }\n\n        public Map<String, String> getHeaders() {\n            return headers;\n        }\n\n        public void setHeaders(Map<String, String> headers) {\n            this.headers = headers;\n        }\n\n        public int getConnectTimeout() {\n            return connectTimeout;\n        }\n\n        public void setConnectTimeout(int connectTimeout) {\n            this.connectTimeout = connectTimeout;\n        }\n\n        public int getReadTimeout() {\n            return readTimeout;\n        }\n\n        public void setReadTimeout(int readTimeout) {\n            this.readTimeout = readTimeout;\n        }\n\n        public boolean isSslVerify() {\n            return sslVerify;\n        }\n\n        public void setSslVerify(boolean sslVerify) {\n            this.sslVerify = sslVerify;\n        }\n\n        public boolean isHostnameVerify() {\n            return hostnameVerify;\n        }\n\n        public void setHostnameVerify(boolean hostnameVerify) {\n            this.hostnameVerify = hostnameVerify;\n        }\n\n        public TrustKeyStore getTrustKeyStore() {\n            return trustKeyStore;\n        }\n\n        public void setTrustKeyStore(TrustKeyStore trustKeyStore) {\n            this.trustKeyStore = trustKeyStore;\n        }\n\n        public ClientKeyStore getClientKeyStore() {\n            return clientKeyStore;\n        }\n\n        public void setClientKeyStore(ClientKeyStore clientKeyStore) {\n            this.clientKeyStore = clientKeyStore;\n        }\n    }\n\n    public static class SimpleHttpResult {\n        private String content;\n        private Map<String, String> headers;\n        private int responseCode;\n        private Exception exception;\n        //getters and setters\n\n        public String getContent() {\n            return content;\n        }\n\n        public void setContent(String content) {\n            this.content = content;\n        }\n\n        public Map<String, String> getHeaders() {\n            return headers;\n        }\n\n        public void setHeaders(Map<String, String> headers) {\n            this.headers = headers;\n        }\n\n        public int getResponseCode() {\n            return responseCode;\n        }\n\n        public void setResponseCode(int responseCode) {\n            this.responseCode = responseCode;\n        }\n\n        public Exception getException() {\n            return exception;\n        }\n\n        public void setException(Exception exception) {\n            this.exception = exception;\n        }\n    }\n\n    public static class TrustKeyStore {\n        // Add fields and methods related to trust keystore as needed\n    }\n\n    public static class ClientKeyStore {\n        // Add fields and methods related to client keystore as needed\n    }\n}\n"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a Java utility class for making asynchronous HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable headers and parameters. The class should handle response processing and error handling through callbacks.\n\nClass Description: HttpURLConnectionUtils is a final utility class that provides static methods for performing asynchronous HTTP requests. It encapsulates the complexity of HttpURLConnection and provides a simple callback-based interface for handling responses and errors.\n\nAttributes:\n\nTIMEOUT_IN_MILLIONS: int - The connection and read timeout duration in milliseconds (default: 5000)\n\nMethods:\n\ndoGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous HTTP GET request to the specified URL and invokes the callback with the response or error.\n\ndoPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous HTTP POST request to the specified URL with the given parameters and invokes the callback with the response or error.\n\nrequest(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic for both GET and POST methods, including setting headers, writing parameters, and processing the response.\n\nCallback: interface - Defines two methods for handling request outcomes:\n  onResponse(String result, long response) -> void - Called when the request succeeds\n  onFail(Throwable error) -> void - Called when the request fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(\n            final String urlStr,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(\n            final String urlStr,\n            final String params,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    public static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    private HttpURLConnectionUtils() {}\n\n    public interface Callback {\n        void onResponse(String result, long responseCode);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n\n    public static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(method);\n                connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        connection.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (\"POST\".equals(method) && params != null) {\n                    connection.setDoOutput(true);\n                    try (OutputStream os = connection.getOutputStream()) {\n                        byte[] input = params.getBytes(StandardCharsets.UTF_8);\n                        os.write(input, 0, input.length);\n                    }\n                }\n\n                int responseCode = connection.getResponseCode();\n                try (InputStream in = (responseCode >= 400) ? connection.getErrorStream() : connection.getInputStream();\n                     BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    callback.onResponse(response.toString(), responseCode);\n                }\n\n            } catch (Exception e) {\n                if (callback != null) {\n                    callback.onFail(e);\n                }\n            }\n        }).start();\n    }\n}\n```"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    public static final Map<Long, Integer> XSTS_ERRORS = new HashMap<>();\n\n    static {\n        // Initialize XSTS error codes mapping (replace with actual resource IDs)\n        XSTS_ERRORS.put(2148916233L, 1); // Example error code mapping\n        // Add more error codes and resource IDs as needed\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException {\n        String grantType = isRefresh ? \"refresh_token\" : \"authorization_code\";\n        String formData = convertToFormData(\"grant_type\", grantType, isRefresh ? \"refresh_token\" : \"code\", authcode);\n        return acquireToken(authTokenUrl, formData);\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException {\n        String relyingParty = \"rp://api.minecraftservices.com/\";\n        String formData = convertToFormData(\"Properties[AuthMethod]\", \"RPS\", \"Properties[SiteName]\", \"user.auth.xboxlive.com\", \"RelyingParty\", relyingParty, \"TokenType\", \"JWT\");\n        return acquireToken(xblAuthUrl, formData, accessToken);\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException {\n        String relyingParty = \"rp://api.minecraftservices.com/\";\n        String formData = convertToFormData(\"Properties[SandboxId]\", \"RETAIL\", \"Properties[UserTokens]\", xblToken, \"RelyingParty\", relyingParty, \"TokenType\", \"JWT\");\n        String response = acquireToken(xstsAuthUrl, formData);\n        String token = response.substring(response.indexOf(\"\\\"Token\\\":\\\"\") + 8, response.indexOf(\"\\\",\\\"DisplayClaims\\\":\"));\n        String userHash = response.substring(response.indexOf(\"\\\"XuiClaims\\\":[{\\\"uhs\\\":\\\"\") + 22, response.indexOf(\"\\\",\\\"gtg\\\":\"));\n        return new String[]{userHash, token};\n    }\n\n    private String acquireToken(String url, String formData) throws IOException {\n        return acquireToken(url, formData, null);\n    }\n\n    private String acquireToken(String url, String formData, String accessToken) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        setCommonProperties(conn, formData);\n        if (accessToken != null) {\n            conn.setRequestProperty(\"Authorization\", \"Bearer \" + accessToken);\n        }\n\n        if (conn.getResponseCode() >= 400) {\n            throw getResponseThrowable(conn);\n        }\n\n        return new BufferedReader(new InputStreamReader(conn.getInputStream())).readLine();\n    }\n\n\n    public void setCommonProperties(HttpURLConnection conn, String formData) throws IOException {\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setDoOutput(true);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n    }\n\n    public String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < data.length; i += 2) {\n            if (i > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(URLEncoder.encode(data[i], StandardCharsets.UTF_8.toString()))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i + 1], StandardCharsets.UTF_8.toString()));\n        }\n        return sb.toString();\n    }\n\n    public RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        String response = new BufferedReader(new InputStreamReader(conn.getErrorStream())).readLine();\n        String errorMessage = \"Failed to acquire token: HTTP \" + conn.getResponseCode();\n        if (response != null && response.contains(\"error\")) {\n            errorMessage += \": \" + response.substring(response.indexOf(\"\\\"error\\\":\\\"\") + 9, response.indexOf(\"\\\",\\\"error_description\\\":\\\"\"));\n        }\n        return new RuntimeException(errorMessage);\n    }\n}\n```"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\npublic class NetworkUtils {\n\n    public static boolean DEBUG = true;\n    public static String TAG = \"NetworkUtils\";\n    public static int HTTP_READ_TIMEOUT = 10000;\n    public static int HTTP_CONNECTION_TIMEOUT = 10000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();\n        urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n        urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n        urlConnection.setRequestMethod(\"GET\");\n        urlConnection.setDoInput(true);\n        urlConnection.connect();\n        return urlConnection;\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        try {\n            HttpsURLConnection urlConnection = setupHttpsRequest(url);\n            int responseCode = urlConnection.getResponseCode();\n            if (responseCode == HttpsURLConnection.HTTP_OK) {\n                InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            if (DEBUG) e.printStackTrace();\n        }\n        return null;\n    }\n\n\n    public static boolean downloadUrlFile(String url, File f) {\n        try {\n            HttpsURLConnection urlConnection = setupHttpsRequest(url);\n            int responseCode = urlConnection.getResponseCode();\n            if (responseCode == HttpsURLConnection.HTTP_OK) {\n                InputStream input = urlConnection.getInputStream();\n                OutputStream output = new FileOutputStream(f);\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    output.write(buffer, 0, bytesRead);\n                }\n                input.close();\n                output.close();\n                return true;\n            }\n        } catch (IOException e) {\n            if (DEBUG) e.printStackTrace();\n        }\n        return false;\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result, boolean success);\n    }\n}\n```"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for MMS (Multimedia Messaging Service) operations, supporting both HTTP and HTTPS protocols with configurable proxy settings and connection parameters.\n\nClass Description: MmsHttpClient is a specialized HTTP client designed for MMS operations that handles both GET and POST requests. It manages network connections, proxy configurations, request/response handling, and includes MMS-specific header management. The class uses OkHttp internally for connection management.\n\nAttributes:\n- mContext: Context - Android application context\n- mSocketFactory: SocketFactory - Factory for creating sockets\n- mHostResolver: MmsNetworkManager - Network host resolver for connection management\n- mConnectionPool: ConnectionPool - Pool of HTTP connections for reuse\n\nMethods:\n- execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) -> byte[] - Executes an HTTP request to the specified URL with given PDU data. Handles both GET and POST methods with proxy support. Returns the response body as byte array.\n- openConnection(URL url, Proxy proxy) -> HttpURLConnection - Creates and configures an appropriate HttpURLConnection (HTTP or HTTPS) with the given URL and proxy settings. Throws MalformedURLException for invalid protocols.\n- checkMethod(String method) -> void - Validates that the HTTP method is either GET or POST (helper method)\n- getCurrentAcceptLanguage(Locale locale) -> String - Generates Accept-Language header value from locale (helper method)\n- addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) -> void - Adds additional MMS-specific headers to the request (helper method)\n- logHttpHeaders(Map<String, List<String>> headers) -> void - Logs HTTP headers for debugging (helper method)",
    "Canonical_solution": "import android.content.Context;\nimport com.android.mms.service_alt.exception.MmsHttpException;\nimport com.squareup.okhttp.ConnectionPool;\nimport com.squareup.okhttp.ConnectionSpec;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Protocol;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.internal.Internal;\nimport com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;\nimport com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;\nimport timber.log.Timber;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MmsHttpClient {\n\n    public static final String METHOD_POST = \"POST\";\n    public static final String METHOD_GET = \"GET\";\n\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String HEADER_ACCEPT = \"Accept\";\n    private static final String HEADER_ACCEPT_LANGUAGE = \"Accept-Language\";\n    private static final String HEADER_USER_AGENT = \"User-Agent\";\n\n    private static final String HEADER_VALUE_ACCEPT =\n            \"*/*, application/vnd.wap.mms-message, application/vnd.wap.sic\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET =\n            \"application/vnd.wap.mms-message; charset=utf-8\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET =\n            \"application/vnd.wap.mms-message\";\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver,\n            ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n            String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig)\n            throws MmsHttpException {\n        Timber.d(\"HTTP: \" + method + \" \" + urlString\n                + (isProxySet ? (\", proxy=\" + proxyHost + \":\" + proxyPort) : \"\")\n                + \", PDU size=\" + (pdu != null ? pdu.length : 0));\n        checkMethod(method);\n        HttpURLConnection connection = null;\n        try {\n            Proxy proxy = null;\n            if (isProxySet) {\n                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n            }\n            final URL url = new URL(urlString);\n            connection = openConnection(url, proxy);\n            connection.setDoInput(true);\n            connection.setConnectTimeout(mmsConfig.getHttpSocketTimeout());\n            connection.setRequestProperty(HEADER_ACCEPT, HEADER_VALUE_ACCEPT);\n            connection.setRequestProperty(\n                    HEADER_ACCEPT_LANGUAGE, getCurrentAcceptLanguage(Locale.getDefault()));\n            final String userAgent = mmsConfig.getUserAgent();\n            Timber.i(\"HTTP: User-Agent=\" + userAgent);\n            connection.setRequestProperty(HEADER_USER_AGENT, userAgent);\n            final String uaProfUrlTagName = mmsConfig.getUaProfTagName();\n            final String uaProfUrl = mmsConfig.getUaProfUrl();\n            if (uaProfUrl != null) {\n                Timber.i(\"HTTP: UaProfUrl=\" + uaProfUrl);\n                connection.setRequestProperty(uaProfUrlTagName, uaProfUrl);\n            }\n            addExtraHeaders(connection, mmsConfig);\n            if (METHOD_POST.equals(method)) {\n                if (pdu == null || pdu.length < 1) {\n                    Timber.e(\"HTTP: empty pdu\");\n                    throw new MmsHttpException(0/*statusCode*/, \"Sending empty PDU\");\n                }\n                connection.setDoOutput(true);\n                connection.setRequestMethod(METHOD_POST);\n                if (mmsConfig.getSupportHttpCharsetHeader()) {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET);\n                } else {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET);\n                }\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setFixedLengthStreamingMode(pdu.length);\n                final OutputStream out = new BufferedOutputStream(connection.getOutputStream());\n                out.write(pdu);\n                out.flush();\n                out.close();\n            } else if (METHOD_GET.equals(method)) {\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setRequestMethod(METHOD_GET);\n            }\n            final int responseCode = connection.getResponseCode();\n            final String responseMessage = connection.getResponseMessage();\n            Timber.d(\"HTTP: \" + responseCode + \" \" + responseMessage);\n            logHttpHeaders(connection.getHeaderFields());\n            if (responseCode / 100 != 2) {\n                throw new MmsHttpException(responseCode, responseMessage);\n            }\n            final InputStream in = new BufferedInputStream(connection.getInputStream());\n            final ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n            final byte[] buf = new byte[4096];\n            int count = 0;\n            while ((count = in.read(buf)) > 0) {\n                byteOut.write(buf, 0, count);\n            }\n            in.close();\n            final byte[] responseBody = byteOut.toByteArray();\n            Timber.d(\"HTTP: response size=\"\n                    + (responseBody != null ? responseBody.length : 0));\n            return responseBody;\n        } catch (MalformedURLException e) {\n            Timber.e(e, \"HTTP: invalid URL \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL \" + urlString, e);\n        } catch (ProtocolException e) {\n            Timber.e(e, \"HTTP: invalid URL protocol \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL protocol \" + urlString, e);\n        } catch (IOException e) {\n            Timber.e(e, \"HTTP: IO failure\");\n            throw new MmsHttpException(0/*statusCode*/, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, final Proxy proxy) throws MalformedURLException {\n        final String protocol = url.getProtocol();\n        OkHttpClient okHttpClient;\n        if (protocol.equals(\"http\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setFollowRedirects(false);\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    if (proxy != null) {\n                        return Arrays.asList(proxy);\n                    } else {\n                        return new ArrayList<Proxy>();\n                    }\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            okHttpClient.setSocketFactory(SocketFactory.getDefault());\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            if (proxy != null) {\n                okHttpClient.setProxy(proxy);\n            }\n\n            return new HttpURLConnectionImpl(url, okHttpClient);\n        } else if (protocol.equals(\"https\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n            okHttpClient.setHostnameVerifier(verifier);\n            okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    return Arrays.asList(proxy);\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            return new HttpsURLConnectionImpl(url, okHttpClient);\n        } else {\n            throw new MalformedURLException(\"Invalid URL or unrecognized protocol \" + protocol);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.content.Context;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.net.SocketFactory;\nimport javax.net.ssl.HttpsURLConnection;\nimport okhttp3.ConnectionPool;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.MediaType;\n\npublic class MmsHttpClient {\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver, ConnectionPool connectionPool) {\n        this.mContext = context;\n        this.mSocketFactory = socketFactory;\n        this.mHostResolver = hostResolver;\n        this.mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n                          String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) throws IOException {\n        checkMethod(method);\n        URL url = new URL(urlString);\n\n        Proxy proxy = Proxy.NO_PROXY;\n        if (isProxySet) {\n            proxy = new Proxy(Proxy.Type.HTTP, mHostResolver.getProxyAddress(proxyHost, proxyPort));\n        }\n\n        OkHttpClient client = new OkHttpClient.Builder()\n                .socketFactory(mSocketFactory)\n                .proxy(proxy)\n                .connectionPool(mConnectionPool)\n                .build();\n\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n\n        if (method.equals(\"POST\")) {\n            requestBuilder.post(RequestBody.create(pdu, MediaType.parse(\"application/vnd.wap.mms-message\")));\n        } else if (method.equals(\"GET\")) {\n            requestBuilder.get();\n        }\n\n        addExtraHeaders(requestBuilder, mmsConfig);\n\n        Request request = requestBuilder.build();\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Unexpected code \" + response);\n            }\n            logHttpHeaders(response.headers().toMultimap());\n            try (InputStream in = response.body().byteStream()) {\n                return readFully(in);\n            }\n        }\n\n    }\n\n\n    private byte[] readFully(InputStream in) throws IOException {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        byte[] buffer = new byte[4096];\n        int count;\n        while ((count = in.read(buffer)) != -1) {\n            out.write(buffer, 0, count);\n        }\n        return out.toByteArray();\n    }\n\n\n    private void checkMethod(String method) {\n        if (!method.equals(\"GET\") && !method.equals(\"POST\")) {\n            throw new IllegalArgumentException(\"Invalid HTTP method: \" + method);\n        }\n    }\n\n    private String getCurrentAcceptLanguage(Locale locale) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(locale.getLanguage());\n        String country = locale.getCountry();\n\n        if (country != null) {\n            builder.append(\"-\");\n            builder.append(country);\n        }\n        return builder.toString();\n    }\n\n\n    private void addExtraHeaders(Request.Builder requestBuilder, MmsConfig.Overridden mmsConfig) {\n        if (mmsConfig != null) {\n            requestBuilder.addHeader(\"User-Agent\", mmsConfig.getUserAgent());\n        }\n        requestBuilder.addHeader(\"Accept-Language\", getCurrentAcceptLanguage(Locale.getDefault()));\n        requestBuilder.addHeader(\"x-wap-profile\", \"http://www.openmobilealliance.org/tech/profiles/UAPROF/ccppschema-20021212#\");\n\n    }\n\n    private void logHttpHeaders(Map<String, List<String>> headers) {\n        // Logging implementation (removed for brevity)\n    }\n\n\n    interface MmsNetworkManager {\n        java.net.SocketAddress getProxyAddress(String proxyHost, int proxyPort);\n    }\n}\n```"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URLEncoder;\nimport java.io.IOException;\n\ninterface OnRequestCallback {\n    void onSuccess();\n    void onFailure(Exception e);\n}\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n    private static final String POST_URL = \"YOUR_POST_URL_HERE\"; // Replace with your URL\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(POST_URL);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n\n            String postData = \"packageName=\" + URLEncoder.encode(packageName, \"UTF-8\");\n\n            OutputStream os = connection.getOutputStream();\n            os.write(postData.getBytes());\n            os.flush();\n            os.close();\n\n            int responseCode = connection.getResponseCode();\n\n            if (responseCode < 400) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"HTTP error code: \" + responseCode));\n            }\n\n        } catch (IOException e) {\n            callback.onFailure(e);\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class HttpPoster {\n\n    private static final String BASE_URL = \"http://localhost:8080\"; // Replace with your base URL\n\n    public static void postAndVerify(String message, String url) throws IOException {\n        URL fullUrl = new URL(BASE_URL + url);\n        HttpURLConnection connection = (HttpURLConnection) fullUrl.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"text/plain; charset=utf-8\");\n\n        try (OutputStream os = connection.getOutputStream()) {\n            os.write(message.getBytes(StandardCharsets.UTF_8));\n        }\n\n        int responseCode = connection.getResponseCode();\n        assertEquals(HttpURLConnection.HTTP_OK, responseCode, \"Unexpected response code\");\n\n\n        String responseBody = readResponse(connection.getInputStream());\n\n        if (!message.equals(responseBody)) {\n            printHexResponse(responseBody);\n        }\n\n        assertEquals(message, responseBody, \"Response content does not match the sent message\");\n\n    }\n\n\n    private static String readResponse(InputStream inputStream) throws IOException {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line);\n            }\n        }\n        return response.toString();\n    }\n\n    private static void printHexResponse(String response) {\n        System.err.println(\"Hexadecimal representation of the response:\");\n        for (byte b : response.getBytes(StandardCharsets.UTF_8)) {\n            System.err.printf(\"%02X \", b);\n        }\n        System.err.println();\n    }\n}\n```\n"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.stream.*;\n\nenum Protocol { HTTP, HTTPS }\n\nclass Param {\n    String key;\n    String value;\n\n    Param(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\n@FunctionalInterface\ninterface StreamConsumer {\n    void accept(OutputStream os) throws IOException;\n}\n\n\nclass SingletonIterator<T> implements Iterator<T> {\n    private T value;\n    private boolean hasNext = true;\n\n    SingletonIterator(T value) {\n        this.value = value;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return hasNext;\n    }\n\n    @Override\n    public T next() {\n        if (hasNext) {\n            hasNext = false;\n            return value;\n        }\n        throw new NoSuchElementException();\n    }\n}\n\nclass Response {\n    int status;\n    String text;\n    Map<String, List<String>> headers;\n\n    Response(int status, String text, Map<String, List<String>> headers) {\n        this.status = status;\n        this.text = text;\n        this.headers = headers;\n    }\n}\n\nclass RestException extends Exception {\n    RestException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n\n\nclass RestClient {\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n\n    public URL getUrl(String path, Param... params) throws MalformedURLException {\n        String paramString = Arrays.stream(params)\n                .map(p -> p.key + \"=\" + URLEncoder.encode(p.value, java.nio.charset.StandardCharsets.UTF_8))\n                .collect(Collectors.joining(\"&\"));\n\n        String urlString = String.format(\"%s://%s:%d%s?%s\", protocol.toString().toLowerCase(), host, port, path, paramString);\n        return new URL(urlString);\n\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                URL url = getUrl(path);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method.name());\n\n                if (username != null && password != null) {\n                    String auth = username + \":\" + password;\n                    String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n                }\n\n                if (outStreamConsumer != null) {\n                    conn.setDoOutput(true);\n                    try (OutputStream os = conn.getOutputStream()) {\n                        outStreamConsumer.accept(os);\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String responseText = tryGetResponseTextFrom(conn, status);\n                return new Response(status, responseText, conn.getHeaderFields());\n\n            } catch (IOException e) {\n                throw new CompletionException(new RestException(\"Failed to send request\", e));\n            }\n        });\n    }\n\n\n    private String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        InputStream is = (status >= 400) ? conn.getErrorStream() : conn.getInputStream();\n        if (is != null) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n                return reader.lines().collect(Collectors.joining(\"\\n\"));\n            }\n        }\n        return \"\";\n    }\n\n    private int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (IOException e) {\n            if (e.getMessage().contains(\"404\")) {\n                return 404;\n            }\n            throw e;\n        }\n    }\n}\n"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Config {\n    public String dnslogDomain;\n    public String dnslogSession;\n}\n\npublic class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n        this.status = 0;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            URL url = new URL(\"http://dnslog.cn/getdomain.php\");\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n\n                String responseBody = response.toString();\n                config.dnslogDomain = responseBody;\n\n                String cookieHeader = connection.getHeaderField(\"Set-Cookie\");\n                Pattern pattern = Pattern.compile(\"PHPSESSID=([^;]+);\");\n                Matcher matcher = pattern.matcher(cookieHeader);\n                if (matcher.find()) {\n                    config.dnslogSession = matcher.group(1);\n                }\n\n                status = 1;\n            } else {\n                status = -1;\n            }\n\n        } catch (IOException e) {\n            status = -1;\n        }\n\n        return 1;\n    }\n}\n```\n"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.os.AsyncTask;\nimport android.widget.Toast;\nimport android.content.Context;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n\npublic class HttpRequestHandler {\n\n    private static Context mContext;\n\n    public HttpRequestHandler(Context context) {\n        mContext = context;\n    }\n\n\n    private static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setRequestMethod(\"GET\");\n\n                int statusCode = urlConnection.getResponseCode();\n\n                if (statusCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = urlConnection.getInputStream();\n                    return ConvertInputToStringNoChange(inputStream);\n                } else {\n                    return \"Error: \" + statusCode;\n                }\n\n            } catch (IOException e) {\n                return \"Error: \" + e.getMessage();\n            }\n        }\n\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            Toast.makeText(mContext, values[0], Toast.LENGTH_SHORT).show();\n        }\n\n        @Override\n        protected void onPostExecute(String s) {\n            super.onPostExecute(s);\n        }\n    }\n\n\n    public static void execute(String url) {\n        new MyAsyncTaskgetNews().execute(url);\n    }\n\n    private static String ConvertInputToStringNoChange(InputStream inputStream) {\n\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line = null;\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                stringBuilder.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nimport com.mongodb.MongoClientException;\n\n\npublic final class HttpHelper {\n\n    private HttpHelper() {\n        throw new AssertionError(\"Utility class cannot be instantiated.\");\n    }\n\n    public static String getHttpContents(String method, String endpoint, Map<String, String> headers) {\n        try {\n            URL url = new URL(endpoint);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setConnectTimeout(15000);\n            connection.setReadTimeout(15000);\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n\n            if (method.equals(\"POST\") && headers != null && headers.containsKey(\"Content-Type\") && headers.get(\"Content-Type\").equals(\"application/x-www-form-urlencoded\")) {\n                StringBuilder postData = new StringBuilder();\n                for (Map.Entry<String, String> param : headers.entrySet()) {\n                    if (!param.getKey().equals(\"Content-Type\")) {\n                        if (postData.length() != 0) postData.append('&');\n                        postData.append(URLEncoder.encode(param.getKey(), StandardCharsets.UTF_8));\n                        postData.append('=');\n                        postData.append(URLEncoder.encode(String.valueOf(param.getValue()), StandardCharsets.UTF_8));\n                    }\n                }\n                byte[] postDataBytes = postData.toString().getBytes(StandardCharsets.UTF_8);\n                connection.setRequestProperty(\"Content-Length\", String.valueOf(postDataBytes.length));\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(postDataBytes);\n                }\n            }\n\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                String inputLine;\n                StringBuilder content = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n                return content.toString();\n            }\n\n        } catch (IOException e) {\n            throw new MongoClientException(\"Error making HTTP request: \" + e.getMessage(), e);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.net.URLEncoder;\n\n\npublic class PostRequest {\n\n    public static String sendPostRequest(String url, String name) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            con.setDoOutput(true);\n\n            String postData = \"name=\" + URLEncoder.encode(name, \"UTF-8\");\n\n            try (OutputStream os = con.getOutputStream()) {\n                byte[] input = postData.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                return response.toString();\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```\n"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport android.os.AsyncTask;\n\npublic class HttpRequestHandler {\n\n    private HttpRequestCallback callback;\n\n    public HttpRequestHandler(HttpRequestCallback callback) {\n        this.callback = callback;\n    }\n\n    public void execute(String... urls) {\n        new MyAsyncTask().execute(urls);\n    }\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... values);\n        void onPostExecute(String result);\n    }\n\n    private class MyAsyncTask extends AsyncTask<String, String, String> {\n\n        @Override\n        protected String doInBackground(String... urls) {\n            StringBuilder response = new StringBuilder();\n            try {\n                URL url = new URL(urls[0]);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(15000);\n                connection.setReadTimeout(15000);\n                connection.connect();\n\n                InputStream inputStream = connection.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n\n                while ((line = reader.readLine()) != null) {\n                    response.append(line).append('\\n');\n                    publishProgress(line);\n                }\n                reader.close();\n                inputStream.close();\n\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"Error: \" + e.getMessage();\n            }\n            return response.toString();\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}\n"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.InetAddress;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\npublic class SSRFChecker {\n\n    private Logger logger = Logger.getLogger(SSRFChecker.class.getName());\n    private String decimalIp = \"\";\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        for (int i = 0; i < checkTimes; i++) {\n            String host = url2host(url);\n            if (host.isEmpty()) {\n                return false;\n            }\n\n            if (isInternalIpByUrl(host)) {\n                return false;\n            }\n\n            try {\n                URL u = new URL(url);\n                url = u.openConnection().getHeaderField(\"Location\");\n                if (url == null) {\n                    return true;\n                }\n            } catch (Exception e) {\n                logger.warning(\"Error checking redirect: \" + e.getMessage());\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    public boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.isEmpty()) return false;\n\n        String ip = host2ip(host);\n        decimalIp = ip;\n        return isInternalIp(ip);\n    }\n\n    public boolean isInternalIp(String strIP) {\n        if (strIP.isEmpty()) return false;\n\n        try {\n            long ip = ip2long(strIP);\n            return (ip >= ip2long(\"127.0.0.0\") && ip <= ip2long(\"127.255.255.255\")) ||\n                    (ip >= ip2long(\"10.0.0.0\") && ip <= ip2long(\"10.255.255.255\")) ||\n                    (ip >= ip2long(\"172.16.0.0\") && ip <= ip2long(\"172.31.255.255\")) ||\n                    (ip >= ip2long(\"192.168.0.0\") && ip <= ip2long(\"192.168.255.255\")) ||\n                    (ip >= ip2long(\"0.0.0.0\") && ip <= ip2long(\"0.255.255.255\")) ||\n                    (ip >= ip2long(\"169.254.0.0\") && ip <= ip2long(\"169.254.255.255\")) ||\n                    (ip >= ip2long(\"224.0.0.0\") && ip <= ip2long(\"255.255.255.255\"));\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n\n    public String host2ip(String host) {\n        if (isOctalIP(host)) {\n            try {\n                return InetAddress.getByName(host).getHostAddress();\n            } catch (UnknownHostException e) {\n                return \"\";\n            }\n        }\n\n        try {\n            InetAddress ip = InetAddress.getByName(host);\n            return ip.getHostAddress();\n        } catch (UnknownHostException e) {\n            return \"\";\n        }\n    }\n\n    public String url2host(String url) {\n        try {\n            URL u = new URL(url);\n            if (!u.getProtocol().startsWith(\"http\")) {\n                return \"\";\n            }\n            return u.getHost();\n        } catch (MalformedURLException e) {\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        return Pattern.matches(\"\\\\d+[.]\\\\d+[.]\\\\d+[.]\\\\d+\", host);\n    }\n\n    private long ip2long(String ipAddress) {\n        String[] ipAddressInArray = ipAddress.split(\"\\\\.\");\n        long result = 0;\n        for (int i = 0; i < ipAddressInArray.length; i++) {\n            int power = 3 - i;\n            int ip = Integer.parseInt(ipAddressInArray[i]);\n            result += ip * Math.pow(256, power);\n        }\n        return result;\n    }\n}\n```"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class HttpRequestManager {\n\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection connection;\n\n                if (mProxyOn) {\n                    Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(mProxyHost, (int) mProxyPort));\n                    connection = (HttpURLConnection) url.openConnection(proxy);\n                } else {\n                    connection = (HttpURLConnection) url.openConnection();\n                }\n\n                connection.setRequestMethod(\"GET\");\n                connection.setConnectTimeout(15000);\n                connection.setReadTimeout(15000);\n                connection.setDoInput(true);\n\n                int responseCode = connection.getResponseCode();\n\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = connection.getInputStream();\n                    String response = readStringFromStream(inputStream);\n\n                    if (callback != null) {\n                        callback.onSuccess(response);\n                    }\n\n                } else {\n                    if (callback != null) {\n                        callback.onFailed();\n                    }\n                }\n            } catch (IOException e) {\n                if (callback != null) {\n                    callback.onFailed();\n                }\n            }\n        }).start();\n    }\n\n\n    private String readStringFromStream(InputStream inputStream) throws IOException {\n        StringBuilder result = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            result.append(line);\n        }\n        reader.close();\n        return result.toString();\n    }\n\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}\n"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.net.*;\nimport java.io.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class HttpTinyClient {\n\n    public static class HttpResult {\n        public int code;\n        public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        String encodedParams = encodingParams(paramValues, encoding);\n        if (!encodedParams.isEmpty()) {\n            url += \"?\" + encodedParams;\n        }\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setReadTimeout((int) readTimeoutMs);\n        setHeaders(conn, headers, encoding);\n        return processResponse(conn);\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setReadTimeout((int) readTimeoutMs);\n        setHeaders(conn, headers, encoding);\n\n        String encodedParams = encodingParams(paramValues, encoding);\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = encodedParams.getBytes(encoding);\n            os.write(input, 0, input.length);\n        }\n        return processResponse(conn);\n\n    }\n\n\n    public static String encodingParams(List<String> paramValues, String encoding) throws UnsupportedEncodingException {\n        if (paramValues == null || paramValues.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < paramValues.size(); i += 2) {\n            if (i > 0) {\n                sb.append(\"&\");\n            }\n            sb.append(URLEncoder.encode(paramValues.get(i), encoding));\n            sb.append(\"=\");\n            sb.append(URLEncoder.encode(paramValues.get(i + 1), encoding));\n        }\n        return sb.toString();\n    }\n\n    public static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + encoding);\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i += 2) {\n                conn.setRequestProperty(headers.get(i), headers.get(i + 1));\n            }\n        }\n    }\n\n    private static HttpResult processResponse(HttpURLConnection conn) throws IOException {\n        int responseCode = conn.getResponseCode();\n        StringBuilder responseContent = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                responseContent.append(inputLine);\n            }\n        } catch (IOException e) {\n            if (responseCode >= 400) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                    String inputLine;\n                    while ((inputLine = in.readLine()) != null) {\n                        responseContent.append(inputLine);\n                    }\n                }\n            } else {\n                throw e;\n            }\n        }\n        return new HttpResult(responseCode, responseContent.toString());\n    }\n}\n```"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws IOException {\n        String BOUNDARY = \"---------------------------\" + System.currentTimeMillis();\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setConnectTimeout(connectTimeout);\n        conn.setReadTimeout(readTimeout);\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n        try (OutputStream out = conn.getOutputStream()) {\n            if (textMap != null) {\n                for (Map.Entry<String, String> entry : textMap.entrySet()) {\n                    writeFormParameter(out, BOUNDARY, entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (fileMap != null) {\n                for (Map.Entry<String, MultipartFile> entry : fileMap.entrySet()) {\n                    MultipartFile file = entry.getValue();\n                    String filename = file.getOriginalFilename();\n                    String contentType = URLConnection.guessContentTypeFromName(filename);\n                    writeFile(out, BOUNDARY, entry.getKey(), filename, contentType, file.getInputStream());\n                }\n            }\n\n            out.write((\"--\" + BOUNDARY + \"--\\r\\n\").getBytes(StandardCharsets.UTF_8));\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            return readResponse(conn.getInputStream());\n        } else {\n            String errorResponse = readResponse(conn.getErrorStream());\n            throw new IOException(\"Server returned non-OK status: \" + responseCode + \" with response: \" + errorResponse);\n        }\n    }\n\n\n    private void writeFormParameter(OutputStream out, String boundary, String name, String value) throws IOException {\n        String part = \"--\" + boundary + \"\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"\" + name + \"\\\"\\r\\n\" +\n                \"\\r\\n\" +\n                value + \"\\r\\n\";\n        out.write(part.getBytes(StandardCharsets.UTF_8));\n    }\n\n    private void writeFile(OutputStream out, String boundary, String name, String filename, String contentType, InputStream fileStream) throws IOException {\n        String partHeader = \"--\" + boundary + \"\\r\\n\" +\n                \"Content-Disposition: form-data; name=\\\"\" + name + \"\\\"; filename=\\\"\" + filename + \"\\\"\\r\\n\" +\n                \"Content-Type: \" + contentType + \"\\r\\n\" +\n                \"\\r\\n\";\n        out.write(partHeader.getBytes(StandardCharsets.UTF_8));\n\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = fileStream.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n        out.write(\"\\r\\n\".getBytes(StandardCharsets.UTF_8));\n        closeStream(fileStream);\n    }\n\n    private String readResponse(InputStream inputStream) throws IOException {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n        }\n        closeStream(inputStream);\n        return response.toString();\n    }\n\n    private void closeStream(Closeable closeable) {\n        try {\n            if (closeable != null) {\n                closeable.close();\n            }\n        } catch (IOException e) {\n            logger.error(\"Error closing stream: \", e);\n        }\n    }\n}\n"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import com.google.gson.Gson;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ApiHandler {\n    private final String baseUrl;\n    private final Map<String, String> additionalHeaders = new HashMap<>();\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this(url);\n        this.additionalHeaders.put(\"Authorization\", \"Bearer \" + apiKey);\n    }\n\n\n    public <T> T get(String endpoint, Class<T> tClass) throws IOException {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        return getFullUrl(additionalHeaders, baseUrl + endpoint, query, tClass);\n    }\n\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) throws IOException {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        return postFullUrl(additionalHeaders, baseUrl + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"GET\");\n        addHeaders(connection, headers);\n        return readResponse(connection);\n    }\n\n\n    public static String postRaw(Map<String, String> headers, String url, String body) throws IOException {\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setDoOutput(true);\n        addHeaders(connection, headers);\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            os.write(input, 0, input.length);\n        }\n        return readResponse(connection);\n    }\n\n    public static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    public static String parseQueries(HashMap<String, Object> query) {\n        if (query == null || query.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder(\"?\");\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            sb.append(urlEncodeUTF8(entry.getKey())).append(\"=\").append(urlEncodeUTF8(entry.getValue().toString())).append(\"&\");\n        }\n        return sb.substring(0, sb.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) throws IOException {\n        String response = getRaw(headers, url);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) throws IOException {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) throws IOException {\n        String jsonBody = new Gson().toJson(body);\n        String response = postRaw(headers, url, jsonBody);\n        return new Gson().fromJson(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) throws IOException {\n        return postFullUrl(headers, url + parseQueries(query), body, tClass);\n    }\n\n\n    public static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, StandardCharsets.UTF_8.toString());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static String readResponse(HttpURLConnection connection) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            return content.toString();\n        }\n    }\n}\n"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.logging.Logger;\n\n\npublic class RemoteServiceImpl {\n\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        String response = sendRequest(packageId, timestamp);\n        if (response != null) {\n            // Process the response and create a KnowledgePackage object\n            // ... (Implementation for parsing the response and creating KnowledgePackage)\n            return new KnowledgePackage(); // Placeholder\n        } else {\n            return null;\n        }\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        try {\n            String endpoint = \"/knowledge/\" + packageId + \"?timestamp=\" + timestamp;\n            URL url = new URL(resporityServerUrl + endpoint);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                log.severe(\"HTTP request failed with response code: \" + responseCode);\n                return null;\n            }\n\n        } catch (IOException e) {\n            log.severe(\"Error sending HTTP request: \" + e.getMessage());\n            return null;\n        }\n    }\n\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if (!resporityServerUrl.endsWith(\"/\")) {\n            resporityServerUrl += \"/\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n\n\n    private static class KnowledgePackage {\n        // ... (Implementation for KnowledgePackage class)\n    }\n}\n```"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "```java\nimport android.app.DownloadManager;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.webkit.CookieManager;\nimport android.webkit.MimeTypeMap;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\n\nimport io.reactivex.Single;\nimport io.reactivex.SingleEmitter;\nimport io.reactivex.SingleOnSubscribe;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class FetchUrlMimeType {\n\n    private DownloadManager.Request mRequest;\n    private DownloadManager mDownloadManager;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(new SingleOnSubscribe<Result>() {\n            @Override\n            public void subscribe(SingleEmitter<Result> emitter) throws Exception {\n                String mimeType = null;\n                String contentDisposition = null;\n\n                try {\n                    OkHttpClient client = new OkHttpClient();\n                    Request.Builder requestBuilder = new Request.Builder().url(mUri).get();\n\n                    if (mCookies != null) {\n                        requestBuilder.addHeader(\"Cookie\", mCookies);\n                    }\n                    if (mUserAgent != null) {\n                        requestBuilder.addHeader(\"User-Agent\", mUserAgent);\n                    }\n\n                    Response response = client.newCall(requestBuilder.build()).execute();\n\n                    if (response.isSuccessful()) {\n                        mimeType = response.header(\"Content-Type\");\n                        contentDisposition = response.header(\"Content-Disposition\");\n                    }\n\n                    response.close();\n\n\n                    if (mimeType == null) {\n                        mimeType = URLConnection.guessContentTypeFromName(mUri);\n                    }\n\n                    if (mimeType == null) {\n                        mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(MimeTypeMap.getFileExtensionFromUrl(mUri));\n                    }\n\n\n                    String fileName = \"download\";\n                    if (contentDisposition != null) {\n                        fileName = contentDisposition.replaceFirst(\"(?i)^.*filename=\\\"?([^\\\"]+)\\\"?.*$\", \"$1\");\n                        fileName = fileName.replaceAll(\"[^a-zA-Z0-9-_.]\", \"_\");\n                    } else {\n                        String[] parts = mUri.split(\"/\");\n                        fileName = parts[parts.length - 1].split(\"\\\\?\")[0];\n                        fileName = fileName.replaceAll(\"[^a-zA-Z0-9-_.]\", \"_\");\n                    }\n\n                    Uri uri = Uri.parse(mUri);\n                    mRequest.setMimeType(mimeType);\n                    mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);\n                    mRequest.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n                    mRequest.setTitle(fileName);\n\n                    if (mCookies != null) {\n                        mRequest.addRequestHeader(\"Cookie\", CookieManager.getInstance().getCookie(mUri));\n                    }\n                    if (mUserAgent != null) {\n                        mRequest.addRequestHeader(\"User-Agent\", mUserAgent);\n                    }\n\n                    long downloadId = mDownloadManager.enqueue(mRequest);\n                    if (downloadId >= 0) {\n                        emitter.onSuccess(Result.SUCCESS);\n                    } else {\n                        emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                    }\n\n                } catch (IllegalArgumentException e) {\n                    emitter.onSuccess(Result.FAILURE_LOCATION);\n                } catch (Exception e) {\n                    emitter.onSuccess(Result.FAILURE_ENQUEUE);\n                }\n            }\n        });\n    }\n\n\n    public enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}\n```"
  }
]