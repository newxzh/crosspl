[
  {
    "Task_id": 10,
    "Instruction": "Task Description: Create a Java class that provides read-only access to file contents using MemorySegment and FileChannel for efficient memory-mapped file operations.\n\nClass Description: MemorySegmentReaderSupplier is a utility class that implements ReaderSupplier interface, designed to provide memory-mapped file reading capabilities. It uses Java NIO's FileChannel to map a file into memory as a MemorySegment, allowing efficient read operations. The class manages memory resources through an Arena and automatically handles resource cleanup.\n\nAttributes:\n- arena: Arena - Manages the lifecycle of the memory segment and ensures proper cleanup\n- memory: MemorySegment - The memory-mapped representation of the file content\n\nMethods:\n- Constructor: MemorySegmentReaderSupplier(Path path) throws IOException - Initializes the reader by opening the specified file and mapping it into memory. Throws IOException if file operations fail.\n- get: get() -> MemorySegmentReader - Returns a new MemorySegmentReader instance for accessing the memory-mapped file content\n- close: close() -> void - Releases all allocated resources by closing the arena and unmapping the memory segment",
    "Canonical_solution": "import java.io.IOException;\nimport java.lang.foreign.Arena;\nimport java.lang.foreign.MemorySegment;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class MemorySegmentReaderSupplier implements ReaderSupplier {\n    private final Arena arena;\n    private final MemorySegment memory;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        this.arena = Arena.ofShared();\n        try (var ch = FileChannel.open(path, StandardOpenOption.READ)) {\n            this.memory = ch.map(FileChannel.MapMode.READ_ONLY, 0L, ch.size(), arena);\n        } catch (Throwable e) {\n            arena.close();\n            if (e instanceof IOException) {\n                throw (IOException) e;\n            }\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    @Override\n    public void close() {\n        arena.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.*;\nimport java.nio.*;\nimport java.lang.foreign.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class MemorySegmentReaderSupplier implements ReaderSupplier {\n    private final Arena arena;\n    private final MemorySegment memory;\n    private final FileChannel channel;\n    private final MappedByteBuffer buffer;\n\n    public MemorySegmentReaderSupplier(Path path) throws IOException {\n        this.arena = Arena.openConfined();\n        this.channel = FileChannel.open(path, StandardOpenOption.READ);\n        this.buffer = channel.map(MapMode.READ_ONLY, 0, channel.size());\n        this.memory = MemorySegment.ofAddress(buffer.address(), buffer.remaining(), arena);\n    }\n\n    public MemorySegmentReader get() {\n        return new MemorySegmentReader(memory);\n    }\n\n    public void close() {\n        try {\n            buffer.close();\n            channel.close();\n            arena.close();\n        } catch (IOException e) {\n            // Handle or log the exception as needed\n        }\n    }\n}"
  },
  {
    "Task_id": 102,
    "Instruction": "Task Description: Create a Java class that demonstrates how to make an HTTP request using HttpURLConnection, including setting connection timeouts and request headers, and handling the response.\n\nClass Description: The CleartextHttpCredentialsTest class is designed to test basic HTTP connectivity with a target URL. It demonstrates how to establish a connection, set timeouts, add request headers, and retrieve response information. The class focuses on proper resource cleanup after the connection is used.\n\nAttributes:\n- TARGET: [String] - A constant storing the URL to which the HTTP request will be made\n\nMethods:\n- runTest: [runTest]() -> [void] - Executes the HTTP request to the target URL. Sets connection timeouts, adds an Authorization header, retrieves the response code and message, and ensures proper connection cleanup. Throws Exception if any step fails.",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class CleartextHttpCredentialsTest {\n\n  private static final String TARGET = \"http://www.google.com\";\n\n  public void runTest() throws Exception {\n    HttpURLConnection connection = null;\n    try {\n      connection = (HttpURLConnection) new URL(TARGET).openConnection();\n      connection.setConnectTimeout(20000);\n      connection.setReadTimeout(20000);\n      connection.setRequestProperty(\"Authorization\", \"value\");\n      int responseCode = connection.getResponseCode();\n      String responseMessage = connection.getResponseMessage();\n    } finally {\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 16,
    "right_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class CleartextHttpCredentialsTest {\n    private static final String TARGET = \"http://httpbin.org/get\";\n\n    public void runTest() throws Exception {\n        URL url = new URL(TARGET);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        connection.setRequestProperty(\"Authorization\", \"Basic \" + Base64.getEncoder().encodeToString(\"user:pass\".getBytes()));\n        int responseCode = connection.getResponseCode();\n        String responseMessage = connection.getResponseMessage();\n        System.out.println(\"Response Code: \" + responseCode + \", Message: \" + responseMessage);\n        connection.disconnect();\n    }\n}"
  },
  {
    "Task_id": 11,
    "Instruction": "Task Description: Create a Java class that reads and processes OSM (OpenStreetMap) PBF (Protocolbuffer Binary Format) files using Java NIO's FileChannel for efficient file operations, with support for lazy reading of file blocks.\n\nClass Description: The OsmInputFile class provides functionality to read and process OSM PBF files. It supports both eager and lazy reading modes, where lazy reading defers the actual decoding of data blocks until needed. The class uses FileChannel for efficient file operations and includes methods for reading headers, blocks, and validating file contents.\n\nAttributes:\n- path: [Path] - The file path to the OSM PBF file to be processed\n- lazy: [boolean] - Flag indicating whether to use lazy reading mode for file blocks\n\nMethods:\n- readInt: [readInt]([FileChannel channel]) -> [int] - Reads a 4-byte integer from the specified FileChannel\n- readBytes: [readBytes]([FileChannel channel, int length]) -> [byte[]] - Reads a specified number of bytes from the current position in the FileChannel\n- readBytes: [readBytes]([FileChannel channel, long offset, int length]) -> [byte[]] - Reads a specified number of bytes from a specific offset in the FileChannel\n- readBlobHeader: [readBlobHeader]([FileChannel channel]) -> [BlobHeader] - Reads and parses a BlobHeader from the FileChannel\n- openChannel: [openChannel]() -> [FileChannel] - Opens and returns a FileChannel for reading the input file\n- LazyReader (inner class): [LazyReader]() -> [OsmBlockSource] - Implements lazy reading functionality for OSM blocks\n  - forEachBlock: [forEachBlock]([Consumer<Block> consumer]) -> [void] - Processes each block in the file using the provided consumer\n  - close: [close]() -> [void] - Closes the lazy reading channel\n  - LazyBlock (inner record): [LazyBlock]([long offset, int length, FileChannel channel]) -> [Block] - Represents a lazily-read block\n    - decodeElements: [decodeElements]() -> [Iterable<OsmElement>] - Decodes the block's elements when accessed",
    "Canonical_solution": "import com.onthegomap.planetiler.reader.FileFormatException;\nimport com.onthegomap.planetiler.util.ByteBufferUtil;\nimport crosby.binary.Fileformat.BlobHeader;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\nimport java.util.function.Consumer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OsmInputFile {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(OsmInputFile.class);\n\n  private final Path path;\n  private final boolean lazy;\n\n  public OsmInputFile(Path path, boolean lazyReads) {\n    this.path = path;\n    lazy = lazyReads;\n  }\n\n  private static int readInt(FileChannel channel) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(4);\n    int read = channel.read(buf);\n    if (read != 4) {\n      throw new IOException(\"Tried to read 4 bytes but only got \" + read);\n    }\n    return buf.flip().getInt();\n  }\n\n  private static byte[] readBytes(FileChannel channel, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n    ByteBuffer buf = ByteBuffer.allocate(length);\n    int read = channel.read(buf, offset);\n    if (read != length) {\n      throw new IOException(\"Tried to read \" + length + \" bytes at \" + offset + \" but only got \" + read);\n    }\n    return buf.flip().array();\n  }\n\n  private static BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n    int headerSize = readInt(channel);\n    if (headerSize > 64 * 1024) {\n      throw new IllegalArgumentException(\"Header longer than 64 KiB\");\n    }\n    byte[] headerBytes = readBytes(channel, headerSize);\n    return BlobHeader.parseFrom(headerBytes);\n  }\n\n  private FileChannel openChannel() {\n    try {\n      return FileChannel.open(path, StandardOpenOption.READ);\n    } catch (IOException e) {\n      throw new UncheckedIOException(e);\n    }\n  }\n\n  private class LazyReader implements OsmBlockSource {\n\n    final FileChannel lazyReadChannel = openChannel();\n\n    @Override\n    public void forEachBlock(Consumer<Block> consumer) {\n      try (FileChannel channel = openChannel()) {\n        final long size = channel.size();\n        while (channel.position() < size) {\n          BlobHeader header = readBlobHeader(channel);\n          int blockSize = header.getDatasize();\n          String headerType = header.getType();\n          long blockStartPosition = channel.position();\n          if (\"OSMData\".equals(headerType)) {\n            consumer.accept(new LazyBlock(blockStartPosition, blockSize, lazyReadChannel));\n          } else if (\"OSMHeader\".equals(headerType)) {\n            validateHeader(readBytes(channel, blockStartPosition, blockSize));\n          } else {\n            LOGGER.warn(\"Unrecognized OSM PBF blob header type: {}\", headerType);\n          }\n          channel.position(blockStartPosition + blockSize);\n        }\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    @Override\n    public void close() {\n      try {\n        lazyReadChannel.close();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n    }\n\n    private record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n\n      public Iterable<OsmElement> decodeElements() {\n        try {\n          var buffer = channel.map(FileChannel.MapMode.READ_ONLY, offset, length);\n          var result = PbfDecoder.decode(buffer);\n          ByteBufferUtil.free(buffer);\n          return result;\n        } catch (IOException e) {\n          throw new UncheckedIOException(e);\n        }\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\npublic class OsmInputFile {\n    private final Path path;\n    private final boolean lazy;\n    private FileChannel channel;\n\n    public OsmInputFile(Path path, boolean lazy) {\n        this.path = path;\n        this.lazy = lazy;\n    }\n\n    public FileChannel openChannel() throws IOException {\n        if (channel == null) {\n            channel = FileChannel.open(path, java.nio.file.StandardOpenOption.READ);\n        }\n        return channel;\n    }\n\n    public int readInt(FileChannel channel) throws IOException {\n        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(4);\n        int bytesRead = channel.read(buffer);\n        if (bytesRead != 4) {\n            throw new IOException(\"Unexpected end of file\");\n        }\n        buffer.flip();\n        return buffer.getInt();\n    }\n\n    public byte[] readBytes(FileChannel channel, int length) throws IOException {\n        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(length);\n        int bytesRead = channel.read(buffer);\n        if (bytesRead != length) {\n            throw new IOException(\"Unexpected end of file\");\n        }\n        buffer.flip();\n        return buffer.array();\n    }\n\n    public byte[] readBytes(FileChannel channel, long offset, int length) throws IOException {\n        channel.position(offset);\n        return readBytes(channel, length);\n    }\n\n    public BlobHeader readBlobHeader(FileChannel channel) throws IOException {\n        int magic = readInt(channel);\n        int length = readInt(channel);\n        return new BlobHeader(magic, length);\n    }\n\n    public class LazyReader implements OsmBlockSource {\n        private final FileChannel channel;\n\n        public LazyReader() {\n            this.channel = openChannel();\n        }\n\n        @Override\n        public void forEachBlock(Consumer<Block> consumer) {\n            try {\n                BlobHeader header = readBlobHeader(channel);\n                long offset = 0;\n                while (offset < header.getLength()) {\n                    int blockLength = readInt(channel);\n                    Block block = new LazyBlock(offset, blockLength, channel);\n                    consumer.accept(block);\n                    offset += blockLength;\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (channel != null) {\n                channel.close();\n            }\n        }\n    }\n\n    public record LazyBlock(long offset, int length, FileChannel channel) implements Block {\n        @Override\n        public Iterable<OsmElement> decodeElements() {\n            try {\n                byte[] data = readBytes(channel, offset, length);\n                return decode(data);\n            } catch (IOException e) {\n                throw new RuntimeException(\"Error decoding elements\", e);\n            }\n        }\n\n        private Iterable<OsmElement> decode(byte[] data) {\n            return java.util.List.of(); // Placeholder\n        }\n    }\n\n    public static class BlobHeader {\n        private final int magic;\n        private final int length;\n\n        public BlobHeader(int magic, int length) {\n            this.magic = magic;\n            this.length = length;\n        }\n\n        public int getMagic() {\n            return magic;\n        }\n\n        public int getLength() {\n            return length;\n        }\n    }\n\n    public interface OsmBlockSource {\n        void forEachBlock(Consumer<Block> consumer);\n        void close() throws IOException;\n    }\n\n    public interface Block {\n        Iterable<OsmElement> decodeElements();\n    }\n\n    public static class OsmElement {\n        // Placeholder for OsmElement\n    }\n}"
  },
  {
    "Task_id": 113,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, send messages, and handle server responses.\n\nClass Description: The TelnetClient class provides functionality to connect to a remote server using TCP, with optional SSL support. It reads input from the console, sends it to the server, and handles the connection lifecycle.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the remote server (default: \"127.0.0.1\")\n- PORT: int - The port number of the remote server (default: 8023 or 8992 for SSL)\n\nMethods:\n- start(): void - Initializes and starts the TCP client. Handles the connection setup, message sending, and connection teardown. Throws Exception if any error occurs during execution.\n  Input: None\n  Output: None (void)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic final class TelnetClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new TelnetClientInitializer(sslCtx));\n\n            Channel ch = b.connect(HOST, PORT).sync().channel();\n\n            ChannelFuture lastWriteFuture = null;\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                lastWriteFuture = ch.writeAndFlush(line + \"\\r\\n\");\n\n                if (\"bye\".equals(line.toLowerCase())) {\n                    ch.closeFuture().sync();\n                    break;\n                }\n            }\n\n            if (lastWriteFuture != null) {\n                lastWriteFuture.sync();\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.InsecureTrustManagerFactory;\nimport io.netty.util.CharsetUtil;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class TelnetClient {\n    private final boolean ssl;\n    private final String host;\n    private final int port;\n\n    public TelnetClient(boolean ssl) {\n        this.ssl = ssl;\n        this.host = \"127.0.0.1\";\n        this.port = ssl ? 8992 : 8023;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ChannelPipeline pipeline = ch.pipeline();\n                            if (ssl) {\n                                SslContext sslContext = SslContextBuilder.forClient()\n                                        .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                        .build();\n                                pipeline.addLast(sslContext.newHandler(ch.alloc()));\n                            }\n                            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new TelnetClientHandler());\n                        }\n                    });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            Channel channel = future.channel();\n\n            Thread inputThread = new Thread(() -> {\n                try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        if (line.trim().isEmpty()) continue;\n                        if (!channel.isOpen()) {\n                            System.out.println(\"Connection closed. Exiting.\");\n                            break;\n                        }\n                        channel.writeAndFlush(line + \"\\n\");\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            inputThread.start();\n\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class TelnetClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String response = (String) msg;\n            System.out.print(response);\n        }\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connected to server.\");\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Disconnected from server.\");\n        }\n    }\n}"
  },
  {
    "Task_id": 116,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a secure (optional SSL) connection to a server, send and receive serialized Java objects.\n\nClass Description: ObjectEchoClient is a Netty-based TCP client that connects to a specified server, handles SSL encryption if enabled, and processes object serialization/deserialization for communication. The client maintains the connection until explicitly closed.\n\nAttributes:\nSSL: [boolean] - Flag indicating whether SSL encryption should be used\nHOST: [String] - The host address of the server to connect to\nPORT: [int] - The port number of the server to connect to\nSIZE: [int] - The size parameter (unused in current implementation but available for configuration)\n\nMethods:\nstart: [start]() -> [void] - Initializes and starts the Netty client, establishes connection to server, configures SSL if enabled, sets up object serialization pipeline, and maintains connection until shutdown. Throws Exception if any error occurs during startup or operation.\n\nThe method performs the following operations:\n1. Creates SSL context if SSL is enabled\n2. Initializes NioEventLoopGroup for I/O operations\n3. Configures Bootstrap with NioSocketChannel\n4. Sets up pipeline with ObjectEncoder, ObjectDecoder and custom handler\n5. Connects to specified host and port\n6. Maintains connection until channel is closed\n7. Shuts down event loop group gracefully when done",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class ObjectEchoClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                    }\n                    p.addLast(\n                            new ObjectEncoder(),\n                            new ObjectDecoder(ClassResolvers.cacheDisabled(null)),\n                            new ObjectEchoClientHandler());\n                }\n             });\n\n            b.connect(HOST, PORT).sync().channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.*;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport java.util.concurrent.TimeUnit;\n\npublic class ObjectEchoClient {\n    private final boolean SSL;\n    private final String HOST;\n    private final int PORT;\n    private final int SIZE;\n\n    public ObjectEchoClient(boolean ssl, String host, int port, int size) {\n        SSL = ssl;\n        HOST = host;\n        PORT = port;\n        SIZE = size;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new ObjectEncoder());\n                        if (SSL) {\n                            SslContext sslContext = SslContextBuilder.forClient()\n                                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                .build();\n                            pipeline.addLast(sslContext.newHandler());\n                        }\n                        pipeline.addLast(new ObjectDecoder(SIZE, ClassResolvers.weakCachingConcurrentResolver(this)));\n                        pipeline.addLast(new CustomHandler());\n                    }\n                });\n            ChannelFuture future = bootstrap.connect(HOST, PORT).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class CustomHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 126,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a server, send requests, and receive responses, with optional SSL support.\n\nClass Description: FactorialClient is a Netty-based TCP client that connects to a server to calculate factorials. It handles SSL configuration, connection management, and graceful shutdown of resources.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be used\n- HOST: String - The host address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server (default: 8322)\n- COUNT: int - The number for which factorial should be calculated (default: 1000)\n\nMethods:\n- start(): void - Initializes and starts the Netty client. Configures SSL if enabled, establishes connection to server, and handles the factorial calculation request. Throws Exception if any error occurs during the process.\n  - Input: None\n  - Output: None (prints result to System.err)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class FactorialClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n    static final int COUNT = Integer.parseInt(System.getProperty(\"count\", \"1000\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new FactorialClientInitializer(sslCtx));\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n\n            FactorialClientHandler handler =\n                (FactorialClientHandler) f.channel().pipeline().last();\n\n            System.err.format(\"Factorial of %,d is: %,d\", COUNT, handler.getFactorial());\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.InsecureTrustManagerFactory;\nimport io.netty.util.CharsetUtil;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\n\npublic class FactorialClient {\n    private final boolean ssl;\n    private final String host = \"127.0.0.1\";\n    private final int port = 8322;\n    private final int count = 1000;\n\n    public FactorialClient(boolean ssl) {\n        this.ssl = ssl;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) throws Exception {\n                             ChannelPipeline pipeline = ch.pipeline();\n                             if (ssl) {\n                                 SslContext sslContext = SslContextBuilder.forClient()\n                                                                         .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                                                                         .build();\n                                 pipeline.addLast(sslContext.newHandler(ch.alloc(), host, port));\n                             }\n                             pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n                             pipeline.addLast(new ChannelInboundHandlerAdapter() {\n                                 @Override\n                                 public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                                     ctx.writeAndFlush(String.valueOf(count));\n                                 }\n\n                                 @Override\n                                 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                     if (msg instanceof String) {\n                                         System.err.println(\"Factorial result: \" + (String) msg);\n                                     }\n                                     ctx.close();\n                                 }\n\n                                 @Override\n                                 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                                     cause.printStackTrace();\n                                     ctx.close();\n                                 }\n                             });\n                         }\n                     });\n\n            ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 129,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish non-blocking connections, send messages to a server, and handle graceful shutdown.\n\nClass Description: The EchoClient class provides functionality to connect to a TCP server, send messages, and manage client resources. It uses Netty's non-blocking I/O for efficient communication.\n\nAttributes:\n- hostName: [String] - The hostname or IP address of the server to connect to\n- portNumber: [int] - The port number of the server to connect to\n- group: [EventLoopGroup] - Netty event loop group for managing I/O threads\n- channel: [Channel] - The active network channel for communication with the server\n\nMethods:\n- connect(): [void] - Establishes a connection to the specified server using Netty's Bootstrap. Initializes the event loop group and configures the client pipeline.\n- sendMessage(message: [String]): [void] - Converts the input string to a ByteBuf and sends it to the connected server through the active channel.\n- startConsoleInput(): [void] - Reads input from the console and sends it to the server line by line until terminated. Handles IO exceptions.\n- shutdown(): [void] - Gracefully shuts down the event loop group and releases all resources. Should be called when the client is no longer needed.",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic final class EchoClient {\n\n    private final String hostName;\n    private final int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() throws InterruptedException {\n        group = new NioEventLoopGroup();\n        Bootstrap b = new Bootstrap();\n        b.group(group)\n         .channel(NioSocketChannel.class)\n         .option(ChannelOption.TCP_NODELAY, true)\n         .handler(new EchoClientHandler());\n\n        ChannelFuture f = b.connect(hostName, portNumber).sync();\n        channel = f.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuffer writeBuffer = ByteBuffer.allocate(32);\n        writeBuffer.put(message.getBytes());\n        writeBuffer.flip();\n        writeBuffer.rewind();\n        \n        ByteBuf buf = Unpooled.copiedBuffer(writeBuffer);\n        channel.writeAndFlush(buf);\n        writeBuffer.clear();\n    }\n\n    public void startConsoleInput() throws IOException {\n        try (BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {\n            String userInput;\n            while ((userInput = stdIn.readLine()) != null) {\n                sendMessage(userInput);\n            }\n        } catch (UnknownHostException e) {\n            System.err.println(\"\u4e0d\u660e\u4e3b\u673a\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a \" + hostName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"\u4e0d\u80fd\u4ece\u4e3b\u673a\u4e2d\u83b7\u53d6I/O\uff0c\u4e3b\u673a\u540d\u4e3a\uff1a\" + hostName);\n            System.exit(1);\n        }\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.buffer.Unpooled;\nimport java.util.Scanner;\n\npublic class EchoClient {\n    private String hostName;\n    private int portNumber;\n    private EventLoopGroup group;\n    private Channel channel;\n\n    public EchoClient(String hostName, int portNumber) {\n        this.hostName = hostName;\n        this.portNumber = portNumber;\n    }\n\n    public void connect() {\n        group = new NioEventLoopGroup();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                });\n        ChannelFuture future = bootstrap.connect(hostName, portNumber).sync();\n        channel = future.channel();\n    }\n\n    public void sendMessage(String message) {\n        ByteBuf buf = Unpooled.copiedBuffer(message);\n        channel.writeAndFlush(buf);\n    }\n\n    public void startConsoleInput() {\n        Scanner scanner = new Scanner(System.in);\n        try {\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sendMessage(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            scanner.close();\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        group.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 134,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, handle Protocol Buffers (protobuf) message encoding/decoding, and manage connection lifecycle.\n\nClass Description: ProtobufProxy is a Netty-based TCP client implementation that connects to a specified server address and port, configures a pipeline for protobuf message processing, and manages connection resources. It implements a Proxy interface and handles graceful shutdown of network resources.\n\nMethods:\n\nconnect: [connect](String serverAddress, int port) -> void - Establishes a TCP connection to the specified server address and port. Configures the Netty pipeline with protobuf handlers and connection management components. The method blocks until the connection is closed and ensures proper resource cleanup.\n\nInput:\n- serverAddress: String - The IP address or hostname of the server to connect to\n- port: int - The TCP port number of the server\n\nOutput: None (void) - The method establishes a persistent connection that remains active until closed by either end",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.client.handler.ProtobufTransferHandler;\nimport org.nico.ratel.landlords.client.handler.SecondProtobufCodec;\nimport org.nico.ratel.landlords.entity.ClientTransferData;\nimport org.nico.ratel.landlords.print.SimplePrinter;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy implements Proxy {\n\n    @Override\n    public void connect(String serverAddress, int port) throws InterruptedException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(0, 4, 0, TimeUnit.SECONDS))\n                                    .addLast(new ProtobufVarint32FrameDecoder())\n                                    .addLast(new ProtobufDecoder(ClientTransferData.ClientTransferDataProtoc.getDefaultInstance()))\n                                    .addLast(new ProtobufVarint32LengthFieldPrepender())\n                                    .addLast(new ProtobufEncoder())\n                                    .addLast(new SecondProtobufCodec())\n                                    .addLast(new ProtobufTransferHandler());\n                        }\n                    });\n            SimplePrinter.printNotice(\"Connecting to \" + serverAddress + \":\" + port);\n            Channel channel = bootstrap.connect(serverAddress, port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class ProtobufProxy implements Proxy {\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n\n    public ProtobufProxy() {\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    @Override\n    public void connect(String serverAddress, int port) {\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) {\n                ch.pipeline().addLast(new ProtobufVarint32FrameDecoder());\n                ch.pipeline().addLast(new ProtobufDecoder(MyMessage.getDefaultInstance().getDescriptorForType()));\n                ch.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());\n                ch.pipeline().addLast(new ProtobufEncoder());\n                ch.pipeline().addLast(new SimpleChannelInboundHandler<MyMessage>() {\n                    @Override\n                    protected void channelRead0(ChannelHandlerContext ctx, MyMessage msg) {\n                        // Handle incoming message\n                        ReferenceCountUtil.release(msg);\n                    }\n                });\n            }\n        });\n\n        ChannelFuture future = bootstrap.connect(serverAddress, port).syncUnordered();\n        future.channel().closeFuture().awaitUninterruptibly();\n        group.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 139,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket client proxy using Netty framework to establish and manage WebSocket connections to a remote server.\n\nClass Description: The WebsocketProxy class implements the Proxy interface and provides functionality to connect to a WebSocket server using Netty's non-blocking I/O. It handles WebSocket protocol negotiation, connection management, and graceful shutdown of resources.\n\nAttributes: (This class doesn't have any explicit attributes as it's primarily focused on connection management)\n\nMethods:\n1: connect(String serverAddress, int port) -> void - Establishes a WebSocket connection to the specified server address and port. The method:\n   - Creates a WebSocket URI using the provided address and port\n   - Initializes Netty's event loop group and bootstrap\n   - Configures the channel pipeline with necessary handlers (idle state, HTTP codec, WebSocket protocol)\n   - Connects to the server and waits for the connection to close\n   - Ensures proper resource cleanup on shutdown\n   Throws InterruptedException if the connection is interrupted and URISyntaxException if the URI is malformed\n\nInput:\n- serverAddress: String - The IP address or hostname of the WebSocket server\n- port: int - The port number on which the WebSocket server is listening\n\nOutput: None (void) - The method establishes a persistent connection that remains open until closed by either end",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.websocketx.*;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.client.handler.WebsocketTransferHandler;\nimport org.nico.ratel.landlords.print.SimplePrinter;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n\n    @Override\n    public void connect(String serverAddress, int port) throws InterruptedException, URISyntaxException {\n        URI uri = new URI(\"ws://\" + serverAddress + \":\" + port + \"/ratel\");\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                    .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                    .addLast(new HttpClientCodec())\n                                    .addLast(new HttpObjectAggregator(8192))\n                                    .addLast(new WebSocketClientProtocolHandler(uri\n                                            , WebSocketVersion.V13\n                                            , null\n                                            , true\n                                            , new DefaultHttpHeaders(), 100000))\n                                    .addLast(\"ws\", new WebsocketTransferHandler());\n                        }\n                    });\n            SimplePrinter.printNotice(\"Connecting to \" + serverAddress + \":\" + port);\n            Channel channel = bootstrap.connect(serverAddress, port).sync().channel();\n            channel.closeFuture().sync();\n        } finally {\n            group.shutdownGracefully().sync();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.HttpClientCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker08;\nimport io.netty.handler.codec.http.websocketx.WebSocketFrame;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.concurrent.TimeUnit;\n\npublic class WebsocketProxy implements Proxy {\n    private final EventLoopGroup group;\n    private Channel channel;\n\n    public WebsocketProxy() {\n        this.group = new NioEventLoopGroup();\n    }\n\n    @Override\n    public void connect(String serverAddress, int port) throws URISyntaxException, InterruptedException {\n        URI uri = new URI(\"ws://\" + serverAddress + \":\" + port);\n        WebSocketClientHandshaker handshaker = WebSocketClientHandshaker08.create(uri, null, null, false);\n\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new IdleStateHandler(0, 0, 0, TimeUnit.SECONDS));\n                        pipeline.addLast(new HttpClientCodec());\n                        pipeline.addLast(new HttpObjectAggregator(65536));\n                        pipeline.addLast(handshaker);\n                        pipeline.addLast(new WebSocketClientHandler(handshaker));\n                    }\n                });\n\n        ChannelFuture future = bootstrap.connect(uri.getHost(), uri.getPort()).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    private class WebSocketClientHandler extends SimpleChannelInboundHandler<WebSocketFrame> {\n        private final WebSocketClientHandshaker handshaker;\n\n        public WebSocketClientHandler(WebSocketClientHandshaker handshaker) {\n            this.handshaker = handshaker;\n        }\n\n        @Override\n        public void handlerAdded(ChannelHandlerContext ctx) {\n            handshaker.handshake(ctx.channel());\n        }\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) {\n            // Handle incoming messages\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 151,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, handle incoming data, and manage connection lifecycle.\n\nClass Description: The TimeClient class establishes and manages a non-blocking TCP connection to a specified server using Netty's NIO framework. It handles connection setup, message processing through a custom pipeline, and graceful shutdown of resources.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server\nworkerGroup: EventLoopGroup - Netty's event loop group for handling I/O operations\nbootstrap: Bootstrap - Netty's client bootstrap for configuring and starting the client\n\nMethods:\nTimeClient(String host, int port) -> None - Constructor that initializes the client with target server details and creates necessary Netty components\nstart() -> void - Configures and starts the Netty client, establishes connection to server, and waits for connection closure\nstop() -> void - Shuts down the client gracefully by releasing all resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(workerGroup)\n                    .channel(NioSocketChannel.class)\n                    .option(ChannelOption.SO_KEEPALIVE, true)\n                    .handler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(new TimeDecoder());\n                            ch.pipeline().addLast(new TimeClientHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.util.CharsetUtil;\n\npublic class TimeClient {\n    private final String host;\n    private final int port;\n    private final EventLoopGroup workerGroup;\n    private final Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    public void start() {\n        try {\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) {\n                    ch.pipeline().addLast(new TimeClientHandler());\n                }\n            });\n\n            ChannelFuture future = bootstrap.connect(host, port).sync();\n            future.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class TimeClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connected to server\");\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf buf = (ByteBuf) msg;\n            byte[] data = new byte[buf.readableBytes()];\n            buf.readBytes(data);\n            String response = new String(data, CharsetUtil.UTF_8);\n            System.out.println(\"Received: \" + response);\n            buf.release();\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Connection closed\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 154,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, send messages from standard input, and handle file operations.\n\nClass Description: The FileClient class establishes a TCP connection to a specified host and port using Netty's non-blocking I/O. It configures the client pipeline with string encoders/decoders and a custom handler for file operations. The client continuously reads input from the console and sends it to the server.\n\nAttributes:\nhost: String - The hostname or IP address of the remote server to connect to\nport: int - The port number of the remote server\ndest: String - The destination path for file operations (used by the client handler)\n\nMethods:\nrun(): void - throws InterruptedException, IOException - Main method that initializes the Netty client, establishes connection, and handles message sending\n  - Input: None\n  - Output: None (but may throw InterruptedException or IOException)\n  \nFileClient(String, int, String) - Constructor that initializes the client with connection parameters\n  - Input:\n    - host: String - Server hostname/IP\n    - port: int - Server port\n    - dest: String - File destination path\n  - Output: FileClient instance (constructor)",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class FileClient {\n\n    private String host;\n    private int port;\n    private String dest;\n\n    public FileClient(String host, int port, String dest) {\n        this.host = host;\n        this.port = port;\n        this.dest = dest;\n    }\n\n    public void run() throws InterruptedException, IOException {\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(workerGroup);\n            b.channel(NioSocketChannel.class);\n            b.option(ChannelOption.SO_KEEPALIVE, true);\n            b.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n                    ch.pipeline().addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n                    ch.pipeline().addLast(new FileClientHandler(dest));\n                }\n            });\n\n            ChannelFuture f = b.connect(host, port).sync();\n            Channel channel = f.channel();\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                channel.writeAndFlush(in.readLine() + \"\\r\\n\");\n            }\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class FileClient {\n    private final String host;\n    private final int port;\n    private final String dest;\n\n    public FileClient(String host, int port, String dest) {\n        this.host = host;\n        this.port = port;\n        this.dest = dest;\n    }\n\n    public void run() throws InterruptedException, IOException {\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(group)\n                     .channel(NioSocketChannel.class)\n                     .handler(new ChannelInitializer<SocketChannel>() {\n                         @Override\n                         protected void initChannel(SocketChannel ch) throws Exception {\n                             ch.pipeline().addLast(new StringEncoder());\n                             ch.pipeline().addLast(new StringDecoder());\n                             ch.pipeline().addLast(new FileClientHandler(dest));\n                         }\n                     });\n\n            Channel channel = bootstrap.connect(host, port).sync().channel();\n\n            Scanner scanner = new Scanner(System.in);\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                channel.writeAndFlush(line + \"\\n\");\n            }\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n\n    private static class FileClientHandler extends ChannelInboundHandlerAdapter {\n        private final String dest;\n\n        public FileClientHandler(String dest) {\n            this.dest = dest;\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String received = (String) msg;\n            try (FileWriter writer = new FileWriter(dest, true)) {\n                writer.write(received);\n                writer.flush();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            super.channelRead(ctx, msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 156,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish secure or non-secure connections to a remote server, with capabilities for graceful shutdown.\n\nClass Description: The HttpUploadClient class provides functionality to create and manage a Netty-based TCP client that can connect to a specified host and port, with optional SSL/TLS encryption. It handles connection establishment, channel management, and resource cleanup.\n\nAttributes:\n- host: [String] - The hostname or IP address of the remote server to connect to\n- port: [int] - The port number of the remote server\n- ssl: [boolean] - Flag indicating whether SSL/TLS encryption should be used\n- sslCtx: [SslContext] - Netty's SSL context for secure connections (null if ssl is false)\n- group: [EventLoopGroup] - Netty event loop group for managing I/O operations\n- bootstrap: [Bootstrap] - Netty bootstrap for configuring client connection parameters\n\nMethods:\n- HttpUploadClient(String host, int port, boolean ssl) -> [Constructor] - Initializes the client with connection parameters and SSL configuration if needed\n- connect() -> [Channel] - Establishes a connection to the remote server and returns the communication channel\n- shutdown() -> [void] - Shuts down the client gracefully and releases all resources\n- main(String[] args) -> [void] - Example usage demonstrating client initialization, connection, and shutdown",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.internal.SocketUtils;\n\npublic class HttpUploadClient {\n\n    private final String host;\n    private final int port;\n    private final boolean ssl;\n    private final SslContext sslCtx;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n\n    public HttpUploadClient(String host, int port, boolean ssl) throws Exception {\n        this.host = host;\n        this.port = port;\n        this.ssl = ssl;\n        \n        if (ssl) {\n            this.sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            this.sslCtx = null;\n        }\n\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new HttpUploadClientInitializer(sslCtx));\n    }\n\n    public Channel connect() throws InterruptedException {\n        ChannelFuture future = bootstrap.connect(SocketUtils.socketAddress(host, port));\n        return future.sync().channel();\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String host = \"127.0.0.1\";\n        int port = 8080;\n        boolean ssl = false;\n\n        HttpUploadClient client = new HttpUploadClient(host, port, ssl);\n        try {\n            Channel channel = client.connect();\n            // Perform operations with the channel here\n        } finally {\n            client.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslProvider;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpUploadClient {\n    private final String host;\n    private final int port;\n    private final boolean ssl;\n    private SslContext sslCtx;\n    private EventLoopGroup group;\n    private Bootstrap bootstrap;\n\n    public HttpUploadClient(String host, int port, boolean ssl) {\n        this.host = host;\n        this.port = port;\n        this.ssl = ssl;\n        group = new NioEventLoopGroup();\n        bootstrap = new Bootstrap();\n        bootstrap.group(group);\n        bootstrap.channel(NioSocketChannel.class);\n        if (ssl) {\n            try {\n                sslCtx = SslContextBuilder.forClient()\n                    .sslProvider(SslProvider.OPENSSL)\n                    .protocols(\"TLSv1.2\")\n                    .build();\n                bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(sslCtx.newHandler(ch.alloc()));\n                    }\n                });\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to create SSL context\", e);\n            }\n        } else {\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                }\n            });\n        }\n    }\n\n    public Channel connect() {\n        ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));\n        future.addListener((ChannelFuture future1) -> {\n            if (future1.isSuccess()) {\n                System.out.println(\"Connected to server\");\n            } else {\n                System.err.println(\"Connection failed: \" + future1.cause());\n            }\n        });\n        return future.channel();\n    }\n\n    public void shutdown() {\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length < 3) {\n            System.err.println(\"Usage: java HttpUploadClient <host> <port> <ssl>\");\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        boolean ssl = Boolean.parseBoolean(args[2]);\n        HttpUploadClient client = new HttpUploadClient(host, port, ssl);\n        Channel channel = client.connect();\n        // Example usage: send data\n        // channel.writeAndFlush(\"Hello, Server!\");\n        client.shutdown();\n    }\n}"
  },
  {
    "Task_id": 158,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to connect to a remote server, handle network communication, and manage resources properly.\n\nClass Description: The TimeClient class represents a Netty-based TCP client that connects to a specified host and port. It manages network connections asynchronously using Netty's event-driven architecture and provides methods to start and stop the client connection.\n\nAttributes:\n- host: String - The hostname or IP address of the remote server to connect to\n- port: int - The port number of the remote server to connect to\n- workerGroup: EventLoopGroup - Netty's event loop group for handling I/O operations\n- bootstrap: Bootstrap - Netty's bootstrap for configuring and starting the client\n\nMethods:\n- TimeClient(String host, int port) -> None - Constructor that initializes the client with target host and port\n- start() -> void - Starts the client connection, configures the pipeline, and connects to the server\n- stop() -> void - Shuts down the client connection gracefully and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class TimeClient {\n\n    private String host;\n    private int port;\n    private EventLoopGroup workerGroup;\n    private Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(workerGroup);\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new TimeClientHandler());\n                }\n            });\n\n            ChannelFuture f = bootstrap.connect(host, port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    public void stop() {\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class TimeClient {\n    private final String host;\n    private final int port;\n    private final EventLoopGroup workerGroup;\n    private final Bootstrap bootstrap;\n\n    public TimeClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.workerGroup = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(workerGroup)\n                 .channel(NioSocketChannel.class);\n    }\n\n    public void start() {\n        bootstrap.remoteAddress(new InetSocketAddress(host, port))\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new TimeClientHandler());\n                    }\n                });\n        ChannelFuture future = bootstrap.connect().syncUninterruptibly();\n        future.channel().closeFuture().syncUninterruptibly();\n    }\n\n    public void stop() {\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class TimeClientHandler extends SimpleChannelInboundHandler<ByteBuf> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {\n            byte[] data = new byte[msg.readableBytes()];\n            msg.readBytes(data);\n            System.out.println(\"Received: \" + new String(data));\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 159,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Netty framework to establish a connection with a remote server, handle SSL/TLS if required, and process incoming/outgoing messages.\n\nClass Description: DiscardClient is a Netty-based TCP client that connects to a specified server, optionally with SSL/TLS encryption, and handles network communication through a custom handler. The client manages resources efficiently and supports graceful shutdown.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL/TLS encryption should be used\n- HOST: String - The hostname or IP address of the server to connect to (default: \"127.0.0.1\")\n- PORT: int - The port number of the server to connect to (default: 8009)\n- SIZE: int - The size parameter for communication (default: 256)\n- sslCtx: SslContext - SSL context for secure connections (nullable)\n\nMethods:\n- main(String[] args) -> void - Entry point that initializes the client, establishes connection, and manages the client lifecycle\n  - args: String[] - Command line arguments (unused in current implementation)\n- initChannel(SocketChannel ch) -> void - Configures the channel pipeline with SSL handler (if enabled) and custom client handler\n  - ch: SocketChannel - The socket channel to be initialized\n- connect() -> ChannelFuture - Establishes connection to the remote server and returns future for connection status\n- shutdown() -> void - Shuts down the client gracefully and releases all resources",
    "Canonical_solution": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n\npublic final class DiscardClient {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8009\"));\n    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            sslCtx = SslContextBuilder.forClient()\n                .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap b = new Bootstrap();\n            b.group(group)\n             .channel(NioSocketChannel.class)\n             .handler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));\n                     }\n                     p.addLast(new DiscardClientHandler());\n                 }\n             });\n\n            ChannelFuture f = b.connect(HOST, PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 3,
    "right_result": "import io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.CharsetUtil;\n\npublic class DiscardClient {\n    private final boolean ssl;\n    private final String host;\n    private final int port;\n    private final int size;\n    private final SslContext sslCtx;\n    private final EventLoopGroup group;\n    private final Bootstrap bootstrap;\n\n    public DiscardClient(boolean ssl, String host, int port, int size) {\n        this.ssl = ssl;\n        this.host = host;\n        this.port = port;\n        this.size = size;\n        this.sslCtx = ssl ? SslContextBuilder.forClient().build() : null;\n        this.group = new NioEventLoopGroup();\n        this.bootstrap = new Bootstrap();\n        bootstrap.group(group)\n                 .channel(NioSocketChannel.class)\n                 .handler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) {\n                         initChannel(ch);\n                     }\n                 });\n    }\n\n    public static void main(String[] args) {\n        DiscardClient client = new DiscardClient(true, \"127.0.0.1\", 8009, 256);\n        ChannelFuture future = client.connect();\n        future.syncUninterruptibly();\n        client.shutdown();\n    }\n\n    public ChannelFuture connect() {\n        return bootstrap.connect(host, port);\n    }\n\n    private void initChannel(SocketChannel ch) {\n        ChannelPipeline pipeline = ch.pipeline();\n        if (ssl) {\n            pipeline.addLast(sslCtx.newHandler(ch.alloc()));\n        }\n        pipeline.addLast(new DiscardClientHandler());\n    }\n\n    public void shutdown() {\n        group.shutdownGracefully();\n    }\n\n    private static class DiscardClientHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf buf = (ByteBuf) msg;\n            System.out.println(\"Received: \" + buf.toString(CharsetUtil.UTF_8));\n            buf.release();\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 165,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections, processing requests through a configurable thread pool, and managing server lifecycle.\n\nClass Description: NettyServer is a TCP server implementation that uses Netty framework for non-blocking I/O operations. It manages server connections, processes incoming requests through a thread pool, and provides lifecycle control (open/close) for the server.\n\nAttributes:\n- channelManage: [NettyServerChannelManage] - Manages active server channels and connections\n- bossGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- serverChannel: [Channel] - The main server channel listening for connections\n- messageHandler: [MessageHandler] - Handler for processing incoming messages\n- threadPoolExecutor: [ThreadPoolExecutor] - Thread pool for request processing\n- rejectCounter: [AtomicInteger] - Counter for rejected requests\n- logger: [Logger] - Logger instance for server operations\n- url: [URL] - Configuration URL containing server parameters\n- state: [ChannelState] - Current state of the server channel\n- codec: [Codec] - Codec for message serialization/deserialization\n\nMethods:\n- open() -> [boolean] - Starts the server, initializes thread pools and Netty components, binds to configured port\n- close([int] timeout) -> [void] - Shuts down the server gracefully, releasing all resources\n- cleanup() -> [void] - Internal method for resource cleanup during server shutdown\n- NettyServer([URL] url, [MessageHandler] messageHandler) - Constructor initializing server with configuration and message handler",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.hongxi.summer.common.ChannelState;\nimport org.hongxi.summer.common.SummerConstants;\nimport org.hongxi.summer.common.URLParamType;\nimport org.hongxi.summer.common.threadpool.DefaultThreadFactory;\nimport org.hongxi.summer.common.threadpool.StandardThreadPoolExecutor;\nimport org.hongxi.summer.exception.SummerFrameworkException;\nimport org.hongxi.summer.rpc.Request;\nimport org.hongxi.summer.rpc.Response;\nimport org.hongxi.summer.rpc.URL;\nimport org.hongxi.summer.transport.AbstractServer;\nimport org.hongxi.summer.transport.MessageHandler;\nimport org.hongxi.summer.transport.TransportException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NettyServer extends AbstractServer {\n    private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);\n\n    protected NettyServerChannelManage channelManage;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private MessageHandler messageHandler;\n    private ThreadPoolExecutor threadPoolExecutor;\n    private AtomicInteger rejectCounter = new AtomicInteger(0);\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        super(url);\n        this.messageHandler = messageHandler;\n    }\n\n    @Override\n    public boolean open() {\n        if (isAvailable()) {\n            logger.warn(\"server channel already open, url={}\", url);\n            return state.isAliveState();\n        }\n\n        if (bossGroup == null) {\n            bossGroup = new NioEventLoopGroup(1);\n            workerGroup = new NioEventLoopGroup();\n        }\n\n        logger.info(\"server channel start open, url={}\", url);\n        boolean shareChannel = url.getBooleanParameter(\n                URLParamType.shareChannel.getName(), URLParamType.shareChannel.boolValue());\n        int maxContentLength = url.getIntParameter(\n                URLParamType.maxContentLength.getName(), URLParamType.maxContentLength.intValue());\n        int maxServerConnections = url.getIntParameter(\n                URLParamType.maxServerConnections.getName(), URLParamType.maxServerConnections.intValue());\n        int maxQueueSize = url.getIntParameter(\n                URLParamType.workerQueueSize.getName(), URLParamType.workerQueueSize.intValue());\n\n        int minWorkerThreads;\n        int maxWorkerThreads;\n        if (shareChannel) {\n            minWorkerThreads = url.getIntParameter(URLParamType.minWorkerThreads.getName(),\n                    SummerConstants.NETTY_SHARE_CHANNEL_MIN_WORKER_THREADS);\n            maxWorkerThreads = url.getIntParameter(URLParamType.maxWorkerThreads.getName(),\n                    SummerConstants.NETTY_SHARE_CHANNEL_MAX_WORKER_THREADS);\n        } else {\n            minWorkerThreads = url.getIntParameter(URLParamType.minWorkerThreads.getName(),\n                    SummerConstants.NETTY_NOT_SHARE_CHANNEL_MIN_WORKER_THREADS);\n            maxWorkerThreads = url.getIntParameter(URLParamType.maxWorkerThreads.getName(),\n                    SummerConstants.NETTY_NOT_SHARE_CHANNEL_MAX_WORKER_THREADS);\n        }\n\n        if (threadPoolExecutor == null || threadPoolExecutor.isShutdown()) {\n            threadPoolExecutor = new StandardThreadPoolExecutor(minWorkerThreads, maxWorkerThreads,\n                    maxQueueSize, new DefaultThreadFactory(\"NettyServer-\" + url.getServerPortStr(), true));\n        }\n        threadPoolExecutor.prestartAllCoreThreads();\n\n        channelManage = new NettyServerChannelManage(maxServerConnections);\n\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        ChannelPipeline pipeline = socketChannel.pipeline();\n                        pipeline.addLast(\"channel_manage\", channelManage);\n                        pipeline.addLast(\"decoder\", new NettyDecoder(codec, NettyServer.this, maxContentLength));\n                        pipeline.addLast(\"encoder\", new NettyEncoder());\n                        pipeline.addLast(\"handler\", new NettyChannelHandler(NettyServer.this, messageHandler, threadPoolExecutor));\n                    }\n                });\n        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n        ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(url.getPort()));\n        channelFuture.syncUninterruptibly();\n        serverChannel = channelFuture.channel();\n        state = ChannelState.ALIVE;\n        logger.info(\"server channel finished open: url={}\", url);\n        return state.isAliveState();\n    }\n\n    @Override\n    public synchronized void close(int timeout) {\n        if (state.isCloseState()) return;\n\n        try {\n            cleanup();\n            if (state.isUnInitState()) {\n                logger.info(\"Server close failed, state={}, uri={}\", state.value(), url.getUri());\n                return;\n            }\n\n            state = ChannelState.CLOSE;\n            logger.info(\"Server close success, uri={}\", url.getUri());\n        } catch (Exception e) {\n            logger.error(\"Server close error, uri={}\", url.getUri(), e);\n        }\n    }\n\n    private void cleanup() {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n            bossGroup = null;\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n            workerGroup = null;\n        }\n        if (channelManage != null) {\n            channelManage.close();\n        }\n        if (threadPoolExecutor != null) {\n            threadPoolExecutor.shutdownNow();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.MessageToMessageDecoder;\nimport io.netty.handler.codec.MessageToMessageEncoder;\nimport java.net.URL;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Logger;\n\npublic class NettyServer {\n    private final URL url;\n    private final MessageHandler messageHandler;\n    private final NettyServerChannelManage channelManage;\n    private final EventLoopGroup bossGroup;\n    private final EventLoopGroup workerGroup;\n    private Channel serverChannel;\n    private final ThreadPoolExecutor threadPoolExecutor;\n    private final AtomicInteger rejectCounter;\n    private final Logger logger;\n    private ChannelState state;\n    private Codec codec;\n\n    public NettyServer(URL url, MessageHandler messageHandler) {\n        this.url = url;\n        this.messageHandler = messageHandler;\n        this.channelManage = new NettyServerChannelManage();\n        this.bossGroup = new NioEventLoopGroup(1);\n        this.workerGroup = new NioEventLoopGroup();\n        this.rejectCounter = new AtomicInteger(0);\n        this.logger = Logger.getLogger(NettyServer.class.getName());\n        this.state = ChannelState.OPEN;\n        String query = url.getQuery();\n        int corePoolSize = 10;\n        int maxPoolSize = 20;\n        if (query != null) {\n            String[] params = query.split(\"&\");\n            for (String param : params) {\n                if (param.startsWith(\"corePoolSize=\")) {\n                    corePoolSize = Integer.parseInt(param.split(\"=\")[1]);\n                } else if (param.startsWith(\"maxPoolSize=\")) {\n                    maxPoolSize = Integer.parseInt(param.split(\"=\")[1]);\n                }\n            }\n        }\n        this.threadPoolExecutor = new ThreadPoolExecutor(\n            corePoolSize,\n            maxPoolSize,\n            60L, TimeUnit.SECONDS,\n            new LinkedBlockingQueue<>(),\n            new RejectedTaskHandler(rejectCounter)\n        );\n    }\n\n    public boolean open() {\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .childHandler(new ChannelInitializer<Channel>() {\n                         @Override\n                         protected void initChannel(Channel ch) throws Exception {\n                             ch.pipeline().addLast(codec);\n                             ch.pipeline().addLast(messageHandler);\n                         }\n                     })\n                     .option(ChannelOption.SO_BACKLOG, 128)\n                     .childOption(ChannelOption.SO_KEEPALIVE, true);\n            ChannelFuture future = bootstrap.bind(url.getPort()).syncUninterruptibly();\n            serverChannel = future.channel();\n            state = ChannelState.OPEN;\n            return true;\n        } catch (Exception e) {\n            logger.severe(\"Failed to open server: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    public void close(int timeout) {\n        if (serverChannel != null) {\n            serverChannel.closeFuture().syncUninterruptibly();\n        }\n        bossGroup.shutdownGracefully(timeout, timeout, TimeUnit.SECONDS);\n        workerGroup.shutdownGracefully(timeout, timeout, TimeUnit.SECONDS);\n        cleanup();\n    }\n\n    public void cleanup() {\n        if (serverChannel != null) {\n            serverChannel.close();\n        }\n        if (threadPoolExecutor != null) {\n            threadPoolExecutor.shutdown();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n        state = ChannelState.CLOSED;\n    }\n\n    private static class RejectedTaskHandler implements RejectedExecutionHandler {\n        private final AtomicInteger rejectCounter;\n\n        public RejectedTaskHandler(AtomicInteger rejectCounter) {\n            this.rejectCounter = rejectCounter;\n        }\n\n        @Override\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n            rejectCounter.incrementAndGet();\n        }\n    }\n}"
  },
  {
    "Task_id": 168,
    "Instruction": "Task Description: Create a Java class that implements a MySQL-compatible Netty TCP server to handle client connections and MySQL protocol communication.\n\nClass Description: The MysqlNettyServer class is a Netty-based TCP server that handles MySQL protocol connections. It manages client connections, processes MySQL protocol messages, and maintains connection state. The server uses Netty's non-blocking I/O model for high performance.\n\nAttributes:\n- host: String - The host address the server binds to (nullable)\n- port: int - The port number the server listens on\n- connections: static Map<String, MysqlConnection> - Thread-safe map storing active MySQL connections by connection ID\n- eventLoopGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- server: ServerBootstrap - Netty server bootstrap instance for server configuration\n\nMethods:\n- start() -> void - Starts the Netty server, binds to the specified host and port, and begins accepting connections. Throws Exception if binding fails.\n- channelInitializer() -> ChannelInitializer<SocketChannel> - Creates and returns a channel initializer that sets up the pipeline for new connections, including handlers for MySQL protocol processing.\n- close() -> void - Shuts down the server gracefully by closing all connections and releasing resources.\n\nThe class uses Netty's NIO transport and includes handlers for:\n1. MySQL handshake protocol\n2. MySQL message decoding\n3. Connection idle state management\n4. MySQL command processing\n5. Exception handling\n\nThe server maintains thread-safe tracking of active connections and automatically cleans up closed connections.",
    "Canonical_solution": "import io.dingodb.common.concurrent.ThreadPoolBuilder;\nimport io.dingodb.driver.mysql.MysqlConnection;\nimport io.dingodb.net.netty.NettyHandlers;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioChannelOption;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.net.StandardSocketOptions;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Slf4j\n@Getter\n@Builder\npublic class MysqlNettyServer {\n    public final String host;\n    public final int port;\n    public static final Map<String, MysqlConnection> connections = new ConcurrentHashMap<>();\n\n    private EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        eventLoopGroup = new NioEventLoopGroup(151,\n            new ThreadPoolBuilder().name(\"mysql server \" + port).coreThreads(151).maximumThreads(151).build());\n        server\n            .channel(NioServerSocketChannel.class)\n            .group(eventLoopGroup)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE)\n            .childOption(NioChannelOption.of(StandardSocketOptions.SO_KEEPALIVE), Boolean.TRUE)\n            .childHandler(channelInitializer());\n        if (host != null) {\n            server.localAddress(host, port);\n        } else {\n            server.localAddress(port);\n        }\n        try {\n            server.bind().sync().await();\n        } catch (Exception e) {\n            log.error(e.getMessage(), e);\n            System.exit(-1);\n        }\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                MysqlConnection mysqlConnection = new MysqlConnection(ch);\n                ch.closeFuture().addListener(f -> {\n                    if (mysqlConnection.getId() != null) {\n                        connections.remove(mysqlConnection.getId());\n                    }\n                }).addListener(f -> mysqlConnection.close());\n                ch.pipeline().addLast(\"handshake\", new HandshakeHandler(mysqlConnection));\n                ch.pipeline().addLast(\"decoder\", new MysqlDecoder());\n                MysqlIdleStateHandler mysqlIdleStateHandler = new MysqlIdleStateHandler(\n                    28800, 60);\n                mysqlConnection.mysqlIdleStateHandler = mysqlIdleStateHandler;\n                ch.pipeline().addLast(\"idleStateHandler\", mysqlIdleStateHandler);\n                ch.pipeline()\n                    .addLast(\"mysqlHandler\", new MysqlHandler(mysqlConnection));\n                ch.pipeline().addLast(\"exception\", new NettyHandlers.ExceptionHandler());\n            }\n        };\n    }\n\n    public void close() {\n        eventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.IdleStateHandler;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.LengthFieldPrepender;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\npublic class MysqlNettyServer {\n    private final String host;\n    private final int port;\n    private final static ConcurrentHashMap<String, MysqlConnection> connections = new ConcurrentHashMap<>();\n    private final EventLoopGroup eventLoopGroup;\n    private ServerBootstrap server;\n\n    public MysqlNettyServer(String host, int port) {\n        this.host = host;\n        this.port = port;\n        this.eventLoopGroup = new NioEventLoopGroup();\n    }\n\n    public void start() throws Exception {\n        server = new ServerBootstrap();\n        server.group(eventLoopGroup)\n              .channel(NioServerSocketChannel.class)\n              .childHandler(channelInitializer())\n              .option(ChannelOption.SO_BACKLOG, 1024)\n              .childOption(ChannelOption.AUTO_READ, true);\n\n        ChannelFuture future = server.bind(new InetSocketAddress(host, port)).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    private ChannelInitializer<SocketChannel> channelInitializer() {\n        return new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ChannelPipeline pipeline = ch.pipeline();\n\n                // Add handlers for MySQL protocol\n                pipeline.addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                pipeline.addLast(new MySQLDecoder());\n                pipeline.addLast(new MySQLEncoder());\n                pipeline.addLast(new CommandHandler());\n                pipeline.addLast(new ExceptionHandler());\n\n                // Add connection tracking\n                String connectionId = ch.id().asLongText();\n                MysqlConnection connection = new MysqlConnection(ch, connectionId);\n                connections.put(connectionId, connection);\n                ch.attr(AttributeKey.valueOf(\"connectionId\")).set(connectionId);\n            }\n        };\n    }\n\n    public void close() {\n        if (server != null) {\n            server.group().shutdownGracefully();\n        }\n\n        // Close all connections\n        connections.forEach((id, conn) -> {\n            try {\n                conn.close();\n            } catch (Exception e) {\n                // Handle exception\n            }\n        });\n\n        connections.clear();\n    }\n\n    // Inner classes for handlers\n    private static class MySQLDecoder extends MessageToMessageDecoder<ByteBuf> {\n        @Override\n        protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {\n            // Decode MySQL message\n        }\n    }\n\n    private static class MySQLEncoder extends MessageToMessageEncoder<MySQLMessage> {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, MySQLMessage msg, List<Object> out) throws Exception {\n            // Encode MySQL message\n        }\n    }\n\n    private static class CommandHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            // Process MySQL command\n        }\n    }\n\n    private static class ExceptionHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 169,
    "Instruction": "Task Description: Implement a Netty-based TCP server class that handles incoming client connections and processes requests using a RESTful service configuration.\n\nClass Description: NettyRestfulService is a final class that implements a RestfulService interface, providing functionality to start and stop a Netty TCP server with configurable host and port settings. It uses Netty's NIO event loop groups for efficient connection handling and includes proper resource cleanup during shutdown.\n\nAttributes:\n- DEFAULT_WORKER_GROUP_THREADS: [int] - Default number of worker threads calculated based on available processors\n- config: [NettyRestfulServiceConfiguration] - Configuration object containing host and port settings\n- serverBootstrap: [ServerBootstrap] - Netty server bootstrap instance for server configuration\n- bossEventLoopGroup: [EventLoopGroup] - Netty event loop group for accepting connections\n- workerEventLoopGroup: [EventLoopGroup] - Netty event loop group for handling I/O operations\n\nMethods:\n- initServerBootstrap() -> [void] - Initializes the server bootstrap with event loop groups, channel type, and pipeline handlers\n- startup() -> [void] - Starts the server by binding to the configured host and port, logs success/failure\n- shutdown() -> [void] - Gracefully shuts down the server by closing event loop groups and releasing resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.NettyRuntime;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.shardingsphere.elasticjob.restful.pipeline.RestfulServiceChannelInitializer;\n\n@RequiredArgsConstructor\n@Slf4j\npublic final class NettyRestfulService implements RestfulService {\n\n    private static final int DEFAULT_WORKER_GROUP_THREADS = 1 + 2 * NettyRuntime.availableProcessors();\n\n    private final NettyRestfulServiceConfiguration config;\n\n    private ServerBootstrap serverBootstrap;\n\n    private EventLoopGroup bossEventLoopGroup;\n\n    private EventLoopGroup workerEventLoopGroup;\n\n    private void initServerBootstrap() {\n        bossEventLoopGroup = new NioEventLoopGroup();\n        workerEventLoopGroup = new NioEventLoopGroup(DEFAULT_WORKER_GROUP_THREADS);\n        serverBootstrap = new ServerBootstrap()\n                .group(bossEventLoopGroup, workerEventLoopGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new RestfulServiceChannelInitializer(config));\n    }\n\n    @SneakyThrows(InterruptedException.class)\n    @Override\n    public void startup() {\n        initServerBootstrap();\n        ChannelFuture channelFuture = serverBootstrap.bind(config.getHost(), config.getPort());\n        channelFuture.addListener(future -> {\n            if (future.isSuccess()) {\n                log.info(\"Restful Service started on port {}.\", config.getPort());\n            } else {\n                log.error(\"Failed to start Restful Service.\", future.cause());\n            }\n        }).sync();\n    }\n\n    @Override\n    public void shutdown() {\n        bossEventLoopGroup.shutdownGracefully();\n        workerEventLoopGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport java.util.concurrent.TimeUnit;\n\npublic final class NettyRestfulService implements RestfulService {\n    private final int DEFAULT_WORKER_GROUP_THREADS;\n    private final NettyRestfulServiceConfiguration config;\n    private ServerBootstrap serverBootstrap;\n    private EventLoopGroup bossEventLoopGroup;\n    private EventLoopGroup workerEventLoopGroup;\n\n    public NettyRestfulService(NettyRestfulServiceConfiguration config) {\n        this.config = config;\n        this.DEFAULT_WORKER_GROUP_THREADS = Runtime.getRuntime().availableProcessors();\n        initServerBootstrap();\n    }\n\n    private void initServerBootstrap() {\n        bossEventLoopGroup = new NioEventLoopGroup(1);\n        workerEventLoopGroup = new NioEventLoopGroup(DEFAULT_WORKER_GROUP_THREADS);\n        serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(bossEventLoopGroup, workerEventLoopGroup)\n                      .channel(NioServerSocketChannel.class)\n                      .childHandler(new ChannelInitializer<SocketChannel>() {\n                          @Override\n                          protected void initChannel(SocketChannel ch) throws Exception {\n                              ch.pipeline().addLast(new HttpServerCodec());\n                              ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                              ch.pipeline().addLast(new MyRestfulHandler());\n                          }\n                      });\n    }\n\n    @Override\n    public void startup() {\n        try {\n            ChannelFuture future = serverBootstrap.bind(config.getHost(), config.getPort()).sync();\n            if (future.isSuccess()) {\n                System.out.println(\"Server started on \" + config.getHost() + \":\" + config.getPort());\n            } else {\n                System.err.println(\"Failed to start server\");\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            System.err.println(\"Server startup interrupted\");\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        try {\n            if (serverBootstrap != null) {\n                serverBootstrap.group().shutdownGracefully(0, 10, TimeUnit.SECONDS);\n            }\n            if (bossEventLoopGroup != null) {\n                bossEventLoopGroup.shutdownGracefully(0, 10, TimeUnit.SECONDS);\n            }\n            if (workerEventLoopGroup != null) {\n                workerEventLoopGroup.shutdownGracefully(0, 10, TimeUnit.SECONDS);\n            }\n            System.out.println(\"Server shutdown completed\");\n        } catch (Exception e) {\n            System.err.println(\"Error during server shutdown: \" + e.getMessage());\n        }\n    }\n}"
  },
  {
    "Task_id": 17,
    "Instruction": "Task Description: Create a Java class that provides file channel operations using Java NIO's FileChannel for efficient file I/O operations, including reading, writing, positioning, truncating, and memory mapping.\n\nClass Description: TranslogFileChannel is a wrapper class for FileChannel that simplifies file operations while maintaining the performance benefits of Java NIO. It implements Closeable to ensure proper resource cleanup.\n\nAttributes:\n- location: Path - The file path associated with the FileChannel\n- channel: FileChannel - The underlying FileChannel instance for performing I/O operations\n\nMethods:\n- TranslogFileChannel(Path location) -> void - Constructor that opens a FileChannel for both reading and writing at the specified path\n- write(ByteBuffer src) -> void - Writes data from the given ByteBuffer to the file\n- read(ByteBuffer dst) -> int - Reads data from the file into the given ByteBuffer, returning the number of bytes read\n- position() -> long - Returns the current position in the file\n- position(long newPosition) -> void - Sets the position in the file\n- size() -> long - Returns the current size of the file\n- truncate(long size) -> void - Truncates the file to the specified size\n- force(boolean metaData) -> void - Forces any updates to be written to the storage device\n- transferTo(long position, long count, WritableByteChannel target) -> long - Transfers bytes from this channel to the given writable channel\n- transferFrom(ReadableByteChannel src, long position, long count) -> long - Transfers bytes into this channel from the given readable channel\n- map(FileChannel.MapMode mode, long position, long size) -> MappedByteBuffer - Maps a region of this channel's file directly into memory\n- close() -> void - Closes the FileChannel and releases associated resources",
    "Canonical_solution": "import java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\n\npublic class TranslogFileChannel implements Closeable {\n\n    private final Path location;\n    private FileChannel channel;\n\n    public TranslogFileChannel(Path location) throws IOException {\n        this.location = location;\n        this.channel = FileChannel.open(location, StandardOpenOption.READ, StandardOpenOption.WRITE);\n    }\n\n    public void write(ByteBuffer src) throws IOException {\n        channel.write(src);\n    }\n\n    public int read(ByteBuffer dst) throws IOException {\n        return channel.read(dst);\n    }\n\n    public long position() throws IOException {\n        return channel.position();\n    }\n\n    public void position(long newPosition) throws IOException {\n        channel.position(newPosition);\n    }\n\n    public long size() throws IOException {\n        return channel.size();\n    }\n\n    public void truncate(long size) throws IOException {\n        channel.truncate(size);\n    }\n\n    public void force(boolean metaData) throws IOException {\n        channel.force(metaData);\n    }\n\n    public long transferTo(long position, long count, WritableByteChannel target) throws IOException {\n        return channel.transferTo(position, count, target);\n    }\n\n    public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {\n        return channel.transferFrom(src, position, count);\n    }\n\n    public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {\n        return channel.map(mode, position, size);\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.channels.FileChannel;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.WritableByteChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.io.Closeable;\nimport java.io.IOException;\n\npublic class TranslogFileChannel implements Closeable {\n    private final Path location;\n    private final FileChannel channel;\n\n    public TranslogFileChannel(Path location) throws IOException {\n        this.location = location;\n        this.channel = FileChannel.open(location, StandardOpenOption.READ, StandardOpenOption.WRITE);\n    }\n\n    public void write(ByteBuffer src) throws IOException {\n        channel.write(src);\n    }\n\n    public int read(ByteBuffer dst) throws IOException {\n        return channel.read(dst);\n    }\n\n    public long position() throws IOException {\n        return channel.position();\n    }\n\n    public void position(long newPosition) throws IOException {\n        channel.position(newPosition);\n    }\n\n    public long size() throws IOException {\n        return channel.size();\n    }\n\n    public void truncate(long size) throws IOException {\n        channel.truncate(size);\n    }\n\n    public void force(boolean metaData) throws IOException {\n        channel.force(metaData);\n    }\n\n    public long transferTo(long position, long count, WritableByteChannel target) throws IOException {\n        return channel.transferTo(position, count, target);\n    }\n\n    public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {\n        return channel.transferFrom(src, position, count);\n    }\n\n    public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {\n        return channel.map(mode, position, size);\n    }\n\n    @Override\n    public void close() throws IOException {\n        channel.close();\n    }\n}"
  },
  {
    "Task_id": 171,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using the Netty framework to handle incoming client connections and process requests.\n\nClass Description: The `JacksonServer` class is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and includes logging for monitoring server activity. The server is designed to be gracefully shutdown when no longer needed.\n\nAttributes:\n- PORT: [int] - The port number on which the server will listen for incoming connections (default: 8082).\n\nMethods:\n- start(): [void] - Initializes and starts the Netty TCP server. It sets up the server configuration, binds to the specified port, and keeps the server running until it is shutdown. This method throws Exception if any error occurs during server startup or operation.\n  - Input: None\n  - Output: None (but may throw Exception)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class JacksonServer {\n\n    static final int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new JacksonServerInitializer());\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport java.net.InetSocketAddress;\n\npublic class JacksonServer {\n    private int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                     ch.pipeline().addLast(new StringDecoder());\n                     ch.pipeline().addLast(new StringEncoder());\n                     ch.pipeline().addLast(new SimpleHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(new InetSocketAddress(PORT)).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class SimpleHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        JacksonServer server = new JacksonServer();\n        server.start();\n    }\n}"
  },
  {
    "Task_id": 179,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and manage heartbeat detection.\n\nClass Description: The HeartbeatServer class is a Netty-based TCP server that listens for incoming connections on a specified port, manages client connections using boss and worker event loop groups, and includes proper startup and shutdown procedures.\n\nAttributes:\n- PORT: [static final int] - The port number on which the server will listen for connections\n- bossGroup: [EventLoopGroup] - The parent event loop group that accepts incoming connections\n- workerGroup: [EventLoopGroup] - The child event loop group that handles the traffic of accepted connections\n- bootstrap: [ServerBootstrap] - The server configuration object that binds the server components together\n\nMethods:\n- HeartbeatServer() -> [constructor] - Initializes the server components including event loop groups and server bootstrap\n- start() throws Exception -> [void] - Configures and starts the server, binds to the specified port, and begins accepting connections\n- stop() -> [void] - Shuts down the server gracefully by closing all event loop groups",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class HeartbeatServer {\n    static final int PORT = 8082;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public HeartbeatServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start() throws Exception {\n        try {\n            bootstrap.group(bossGroup, workerGroup)\n                     .channel(NioServerSocketChannel.class)\n                     .option(ChannelOption.SO_BACKLOG, 100)\n                     .handler(new LoggingHandler(LogLevel.INFO))\n                     .childHandler(new HeartbeatHandlerInitializer());\n\n            ChannelFuture f = bootstrap.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            stop();\n        }\n    }\n\n    public void stop() {\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport java.util.concurrent.TimeUnit;\n\npublic class HeartbeatServer {\n    public static final int PORT = 8080;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private ServerBootstrap bootstrap;\n\n    public HeartbeatServer() {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        bootstrap = new ServerBootstrap();\n    }\n\n    public void start() throws Exception {\n        bootstrap.group(bossGroup, workerGroup)\n                 .channel(NioServerSocketChannel.class)\n                 .childHandler(new ChannelInitializer<SocketChannel>() {\n                     @Override\n                     protected void initChannel(SocketChannel ch) {\n                         ch.pipeline().addLast(new StringDecoder());\n                         ch.pipeline().addLast(new StringEncoder());\n                         ch.pipeline().addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                         ch.pipeline().addLast(new HeartbeatHandler());\n                     }\n                 })\n                 .option(ChannelOption.SO_BACKLOG, 128)\n                 .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n        ChannelFuture future = bootstrap.bind(PORT).sync();\n        future.channel().closeFuture().sync();\n    }\n\n    public void stop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class HeartbeatHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n            System.out.println(\"Received message: \" + msg);\n            if (msg.equals(\"HEARTBEAT\")) {\n                ctx.writeAndFlush(\"HEARTBEAT_ACK\");\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent e = (IdleStateEvent) evt;\n                System.out.println(\"Idle event: \" + e.state());\n                ctx.close();\n            }\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n}"
  },
  {
    "Task_id": 181,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that can handle HTTP requests and responses efficiently with proper resource management.\n\nClass Description: NettyTCPServer is a class that creates and manages a TCP server using Netty framework. It handles HTTP protocol communication with clients, including request decoding, response encoding, chunked writes, and message aggregation. The server is designed to be non-blocking and supports graceful shutdown.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\nchannel: Channel - The server's communication channel\nbossGroup: EventLoopGroup - The parent event loop group that accepts incoming connections\nworkerGroup: EventLoopGroup - The child event loop group that handles the traffic of accepted connections\n\nMethods:\nstart(): void - Starts the TCP server on the specified port. Initializes event loop groups, configures server bootstrap with HTTP handlers, and binds to the port. Throws InterruptedException if interrupted during startup.\nshutdown(): void - Gracefully shuts down the server by closing the channel and shutting down event loop groups. Handles any InterruptedException during shutdown.\n\nThe class uses Netty's NIO transport and includes HTTP-specific handlers for proper protocol handling. It maintains proper resource management through graceful shutdown mechanisms.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyTCPServer {\n\n    private static final Logger Logger = LoggerFactory.getLogger(NettyTCPServer.class);\n    private int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyTCPServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(2);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            final ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .option(ChannelOption.SO_BACKLOG, 10240)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .option(ChannelOption.SO_REUSEADDR, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childOption(ChannelOption.SO_SNDBUF, 1024*64)\n                .childOption(ChannelOption.SO_RCVBUF, 1024*64)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception {\n                        socketChannel.pipeline().addLast(new HttpRequestDecoder());\n                        socketChannel.pipeline().addLast(new HttpResponseEncoder());\n                        socketChannel.pipeline().addLast(new ChunkedWriteHandler());\n                        socketChannel.pipeline().addLast(new HttpObjectAggregator(100 * 1024 * 1024));\n                    }\n                });\n\n            channel = b.bind(port).sync().channel();\n            Logger.info(\"Server started on port {}\", port);\n        } catch (Exception e) {\n            Logger.error(\"Failed to start server on port {}: {}\", port, e.getMessage());\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n            try {\n                channel.closeFuture().sync();\n            } catch (InterruptedException e) {\n                Logger.error(\"Error during server shutdown: {}\", e.getMessage());\n            }\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.CharsetUtil;\nimport java.net.InetSocketAddress;\n\npublic class NettyTCPServer {\n    private final int port;\n    private Channel channel;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public NettyTCPServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(65536));\n                     p.addLast(new ChunkedWriteHandler());\n                     p.addLast(new HttpServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            channel = b.bind(port).sync().channel();\n            System.out.println(\"Server started on port \" + port);\n        } catch (Exception e) {\n            e.printStackTrace();\n            shutdown();\n            throw e;\n        }\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class HttpServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof FullHttpRequest) {\n                FullHttpRequest request = (FullHttpRequest) msg;\n                FullHttpResponse response = new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                    Unpooled.copiedBuffer(\"Hello from Netty Server\", CharsetUtil.UTF_8)\n                );\n                response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n                response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());\n                ctx.writeAndFlush(response);\n            }\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 184,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages. The server should support optional SSL encryption and be configurable via system properties.\n\nClass Description: EchoServer is a Netty-based TCP server that listens for incoming connections on a specified port and echoes back any received data. It supports optional SSL encryption and uses NIO for non-blocking I/O operations.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL encryption should be enabled (configured via system property \"ssl\")\n- PORT: int - The port number on which the server will listen (configured via system property \"port\", defaults to 8007)\n\nMethods:\n- start(): void - Starts the Netty TCP server, configures SSL if enabled, sets up event loop groups, and binds to the specified port. Throws Exception if any error occurs during startup.\n  - Input: None\n  - Output: None (void)\n  - Description: Initializes the server with boss and worker event loop groups, configures the server bootstrap with channel options and handlers, and starts listening for incoming connections. The method blocks until the server channel is closed.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class EchoServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (sslCtx != null) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(serverHandler);\n                 }\n             });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\n\npublic class EchoServer {\n    private final boolean ssl;\n    private final int port;\n\n    public EchoServer() {\n        this.ssl = Boolean.getBoolean(\"ssl\");\n        this.port = Integer.getInteger(\"port\", 8007);\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.TCP_NODELAY, true)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\n                         ssl ? new SslHandler(createSslContext()) : null,\n                         new StringDecoder(),\n                         new StringEncoder(),\n                         new EchoServerHandler()\n                     );\n                 }\n             });\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private SslContext createSslContext() throws Exception {\n        return SslContextBuilder.forServer()\n                .sslProvider(SslProvider.OPENSSL)\n                .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                .build();\n    }\n\n    static class EchoServerHandler extends io.netty.channel.ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String received = (String) msg;\n            System.out.println(\"Received: \" + received);\n            ctx.writeAndFlush(received);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 188,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process their requests.\n\nClass Description: The MyServer class represents a Netty-based TCP server that listens on a specified port, accepts client connections, and processes incoming data through a configured pipeline of handlers.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nMyServer: [constructor](int port) -> void - Initializes the server with the specified port number\nrun: [method]() throws Exception -> void - Starts the server, binds to the configured port, and begins accepting client connections. Sets up the server bootstrap with worker threads, channel type, and handler pipeline. Includes proper resource cleanup on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class MyServer {\n\n    private int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"logging\", new LoggingHandler(LogLevel.INFO));\n                     ch.pipeline().addLast(\"codec\", new MyCodec());\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            System.out.println(\"Server start listen at \" + port);\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class MyServer {\n    private final int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new DiscardServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class DiscardServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ReferenceCountUtil.release(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 189,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling telnet connections with optional SSL encryption.\n\nClass Description: The TelnetServer class is a Netty-based TCP server implementation that listens for incoming telnet connections. It supports optional SSL encryption and provides graceful shutdown capabilities. The server uses a boss-worker thread model for handling connections efficiently.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n\nMethods:\n- start(): [void] throws [Exception] - Initializes and starts the TCP server. Configures SSL if enabled, sets up event loop groups, and binds to the specified port. The method blocks until the server is shut down.\n  - Input: None\n  - Output: None (but may throw exceptions during server setup or operation)\n  - Side effects: Starts a TCP server that listens for incoming connections and processes them using the configured pipeline handlers",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class TelnetServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8992\" : \"8023\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new TelnetServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.CharsetUtil;\n\npublic class TelnetServer {\n    private final boolean SSL;\n    private final int PORT;\n\n    public TelnetServer(boolean ssl, int port) {\n        this.SSL = ssl;\n        this.PORT = port;\n    }\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (SSL) {\n                         SslContext sslContext = SslContextBuilder.forServer()\n                             .sslProvider(SslProvider.OPENSSL)\n                             .build();\n                         p.addLast(sslContext.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new LineBasedFrameDecoder(8192));\n                     p.addLast(new StringDecoder(CharsetUtil.UTF_8));\n                     p.addLast(new TelnetServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class TelnetServerHandler extends SimpleChannelInboundHandler<String> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n            System.out.println(\"Received: \" + msg);\n            ctx.writeAndFlush(msg);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 203,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections, process requests, and manage server resources efficiently.\n\nClass Description: The MyServer class represents a Netty-based TCP server that listens on a specified port, handles incoming connections using NIO, processes client requests through a pipeline of handlers, and properly manages server resources during startup and shutdown.\n\nAttributes:\nport: int - The port number on which the server will listen for incoming connections\n\nMethods:\nMyServer(int port) -> None - Constructor that initializes the server with the specified port number\nrun() throws Exception -> void - Starts the Netty server, configures the server bootstrap with event loop groups, channel type, pipeline handlers, and socket options. Binds to the specified port and keeps the server running until shutdown is triggered. Properly releases resources during shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class MyServer {\n\n    private int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(\"decoder\", new MyDecoder());\n                     ch.pipeline().addLast(\"encoder\", new MyEncoder());\n                     ch.pipeline().addLast(new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\n\npublic class MyServer {\n    private final int port;\n\n    public MyServer(int port) {\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ch.pipeline().addLast(new StringDecoder(), new StringEncoder(), new MyServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128);\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class MyServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client connected\");\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            String request = (String) msg;\n            System.out.println(\"Received: \" + request);\n            ctx.writeAndFlush(\"Server received: \" + request);\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client disconnected\");\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new MyServer(8080).run();\n    }\n}"
  },
  {
    "Task_id": 205,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of handling incoming client connections and messages, with proper initialization and graceful shutdown.\n\nClass Description: NettyServer is a Spring component that sets up and manages a Netty-based TCP server. It handles server lifecycle including startup and shutdown, and delegates incoming connection handling to a specified handler initializer.\n\nAttributes:\n- logger: Logger - SLF4J logger for logging server events\n- port: Integer - Port number on which the server will listen (injected from configuration)\n- nettyServerHandlerInitializer: NettyServerHandlerInitializer - Handler for initializing channel pipelines (Spring-injected)\n- bossGroup: EventLoopGroup - Netty event loop group for accepting connections\n- workerGroup: EventLoopGroup - Netty event loop group for handling I/O operations\n- channel: Channel - Active server channel instance\n\nMethods:\n- start() -> void - Initializes and starts the Netty server (annotated with @PostConstruct)\n  - Input: None\n  - Output: None\n  - Throws: InterruptedException if thread is interrupted during startup\n- shutdown() -> void - Gracefully shuts down the server (annotated with @PreDestroy)\n  - Input: None\n  - Output: None",
    "Canonical_solution": "import cn.iocoder.springboot.lab67.nettyserverdemo.server.handler.NettyServerHandlerInitializer;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.net.InetSocketAddress;\n\n@Component\npublic class NettyServer {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Value(\"${netty.port}\")\n    private Integer port;\n\n    @Autowired\n    private NettyServerHandlerInitializer nettyServerHandlerInitializer;\n\n    private EventLoopGroup bossGroup = new NioEventLoopGroup();\n    private EventLoopGroup workerGroup = new NioEventLoopGroup();\n    private Channel channel;\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .localAddress(new InetSocketAddress(port))\n                .option(ChannelOption.SO_BACKLOG, 1024)\n                .childOption(ChannelOption.SO_KEEPALIVE, true)\n                .childOption(ChannelOption.TCP_NODELAY, true)\n                .childHandler(nettyServerHandlerInitializer);\n        ChannelFuture future = bootstrap.bind().sync();\n        if (future.isSuccess()) {\n            channel = future.channel();\n            logger.info(\"[start][Netty Server started on port {}]\", port);\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\n@Component\npublic class NettyServer {\n    private static final Logger logger = LoggerFactory.getLogger(NettyServer.class);\n    private final int port;\n    private final NettyServerHandlerInitializer nettyServerHandlerInitializer;\n\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n    private Channel channel;\n\n    @Autowired\n    public NettyServer(int port, NettyServerHandlerInitializer nettyServerHandlerInitializer) {\n        this.port = port;\n        this.nettyServerHandlerInitializer = nettyServerHandlerInitializer;\n    }\n\n    @PostConstruct\n    public void start() throws InterruptedException {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(nettyServerHandlerInitializer)\n             .option(ChannelOption.SO_BACKLOG, 1024)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            channel = b.bind(port).sync().channel();\n            logger.info(\"Netty server started on port {}\", port);\n        } catch (Exception e) {\n            logger.error(\"Failed to start Netty server\", e);\n            shutdown();\n            throw e;\n        }\n    }\n\n    @PreDestroy\n    public void shutdown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        logger.info(\"Netty server shut down gracefully\");\n    }\n}"
  },
  {
    "Task_id": 207,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process their requests.\n\nClass Description: UptimeServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It uses a boss-worker thread model to handle connections efficiently and includes logging for server events. The server remains active until explicitly shut down.\n\nAttributes:\n- PORT: int - The port number on which the server listens for incoming connections (default: 8080)\n- handler: UptimeServerHandler - The custom handler that processes incoming client requests\n\nMethods:\n- main: main(String[] args) -> void - The entry point of the application that configures and starts the Netty server\n  - args: String[] - Command line arguments (unused in this implementation)\n  - throws Exception - May throw exceptions during server startup or operation\n\nThe server uses two NioEventLoopGroups:\n1. bossGroup: Handles accepting new connections\n2. workerGroup: Handles processing of established connections\n\nThe server configuration includes:\n- Channel type: NioServerSocketChannel\n- Logging handler: LogLevel.INFO\n- Custom channel initializer that adds the UptimeServerHandler to the pipeline\n\nThe server binds to the specified port and remains running until shutdown. Resources are cleaned up gracefully on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class UptimeServer {\n    private static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n    private static final UptimeServerHandler handler = new UptimeServerHandler();\n\n    public static void main(String[] args) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(handler);\n                        }\n                    });\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.logging LogLevel;\n\npublic class UptimeServer {\n    private static final int PORT = 8080;\n\n    public static void main(String[] args) throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));\n                     ch.pipeline().addLast(new UptimeServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 214,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle client connections and process requests, with optional SSL support for secure communication.\n\nClass Description: FactorialServer is a Netty-based TCP server that listens on a specified port for incoming client connections. It supports optional SSL encryption and uses a boss-worker thread model for efficient connection handling. The server remains active until explicitly shut down, gracefully releasing all resources upon termination.\n\nAttributes:\n- SSL: [boolean] - Flag indicating whether SSL encryption should be enabled\n- PORT: [int] - The port number on which the server will listen for connections\n- sslCtx: [SslContext] - SSL context for secure communication (nullable)\n\nMethods:\n- main: [main(String[] args)] -> [void] - Entry point that initializes and starts the server. Handles SSL configuration if enabled, sets up event loop groups, configures server bootstrap, and manages server lifecycle.\n  - Input: String[] args - Command line arguments\n  - Output: void",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class FactorialServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8322\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new FactorialServerInitializer(sslCtx));\n\n            b.bind(PORT).sync().channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.ReferenceCountUtil;\n\nimport java.net.InetSocketAddress;\n\npublic class FactorialServer {\n    private static boolean ssl;\n    private static int port;\n    private static SslContext sslCtx;\n\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java FactorialServer <port> <ssl>\");\n            System.exit(1);\n        }\n\n        port = Integer.parseInt(args[0]);\n        ssl = Boolean.parseBoolean(args[1]);\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (ssl) {\n                         p.addLast(sslCtx.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new FactorialServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            if (ssl) {\n                try {\n                    sslCtx = SslContextBuilder.forServer(\"keystore.jks\", \"password\").build();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n\n            ChannelFuture f = b.bind(new InetSocketAddress(port)).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class FactorialServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            ByteBuf in = (ByteBuf) msg;\n            try {\n                byte[] data = new byte[in.readableBytes()];\n                in.readBytes(data);\n                String request = new String(data, CharsetUtil.UTF_8);\n                String response = \"Received: \" + request;\n                ByteBuf out = ctx.alloc().buffer();\n                out.writeBytes(response.getBytes(CharsetUtil.UTF_8));\n                ctx.writeAndFlush(out);\n            } finally {\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 215,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP file uploads, with optional SSL support for secure connections.\n\nClass Description: HttpUploadServer is a Netty-based server that listens for incoming HTTP connections and handles file upload requests. It supports both secure (HTTPS) and non-secure (HTTP) connections, configurable via system properties.\n\nAttributes:\n- SSL: boolean - Flag indicating whether SSL should be enabled (read from system property \"ssl\")\n- PORT: int - The port number the server will listen on (read from system property \"port\", defaults to 8443 for SSL or 8080 for non-SSL)\n\nMethods:\n- main(String[] args) -> void - Entry point of the application that sets up and runs the Netty server\n  - args: String[] - Command line arguments (not directly used)\n  - return: void\n\nThe method performs the following operations:\n1. Configures SSL context if SSL is enabled\n2. Creates event loop groups for handling connections\n3. Sets up server bootstrap with channel type and handlers\n4. Binds to the specified port and starts the server\n5. Keeps the server running until shutdown\n6. Cleans up resources on shutdown",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpUploadServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public static void main(String[] args) throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.handler(new LoggingHandler(LogLevel.INFO));\n            b.childHandler(new HttpUploadServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.buffer.Unpooled;\nimport io.netty.util.CharsetUtil;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.util.concurrent.TimeUnit;\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.TrustManagerFactory;\n\npublic class HttpUploadServer {\n    private static final int MAX_CONTENT_LENGTH = 1024 * 1024 * 10; // 10 MB\n    private final boolean ssl;\n    private final int port;\n\n    public HttpUploadServer(boolean ssl, int port) {\n        this.ssl = ssl;\n        this.port = port;\n    }\n\n    public void run() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            SslContext sslContext = null;\n            if (ssl) {\n                sslContext = SslContextBuilder.forServer()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .keyManager(loadKeyStore())\n                    .build();\n            }\n\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.TCP_NODELAY, true)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     if (ssl) {\n                         p.addLast(sslContext.newHandler(ch.alloc()));\n                     }\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(MAX_CONTENT_LENGTH));\n                     p.addLast(new ChunkedWriteHandler());\n                     p.addLast(new UploadHandler());\n                 }\n             });\n\n            ChannelFuture f = b.bind(new InetSocketAddress(port)).sync();\n            System.out.println(\"Server started on port \" + port + (ssl ? \" (SSL)\" : \"\"));\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private KeyManager[] loadKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n        keyStore.load(getClass().getResourceAsStream(\"/keystore.jks\"), \"password\".toCharArray());\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n        keyManagerFactory.init(keyStore, \"password\".toCharArray());\n        return keyManagerFactory.getKeyManagers();\n    }\n\n    public static void main(String[] args) throws Exception {\n        boolean ssl = Boolean.getBoolean(\"ssl\");\n        int port = Integer.getInteger(\"port\", ssl ? 8443 : 8080);\n        new HttpUploadServer(ssl, port).run();\n    }\n\n    static class UploadHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof HttpRequest) {\n                HttpRequest request = (HttpRequest) msg;\n                if (request.method().equals(\"POST\")) {\n                    // Handle file upload logic here\n                    DefaultFullHttpResponse response = new DefaultFullHttpResponse(\n                        HttpVersion.HTTP_1_1, HttpResponseStatus.OK,\n                        Unpooled.copiedBuffer(\"File uploaded successfully\", CharsetUtil.UTF_8));\n                    response.headers().set(\"Content-Type\", \"text/plain\");\n                    ctx.writeAndFlush(response);\n                }\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 216,
    "Instruction": "Task Description: Create a Java class that implements an HTTP test server using Netty framework to handle incoming HTTP requests, process them with a custom handler, and return appropriate responses.\n\nClass Description: HttpTestServer is a Netty-based HTTP server designed for testing purposes. It handles incoming HTTP requests, processes them using a customizable request handler, and returns JSON responses. The server can be configured to simulate failures and include custom headers in responses.\n\nAttributes:\n- port: int - The port number on which the server will listen\n- fail: boolean - Flag to determine if server should respond with failure status\n- requestHandler: BiConsumer<HttpRequest, JsonGenerator> - Custom handler for processing requests and generating JSON responses\n- headers: Map<String, String> - Optional custom headers to include in responses\n- channel: Channel - Netty channel for server communication\n- group: NioEventLoopGroup - Netty event loop group for handling I/O operations\n- responses: List<String> - Stores all generated responses for testing purposes\n- JSON_FACTORY: JsonFactory - Static Jackson JSON factory for JSON processing\n\nMethods:\n- HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, Map<String, String> headers) - Constructor with all parameters\n- HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) - Constructor without headers parameter\n- run() -> void - Starts the server and binds it to the specified port\n- boundPort() -> int - Returns the actual port the server is bound to\n- shutDown() -> void - Gracefully shuts down the server and releases resources\n- HttpTestServerHandler (inner class) - Handles incoming HTTP requests and generates responses",
    "Canonical_solution": "import java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.jetbrains.annotations.Nullable;\n\nimport com.fasterxml.jackson.core.JsonEncoding;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParser;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.HttpContentCompressor;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpRequestDecoder;\nimport io.netty.handler.codec.http.HttpResponseEncoder;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class HttpTestServer {\n\n    private final int port;\n    private final boolean fail;\n    private final BiConsumer<HttpRequest, JsonGenerator> requestHandler;\n    private static final JsonFactory JSON_FACTORY;\n    private Channel channel;\n    private NioEventLoopGroup group;\n    public List<String> responses = new ArrayList<>();\n    @Nullable\n    private final Map<String, String> headers;\n\n    static {\n        JSON_FACTORY = new JsonFactory();\n        JSON_FACTORY.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n        JSON_FACTORY.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n        JSON_FACTORY.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, @Nullable Map<String, String> headers) {\n        this.port = port;\n        this.fail = fail;\n        this.requestHandler = requestHandler;\n        this.headers = headers;\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) {\n        this(port, fail, requestHandler, null);\n    }\n\n    public void run() throws InterruptedException {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        group = new NioEventLoopGroup();\n        bootstrap.group(group);\n        bootstrap.channel(NioServerSocketChannel.class);\n        bootstrap.childHandler(new ChannelInitializer<Channel>() {\n            @Override\n            protected void initChannel(Channel ch) {\n                ChannelPipeline pipeline = ch.pipeline();\n                pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n                pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n                pipeline.addLast(\"deflater\", new HttpContentCompressor());\n                pipeline.addLast(\"handler\", new HttpTestServerHandler());\n            }\n        });\n        channel = bootstrap.bind(new InetSocketAddress(port)).sync().channel();\n    }\n\n    public int boundPort() {\n        InetSocketAddress localAddress = (InetSocketAddress) channel.localAddress();\n        return localAddress.getPort();\n    }\n\n    public void shutDown() {\n        channel.close().awaitUninterruptibly();\n        if (group != null) {\n            group.shutdownGracefully().awaitUninterruptibly();\n            group.terminationFuture().awaitUninterruptibly();\n            group = null;\n        }\n    }\n\n    @ChannelHandler.Sharable\n    public class HttpTestServerHandler extends SimpleChannelInboundHandler<Object> {\n        private final Logger logger = LogManager.getLogger(HttpTestServerHandler.class.getName());\n\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n            if (!(msg instanceof HttpRequest)) {\n                ctx.fireChannelRead(msg);\n                return;\n            }\n            try {\n                handleHttpRequest(ctx, (HttpRequest) msg);\n            } finally {\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        private void handleHttpRequest(ChannelHandlerContext ctx, HttpRequest msg) throws UnsupportedEncodingException {\n            String uri = msg.uri();\n            logger.debug(\"Got Request for \" + uri);\n            HttpResponseStatus status = fail ? HttpResponseStatus.BAD_REQUEST : HttpResponseStatus.OK;\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            try {\n                JsonGenerator generator = JSON_FACTORY.createGenerator(out, JsonEncoding.UTF8);\n                requestHandler.accept(msg, generator);\n            } catch (Exception ex) {\n                status = HttpResponseStatus.INTERNAL_SERVER_ERROR;\n            }\n            ByteBuf byteBuf = Unpooled.wrappedBuffer(out.toByteArray());\n            responses.add(out.toString(StandardCharsets.UTF_8));\n\n            DefaultFullHttpResponse response;\n            if (headers != null && headers.isEmpty() == false) {\n                HttpHeaders httpHeaders = new DefaultHttpHeaders();\n                for (var entries : headers.entrySet()) {\n                    httpHeaders.add(entries.getKey(), entries.getValue());\n                }\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf, httpHeaders, EmptyHttpHeaders.INSTANCE);\n            } else {\n                response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, byteBuf);\n            }\n\n            ChannelFuture future = ctx.channel().writeAndFlush(response);\n            future.addListener(ChannelFutureListener.CLOSE);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            logger.warn(\"Unexpected exception from downstream.\", cause);\n            ctx.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.util.CharsetUtil;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\n\npublic class HttpTestServer {\n    private final int port;\n    private final boolean fail;\n    private final BiConsumer<HttpRequest, JsonGenerator> requestHandler;\n    private final Map<String, String> headers;\n    private Channel channel;\n    private NioEventLoopGroup group;\n    private final List<String> responses = new ConcurrentLinkedDeque<>();\n    private static final JsonFactory JSON_FACTORY = new JsonFactory();\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler, Map<String, String> headers) {\n        this.port = port;\n        this.fail = fail;\n        this.requestHandler = requestHandler;\n        this.headers = headers;\n    }\n\n    public HttpTestServer(int port, boolean fail, BiConsumer<HttpRequest, JsonGenerator> requestHandler) {\n        this(port, fail, requestHandler, new java.util.HashMap<>());\n    }\n\n    public void run() {\n        group = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(group)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ch.pipeline().addLast(new HttpServerCodec());\n                     ch.pipeline().addLast(new HttpTestServerHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            channel = f.channel();\n            f.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {\n            shutDown();\n        }\n    }\n\n    public int boundPort() {\n        return channel.localAddress().getPort();\n    }\n\n    public void shutDown() {\n        if (channel != null) {\n            channel.close();\n        }\n        if (group != null) {\n            group.shutdownGracefully();\n        }\n    }\n\n    private class HttpTestServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            JsonGenerator gen = JSON_FACTORY.createGenerator(baos);\n            requestHandler.accept(request, gen);\n            gen.close();\n            String content = baos.toString();\n            responses.add(content);\n\n            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,\n                    fail ? HttpResponseStatus.INTERNAL_SERVER_ERROR : HttpResponseStatus.OK);\n            response.content().writeBytes(content.getBytes(CharsetUtil.UTF_8));\n            response.headers().set(\"Content-Type\", \"application/json\");\n\n            for (Map.Entry<String, String> entry : headers.entrySet()) {\n                response.headers().add(entry.getKey(), entry.getValue());\n            }\n\n            ChannelFuture f = ctx.writeAndFlush(response);\n            f.addListener(ChannelFutureListener.CLOSE);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 217,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and process serialized data.\n\nClass Description: SerializationServer is a Netty-based TCP server that listens on a specified port for incoming connections, processes serialized data through a custom pipeline, and manages server resources efficiently.\n\nAttributes:\nPORT: static final int - The port number on which the server will listen for incoming connections (default: 8082)\n\nMethods:\nstart(): void - Starts the Netty TCP server with the following behavior:\n1. Creates boss and worker event loop groups for connection handling\n2. Configures server bootstrap with NIO transport channel\n3. Sets server options (backlog and keepalive)\n4. Adds logging handler and custom pipeline initializer\n5. Binds to the specified port and waits for server shutdown\n6. Cleans up resources on shutdown\n\nInput: None (The port is defined as a class constant)\n\nOutput: None (The method runs indefinitely until server shutdown)\n\nNote: The class requires proper exception handling for server operations and resource cleanup in finally block. The actual data processing is handled by a separate SerializationServerInitializer class which should be provided separately.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic final class SerializationServer {\n\n    static final int PORT = 8082;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new SerializationServerInitializer());\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\n\npublic class SerializationServer {\n    public static final int PORT = 8082;\n\n    public void start() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 1024)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .childHandler(new SerializationServerInitializer());\n\n            Channel ch = b.bind(PORT).sync().channel();\n            ch.closeFuture().await();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}"
  },
  {
    "Task_id": 219,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests, with optional SSL support for secure connections.\n\nClass Description: The HttpHelloWorldServer class is a Netty-based TCP server that listens for HTTP requests on a specified port. It supports both plain HTTP and HTTPS (when SSL is enabled) connections. The server uses a boss-worker thread model for handling connections and includes logging capabilities.\n\nAttributes:\n- SSL: static final boolean - Flag indicating whether SSL should be enabled\n- PORT: static final int - The port number on which the server will listen\n\nMethods:\n- start(): void - Starts the Netty TCP server. Throws Exception if any error occurs during startup.\n  - Input: None\n  - Output: None (but starts the server process)\n  - Description: Initializes SSL context if enabled, sets up event loop groups, configures server bootstrap with channel options and handlers, binds to the specified port, and keeps the server running until shutdown. Properly cleans up resources on shutdown.",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\n\npublic final class HttpHelloWorldServer {\n\n    static final boolean SSL = System.getProperty(\"ssl\") != null;\n    static final int PORT = Integer.parseInt(System.getProperty(\"port\", SSL? \"8443\" : \"8080\"));\n\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (SSL) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.option(ChannelOption.SO_BACKLOG, 1024);\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .handler(new LoggingHandler(LogLevel.INFO))\n             .childHandler(new HttpHelloWorldServerInitializer(sslCtx));\n\n            Channel ch = b.bind(PORT).sync().channel();\n\n            System.err.println(\"Open your web browser and navigate to \" +\n                    (SSL? \"https\" : \"http\") + \"://127.0.0.1:\" + PORT + '/');\n\n            ch.closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.FullHttpResponse;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.CharsetUtil;\nimport java.net.InetSocketAddress;\n\npublic class HttpHelloWorldServer {\n    public static final boolean SSL = false;\n    public static final int PORT = 8080;\n\n    public void start() throws Exception {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            if (SSL) {\n                SslContext sslContext = SslContextBuilder.forServer()\n                        .trustManager((java.security.cert.TrustManager[]) null)\n                        .keyManager((java.security.KeyManager[]) null)\n                        .build();\n                b.childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(sslContext.newHandler(ch.alloc()));\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpHelloWorldHandler());\n                    }\n                });\n            } else {\n                b.childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(65536));\n                        ch.pipeline().addLast(new HttpHelloWorldHandler());\n                    }\n                });\n            }\n\n            ChannelFuture f = b.bind(PORT).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class HttpHelloWorldHandler extends SimpleChannelInboundHandler<HttpRequest> {\n        @Override\n        protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\");\n            response.content().writeBytes(\"Hello World\".getBytes(CharsetUtil.UTF_8));\n            ctx.writeAndFlush(response);\n        }\n    }\n\n    public static void main(String[] args) {\n        new HttpHelloWorldServer().start();\n    }\n}"
  },
  {
    "Task_id": 221,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework, capable of starting and stopping the server, and handling incoming client connections through a configurable pipeline.\n\nClass Description: MocoServer is a Netty-based TCP server implementation that provides simple start/stop functionality and allows for custom channel pipeline configuration. It manages server resources including event loop groups and channel futures.\n\nAttributes:\n- group: [EventLoopGroup] - Netty event loop group for handling I/O operations\n- future: [ChannelFuture] - Future representing the server's channel binding operation\n\nMethods:\n- MocoServer() -> [void] - Constructor that initializes the event loop group\n- start([int port, ChannelInitializer<? extends Channel> pipelineFactory]) -> [int] - Starts the server on specified port with given pipeline configuration, returns actual bound port\n- stop() -> [void] - Stops the server gracefully, releasing all resources",
    "Canonical_solution": "import com.github.dreamhead.moco.MocoException;\nimport com.github.dreamhead.moco.util.MocoExecutors;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.util.concurrent.Future;\n\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.concurrent.TimeUnit;\n\npublic final class MocoServer {\n    private EventLoopGroup group;\n    private ChannelFuture future;\n\n    public MocoServer() {\n        group = new NioEventLoopGroup(0, MocoExecutors.executor());\n    }\n\n    public int start(final int port, final ChannelInitializer<? extends Channel> pipelineFactory) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(pipelineFactory);\n\n        try {\n            future = bootstrap.bind(port).sync();\n            SocketAddress socketAddress = future.channel().localAddress();\n            return ((InetSocketAddress) socketAddress).getPort();\n        } catch (InterruptedException e) {\n            throw new MocoException(e);\n        }\n    }\n\n    public void stop() {\n        if (future != null) {\n            future.channel().close().syncUninterruptibly();\n            future = null;\n        }\n\n        if (group != null) {\n            Future<?> groupFuture = group.shutdownGracefully(0, 0, TimeUnit.SECONDS);\n            try {\n                groupFuture.get();\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n            group = null;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class MocoServer {\n    private final EventLoopGroup group;\n    private ChannelFuture future;\n\n    public MocoServer() {\n        group = new NioEventLoopGroup();\n    }\n\n    public int start(int port, ChannelInitializer<? extends Channel> pipelineFactory) {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(group)\n                 .channel(NioServerSocketChannel.class)\n                 .childHandler(pipelineFactory);\n\n        future = bootstrap.bind(port).sync().channel().closeFuture();\n        return future.channel().localAddress().getPort();\n    }\n\n    public void stop() {\n        if (future != null) {\n            future.channel().close();\n        }\n        group.shutdownGracefully();\n    }\n}"
  },
  {
    "Task_id": 224,
    "Instruction": "Task Description: Create a Java class that implements a WebSocket server using Netty framework to handle WebSocket connections and messages.\n\nClass Description: The WebSocketServer class is responsible for initializing and running a Netty-based WebSocket server. It configures the server with appropriate handlers for HTTP and WebSocket protocols, manages connection threads, and binds to a specified port.\n\nAttributes:\n- initParamDTO: InitParamDTO - Configuration parameters for the server including port number and thread counts\n\nMethods:\n- WebSocketServer(InitParamDTO initParamDTO) -> None - Constructor that initializes the server with configuration parameters\n- run() -> None - Starts the WebSocket server, configures the pipeline with necessary handlers, and binds to the specified port",
    "Canonical_solution": "import com.cf.carpark.service.core.dto.InitParamDTO;\nimport com.cf.carpark.service.websocket.handler.WebSocketFrameHandler;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.util.CharsetUtil;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.net.InetSocketAddress;\n\n@Slf4j\npublic class WebSocketServer {\n\n    private InitParamDTO initParamDTO;\n\n    public void run() {\n        EventLoopGroup boosGroup = new NioEventLoopGroup(initParamDTO.getBoosTread());\n        EventLoopGroup workGroup = new NioEventLoopGroup(initParamDTO.getWorkTread());\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            InitParamDTO initParamDTO = this.initParamDTO;\n            serverBootstrap.group(boosGroup, workGroup).channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel socketChannel) throws Exception {\n                            ChannelPipeline pipeline = socketChannel.pipeline();\n\n                            pipeline.addLast(new HttpServerCodec());\n                            pipeline.addLast(new ChunkedWriteHandler());\n                            pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n                            pipeline.addLast(new HttpObjectAggregator(1024 * 1024));\n                            pipeline.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                            pipeline.addLast(new WebSocketFrameHandler(initParamDTO));\n                        }\n                    });\n\n            ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(this.initParamDTO.getPort()))\n                    .addListener(future -> {\n                        log.info(\"\u670d\u52a1\u7aef\u6210\u529f\u7ed1\u5b9a\u7aef\u53e3\u53f7={}\", this.initParamDTO.getPort());\n                    });\n        } catch (Exception e) {\n            boosGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            log.error(\"websocketServer\u542f\u52a8\u5931\u8d25:{}\", e);\n        }\n    }\n\n    public WebSocketServer(InitParamDTO initParamDTO) {\n        this.initParamDTO = initParamDTO;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.websocketx.TextWebSocketFrame;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;\n\npublic class WebSocketServer {\n    private final InitParamDTO initParamDTO;\n\n    public WebSocketServer(InitParamDTO initParamDTO) {\n        this.initParamDTO = initParamDTO;\n    }\n\n    public void run() {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(initParamDTO.getBossThreads());\n        EventLoopGroup workerGroup = new NioEventLoopGroup(initParamDTO.getWorkerThreads());\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new HttpServerCodec());\n                     p.addLast(new HttpObjectAggregator(65536));\n                     p.addLast(new WebSocketServerProtocolHandler(\"/websocket\"));\n                     p.addLast(new CustomWebSocketHandler());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(initParamDTO.getPort()).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private class CustomWebSocketHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client connected\");\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) {\n            System.out.println(\"Client disconnected\");\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            if (msg instanceof TextWebSocketFrame) {\n                TextWebSocketFrame frame = (TextWebSocketFrame) msg;\n                System.out.println(\"Received: \" + frame.text());\n                ctx.writeAndFlush(new TextWebSocketFrame(\"Echo: \" + frame.text()));\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n            cause.printStackTrace();\n            ctx.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 226,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle HTTP requests, with configurable bind address and port, and proper resource management for startup and shutdown.\n\nClass Description: WebConfigContainer is a container class that manages the lifecycle of a Netty-based HTTP server. It initializes and configures the server components, starts the server on a specified port, and provides graceful shutdown capabilities.\n\nAttributes:\n- serverWorkerGroup: [NioEventLoopGroup] - Worker thread group for handling I/O operations\n- serverBossGroup: [NioEventLoopGroup] - Boss thread group for accepting incoming connections\n- logger: [Logger] - SLF4J logger instance for logging server events\n\nMethods:\n- WebConfigContainer() -> [void] - Constructor that initializes the boss and worker event loop groups\n- start() -> [void] - Starts the HTTP server by configuring ServerBootstrap, setting up the channel pipeline with HTTP handlers, and binding to the configured port\n- stop() -> [void] - Gracefully shuts down the server by closing the event loop groups and releasing all resources",
    "Canonical_solution": "import org.fengfei.lanproxy.common.container.Container;\nimport org.fengfei.lanproxy.server.config.ProxyConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.stream.ChunkedWriteHandler;\n\npublic class WebConfigContainer implements Container {\n\n    private static Logger logger = LoggerFactory.getLogger(WebConfigContainer.class);\n\n    private NioEventLoopGroup serverWorkerGroup;\n    private NioEventLoopGroup serverBossGroup;\n\n    public WebConfigContainer() {\n        serverBossGroup = new NioEventLoopGroup(1);\n        serverWorkerGroup = new NioEventLoopGroup(1);\n    }\n\n    @Override\n    public void start() {\n        ServerBootstrap httpServerBootstrap = new ServerBootstrap();\n        httpServerBootstrap.group(serverBossGroup, serverWorkerGroup)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                public void initChannel(SocketChannel ch) throws Exception {\n                    ChannelPipeline pipeline = ch.pipeline();\n                    pipeline.addLast(new HttpServerCodec());\n                    pipeline.addLast(new HttpObjectAggregator(8 * 1024 * 1024));\n                    pipeline.addLast(new ChunkedWriteHandler());\n                    pipeline.addLast(new HttpRequestHandler());\n                }\n            });\n\n        try {\n            httpServerBootstrap.bind(ProxyConfig.getInstance().getConfigServerBind(),\n                    ProxyConfig.getInstance().getConfigServerPort()).get();\n            logger.info(\"http server start on port \" + ProxyConfig.getInstance().getConfigServerPort());\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    @Override\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class WebConfigContainer {\n    private final String bindAddress;\n    private final int port;\n    private final NioEventLoopGroup bossGroup;\n    private final NioEventLoopGroup workerGroup;\n    private final Logger logger;\n\n    public WebConfigContainer(String bindAddress, int port) {\n        this.bindAddress = bindAddress;\n        this.port = port;\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        logger = LoggerFactory.getLogger(WebConfigContainer.class);\n    }\n\n    public void start() {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .childHandler(new ChannelInitializer<Channel>() {\n                 @Override\n                 protected void initChannel(Channel ch) throws Exception {\n                     ch.pipeline().addLast(\n                         new LoggingHandler(LogLevel.INFO),\n                         new HttpServerCodec(),\n                         new HttpObjectAggregator(65536),\n                         new CustomHttpHandler()\n                     );\n                 }\n             });\n\n            ChannelFuture f = b.bind(bindAddress, port).sync();\n            logger.info(\"Server started on {}:{}\", bindAddress, port);\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"Server failed to start\", e);\n        }\n    }\n\n    public void stop() {\n        if (bossGroup != null) {\n            bossGroup.shutdownGracefully();\n        }\n        if (workerGroup != null) {\n            workerGroup.shutdownGracefully();\n        }\n    }\n\n    private static class CustomHttpHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Handle HTTP request\n        }\n    }\n}"
  },
  {
    "Task_id": 228,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle incoming client connections and echo back received messages.\n\nClass Description: The EchoServer class is a Netty-based TCP server that listens on a specified port, accepts client connections, and echoes back any received messages. It uses Netty's event-driven architecture for efficient network communication.\n\nAttributes:\n- port: int - The port number on which the server will listen for incoming connections\n\nMethods:\n- EchoServer(int port) -> Constructor - Initializes the server with the specified port number\n- start() -> void - Starts the server, binds to the specified port, and begins accepting connections. Handles server shutdown gracefully when stopped. Throws Exception if any error occurs during startup or operation",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport java.net.InetSocketAddress;\n\npublic class EchoServer {\n    private final int port;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        final EchoServerHandler serverHandler = new EchoServerHandler();\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b = b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        public void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline().addLast(serverHandler);\n                        }\n                    });\n            ChannelFuture f = b.bind().sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully().sync();\n            workerGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.util.CharsetUtil;\n\npublic class EchoServer {\n    private final int port;\n    private ServerBootstrap bootstrap;\n    private EventLoopGroup bossGroup;\n    private EventLoopGroup workerGroup;\n\n    public EchoServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws Exception {\n        bossGroup = new NioEventLoopGroup(1);\n        workerGroup = new NioEventLoopGroup();\n        try {\n            bootstrap = new ServerBootstrap();\n            bootstrap.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new StringDecoder(CharsetUtil.UTF_8));\n                            ch.pipeline().addLast(new StringEncoder(CharsetUtil.UTF_8));\n                            ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() {\n                                @Override\n                                protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                                    ctx.writeAndFlush(msg);\n                                }\n                            });\n                        }\n                    })\n                    .option(ChannelOption.SO_BACKLOG, 1024)\n                    .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture future = bootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            shutdown();\n        }\n    }\n\n    private void shutdown() {\n        if (bossGroup != null) bossGroup.shutdownGracefully();\n        if (workerGroup != null) workerGroup.shutdownGracefully();\n    }\n\n    public static void main(String[] args) {\n        new EchoServer(8080).start();\n    }\n}"
  },
  {
    "Task_id": 229,
    "Instruction": "Task Description: Create a Java class that implements a TCP server using Netty framework to handle proxy server functionality, including SSL/TLS support, message encoding/decoding, and idle connection management.\n\nClass Description: ProxyServerContainer is a Netty-based TCP server container that manages proxy server operations. It handles client connections, processes proxy messages, and manages server resources. The class includes SSL/TLS support, custom message handlers, and graceful shutdown capabilities.\n\nAttributes:\n- serverWorkerGroup: [NioEventLoopGroup] - Handles I/O operations and other tasks for accepted connections\n- serverBossGroup: [NioEventLoopGroup] - Accepts incoming connections and assigns them to worker group\n- logger: [Logger] - SLF4J logger instance for logging server events and errors\n\nMethods:\n- ProxyServerContainer() -> [void] - Constructor that initializes the event loop groups\n- start() -> [void] - Starts the proxy server by binding to configured host/port and setting up channel pipeline\n- stop() -> [void] - Shuts down the server gracefully by releasing all resources\n- createSslHandler(SSLContext sslContext, boolean needsClientAuth) -> [ChannelHandler] - Creates SSL handler for secure communication (input: SSLContext for security configuration, boolean for client auth requirement; output: configured SSL handler)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslHandler;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport org.fengfei.lanproxy.server.config.ProxyConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ProxyServerContainer {\n\n    private static final Logger logger = LoggerFactory.getLogger(ProxyServerContainer.class);\n\n    private NioEventLoopGroup serverWorkerGroup;\n    private NioEventLoopGroup serverBossGroup;\n\n    public ProxyServerContainer() {\n        serverBossGroup = new NioEventLoopGroup();\n        serverWorkerGroup = new NioEventLoopGroup();\n    }\n\n    public void start() {\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(serverBossGroup, serverWorkerGroup)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    public void initChannel(SocketChannel ch) throws Exception {\n                        ChannelPipeline pipeline = ch.pipeline();\n                        pipeline.addLast(new ProxyMessageDecoder(MAX_FRAME_LENGTH, LENGTH_FIELD_OFFSET, \n                                LENGTH_FIELD_LENGTH, LENGTH_ADJUSTMENT, INITIAL_BYTES_TO_STRIP));\n                        pipeline.addLast(new ProxyMessageEncoder());\n                        pipeline.addLast(new IdleCheckHandler(IdleCheckHandler.READ_IDLE_TIME, \n                                IdleCheckHandler.WRITE_IDLE_TIME, 0));\n                        pipeline.addLast(new ServerChannelHandler());\n                    }\n                });\n\n        try {\n            ChannelFuture future = bootstrap.bind(ProxyConfig.getInstance().getServerBind(), \n                    ProxyConfig.getInstance().getServerPort()).sync();\n            logger.info(\"proxy server start on port \" + ProxyConfig.getInstance().getServerPort());\n        } catch (InterruptedException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private ChannelHandler createSslHandler(SSLContext sslContext, boolean needsClientAuth) {\n        SSLEngine sslEngine = sslContext.createSSLEngine();\n        sslEngine.setUseClientMode(false);\n        if (needsClientAuth) {\n            sslEngine.setNeedClientAuth(true);\n        }\n        return new SslHandler(sslEngine);\n    }\n\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.handler.codec.MessageToByteEncoder;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SslContextUtil;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.concurrent.DefaultEventExecutorGroup;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.SSLException;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProxyServerContainer {\n    private final EventLoopGroup serverBossGroup;\n    private final EventLoopGroup serverWorkerGroup;\n    private final Logger logger;\n\n    public ProxyServerContainer() {\n        this.serverBossGroup = new NioEventLoopGroup(1);\n        this.serverWorkerGroup = new NioEventLoopGroup();\n        this.logger = LoggerFactory.getLogger(ProxyServerContainer.class);\n    }\n\n    public void start(String host, int port) {\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(serverBossGroup, serverWorkerGroup)\n             .channel(NioServerSocketChannel.class)\n             .option(ChannelOption.SO_BACKLOG, 100)\n             .childOption(ChannelOption.TCP_NODELAY, true)\n             .childOption(ChannelOption.SO_KEEPALIVE, true)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 public void initChannel(SocketChannel ch) throws Exception {\n                     ChannelPipeline p = ch.pipeline();\n                     SslContext sslContext = SslContextBuilder.forServer(\"path/to/cert.pem\", \"path/to/key.pem\").build();\n                     p.addLast(createSslHandler(sslContext, false));\n                     p.addLast(new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS));\n                     p.addLast(new MessageDecoder());\n                     p.addLast(new MessageEncoder());\n                     p.addLast(new ProxyServerHandler());\n                 }\n             });\n            ChannelFuture f = b.bind(host, port).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"Error starting server\", e);\n        }\n    }\n\n    public void stop() {\n        serverBossGroup.shutdownGracefully();\n        serverWorkerGroup.shutdownGracefully();\n    }\n\n    private ChannelHandler createSslHandler(SslContext sslContext, boolean needsClientAuth) {\n        return new SslHandler(sslContext.newEngine(ChannelMatchers.isAny(), needsClientAuth));\n    }\n\n    private class MessageDecoder extends LengthFieldBasedFrameDecoder {\n        public MessageDecoder() {\n            super(1024, 0, 4, 0, 0);\n        }\n\n        @Override\n        protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n            Object msg = super.decode(ctx, in);\n            if (msg instanceof ByteBuf) {\n                ByteBuf frame = (ByteBuf) msg;\n                byte[] content = new byte[frame.readableBytes()];\n                frame.readBytes(content);\n                return new Message(content);\n            }\n            return msg;\n        }\n    }\n\n    private class MessageEncoder extends MessageToByteEncoder<Message> {\n        @Override\n        protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {\n            byte[] content = msg.getContent();\n            out.writeInt(content.length);\n            out.writeBytes(content);\n        }\n    }\n\n    private class ProxyServerHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            logger.info(\"Received message: {}\", msg);\n            super.channelRead(ctx, msg);\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent e = (IdleStateEvent) evt;\n                logger.warn(\"Connection idle: {}\", e.state());\n                ctx.close();\n            }\n            super.userEventTriggered(ctx, evt);\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            logger.error(\"Exception caught\", cause);\n            ctx.close();\n        }\n    }\n\n    private static class Message {\n        private final byte[] content;\n\n        public Message(byte[] content) {\n            this.content = content;\n        }\n\n        public byte[] getContent() {\n            return content;\n        }\n    }\n}"
  },
  {
    "Task_id": 23,
    "Instruction": "Task Description: Create a Java class for writing FLV (Flash Video) files using Java NIO's FileChannel and ByteBuffer for efficient file operations. The class should handle both new file creation and appending to existing files, including metadata management.\n\nClass Description: The FLVWriter class provides functionality to write FLV video files with proper headers, metadata tags, and media data tags. It uses Java NIO channels and buffers for efficient file operations, supporting both new file creation and appending to existing files while maintaining FLV format specifications.\n\nAttributes:\n- fileChannel: [SeekableByteChannel] - Channel for writing the final FLV output file\n- dataChannel: [SeekableByteChannel] - Temporary channel for storing tags before finalization\n- filePath: [String] - Path to the output FLV file\n- append: [boolean] - Flag indicating whether to append to an existing file\n- appendOffset: [long] - Position in existing file where new data should be appended\n- meta: [Map<String, ?>] - Metadata extracted from existing FLV file when appending\n\nMethods:\n- FLVWriter(String filePath) -> [void] - Constructor that initializes the writer with a file path for new file creation\n- FLVWriter(Path path, boolean append) -> [void] - Constructor that initializes the writer with append mode and handles existing file metadata\n- getMetaData(Path path, int maxTags) -> [Map<String, ?>] - Extracts metadata from an existing FLV file (private method)\n- createDataFile() -> [void] - Creates a temporary data file for storing tags (private method)\n- createOutputFile() -> [void] - Creates the final output FLV file (private method)\n- writeTag(ITag tag) -> [boolean] - Writes a media tag to the temporary data file\n- close() -> [void] - Finalizes the FLV file and cleans up resources\n- finalizeFlv() -> [long] - Combines temporary data with existing file (if appending) and writes final FLV file (private method)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Map;\n\npublic class FLVWriter {\n\n    private static final Logger log = LoggerFactory.getLogger(FLVWriter.class);\n\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset = 13L;\n    private Map<String, ?> meta;\n\n    public FLVWriter(String filePath) {\n        this.filePath = filePath;\n        try {\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    public FLVWriter(Path path, boolean append) {\n        filePath = path.toFile().getAbsolutePath();\n        this.append = append;\n        try {\n            if (append) {\n                meta = getMetaData(path, 5);\n                Files.move(path, path.resolveSibling(path.toFile().getName().replace(\".flv\", \".old\")));\n            }\n            createDataFile();\n        } catch (Exception e) {\n            log.error(\"Failed to create FLV writer\", e);\n        }\n    }\n\n    private Map<String, ?> getMetaData(Path path, int maxTags) throws IOException {\n        Map<String, ?> meta = null;\n        try (SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n            long size = channel.size();\n            if (size > 0L) {\n                channel.position(appendOffset);\n                ByteBuffer dst = ByteBuffer.allocate(11);\n                do {\n                    int read = channel.read(dst);\n                    if (read > 0) {\n                        dst.flip();\n                        byte tagType = (byte) (dst.get() & 31);\n                        int bodySize = IOUtils.readUnsignedMediumInt(dst);\n                        if (tagType == ITag.TYPE_METADATA) {\n                            ByteBuffer buf = ByteBuffer.allocate(bodySize);\n                            read = channel.read(buf);\n                            if (read > 0) {\n                                buf.flip();\n                                Input input = new Input(IoBuffer.wrap(buf));\n                                String metaType = Deserializer.deserialize(input, String.class);\n                                meta = Deserializer.deserialize(input, Map.class);\n                                if (meta.containsKey(\"duration\")) {\n                                    appendOffset = channel.position() + 4L;\n                                    break;\n                                }\n                            }\n                            buf.compact();\n                        }\n                        channel.position(channel.position() + 4L);\n                        dst.compact();\n                    }\n                } while (--maxTags > 0);\n            }\n        }\n        return meta;\n    }\n\n    private void createDataFile() throws IOException {\n        Path path = Paths.get(filePath + \".ser\");\n        if (Files.deleteIfExists(path)) {\n            log.debug(\"Previous flv data file existed and was removed\");\n        }\n        this.dataChannel = Files.newByteChannel(path, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.READ);\n    }\n\n    private void createOutputFile() throws IOException {\n        this.fileChannel = Files.newByteChannel(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);\n    }\n\n    public boolean writeTag(ITag tag) throws IOException {\n        try {\n            int bodySize = tag.getBodySize();\n            byte dataType = tag.getDataType();\n            IoBuffer tagBody = tag.getBody();\n            int totalTagSize = 11 + bodySize + 4;\n            ByteBuffer tagBuffer = ByteBuffer.allocate(totalTagSize);\n            int timestamp = tag.getTimestamp();\n            byte[] bodyBuf = new byte[bodySize];\n            tagBody.get(bodyBuf);\n            IOUtils.writeUnsignedByte(tagBuffer, dataType);\n            IOUtils.writeMediumInt(tagBuffer, bodySize);\n            IOUtils.writeExtendedMediumInt(tagBuffer, timestamp);\n            tagBuffer.put(new byte[] {0, 0, 0});\n            tagBuffer.put(bodyBuf);\n            tagBuffer.putInt(11 + bodySize);\n            tagBuffer.flip();\n            dataChannel.write(tagBuffer);\n            return true;\n        } catch (Exception e) {\n            log.error(\"Failed to write tag\", e);\n            return false;\n        }\n    }\n\n    public void close() {\n        try {\n            finalizeFlv();\n        } catch (Exception e) {\n            log.error(\"Failed to finalize FLV\", e);\n        } finally {\n            try {\n                if (dataChannel != null) dataChannel.close();\n                if (fileChannel != null) fileChannel.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close channels\", e);\n            }\n        }\n    }\n\n    private long finalizeFlv() throws IOException {\n        createOutputFile();\n        writeHeader();\n        writeMetadataTag();\n        ByteBuffer dst = ByteBuffer.allocate(1024);\n        if (append) {\n            Path prevFlv = Paths.get(filePath.replace(\".flv\", \".old\"));\n            if (Files.exists(prevFlv)) {\n                try (SeekableByteChannel prevChannel = Files.newByteChannel(prevFlv, StandardOpenOption.READ)) {\n                    prevChannel.position(appendOffset);\n                    int read;\n                    do {\n                        read = prevChannel.read(dst);\n                        if (read > 0) {\n                            dst.flip();\n                            fileChannel.write(dst);\n                            dst.compact();\n                        }\n                    } while (read > 0);\n                }\n                Files.deleteIfExists(prevFlv);\n            }\n        }\n        dataChannel.position(0L);\n        int read;\n        do {\n            read = dataChannel.read(dst);\n            if (read > 0) {\n                dst.flip();\n                fileChannel.write(dst);\n                dst.compact();\n            }\n        } while (read > 0);\n        Files.deleteIfExists(Paths.get(filePath + \".ser\"));\n        return fileChannel.position();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class FLVWriter {\n    private SeekableByteChannel fileChannel;\n    private SeekableByteChannel dataChannel;\n    private String filePath;\n    private boolean append;\n    private long appendOffset;\n    private Map<String, Object> meta;\n\n    public FLVWriter(String filePath) throws IOException {\n        this.filePath = filePath;\n        createOutputFile();\n        createDataFile();\n    }\n\n    public FLVWriter(Path path, boolean append) throws IOException {\n        this.filePath = path.toString();\n        this.append = append;\n        if (append) {\n            // Read existing metadata\n            meta = getMetaData(path, 10);\n            // Open existing file for appending\n            FileChannel existingChannel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE);\n            this.fileChannel = existingChannel;\n            // Create temporary data channel\n            createDataFile();\n            // Set append offset\n            appendOffset = existingChannel.size();\n        } else {\n            createOutputFile();\n            createDataFile();\n        }\n    }\n\n    private Map<String, Object> getMetaData(Path path, int maxTags) throws IOException {\n        try (FileChannel fc = FileChannel.open(path, StandardOpenOption.READ)) {\n            ByteBuffer header = ByteBuffer.allocate(9);\n            fc.read(header);\n            header.flip();\n            \n            int headerSize = header.getShort(0) & 0xFF;\n            int type = header.get(7) & 0xFF;\n            \n            if (type != 1) {\n                throw new IllegalArgumentException(\"Invalid FLV file\");\n            }\n            \n            long fileSize = fc.size();\n            long tagSize = 0;\n            long offset = 8;\n            \n            Map<String, Object> metaData = new HashMap<>();\n            while (offset < fileSize && maxTags > 0) {\n                ByteBuffer tagHeader = ByteBuffer.allocate(11);\n                fc.read(tagHeader);\n                tagHeader.flip();\n                \n                int tagType = tagHeader.get(0) & 0xFF;\n                int dataLength = tagHeader.getInt(1) & 0xFFFFFFFF;\n                long timestamp = tagHeader.getInt(5) & 0xFFFFFFFF;\n                \n                if (tagType == 18) { // Metadata tag\n                    ByteBuffer data = ByteBuffer.allocate(dataLength);\n                    fc.read(data);\n                    data.flip();\n                    \n                    String xml = Charset.forName(\"UTF-8\").decode(data).toString();\n                    metaData.put(\"onMetaData\", xml);\n                    maxTags--;\n                }\n                \n                offset += 11 + dataLength;\n                tagSize += 11 + dataLength;\n            }\n            \n            return metaData;\n        }\n    }\n\n    private void createOutputFile() throws IOException {\n        Path outputPath = Paths.get(filePath);\n        if (Files.exists(outputPath)) {\n            Files.delete(outputPath);\n        }\n        fileChannel = FileChannel.open(outputPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ);\n    }\n\n    private void createDataFile() throws IOException {\n        Path tempPath = Files.createTempFile(\"flv_data_\", \".tmp\");\n        dataChannel = FileChannel.open(tempPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.READ);\n    }\n\n    public boolean writeTag(ITag tag) throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(tag.getSize());\n        tag.write(buffer);\n        buffer.flip();\n        \n        dataChannel.write(buffer);\n        return true;\n    }\n\n    public void close() throws IOException {\n        if (dataChannel != null) {\n            dataChannel.close();\n        }\n        if (fileChannel != null) {\n            finalizeFlv();\n            fileChannel.close();\n        }\n    }\n\n    private long finalizeFlv() throws IOException {\n        if (append) {\n            // Write new data to existing file\n            fileChannel.position(appendOffset);\n            ByteBuffer buffer = ByteBuffer.allocate((int) dataChannel.size());\n            dataChannel.read(buffer);\n            buffer.flip();\n            fileChannel.write(buffer);\n            \n            // Write FLV header\n            ByteBuffer header = ByteBuffer.allocate(9);\n            header.putShort((short) 0x1A45DFA3); // FLV header\n            header.put((byte) 0x00); // version\n            header.put((byte) 0x00); // flags\n            header.putInt(0x00000013); // header size\n            header.flip();\n            fileChannel.write(header);\n            \n            // Write metadata tag\n            if (meta != null) {\n                ByteBuffer metaDataBuffer = ByteBuffer.allocate(11 + 100); // Approximate size\n                metaDataBuffer.put((byte) 0x18); // Metadata tag type\n                metaDataBuffer.putInt(0); // Data length\n                metaDataBuffer.putInt(0); // Timestamp\n                metaDataBuffer.putInt(0); // Stream ID\n                metaDataBuffer.flip();\n                fileChannel.write(metaDataBuffer);\n                fileChannel.position(fileChannel.position() - 11);\n                metaDataBuffer.putInt(100); // Update data length\n                metaDataBuffer.flip();\n                fileChannel.write(metaDataBuffer);\n                \n                String xml = (String) meta.get(\"onMetaData\");\n                ByteBuffer xmlBuffer = Charset.forName(\"UTF-8\").encode(xml);\n                fileChannel.write(xmlBuffer);\n            }\n        } else {\n            // Write FLV header\n            ByteBuffer header = ByteBuffer.allocate(9);\n            header.putShort((short) 0x1A45DFA3); // FLV header\n            header.put((byte) 0x00); // version\n            header.put((byte) 0x00); // flags\n            header.putInt(0x00000013); // header size\n            header.flip();\n            fileChannel.write(header);\n            \n            // Write metadata tag\n            if (meta != null) {\n                ByteBuffer metaDataBuffer = ByteBuffer.allocate(11 + 100); // Approximate size\n                metaDataBuffer.put((byte) 0x18); // Metadata tag type\n                metaDataBuffer.putInt(0); // Data length\n                metaDataBuffer.putInt(0); // Timestamp\n                metaDataBuffer.putInt(0); // Stream ID\n                metaDataBuffer.flip();\n                fileChannel.write(metaDataBuffer);\n                fileChannel.position(fileChannel.position() - 11);\n                metaDataBuffer.putInt(100); // Update data length\n                metaDataBuffer.flip();\n                fileChannel.write(metaDataBuffer);\n                \n                String xml = (String) meta.get(\"onMetaData\");\n                ByteBuffer xmlBuffer = Charset.forName(\"UTF-8\").encode(xml);\n                fileChannel.write(xmlBuffer);\n            }\n            \n            // Write all tags\n            ByteBuffer buffer = ByteBuffer.allocate((int) dataChannel.size());\n            dataChannel.read(buffer);\n            buffer.flip();\n            fileChannel.write(buffer);\n        }\n        \n        return fileChannel.size();\n    }\n}"
  },
  {
    "Task_id": 232,
    "Instruction": "Task Description: Implement a TCP server using Java Netty framework that handles client connections and processes Protocol Buffers (protobuf) messages with support for idle connection detection and custom message handling.\n\nClass Description: ProtobufProxy is a Netty-based TCP server implementation that establishes a server socket, configures protocol buffer message handling, and manages client connections. It includes idle connection detection, protobuf message encoding/decoding, and custom business logic handlers.\n\nAttributes: None (This class doesn't maintain any instance attributes, using local variables within methods instead)\n\nMethods:\n1: start(int port) -> void - Initializes and starts the Netty TCP server on the specified port. Creates event loop groups, configures server bootstrap with protobuf handlers, binds to the port, and manages server lifecycle. The method blocks until server shutdown.\n   - Input Parameters:\n     - port: int - The TCP port number to bind the server to\n   - Output: None (void)",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.epoll.Epoll;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport org.nico.ratel.landlords.entity.ServerTransferData;\nimport org.nico.ratel.landlords.print.SimplePrinter;\nimport org.nico.ratel.landlords.robot.RobotDecisionMakers;\nimport org.nico.ratel.landlords.server.ServerContains;\nimport org.nico.ratel.landlords.server.handler.SecondProtobufCodec;\nimport org.nico.ratel.landlords.server.handler.ProtobufTransferHandler;\n\nimport java.net.InetSocketAddress;\nimport java.util.Timer;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy implements Proxy {\n\n    @Override\n    public void start(int port) throws InterruptedException {\n        EventLoopGroup parentGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        EventLoopGroup childGroup = Epoll.isAvailable() ? new EpollEventLoopGroup() : new NioEventLoopGroup();\n        try {\n            ServerBootstrap bootstrap = new ServerBootstrap()\n                    .group(parentGroup, childGroup)\n                    .channel(Epoll.isAvailable() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)\n                    .localAddress(new InetSocketAddress(port))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) throws Exception {\n                            ch.pipeline()\n                                .addLast(new IdleStateHandler(60 * 30, 0, 0, TimeUnit.SECONDS))\n                                .addLast(new ProtobufVarint32FrameDecoder())\n                                .addLast(new ProtobufDecoder(ServerTransferData.ServerTransferDataProtoc.getDefaultInstance()))\n                                .addLast(new ProtobufVarint32LengthFieldPrepender())\n                                .addLast(new ProtobufEncoder())\n                                .addLast(new SecondProtobufCodec())\n                                .addLast(new ProtobufTransferHandler());\n                        }\n                    });\n\n            ChannelFuture f = bootstrap.bind().sync();\n\n            SimplePrinter.serverLog(\"The protobuf server was successfully started on port \" + port);\n            RobotDecisionMakers.init();\n\n            ServerContains.THREAD_EXCUTER.execute(() -> {\n                Timer timer = new Timer();\n                timer.schedule(new RoomClearTask(), 0L, 3000L);\n            });\n            f.channel().closeFuture().sync();\n        } finally {\n            parentGroup.shutdownGracefully();\n            childGroup.shutdownGracefully();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 4,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.protobuf.ProtobufDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufEncoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;\nimport io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;\nimport io.netty.handler.idle.IdleStateEvent;\nimport io.netty.handler.idle.IdleStateHandler;\nimport java.util.concurrent.TimeUnit;\n\npublic class ProtobufProxy {\n    public void start(int port) {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup workerGroup = new NioEventLoopGroup();\n\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workerGroup)\n             .channel(NioServerSocketChannel.class)\n             .childHandler(new ChannelInitializer<SocketChannel>() {\n                 @Override\n                 protected void initChannel(SocketChannel ch) {\n                     ChannelPipeline p = ch.pipeline();\n                     p.addLast(new IdleStateHandler(10, 0, 0, TimeUnit.SECONDS));\n                     p.addLast(new ProtobufVarint32FrameDecoder());\n                     p.addLast(new ProtobufDecoder(MyMessage.getDefaultInstance()));\n                     p.addLast(new CustomHandler());\n                     p.addLast(new ProtobufVarint32LengthFieldPrepender());\n                     p.addLast(new ProtobufEncoder());\n                 }\n             })\n             .option(ChannelOption.SO_BACKLOG, 128)\n             .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            ChannelFuture f = b.bind(port).sync();\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            workerGroup.shutdownGracefully();\n            bossGroup.shutdownGracefully();\n        }\n    }\n\n    private static class CustomHandler extends ChannelInboundHandlerAdapter {\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            // Process the message here\n            MyMessage message = (MyMessage) msg;\n            // Business logic\n            MyMessage response = ...;\n            ctx.writeAndFlush(response);\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) {\n            ctx.flush();\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n            if (evt instanceof IdleStateEvent) {\n                ctx.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 246,
    "Instruction": "Task Description: Create a Java class that provides HTTP client functionality for making POST requests and JSON requests to RESTful APIs, with support for both JSON and form-data payloads, and proper response handling.\n\nClass Description: The Network class is a utility class that encapsulates HTTP client operations for interacting with RESTful APIs. It provides methods for making POST requests with flexible parameter formats (JSON or form-data) and a specialized method for making requests that expect JSON responses.\n\nAttributes:\n\nhttpClient: [HttpClient] - A shared HTTP client instance used for all requests, initialized as a static final variable to ensure thread-safety and reuse.\n\nMethods:\n\nmakePOSTRequest: [Name](String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) -> [HttpResponse<String>] - Makes a POST request to the specified URL with the given parameters and headers. The convertParamtersToJSON flag determines whether parameters are sent as JSON or form-urlencoded data.\n\nbuildFormDataFromMap: [Name](Map<Object, Object> data) -> [HttpRequest.BodyPublisher] - A private helper method that converts a Map into form-urlencoded string format for POST requests.\n\nmakeJsonRequest: [Name](String url) -> [JsonElement] - Makes a GET request to the specified URL and parses the response as JSON, throwing an IOException if the request fails.\n\nfailure: [Name](int statusCode) -> [boolean] - A private helper method that checks if an HTTP status code indicates failure (outside 200-299 range).",
    "Canonical_solution": "import com.google.gson.Gson;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonParser;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\npublic class Network {\n\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n\n    public static HttpResponse<String> makePOSTRequest(String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) throws IOException, InterruptedException {\n        Gson gson = new Gson();\n        String JSONParameters = gson.toJson(parameters);\n\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(URI.create(url))\n                .POST(convertParamtersToJSON ? BodyPublishers.ofString(JSONParameters) : buildFormDataFromMap(parameters));\n\n        for (Map.Entry<String, String> entry : headers.entrySet())\n            requestBuilder.header(entry.getKey(), entry.getValue());\n\n        HttpRequest request = requestBuilder.build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    private static HttpRequest.BodyPublisher buildFormDataFromMap(Map<Object, Object> data) {\n        var builder = new StringBuilder();\n        for (Map.Entry<Object, Object> entry : data.entrySet()) {\n            if (builder.length() > 0) {\n                builder.append(\"&\");\n            }\n            builder.append(URLEncoder.encode(entry.getKey().toString(), StandardCharsets.UTF_8));\n            builder.append(\"=\");\n            builder.append(URLEncoder.encode(entry.getValue().toString(), StandardCharsets.UTF_8));\n        }\n        return HttpRequest.BodyPublishers.ofString(builder.toString());\n    }\n\n    static JsonElement makeJsonRequest(String url) throws IOException {\n        try {\n            HttpResponse<InputStream> response = httpClient.send(HttpRequest.newBuilder(URI.create(url)).build(),\n                    HttpResponse.BodyHandlers.ofInputStream());\n            if (failure(response.statusCode())) {\n                throw new IOException(\"HTTP Response was \" + response);\n            }\n            return JsonParser.parseReader(new BufferedReader(new InputStreamReader(response.body())));\n        } catch (InterruptedException e) {\n            throw new IOException(e);\n        }\n    }\n\n    private static boolean failure(int statusCode) {\n        return statusCode < 200 || statusCode > 299;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.io.IOException;\nimport com.google.gson.JsonElement;\nimport com.google.gson.Gson;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.stream.Collectors;\n\npublic class Network {\n    private static final HttpClient httpClient = HttpClient.newHttpClient();\n\n    public HttpResponse<String> makePOSTRequest(String url, Map<Object, Object> parameters, Map<String, String> headers, boolean convertParamtersToJSON) throws IOException, InterruptedException {\n        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()\n                .uri(URI.create(url));\n        if (headers != null) {\n            requestBuilder.headers(headers.entrySet().stream()\n                    .map(entry -> entry.getKey() + \":\" + entry.getValue())\n                    .toArray(String[]::new));\n        }\n        if (convertParamtersToJSON) {\n            String jsonBody = new Gson().toJson(parameters);\n            requestBuilder.body(BodyPublishers.ofString(jsonBody));\n        } else {\n            requestBuilder.body(buildFormDataFromMap(parameters));\n        }\n        return httpClient.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString());\n    }\n\n    private HttpRequest.BodyPublisher buildFormDataFromMap(Map<Object, Object> data) {\n        StringBuilder formData = new StringBuilder();\n        for (Map.Entry<Object, Object> entry : data.entrySet()) {\n            String key = (String) entry.getKey();\n            String value = (String) entry.getValue();\n            if (formData.length() > 0) {\n                formData.append('&');\n            }\n            formData.append(URLEncoder.encode(key, StandardCharsets.UTF_8));\n            formData.append('=');\n            formData.append(URLEncoder.encode(value, StandardCharsets.UTF_8));\n        }\n        return BodyPublishers.ofString(formData.toString());\n    }\n\n    public JsonElement makeJsonRequest(String url) throws IOException, InterruptedException {\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(url))\n                .GET()\n                .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        if (failure(response.statusCode())) {\n            throw new IOException(\"Request failed with status code: \" + response.statusCode());\n        }\n        return new Gson().fromJson(response.body(), JsonElement.class);\n    }\n\n    private boolean failure(int statusCode) {\n        return statusCode < 200 || statusCode >= 300;\n    }\n}"
  },
  {
    "Task_id": 247,
    "Instruction": "Task Description: Create a Java class that handles HTTP requests to a RESTful API using the OkHttp client library, with support for both GET and POST methods, including timeout configuration and proper resource cleanup.\n\nClass Description: GHMatrixBatchRequester is a utility class designed to make HTTP requests to a GraphHopper matrix API. It provides methods for sending GET and POST requests, handles response processing, and includes timeout configurations for network operations.\n\nAttributes:\n- logger: Logger - Used for logging debug and error information\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Constructor: GHMatrixBatchRequester() -> void - Initializes the HTTP client with default timeout settings (5 seconds for connect and read)\n- Constructor: GHMatrixBatchRequester(OkHttpClient) -> void - Allows injection of a custom configured OkHttpClient instance\n- getJson: getJson(String url) -> JsonResult - Sends a GET request to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers\n- postJson: postJson(String url, JsonNode requestJson) -> JsonResult - Sends a POST request with JSON payload to the specified URL and returns the response as a JsonResult object containing the response body, status code, and headers",
    "Canonical_solution": "import com.fasterxml.jackson.databind.JsonNode;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketTimeoutException;\nimport java.util.concurrent.TimeUnit;\n\nimport static com.graphhopper.api.GraphHopperWeb.X_GH_CLIENT_VERSION;\nimport static com.graphhopper.api.Version.GH_VERSION_FROM_MAVEN;\n\npublic class GHMatrixBatchRequester {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n    private OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    protected JsonResult getJson(String url) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n\n    protected JsonResult postJson(String url, JsonNode requestJson) throws IOException {\n        Request okRequest = new Request.Builder().url(url)\n                .header(X_GH_CLIENT_VERSION, GH_VERSION_FROM_MAVEN)\n                .post(createRequestBody(requestJson))\n                .build();\n        ResponseBody body = null;\n        try {\n            Response rsp = client.newCall(okRequest).execute();\n            body = rsp.body();\n            return new JsonResult(body.string(), rsp.code(), rsp.headers().toMultimap());\n        } finally {\n            if (body != null) {\n                body.close();\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import okhttp3.*;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\n\npublic class GHMatrixBatchRequester {\n    private final Logger logger = Logger.getLogger(GHMatrixBatchRequester.class.getName());\n    private final OkHttpClient client;\n\n    public GHMatrixBatchRequester() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(5, TimeUnit.SECONDS)\n                .readTimeout(5, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public GHMatrixBatchRequester(OkHttpClient client) {\n        this.client = client;\n    }\n\n    public JsonResult getJson(String url) {\n        Request request = new Request.Builder().url(url).build();\n        Response response = null;\n        try {\n            response = client.newCall(request).execute();\n            return new JsonResult(response.body().string(), response.code(), response.headers());\n        } catch (IOException e) {\n            logger.severe(\"Error during GET request to \" + url);\n            return new JsonResult(null, -1, null);\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n    }\n\n    public JsonResult postJson(String url, JsonNode requestJson) {\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonBody = null;\n        try {\n            jsonBody = mapper.writeValueAsString(requestJson);\n        } catch (Exception e) {\n            logger.severe(\"Error converting JSON node to string: \" + e.getMessage());\n            return new JsonResult(null, -1, null);\n        }\n\n        RequestBody body = RequestBody.create(jsonBody, MediaType.get(\"application/json; charset=utf-8\"));\n        Request request = new Request.Builder()\n                .url(url)\n                .post(body)\n                .build();\n\n        Response response = null;\n        try {\n            response = client.newCall(request).execute();\n            return new JsonResult(response.body().string(), response.code(), response.headers());\n        } catch (IOException e) {\n            logger.severe(\"Error during POST request to \" + url);\n            return new JsonResult(null, -1, null);\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n    }\n\n    public void close() {\n        if (client != null) {\n            client.dispatcher().executorService().shutdown();\n            client.connectionPool().evictAll();\n        }\n    }\n\n    static class JsonResult {\n        private final String body;\n        private final int statusCode;\n        private final Headers headers;\n\n        public JsonResult(String body, int statusCode, Headers headers) {\n            this.body = body;\n            this.statusCode = statusCode;\n            this.headers = headers;\n        }\n    }\n}"
  },
  {
    "Task_id": 25,
    "Instruction": "Task Description: Create a Java class that processes large files efficiently using memory-mapped file I/O operations through FileChannel and MappedByteBuffer.\n\nClass Description: FileChannelProcessor is a utility class designed to handle large file processing by mapping portions of a file into memory buffers. It reads files in chunks (up to 500MB each) and ensures each chunk ends at a line boundary for proper text processing.\n\nAttributes:\n- BUFFER_SIZE: int - Constant defining the maximum size (500MB) for each memory-mapped buffer\n- channel: FileChannel - The file channel used for file operations\n- buffers: List<Buffer> - List of buffers containing mapped portions of the file\n\nMethods:\n- FileChannelProcessor(Path filePath) -> void - Constructor that initializes the FileChannel by opening the specified file\n- createBuffers() -> List<Buffer> - Creates memory-mapped buffers for the file, ensuring each buffer ends at a line boundary\n- close() -> void - Closes the FileChannel to release system resources\n\nNested Record:\n- Buffer(ByteBuffer byteBuffer, int length) - A record holding a ByteBuffer and its effective length (up to the last newline character)",
    "Canonical_solution": "import java.nio.ByteBuffer;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.nio.channels.FileChannel.MapMode.READ_ONLY;\n\npublic class FileChannelProcessor {\n    private static final int BUFFER_SIZE = (1 << 29); // 500mb\n    private final FileChannel channel;\n    private final List<Buffer> buffers = new ArrayList<>();\n\n    public FileChannelProcessor(Path filePath) throws Exception {\n        this.channel = FileChannel.open(filePath);\n    }\n\n    public List<Buffer> createBuffers() throws Exception {\n        long size = channel.size();\n        int lastByte;\n        for (long offset = 0; offset < size; offset += lastByte + 1) {\n            long sizeToMap = Math.min(size - offset, BUFFER_SIZE);\n            MappedByteBuffer buffer = channel.map(READ_ONLY, offset, sizeToMap);\n            lastByte = (int) sizeToMap - 1;\n            while (buffer.get(lastByte) != '\\n')\n                --lastByte;\n            buffers.add(new Buffer(buffer, lastByte + 1));\n        }\n        return buffers;\n    }\n\n    public void close() throws Exception {\n        channel.close();\n    }\n\n    public record Buffer(ByteBuffer byteBuffer, int length) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FileChannelProcessor {\n    public static final int BUFFER_SIZE = 500 * 1024 * 1024; // 500MB\n    private final FileChannel channel;\n    private List<Buffer> buffers;\n\n    public FileChannelProcessor(Path filePath) throws IOException {\n        this.channel = FileChannel.open(filePath, StandardOpenOption.READ);\n        this.buffers = new ArrayList<>();\n    }\n\n    public List<Buffer> createBuffers() throws IOException {\n        long fileSize = channel.size();\n        long start = 0;\n        while (start < fileSize) {\n            long end = Math.min(start + BUFFER_SIZE, fileSize);\n            MappedByteBuffer buffer = channel.map(MapMode.READ_ONLY, start, end - start);\n            int dataLength = (int) (end - start);\n            byte[] data = new byte[dataLength];\n            buffer.get(data, 0, dataLength);\n            int lastNewline = -1;\n            for (int i = dataLength - 1; i >= 0; i--) {\n                if (data[i] == '\\n') {\n                    lastNewline = i;\n                    break;\n                }\n            }\n            int effectiveLength = lastNewline != -1 ? lastNewline + 1 : dataLength;\n            buffers.add(new Buffer(buffer, effectiveLength));\n            start += BUFFER_SIZE;\n        }\n        return buffers;\n    }\n\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n\n    public record Buffer(ByteBuffer byteBuffer, int length) {}\n}"
  },
  {
    "Task_id": 250,
    "Instruction": "Task Description: Create a Java class that implements a web scraper using the OkHttp library to make HTTP requests, handle authentication, and process responses with retry logic for failed attempts.\n\nClass Description: The Scraper class provides functionality to scrape content from web URLs using HTTP requests. It supports basic authentication and includes timeout handling with retry logic for failed requests.\n\nAttributes:\n- client: OkHttpClient - The HTTP client instance used to make requests\n\nMethods:\n- Scraper() -> None - Constructor that initializes the OkHttpClient instance\n- scrape(String url, long timeoutMillis) -> List<String> - Scrapes content from the given URL without authentication, with a specified timeout\n- scrape(String url, String user, String password, long timeoutMillis) -> List<String> - Scrapes content from the given URL with basic authentication, with a specified timeout",
    "Canonical_solution": "import okhttp3.Credentials;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Scraper {\n\n    private OkHttpClient client;\n    \n    public Scraper() {\n        this.client = new OkHttpClient();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return scrape(url, null, null, timeoutMillis);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        long start = System.currentTimeMillis();\n        Exception exception = null;\n        while (System.currentTimeMillis() - start < timeoutMillis) {\n            try {\n                Request.Builder requestBuilder = new Request.Builder()\n                        .header(\"Accept\", \"application/openmetrics-text; version=1.0.0; charset=utf-8\")\n                        .url(url);\n                if (user != null && password != null) {\n                    requestBuilder.header(\"Authorization\", Credentials.basic(user, password));\n                }\n                Request request = requestBuilder.build();\n                try (Response response = client.newCall(request).execute()) {\n                    if (response.code() != 200) {\n                        throw new IOException(\"Received HTTP Status \" + response.code() + \": \" + response.body().string());\n                    }\n                    return Arrays.asList(response.body().string().split(\"\\\\n\"));\n                }\n            } catch (Exception e) {\n                exception = e;\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        }\n        if (exception != null) {\n            exception.printStackTrace();\n        }\n        return null;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 22,
    "right_result": "import okhttp3.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class Scraper {\n    private final OkHttpClient client;\n\n    public Scraper() {\n        this.client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(10, TimeUnit.SECONDS)\n                .build();\n    }\n\n    public List<String> scrape(String url, long timeoutMillis) {\n        return scrapeWithRetry(url, null, null, timeoutMillis);\n    }\n\n    public List<String> scrape(String url, String user, String password, long timeoutMillis) {\n        return scrapeWithRetry(url, user, password, timeoutMillis);\n    }\n\n    private List<String> scrapeWithRetry(String url, String user, String password, long timeoutMillis) {\n        List<String> result = new ArrayList<>();\n        int retryCount = 3;\n        for (int i = 0; i <= retryCount; i++) {\n            try {\n                OkHttpClient tempClient = new OkHttpClient.Builder()\n                        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)\n                        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)\n                        .build();\n\n                Request.Builder requestBuilder = new Request.Builder().url(url);\n\n                if (user != null && password != null) {\n                    String credentials = user + \":\" + password;\n                    String base64Credentials = Base64.getEncoder().encodeToString(credentials.getBytes());\n                    requestBuilder.header(\"Authorization\", \"Basic \" + base64Credentials);\n                }\n\n                Request request = requestBuilder.build();\n                Response response = tempClient.newCall(request).execute();\n                if (response.isSuccessful()) {\n                    result.add(response.body().string());\n                    return result;\n                } else {\n                    if (i == retryCount) {\n                        throw new RuntimeException(\"Request failed after \" + retryCount + \" retries\");\n                    }\n                    Thread.sleep(1000); // Wait before retry\n                }\n            } catch (Exception e) {\n                if (i == retryCount) {\n                    throw new RuntimeException(\"Request failed after \" + retryCount + \" retries\", e);\n                }\n                Thread.sleep(1000); // Wait before retry\n            }\n        }\n        return result;\n    }\n}"
  },
  {
    "Task_id": 260,
    "Instruction": "Task Description: Create a Java class that implements a Kafka Producer for sending maintenance plan messages to a Kafka topic.\n\nClass Description: The MaintenancePlanProducer class is responsible for producing and sending maintenance plan messages to a specified Kafka topic. It handles the configuration of the Kafka Producer, message sending, and resource cleanup.\n\nAttributes:\n- _producer: Producer<String, MaintenancePlan> - The Kafka Producer instance used to send messages to Kafka.\n\nMethods:\n- MaintenancePlanProducer(String bootstrapServers, Properties overrides) -> void - Constructor that initializes the Kafka Producer with the given bootstrap servers and optional configuration overrides.\n  - Input Parameters:\n    - bootstrapServers: String - Comma-separated list of Kafka broker addresses\n    - overrides: Properties - Optional additional Kafka Producer configuration properties\n- sendPlan(String topic, MaintenancePlan maintenancePlan) -> void - Sends a maintenance plan to the specified Kafka topic.\n  - Input Parameters:\n    - topic: String - The Kafka topic to send the message to\n    - maintenancePlan: MaintenancePlan - The maintenance plan object to be sent\n- close() -> void - Closes the Kafka Producer and releases all resources.\n  - No input parameters",
    "Canonical_solution": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\n\npublic class MaintenancePlanProducer {\n    private Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getCanonicalName());\n        props.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, MaintenancePlanSerde.class.getCanonicalName());\n        \n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        \n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan), (recordMetadata, e) -> {\n            if (e != null) {\n                throw new RuntimeException(\"Failed to produce maintenance plan\", e);\n            }\n        });\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 31,
    "right_result": "import org.apache.kafka.clients.producer.KafkaProducer;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic class MaintenancePlanProducer {\n    private final Producer<String, MaintenancePlan> _producer;\n\n    public MaintenancePlanProducer(String bootstrapServers, Properties overrides) {\n        Properties props = new Properties();\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringSerializer\");\n        if (overrides != null) {\n            props.putAll(overrides);\n        }\n        _producer = new KafkaProducer<>(props);\n    }\n\n    public void sendPlan(String topic, MaintenancePlan maintenancePlan) throws ExecutionException, InterruptedException {\n        _producer.send(new ProducerRecord<>(topic, maintenancePlan.toString(), maintenancePlan)).get();\n    }\n\n    public void close() {\n        _producer.close();\n    }\n}"
  },
  {
    "Task_id": 263,
    "Instruction": "Task Description: Implement a Java NIO HTTP server that handles multiple client connections asynchronously, measures throughput performance, and tracks message statistics.\n\nClass Description: NioServerPerfTest is a non-blocking NIO server implementation that accepts client connections, reads data efficiently, and tracks performance metrics including bytes received, messages processed, and throughput rates.\n\nAttributes:\n- ch: [ServerSocketChannel] - The server socket channel listening for incoming connections\n- selector: [Selector] - The selector managing multiple non-blocking channels\n- running: [boolean] - Flag controlling server execution\n- buffer: [ByteBuffer] - Buffer for reading incoming data\n- total_bytes_received: [AtomicLong] - Counter for total bytes received\n- total_msgs: [AtomicLong] - Counter for total messages processed\n- start: [AtomicLong] - Timestamp for performance measurement start\n\nMethods:\n- create: [create(int size, boolean direct)] -> [ByteBuffer] - Creates a new ByteBuffer of given size, optionally direct\n- start: [start(boolean direct)] -> [void] - Starts the NIO server with specified buffer type (direct/heap)\n- handle: [handle(SocketChannel ch, ByteBuffer buf)] -> [boolean] - Handles read operations from a client channel, returns false to close connection",
    "Canonical_solution": "import org.jgroups.util.Util;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic class NioServerPerfTest {\n    protected ServerSocketChannel ch;\n    protected Selector            selector;\n    protected volatile boolean    running=true;\n    protected ByteBuffer          buffer;\n    protected final AtomicLong    total_bytes_received=new AtomicLong(0);\n    protected final AtomicLong    total_msgs=new AtomicLong(0);\n    protected final AtomicLong    start=new AtomicLong(0);\n\n    public static final long      BYTES_TO_SEND=10_000_000;\n    public static final int       SIZE=1000;\n\n    protected static ByteBuffer create(int size, boolean direct) {\n        return direct? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    protected void start(boolean direct) throws Exception {\n        selector=Selector.open();\n\n        ch=ServerSocketChannel.open();\n        ch.bind(new InetSocketAddress(\"0.0.0.0\", 7500));\n        ch.configureBlocking(false);\n        ch.register(selector, SelectionKey.OP_ACCEPT, null);\n        System.out.println(\"-- server ready\");\n\n        while(running) {\n            selector.select();\n            Set<SelectionKey> keys=selector.selectedKeys();\n            for(Iterator<SelectionKey> it=keys.iterator(); it.hasNext();) {\n                SelectionKey key=it.next();\n                if(!key.isValid()) {\n                    it.remove();\n                    continue;\n                }\n                it.remove();\n                if(key.isAcceptable()) {\n                    SocketChannel client_ch=ch.accept();\n                    if(client_ch != null) {\n                        System.out.printf(\"accepted connection from %s\\n\", client_ch.getRemoteAddress());\n                        client_ch.configureBlocking(false);\n                        client_ch.register(selector, SelectionKey.OP_READ, create(SIZE, direct));\n                    }\n                }\n                else if(key.isReadable()) {\n                    if(!handle((SocketChannel)key.channel(), (ByteBuffer)key.attachment())) {\n                        key.cancel();\n                        Util.close(key.channel());\n                    }\n                }\n            }\n        }\n\n        Util.close(selector,ch);\n    }\n\n    protected boolean handle(SocketChannel ch, ByteBuffer buf) {\n        try {\n            if(start.get() == 0)\n                start.compareAndSet(0, System.currentTimeMillis());\n            int num=ch.read(buf);\n            if(num < 0)\n                return false;\n            total_bytes_received.addAndGet(num);\n            if(!buf.hasRemaining()) {\n                total_msgs.incrementAndGet();\n                buf.rewind();\n            }\n            if(total_bytes_received.get() >= BYTES_TO_SEND) {\n                long time=System.currentTimeMillis() - start.get();\n                double throughput_sec=total_bytes_received.get() / (time / 1000.0), msgs_sec=total_msgs.get() / (time / 1000.0);\n                System.out.printf(\"\\n===========================\\nreceived %d messages in %.2f secs: throughput: %s/sec, %.2f msgs/sec\\n\",\n                                  total_msgs.get(), time/1000.0, Util.printBytes(throughput_sec), msgs_sec);\n                start.set(0);\n                total_bytes_received.set(0);\n                total_msgs.set(0);\n                return false;\n            }\n        }\n        catch(IOException e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 21,
    "right_result": "import java.nio.channels.*;\nimport java.nio.ByteBuffer;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.io.IOException;\n\npublic class NioServerPerfTest {\n    private ServerSocketChannel ch;\n    private Selector selector;\n    private boolean running;\n    private ByteBuffer buffer;\n    private final AtomicLong total_bytes_received = new AtomicLong();\n    private final AtomicLong total_msgs = new AtomicLong();\n    private final AtomicLong start = new AtomicLong();\n\n    public ByteBuffer create(int size, boolean direct) {\n        return direct ? ByteBuffer.allocateDirect(size) : ByteBuffer.allocate(size);\n    }\n\n    public void start(boolean direct) {\n        try {\n            ch = ServerSocketChannel.open();\n            ch.configureBlocking(false);\n            ch.socket().bind(new InetSocketAddress(8080));\n            selector = Selector.open();\n            buffer = create(1024, direct);\n            start.set(System.currentTimeMillis());\n            ch.register(selector, SelectionKey.OP_ACCEPT);\n            running = true;\n            while (running) {\n                int events = selector.select();\n                if (events == 0) continue;\n                Set<SelectionKey> keys = selector.selectedKeys();\n                Iterator<SelectionKey> it = keys.iterator();\n                while (it.hasNext()) {\n                    SelectionKey key = it.next();\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n                        SocketChannel clientChannel = serverChannel.accept();\n                        clientChannel.configureBlocking(false);\n                        clientChannel.register(selector, SelectionKey.OP_READ);\n                    } else if (key.isReadable()) {\n                        SocketChannel clientChannel = (SocketChannel) key.channel();\n                        if (!handle(clientChannel, buffer)) {\n                            clientChannel.close();\n                        }\n                    }\n                    it.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean handle(SocketChannel ch, ByteBuffer buf) {\n        buf.clear();\n        int bytesRead = ch.read(buf);\n        if (bytesRead == -1) {\n            return false;\n        }\n        if (bytesRead > 0) {\n            total_bytes_received.addAndGet(bytesRead);\n            total_msgs.incrementAndGet();\n        }\n        return true;\n    }\n}"
  },
  {
    "Task_id": 268,
    "Instruction": "Task Description: Create a Java class that implements an HTTP/2 server using Netty framework, supporting SSL/TLS encryption and providing methods for server startup and shutdown.\n\nClass Description: BaseHttp2Server is an abstract class that serves as a foundation for building HTTP/2 servers using Netty. It handles SSL/TLS configuration, channel management, and provides basic server lifecycle methods. Concrete implementations must define their own request handlers.\n\nAttributes:\n- sslContext: [SslContext] - SSL/TLS context for secure connections\n- hasReleasedSslContext: [AtomicBoolean] - Tracks whether SSL context resources have been released\n- bootstrap: [ServerBootstrap] - Netty server bootstrap configuration\n- shouldShutDownEventLoopGroup: [boolean] - Flag indicating whether to shutdown event loop group\n- allChannels: [ChannelGroup] - Tracks all active server channels\n\nMethods:\n- BaseHttp2Server([SslContext], [EventLoopGroup]) -> [void] - Constructor that initializes the server with SSL context and optional event loop group\n- addHandlersToPipeline([SSLSession], [ChannelPipeline]) -> [void] - Abstract method to be implemented by subclasses for adding custom handlers to the pipeline\n- start([int]) -> [CompletableFuture<Integer>] - Starts the server on specified port and returns future with bound port number\n- shutdown() -> [CompletableFuture<Void>] - Gracefully shuts down the server and releases resources",
    "Canonical_solution": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.ReferenceCounted;\nimport io.netty.util.concurrent.Future;\nimport java.net.InetSocketAddress;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLSession;\n\nabstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext = new AtomicBoolean(false);\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    BaseHttp2Server(final SslContext sslContext, final EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n\n        if (this.sslContext instanceof ReferenceCounted) {\n            ((ReferenceCounted) this.sslContext).retain();\n        }\n\n        this.bootstrap = new ServerBootstrap();\n\n        if (eventLoopGroup != null) {\n            this.bootstrap.group(eventLoopGroup);\n            this.shouldShutDownEventLoopGroup = false;\n        } else {\n            this.bootstrap.group(new NioEventLoopGroup(1));\n            this.shouldShutDownEventLoopGroup = true;\n        }\n\n        this.allChannels = new DefaultChannelGroup(this.bootstrap.config().group().next());\n\n        this.bootstrap.channel(ServerChannelClassUtil.getServerSocketChannelClass(this.bootstrap.config().group()));\n        this.bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(final SocketChannel channel) {\n                final SslHandler sslHandler = sslContext.newHandler(channel.alloc());\n                channel.pipeline().addLast(sslHandler);\n\n                sslHandler.handshakeFuture().addListener(handshakeFuture -> {\n                    if (handshakeFuture.isSuccess()) {\n                        BaseHttp2Server.this.addHandlersToPipeline(sslHandler.engine().getSession(), channel.pipeline());\n                        BaseHttp2Server.this.allChannels.add(channel);\n                    }\n                });\n            }\n        });\n    }\n\n    protected abstract void addHandlersToPipeline(final SSLSession sslSession, final ChannelPipeline pipeline) throws Exception;\n\n    public CompletableFuture<Integer> start(final int port) {\n        final ChannelFuture channelFuture = this.bootstrap.bind(port);\n        this.allChannels.add(channelFuture.channel());\n\n        final CompletableFuture<Integer> startFuture = new CompletableFuture<>();\n\n        channelFuture.addListener((future -> {\n            if (future.isSuccess()) {\n                startFuture.complete(((InetSocketAddress) channelFuture.channel().localAddress()).getPort());\n            } else {\n                startFuture.completeExceptionally(future.cause());\n            }\n        }));\n\n        return startFuture;\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        final CompletableFuture<Void> shutdownFuture = new CompletableFuture<>();\n        final Future<Void> channelCloseFuture = this.allChannels.close();\n\n        if (this.shouldShutDownEventLoopGroup) {\n            channelCloseFuture.addListener(future ->\n                    BaseHttp2Server.this.bootstrap.config().group().shutdownGracefully());\n\n            this.bootstrap.config().group().terminationFuture().addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        } else {\n            channelCloseFuture.addListener(future -> {\n                if (future.isSuccess()) {\n                    shutdownFuture.complete(null);\n                } else {\n                    shutdownFuture.completeExceptionally(future.cause());\n                }\n            });\n        }\n\n        return shutdownFuture.thenRun(() -> {\n            if (BaseHttp2Server.this.sslContext instanceof ReferenceCounted) {\n                if (BaseHttp2Server.this.hasReleasedSslContext.compareAndSet(false, true)) {\n                    ((ReferenceCounted) BaseHttp2Server.this.sslContext).release();\n                }\n            }\n        });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 19,
    "right_result": "import io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport io.netty.util.concurrent.Promise;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.CompletableFuture;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpContentCompressor;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.ssl.SslContextBuilder;\nimport io.netty.handler.ssl.util.SslContextUtil;\nimport io.netty.handler.ssl.util.InsecureTrustManagerFactory;\nimport io.netty.handler.ssl.util.SelfSignedCertificate;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.util.concurrent.GlobalEventExecutor;\n\npublic abstract class BaseHttp2Server {\n    private final SslContext sslContext;\n    private final AtomicBoolean hasReleasedSslContext;\n    private final ServerBootstrap bootstrap;\n    private final boolean shouldShutDownEventLoopGroup;\n    private final ChannelGroup allChannels;\n\n    public BaseHttp2Server(SslContext sslContext, EventLoopGroup eventLoopGroup) {\n        this.sslContext = sslContext;\n        this.hasReleasedSslContext = new AtomicBoolean(false);\n        this.bootstrap = new ServerBootstrap();\n        this.shouldShutDownEventLoopGroup = true;\n        this.allChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n        \n        bootstrap.group(eventLoopGroup, new NioEventLoopGroup())\n                 .channel(NioServerSocketChannel.class)\n                 .childHandler(new ChannelInitializer<Channel>() {\n                     @Override\n                     protected void initChannel(Channel ch) throws Exception {\n                         ChannelPipeline pipeline = ch.pipeline();\n                         if (sslContext != null) {\n                             pipeline.addLast(new SslHandler(sslContext.newEngine(ch.alloc())));\n                         }\n                         addHandlersToPipeline((SSLSession)null, pipeline);\n                     }\n                 })\n                 .option(ChannelOption.SO_BACKLOG, 128)\n                 .childOption(ChannelOption.SO_KEEPALIVE, true);\n    }\n\n    protected abstract void addHandlersToPipeline(SSLSession sslSession, ChannelPipeline pipeline);\n\n    public CompletableFuture<Integer> start(int port) {\n        return bootstrap.bind(port).thenApply(f -> {\n            if (f.isSuccess()) {\n                Channel channel = f.channel();\n                allChannels.add(channel);\n                return channel.localAddress().getPort();\n            } else {\n                throw new RuntimeException(\"Failed to bind to port \" + port, f.cause());\n            }\n        });\n    }\n\n    public CompletableFuture<Void> shutdown() {\n        return shutdown(false);\n    }\n\n    public CompletableFuture<Void> shutdown(boolean force) {\n        Promise<Void> promise = new DefaultPromise<>(GlobalEventExecutor.INSTANCE);\n        if (allChannels.isEmpty()) {\n            promise.setSuccess(null);\n            return promise;\n        }\n\n        allChannels.close().addListener((GenericFutureListener<Future<? super Void>>) future -> {\n            if (future.isSuccess()) {\n                if (shouldShutDownEventLoopGroup) {\n                    bootstrap.config().group().shutdownGracefully();\n                }\n                if (!hasReleasedSslContext.getAndSet(true)) {\n                    sslContext.close();\n                }\n                promise.setSuccess(null);\n            } else {\n                promise.setFailure(future.cause());\n            }\n        });\n\n        return promise;\n    }\n}"
  },
  {
    "Task_id": 27,
    "Instruction": "Task Description: Implement a class for memory-mapped file reading with random access capabilities using Java NIO's FileChannel and MappedByteBuffer.\n\nClass Description: RandomAccessReadMemoryMappedFile is a class that provides random access reading functionality for files using memory-mapped I/O. It maps a file into memory for efficient reading operations and implements common random access operations like seek, read, and position tracking.\n\nAttributes:\n- mappedByteBuffer: ByteBuffer - The memory-mapped buffer containing the file contents\n- size: long - The size of the file in bytes\n- fileChannel: FileChannel - The file channel used for memory mapping\n- unmapper: Consumer<? super ByteBuffer> - A consumer for properly unmapping the buffer when closing\n\nMethods:\n- Constructor(filename: String) -> void - Creates an instance by opening the specified file\n- Constructor(file: File) -> void - Creates an instance using the specified File object\n- Constructor(path: Path) -> void - Creates an instance using the specified Path object\n- close() -> void - Closes the file channel and unmaps the buffer\n- seek(position: long) -> void - Sets the reading position in the file\n- getPosition() -> long - Returns the current reading position\n- read() -> int - Reads a single byte from the current position\n- read(b: byte[], offset: int, length: int) -> int - Reads bytes into an array\n- length() -> long - Returns the file size\n- isClosed() -> boolean - Checks if the reader is closed\n- isEOF() -> boolean - Checks if the current position is at end of file\n- checkClosed() -> void - Internal method to verify the reader isn't closed (throws IOException if closed)",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.EnumSet;\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile implements RandomAccessRead\n{\n    private ByteBuffer mappedByteBuffer;\n    private final long size;\n    private final FileChannel fileChannel;\n    private final Consumer<? super ByteBuffer> unmapper;\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException\n    {\n        this(new File(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException\n    {\n        this(file.toPath());\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException\n    {\n        fileChannel = FileChannel.open(path, EnumSet.of(StandardOpenOption.READ));\n        size = fileChannel.size();\n        if (size > Integer.MAX_VALUE)\n        {\n            throw new IOException(getClass().getName() + \" doesn't yet support files bigger than \"\n                    + Integer.MAX_VALUE);\n        }\n        mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n        unmapper = IOUtils::unmap;\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        if (fileChannel != null)\n        {\n            fileChannel.close();\n        }\n        if (mappedByteBuffer != null)\n        {\n            Optional.ofNullable(unmapper).ifPresent(u -> u.accept(mappedByteBuffer));\n            mappedByteBuffer = null;\n        }\n    }\n\n    @Override\n    public void seek(long position) throws IOException\n    {\n        checkClosed();\n        if (position < 0)\n        {\n            throw new IOException(\"Invalid position \"+position);\n        }\n        mappedByteBuffer.position((int) Math.min(position, size));\n    }\n\n    @Override\n    public long getPosition() throws IOException\n    {\n       checkClosed();\n       return mappedByteBuffer.position();\n    }\n\n    @Override\n    public int read() throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        return mappedByteBuffer.get() & 0xff;\n    }\n\n    @Override\n    public int read(byte[] b, int offset, int length) throws IOException\n    {\n        if (isEOF())\n        {\n            return -1;\n        }\n        int remainingBytes = (int)size - mappedByteBuffer.position();\n        remainingBytes = Math.min(remainingBytes, length);\n        mappedByteBuffer.get(b, offset, remainingBytes);\n        return remainingBytes;\n    }\n\n    @Override\n    public long length() throws IOException\n    {\n        checkClosed();\n        return size;\n    }\n\n    private void checkClosed() throws IOException\n    {\n        if (isClosed())\n        {\n            throw new IOException(getClass().getSimpleName() + \" already closed\");\n        }\n    }\n\n    @Override\n    public boolean isClosed()\n    {\n        return mappedByteBuffer == null;\n    }\n\n    @Override\n    public boolean isEOF() throws IOException\n    {\n        checkClosed();\n        return mappedByteBuffer.position() >= size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Consumer;\n\npublic class RandomAccessReadMemoryMappedFile {\n    private final FileChannel fileChannel;\n    private final MappedByteBuffer mappedByteBuffer;\n    private final long size;\n    private final Consumer<ByteBuffer> unmapper;\n    private boolean closed = false;\n\n    public RandomAccessReadMemoryMappedFile(String filename) throws IOException {\n        this(Paths.get(filename));\n    }\n\n    public RandomAccessReadMemoryMappedFile(File file) throws IOException {\n        this(Paths.get(file.toURI()));\n    }\n\n    public RandomAccessReadMemoryMappedFile(Path path) throws IOException {\n        this.fileChannel = FileChannel.open(path, java.nio.file.StandardOpenOption.READ);\n        this.size = Files.size(path);\n        this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_ONLY, 0, this.size);\n        this.unmapper = bb -> {\n            // Assuming that closing the file channel unmaps the buffer\n        };\n    }\n\n    public void close() {\n        if (closed) return;\n        try {\n            checkClosed();\n            this.fileChannel.close();\n            this.unmapper.accept(this.mappedByteBuffer);\n        } catch (IOException e) {\n            // Handle exception\n        } finally {\n            this.closed = true;\n        }\n    }\n\n    public void seek(long position) {\n        checkClosed();\n        if (position < 0 || position > size) {\n            throw new IllegalArgumentException(\"Position out of bounds\");\n        }\n        this.fileChannel.position(position);\n    }\n\n    public long getPosition() {\n        checkClosed();\n        return this.fileChannel.position();\n    }\n\n    public int read() {\n        checkClosed();\n        if (isEOF()) {\n            return -1;\n        }\n        return this.mappedByteBuffer.get() & 0xFF;\n    }\n\n    public int read(byte[] b, int offset, int length) {\n        checkClosed();\n        if (isEOF()) {\n            return -1;\n        }\n        int bytesRead = 0;\n        int remaining = length;\n        while (remaining > 0) {\n            int available = (int) (size - this.fileChannel.position());\n            int toRead = Math.min(remaining, available);\n            if (toRead <= 0) {\n                break;\n            }\n            bytesRead += this.mappedByteBuffer.get(b, offset + bytesRead, toRead);\n            remaining -= toRead;\n        }\n        return bytesRead == 0 ? -1 : bytesRead;\n    }\n\n    public long length() {\n        checkClosed();\n        return this.size;\n    }\n\n    public boolean isClosed() {\n        return this.closed;\n    }\n\n    public boolean isEOF() {\n        checkClosed();\n        return this.fileChannel.position() == this.size;\n    }\n\n    private void checkClosed() throws IOException {\n        if (this.closed) {\n            throw new IOException(\"Reader is closed\");\n        }\n    }\n}"
  },
  {
    "Task_id": 279,
    "Instruction": "Task Description: Create a Java class that facilitates interaction with external processes through command execution, providing methods for writing input, executing commands, and retrieving results, with support for timeout handling and resource cleanup.\n\nClass Description: The Command class encapsulates functionality for executing and interacting with external processes. It handles process creation, input/output stream management, command execution, and result collection, with features for line-based input, process termination, and timeout control.\n\nAttributes:\n\nprocess: [Process] - The running external process instance\nstdIn: [OutputStream] - Stream for writing input to the process\nstdOut: [File] - Temporary file storing the process's standard output\nstdErr: [File] - Temporary file storing the process's error output\nnextLine: [String] - Line separator string for command input\nexit: [String] - Command string to terminate the process\ncharset: [Charset] - Character encoding for input/output\nstartTime: [LocalDateTime] - Timestamp when the process was started\n\nMethods:\n\nof: [of(String init)] -> [Command] - Creates a Command instance with default settings\nof: [of(String init, Charset charset)] -> [Command] - Creates a Command instance with specified charset\nof: [of(String init, String nextLine, String exit, Charset charset)] -> [Command] - Creates a Command instance with custom settings\nwrite: [write(String str)] -> [Command] - Writes a string to the process's input stream\nline: [line()] -> [Command] - Writes a line separator to the process's input stream\nexit: [exit()] -> [Command] - Sends the exit command to terminate the process\nexec: [exec(String str)] -> [Command] - Executes a command string (writes input and adds line separator)\nresult: [result()] -> [CommandResult] - Waits for process completion and returns results\nresult: [result(long millis)] -> [CommandResult] - Waits with timeout for process completion\nclose: [close()] -> [void] - Terminates the process and releases resources",
    "Canonical_solution": "import java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.time.LocalDateTime;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\n\npublic final class Command {\n\n    public static final String NEXT_LINE = SystemUtils.lineSeparator();\n    public static final String EXIT_COMMAND = \"exit\";\n\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String init, String nextLine, String exit, Charset charset) throws IOException {\n        if (!StringUtils.hasText(init)) {\n            throw new IllegalArgumentException(\"Empty init\");\n        }\n        StringTokenizer st = new StringTokenizer(init);\n        String[] cmdArray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++) {\n            cmdArray[i] = st.nextToken();\n        }\n\n        this.stdOut = FileUtils.createTemp();\n        this.stdErr = FileUtils.createTemp();\n\n        ProcessBuilder builder = new ProcessBuilder(cmdArray).redirectError(this.stdErr).redirectOutput(this.stdOut);\n        this.process = builder.start();\n        this.stdIn = this.process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        this.startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) throws IOException {\n        return of(init, SystemUtils.charset());\n    }\n\n    public static Command of(String init, Charset charset) throws IOException {\n        return of(init, NEXT_LINE, EXIT_COMMAND, charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) throws IOException {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) throws IOException {\n        this.stdIn.write(str.getBytes(this.charset));\n        this.stdIn.flush();\n        return this;\n    }\n\n    public Command line() throws IOException {\n        return write(this.nextLine);\n    }\n\n    public Command exit() throws IOException {\n        write(this.exit);\n        return line();\n    }\n\n    public Command exec(String str) throws IOException {\n        write(str);\n        return line();\n    }\n\n    public CommandResult result() throws InterruptedException {\n        this.process.waitFor();\n        return CommandResult.of(this.stdOut, this.stdErr, this.startTime, LocalDateTime.now(), this.charset);\n    }\n\n    public CommandResult result(long millis) throws InterruptedException, CommandTimeoutException {\n        if (this.process.waitFor(millis, TimeUnit.MILLISECONDS)) {\n            return result();\n        }\n        this.process.destroyForcibly();\n        throw new CommandTimeoutException();\n    }\n\n    public void close() {\n        this.process.destroy();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 44,
    "right_result": "import java.io.*;\nimport java.nio.file.*;\nimport java.nio.charset.*;\nimport java.time.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class Command {\n    private final Process process;\n    private final OutputStream stdIn;\n    private final File stdOut;\n    private final File stdErr;\n    private final String nextLine;\n    private final String exit;\n    private final Charset charset;\n    private final LocalDateTime startTime;\n\n    private Command(String command, String nextLine, String exit, Charset charset) throws IOException {\n        stdOut = Files.createTempFile(\"stdout\", \".txt\").toFile();\n        stdErr = Files.createTempFile(\"stderr\", \".txt\").toFile();\n        ProcessBuilder pb = new ProcessBuilder(command.split(\" \"));\n        pb.redirectOutput(stdOut);\n        pb.redirectError(stdErr);\n        process = pb.start();\n        stdIn = process.getOutputStream();\n        this.nextLine = nextLine;\n        this.exit = exit;\n        this.charset = charset;\n        startTime = LocalDateTime.now();\n    }\n\n    public static Command of(String init) {\n        return new Command(init, \"\\n\", \"exit\", StandardCharsets.UTF_8);\n    }\n\n    public static Command of(String init, Charset charset) {\n        return new Command(init, \"\\n\", \"exit\", charset);\n    }\n\n    public static Command of(String init, String nextLine, String exit, Charset charset) {\n        return new Command(init, nextLine, exit, charset);\n    }\n\n    public Command write(String str) {\n        try {\n            byte[] bytes = str.getBytes(charset);\n            stdIn.write(bytes);\n            stdIn.flush();\n        } catch (IOException e) {\n            // Handle exception if needed\n        }\n        return this;\n    }\n\n    public Command line() {\n        return write(nextLine);\n    }\n\n    public Command exit() {\n        return write(exit);\n    }\n\n    public Command exec(String str) {\n        write(str);\n        line();\n        return this;\n    }\n\n    public CommandResult result() {\n        return result(Long.MAX_VALUE);\n    }\n\n    public CommandResult result(long millis) {\n        CommandResult result = new CommandResult();\n        try {\n            boolean completed = process.waitFor(millis, TimeUnit.MILLISECONDS);\n            if (completed) {\n                String stdout = new String(Files.readAllBytes(stdOut.toPath()), charset);\n                String stderr = new String(Files.readAllBytes(stdErr.toPath()), charset);\n                int exitCode = process.exitValue();\n                result.setExitCode(exitCode);\n                result.setStdout(stdout);\n                result.setStderr(stderr);\n                result.setStartTime(startTime);\n                result.setEndTime(LocalDateTime.now());\n            } else {\n                process.destroyForcibly();\n                String stdout = new String(Files.readAllBytes(stdOut.toPath()), charset);\n                String stderr = new String(Files.readAllBytes(stdErr.toPath()), charset);\n                int exitCode = process.exitValue();\n                result.setExitCode(exitCode);\n                result.setStdout(stdout);\n                result.setStderr(stderr);\n                result.setStartTime(startTime);\n                result.setEndTime(LocalDateTime.now());\n            }\n        } catch (Exception e) {\n            // Handle exceptions\n        }\n        return result;\n    }\n\n    public void close() {\n        if (process != null && process.isAlive()) {\n            process.destroyForcibly();\n        }\n        try {\n            if (stdIn != null) stdIn.close();\n        } catch (IOException e) {\n            // Handle exception\n        }\n        stdOut.delete();\n        stdErr.delete();\n    }\n}\n\npublic class CommandResult {\n    private int exitCode;\n    private String stdout;\n    private String stderr;\n    private LocalDateTime startTime;\n    private LocalDateTime endTime;\n\n    public int getExitCode() {\n        return exitCode;\n    }\n\n    public void setExitCode(int exitCode) {\n        this.exitCode = exitCode;\n    }\n\n    public String getStdout() {\n        return stdout;\n    }\n\n    public void setStdout(String stdout) {\n        this.stdout = stdout;\n    }\n\n    public String getStderr() {\n        return stderr;\n    }\n\n    public void setStderr(String stderr) {\n        this.stderr = stderr;\n    }\n\n    public LocalDateTime getStartTime() {\n        return startTime;\n    }\n\n    public void setStartTime(LocalDateTime startTime) {\n        this.startTime = startTime;\n    }\n\n    public LocalDateTime getEndTime() {\n        return endTime;\n    }\n\n    public void setEndTime(LocalDateTime endTime) {\n        this.endTime = endTime;\n    }\n}"
  },
  {
    "Task_id": 289,
    "Instruction": "Task Description: Implement a utility class that provides methods to retrieve system information, specifically the hostname, in a cross-platform manner (supporting both Linux and Windows operating systems).\n\nClass Description: The SystemInfoUtil class contains static methods for obtaining system information. It handles platform-specific differences internally and provides a consistent interface for retrieving the hostname.\n\nMethods:\n\nMethod1: getHostName() -> String - Retrieves the hostname of the current system. On Linux systems, it uses the 'uname -n' command, while on Windows it first tries the COMPUTERNAME environment variable and falls back to the 'hostname' command if needed. Returns an empty string if the hostname cannot be determined.\n\nMethod2: getUname(String param) -> String - A helper method that executes the 'uname' command with the specified parameter and returns its output. Primarily used internally by getHostName() for Linux systems. Returns an empty string if the command fails or times out.\n\nInput Parameters:\n- param (String): The parameter to pass to the uname command (e.g., \"-n\" for nodename)\n\nOutput:\n- String: The requested system information (hostname or uname output), or empty string if retrieval fails",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic static String getHostName()\n{\n    String hostname = \"\";\n\n    if (Platform.isLinux())\n    {\n        hostname = getUname(\"-n\");\n    }\n    else if (Platform.isWindows())\n    {\n        hostname = System.getenv().get(\"COMPUTERNAME\");\n        try\n        {\n            Process process = new ProcessBuilder(\"hostname\").start();\n            process.waitFor(1, TimeUnit.SECONDS);\n            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            hostname = br.readLine().trim();\n        }\n        catch (IOException | InterruptedException ignored)\n        {\n        }\n    }\n    return hostname;\n}\n\npublic static String getUname(String param)\n{\n    String uname = \"\";\n    try\n    {\n        Process process = new ProcessBuilder(\"uname\", param).start();\n        process.waitFor(1, TimeUnit.SECONDS);\n        BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        uname = br.readLine().trim();\n    }\n    catch (IOException | InterruptedException ignored)\n    {\n    }\n    return uname;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 44,
    "right_result": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.concurrent.TimeUnit;\n\npublic class SystemInfoUtil {\n    public static String getHostName() {\n        String os = System.getProperty(\"os.name\").toLowerCase();\n        if (os.contains(\"linux\")) {\n            return getUname(\"-n\");\n        } else if (os.contains(\"win\")) {\n            String computerName = System.getenv(\"COMPUTERNAME\");\n            if (computerName != null && !computerName.isEmpty()) {\n                return computerName;\n            } else {\n                return executeHostnameCommand();\n            }\n        }\n        return \"\";\n    }\n\n    public static String getUname(String param) {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"uname\", param);\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            boolean success = process.waitFor(10, TimeUnit.SECONDS);\n            if (!success) {\n                return \"\";\n            }\n            int exitCode = process.exitValue();\n            if (exitCode != 0) {\n                return \"\";\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString().trim();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    private static String executeHostnameCommand() {\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"hostname\");\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            boolean success = process.waitFor(10, TimeUnit.SECONDS);\n            if (!success) {\n                return \"\";\n            }\n            int exitCode = process.exitValue();\n            if (exitCode != 0) {\n                return \"\";\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString().trim();\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}"
  },
  {
    "Task_id": 3,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ producer for sending byte array messages to a specified queue.\n\nClass Description: The ActiveMQProducer class establishes a connection to an ActiveMQ broker, creates a message producer, and provides functionality to send byte array messages to a specified queue. It handles connection management and resource cleanup.\n\nAttributes:\n- connectionFactory: ActiveMQConnectionFactory - Factory for creating connections to the ActiveMQ broker\n- connection: javax.jms.Connection - The connection to the ActiveMQ broker\n- session: Session - JMS session for creating messages and producers\n- destination: Destination - The target queue for messages\n- producer: MessageProducer - The message producer for sending messages\n\nMethods:\n- ActiveMQProducer(String brokerUrl, String queueName) -> void - Constructor that initializes the connection to the ActiveMQ broker and sets up the message producer for the specified queue\n- sendBytesMessage(byte[] messageData) -> void - Creates and sends a bytes message containing the provided byte array to the configured queue\n- close() -> void - Closes the session and connection to release resources",
    "Canonical_solution": "import javax.jms.BytesMessage;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageProducer;\nimport javax.jms.Session;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class ActiveMQProducer {\n\n    private ActiveMQConnectionFactory connectionFactory;\n    private javax.jms.Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageProducer producer;\n\n    public ActiveMQProducer(String brokerUrl, String queueName) throws JMSException {\n        connectionFactory = new ActiveMQConnectionFactory(brokerUrl);\n        connection = connectionFactory.createConnection();\n        connection.start();\n        session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        destination = session.createQueue(queueName);\n        producer = session.createProducer(destination);\n    }\n\n    public void sendBytesMessage(byte[] messageData) throws JMSException {\n        BytesMessage message = session.createBytesMessage();\n        message.writeBytes(messageData);\n        producer.send(message);\n    }\n\n    public void close() throws JMSException {\n        session.close();\n        connection.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 38,
    "right_result": "import javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class ActiveMQProducer {\n    private ActiveMQConnectionFactory connectionFactory;\n    private Connection connection;\n    private Session session;\n    private Destination destination;\n    private MessageProducer producer;\n\n    public ActiveMQProducer(String brokerUrl, String queueName) {\n        connectionFactory = new ActiveMQConnectionFactory(brokerUrl);\n        try {\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            destination = Session.createQueue(queueName);\n            producer = session.createProducer(destination);\n        } catch (JMSException e) {\n        }\n    }\n\n    public void sendBytesMessage(byte[] messageData) {\n        try {\n            BytesMessage message = session.createBytesMessage();\n            message.writeBytes(messageData);\n            producer.send(message);\n        } catch (JMSException e) {\n        }\n    }\n\n    public void close() {\n        try {\n            if (producer != null) producer.close();\n            if (session != null) session.close();\n            if (connection != null) connection.close();\n        } catch (JMSException e) {\n        }\n    }\n}"
  },
  {
    "Task_id": 304,
    "Instruction": "Task Description: Implement a RabbitMQ message consumer in Java that connects to a RabbitMQ broker, declares a queue, and continuously consumes messages from that queue.\n\nClass Description: The MessageConsumer class provides functionality to connect to a RabbitMQ broker, initialize a message queue, consume messages from the queue, and properly close connections when finished.\n\nAttributes:\n- ROUTING_KEY: String - The name of the queue to consume messages from\n- factory: ConnectionFactory - RabbitMQ connection factory for broker configuration\n- connection: Connection - Active connection to the RabbitMQ broker\n- channel: Channel - Communication channel for message operations\n\nMethods:\n- MessageConsumer() - Constructor - Initializes the ConnectionFactory with default host settings\n- initializeConnection() throws Exception -> void - Establishes connection to RabbitMQ broker and creates a channel\n- startConsuming() throws Exception -> void - Starts consuming messages from the queue and prints received messages\n- close() throws Exception -> void - Closes the channel and connection to the RabbitMQ broker",
    "Canonical_solution": "import com.rabbitmq.client.*;\n\npublic class MessageConsumer {\n\n    private final static String ROUTING_KEY = \"SAMPLE_RABBITMQ\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        this.factory = new ConnectionFactory();\n        this.factory.setHost(\"127.0.0.1\");\n    }\n\n    public void initializeConnection() throws Exception {\n        this.connection = factory.newConnection();\n        this.channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        System.out.println(\"C [*] Waiting for messages. To exit press CTRL+C\");\n        Consumer consumer = new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Consumer [x] Received '\" + message + \"'\");\n            }\n        };\n        channel.basicConsume(ROUTING_KEY, true, consumer);\n    }\n\n    public void close() throws Exception {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 41,
    "right_result": "import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.DefaultConsumer;\nimport com.rabbitmq.client.Envelope;\nimport com.rabbitmq.client.IOException;\nimport java.io.IOException;\n\npublic class MessageConsumer {\n    private String ROUTING_KEY;\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public MessageConsumer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        factory.setPort(5672);\n        this.ROUTING_KEY = \"my_queue\";\n    }\n\n    public void initializeConnection() throws Exception {\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(ROUTING_KEY, false, false, false, null);\n    }\n\n    public void startConsuming() throws Exception {\n        channel.basicConsume(ROUTING_KEY, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException {\n                String message = new String(body, \"UTF-8\");\n                System.out.println(\"Received: \" + message);\n            }\n        });\n    }\n\n    public void close() throws Exception {\n        if (channel != null) {\n            channel.close();\n        }\n        if (connection != null) {\n            connection.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 305,
    "Instruction": "Task Description: Implement a RabbitMQ message producer in Java that sends messages to a specified exchange.\n\nClass Description: A service class that handles the production and sending of messages to a RabbitMQ exchange using a fanout pattern. The class manages connection setup, message publishing, and resource cleanup.\n\nAttributes:\n- EXCHANGE_NAME: String - The name of the RabbitMQ exchange to which messages will be published.\n\nMethods:\n- produceMessage(String message) -> String - Publishes the given message to the configured RabbitMQ exchange. Returns a simple response string.\n  - Input Parameters:\n    - message: String - The message content to be published\n  - Return Type: String - A simple response string (\"response\") indicating completion",
    "Canonical_solution": "import com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.visualpathit.account.utils.RabbitMqUtil;\nimport com.rabbitmq.client.Channel;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\n@Service\npublic class ProducerServiceImpl implements ProducerService {\n\n    private static final String EXCHANGE_NAME = \"messages\";\n\n    @Override\n    public String produceMessage(String message) {\n        try {\n            ConnectionFactory factory = new ConnectionFactory();\n            factory.setHost(RabbitMqUtil.getRabbitMqHost());\n            factory.setPort(Integer.parseInt(RabbitMqUtil.getRabbitMqPort()));\n            factory.setUsername(RabbitMqUtil.getRabbitMqUser());\n            factory.setPassword(RabbitMqUtil.getRabbitMqPassword());\n            Connection connection = factory.newConnection();\n            Channel channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            channel.close();\n            connection.close();\n        } catch (IOException io) {\n            io.printStackTrace();\n        } catch (TimeoutException toe) {\n            toe.printStackTrace();\n        }\n        return \"response\";\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "right_result": "import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class RabbitMQProducer {\n    private static final String EXCHANGE_NAME = \"my_exchange\";\n    private ConnectionFactory factory;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer() {\n        factory = new ConnectionFactory();\n        factory.setHost(\"localhost\");\n        factory.setPort(5672);\n        factory.setUsername(\"guest\");\n        factory.setPassword(\"guest\");\n        try {\n            connection = factory.newConnection();\n            channel = connection.createChannel();\n            channel.exchangeDeclare(EXCHANGE_NAME, \"fanout\");\n        } catch (IOException | TimeoutException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String produceMessage(String message) {\n        try {\n            channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes());\n            return \"response\";\n        } catch (IOException | TimeoutException e) {\n            return \"error\";\n        }\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null) channel.close();\n        if (connection != null) connection.close();\n    }\n}"
  },
  {
    "Task_id": 306,
    "Instruction": "Task Description: Implement a RabbitMQ producer class in Java that can connect to a RabbitMQ broker, send messages to a specified queue, and properly manage resources.\n\nClass Description: The RabbitMQProducer class provides functionality to establish a connection with a RabbitMQ message broker, declare a queue, send messages to that queue, and handle connection cleanup. It supports both single message and batch message sending operations.\n\nAttributes:\n- host: String - The hostname or IP address of the RabbitMQ server\n- port: int - The port number of the RabbitMQ server\n- username: String - The username for authentication with RabbitMQ\n- password: String - The password for authentication with RabbitMQ\n- queueName: String - The name of the queue to send messages to\n- durable: boolean - Whether the queue should survive server restarts\n- connection: Connection - The RabbitMQ connection object\n- channel: Channel - The RabbitMQ channel object for message operations\n\nMethods:\n- RabbitMQProducer(Map<String, String> config) -> void - Constructor that initializes the producer with configuration parameters\n- connect() -> void - Establishes connection to RabbitMQ and creates a channel\n- sendMessage(String message) -> void - Sends a single message to the declared queue\n- sendMessages(String[] messages) -> void - Sends multiple messages to the declared queue\n- close() -> void - Closes the channel and connection to release resources",
    "Canonical_solution": "import java.io.IOException;\nimport java.util.Map;\nimport java.util.concurrent.TimeoutException;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.MessageProperties;\n\npublic class RabbitMQProducer {\n\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"rabbitmq_host\");\n        this.port = Integer.parseInt(config.get(\"rabbitmq_port\"));\n        this.username = config.get(\"rabbitmq_user\");\n        this.password = config.get(\"rabbitmq_pass\");\n        this.queueName = config.get(\"rabbitmq_queuename\");\n        this.durable = config.get(\"rabbitmq_durable\").equals(\"true\");\n    }\n\n    public void connect() throws IOException, TimeoutException {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n        connection = factory.newConnection();\n        channel = connection.createChannel();\n        channel.queueDeclare(queueName, durable, false, false, null);\n    }\n\n    public void sendMessage(String message) throws IOException {\n        channel.basicPublish(\"\", queueName, \n            MessageProperties.PERSISTENT_TEXT_PLAIN,\n            message.getBytes()\n        );\n    }\n\n    public void sendMessages(String[] messages) throws IOException {\n        for (String message : messages) {\n            sendMessage(message);\n        }\n    }\n\n    public void close() throws IOException, TimeoutException {\n        if (channel != null && channel.isOpen()) {\n            channel.close();\n        }\n        if (connection != null && connection.isOpen()) {\n            connection.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 40,
    "right_result": "import com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.Channel;\n\npublic class RabbitMQProducer {\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private String queueName;\n    private boolean durable;\n    private Connection connection;\n    private Channel channel;\n\n    public RabbitMQProducer(Map<String, String> config) {\n        this.host = config.get(\"host\");\n        this.port = Integer.parseInt(config.get(\"port\"));\n        this.username = config.get(\"username\");\n        this.password = config.get(\"password\");\n        this.queueName = config.get(\"queueName\");\n        this.durable = Boolean.parseBoolean(config.get(\"durable\"));\n    }\n\n    public void connect() {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(host);\n        factory.setPort(port);\n        factory.setUsername(username);\n        factory.setPassword(password);\n        try {\n            connection = factory.newConnection();\n            channel = connection.createChannel();\n            channel.queueDeclare(queueName, durable, false, false, null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        try {\n            channel.basicPublish(\"\", queueName, null, message.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessages(String[] messages) {\n        for (String msg : messages) {\n            sendMessage(msg);\n        }\n    }\n\n    public void close() {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n            if (connection != null) {\n                connection.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 317,
    "Instruction": "Task Description: Create a Java class that provides a client interface for interacting with Redis Search functionality, including index creation, document management, search operations, and aggregation.\n\nClass Description: The RedisSearchClient class encapsulates Redis Search operations using the Jedis client library. It manages a connection to Redis and provides methods for creating search indexes, adding JSON documents, performing searches, and running aggregations.\n\nAttributes:\n- jedis: JedisPooled - The pooled Redis client connection used for all operations\n\nMethods:\n- RedisSearchClient(String host, int port) -> void - Constructor that initializes the Redis connection with the specified host and port\n- createIndex(String indexName, String prefix, SchemaField[] schema) -> void - Creates a new search index with the given name, prefix, and schema definition\n- addDocument(String key, Object document) -> void - Adds a JSON document to Redis with the specified key\n- search(String indexName, Query query) -> List<Document> - Performs a search query on the specified index and returns matching documents\n- aggregate(String indexName, AggregationBuilder aggregationBuilder) -> AggregationResult - Executes an aggregation query on the specified index and returns the results\n- close() -> void - Closes the Redis connection and releases resources",
    "Canonical_solution": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.search.*;\nimport redis.clients.jedis.search.aggr.*;\nimport redis.clients.jedis.search.schemafields.*;\n\npublic class RedisSearchClient {\n\n    private JedisPooled jedis;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        jedis.ftCreate(indexName,\n            FTCreateParams.createParams()\n                .on(IndexDataType.JSON)\n                .addPrefix(prefix),\n            schema\n        );\n    }\n\n    public void addDocument(String key, Object document) {\n        jedis.jsonSetWithEscape(key, document);\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        return jedis.ftSearch(indexName, query).getDocuments();\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        return jedis.ftAggregate(indexName, aggregationBuilder);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.exceptions.JedisException;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\n\npublic class RedisSearchClient {\n    private JedisPooled jedis;\n    private String currentIndexName;\n\n    public RedisSearchClient(String host, int port) {\n        this.jedis = new JedisPooled(host, port);\n    }\n\n    public void createIndex(String indexName, String prefix, SchemaField[] schema) {\n        StringBuilder schemaBuilder = new StringBuilder();\n        for (SchemaField field : schema) {\n            schemaBuilder.append(field.getName()).append(\" \").append(field.getType()).append(\" \");\n        }\n        String command = String.format(\"FT.CREATE %s PREFIX %s SCHEMA %s\", indexName, prefix, schemaBuilder.toString());\n        try {\n            jedis.sendCommand(Command.STRINGS, command);\n            currentIndexName = indexName;\n        } catch (JedisException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void addDocument(String key, Object document) {\n        String docStr = document.toString();\n        String command = String.format(\"FT.ADD %s %s 0 JSON %s\", currentIndexName, key, docStr);\n        try {\n            jedis.sendCommand(Command.STRINGS, command);\n        } catch (JedisException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public List<Document> search(String indexName, Query query) {\n        String queryStr = query.toString();\n        String command = String.format(\"FT.SEARCH %s %s\", indexName, queryStr);\n        try {\n            List<String> result = jedis.lrange(command, 0, -1);\n            List<Document> documents = new ArrayList<>();\n            for (String doc : result) {\n                documents.add(new Document(doc));\n            }\n            return documents;\n        } catch (JedisException e) {\n            e.printStackTrace();\n            return new ArrayList<>();\n        }\n    }\n\n    public AggregationResult aggregate(String indexName, AggregationBuilder aggregationBuilder) {\n        String aggCommand = aggregationBuilder.build(indexName);\n        try {\n            String result = jedis.get(aggCommand);\n            return new AggregationResult(result);\n        } catch (JedisException e) {\n            e.printStackTrace();\n            return new AggregationResult();\n        }\n    }\n\n    public void close() {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 318,
    "Instruction": "Task Description: Create a Redis connection manager class that handles both standalone and cluster Redis connections with token-based authentication for multiple users.\n\nClass Description: The RedisConnectionManager class provides functionality to establish and manage Redis connections (both standalone and cluster) using token-based authentication. It supports multiple authentication credentials and configures connection options like timeouts and reauthentication behavior.\n\nAttributes:\n- redisClient: RedisClient - The client for standalone Redis connections\n- redisClusterClient: RedisClusterClient - The client for Redis cluster connections\n- credentialsUser1: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 1\n- credentialsUser2: TokenBasedRedisCredentialsProvider - Authentication credentials provider for user 2\n\nMethods:\n- RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) -> void - Constructor that initializes the connection manager with Redis URI, authentication authority, scopes, and credentials for two users\n- createStandaloneConnection() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user1 credentials\n- createStandaloneConnectionWithUser2() -> StatefulRedisConnection<String, String> - Creates and returns a standalone Redis connection using user2 credentials\n- createClusterConnection() -> StatefulRedisClusterConnection<String, String> - Creates and returns a Redis cluster connection\n- close() -> void - Closes all connections and releases resources",
    "Canonical_solution": "import io.lettuce.authx.TokenBasedRedisCredentialsProvider;\nimport io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.SocketOptions;\nimport io.lettuce.core.TimeoutOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport io.lettuce.core.cluster.api.StatefulRedisClusterConnection;\nimport io.lettuce.core.cluster.api.sync.NodeSelection;\nimport io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;\nimport io.lettuce.core.codec.StringCodec;\nimport redis.clients.authentication.core.IdentityProviderConfig;\nimport redis.clients.authentication.core.TokenAuthConfig;\nimport redis.clients.authentication.entraid.EntraIDTokenAuthConfigBuilder;\n\nimport java.time.Duration;\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n    private TokenBasedRedisCredentialsProvider credentialsUser1;\n    private TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, \n                                String user1ClientId, String user1Secret, \n                                String user2ClientId, String user2Secret) {\n        IdentityProviderConfig config1;\n        try (EntraIDTokenAuthConfigBuilder builder = EntraIDTokenAuthConfigBuilder.builder()) {\n            config1 = builder.authority(authority).clientId(user1ClientId).secret(user1Secret).scopes(scopes)\n                    .tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        }\n\n        TokenAuthConfig tokenAuthConfigUser1 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config1).build();\n        credentialsUser1 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser1);\n\n        IdentityProviderConfig config2 = EntraIDTokenAuthConfigBuilder.builder().authority(authority).clientId(user2ClientId)\n                .secret(user2Secret).scopes(scopes).tokenRequestExecTimeoutInMs(10000).build().getIdentityProviderConfig();\n        TokenAuthConfig tokenAuthConfigUser2 = TokenAuthConfig.builder().tokenRequestExecTimeoutInMs(10000)\n                .expirationRefreshRatio(0.1f).identityProviderConfig(config2).build();\n        credentialsUser2 = TokenBasedRedisCredentialsProvider.create(tokenAuthConfigUser2);\n\n        RedisURI redisURI1 = RedisURI.create(redisUri);\n        redisURI1.setCredentialsProvider(credentialsUser1);\n\n        RedisURI redisURI2 = RedisURI.create(redisUri);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClient = RedisClient.create(redisURI1);\n        redisClient.setOptions(clientOptions);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        return redisClient.connect(StringCodec.UTF8);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        RedisURI redisURI2 = RedisURI.create(REDIS_URI);\n        redisURI2.setCredentialsProvider(credentialsUser2);\n        return redisClient.connect(StringCodec.UTF8, redisURI2);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()\n                .socketOptions(SocketOptions.builder().connectTimeout(Duration.ofSeconds(5)).build())\n                .disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS)\n                .timeoutOptions(TimeoutOptions.enabled(Duration.ofSeconds(1)))\n                .reauthenticateBehavior(ClientOptions.ReauthenticateBehavior.ON_NEW_CREDENTIALS).build();\n\n        redisClusterClient = RedisClusterClient.create(redisURI1);\n        redisClusterClient.setOptions(clusterClientOptions);\n        return redisClusterClient.connect(StringCodec.UTF8);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n        if (credentialsUser1 != null) {\n            credentialsUser1.close();\n        }\n        if (credentialsUser2 != null) {\n            credentialsUser2.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "RedisConnectionManager.java\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisClusterClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.StatefulRedisClusterConnection;\nimport java.util.Set;\n\npublic class RedisConnectionManager {\n    private final RedisClient redisClient;\n    private final RedisClusterClient redisClusterClient;\n    private final TokenBasedRedisCredentialsProvider credentialsUser1;\n    private final TokenBasedRedisCredentialsProvider credentialsUser2;\n\n    public RedisConnectionManager(String redisUri, String authority, Set<String> scopes, String user1ClientId, String user1Secret, String user2ClientId, String user2Secret) {\n        this.credentialsUser1 = new TokenBasedRedisCredentialsProvider(authority, scopes, user1ClientId, user1Secret);\n        this.credentialsUser2 = new TokenBasedRedisCredentialsProvider(authority, scopes, user2ClientId, user2Secret);\n        this.redisClient = RedisClient.create(redisUri);\n        this.redisClusterClient = RedisClusterClient.create(redisUri);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnection() {\n        String token = credentialsUser1.getToken();\n        return redisClient.connect().withPassword(token);\n    }\n\n    public StatefulRedisConnection<String, String> createStandaloneConnectionWithUser2() {\n        String token = credentialsUser2.getToken();\n        return redisClient.connect().withPassword(token);\n    }\n\n    public StatefulRedisClusterConnection<String, String> createClusterConnection() {\n        String token = credentialsUser1.getToken();\n        return redisClusterClient.connect().withPassword(token);\n    }\n\n    public void close() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 322,
    "Instruction": "Task Description: Implement a Redis data access object (DAO) class in Java that provides functionality for caching and retrieving Seckill objects using Redis as the storage backend. The class should handle connection management, serialization/deserialization, and implement a cache-aside pattern with distributed locking.\n\nClass Description: RedisDao is a Java class that interacts with Redis to store and retrieve Seckill objects. It uses Jedis as the Redis client, Protostuff for serialization, and implements distributed locking for thread-safe operations.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- schema: RuntimeSchema<Seckill> - The Protostuff schema for Seckill object serialization\n\nMethods:\n- RedisDao(String ip, int port) -> void - Constructor that initializes the JedisPool with given Redis server IP and port\n- getSeckill(long seckillId) -> Seckill - Retrieves a Seckill object from Redis by its ID\n- getSeckill(long seckillId, Jedis jedis) -> Seckill - Retrieves a Seckill object from Redis using an existing Jedis connection\n- getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) -> Seckill - Implements cache-aside pattern with distributed locking, fetching from DB if not in cache\n- putSeckill(Seckill seckill) -> String - Stores a Seckill object in Redis with default expiration\n- putSeckill(Seckill seckill, Jedis jedis) -> String - Stores a Seckill object in Redis using an existing Jedis connection\n- getSeckillRedisKey(long seckillId) -> String - Helper method to generate Redis key for a Seckill object",
    "Canonical_solution": "import cn.codingxiaxw.entity.Seckill;\nimport cn.codingxiaxw.utils.JedisUtils;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport com.dyuproject.protostuff.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\nimport java.util.UUID;\nimport java.util.function.Function;\n\npublic class RedisDao {\n    private final JedisPool jedisPool;\n    private RuntimeSchema<Seckill> schema = RuntimeSchema.createFrom(Seckill.class);\n\n    public RedisDao(String ip, int port) {\n        jedisPool = new JedisPool(ip, port);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, null);\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckillId);\n                byte[] bytes = jedis.get(key.getBytes());\n                if (bytes != null) {\n                    Seckill seckill = schema.newMessage();\n                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n                    return seckill;\n                }\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String lockKey = \"seckill:locks:getSeckill:\" + seckillId;\n        String lockRequestId = UUID.randomUUID().toString();\n        Jedis jedis = jedisPool.getResource();\n\n        try {\n            while (true) {\n                Seckill seckill = getSeckill(seckillId, jedis);\n                if (seckill != null) {\n                    return seckill;\n                }\n                boolean getLock = JedisUtils.tryGetDistributedLock(jedis, lockKey, lockRequestId, 1000);\n                if (getLock) {\n                    seckill = getDataFromDb.apply(seckillId);\n                    putSeckill(seckill, jedis);\n                    return seckill;\n                }\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException ignored) {\n                }\n            }\n        } catch (Exception ignored) {\n        } finally {\n            JedisUtils.releaseDistributedLock(jedis, lockKey, lockRequestId);\n            jedis.close();\n        }\n        return null;\n    }\n\n    public String putSeckill(Seckill seckill) {\n        return putSeckill(seckill, null);\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        boolean hasJedis = jedis != null;\n        try {\n            if (!hasJedis) {\n                jedis = jedisPool.getResource();\n            }\n            try {\n                String key = getSeckillRedisKey(seckill.getSeckillId());\n                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,\n                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));\n                int timeout = 60 * 60;\n                return jedis.setex(key.getBytes(), timeout, bytes);\n            } finally {\n                if (!hasJedis) {\n                    jedis.close();\n                }\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport com.dyuproject.protostuff.Schema;\nimport com.dyuproject.protostuff.runtime.RuntimeSchema;\nimport com.dyuproject.protostuff.io.ProtostuffIOUtil;\nimport com.dyuproject.protostuff.LinkedBuffer;\nimport java.util.function.Function;\nimport java.util.concurrent.TimeUnit;\nimport java.util.UUID;\n\npublic class RedisDao {\n    private JedisPool jedisPool;\n    private Schema<Seckill> schema;\n\n    public RedisDao(String ip, int port) {\n        this.jedisPool = new JedisPool(new JedisPoolConfig(), ip, port);\n        this.schema = RuntimeSchema.createFrom(Seckill.class);\n    }\n\n    public Seckill getSeckill(long seckillId) {\n        return getSeckill(seckillId, jedisPool.getResource());\n    }\n\n    public Seckill getSeckill(long seckillId, Jedis jedis) {\n        String key = getSeckillRedisKey(seckillId);\n        byte[] bytes = jedis.get(key);\n        if (bytes == null) {\n            return null;\n        }\n        return deserialize(bytes);\n    }\n\n    public Seckill getOrPutSeckill(long seckillId, Function<Long, Seckill> getDataFromDb) {\n        String key = getSeckillRedisKey(seckillId);\n        Jedis jedis = null;\n        try {\n            jedis = jedisPool.getResource();\n            if (jedis.exists(key)) {\n                return deserialize(jedis.get(key));\n            }\n            String lockKey = \"lock:seckill:\" + seckillId;\n            String lockValue = UUID.randomUUID().toString();\n            if (jedis.set(lockKey, lockValue, \"NX\", \"PX\", 30000)) {\n                if (jedis.exists(key)) {\n                    return deserialize(jedis.get(key));\n                }\n                Seckill seckill = getDataFromDb.apply(seckillId);\n                String serialized = serialize(seckill);\n                jedis.setex(key, 60, serialized);\n                return seckill;\n            } else {\n                Thread.sleep(100);\n                return getOrPutSeckill(seckillId, getDataFromDb);\n            }\n        } catch (Exception e) {\n            if (jedis != null) {\n                jedis.close();\n            }\n            throw new RuntimeException(e);\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String putSeckill(Seckill seckill) {\n        Jedis jedis = null;\n        try {\n            jedis = jedisPool.getResource();\n            String key = getSeckillRedisKey(seckill.getSeckillId());\n            String serialized = serialize(seckill);\n            jedis.setex(key, 60, serialized);\n            return key;\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public String putSeckill(Seckill seckill, Jedis jedis) {\n        String key = getSeckillRedisKey(seckill.getSeckillId());\n        String serialized = serialize(seckill);\n        jedis.setex(key, 60, serialized);\n        return key;\n    }\n\n    private String getSeckillRedisKey(long seckillId) {\n        return \"seckill:\" + seckillId;\n    }\n\n    private byte[] serialize(Seckill seckill) {\n        byte[] bytes = new byte[0];\n        try {\n            bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_SIZE));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return bytes;\n    }\n\n    private Seckill deserialize(byte[] bytes) {\n        Seckill seckill = new Seckill();\n        try {\n            ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return seckill;\n    }\n}"
  },
  {
    "Task_id": 325,
    "Instruction": "Task Description: Create a Java class that implements a Redis client using connection pooling to perform high-throughput operations in a multi-threaded environment.\n\nClass Description: The RedisPooledClient class provides a thread-safe interface to interact with Redis using a pooled connection. It supports basic CRUD operations and is designed to handle concurrent requests efficiently.\n\nAttributes:\n- jedisPool: JedisPooled - The pooled Redis connection instance that manages connections to the Redis server\n\nMethods:\n- RedisPooledClient(String host, int port, String password) -> void - Constructor that initializes the Redis connection pool with the specified host, port, and password\n- performOperations(int totalOperations) -> void - Executes a specified number of set/get operations across multiple threads to demonstrate concurrent Redis access\n- close() -> void - Properly closes the Redis connection pool to release resources",
    "Canonical_solution": "import redis.clients.jedis.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RedisPooledClient {\n\n    private JedisPooled jedisPool;\n\n    public RedisPooledClient(String host, int port, String password) {\n        this.jedisPool = new JedisPooled(host, port, null, password);\n    }\n\n    public void performOperations(int totalOperations) {\n        List<Thread> threads = new ArrayList<>();\n        AtomicInteger counter = new AtomicInteger();\n\n        for (int i = 0; i < 50; i++) {\n            Thread thread = new Thread(() -> {\n                for (int j = 0; (j = counter.getAndIncrement()) < totalOperations;) {\n                    try {\n                        String key = \"foo\" + j;\n                        jedisPool.set(key, key);\n                        jedisPool.get(key);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            threads.add(thread);\n            thread.start();\n        }\n\n        for (Thread t : threads) {\n            try {\n                t.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        jedisPool.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class RedisPooledClient {\n    private JedisPool jedisPool;\n\n    public RedisPooledClient(String host, int port, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxTotal(100);\n        poolConfig.setMaxIdle(50);\n        poolConfig.setMinIdle(10);\n        poolConfig.setTestOnBorrow(true);\n        this.jedisPool = new JedisPool(poolConfig, host, port, 2000, password);\n    }\n\n    public void performOperations(int totalOperations) {\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        int operationsPerThread = totalOperations / 10;\n        for (int i = 0; i < 10; i++) {\n            int threadOperations = (i < totalOperations % 10) ? operationsPerThread + 1 : operationsPerThread;\n            executor.submit(() -> {\n                for (int j = 0; j < threadOperations; j++) {\n                    String key = \"key_\" + System.currentTimeMillis() + \"_\" + j;\n                    String value = \"value_\" + j;\n                    try (Jedis jedis = jedisPool.getResource()) {\n                        jedis.set(key, value);\n                        String retrievedValue = jedis.get(key);\n                        // Optionally verify the value\n                    }\n                }\n            });\n        }\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 326,
    "Instruction": "Task Description: Create a Redis connection manager class in Java that handles connection pooling and basic Redis operations using the Jedis client library.\n\nClass Description: The RedisConnectionManager class provides a convenient way to manage Redis connections using a connection pool and execute common Redis commands. It handles connection lifecycle and resource management.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool instance that manages Redis connections\n\nMethods:\n- RedisConnectionManager(String host, int port, String username, String password) -> void - Constructor that initializes the Redis connection pool with the specified connection parameters\n- executeCommand(RedisCommand command) -> void - Executes the specified Redis command (SET, GET, or INCR) using a connection from the pool and stores the result in the command object for GET operations\n- close() -> void - Closes the connection pool and releases all resources\n- isClosed() -> boolean - Checks if the connection pool is closed",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport redis.clients.jedis.exceptions.JedisException;\n\npublic class RedisConnectionManager {\n\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, String username, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, username, password);\n    }\n\n    public void executeCommand(RedisCommand command) {\n        try (Jedis jedis = jedisPool.getResource()) {\n            switch (command.getOperation()) {\n                case \"SET\":\n                    jedis.set(command.getKey(), command.getValue());\n                    break;\n                case \"GET\":\n                    String result = jedis.get(command.getKey());\n                    command.setResult(result);\n                    break;\n                case \"INCR\":\n                    jedis.incr(command.getKey());\n                    break;\n                default:\n                    throw new JedisException(\"Unsupported operation: \" + command.getOperation());\n            }\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null && !jedisPool.isClosed()) {\n            jedisPool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return jedisPool == null || jedisPool.isClosed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, String username, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 2000, password, username);\n    }\n\n    public void executeCommand(RedisCommand command) {\n        Jedis jedis = null;\n        try {\n            jedis = jedisPool.getResource();\n            switch (command.getType()) {\n                case SET:\n                    jedis.set(command.getKey(), command.getValue());\n                    break;\n                case GET:\n                    String result = jedis.get(command.getKey());\n                    command.setResult(result);\n                    break;\n                case INCR:\n                    Long incrResult = jedis.incr(command.getKey());\n                    command.setResult(incrResult.toString());\n                    break;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    public void close() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n\n    public boolean isClosed() {\n        return jedisPool.isClosed();\n    }\n}\n\nenum RedisCommand {\n    SET, GET, INCR\n}\n\nclass RedisCommandImpl {\n    private String key;\n    private String value;\n    private String result;\n    private RedisCommand type;\n\n    public RedisCommandImpl(RedisCommand type, String key, String value) {\n        this.type = type;\n        this.key = key;\n        this.value = value;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setResult(String result) {\n        this.result = result;\n    }\n\n    public String getResult() {\n        return result;\n    }\n\n    public RedisCommand getType() {\n        return type;\n    }\n}"
  },
  {
    "Task_id": 327,
    "Instruction": "Task Description: Create a Java class that establishes a secure SSL/TLS connection to a Redis server using Lettuce client library, with support for SNI (Server Name Indication) and custom truststore configuration.\n\nClass Description: The RedisSSLConnection class provides a secure way to connect to a Redis server using SSL/TLS encryption. It handles SSL configuration including truststore setup and SNI support, and manages the Redis client lifecycle.\n\nAttributes:\n- redisClient: RedisClient - The underlying Redis client instance\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n\nMethods:\n- RedisSSLConnection(String redisUri, String hostName, String truststorePath, String truststorePassword) -> void - Constructor that initializes the Redis client with SSL configuration\n  - redisUri: String - Redis server URI (e.g., \"rediss://host:port\")\n  - hostName: String - The hostname for SNI\n  - truststorePath: String - Path to the truststore file\n  - truststorePassword: String - Password for the truststore\n- getConnection() -> StatefulRedisConnection<String, String> - Returns the established Redis connection\n- close() -> void - Closes the connection and shuts down the Redis client",
    "Canonical_solution": "import io.lettuce.core.ClientOptions;\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.SslOptions;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport javax.net.ssl.SNIHostName;\nimport javax.net.ssl.SNIServerName;\nimport javax.net.ssl.SSLParameters;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RedisSSLConnection {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisSSLConnection(String redisUri, String hostName, String truststorePath, String truststorePassword) {\n        this.redisClient = RedisClient.create(redisUri);\n\n        List<SNIServerName> serverNames = new ArrayList<>();\n        serverNames.add(new SNIHostName(hostName));\n        \n        SslOptions sslOptions = SslOptions.builder()\n                .jdkSslProvider()\n                .truststore(new File(truststorePath), truststorePassword)\n                .sslParameters(() -> {\n                    SSLParameters parameters = new SSLParameters();\n                    parameters.setServerNames(serverNames);\n                    return parameters;\n                }).build();\n\n        ClientOptions clientOptions = ClientOptions.builder()\n                .sslOptions(sslOptions)\n                .build();\n        \n        redisClient.setOptions(clientOptions);\n        this.connection = redisClient.connect();\n    }\n\n    public StatefulRedisConnection<String, String> getConnection() {\n        return this.connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.ssl.SslOptions;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\n\npublic class RedisSSLConnection {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public RedisSSLConnection(String redisUri, String hostName, String truststorePath, String truststorePassword) {\n        RedisURI redisUriObj = RedisURI.create(redisUri);\n        try {\n            KeyStore trustStore = KeyStore.getInstance(\"JKS\");\n            try (FileInputStream fis = new FileInputStream(truststorePath)) {\n                trustStore.load(fis, truststorePassword.toCharArray());\n            }\n            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            tmf.init(trustStore);\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, tmf.getTrustManagers(), null);\n            SslOptions sslOptions = SslOptions.builder()\n                    .sslContext(sslContext)\n                    .serverName(hostName)\n                    .build();\n            redisClient = RedisClient.create(redisUriObj)\n                    .ssl(sslOptions);\n            connection = redisClient.connect();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize SSL connection\", e);\n        }\n    }\n\n    public StatefulRedisConnection<String, String> getConnection() {\n        return connection;\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 341,
    "Instruction": "Task Description: Create a Java class that implements Redis client functionality using Jedis for basic key-value operations, hash operations, and key expiration management.\n\nClass Description: JedisClientSingle is a Redis client wrapper class that provides simplified access to common Redis operations using connection pooling. It handles connection management, authentication, and resource cleanup automatically.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool for Redis connections\n- password: String - The password for Redis authentication (optional)\n- port: int - The port number of the Redis server\n- host: String - The host address of the Redis server\n- logger: Logger - SLF4J logger instance for logging operations\n\nMethods:\n- getResource() -> Jedis - Internal method to get a Jedis instance from the pool and authenticate if needed\n- get(String key) -> String - Retrieves the value associated with the given key\n- set(String key, String value) -> String - Sets the value for the given key\n- hget(String hkey, String key) -> String - Gets the value of a field in a hash\n- hset(String hkey, String key, String value) -> long - Sets the value of a field in a hash\n- incr(String key) -> long - Increments the integer value of a key by 1\n- expire(String key, Integer second) -> long - Sets a timeout on a key\n- ttl(String key) -> long - Gets the remaining time to live of a key\n- del(String key) -> long - Deletes a key\n- hdel(String hkey, String key) -> long - Deletes a field from a hash",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisClientSingle {\n\n    private static final Logger logger = LoggerFactory.getLogger(JedisClientSingle.class);\n\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n\n    private Jedis getResource() {\n        if(jedisPool==null) {\n            jedisPool = new JedisPool(host, port);\n        }\n        Jedis resource = jedisPool.getResource();\n        if (StringUtils.isBlank(password)) {\n            return resource;\n        } else {\n            resource.auth(password);\n            return resource;\n        }\n    }\n\n    public String get(String key) {\n        Jedis resource = getResource();\n        String string = resource.get(key);\n        resource.close();\n        return string;\n    }\n\n    public String set(String key, String value) {\n        Jedis resource = getResource();\n        String string = resource.set(key, value);\n        resource.close();\n        return string;\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis resource = getResource();\n        String string = resource.hget(hkey, key);\n        resource.close();\n        return string;\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis resource = getResource();\n        Long hset = resource.hset(hkey, key, value);\n        resource.close();\n        return hset;\n    }\n\n    public long incr(String key) {\n        Jedis resource = getResource();\n        Long incr = resource.incr(key);\n        resource.close();\n        return incr;\n    }\n\n    public long expire(String key, Integer second) {\n        Jedis resource = getResource();\n        Long expire = resource.expire(key, second);\n        resource.close();\n        return expire;\n    }\n\n    public long ttl(String key) {\n        Jedis resource = getResource();\n        Long ttl = resource.ttl(key);\n        resource.close();\n        return ttl;\n    }\n\n    public long del(String key) {\n        Jedis resource = getResource();\n        Long del = resource.del(key);\n        resource.close();\n        return del;\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis resource = getResource();\n        Long hdel = resource.hdel(hkey, key);\n        resource.close();\n        return hdel;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class JedisClientSingle {\n    private JedisPool jedisPool;\n    private String password;\n    private int port;\n    private String host;\n    private Logger logger;\n\n    public JedisClientSingle(String host, int port, String password, Logger logger) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, 2000, password);\n        this.host = host;\n        this.port = port;\n        this.password = password;\n        this.logger = logger;\n    }\n\n    private Jedis getResource() {\n        Jedis jedis = jedisPool.getResource();\n        if (password != null && !password.isEmpty()) {\n            try {\n                jedis.auth(password);\n            } catch (Exception e) {\n                logger.error(\"Authentication failed for Redis\", e);\n                throw new RuntimeException(\"Authentication failed\", e);\n            }\n        }\n        return jedis;\n    }\n\n    public String get(String key) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.get(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String set(String key, String value) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.set(key, value);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public String hget(String hkey, String key) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.hget(hkey, key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public long hset(String hkey, String key, String value) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.hset(hkey, key, value);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public long incr(String key) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.incr(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public long expire(String key, Integer seconds) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.expire(key, seconds);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public long ttl(String key) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.ttl(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public long del(String key) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.del(key);\n        } finally {\n            jedis.close();\n        }\n    }\n\n    public long hdel(String hkey, String key) {\n        Jedis jedis = getResource();\n        try {\n            return jedis.hdel(hkey, key);\n        } finally {\n            jedis.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 344,
    "Instruction": "Task Description: Create a Java class that provides asynchronous Redis hash operations using the Lettuce client, including CRUD operations and field manipulation.\n\nClass Description: RedisHashInteraction is a utility class that encapsulates asynchronous Redis hash operations. It manages Redis connections and provides thread-safe methods for interacting with Redis hashes.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for creating connections\n- connection: StatefulRedisConnection<String, String> - The persistent connection to Redis\n- asyncCommands: RedisAsyncCommands<String, String> - The asynchronous command interface for Redis operations\n\nMethods:\n- Constructor(redisUri: String) -> void - Initializes the Redis client and establishes a connection using the provided URI\n- deleteKeys(keys: String...) -> CompletableFuture<Long> - Deletes one or more keys from Redis and returns the count of deleted keys\n- setHash(key: String, hash: Map<String, String>) -> CompletableFuture<Long> - Sets multiple hash fields at once for a given key\n- getHashField(key: String, field: String) -> CompletableFuture<String> - Retrieves the value of a specific field in a hash\n- getAllHashFields(key: String) -> CompletableFuture<Map<String, String>> - Retrieves all fields and values of a hash\n- incrementHashField(key: String, field: String, amount: long) -> CompletableFuture<Long> - Increments the integer value of a hash field by the given amount\n- closeConnection() -> void - Properly closes the Redis connection and shuts down the client",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisHashInteraction {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n    private RedisAsyncCommands<String, String> asyncCommands;\n\n    public RedisHashInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = redisClient.connect();\n        this.asyncCommands = connection.async();\n    }\n\n    public CompletableFuture<Long> deleteKeys(String... keys) {\n        return asyncCommands.del(keys).toCompletableFuture();\n    }\n\n    public CompletableFuture<Long> setHash(String key, Map<String, String> hash) {\n        return asyncCommands.hset(key, hash).toCompletableFuture();\n    }\n\n    public CompletableFuture<String> getHashField(String key, String field) {\n        return asyncCommands.hget(key, field).toCompletableFuture();\n    }\n\n    public CompletableFuture<Map<String, String>> getAllHashFields(String key) {\n        return asyncCommands.hgetall(key).toCompletableFuture();\n    }\n\n    public CompletableFuture<Long> incrementHashField(String key, String field, long amount) {\n        return asyncCommands.hincrby(key, field, amount).toCompletableFuture();\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.StatefulRedisConnection;\nimport io.lettuce.core.api.async.RedisAsyncCommands;\nimport java.util.Map;\nimport java.util.Arrays;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisHashInteraction {\n    private final RedisClient redisClient;\n    private final StatefulRedisConnection<String, String> connection;\n    private final RedisAsyncCommands<String, String> asyncCommands;\n\n    public RedisHashInteraction(String redisUri) {\n        this.redisClient = RedisClient.create(redisUri);\n        this.connection = redisClient.connect();\n        this.asyncCommands = connection.async();\n    }\n\n    public CompletableFuture<Long> deleteKeys(String... keys) {\n        return asyncCommands.del(Arrays.asList(keys));\n    }\n\n    public CompletableFuture<Long> setHash(String key, Map<String, String> hash) {\n        return asyncCommands.hset(key, hash);\n    }\n\n    public CompletableFuture<String> getHashField(String key, String field) {\n        return asyncCommands.hget(key, field);\n    }\n\n    public CompletableFuture<Map<String, String>> getAllHashFields(String key) {\n        return asyncCommands.hgetall(key);\n    }\n\n    public CompletableFuture<Long> incrementHashField(String key, String field, long amount) {\n        return asyncCommands.hincrby(key, field, amount);\n    }\n\n    public void closeConnection() {\n        connection.close();\n        redisClient.shutdown();\n    }\n}"
  },
  {
    "Task_id": 346,
    "Instruction": "Task Description: Create a Java class for managing Redis cluster connections and operations using Jedis and UnifiedJedis clients.\n\nClass Description: The RedisClusterManager class provides functionality to interact with a Redis cluster, including connection management, bucket creation/initialization, and performing Redis operations. It supports both JedisCluster and UnifiedJedis interfaces for cluster operations.\n\nAttributes:\n- jedisCluster: JedisCluster - The Jedis cluster client instance for Redis operations\n- unifiedJedisCluster: UnifiedJedis - The UnifiedJedis interface for Redis cluster operations (wraps jedisCluster)\n\nMethods:\n- RedisClusterManager(List<HostAndPort> shards) -> void - Constructor that initializes the Redis cluster connection using provided shards\n- createBucket(String key) -> byte[] - Converts a string key to UTF-8 bytes for Redis operations\n- initializeBucket(byte[] key) -> void - Placeholder for bucket initialization logic using the cluster client\n- performRedisOperations(byte[] key) -> void - Placeholder for performing CRUD operations on the cluster\n- closeConnections() -> void - Properly closes all Redis cluster connections\n- createShards(String host, List<Integer> ports) -> List<HostAndPort> - Static helper method to create shard configurations from host and ports",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.UUID;\n\nimport redis.clients.jedis.HostAndPort;\nimport redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.UnifiedJedis;\n\npublic class RedisClusterManager {\n\n    private JedisCluster jedisCluster;\n    private UnifiedJedis unifiedJedisCluster;\n\n    public RedisClusterManager(List<HostAndPort> shards) {\n        this.jedisCluster = new JedisCluster(new HashSet<>(shards));\n        this.unifiedJedisCluster = this.jedisCluster;\n    }\n\n    public byte[] createBucket(String key) {\n        byte[] byteKey = key.getBytes(StandardCharsets.UTF_8);\n        return byteKey;\n    }\n\n    public void initializeBucket(byte[] key) {\n        // Initialize bucket logic using jedisCluster\n    }\n\n    public void performRedisOperations(byte[] key) {\n        // Perform CRUD operations using jedisCluster\n    }\n\n    public void closeConnections() {\n        try {\n            if (jedisCluster != null) {\n                jedisCluster.close();\n            }\n            if (unifiedJedisCluster != null) {\n                unifiedJedisCluster.close();\n            }\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    public static List<HostAndPort> createShards(String host, List<Integer> ports) {\n        List<HostAndPort> shards = new ArrayList<>();\n        for (Integer port : ports) {\n            shards.add(new HostAndPort(host, port));\n        }\n        return shards;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.HostAndPort;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RedisClusterManager {\n    private JedisCluster jedisCluster;\n    private UnifiedJedis unifiedJedisCluster;\n\n    public RedisClusterManager(List<HostAndPort> shards) {\n        this.jedisCluster = new JedisCluster(shards);\n        this.unifiedJedisCluster = new UnifiedJedis(jedisCluster);\n    }\n\n    public byte[] createBucket(String key) {\n        return key.getBytes(StandardCharsets.UTF_8);\n    }\n\n    public void initializeBucket(byte[] key) {\n        // Placeholder for bucket initialization logic\n    }\n\n    public void performRedisOperations(byte[] key) {\n        // Placeholder for performing Redis operations\n    }\n\n    public void closeConnections() {\n        if (jedisCluster != null) {\n            jedisCluster.close();\n        }\n    }\n\n    public static List<HostAndPort> createShards(String host, List<Integer> ports) {\n        List<HostAndPort> shards = new ArrayList<>();\n        for (int port : ports) {\n            shards.add(new HostAndPort(host, port));\n        }\n        return shards;\n    }\n}"
  },
  {
    "Task_id": 348,
    "Instruction": "Task Description: Create a Redis connection manager class in Java that handles connection pooling, resource management, and basic Redis operations.\n\nClass Description: RedisConnectionManager is a utility class that manages Redis connections using Jedis connection pooling. It provides methods to get connections, execute commands, and properly close connections to ensure resource efficiency.\n\nAttributes:\n- jedisPool: JedisPool - The connection pool instance that manages Redis connections\n\nMethods:\n- RedisConnectionManager(String host, int port, int timeout, String password) -> void - Constructor that initializes the connection pool with specified parameters\n- getConnection() -> Jedis - Retrieves a Redis connection from the pool\n- closeConnection(Jedis jedis) -> void - Returns a connection to the pool\n- closePool() -> void - Closes the entire connection pool\n- executeCommand(String key, String value) -> void - Executes a basic Redis SET/GET operation and prints the result",
    "Canonical_solution": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, int timeout, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, timeout, password);\n    }\n\n    public Jedis getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Jedis jedis) {\n        if (jedis != null) {\n            jedis.close();\n        }\n    }\n\n    public void closePool() {\n        if (jedisPool != null && !jedisPool.isClosed()) {\n            jedisPool.close();\n        }\n    }\n\n    public void executeCommand(String key, String value) {\n        try (Jedis jedis = getConnection()) {\n            jedis.set(key, value);\n            String result = jedis.get(key);\n            System.out.println(\"Redis operation result: \" + result);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\nimport redis.clients.jedis.JedisPoolConfig;\n\npublic class RedisConnectionManager {\n    private JedisPool jedisPool;\n\n    public RedisConnectionManager(String host, int port, int timeout, String password) {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        this.jedisPool = new JedisPool(poolConfig, host, port, timeout, password);\n    }\n\n    public Jedis getConnection() {\n        return jedisPool.getResource();\n    }\n\n    public void closeConnection(Jedis jedis) {\n        if (jedis != null) {\n            jedisPool.returnResource(jedis);\n        }\n    }\n\n    public void closePool() {\n        if (jedisPool != null) {\n            jedisPool.close();\n        }\n    }\n\n    public void executeCommand(String key, String value) {\n        Jedis jedis = null;\n        try {\n            jedis = getConnection();\n            String result = jedis.set(key, value);\n            System.out.println(\"SET result: \" + result);\n        } finally {\n            if (jedis != null) {\n                closeConnection(jedis);\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 35,
    "Instruction": "Task Description: Create a Java class that implements a writable tile archive using Java NIO's FileChannel for efficient file operations, supporting both file-based and in-memory storage options.\n\nClass Description: WriteablePmtiles is a class that provides functionality to write and manage tile archive data using Java NIO channels. It supports writing to either a physical file or an in-memory buffer, tracks bytes written, and handles proper resource cleanup.\n\nAttributes:\n- out: [SeekableByteChannel] - The channel used for writing data (either FileChannel or in-memory channel)\n- bytesWritten: [LongSupplier] - A supplier that provides the number of bytes written to the channel\n\nMethods:\n- newWriteToFile(Path path) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to a physical file at the specified path\n- newWriteToMemory(SeekableInMemoryByteChannel bytes) -> [WriteablePmtiles] - Static factory method that creates a new instance writing to an in-memory byte channel\n- finish(TileArchiveMetadata tileArchiveMetadata) -> [void] - Finalizes the archive by writing metadata and directory information\n- bytesWritten() -> [long] - Returns the number of bytes written to the archive\n- close() -> [void] - Closes the underlying channel and releases system resources\n- DeduplicatingTileWriter.write(TileEncodingResult encodingResult) -> [void] - Inner class method that writes tile data to the channel\n- DeduplicatingTileWriter.close() -> [void] - Inner class method that performs any necessary cleanup (none in this implementation)",
    "Canonical_solution": "import com.onthegomap.planetiler.util.FileUtils;\nimport com.onthegomap.planetiler.util.SeekableInMemoryByteChannel;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic final class WriteablePmtiles implements WriteableTileArchive {\n\n  private final SeekableByteChannel out;\n  private final LongSupplier bytesWritten;\n\n  private WriteablePmtiles(SeekableByteChannel channel, LongSupplier bytesWritten) throws IOException {\n    this.out = channel;\n    out.write(ByteBuffer.allocate(INIT_SECTION));\n    this.bytesWritten = bytesWritten;\n  }\n\n  public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n    return new WriteablePmtiles(\n      FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE),\n      () -> FileUtils.size(path)\n    );\n  }\n\n  public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) throws IOException {\n    return new WriteablePmtiles(bytes, () -> 0);\n  }\n\n  @Override\n  public void finish(TileArchiveMetadata tileArchiveMetadata) {\n    try {\n      out.write(ByteBuffer.wrap(jsonBytes));\n      out.write(ByteBuffer.wrap(directories.leaves));\n      out.position(0);\n      out.write(ByteBuffer.wrap(header.toBytes()));\n      out.write(ByteBuffer.wrap(directories.root));\n    } catch (IOException e) {\n      LOGGER.error(e.getMessage());\n    }\n  }\n\n  @Override\n  public long bytesWritten() {\n    return bytesWritten.getAsLong();\n  }\n\n  @Override\n  public void close() throws IOException {\n    out.close();\n  }\n\n  private class DeduplicatingTileWriter implements TileWriter {\n    @Override\n    public void write(TileEncodingResult encodingResult) {\n      try {\n        out.write(ByteBuffer.wrap(data));\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      currentOffset += data.length;\n    }\n\n    @Override\n    public void close() {\n      // no cleanup needed.\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 9,
    "right_result": "import java.io.IOException;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.function.LongSupplier;\n\npublic class WriteablePmtiles {\n    private final SeekableByteChannel out;\n    private long bytesWritten;\n    private final LongSupplier bytesWrittenSupplier;\n\n    public WriteablePmtiles(SeekableByteChannel out) {\n        this.out = out;\n        this.bytesWritten = 0;\n        this.bytesWrittenSupplier = () -> bytesWritten;\n    }\n\n    public static WriteablePmtiles newWriteToFile(Path path) throws IOException {\n        return new WriteablePmtiles(FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.DELETE_ON_CLOSE));\n    }\n\n    public static WriteablePmtiles newWriteToMemory(SeekableInMemoryByteChannel bytes) {\n        return new WriteablePmtiles(bytes);\n    }\n\n    public void finish(TileArchiveMetadata tileArchiveMetadata) throws IOException {\n        // Implement finalization logic for metadata and directory structure\n    }\n\n    public LongSupplier bytesWritten() {\n        return bytesWrittenSupplier;\n    }\n\n    public void close() throws IOException {\n        if (out != null) {\n            out.close();\n        }\n    }\n\n    public class DeduplicatingTileWriter {\n        public void write(TileEncodingResult encodingResult) throws IOException {\n            byte[] data = encodingResult.getData();\n            int length = data.length;\n            out.write(ByteBuffer.wrap(data));\n            bytesWritten += length;\n        }\n\n        public void close() {\n            // No-op cleanup required\n        }\n    }\n}"
  },
  {
    "Task_id": 353,
    "Instruction": "Task Description: Create a Java class that manages Redis connections using the Lettuce client, supporting batch operations with asynchronous command execution.\n\nClass Description: The RedisConnectionManager class provides a way to establish, manage, and close Redis connections using Lettuce client. It supports binary data operations through ByteArrayCodec and maintains a batch of asynchronous commands for execution.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance for connection management\n- connection: StatefulRedisConnection<byte[], byte[]> - The active Redis connection using byte arrays as key/value format\n- BATCH_SIZE: int (static final) - Constant defining the maximum number of commands in a batch\n- commands: CompletableFuture[] - Array to store asynchronous command futures for batch operations\n\nMethods:\n- setupConnection(): void - Initializes the Redis client and establishes a connection using test settings (host and port from TestSettings)\n- getConnection(): StatefulRedisConnection<byte[], byte[]> - Returns the active Redis connection\n- closeConnection(): void - Properly closes the Redis connection and shuts down the client\n- getCommandFutures(): CompletableFuture[] - Returns the array of command futures for batch operations\n- getBatchSize(): int - Returns the constant batch size value",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport io.lettuce.test.settings.TestSettings;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisConnectionManager {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n    private static final int BATCH_SIZE = 20;\n    private CompletableFuture[] commands;\n\n    public void setupConnection() {\n        redisClient = RedisClient.create(RedisURI.create(TestSettings.host(), TestSettings.port()));\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE);\n        commands = new CompletableFuture[BATCH_SIZE];\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public CompletableFuture[] getCommandFutures() {\n        return commands;\n    }\n\n    public int getBatchSize() {\n        return BATCH_SIZE;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.codec.ByteArrayCodec;\nimport java.util.concurrent.CompletableFuture;\n\npublic class RedisConnectionManager {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<byte[], byte[]> connection;\n    private static final int BATCH_SIZE = 100;\n    private CompletableFuture[] commands;\n\n    public void setupConnection() {\n        redisClient = RedisClient.create(\"redis://\" + TestSettings.HOST + \":\" + TestSettings.PORT);\n        connection = redisClient.connect(ByteArrayCodec.INSTANCE, ByteArrayCodec.INSTANCE);\n        commands = new CompletableFuture[BATCH_SIZE];\n    }\n\n    public StatefulRedisConnection<byte[], byte[]> getConnection() {\n        return connection;\n    }\n\n    public void closeConnection() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public CompletableFuture[] getCommandFutures() {\n        return commands;\n    }\n\n    public int getBatchSize() {\n        return BATCH_SIZE;\n    }\n}"
  },
  {
    "Task_id": 355,
    "Instruction": "Task Description: Create a Java class that provides functionality to connect to Redis using Unix domain sockets, perform basic Redis operations, and manage connection lifecycle.\n\nClass Description: The RedisSocketConnector class enables interaction with Redis server through Unix domain sockets. It handles connection establishment, basic key-value operations, and proper resource cleanup. The class also includes utility methods for Redis URI creation and socket support detection.\n\nAttributes:\n- redisClient: RedisClient - The main Redis client instance used for connections\n- connection: StatefulRedisConnection<String, String> - The active Redis connection\n\nMethods:\n- connect(RedisURI redisURI) -> void - Establishes a connection to Redis using the provided URI\n- performRedisAction(String key, String value) -> void - Performs a set and get operation on the specified key-value pair\n- close() -> void - Closes the Redis connection and shuts down the client\n- createSocketRedisUri(String socketPath) -> RedisURI - Creates a Redis URI for socket connection from the given path\n- isSupported() -> boolean - Checks if domain sockets are supported on the current system",
    "Canonical_solution": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.api.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\nimport io.lettuce.core.resource.Transports;\nimport io.lettuce.test.resource.TestClientResources;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Locale;\n\npublic class RedisSocketConnector {\n\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void connect(RedisURI redisURI) {\n        redisClient = RedisClient.create(TestClientResources.get(), redisURI);\n        connection = redisClient.connect();\n    }\n\n    public void performRedisAction(String key, String value) {\n        RedisCommands<String, String> syncCommands = connection.sync();\n        syncCommands.set(key, value);\n        String result = syncCommands.get(key);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public static RedisURI createSocketRedisUri(String socketPath) throws IOException {\n        File file = new File(socketPath).getCanonicalFile();\n        return RedisURI.create(RedisURI.URI_SCHEME_REDIS_SOCKET + \"://\" + file.getCanonicalPath());\n    }\n\n    public static boolean isSupported() {\n        String osName = SystemPropertyUtil.get(\"os.name\").toLowerCase(Locale.UK).trim();\n        return Transports.NativeTransports.isDomainSocketSupported();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 37,
    "right_result": "import io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.StatefulRedisConnection;\nimport io.lettuce.core.api.sync.RedisCommands;\n\npublic class RedisSocketConnector {\n    private RedisClient redisClient;\n    private StatefulRedisConnection<String, String> connection;\n\n    public void connect(RedisURI redisURI) {\n        redisClient = RedisClient.create(redisURI);\n        connection = redisClient.connect(redisURI);\n    }\n\n    public void performRedisAction(String key, String value) {\n        RedisCommands<String, String> sync = connection.sync();\n        sync.set(key, value);\n        sync.get(key);\n    }\n\n    public void close() {\n        if (connection != null) {\n            connection.close();\n        }\n        if (redisClient != null) {\n            redisClient.shutdown();\n        }\n    }\n\n    public RedisURI createSocketRedisUri(String socketPath) {\n        return RedisURI.create(\"unix://\" + socketPath);\n    }\n\n    public boolean isSupported() {\n        String osName = System.getProperty(\"os.name\").toLowerCase();\n        return !osName.contains(\"win\");\n    }\n}"
  },
  {
    "Task_id": 359,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The SimpleConsumer class provides a basic implementation of a RocketMQ push consumer. It handles the setup, subscription, message listening, and lifecycle management of a consumer instance. The class allows for easy configuration of consumer group, NameServer address, topic subscription, and message processing logic.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- SimpleConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a message listener to handle incoming messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n- createDefaultListener() -> MessageListenerConcurrently - Static factory method that creates a default message listener which prints received messages",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport java.util.List;\n\npublic class SimpleConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public SimpleConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static MessageListenerConcurrently createDefaultListener() {\n        return new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(msg.getKeys() + \":\" + new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        };\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.ConsumeConcurrentlyStatus;\nimport java.util.List;\n\npublic class SimpleConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public SimpleConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.setMessageListener(listener);\n    }\n\n    public void start() {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static MessageListenerConcurrently createDefaultListener() {\n        return new MessageListenerConcurrently() {\n            @Override\n            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n                for (MessageExt msg : msgs) {\n                    System.out.println(\"Received message: \" + new String(msg.getBody()));\n                }\n                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 360,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ message consumer using the push model. The class should handle message consumption from a specified topic, with configurable NameServer address and consumer group settings.\n\nClass Description: The Consumer class is a RocketMQ message consumer implementation that subscribes to a topic and processes incoming messages asynchronously. It uses DefaultMQPushConsumer for push-based consumption and provides methods to start, shutdown, and configure the consumer.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address if none is provided\n- TOPIC: [String] - The topic to subscribe to for messages\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- Consumer() - [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers a message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer gracefully\n- setNamesrvAddr(String namesrvAddr) -> [void] - Sets the NameServer address for the consumer",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\n\npublic class Consumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_4\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(TOPIC, \"*\");\n        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msg);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.MQClientException;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.ConsumeConcurrentlyStatus;\n\npublic class Consumer {\n    private String CONSUMER_GROUP;\n    private String DEFAULT_NAMESRVADDR;\n    private String TOPIC;\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer() {\n        this.CONSUMER_GROUP = \"DEFAULT_CONSUMER_GROUP\";\n        this.DEFAULT_NAMESRVADDR = \"localhost:9876\";\n        this.TOPIC = \"TEST_TOPIC\";\n        this.consumer = new DefaultMQPushConsumer(this.CONSUMER_GROUP);\n        this.consumer.setNamesrvAddr(this.DEFAULT_NAMESRVADDR);\n        this.consumer.subscribe(this.TOPIC, \"*\");\n        this.consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (Message msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() {\n        try {\n            this.consumer.start();\n        } catch (MQClientException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        this.consumer.shutdown();\n    }\n\n    public void setNamesrvAddr(String namesrvAddr) {\n        this.consumer.setNamesrvAddr(namesrvAddr);\n    }\n}"
  },
  {
    "Task_id": 365,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to asynchronously receive and process messages from a specified topic.\n\nClass Description: The PushConsumer class provides a wrapper around RocketMQ's DefaultMQPushConsumer to simplify message consumption. It handles consumer initialization, topic subscription, message listening, and lifecycle management.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The underlying RocketMQ push consumer instance\n\nMethods:\n- PushConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) -> void - Sets the consumption starting point (e.g., from last offset or earliest)\n- setConsumeTimestamp(String consumeTimestamp) -> void - Sets the timestamp for consumption starting point\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a callback for processing received messages\n- start() -> void - Starts the consumer to begin message consumption\n- shutdown() -> void - Shuts down the consumer gracefully\n\nNested Class:\n- SimpleMessageListener: MessageListenerConcurrently - A basic message listener implementation that prints received messages and returns success status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {\n        consumer.setConsumeFromWhere(consumeFromWhere);\n    }\n\n    public void setConsumeTimestamp(String consumeTimestamp) {\n        consumer.setConsumeTimestamp(consumeTimestamp);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.consume.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.consume.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.common.consume.ConsumeConcurrentlyStatus;\n\npublic class PushConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void setConsumeFromWhere(ConsumeFromWhere consumeFromWhere) {\n        consumer.setConsumeFromWhere(consumeFromWhere);\n    }\n\n    public void setConsumeTimestamp(String consumeTimestamp) {\n        consumer.setConsumeTimestamp(consumeTimestamp);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(java.util.List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 369,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The PushConsumer class is a RocketMQ message consumer that uses push mode to receive messages from a message queue. It handles message subscription, listener registration, and consumer lifecycle management.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- PushConsumer(String consumerGroup, String namesrvAddr) -> void - Constructor that initializes the consumer with a consumer group and NameServer address\n- subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering\n- registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a message listener to handle incoming messages\n- start() -> void - Starts the consumer to begin receiving messages\n- shutdown() -> void - Shuts down the consumer gracefully\n\nNested Class:\n- SimpleMessageListener: MessageListenerConcurrently - A basic message listener implementation that prints received messages\n  Methods:\n  - consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) -> ConsumeConcurrentlyStatus - Processes received messages and returns consumption status",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.MessageModel;\n\nimport java.util.List;\n\npublic class PushConsumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                      ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.consume.ConsumeConcurrentlyStatus;\nimport java.util.List;\nimport org.apache.rocketmq.common.consume.ConsumeConcurrentlyContext;\n\npublic class PushConsumer {\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.setMessageListener(listener);\n    }\n\n    public void start() {\n        consumer.start();\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 370,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic, process them using an orderly message listener, and manage the consumer lifecycle.\n\nClass Description: The Consumer class encapsulates the functionality of a RocketMQ push consumer that subscribes to a topic, processes messages in order, and provides methods to start and stop the consumer.\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance\n- consumerGroup: String - The consumer group name for this consumer\n- topic: String - The topic to subscribe to\n- subExpression: String - The tag expression for message filtering\n\nMethods:\n- Consumer(String, String, String) -> None - Constructor that initializes the consumer group, topic, and subscription expression\n- initialize() -> None - Initializes the consumer instance with basic configuration and subscription\n- start() -> None - Registers the message listener and starts the consumer\n- shutdown() -> None - Gracefully shuts down the consumer",
    "Canonical_solution": "import java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void start() throws MQClientException {\n        consumer.registerMessageListener(new MessageListenerOrderly() {\n            AtomicLong consumeTimes = new AtomicLong(0);\n\n            @Override\n            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n                context.setAutoCommit(true);\n                System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n                this.consumeTimes.incrementAndGet();\n                if ((this.consumeTimes.get() % 2) == 0) {\n                    return ConsumeOrderlyStatus.SUCCESS;\n                } else if ((this.consumeTimes.get() % 5) == 0) {\n                    context.setSuspendCurrentQueueTimeMillis(3000);\n                    return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;\n                }\n                return ConsumeOrderlyStatus.SUCCESS;\n            }\n        });\n        consumer.start();\n        System.out.printf(\"Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerOrderly;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.heartbeat.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.common.protocol.heartbeat.ConsumeConcurrentlyStatus;\n\npublic class Consumer {\n    private DefaultMQPushConsumer consumer;\n    private String consumerGroup;\n    private String topic;\n    private String subExpression;\n\n    public Consumer(String consumerGroup, String topic, String subExpression) {\n        this.consumerGroup = consumerGroup;\n        this.topic = topic;\n        this.subExpression = subExpression;\n    }\n\n    public void initialize() {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(\"localhost:9876\");\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void start() {\n        consumer.registerMessageListener((MessageListenerOrderly) (msgs, context) -> {\n            for (MessageExt msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n        consumer.start();\n    }\n\n    public void shutdown() {\n        if (consumer != null) {\n            consumer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 376,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ push consumer to asynchronously receive and process messages from a specified topic with tag filtering.\n\nClass Description: The PushConsumer class is a RocketMQ message consumer that subscribes to a topic and processes incoming messages using a concurrent message listener. It supports broadcasting message model and can be configured with various consumption strategies.\n\nAttributes:\n- CONSUMER_GROUP: [String] - The consumer group name for this consumer instance\n- DEFAULT_NAMESRVADDR: [String] - Default NameServer address for RocketMQ\n- TOPIC: [String] - The topic to subscribe to for messages\n- SUB_EXPRESSION: [String] - Tag filter expression for message subscription\n- consumer: [DefaultMQPushConsumer] - The RocketMQ push consumer instance\n\nMethods:\n- PushConsumer() [Constructor] -> [void] - Initializes the consumer with default settings, subscribes to the topic, and registers the message listener\n- start() -> [void] - Starts the consumer to begin receiving messages\n- shutdown() -> [void] - Shuts down the consumer and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class PushConsumer {\n\n    public static final String CONSUMER_GROUP = \"please_rename_unique_group_name_1\";\n    public static final String DEFAULT_NAMESRVADDR = \"127.0.0.1:9876\";\n    public static final String TOPIC = \"TopicTest\";\n    public static final String SUB_EXPRESSION = \"TagA || TagC || TagD\";\n\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer() throws MQClientException {\n        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n        consumer.setMessageModel(MessageModel.BROADCASTING);\n        consumer.subscribe(TOPIC, SUB_EXPRESSION);\n        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            System.out.printf(\"%s Receive New Messages: %s %n\", Thread.currentThread().getName(), msgs);\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.printf(\"Broadcast Consumer Started.%n\");\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageModel;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.common.protocol.heartbeat.ConsumeConcurrentlyStatus;\n\npublic class PushConsumer {\n    private String CONSUMER_GROUP;\n    private String DEFAULT_NAMESRVADDR;\n    private String TOPIC;\n    private String SUB_EXPRESSION;\n    private DefaultMQPushConsumer consumer;\n\n    public PushConsumer() {\n        this.CONSUMER_GROUP = \"default_group\";\n        this.DEFAULT_NAMESRVADDR = \"localhost:9876\";\n        this.TOPIC = \"example_topic\";\n        this.SUB_EXPRESSION = \"*\";\n        this.consumer = new DefaultMQPushConsumer(this.CONSUMER_GROUP);\n        this.consumer.setNamesrvAddr(this.DEFAULT_NAMESRVADDR);\n        this.consumer.setMessageModel(MessageModel.BROADCASTING);\n        this.consumer.subscribe(this.TOPIC, this.SUB_EXPRESSION);\n        this.consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {\n            for (Message msg : msgs) {\n                System.out.println(\"Received message: \" + new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        });\n    }\n\n    public void start() {\n        this.consumer.start();\n    }\n\n    public void shutdown() {\n        this.consumer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 378,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and handle them asynchronously.\n\nClass Description: The RocketMQConsumer class is a message consumer implementation that uses RocketMQ's push-based consumption model. It subscribes to a specified topic, configures consumption settings, and processes incoming messages through a registered message listener.\n\nAttributes:\n- log: Logger - SLF4J logger instance for logging consumer activities\n- defaultMQPushConsumer: DefaultMQPushConsumer - The core RocketMQ push consumer instance\n- rpcHook: RPCHook - Optional RPC hook for custom communication handling\n- topicName: String - The topic name to subscribe to\n- consumerGroup: String - The consumer group name for this consumer\n\nMethods:\n- RocketMQConsumer(RPCHook, String, String) -> void - Constructor that initializes the consumer with RPC hook, topic name, and consumer group\n- startConsumer() -> void - Configures and starts the consumer instance, subscribes to the topic, and registers the message listener\n- shutdown() -> void - Gracefully shuts down the consumer instance\n- buildSendMessageRequestHeader(Message, String, int) -> SendMessageRequestHeader - Helper method to build message request headers for sending messages\n- (implements) consumeMessage(List<MessageExt>, ConsumeConcurrentlyContext) -> ConsumeConcurrentlyStatus - Message listener implementation that processes consumed messages (inherited from MessageListenerConcurrently interface)",
    "Canonical_solution": "import com.alibaba.fastjson.JSON;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageDecoder;\nimport org.apache.rocketmq.common.topic.TopicValidator;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.proxy.common.ProxyContext;\nimport org.apache.rocketmq.proxy.common.ProxyException;\nimport org.apache.rocketmq.proxy.common.ProxyExceptionCode;\nimport org.apache.rocketmq.remoting.RPCHook;\nimport org.apache.rocketmq.remoting.protocol.header.SendMessageRequestHeader;\nimport org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(LoggerName.PROXY_LOGGER_NAME);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n    }\n\n    public void startConsumer() throws Exception {\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(this.consumerGroup, this.rpcHook);\n        this.defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);\n        this.defaultMQPushConsumer.setMessageModel(MessageModel.BROADCASTING);\n        \n        try {\n            this.defaultMQPushConsumer.subscribe(this.topicName, \"*\");\n        } catch (MQClientException e) {\n            throw new ProxyException(ProxyExceptionCode.INTERNAL_SERVER_ERROR, \n                \"subscribe to topic \" + this.topicName + \" failed. \" + e.getMessage());\n        }\n        \n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() throws Exception {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    protected SendMessageRequestHeader buildSendMessageRequestHeader(Message message,\n        String producerGroup, int queueId) {\n        SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n        requestHeader.setProducerGroup(producerGroup);\n        requestHeader.setTopic(message.getTopic());\n        requestHeader.setDefaultTopic(TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC);\n        requestHeader.setDefaultTopicQueueNums(0);\n        requestHeader.setQueueId(queueId);\n        requestHeader.setSysFlag(0);\n        requestHeader.setBornTimestamp(System.currentTimeMillis());\n        requestHeader.setFlag(message.getFlag());\n        requestHeader.setProperties(MessageDecoder.messageProperties2String(message.getProperties()));\n        requestHeader.setReconsumeTimes(0);\n        requestHeader.setBatch(false);\n        return requestHeader;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.RPCHook;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.message.SendMessageRequestHeader;\nimport org.apache.rocketmq.common.consume.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.common.consume.ConsumeConcurrentlyStatus;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.List;\n\npublic class RocketMQConsumer implements MessageListenerConcurrently {\n    private static final Logger log = LoggerFactory.getLogger(RocketMQConsumer.class);\n    private DefaultMQPushConsumer defaultMQPushConsumer;\n    private RPCHook rpcHook;\n    private String topicName;\n    private String consumerGroup;\n\n    public RocketMQConsumer(RPCHook rpcHook, String topicName, String consumerGroup) {\n        this.rpcHook = rpcHook;\n        this.topicName = topicName;\n        this.consumerGroup = consumerGroup;\n        this.defaultMQPushConsumer = new DefaultMQPushConsumer(consumerGroup);\n        if (rpcHook != null) {\n            this.defaultMQPushConsumer.setRPCHook(rpcHook);\n        }\n    }\n\n    public void startConsumer() {\n        this.defaultMQPushConsumer.setNamesrvAddr(\"localhost:9876\");\n        this.defaultMQPushConsumer.subscribe(topicName, \"*\");\n        this.defaultMQPushConsumer.registerMessageListener(this);\n        this.defaultMQPushConsumer.start();\n    }\n\n    public void shutdown() {\n        if (this.defaultMQPushConsumer != null) {\n            this.defaultMQPushConsumer.shutdown();\n        }\n    }\n\n    private SendMessageRequestHeader buildSendMessageRequestHeader(Message message, String topic, int timeout) {\n        return new SendMessageRequestHeaderBuilder()\n                .setTopic(topic)\n                .setKeys(message.getKeys())\n                .setTags(message.getTags())\n                .setDelayTimeLevel(timeout)\n                .build();\n    }\n\n    @Override\n    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {\n        for (MessageExt msg : msgs) {\n            log.info(\"Received message: {}\", new String(msg.getBody()));\n        }\n        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n    }\n}"
  },
  {
    "Task_id": 379,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ consumer to subscribe to messages from a specified topic and process them asynchronously.\n\nClass Description: The Consumer class is a RocketMQ message consumer that uses push-based consumption model. It allows subscribing to topics, registering message listeners, and managing the consumer lifecycle (startup and shutdown).\n\nAttributes:\n- consumer: DefaultMQPushConsumer - The RocketMQ push consumer instance that handles message consumption\n\nMethods:\n- Constructor: Consumer(String consumerGroup, String namesrvAddr) -> void - Initializes the consumer with a consumer group name and NameServer address. Sets the consumption offset strategy to start from the first offset.\n- subscribe: subscribe(String topic, String subExpression) -> void - Subscribes to a specific topic with optional tag filtering using a subscription expression.\n- registerMessageListener: registerMessageListener(MessageListenerConcurrently listener) -> void - Registers a concurrent message listener to handle incoming messages.\n- start: start() -> void - Starts the consumer to begin message consumption.\n- shutdown: shutdown() -> void - Shuts down the consumer gracefully.\n\nNested Class:\n- SimpleMessageListener: Implements MessageListenerConcurrently interface to provide basic message handling functionality. Prints received messages and returns CONSUME_SUCCESS status.",
    "Canonical_solution": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;\nimport org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.common.consumer.ConsumeFromWhere;\nimport org.apache.rocketmq.common.message.MessageExt;\n\nimport java.util.List;\n\npublic class Consumer {\n\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer(String consumerGroup, String namesrvAddr) throws MQClientException {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) throws MQClientException {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() throws MQClientException {\n        consumer.start();\n        System.out.println(String.format(\"Consumer %s Started.\", consumer.getConsumerGroup()));\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,\n                                                       ConsumeConcurrentlyContext context) {\n            System.out.printf(Thread.currentThread().getName() + \" Receive New Messages: \" + msgs + \"%n\");\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 43,
    "right_result": "import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;\nimport org.apache.rocketmq.client.consumer.MessageListenerConcurrently;\nimport org.apache.rocketmq.client.consumer.OffsetStrategy;\nimport org.apache.rocketmq.common.message.MessageExt;\nimport org.apache.rocketmq.common.protocol.consumption.ConsumeConcurrentlyStatus;\nimport org.apache.rocketmq.common.context.Context;\n\npublic class Consumer {\n    private DefaultMQPushConsumer consumer;\n\n    public Consumer(String consumerGroup, String namesrvAddr) {\n        consumer = new DefaultMQPushConsumer(consumerGroup);\n        consumer.setNamesrvAddr(namesrvAddr);\n        consumer.setConsumeFromWhere(OffsetStrategy.CONSUME_FROM_FIRST_OFFSET);\n    }\n\n    public void subscribe(String topic, String subExpression) {\n        consumer.subscribe(topic, subExpression);\n    }\n\n    public void registerMessageListener(MessageListenerConcurrently listener) {\n        consumer.registerMessageListener(listener);\n    }\n\n    public void start() {\n        try {\n            consumer.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        consumer.shutdown();\n    }\n\n    public static class SimpleMessageListener implements MessageListenerConcurrently {\n        @Override\n        public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, Context context) {\n            for (MessageExt msg : msgs) {\n                System.out.println(new String(msg.getBody()));\n            }\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        }\n    }\n}"
  },
  {
    "Task_id": 381,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic using Apache RocketMQ client library.\n\nClass Description: The RocketMQProducer class encapsulates the functionality to create, configure, and manage a RocketMQ message producer. It handles producer initialization, message creation, message sending, and producer shutdown.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The address of the NameServer for service discovery\n- producerGroup: String - The group name of the producer\n- topic: String - The target topic for message sending\n- messageSize: int - The size of the message to be sent\n\nMethods:\n- RocketMQProducer(String, String, String, int) - Constructor - Initializes the producer with NameServer address, producer group, topic, and message size\n- start() -> void - Configures and starts the producer instance\n- sendMessage() -> SendResult - Creates and sends a message to the configured topic\n- shutdown() -> void - Shuts down the producer instance",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport java.nio.charset.StandardCharsets;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private String producerGroup;\n    private String topic;\n    private int messageSize;\n\n    public RocketMQProducer(String namesrvAddr, String producerGroup, String topic, int messageSize) {\n        this.namesrvAddr = namesrvAddr;\n        this.producerGroup = producerGroup;\n        this.topic = topic;\n        this.messageSize = messageSize;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void start() throws MQClientException {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setVipChannelEnabled(false);\n        producer.start();\n    }\n\n    public SendResult sendMessage() throws Exception {\n        StringBuilder sb = new StringBuilder();\n        for (int j = 0; j < messageSize; j += 10) {\n            sb.append(\"hello baby\");\n        }\n        byte[] body = sb.toString().getBytes(StandardCharsets.UTF_8);\n        Message message = new Message(topic, body);\n        return producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.exception.MQClientException;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private String producerGroup;\n    private String topic;\n    private int messageSize;\n\n    public RocketMQProducer(String namesrvAddr, String producerGroup, String topic, int messageSize) {\n        this.namesrvAddr = namesrvAddr;\n        this.producerGroup = producerGroup;\n        this.topic = topic;\n        this.messageSize = messageSize;\n        producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void start() {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage() throws MQClientException {\n        byte[] body = new byte[messageSize];\n        Message msg = new Message(topic, body);\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 385,
    "Instruction": "Task Description: Create a Java class that implements a simple RocketMQ producer to send messages to a specified topic.\n\nClass Description: The SimpleProducer class provides basic functionality to send messages to a RocketMQ broker. It handles producer initialization, message sending, and cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- SimpleProducer(String producerGroup, String namesrvAddr) -> Constructor - Initializes the producer with the specified producer group and NameServer address\n- start() -> void - Starts the producer instance to begin sending messages\n- sendMessage(String topic, String tags, String keys, byte[] body) -> void - Creates and sends a message with the specified topic, tags, keys, and body content\n- shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) throws Exception {\n        Message msg = new Message(topic, tags, keys, body);\n        producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.exception.MQBrokerException;\nimport org.apache.rocketmq.client.exception.RemotingException;\nimport org.apache.rocketmq.client.exception.MQException;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\n\npublic class SimpleProducer {\n    private DefaultMQProducer producer;\n\n    public SimpleProducer(String producerGroup, String namesrvAddr) {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setSendMsgTimeout(30 * 1000);\n    }\n\n    public void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(\"Failed to start producer\", e);\n        }\n    }\n\n    public void sendMessage(String topic, String tags, String keys, byte[] body) {\n        try {\n            Message msg = new Message(topic, tags, keys, body);\n            producer.send(msg);\n        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 386,
    "Instruction": "Task Description: Create a Java function that demonstrates how to use RocketMQ's producer to send messages to a specified topic with ACL authentication.\n\nFunction Description: This function creates and configures a RocketMQ producer with ACL authentication, sends multiple messages to a specified topic, and then shuts down the producer. It demonstrates the basic workflow of message production including producer initialization, message creation, message sending, and resource cleanup.\n\nInput: None (The function uses predefined constants for configuration)\n\nOutput: None (The function prints send results to console but doesn't return any value)\n\nMethods:\n\nproducer: producer() -> void - Main function that creates and configures the producer, sends messages, and handles shutdown\ngetAclRPCHook: getAclRPCHook() -> RPCHook - Helper function that creates and returns an ACL authentication hook using predefined credentials",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.acl.common.AclClientRPCHook;\nimport org.apache.rocketmq.acl.common.SessionCredentials;\nimport org.apache.rocketmq.remoting.RPCHook;\n\nprivate static final String ACL_ACCESS_KEY = \"RocketMQ\";\nprivate static final String ACL_SECRET_KEY = \"1234567\";\n\npublic static void producer() throws MQClientException {\n    DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroupName\", getAclRPCHook());\n    producer.setNamesrvAddr(\"127.0.0.1:9876\");\n    producer.start();\n\n    for (int i = 0; i < 128; i++)\n        try {\n            {\n                Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n                SendResult sendResult = producer.send(msg);\n                System.out.printf(\"%s%n\", sendResult);\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    producer.shutdown();\n}\n\nstatic RPCHook getAclRPCHook() {\n    return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.SendResult;\nimport org.apache.rocketmq.remoting.common.AccessKeySecretCredential;\nimport org.apache.rocketmq.remoting.common.RPCHook;\n\npublic class RocketMQProducer {\n    private static final String NAME_SRV_ADDR = \"localhost:9876\";\n    private static final String ACCESS_KEY = \"your_access_key\";\n    private static final String SECRET_KEY = \"your_secret_key\";\n\n    public void producer() {\n        DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroup\");\n        producer.setNamesrvAddr(NAME_SRV_ADDR);\n        producer.setRPCHook(getAclRPCHook());\n        \n        try {\n            producer.start();\n            for (int i = 0; i < 10; i++) {\n                Message msg = new Message(\"TopicTest\", (\"Hello RocketMQ \" + i).getBytes());\n                SendResult sendResult = producer.send(msg);\n                System.out.println(\"SendResult: \" + sendResult.getSendStatus());\n            }\n        } catch (MQClientException | InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            producer.shutdown();\n        }\n    }\n\n    private RPCHook getAclRPCHook() {\n        return new RPCHook((rpcContext) -> {\n            rpcContext.putHeader(\"accessKey\", ACCESS_KEY);\n            rpcContext.putHeader(\"secretKey\", SECRET_KEY);\n        });\n    }\n}"
  },
  {
    "Task_id": 389,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer to send messages to a RocketMQ broker.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for sending messages to a RocketMQ message broker. It handles producer initialization, message sending, and resource cleanup.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance that handles message sending operations\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> void - Constructor that initializes the producer with a producer group and NameServer address. Starts the producer instance.\n- sendMessage(String topic, String tags, String keys, String body) -> SendResult - Creates and sends a message to the specified topic with given tags and keys. Returns the send result containing message status.\n- shutdown() -> void - Shuts down the producer instance and releases resources.\n\nInput:\n- Constructor parameters:\n  - producerGroup: String - The group name of the producer\n  - namesrvAddr: String - The address of the NameServer\n- sendMessage parameters:\n  - topic: String - The topic to send the message to\n  - tags: String - Tags for message filtering\n  - keys: String - The business key of the message\n  - body: String - The message content\n\nOutput:\n- sendMessage returns: SendResult - Contains information about the message sending operation\n- shutdown returns: void",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) throws MQClientException {\n        producer = new DefaultMQProducer(producerGroup);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) throws Exception {\n        Message msg = new Message(topic,\n                tags,\n                keys,\n                body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.client.producer.SendResult;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n        this.producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tags, String keys, String body) {\n        Message message = new Message(topic, tags, keys, body.getBytes());\n        return this.producer.send(message);\n    }\n\n    public void shutdown() {\n        if (this.producer != null) {\n            this.producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 39,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality for making synchronous and asynchronous HTTP requests, specifically designed for interacting with the Broadcastify API.\n\nClass Description: The BroadcastifyHttpClient class provides methods for testing API connections and sending asynchronous requests to the Broadcastify service. It uses Java's HttpClient for HTTP/2 communication with configurable timeout and redirect policies.\n\nAttributes:\n- mHttpClient: [HttpClient] - The underlying HTTP client instance configured with HTTP/2 support, 20-second timeout, and normal redirect policy\n\nMethods:\n- testConnection: [testConnection](BroadcastifyCallConfiguration configuration) -> String - Tests the connection to the Broadcastify API by sending a synchronous multipart/form-data POST request with API key, system ID, and test flag. Returns the response body with status code or error message.\n- sendAsyncRequest: [sendAsyncRequest](HttpRequest request) -> void - Sends an HTTP request asynchronously and handles the response or error in a completion callback. Successful responses (status 200) and errors are handled separately.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class BroadcastifyHttpClient {\n\n    private HttpClient mHttpClient = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_2)\n        .followRedirects(HttpClient.Redirect.NORMAL)\n        .connectTimeout(Duration.ofSeconds(20))\n        .build();\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        BroadcastifyCallBuilder bodyBuilder = new BroadcastifyCallBuilder();\n        bodyBuilder.addPart(FormField.API_KEY, configuration.getApiKey())\n            .addPart(FormField.SYSTEM_ID, configuration.getSystemID())\n            .addPart(FormField.TEST, 1);\n\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(configuration.getHost()))\n            .header(HttpHeaders.CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bodyBuilder.getBoundary())\n            .header(HttpHeaders.USER_AGENT, \"sdrtrunk\")\n            .header(HttpHeaders.ACCEPT, \"*/*\")\n            .POST(bodyBuilder.build())\n            .build();\n\n        HttpResponse.BodyHandler<String> responseHandler = HttpResponse.BodyHandlers.ofString();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, responseHandler);\n            String responseBody = response.body();\n            return (responseBody != null ? responseBody : \"(no response)\") + \" Status Code:\" + response.statusCode();\n        }\n        catch(Exception e) {\n            return e.getLocalizedMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n            .whenComplete((response, throwable) -> {\n                if(throwable != null || response.statusCode() != 200) {\n                    if(!(throwable instanceof IOException || throwable instanceof CompletionException)) {\n                        // Handle non-I/O errors\n                    }\n                }\n                else {\n                    // Handle successful response\n                }\n            });\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.Map;\n\npublic class BroadcastifyHttpClient {\n    private final HttpClient mHttpClient;\n\n    public BroadcastifyHttpClient() {\n        mHttpClient = HttpClient.newBuilder()\n                .version(HttpClient.Version.HTTP_2)\n                .connectTimeout(Duration.ofSeconds(20))\n                .followRedirects(HttpClient.Redirect.NORMAL)\n                .build();\n    }\n\n    public String testConnection(BroadcastifyCallConfiguration configuration) {\n        String testUrl = \"https://api.broadcastify.com/v1/test\";\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(testUrl))\n                .header(\"Content-Type\", \"multipart/form-data\")\n                .POST(HttpRequest.BodyPublishers.ofMultipartFormData(\n                        Map.of(\n                                \"apiKey\", configuration.getApiKey(),\n                                \"systemId\", configuration.getSystemId(),\n                                \"test\", String.valueOf(configuration.isTest())\n                        )\n                ))\n                .build();\n\n        try {\n            HttpResponse<String> response = mHttpClient.send(request, HttpResponse.BodyHandlers.ofString());\n            return response.body();\n        } catch (Exception e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n\n    public void sendAsyncRequest(HttpRequest request) {\n        mHttpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenAccept(response -> {\n                    if (response.statusCode() == 200) {\n                        System.out.println(\"Success: \" + response.body());\n                    } else {\n                        System.out.println(\"Error: \" + response.statusCode() + \" - \" + response.body());\n                    }\n                })\n                .exceptionally(ex -> {\n                    System.err.println(\"Exception occurred: \" + ex.getMessage());\n                    return null;\n                });\n    }\n}"
  },
  {
    "Task_id": 390,
    "Instruction": "Task Description: Create a Java class that implements a RocketMQ producer capable of sending messages to a specified topic with a given tag. The class should handle producer initialization, message sending, and resource cleanup.\n\nClass Description: The Producer class encapsulates the functionality of a RocketMQ message producer. It manages the producer lifecycle (startup and shutdown) and provides a method to send messages to a RocketMQ broker.\n\nAttributes:\n- producer: DefaultMQProducer - The underlying RocketMQ producer instance that handles message sending operations\n\nMethods:\n- Constructor: Producer(String producerGroup, String namesrvAddr) -> void - Initializes a new producer instance with the specified producer group and NameServer address\n- start: start() -> void - Starts the producer instance to begin sending messages\n- sendMessage: sendMessage(String topic, String tag, String messageBody) -> SendResult - Creates and sends a message to the specified topic with the given tag and body\n- shutdown: shutdown() -> void - Shuts down the producer instance and releases resources",
    "Canonical_solution": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\npublic class Producer {\n\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) throws MQClientException {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() throws MQClientException {\n        producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tag, String messageBody) throws Exception {\n        Message msg = new Message(topic, \n                                tag,\n                                messageBody.getBytes(RemotingHelper.DEFAULT_CHARSET));\n        return producer.send(msg);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.SendResult;\nimport java.nio.charset.StandardCharsets;\n\npublic class Producer {\n    private DefaultMQProducer producer;\n\n    public Producer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void start() {\n        this.producer.start();\n    }\n\n    public SendResult sendMessage(String topic, String tag, String messageBody) {\n        Message msg = new Message(topic, tag, messageBody.getBytes(StandardCharsets.UTF_8));\n        return this.producer.send(msg);\n    }\n\n    public void shutdown() {\n        this.producer.shutdown();\n    }\n}"
  },
  {
    "Task_id": 391,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic with tags. The class should handle producer configuration, message sending, and resource cleanup.\n\nClass Description: The RocketMQProducer class encapsulates the functionality for creating and managing a RocketMQ message producer. It handles initialization, configuration, message sending, and shutdown of the producer instance.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namesrvAddr: String - The NameServer address for RocketMQ\n- LOGGER: Logger - Logger instance for logging producer activities\n\nMethods:\n- RocketMQProducer(String producerGroup, String namesrvAddr) -> None - Constructor that initializes the producer with a group name and NameServer address\n- configureProducer() -> None - Configures the producer with necessary settings including NameServer address and access channel\n- startProducer() -> None - Starts the producer instance and logs the startup\n- sendMessage(String topic, String tags, String messageBody) -> SendResult - Creates and sends a message to the specified topic with given tags and body, returns the send result\n- shutdownProducer() -> None - Shuts down the producer instance to release resources",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.client.producer.SendStatus;\nimport org.apache.rocketmq.client.AccessChannel;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\n\npublic class RocketMQProducer {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(RocketMQProducer.class);\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup, false, null);\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void configureProducer() {\n        producer.setAccessChannel(AccessChannel.CLOUD);\n        producer.setNamesrvAddr(namesrvAddr);\n    }\n\n    public void startProducer() throws Exception {\n        producer.start();\n        LOGGER.info(\"Producer Started...\");\n    }\n\n    public SendResult sendMessage(String topic, String tags, String messageBody) throws Exception {\n        Message msg = new Message(\n            topic, \n            tags, \n            messageBody.getBytes(RemotingHelper.DEFAULT_CHARSET)\n        );\n        SendResult sendResult = producer.send(msg);\n        if (sendResult.getSendStatus() != SendStatus.SEND_OK) {\n            throw new Exception(\"Message sending failed\");\n        }\n        return sendResult;\n    }\n\n    public void shutdownProducer() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.ClientConfig;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.SendResult;\nimport org.apache.rocketmq.remoting.common.RemotingCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namesrvAddr;\n    private static final Logger LOGGER = LoggerFactory.getLogger(RocketMQProducer.class);\n\n    public RocketMQProducer(String producerGroup, String namesrvAddr) {\n        this.producer = new DefaultMQProducer(producerGroup);\n        this.namesrvAddr = namesrvAddr;\n    }\n\n    public void configureProducer() {\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.setAccessChannel(ClientConfig.AccessChannel.ASYNC);\n    }\n\n    public void startProducer() {\n        try {\n            producer.start();\n            LOGGER.info(\"RocketMQ producer started successfully.\");\n        } catch (MQClientException e) {\n            LOGGER.error(\"Failed to start RocketMQ producer.\", e);\n            throw new RuntimeException(\"Failed to start RocketMQ producer.\", e);\n        }\n    }\n\n    public SendResult sendMessage(String topic, String tags, String messageBody) {\n        Message msg = new Message(topic, tags, messageBody.getBytes(RemotingCommand.DEFAULT_CHARSET));\n        try {\n            return producer.send(msg);\n        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n            LOGGER.error(\"Failed to send message to RocketMQ.\", e);\n            throw new RuntimeException(\"Failed to send message.\", e);\n        }\n    }\n\n    public void shutdownProducer() {\n        if (producer != null) {\n            producer.shutdown();\n            LOGGER.info(\"RocketMQ producer shut down.\");\n        }\n    }\n}"
  },
  {
    "Task_id": 393,
    "Instruction": "Task Description: Create a Java class that serves as a template for interacting with RocketMQ producers, providing various methods to send messages (including ordered messages) with configurable parameters.\n\nClass Description: The RocketMQTemplate class is a utility class that simplifies interaction with RocketMQ producers. It manages producer instances, provides default configurations, and offers multiple methods for sending messages with different levels of customization. The class handles both regular and ordered message sending, with configurable timeouts, queue numbers, and producer groups.\n\nAttributes:\n- log: [InternalLogger] - Logger instance for error and debug logging\n- DEFAULT_PRODUCER_GROUP: [String] - Default producer group name\n- DEFAULT_QUEUE_NUM: [int] - Default number of queues\n- DEFAULT_SEND_MSG_TIMEOUT: [int] - Default message sending timeout in milliseconds\n- producerMap: [Map<String, DefaultMQProducer>] - Map storing producer instances with their configuration keys\n\nMethods:\n- getProducer() -> [DefaultMQProducer] - Gets a producer with default settings\n- getProducer([int queueNum]) -> [DefaultMQProducer] - Gets a producer with custom queue number\n- getProducer([String producerGroup, int sendMsgTimeout]) -> [DefaultMQProducer] - Gets a producer with custom group and timeout\n- getProducer([int queueNum, String producerGroup, int sendMsgTimeout]) -> [DefaultMQProducer] - Gets a fully customized producer\n- send([String topic, String body]) -> [SendResult] - Sends a message with default settings\n- send([String topic, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with custom timeout\n- send([String producerGroup, String topic, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with custom group and timeout\n- send([String producerGroup, String topic, String tags, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with tags\n- send([String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends a message with tags and keys\n- send([String producerGroup, Message message, int sendMsgTimeout]) -> [SendResult] - Internal method for sending messages\n- sendOrderly([String producerGroup, String topic, String keys, String body]) -> [SendResult] - Sends ordered message with default timeout\n- sendOrderly([String producerGroup, String topic, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends ordered message with custom timeout\n- sendOrderly([String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout]) -> [SendResult] - Sends ordered message with tags\n- sendOrderly([String producerGroup, Message message, int sendMsgTimeout]) -> [SendResult] - Internal method for sending ordered messages",
    "Canonical_solution": "import org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.rocketmq.client.log.ClientLogger;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.InternalLogger;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RocketMQTemplate {\n\n    private static final InternalLogger log = ClientLogger.getLog();\n\n    private static final String DEFAULT_PRODUCER_GROUP = \"default-producer\";\n    private static final int DEFAULT_QUEUE_NUM = 4;\n    private static final int DEFAULT_SEND_MSG_TIMEOUT = 3000;\n\n    private static Map<String, DefaultMQProducer> producerMap = new HashMap<>();\n\n    public static DefaultMQProducer getProducer() throws Exception {\n        return getProducer(DEFAULT_QUEUE_NUM, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static DefaultMQProducer getProducer(int queueNum) throws Exception {\n        return getProducer(queueNum, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static DefaultMQProducer getProducer(String producerGroup, int sendMsgTimeout) throws Exception {\n        return getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n    }\n\n    public static DefaultMQProducer getProducer(int queueNum, String producerGroup, int sendMsgTimeout) throws Exception {\n        if (queueNum < 1) throw new IllegalArgumentException(\"queueNum must >= 1\");\n        if (StringUtils.isBlank(producerGroup)) throw new IllegalArgumentException(\"producerGroup cannot be null\");\n        String producerKey = producerGroup + queueNum;\n        if (producerMap.get(producerKey) == null) {\n            synchronized (producerMap) {\n                if (producerMap.get(producerKey) == null) {\n                    DefaultMQProducer producer = new DefaultMQProducer(DEFAULT_PRODUCER_GROUP);\n                    producer.setDefaultTopicQueueNums(queueNum);\n                    producer.setSendMsgTimeout(sendMsgTimeout);\n                    producer.start();\n                    producerMap.put(producerKey, producer);\n                }\n            }\n        }\n        return producerMap.get(producerKey);\n    }\n\n    public static SendResult send(String topic, String body) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static SendResult send(String topic, String body, int sendMsgTimeout) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, \"\", body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String tags, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, tags, \"\", body, sendMsgTimeout);\n    }\n\n    public static SendResult send(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        try {\n            return send(producerGroup, new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET)), sendMsgTimeout);\n        } catch (Exception e) {\n            log.error(\"send error, producerGroup:{}, topic:{}, tags:{}, keys:{}, body:{}\",\n                    producerGroup, topic, tags, keys, body, e);\n            throw new MessagingException(e.getMessage(), e);\n        }\n    }\n\n    private static SendResult send(String producerGroup, Message message, int sendMsgTimeout) throws Exception {\n        return getProducer(producerGroup, sendMsgTimeout).send(message);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String keys, String body) {\n        return sendOrderly(producerGroup, topic, keys, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String keys, String body, int sendMsgTimeout) {\n        return sendOrderly(producerGroup, topic, keys, body, sendMsgTimeout);\n    }\n\n    public static SendResult sendOrderly(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        try {\n            return sendOrderly(producerGroup, new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET)), sendMsgTimeout);\n        } catch (Exception e) {\n            log.error(\"send error, producerGroup:{}, topic:{}, tags:{}, keys:{}, body:{}\",\n                    producerGroup, topic, tags, keys, body, e);\n            throw new MessagingException(e.getMessage(), e);\n        }\n    }\n\n    private static SendResult sendOrderly(String producerGroup, Message message, int sendMsgTimeout) throws Exception {\n        return getProducer(producerGroup, sendMsgTimeout).send(message,\n                new MessageQueueSelector() {\n                    @Override\n                    public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                        long id = NumberUtils.toLong(String.valueOf(arg));\n                        int index = (int) (id % mqs.size());\n                        return mqs.get(index);\n                    }\n                }, message.getKeys());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.remoting.common.RemotingHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class RocketMQTemplate {\n    private static final Logger log = LoggerFactory.getLogger(RocketMQTemplate.class);\n    private static final String DEFAULT_PRODUCER_GROUP = \"DEFAULT_PRODUCER_GROUP\";\n    private static final int DEFAULT_QUEUE_NUM = 4;\n    private static final int DEFAULT_SEND_MSG_TIMEOUT = 3000;\n    private final Map<String, DefaultMQProducer> producerMap = new java.util.HashMap<>();\n\n    public RocketMQTemplate() {\n        // Initialize default producer if needed\n    }\n\n    public DefaultMQProducer getProducer() {\n        return getProducer(DEFAULT_QUEUE_NUM, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public DefaultMQProducer getProducer(int queueNum) {\n        return getProducer(queueNum, DEFAULT_PRODUCER_GROUP, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public DefaultMQProducer getProducer(String producerGroup, int sendMsgTimeout) {\n        return getProducer(DEFAULT_QUEUE_NUM, producerGroup, sendMsgTimeout);\n    }\n\n    public DefaultMQProducer getProducer(int queueNum, String producerGroup, int sendMsgTimeout) {\n        String key = String.format(\"%s_%d_%d\", producerGroup, queueNum, sendMsgTimeout);\n        if (producerMap.containsKey(key)) {\n            return producerMap.get(key);\n        }\n        DefaultMQProducer producer = new DefaultMQProducer(producerGroup);\n        producer.setSendMsgTimeout(sendMsgTimeout);\n        producer.setRetryTimesWhenSendFailed(2);\n        producer.setVipChannelEnabled(false);\n        producer.setNamesrvAddr(\"localhost:9876\");\n        producer.setInstanceName(\"RocketMQTemplate-\" + System.currentTimeMillis());\n        try {\n            producer.start();\n            producerMap.put(key, producer);\n        } catch (MQClientException e) {\n            log.error(\"Failed to start producer\", e);\n            throw new RuntimeException(\"Producer start failed\", e);\n        }\n        return producer;\n    }\n\n    public SendResult send(String topic, String body) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public SendResult send(String topic, String body, int sendMsgTimeout) {\n        return send(DEFAULT_PRODUCER_GROUP, topic, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String tags, String body, int sendMsgTimeout) {\n        return send(producerGroup, topic, tags, null, body, sendMsgTimeout);\n    }\n\n    public SendResult send(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        DefaultMQProducer producer = getProducer(producerGroup, sendMsgTimeout);\n        try {\n            Message msg = new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n            return producer.send(msg, sendMsgTimeout, 1000, 0);\n        } catch (MQClientException | InterruptedException e) {\n            log.error(\"Message send failed\", e);\n            throw new RuntimeException(\"Message send failed\", e);\n        }\n    }\n\n    public SendResult send(String producerGroup, Message message, int sendMsgTimeout) {\n        DefaultMQProducer producer = getProducer(producerGroup, sendMsgTimeout);\n        try {\n            return producer.send(message, sendMsgTimeout, 1000, 0);\n        } catch (MQClientException | InterruptedException e) {\n            log.error(\"Message send failed\", e);\n            throw new RuntimeException(\"Message send failed\", e);\n        }\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String keys, String body) {\n        return sendOrderly(producerGroup, topic, keys, body, DEFAULT_SEND_MSG_TIMEOUT);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String keys, String body, int sendMsgTimeout) {\n        return sendOrderly(producerGroup, topic, null, keys, body, sendMsgTimeout);\n    }\n\n    public SendResult sendOrderly(String producerGroup, String topic, String tags, String keys, String body, int sendMsgTimeout) {\n        DefaultMQProducer producer = getProducer(producerGroup, sendMsgTimeout);\n        try {\n            Message msg = new Message(topic, tags, keys, body.getBytes(RemotingHelper.DEFAULT_CHARSET));\n            return producer.send(msg, sendMsgTimeout, 1000, 0);\n        } catch (MQClientException | InterruptedException e) {\n            log.error(\"Ordered message send failed\", e);\n            throw new RuntimeException(\"Ordered message send failed\", e);\n        }\n    }\n\n    public SendResult sendOrderly(String producerGroup, Message message, int sendMsgTimeout) {\n        DefaultMQProducer producer = getProducer(producerGroup, sendMsgTimeout);\n        try {\n            return producer.send(message, sendMsgTimeout, 1000, 0);\n        } catch (MQClientException | InterruptedException e) {\n            log.error(\"Ordered message send failed\", e);\n            throw new RuntimeException(\"Ordered message send failed\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 394,
    "Instruction": "Task Description: Implement a Java class that acts as a RocketMQ producer to send messages to a specified topic with a given tag.\n\nClass Description: The RocketMQProducer class encapsulates the functionality to initialize, send messages, and shutdown a RocketMQ producer instance. It handles the connection to the RocketMQ NameServer and manages message production.\n\nAttributes:\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- namespace: String - The namespace for the producer (V2 version)\n- producerGroup: String - The group name for the producer\n- namesrvAddr: String - The address of the NameServer\n- topic: String - The topic to which messages will be sent\n- tag: String - The tag for the messages\n\nMethods:\n- RocketMQProducer(String namespace, String producerGroup, String namesrvAddr, String topic, String tag) -> None - Constructor that initializes the producer with the given parameters\n- initialize() -> void - Configures and starts the producer instance with the specified namespace and NameServer address\n- sendMessage(String messageContent) -> void - Creates and sends a message with the given content to the configured topic and tag\n- shutdown() -> void - Shuts down the producer instance gracefully",
    "Canonical_solution": "import org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\nimport java.nio.charset.StandardCharsets;\n\npublic class RocketMQProducer {\n\n    private DefaultMQProducer producer;\n    private String namespace;\n    private String producerGroup;\n    private String namesrvAddr;\n    private String topic;\n    private String tag;\n\n    public RocketMQProducer(String namespace, String producerGroup, String namesrvAddr, String topic, String tag) {\n        this.namespace = namespace;\n        this.producerGroup = producerGroup;\n        this.namesrvAddr = namesrvAddr;\n        this.topic = topic;\n        this.tag = tag;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void initialize() throws Exception {\n        producer.setNamespaceV2(namespace);\n        producer.setNamesrvAddr(namesrvAddr);\n        producer.start();\n    }\n\n    public void sendMessage(String messageContent) throws Exception {\n        Message message = new Message(topic, tag, messageContent.getBytes(StandardCharsets.UTF_8));\n        producer.send(message);\n    }\n\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.common.message.Message;\n\npublic class RocketMQProducer {\n    private DefaultMQProducer producer;\n    private String namespace;\n    private String producerGroup;\n    private String namesrvAddr;\n    private String topic;\n    private String tag;\n\n    public RocketMQProducer(String namespace, String producerGroup, String namesrvAddr, String topic, String tag) {\n        this.namespace = namespace;\n        this.producerGroup = producerGroup;\n        this.namesrvAddr = namesrvAddr;\n        this.topic = topic;\n        this.tag = tag;\n        this.producer = new DefaultMQProducer(producerGroup);\n    }\n\n    public void initialize() {\n        producer.setV2Namespace(namespace);\n        producer.setNamesrvAddr(namesrvAddr);\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            throw new RuntimeException(\"Failed to start producer\", e);\n        }\n    }\n\n    public void sendMessage(String messageContent) {\n        Message msg = new Message(topic, tag, messageContent.getBytes());\n        try {\n            producer.send(msg);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to send message\", e);\n        }\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 395,
    "Instruction": "Task Description: Create a Java class that implements an asynchronous message producer using RocketMQ, capable of sending messages to specified topics with callback handling for success and failure cases.\n\nClass Description: RMQAsyncSendProducer is a RocketMQ asynchronous message producer that sends messages to a specified topic and handles responses through callbacks. It tracks successful sends and exceptions, and provides methods for waiting for responses and shutting down the producer.\n\nAttributes:\n- nsAddr: String - The NameServer address for RocketMQ\n- producer: DefaultMQProducer - The RocketMQ producer instance\n- sendCallback: SendCallback - Callback handler for message send results\n- successSendResult: List<SendResult> - Thread-safe list of successful send results\n- exceptionMsgCount: AtomicInteger - Counter for messages that failed to send\n- msgSize: int - The number of messages to send\n- logger: Logger - SLF4J logger instance\n- topic: String - The topic to which messages will be sent (inherited from AbstractMQProducer)\n- msgBodys: [Data Structure] - Stores message bodies (inherited from AbstractMQProducer)\n- originMsgs: [Data Structure] - Stores original messages (inherited from AbstractMQProducer)\n\nMethods:\n- RMQAsyncSendProducer(String nsAddr, String topic) -> void - Constructor that initializes the producer with NameServer address and topic\n- create() -> void - Creates and configures the DefaultMQProducer instance\n- start() -> void - Starts the producer instance\n- asyncSend(Object msg) -> void - Asynchronously sends a single message\n- asyncSend(int msgSize) -> void - Asynchronously sends multiple messages (quantity specified by msgSize)\n- asyncSend(Object msg, MessageQueueSelector selector, Object arg) -> void - Asynchronously sends a message with queue selection\n- waitForResponse(int timeoutMills) -> void - Waits for all responses until timeout\n- shutdown() -> void - Shuts down the producer (overrides AbstractMQProducer method)",
    "Canonical_solution": "import java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.MessageQueueSelector;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueue;\nimport org.apache.rocketmq.logging.org.slf4j.Logger;\nimport org.apache.rocketmq.logging.org.slf4j.LoggerFactory;\nimport org.apache.rocketmq.test.clientinterface.AbstractMQProducer;\nimport org.apache.rocketmq.test.sendresult.ResultWrapper;\nimport org.apache.rocketmq.test.util.RandomUtil;\nimport org.apache.rocketmq.test.util.TestUtil;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private static Logger logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n    private String nsAddr = null;\n    private DefaultMQProducer producer = null;\n    private SendCallback sendCallback = null;\n    private List<SendResult> successSendResult = Collections.synchronizedList(new ArrayList<SendResult>());\n    private AtomicInteger exceptionMsgCount = new AtomicInteger(0);\n    private int msgSize = 0;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        super(topic);\n        this.nsAddr = nsAddr;\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n            }\n            @Override\n            public void onException(Throwable throwable) {\n                exceptionMsgCount.getAndIncrement();\n            }\n        };\n        create();\n        start();\n    }\n\n    private void create() {\n        producer = new DefaultMQProducer();\n        producer.setProducerGroup(RandomUtil.getStringByUUID());\n        producer.setInstanceName(RandomUtil.getStringByUUID());\n        if (nsAddr != null) {\n            producer.setNamesrvAddr(nsAddr);\n        }\n    }\n\n    private void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            logger.error(\"producer start failed!\");\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        for (int i = 0; i < msgSize; i++) {\n            Message msg = new Message(topic, RandomUtil.getStringByUUID().getBytes(StandardCharsets.UTF_8));\n            this.asyncSend(msg);\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message metaqMsg = (Message) msg;\n        try {\n            producer.send(metaqMsg, selector, arg, sendCallback);\n            msgBodys.addData(new String(metaqMsg.getBody(), StandardCharsets.UTF_8));\n            originMsgs.addData(msg);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        long startTime = System.currentTimeMillis();\n        while (this.successSendResult.size() != this.msgSize) {\n            if (System.currentTimeMillis() - startTime < timeoutMills) {\n                TestUtil.waitForMonment(100);\n            } else {\n                logger.info(\"timeout but still not recv all response!\");\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        producer.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 42,
    "right_result": "import org.apache.rocketmq.client.exception.MQClientException;\nimport org.apache.rocketmq.client.producer.DefaultMQProducer;\nimport org.apache.rocketmq.client.producer.SendCallback;\nimport org.apache.rocketmq.client.producer.SendResult;\nimport org.apache.rocketmq.common.message.Message;\nimport org.apache.rocketmq.common.message.MessageQueueSelector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RMQAsyncSendProducer extends AbstractMQProducer {\n    private String nsAddr;\n    private DefaultMQProducer producer;\n    private SendCallback sendCallback;\n    private List<SendResult> successSendResult;\n    private AtomicInteger exceptionMsgCount;\n    private int msgSize;\n    private Logger logger;\n    private CountDownLatch latch;\n\n    public RMQAsyncSendProducer(String nsAddr, String topic) {\n        this.nsAddr = nsAddr;\n        this.topic = topic;\n        this.logger = LoggerFactory.getLogger(RMQAsyncSendProducer.class);\n        this.successSendResult = new java.util.concurrent.CopyOnWriteArrayList<>();\n        this.exceptionMsgCount = new AtomicInteger(0);\n        this.latch = null;\n    }\n\n    public void create() {\n        producer = new DefaultMQProducer(this.topic);\n        producer.setNamesrvAddr(this.nsAddr);\n    }\n\n    public void start() {\n        try {\n            producer.start();\n        } catch (MQClientException e) {\n            logger.error(\"Failed to start producer\", e);\n        }\n    }\n\n    public void asyncSend(Object msg) {\n        Message message = new Message(this.topic, msg.toString().getBytes());\n        producer.sendAsync(message, sendCallback);\n    }\n\n    public void asyncSend(int msgSize) {\n        this.msgSize = msgSize;\n        this.latch = new CountDownLatch(msgSize);\n        for (int i = 0; i < msgSize; i++) {\n            asyncSend(new Object());\n        }\n    }\n\n    public void asyncSend(Object msg, MessageQueueSelector selector, Object arg) {\n        Message message = new Message(this.topic, msg.toString().getBytes());\n        producer.sendAsync(message, selector, arg, sendCallback);\n    }\n\n    public void waitForResponse(int timeoutMills) {\n        try {\n            if (latch != null) {\n                latch.await(timeoutMills, java.util.concurrent.TimeUnit.MILLISECONDS);\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            logger.error(\"Wait for response interrupted\", e);\n        }\n    }\n\n    public void shutdown() {\n        if (producer != null) {\n            producer.shutdown();\n        }\n    }\n\n    {\n        sendCallback = new SendCallback() {\n            @Override\n            public void onSuccess(SendResult sendResult) {\n                successSendResult.add(sendResult);\n                if (latch != null) {\n                    latch.countDown();\n                }\n            }\n\n            @Override\n            public void onException(Throwable e) {\n                exceptionMsgCount.incrementAndGet();\n                logger.error(\"Message send failed\", e);\n                if (latch != null) {\n                    latch.countDown();\n                }\n            }\n        };\n    }\n}"
  },
  {
    "Task_id": 4,
    "Instruction": "Task Description: Create a Java class that implements an ActiveMQ message producer capable of sending messages to both queues and topics.\n\nClass Description: The JmsProducer class is responsible for establishing a connection to an ActiveMQ broker, creating both queue and topic destinations, and sending multiple text messages to each destination. It handles connection management and includes error handling for JMS operations.\n\nAttributes:\n- USERNAME: [String] - Default username for ActiveMQ connection (default: ActiveMQConnection.DEFAULT_USER)\n- PASSWORD: [String] - Default password for ActiveMQ connection (default: ActiveMQConnection.DEFAULT_PASSWORD)\n- BROKEURL: [String] - Default broker URL for ActiveMQ connection (default: ActiveMQConnection.DEFAULT_BROKER_URL)\n- SENDNUM: [int] - Number of messages to send to each destination (default: 10)\n\nMethods:\n- run(): [void] - Main method that establishes the connection, creates destinations (queue and topic), and initiates message sending. Handles connection lifecycle and error cases.\n- sendMessage(Session session, MessageProducer messageProducer, String type): [void] - Helper method that creates and sends multiple text messages with timestamps to the specified destination. \n  Parameters:\n    - session: [Session] - JMS session for message creation\n    - messageProducer: [MessageProducer] - Producer for sending messages\n    - type: [String] - Destination type identifier (\"QUEUE\" or \"TOPIC\") for logging purposes",
    "Canonical_solution": "import javax.jms.Connection;\nimport javax.jms.ConnectionFactory;\nimport javax.jms.Destination;\nimport javax.jms.JMSException;\nimport javax.jms.MessageProducer;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport org.apache.activemq.ActiveMQConnection;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsProducer {\n\n    private static final String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private static final String BROKEURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n    private static final int SENDNUM = 10;\n\n    public static void run() {\n        ConnectionFactory connectionFactory;\n        Connection connection = null;\n        Session session;\n        Destination destination;\n        MessageProducer messageProducer;\n        \n        connectionFactory = new ActiveMQConnectionFactory(JmsProducer.USERNAME, JmsProducer.PASSWORD, JmsProducer.BROKEURL);\n        try {\n            connection = connectionFactory.createConnection();\n            connection.start();\n            session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n            destination = session.createQueue(\"SAMPLE_MQ_QUEUE\");\n            messageProducer = session.createProducer(destination);\n            sendMessage(session, messageProducer, \"QUEUE\");\n\n            destination = session.createTopic(\"SAMPLE_MQ_TOPIC\");\n            messageProducer = session.createProducer(destination);\n            sendMessage(session, messageProducer, \"TOPIC\");\n            session.commit();\n            Thread.sleep(1000);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void sendMessage(Session session, MessageProducer messageProducer, String type) throws Exception {\n        for (int i = 0; i < JmsProducer.SENDNUM; i++) {\n            Date date = new Date();\n            TextMessage message = session.createTextMessage(\"ActiveMQ \u53d1\u9001\u6d88\u606f\u65f6\u95f4\uff1a\" + date);\n            System.out.println(\"\\t\" + type + \"\\t\u53d1\u9001\u6d88\u606f\uff1aActivemq \u53d1\u9001\u6d88\u606f\u65f6\u95f4\uff1a\" + date);\n            messageProducer.send(message);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 38,
    "right_result": "import javax.jms.*;\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\npublic class JmsProducer {\n    private String USERNAME = ActiveMQConnection.DEFAULT_USER;\n    private String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;\n    private String BROKERURL = ActiveMQConnection.DEFAULT_BROKER_URL;\n    private int SENDNUM = 10;\n\n    public void run() {\n        ConnectionFactory connectionFactory;\n        Connection connection;\n        Session session;\n        Destination queue;\n        Destination topic;\n        MessageProducer queueProducer;\n        MessageProducer topicProducer;\n\n        try {\n            connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKERURL);\n            connection = connectionFactory.createConnection();\n            connection.start();\n\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n            queue = session.createQueue(\"exampleQueue\");\n            topic = session.createTopic(\"exampleTopic\");\n\n            queueProducer = session.createProducer(queue);\n            topicProducer = session.createProducer(topic);\n\n            sendMessage(session, queueProducer, \"QUEUE\");\n            sendMessage(session, topicProducer, \"TOPIC\");\n\n        } catch (JMSException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (queueProducer != null) queueProducer.close();\n                if (topicProducer != null) topicProducer.close();\n                if (session != null) session.close();\n                if (connection != null) connection.close();\n            } catch (JMSException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void sendMessage(Session session, MessageProducer producer, String type) throws JMSException {\n        for (int i = 0; i < SENDNUM; i++) {\n            TextMessage message = session.createTextMessage(\"Message \" + i + \" sent to \" + type + \" at \" + System.currentTimeMillis());\n            producer.send(message);\n            System.out.println(\"Sent message to \" + type + \": \" + message.getText());\n        }\n    }\n\n    public static void main(String[] args) {\n        JmsProducer producer = new JmsProducer();\n        producer.run();\n    }\n}"
  },
  {
    "Task_id": 406,
    "Instruction": "Task Description: Write a Java function that tests a server's handling of a malformed HTTP request by sending a bad request and verifying the server's response.\n\nFunction Description: The function `testBadRequest` attempts to send a deliberately malformed HTTP POST request to a server and verifies that the server responds with a \"400 Bad Request\" error. The function creates a TCP socket connection to the server, sends the malformed request, reads the server's response, and compares it to the expected response. If the response matches, the test passes; otherwise, it may throw an IOException if the connection is closed prematurely.\n\nInput: None (The server address and port are obtained from `DefaultServer.getDefaultServerAddress()` internally)\n\nOutput: None (The function asserts the server's response matches the expected \"400 Bad Request\" response. Any mismatch or IOException will result in a test failure or exception.)",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Socket;\n\npublic void testBadRequest() throws IOException {\n    String request = \"POST /\\r HTTP/1.1\\r\\nTrailer:foo, bar\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n9\\r\\nabcdefghi\\r\\n0\\r\\nfoo: fooVal\\r\\n bar: barVal\\r\\n\\r\\n\";\n    String response1 = \"HTTP/1.1 400 Bad Request\\r\\nContent-Length: 0\\r\\nConnection: close\\r\\n\\r\\n\";\n    Socket s = new Socket(DefaultServer.getDefaultServerAddress().getAddress(), DefaultServer.getDefaultServerAddress().getPort());\n    try {\n        s.getOutputStream().write(request.getBytes());\n\n        StringBuilder sb = new StringBuilder();\n        int read = 0;\n        byte[] buf = new byte[100];\n        while (read < response1.length()) {\n            int r = s.getInputStream().read(buf);\n            if (r <= 0) break;\n            if (r > 0) {\n                read += r;\n                sb.append(new String(buf, 0, r));\n            }\n        }\n        Assert.assertEquals(response1, sb.toString());\n\n    } catch (IOException expected) {\n        //this can happen as well, as in some cases we may not have fully consumed the read side\n        //before the connection is shutdown, namely when we are running in test.single\n    } finally {\n        s.close();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 15,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.nio.charset.StandardCharsets;\n\npublic class TestServer {\n    public void testBadRequest() throws IOException {\n        String serverAddress = DefaultServer.getDefaultServerAddress();\n        String[] parts = serverAddress.split(\":\");\n        String host = parts[0];\n        int port = Integer.parseInt(parts[1]);\n\n        Socket socket = new Socket(host, port);\n        try (OutputStream os = socket.getOutputStream();\n             InputStream is = socket.getInputStream()) {\n            String request = \"POST / HTTP/1.1\\r\\n\" +\n                             \"Content-Length: 0\\r\\n\" +\n                             \"\\r\\n\";\n            os.write(request.getBytes(StandardCharsets.UTF_8));\n            os.flush();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuilder response = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n                if (line.startsWith(\"HTTP/\")) {\n                    break;\n                }\n            }\n\n            String statusLine = response.toString().trim();\n            if (!statusLine.startsWith(\"HTTP/1.1 400 Bad Request\")) {\n                throw new IOException(\"Unexpected response: \" + statusLine);\n            }\n        } finally {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 412,
    "Instruction": "Task Description: Create a Java class that checks for a specific vulnerability (HTTP.sys Remote Code Execution) in a target server using TCP client communication.\n\nClass Description: The HttpSysRCEClient class is designed to detect the presence of the CVE-2015-1635 (MS15-034) vulnerability in a target HTTP server by sending specially crafted HTTP requests and analyzing the responses. It utilizes TCP socket communication to interact with the server.\n\nAttributes:\n- target: String - The URL of the target server to be checked\n- task: Task - An object containing task-related information and results\n\nMethods:\n- HttpSysRCEClient(String target, Task task) -> None - Constructor that initializes the target URL and task object\n- checkVulnerability() -> void - Main method that performs the vulnerability check by:\n  1. Establishing TCP connection to the target server\n  2. Sending crafted HTTP requests with malicious Range headers\n  3. Analyzing responses for vulnerability indicators\n  4. Adding vulnerability to task results if detected\n- addVulnerable() -> void - Helper method that adds vulnerability information to the task results when detected",
    "Canonical_solution": "import com.trackray.base.bean.Task;\nimport com.trackray.base.bean.Vulnerable;\nimport com.trackray.base.utils.IOUtils;\nimport com.trackray.base.utils.SysLog;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\nimport java.util.concurrent.TimeUnit;\n\npublic class HttpSysRCEClient {\n\n    private String target;\n    private Task task;\n\n    public HttpSysRCEClient(String target, Task task) {\n        this.target = target;\n        this.task = task;\n    }\n\n    public void checkVulnerability() {\n        try {\n            URL url = new URL(target);\n            String host = url.getHost();\n            int port = url.getPort();\n\n            Socket socket = new Socket(host, port);\n\n            Callable<String> callable = new Callable<String>() {\n                @Override\n                public String call() throws Exception {\n                    String hexAllFfff = \"18446744073709551615\";\n                    String req = \"GET / HTTP/1.0\\r\\nHost: \" + host + \"\\r\\nRange: bytes=0-\" + hexAllFfff + \"\\r\\n\\r\\n\";\n\n                    InputStream inputStream = socket.getInputStream();\n                    OutputStream outputStream = socket.getOutputStream();\n\n                    outputStream.write(req.getBytes());\n                    outputStream.flush();\n\n                    return IOUtils.analysisStream(inputStream);\n                }\n            };\n\n            FutureTask<String> futureTask = new FutureTask<>(callable);\n            futureTask.run();\n            \n            try {\n                String result = futureTask.get(30, TimeUnit.SECONDS);\n                if (StringUtils.contains(result, \"Requested Range Not Satisfiable\")) {\n                    addVulnerable();\n                }\n            } catch (Exception e) {\n                Socket newSocket = new Socket(host, port);\n\n                callable = new Callable<String>() {\n                    @Override\n                    public String call() throws Exception {\n                        String hexAllFfff = \"18446744073709551615\";\n                        String req = \"GET / HTTP/1.1\\r\\nHost: \" + host + \"\\r\\nRange: bytes=0-\" + hexAllFfff + \"\\r\\n\\r\\n\";\n\n                        InputStream inputStream = newSocket.getInputStream();\n                        OutputStream outputStream = newSocket.getOutputStream();\n\n                        outputStream.write(req.getBytes());\n                        outputStream.flush();\n\n                        return IOUtils.analysisStream(inputStream);\n                    }\n                };\n\n                futureTask.cancel(true);\n                futureTask = new FutureTask<>(callable);\n                futureTask.run();\n                \n                try {\n                    String result = futureTask.get(30, TimeUnit.SECONDS);\n                    if (StringUtils.contains(result, \"Requested Range Not Satisfiable\")) {\n                        addVulnerable();\n                    }\n                } catch (Exception ee) {\n                } finally {\n                    futureTask.cancel(true);\n                    newSocket.close();\n                }\n            } finally {\n                socket.close();\n            }\n        } catch (Exception e) {\n            SysLog.error(e);\n        }\n    }\n\n    private void addVulnerable() {\n        task.getResult().addVulnerable(\n            Vulnerable.builder()\n                .title(\"HTTP.sys \u8fdc\u7a0b\u4ee3\u7801\u6267\u884c\")\n                .address(target)\n                .level(Vulnerable.Level.HIGH.getLevel())\n                .type(Vulnerable.Type.CODE_EXECUTION.getType())\n                .vulnId(Arrays.asList(\"CVE-2015-1635\", \"MS15-034\"))\n                .build()\n        );\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "import java.io.*;\nimport java.net.*;\n\npublic class HttpSysRCEClient {\n    private String target;\n    private Task task;\n\n    public HttpSysRCEClient(String target, Task task) {\n        this.target = target;\n        this.task = task;\n    }\n\n    public void checkVulnerability() {\n        try {\n            URL url = new URL(target);\n            String host = url.getHost();\n            int port = url.getPort();\n            if (port == -1) port = 80;\n\n            Socket socket = new Socket();\n            socket.connect(new InetSocketAddress(host, port), 5000);\n\n            OutputStream os = socket.getOutputStream();\n            InputStream is = socket.getInputStream();\n\n            String request = \"GET / HTTP/1.1\\r\\n\" +\n                             \"Host: \" + host + \"\\r\\n\" +\n                             \"Range: bytes=0-18446744073709551615\\r\\n\" +\n                             \"\\r\\n\";\n            os.write(request.getBytes());\n            os.flush();\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line).append(\"\\n\");\n                if (line.trim().isEmpty()) break;\n            }\n\n            String statusLine = response.toString().split(\"\\n\")[0];\n            String[] statusParts = statusLine.split(\" \");\n            String statusCode = statusParts[1];\n\n            String contentLength = \"\";\n            for (String headerLine : response.toString().split(\"\\n\")) {\n                if (headerLine.startsWith(\"Content-Length: \")) {\n                    contentLength = headerLine.substring(\"Content-Length: \".length()).trim();\n                    break;\n                }\n            }\n\n            boolean isVulnerable = false;\n            if (statusCode.equals(\"206\") && contentLength.equals(\"0\")) {\n                isVulnerable = true;\n            } else if (statusCode.equals(\"200\") && contentLength.equals(\"0\")) {\n                isVulnerable = true;\n            }\n\n            if (isVulnerable) addVulnerable();\n\n            socket.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void addVulnerable() {\n        task.addResult(\"Vulnerability found: HTTP.sys Remote Code Execution (CVE-2015-1635)\");\n    }\n}"
  },
  {
    "Task_id": 419,
    "Instruction": "Task Description: Create a Java class that implements a TCP client for voice communication, handling both input and output streams for audio data transmission.\n\nClass Description: The VoiceClient class extends Thread to create a TCP client that connects to a voice server. It manages audio stream connections, handles data transmission, and provides methods for connection management.\n\nAttributes:\n- format: AudioFormat - The audio format configuration for the voice data\n- outputThread: VoiceOutput - Thread handling outgoing voice data\n- inputThread: VoiceInput - Thread handling incoming voice data\n- output: DataOutputStream - Output stream for sending data to server\n- input: DataInputStream - Input stream for receiving data from server\n- running: boolean - Flag indicating if the client is active\n- socket: Socket - The TCP socket connection\n- ip: String - The IP address of the server to connect to\n\nMethods:\n- VoiceClient(String ip) -> None - Constructor that initializes the client with server IP\n- run() -> None - Main thread method that establishes connection and starts I/O threads\n- disconnect() -> None - Closes all connections and stops the client\n- isRunning() -> boolean - Returns the running status of the client\n- getOutputStream() -> DataOutputStream - Returns the output stream\n- getInputStream() -> DataInputStream - Returns the input stream\n- getAudioFormat() -> AudioFormat - Returns the audio format configuration",
    "Canonical_solution": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.net.ConnectException;\nimport java.net.Socket;\nimport javax.sound.sampled.AudioFormat;\n\npublic class VoiceClient extends Thread {\n\n    private final AudioFormat format = new AudioFormat(16_000F, 16, 1, true, true);\n    private VoiceOutput outputThread;\n    private VoiceInput inputThread;\n    private DataOutputStream output;\n    private DataInputStream input;\n    private boolean running;\n    private Socket socket;\n    private final String ip;\n\n    public VoiceClient(String ip) {\n        super(\"VoiceServer Client Thread \" + ip);\n        this.ip = ip;\n        setDaemon(true);\n    }\n\n    @Override\n    public void run() {\n        try {\n            socket = new Socket(ip, MekanismAdditionsConfig.additions.voicePort.get());\n            running = true;\n\n            input = new DataInputStream(new BufferedInputStream(socket.getInputStream()));\n            output = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));\n\n            (outputThread = new VoiceOutput(this)).start();\n            (inputThread = new VoiceInput(this)).start();\n        } catch (ConnectException e) {\n        } catch (Exception e) {\n        }\n    }\n\n    public void disconnect() {\n        try {\n            if (inputThread != null) {\n                inputThread.interrupt();\n                inputThread.close();\n            }\n            if (outputThread != null) {\n                outputThread.interrupt();\n                outputThread.close();\n            }\n            if (output != null) {\n                output.close();\n            }\n            if (input != null) {\n                input.close();\n            }\n            if (socket != null) {\n                socket.close();\n            }\n\n            interrupt();\n\n            running = false;\n        } catch (Exception e) {\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public DataOutputStream getOutputStream() {\n        return output;\n    }\n\n    public DataInputStream getInputStream() {\n        return input;\n    }\n\n    public AudioFormat getAudioFormat() {\n        return format;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 15,
    "right_result": "import java.net.Socket;\nimport java.io.DataOutputStream;\nimport java.io.DataInputStream;\nimport javax.sound.sampled.AudioFormat;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\n\npublic class VoiceClient extends Thread {\n    private String ip;\n    private AudioFormat format;\n    private VoiceOutput outputThread;\n    private VoiceInput inputThread;\n    private DataOutputStream output;\n    private DataInputStream input;\n    private boolean running;\n    private Socket socket;\n\n    public VoiceClient(String ip) {\n        this.ip = ip;\n        format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, 44100, 16, 2, 4, 44100, false);\n        running = false;\n    }\n\n    @Override\n    public void run() {\n        try {\n            socket = new Socket(ip, 5000);\n            output = new DataOutputStream(socket.getOutputStream());\n            input = new DataInputStream(socket.getInputStream());\n            running = true;\n            outputThread = new VoiceOutput(input);\n            inputThread = new VoiceInput(output);\n            outputThread.start();\n            inputThread.start();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void disconnect() {\n        running = false;\n        try {\n            if (socket != null) socket.close();\n            if (output != null) output.close();\n            if (input != null) input.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public DataOutputStream getOutputStream() {\n        return output;\n    }\n\n    public DataInputStream getInputStream() {\n        return input;\n    }\n\n    public AudioFormat getAudioFormat() {\n        return format;\n    }\n}"
  },
  {
    "Task_id": 434,
    "Instruction": "Task Description: Create a Java class that implements a TCP client using Java NIO (Non-blocking I/O) for efficient network communication. The client should handle connection establishment, data transmission with checksum verification, and proper resource management.\n\nClass Description: ClientController is a TCP client implementation that manages non-blocking communication with a server. It uses a producer-consumer pattern with an internal queue for packet handling and implements checksum verification for data integrity.\n\nAttributes:\n- inner: BlockingQueue<Packet> - Queue for storing packets to be sent to the server\n- lock: Object - Synchronization lock for thread-safe operations\n- remote: InetSocketAddress - Server address to connect to\n- thread: Thread - Worker thread for handling network operations\n- channel: SocketChannel - NIO channel for communication with the server\n\nMethods:\n- ClientController(String host, int port) -> None - Constructor that initializes the client with server address\n- start() -> void - Starts the client thread if not already running\n- put(Packet packet) -> boolean - Adds a packet to the send queue (non-blocking)\n- clear() -> void - Clears all pending packets from the queue\n- run() -> void - Main thread method that handles connection and I/O operations (internal to ClientThread)\n- write() -> void - Handles packet writing to the channel with checksum calculation (internal to ClientThread)",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.zip.Adler32;\nimport java.util.zip.Checksum;\n\npublic class ClientController {\n\n    private BlockingQueue<Packet> inner = new LinkedBlockingQueue<>(100);\n    private Object lock = new Object();\n    private InetSocketAddress remote;\n    private Thread thread = new ClientThread(remote);\n\n    public ClientController(String host, int port) {\n        remote = new InetSocketAddress(host, port);\n    }\n\n    public void start() {\n        if (thread.isAlive() || remote == null) {\n            return;\n        }\n        synchronized (lock) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        inner.clear();\n    }\n\n    class ClientThread extends Thread {\n        SocketAddress remote;\n        SocketChannel channel;\n\n        ClientThread(SocketAddress remote) {\n            this.remote = remote;\n        }\n\n        @Override\n        public void run() {\n            try {\n                channel = SocketChannel.open();\n                channel.configureBlocking(false);\n                boolean isSuccess = channel.connect(new InetSocketAddress(30008));\n                if (!isSuccess) {\n                    while (!channel.finishConnect()) {\n                        System.out.println(\"Client is connecting...\");\n                    }\n                }\n                System.out.println(\"Client is connected.\");\n\n                Selector selector = Selector.open();\n                channel.register(selector, SelectionKey.OP_WRITE);\n                while (selector.isOpen()) {\n                    selector.select();\n                    Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n                    while (it.hasNext()) {\n                        SelectionKey key = it.next();\n                        it.remove();\n                        if (!key.isValid()) {\n                            continue;\n                        }\n                        if (key.isWritable()) {\n                            write();\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                if (channel != null) {\n                    try {\n                        channel.close();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n                inner.clear();\n            }\n        }\n\n        private void write() throws Exception {\n            Packet packet = inner.take();\n            synchronized (lock) {\n                ByteBuffer body = packet.getBuffer();\n                ByteBuffer head = ByteBuffer.allocate(4);\n                head.putInt(body.limit());\n                head.flip();\n                while (head.hasRemaining()) {\n                    channel.write(head);\n                }\n\n                Checksum checksum = new Adler32();\n                while (body.hasRemaining()) {\n                    checksum.update(body.get());\n                }\n\n                body.rewind();\n                while (body.hasRemaining()) {\n                    channel.write(body);\n                }\n\n                long cks = checksum.getValue();\n                ByteBuffer tail = ByteBuffer.allocate(8);\n                tail.putLong(cks);\n                tail.flip();\n                while (tail.hasRemaining()) {\n                    channel.write(tail);\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 6,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class ClientController {\n    private final BlockingQueue<Packet> inner;\n    private final Object lock;\n    private final InetSocketAddress remote;\n    private final Thread thread;\n    private SocketChannel channel;\n\n    public ClientController(String host, int port) {\n        this.remote = new InetSocketAddress(host, port);\n        this.inner = new LinkedBlockingQueue<>();\n        this.lock = new Object();\n        this.thread = new Thread(this::run);\n    }\n\n    public void start() {\n        if (!thread.isAlive()) {\n            thread.start();\n        }\n    }\n\n    public boolean put(Packet packet) {\n        return inner.offer(packet);\n    }\n\n    public void clear() {\n        synchronized (lock) {\n            inner.clear();\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            channel = SocketChannel.open();\n            channel.configureBlocking(false);\n            if (!channel.connect(remote)) {\n                while (!channel.finishConnect()) {\n                    Thread.sleep(100);\n                }\n            }\n            Selector selector = Selector.open();\n            channel.register(selector, SelectionKey.OP_WRITE);\n            while (true) {\n                selector.select();\n                Set<SelectionKey> keys = selector.selectedKeys();\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    if (key.isWritable()) {\n                        write();\n                    }\n                    iter.remove();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (channel != null) {\n                    channel.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void write() {\n        synchronized (lock) {\n            while (!inner.isEmpty()) {\n                Packet packet = inner.poll();\n                if (packet == null) break;\n                byte[] data = packet.getData();\n                int checksum = computeChecksum(data);\n                byte[] sendData = new byte[data.length + 4];\n                System.arraycopy(data, 0, sendData, 0, data.length);\n                ByteBuffer bb = ByteBuffer.allocate(4);\n                bb.putInt(checksum);\n                bb.flip();\n                System.arraycopy(bb.array(), 0, sendData, data.length, 4);\n                try {\n                    int bytesSent = channel.write(ByteBuffer.wrap(sendData));\n                    if (bytesSent == 0) {\n                        break;\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    break;\n                }\n            }\n        }\n    }\n\n    private int computeChecksum(byte[] data) {\n        int sum = 0;\n        for (byte b : data) {\n            sum += b & 0xFF;\n        }\n        return sum & 0xFF;\n    }\n}"
  },
  {
    "Task_id": 436,
    "Instruction": "Task Description: Implement a TCP server using Apache MINA framework in Java that handles incoming connections, processes messages, and manages server lifecycle operations.\n\nClass Description: MinaRemotingServer is a concrete implementation of AbstractRemotingServer that uses Apache MINA for TCP communication. It handles server initialization, message processing, and shutdown procedures.\n\nAttributes:\n- acceptor: [IoAcceptor] - The MINA IO acceptor that manages socket connections\n- bindAddress: [InetSocketAddress] - The address and port the server binds to\n\nMethods:\n- serverStart() -> [void] - Initializes and starts the MINA TCP server by:\n  1. Creating a NioSocketAcceptor\n  2. Adding protocol codec and MDC injection filters\n  3. Setting the connection handler\n  4. Configuring session timeouts\n  5. Binding to the specified port\n  Throws RemotingException if startup fails\n\n- serverShutdown() -> [void] - Stops the server by:\n  1. Unbinding from the port\n  2. Disposing of the acceptor resources\n  Throws RemotingException if shutdown fails\n\n- MinaRemotingServer([RemotingServerConfig]) -> [void] - Constructor that initializes with server configuration\n- MinaRemotingServer([RemotingServerConfig], [ChannelEventListener]) -> [void] - Constructor that initializes with both server configuration and channel event listener",
    "Canonical_solution": "import com.github.ltsopensource.remoting.AbstractRemotingServer;\nimport com.github.ltsopensource.remoting.ChannelEventListener;\nimport com.github.ltsopensource.remoting.RemotingServerConfig;\nimport com.github.ltsopensource.remoting.exception.RemotingException;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.logging.MdcInjectionFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig) {\n        this(remotingServerConfig, null);\n    }\n\n    public MinaRemotingServer(RemotingServerConfig remotingServerConfig, ChannelEventListener channelEventListener) {\n        super(remotingServerConfig, channelEventListener);\n    }\n\n    @Override\n    protected void serverStart() throws RemotingException {\n        acceptor = new NioSocketAcceptor();\n        acceptor.getFilterChain().addLast(\"codec\", new ProtocolCodecFilter(new MinaCodecFactory(getCodec())));\n        acceptor.getFilterChain().addLast(\"mdc\", new MdcInjectionFilter());\n        acceptor.setHandler(new MinaHandler(this));\n        IoSessionConfig cfg = acceptor.getSessionConfig();\n        cfg.setReaderIdleTime(remotingServerConfig.getReaderIdleTimeSeconds());\n        cfg.setWriterIdleTime(remotingServerConfig.getWriterIdleTimeSeconds());\n        cfg.setBothIdleTime(remotingServerConfig.getServerChannelMaxIdleTimeSeconds());\n\n        bindAddress = new InetSocketAddress(remotingServerConfig.getListenPort());\n        try {\n            acceptor.bind(bindAddress);\n        } catch (IOException e) {\n            throw new RemotingException(\"Start Mina server error\", e);\n        }\n    }\n\n    @Override\n    protected void serverShutdown() throws RemotingException {\n        if (acceptor != null) {\n            acceptor.unbind(bindAddress);\n            acceptor.dispose();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 11,
    "right_result": "import org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.core.session.IoSession;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport org.apache.mina.filter.codec.textline.TextLineCodecFactory;\nimport org.apache.mina.filter.mdc.MdcInjectionFilter;\nimport org.apache.mina.transport.socket.nio.NioSocketAcceptor;\nimport org.apache.mina.core.session.IdleStatus;\nimport org.apache.mina.core.session.IoSessionConfig;\nimport org.apache.mina.core.filterchain.IoFilterChain;\nimport org.apache.mina.core.service.IoHandlerAdapter;\nimport java.net.InetSocketAddress;\n\npublic class MinaRemotingServer extends AbstractRemotingServer {\n    private IoAcceptor acceptor;\n    private InetSocketAddress bindAddress;\n    private ChannelEventListener channelEventListener;\n\n    public MinaRemotingServer(RemotingServerConfig config) {\n        this.bindAddress = new InetSocketAddress(config.getPort());\n    }\n\n    public MinaRemotingServer(RemotingServerConfig config, ChannelEventListener listener) {\n        this(config);\n        this.channelEventListener = listener;\n    }\n\n    @Override\n    public void serverStart() throws RemotingException {\n        try {\n            acceptor = new NioSocketAcceptor();\n            IoFilterChain filterChain = acceptor.getFilterChain();\n            filterChain.addLast(\"codec\", new ProtocolCodecFilter(new TextLineCodecFactory()));\n            filterChain.addLast(\"mdc\", new MdcInjectionFilter());\n            \n            acceptor.setHandler(new IoHandlerAdapter() {\n                @Override\n                public void channelOpened(IoSession session) throws Exception {\n                    if (channelEventListener != null) {\n                        channelEventListener.onChannelOpen(session);\n                    }\n                }\n\n                @Override\n                public void messageReceived(IoSession session, Object message) throws Exception {\n                    if (channelEventListener != null) {\n                        channelEventListener.onMessageReceived(session, message);\n                    }\n                }\n\n                @Override\n                public void sessionClosed(IoSession session) throws Exception {\n                    if (channelEventListener != null) {\n                        channelEventListener.onSessionClose(session);\n                    }\n                }\n            });\n            \n            IoSessionConfig sessionConfig = acceptor.getSessionConfig();\n            sessionConfig.setIdleTime(IdleStatus.BOTH_IDLE, 60); // 60 seconds\n            \n            acceptor.bind(bindAddress);\n        } catch (Exception e) {\n            throw new RemotingException(\"Failed to start Mina server\", e);\n        }\n    }\n\n    @Override\n    public void serverShutdown() throws RemotingException {\n        try {\n            if (acceptor != null) {\n                acceptor.unbind();\n                acceptor.dispose();\n                acceptor = null;\n            }\n        } catch (Exception e) {\n            throw new RemotingException(\"Failed to shutdown Mina server\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 441,
    "Instruction": "Task Description: Implement a Unix domain socket-based IPC server using Java NIO that can listen for incoming messages and send responses asynchronously.\n\nClass Description: The Server class implements an IPC communicator that establishes a Unix domain socket server. It handles client connections asynchronously, processes incoming messages through a listener callback, and sends responses. The server manages its socket resources and cleans up the socket file on termination.\n\nAttributes:\n- serverSocketChannel: [ServerSocketChannel] - The NIO channel for accepting client connections on the Unix domain socket\n- socketPath: [Path] - Filesystem path where the Unix domain socket is created\n- LOG: [Logger] - Logger instance for recording server events and errors\n\nMethods:\n- create: [static](Path socketPath) -> [Server] - Factory method that creates and binds a Unix domain socket server at the specified path. Throws IOException if binding fails.\n- isClient: []() -> [boolean] - Returns false indicating this is a server-side communicator (always returns false for Server instances)\n- listen: [](IpcMessageListener listener, Executor executor) -> [void] - Starts listening for incoming messages asynchronously using the provided executor. Each message is delivered to the listener callback.\n- send: [](IpcMessage message, Executor executor) -> [void] - Sends a message to a connected client asynchronously using the provided executor.\n- close: []() -> [void] - Closes the server socket channel and deletes the socket file. Throws IOException if cleanup fails.",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.net.StandardProtocolFamily;\nimport java.net.UnixDomainSocketAddress;\nimport java.nio.channels.AlreadyBoundException;\nimport java.nio.channels.AsynchronousCloseException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.concurrent.Executor;\n\nclass Server implements IpcCommunicator {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Server.class);\n\n\tprivate final ServerSocketChannel serverSocketChannel;\n\tprivate final Path socketPath;\n\n\tprivate Server(ServerSocketChannel serverSocketChannel, Path socketPath) {\n\t\tthis.serverSocketChannel = serverSocketChannel;\n\t\tthis.socketPath = socketPath;\n\t}\n\n\tpublic static Server create(Path socketPath) throws IOException {\n\t\tFiles.createDirectories(socketPath.getParent());\n\t\tvar address = UnixDomainSocketAddress.of(socketPath);\n\t\tServerSocketChannel ch = null;\n\t\ttry {\n\t\t\tch = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n\t\t\tch.bind(address);\n\t\t\tLOG.info(\"Spawning IPC server listening on socket {}\", socketPath);\n\t\t\treturn new Server(ch, socketPath);\n\t\t} catch (IOException | AlreadyBoundException | UnsupportedAddressTypeException e) {\n\t\t\tif (ch != null) {\n\t\t\t\tch.close();\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isClient() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void listen(IpcMessageListener listener, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\twhile (serverSocketChannel.isOpen()) {\n\t\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\t\twhile (ch.isConnected()) {\n\t\t\t\t\t\tvar msg = IpcMessage.receive(ch);\n\t\t\t\t\t\tlistener.handleMessage(msg);\n\t\t\t\t\t}\n\t\t\t\t} catch (AsynchronousCloseException e) {\n\t\t\t\t\treturn;\n\t\t\t\t} catch (EOFException | ClosedChannelException e) {\n\t\t\t\t\t// continue with next connected client\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOG.error(\"Failed to read IPC message\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void send(IpcMessage message, Executor executor) {\n\t\texecutor.execute(() -> {\n\t\t\ttry (var ch = serverSocketChannel.accept()) {\n\t\t\t\tmessage.send(ch);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(\"Failed to send IPC message\", e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\ttry {\n\t\t\tserverSocketChannel.close();\n\t\t} finally {\n\t\t\tFiles.deleteIfExists(socketPath);\n\t\t\tLOG.debug(\"IPC server closed\");\n\t\t}\n\t}\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 7,
    "right_result": "import java.io.IOException;\nimport java.nio.channels.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.concurrent.Executor;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Server {\n    private final ServerSocketChannel serverSocketChannel;\n    private final Path socketPath;\n    private final Logger LOG;\n\n    public Server() {\n        this.LOG = Logger.getLogger(Server.class.getName());\n    }\n\n    public static Server create(Path socketPath) throws IOException {\n        Server server = new Server();\n        server.socketPath = socketPath;\n        server.serverSocketChannel = ServerSocketChannel.open();\n        server.serverSocketChannel.configureBlocking(false);\n        UnixDomainSocketAddress address = UnixDomainSocketAddress.create(socketPath);\n        server.serverSocketChannel.bind(address);\n        return server;\n    }\n\n    public boolean isClient() {\n        return false;\n    }\n\n    public void listen(IpcMessageListener listener, Executor executor) {\n        try {\n            Selector selector = Selector.open();\n            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                selector.select();\n                Set<SelectionKey> keys = selector.selectedKeys();\n                Iterator<SelectionKey> it = keys.iterator();\n\n                while (it.hasNext()) {\n                    SelectionKey key = it.next();\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n                        SocketChannel clientChannel = serverChannel.accept();\n                        clientChannel.configureBlocking(false);\n                        clientChannel.register(selector, SelectionKey.OP_READ);\n                    } else if (key.isReadable()) {\n                        SocketChannel clientChannel = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(1024);\n                        int bytesRead = clientChannel.read(buffer);\n                        if (bytesRead > 0) {\n                            buffer.flip();\n                            byte[] data = new byte[bytesRead];\n                            buffer.get(data);\n                            IpcMessage message = parseMessage(data);\n                            executor.execute(() -> listener.onMessage(message));\n                            buffer.clear();\n                        }\n                    }\n                    it.remove();\n                }\n            }\n        } catch (IOException e) {\n            LOG.log(Level.SEVERE, \"Error in selector\", e);\n        }\n    }\n\n    public void send(IpcMessage message, Executor executor) {\n        // Implementation requires tracking connected clients\n        // This is a placeholder for demonstration\n    }\n\n    public void close() throws IOException {\n        if (serverSocketChannel != null) {\n            serverSocketChannel.close();\n        }\n        if (Files.exists(socketPath)) {\n            Files.delete(socketPath);\n        }\n    }\n\n    private IpcMessage parseMessage(byte[] data) {\n        // Placeholder for message parsing logic\n        return new IpcMessage(data);\n    }\n}"
  },
  {
    "Task_id": 445,
    "Instruction": "Task Description: Implement a Java class for UDP-based communication with OpenTracker for live synchronization of peer information using Java NIO's non-blocking DatagramChannel.\n\nClass Description: The OpentrackerLiveSync class handles UDP communication with an OpenTracker server for peer synchronization. It uses non-blocking I/O to send peer information packets to a multicast group. The class maintains a queue of outgoing messages and processes them in batches.\n\nAttributes:\n- toSend: TransferQueue<ByteBuffer> - Thread-safe queue holding outgoing peer information packets\n- channel: DatagramChannel - The UDP communication channel for sending data\n- id: byte[] - 4-byte random identifier for this client\n- running: volatile boolean - Flag controlling the operation of the sender thread\n- HEADER_LENGTH: static final int - Constant for header size (8 bytes)\n- PEER_LENGTH: static final int - Constant for peer information size (28 bytes)\n- PEERS_PER_PACKET: static final int - Constant for maximum peers per packet (50)\n\nMethods:\n- OpentrackerLiveSync() -> None - Constructor initializes random client ID\n- start() -> None - Initializes UDP channel and starts sender thread\n- incomingPacket(MessageBase msg) -> None - Processes incoming messages and queues valid peer requests\n- send() -> None - Worker method that sends batched peer information packets\n- stop() -> None - Stops the sender thread and closes the channel\n\nInput Parameters for Methods:\n- incomingPacket: msg [MessageBase] - The incoming message to process\n- (Other methods take no explicit parameters)\n\nOutput/Return Values:\n- All methods return void except the constructor\n- Methods primarily affect class state and perform I/O operations",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.Inet4Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.StandardProtocolFamily;\nimport java.net.StandardSocketOptions;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.util.concurrent.LinkedTransferQueue;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TransferQueue;\n\npublic class OpentrackerLiveSync {\n\n    TransferQueue<ByteBuffer> toSend = new LinkedTransferQueue<>();\n    DatagramChannel channel;\n    byte[] id = new byte[4];\n    volatile boolean running = true;\n    \n    private static final int HEADER_LENGTH = 0x08;\n    private static final int PEER_LENGTH = 0x1C;\n    private static final int PEERS_PER_PACKET = 50;\n    \n    public OpentrackerLiveSync() {\n        ThreadLocalRandom.current().nextBytes(id);\n    }\n    \n    public void start() {\n        try {\n            channel = DatagramChannel.open(StandardProtocolFamily.INET);\n            channel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, 1);\n            channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n            channel.bind(new InetSocketAddress(0));\n            channel.connect(new InetSocketAddress(InetAddress.getByAddress(new byte[] {(byte) 224,0,23,5}), 9696));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        \n        Thread t = new Thread(this::send);\n        t.setDaemon(true);\n        t.setName(\"opentracker-sync\");\n        t.start();\n    }\n    \n    public void incomingPacket(MessageBase msg) {\n        if(!running)\n            return;\n        if(msg.getType() != MessageBase.Type.REQ_MSG || msg.getMethod() != MessageBase.Method.GET_PEERS)\n            return;\n        \n        GetPeersRequest req = (GetPeersRequest) msg;\n        \n        ByteBuffer buf = ByteBuffer.allocate(PEER_LENGTH);\n        buf.put(req.getTarget().getHash());\n        buf.put(req.getOrigin().getAddress().getAddress());\n        buf.putShort((short) req.getOrigin().getPort());\n        buf.putShort((short) 0);\n        buf.flip();\n        toSend.add(buf);\n    }\n    \n    void send() {\n        ByteBuffer sendBuffer = ByteBuffer.allocate(HEADER_LENGTH);\n        sendBuffer.put(id);\n        sendBuffer.put(new byte[4]);\n        sendBuffer.flip();\n        \n        ByteBuffer[] buffers = new ByteBuffer[1 + PEERS_PER_PACKET];\n        buffers[0] = sendBuffer;\n\n        try {\n            while(running) {\n                for(int i = 1;i<buffers.length;i++) {\n                    buffers[i] = toSend.take();\n                }\n                \n                channel.write(buffers);\n                buffers[0].rewind();\n            }\n        } catch (IOException | InterruptedException e) {\n            running = false;\n            e.printStackTrace();\n        }\n    }\n\n    public void stop() {\n        running = false;\n        try {\n            channel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.concurrent.LinkedTransferQueue;\nimport java.util.concurrent.TransferQueue;\nimport java.security.SecureRandom;\n\npublic class OpentrackerLiveSync {\n    private final TransferQueue<ByteBuffer> toSend = new LinkedTransferQueue<>();\n    private DatagramChannel channel;\n    private final byte[] id;\n    private volatile boolean running;\n    public static final int HEADER_LENGTH = 8;\n    public static final int PEER_LENGTH = 28;\n    public static final int PEERS_PER_PACKET = 50;\n\n    public OpentrackerLiveSync() {\n        SecureRandom random = new SecureRandom();\n        id = new byte[4];\n        random.nextBytes(id);\n    }\n\n    public void start() throws IOException {\n        channel = DatagramChannel.open();\n        channel.configureBlocking(false);\n        channel.socket().bind(new InetSocketAddress(0));\n        running = true;\n        new Thread(this::send).start();\n    }\n\n    public void incomingPacket(MessageBase msg) {\n        if (msg != null && msg.isRequest()) {\n            ByteBuffer buffer = ByteBuffer.allocate(HEADER_LENGTH + PEER_LENGTH * PEERS_PER_PACKET);\n            buffer.put(id);\n            for (int i = 0; i < PEERS_PER_PACKET; i++) {\n                buffer.putLong(0L); // placeholder peer data\n            }\n            buffer.flip();\n            toSend.transfer(buffer);\n        }\n    }\n\n    private void send() {\n        while (running) {\n            ByteBuffer buffer = toSend.poll();\n            if (buffer != null) {\n                try {\n                    channel.send(buffer, new InetSocketAddress(\"224.0.0.1\", 6343));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void stop() {\n        running = false;\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 448,
    "Instruction": "Task Description: Implement a Java class for multicast UDP communication using Java NIO's DatagramChannel for both sending and receiving messages in a non-blocking manner.\n\nClass Description: The MulticastUDP class provides functionality for joining a multicast group, sending messages to specified targets, receiving messages from the group, and closing the communication channel. It utilizes Java NIO's non-blocking capabilities for efficient UDP communication.\n\nAttributes:\n- channel: DatagramChannel - The NIO channel used for UDP communication  \n- group: InetAddress - The multicast group address  \n- port: int - The port number for multicast communication  \n\nMethods:\n- MulticastUDP(String host, int port) -> void - Constructor that initializes the multicast group address and port, and opens a DatagramChannel  \n- joinGroup() -> void - Binds the channel to the specified port and joins the multicast group  \n- receive() -> String - Receives a message from the multicast group and returns it as a String  \n- send(String message, String targetHost, int targetPort) -> void - Sends a message to a specified target host and port  \n- close() -> void - Closes the DatagramChannel to release resources",
    "Canonical_solution": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.net.StandardProtocolFamily;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\n\npublic final class MulticastUDP {\n\n    private DatagramChannel channel;\n    private InetAddress group;\n    private int port;\n\n    public MulticastUDP(String host, int port) throws Exception {\n        this.group = InetAddress.getByName(host);\n        this.port = port;\n        this.channel = DatagramChannel.open(StandardProtocolFamily.INET);\n    }\n\n    public void joinGroup() throws Exception {\n        channel.bind(new InetSocketAddress(port));\n        channel.join(group, Utils.getLocalNetworkInterface());\n    }\n\n    public String receive() throws Exception {\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        SocketAddress sender = channel.receive(buffer);\n        buffer.flip();\n        byte[] data = new byte[buffer.remaining()];\n        buffer.get(data);\n        return new String(data);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws Exception {\n        channel.configureBlocking(true);\n        InetSocketAddress sender = new InetSocketAddress(targetHost, targetPort);\n        channel.send(ByteBuffer.wrap(message.getBytes()), sender);\n    }\n\n    public void close() throws Exception {\n        channel.close();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 8,
    "right_result": "import java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.DatagramChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.charset.StandardCharsets;\nimport java.io.IOException;\n\npublic class MulticastUDP {\n    private DatagramChannel channel;\n    private InetAddress group;\n    private int port;\n\n    public MulticastUDP(String host, int port) throws IOException {\n        this.group = InetAddress.getByName(host);\n        this.port = port;\n        this.channel = DatagramChannel.open();\n        this.channel.configureBlocking(false);\n    }\n\n    public void joinGroup() throws IOException {\n        channel.bind(new InetSocketAddress(port));\n        channel.joinGroup(new InetSocketAddress(group, 0), null);\n    }\n\n    public String receive() throws IOException {\n        ByteBuffer buffer = ByteBuffer.allocate(65536);\n        int bytesRead = channel.receive(buffer);\n        if (bytesRead == -1) {\n            return \"\";\n        }\n        buffer.flip();\n        byte[] data = new byte[bytesRead];\n        buffer.get(data, 0, bytesRead);\n        return new String(data, StandardCharsets.UTF_8);\n    }\n\n    public void send(String message, String targetHost, int targetPort) throws IOException {\n        ByteBuffer buffer = ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));\n        channel.send(buffer, new InetSocketAddress(targetHost, targetPort));\n    }\n\n    public void close() throws IOException {\n        if (channel != null) {\n            channel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 452,
    "Instruction": "Task Description: Create a Java class that implements UDP communication using Vert.x, allowing for the initialization of a UDP socket, sending UDP packets, and closing the socket.\n\nClass Description: The UdpSender class provides functionality for sending UDP packets using Vert.x's DatagramSocket. It supports socket configuration, packet transmission, and socket cleanup.\n\nAttributes:\n\nAttribute1: socket [DatagramSocket] - The Vert.x DatagramSocket instance used for UDP communication.\nAttribute2: vertx [Vertx] - The Vert.x instance used to create the DatagramSocket.\n\nMethods:\n\nMethod1: initialize(DatagramSocketOptions options) -> void - Initializes the UDP socket with the specified configuration options.\nMethod2: sendPacket(Buffer data, int port, String host, Handler<AsyncResult<Void>> resultHandler) -> void - Sends a UDP packet containing the specified data to the given host and port, with an optional handler to track the send operation's success or failure.\nMethod3: close(Handler<AsyncResult<Void>> closeHandler) -> void - Closes the UDP socket, with an optional handler to track the close operation's completion.",
    "Canonical_solution": "import io.vertx.core.*;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\n\npublic class UdpSender {\n\n    private DatagramSocket socket;\n    private Vertx vertx;\n\n    public UdpSender(Vertx vertx) {\n        this.vertx = vertx;\n    }\n\n    public void initialize(DatagramSocketOptions options) {\n        socket = vertx.createDatagramSocket(options);\n    }\n\n    public void sendPacket(Buffer data, int port, String host, Handler<AsyncResult<Void>> resultHandler) {\n        socket.send(data, port, host).onComplete(resultHandler);\n    }\n\n    public void close(Handler<AsyncResult<Void>> closeHandler) {\n        if (socket != null) {\n            socket.close().onComplete(closeHandler);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 14,
    "right_result": "import io.vertx.core.Vertx;\nimport io.vertx.core.datagram.DatagramSocket;\nimport io.vertx.core.datagram.DatagramSocketOptions;\nimport io.vertx.core.buffer.Buffer;\nimport io.vertx.core.Handler;\nimport io.vertx.core.AsyncResult;\n\npublic class UdpSender {\n    private DatagramSocket socket;\n    private Vertx vertx;\n\n    public UdpSender(Vertx vertx) {\n        this.vertx = vertx;\n    }\n\n    public void initialize(DatagramSocketOptions options) {\n        socket = vertx.createDatagramSocket(options);\n    }\n\n    public void sendPacket(Buffer data, int port, String host, Handler<AsyncResult<Void>> resultHandler) {\n        socket.send(data, port, host, resultHandler);\n    }\n\n    public void close(Handler<AsyncResult<Void>> closeHandler) {\n        socket.close(closeHandler);\n    }\n}"
  },
  {
    "Task_id": 454,
    "Instruction": "Task Description: Retrieve the configurations of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: This function connects to a Kafka cluster using the provided bootstrap servers and retrieves the configurations for the specified topic names. It utilizes the Kafka AdminClient to describe the configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.\n- topicNames: [String[]] - Array of topic names for which configurations need to be retrieved.\n\nOutput: \n- [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration entries for each topic. The operation will timeout after 3 seconds if the configuration retrieval is not completed.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.ConfigResource;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport java.util.Properties;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\nimport java.util.Map;\n\npublic class KafkaConfigRetriever {\n    public static Map<ConfigResource, Config> getTopicConfigurations(String bootstrapServers, String[] topicNames) {\n        Properties props = new Properties();\n        props.put(\"bootstrap.servers\", bootstrapServers);\n        try (AdminClient adminClient = AdminClient.create(props)) {\n            var resources = Arrays.stream(topicNames)\n                .map(name -> new ConfigResource(ConfigResource.Type.TOPIC, name))\n                .collect(Collectors.toList());\n            var result = adminClient.describeConfigs(resources).timeout(3000);\n            return result.all().get();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve configurations\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 455,
    "Instruction": "Task Description: Write a function that retrieves the configuration details of specified Kafka topics using the Kafka AdminClient API.\n\nFunction Description: The function connects to a Kafka cluster using the provided bootstrap servers, then fetches and returns the configuration details for each specified topic name. It utilizes Kafka's AdminClient to describe topic configurations and returns them as a map of ConfigResource to Config objects.\n\nInput: \n- bootstrapServers: [String] - Comma-separated list of host:port pairs for establishing the initial connection to the Kafka cluster\n- topicNames: [String[]] - Array of topic names whose configurations need to be retrieved\n\nOutput: \n- Returns [Map<ConfigResource, Config>] - A map where keys are ConfigResource objects representing the topics, and values are Config objects containing the configuration details for each topic\n- Throws [Exception] - If there's any error during the configuration retrieval process or if the operation times out",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\nimport java.util.concurrent.TimeUnit;\n\npublic Map<ConfigResource, Config> getKafkaTopicConfigs(String bootstrapServers, String[] topicNames) throws Exception {\n    Map<String, Object> adminClientConfig = new HashMap<>();\n    adminClientConfig.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminClientConfig);\n    \n    ConfigResource[] configResources = Arrays.stream(topicNames)\n        .map(topicName -> new ConfigResource(ConfigResource.Type.TOPIC, topicName))\n        .toArray(ConfigResource[]::new);\n        \n    DescribeConfigsResult describeConfigsResult = adminClient.describeConfigs(Arrays.asList(configResources));\n    return describeConfigsResult.all().get(3, TimeUnit.SECONDS);\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 36,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.ConfigResource;\nimport org.apache.kafka.clients.admin.ConfigResourceType;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaConfigFetcher {\n    public static Map<ConfigResource, Config> getTopicConfigs(String bootstrapServers, String[] topicNames) throws Exception {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        try (AdminClient adminClient = AdminClient.create(props)) {\n            List<ConfigResource> configResources = new ArrayList<>();\n            for (String topic : topicNames) {\n                configResources.add(new ConfigResource(ConfigResourceType.TOPIC, topic));\n            }\n            DescribeConfigsResult result = adminClient.describeConfigs(configResources);\n            return result.all().get();\n        } catch (ExecutionException | InterruptedException e) {\n            throw new Exception(\"Error retrieving topic configurations\", e);\n        }\n    }\n}"
  },
  {
    "Task_id": 456,
    "Instruction": "Task Description: Create a Java class that provides administrative operations for Kafka topics, including retrieving configurations for individual topics, multiple topics, and all topics in a Kafka cluster.\n\nClass Description: The KafkaAdminTopicConfigProvider class is designed to interact with Kafka's AdminClient to perform topic configuration operations. It provides methods to fetch topic configurations either for a single topic, a set of topics, or all topics in the cluster. The class handles timeouts and errors gracefully and converts Kafka Config objects into standard Java Properties objects.\n\nAttributes:\n- _clusterConfigs: [Properties] - Stores configuration properties for the Kafka cluster\n- _adminClient: [AdminClient] - The Kafka AdminClient instance used to perform administrative operations\n- DESCRIBE_CLUSTER_CONFIGS_TIMEOUT: [Duration] - Constant defining the timeout duration for describeConfigs operations (90 seconds)\n- LOG: [Logger] - Logger instance for logging debug and warning messages\n\nMethods:\n- topicConfigs: [String topic] -> [Properties] - Retrieves configuration properties for a single specified topic. Returns empty Properties if retrieval fails.\n- topicConfigs: [Set<String> topics] -> [Map<String, Properties>] - Retrieves configurations for multiple topics specified in the input set. Returns a map of topic names to their configurations.\n- allTopicConfigs: [] -> [Map<String, Properties>] - Retrieves configurations for all topics in the Kafka cluster. Returns an empty map if retrieval fails.\n- convertConfigToProperties: [Config config] -> [Properties] - Helper method that converts a Kafka Config object into a Java Properties object, filtering out null entries.",
    "Canonical_solution": "import java.time.Duration;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.stream.Collectors;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.ConfigEntry;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KafkaAdminTopicConfigProvider {\n  private static final Logger LOG = LoggerFactory.getLogger(KafkaAdminTopicConfigProvider.class);\n  public static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n  protected Properties _clusterConfigs;\n  protected AdminClient _adminClient;\n\n  public Properties topicConfigs(String topic) {\n    Config topicConfig = null;\n    ConfigResource topicResource = new ConfigResource(ConfigResource.Type.TOPIC, topic);\n    try {\n      LOG.debug(\"Requesting details for topic '{}'\", topic);\n      topicConfig = _adminClient\n              .describeConfigs(Collections.singletonList(topicResource))\n              .all()\n              .get()\n              .get(topicResource);\n    } catch (ExecutionException ee) {\n      if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n        LOG.warn(\"Failed to retrieve configuration for topic '{}' due to describeConfigs request time out.\", topic);\n      } else {\n        LOG.warn(\"Cannot retrieve configuration for topic '{}'.\", topic, ee);\n      }\n    } catch (InterruptedException ie) {\n      LOG.debug(\"Interrupted while getting configuration for topic '{}'.\", topic, ie);\n    }\n\n    if (topicConfig != null) {\n      return convertConfigToProperties(topicConfig);\n    } else {\n      LOG.warn(\"The configuration for topic '{}' could not be retrieved, returning empty Properties instance.\", topic);\n      return new Properties();\n    }\n  }\n\n  public Map<String, Properties> topicConfigs(Set<String> topics) {\n    Map<ConfigResource, KafkaFuture<Config>> topicConfigs;\n    topicConfigs = _adminClient.describeConfigs(\n            topics.stream().map(name -> new ConfigResource(ConfigResource.Type.TOPIC, name)).collect(Collectors.toList())\n    ).values();\n\n    Map<String, Properties> propsMap = new HashMap<>();\n    if (topicConfigs != null) {\n      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : topicConfigs.entrySet()) {\n        try {\n          Config config = entry.getValue().get();\n          propsMap.put(entry.getKey().name(), convertConfigToProperties(config));\n        } catch (ExecutionException ee) {\n          if (Errors.REQUEST_TIMED_OUT.exception().getClass() == ee.getCause().getClass()) {\n            LOG.warn(\"Failed to retrieve config for topics due to describeConfigs request timing out.\");\n            break;\n          } else {\n            LOG.debug(\"Cannot retrieve config for topic {}.\", entry.getKey().name(), ee);\n          }\n        } catch (InterruptedException ie) {\n          LOG.debug(\"Interrupted while getting config for topic {}.\", entry.getKey().name(), ie);\n        }\n      }\n    }\n    return propsMap;\n  }\n\n  public Map<String, Properties> allTopicConfigs() {\n    LOG.debug(\"Requesting configurations for all topics\");\n    Set<String> topicNames = null;\n    try {\n      topicNames = _adminClient.listTopics().names().get();\n    } catch (InterruptedException | ExecutionException e) {\n      LOG.warn(\"Unable to obtain list of all topic names from the Kafka Cluster\");\n    }\n\n    if (topicNames == null) {\n      return Collections.emptyMap();\n    } else {\n      return topicConfigs(topicNames);\n    }\n  }\n\n  protected static Properties convertConfigToProperties(Config config) {\n    Properties props = new Properties();\n    for (ConfigEntry entry : config.entries()) {\n      if (entry.name() == null || entry.value() == null) {\n        continue;\n      }\n      props.put(entry.name(), entry.value());\n    }\n    return props;\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 35,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.Config;\nimport org.apache.kafka.clients.admin.DescribeConfigsResult;\nimport org.apache.kafka.clients.admin.ListTopicsResult;\nimport org.apache.kafka.common.config.ConfigResource;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\nimport java.util.Properties;\n\npublic class KafkaAdminTopicConfigProvider {\n    private final AdminClient _adminClient;\n    private final Properties _clusterConfigs;\n    private static final Duration DESCRIBE_CLUSTER_CONFIGS_TIMEOUT = Duration.ofSeconds(90);\n    private final Logger LOG;\n\n    public KafkaAdminTopicConfigProvider(AdminClient adminClient) {\n        this._adminClient = adminClient;\n        this._clusterConfigs = new Properties();\n        this.LOG = Logger.getLogger(KafkaAdminTopicConfigProvider.class.getName());\n    }\n\n    public Properties topicConfigs(String topic) {\n        try {\n            List<ConfigResource> resources = Collections.singletonList(new ConfigResource(ConfigResource.Type.TOPIC, topic));\n            DescribeConfigsResult result = _adminClient.describeConfig(resources);\n            Config config = result.all().get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n            return convertConfigToProperties(config);\n        } catch (Exception e) {\n            LOG.warning(\"Failed to retrieve configuration for topic: \" + topic + \". Error: \" + e.getMessage());\n            return new Properties();\n        }\n    }\n\n    public Map<String, Properties> topicConfigs(Set<String> topics) {\n        try {\n            List<ConfigResource> configResources = topics.stream()\n                .map(topic -> new ConfigResource(ConfigResource.Type.TOPIC, topic))\n                .collect(Collectors.toList());\n            DescribeConfigsResult result = _adminClient.describeConfig(configResources);\n            Map<String, Properties> configMap = new HashMap<>();\n            for (ConfigResource resource : result.all().keySet()) {\n                Config config = result.all().get(resource);\n                Properties props = convertConfigToProperties(config);\n                configMap.put(resource.name(), props);\n            }\n            return configMap;\n        } catch (Exception e) {\n            LOG.warning(\"Failed to retrieve configurations for topics: \" + topics + \". Error: \" + e.getMessage());\n            return new HashMap<>();\n        }\n    }\n\n    public Map<String, Properties> allTopicConfigs() {\n        try {\n            ListTopicsResult listTopicsResult = _adminClient.listTopics();\n            Set<String> topics = listTopicsResult.names().get(DESCRIBE_CLUSTER_CONFIGS_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n            Map<String, Properties> result = new HashMap<>();\n            for (String topic : topics) {\n                Properties props = topicConfigs(topic);\n                result.put(topic, props);\n            }\n            return result;\n        } catch (Exception e) {\n            LOG.warning(\"Failed to retrieve all topic configurations. Error: \" + e.getMessage());\n            return new HashMap<>();\n        }\n    }\n\n    private Properties convertConfigToProperties(Config config) {\n        Properties props = new Properties();\n        for (ConfigEntry entry : config.entries()) {\n            if (entry.value() != null) {\n                props.put(entry.name(), entry.value());\n            }\n        }\n        return props;\n    }\n}"
  },
  {
    "Task_id": 459,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server and handle communication events.\n\nClass Description: The MyWebSocketClient class extends WebSocketClient to provide a custom WebSocket client implementation. It supports WebSocket communication with a server, including connection establishment, message exchange, and error handling. The class includes event handlers for WebSocket lifecycle events.\n\nAttributes:\n- perMessageDeflateDraft: [Draft] - A WebSocket draft implementation with Per-Message Deflate extension for message compression.\n\nMethods:\n- MyWebSocketClient: [Constructor](String serverUri) -> [void] - Initializes the WebSocket client with the server URI. Throws URISyntaxException if the URI is invalid.\n- onOpen: [void](ServerHandshake handshakedata) -> [void] - Callback invoked when the WebSocket connection is established.\n- onMessage: [void](String message) -> [void] - Callback invoked when a message is received from the server.\n- onClose: [void](int code, String reason, boolean remote) -> [void] - Callback invoked when the WebSocket connection is closed.\n- onError: [void](Exception ex) -> [void] - Callback invoked when an error occurs during WebSocket communication.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Collections;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.extensions.permessage_deflate.PerMessageDeflateExtension;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class MyWebSocketClient extends WebSocketClient {\n\n    private static final Draft perMessageDeflateDraft = new Draft_6455(\n        new PerMessageDeflateExtension());\n\n    public MyWebSocketClient(String serverUri) throws URISyntaxException {\n        super(new URI(serverUri), perMessageDeflateDraft);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft_14;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\npublic class MyWebSocketClient extends WebSocketClient {\n    private final Draft perMessageDeflateDraft;\n\n    public MyWebSocketClient(String serverUri) throws URISyntaxException {\n        super(new URI(serverUri), new Draft_14());\n        this.perMessageDeflateDraft = new Draft_14();\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}"
  },
  {
    "Task_id": 461,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a connection with a WebSocket server, send and receive messages, and handle connection events.\n\nClass Description: The ExampleClient class extends WebSocketClient to create a WebSocket client that connects to a specified server URI. It overrides key WebSocket event-handling methods to manage connection lifecycle events.\n\nAttributes:\n- Inherited from WebSocketClient: All necessary attributes for WebSocket connection management are inherited from the parent class.\n\nMethods:\n- Constructor: ExampleClient(URI serverUri, Draft draft) -> void - Initializes the WebSocket client with server URI and protocol draft.\n- Constructor: ExampleClient(URI serverURI) -> void - Initializes the WebSocket client with server URI using default draft.\n- Constructor: ExampleClient(URI serverUri, Map<String, String> httpHeaders) -> void - Initializes the WebSocket client with server URI and custom HTTP headers.\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when connection is established, sends a greeting message.\n- onMessage: onMessage(String message) -> void - Called when a message is received from the server.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the connection is closed, logs closure details.\n- onError: onError(Exception ex) -> void - Called when an error occurs, prints the stack trace.",
    "Canonical_solution": "import java.net.URI;\nimport java.util.Map;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class ExampleClient extends WebSocketClient {\n\n  public ExampleClient(URI serverUri, Draft draft) {\n    super(serverUri, draft);\n  }\n\n  public ExampleClient(URI serverURI) {\n    super(serverURI);\n  }\n\n  public ExampleClient(URI serverUri, Map<String, String> httpHeaders) {\n    super(serverUri, httpHeaders);\n  }\n\n  @Override\n  public void onOpen(ServerHandshake handshakedata) {\n    send(\"Hello, it is me. Mario :)\");\n    System.out.println(\"opened connection\");\n  }\n\n  @Override\n  public void onMessage(String message) {\n    System.out.println(\"received: \" + message);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    System.out.println(\n        \"Connection closed by \" + (remote ? \"remote peer\" : \"us\") + \" Code: \" + code + \" Reason: \"\n            + reason);\n  }\n\n  @Override\n  public void onError(Exception ex) {\n    ex.printStackTrace();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.java_websocket.drafts.Draft;\nimport java.net.URI;\nimport java.util.Map;\n\npublic class ExampleClient extends WebSocketClient {\n    public ExampleClient(URI serverUri, Draft draft) {\n        super(serverUri, draft);\n    }\n\n    public ExampleClient(URI serverURI) {\n        super(serverURI);\n    }\n\n    public ExampleClient(URI serverUri, Map<String, String> httpHeaders) {\n        super(serverUri, httpHeaders);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        send(\"Hello, Server!\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Closed: \" + code + \", \" + reason + \", \" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 462,
    "Instruction": "Task Description: Create a WebSocket client class that extends the basic WebSocketClient functionality to handle WebSocket communication with event callbacks and response streaming.\n\nClass Description: The MilkmanWebsocketClient class extends WebSocketClient to provide custom WebSocket client functionality. It handles WebSocket events (open, message, close, error) and streams responses to a subscriber while managing asynchronous request control.\n\nAttributes:\n- responseSubscriber: [Subscriber<byte[]>] - A subscriber that receives response data as byte arrays\n- asyncControl: [AsyncControl] - An asynchronous control object for managing request state and cancellation\n\nMethods:\n- MilkmanWebsocketClient([URI serverUri, Subscriber<byte[]> responseSubscriber, AsyncControl asyncControl]) -> [void] - Constructor that initializes the WebSocket client with server URI, response subscriber, and async control\n- onOpen([ServerHandshake handshakedata]) -> [void] - Callback when WebSocket connection is opened, triggers request ready\n- send([String message]) -> [void] - Sends a message through WebSocket and notifies subscriber of sent message\n- onMessage([String message]) -> [void] - Callback when message is received, notifies subscriber\n- onClose([int code, String reason, boolean remote]) -> [void] - Callback when WebSocket is closed, completes subscriber and marks request success\n- onError([Exception ex]) -> [void] - Callback when error occurs, notifies subscriber and marks request failure",
    "Canonical_solution": "import milkman.utils.AsyncResponseControl.AsyncControl;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport org.reactivestreams.Subscriber;\n\nimport java.net.URI;\n\npublic class MilkmanWebsocketClient extends WebSocketClient {\n\n    private final Subscriber<byte[]> responseSubscriber;\n    private final AsyncControl asyncControl;\n\n    public MilkmanWebsocketClient(URI serverUri,\n                                Subscriber<byte[]> responseSubscriber,\n                                AsyncControl asyncControl) {\n        super(serverUri);\n        this.responseSubscriber = responseSubscriber;\n        this.asyncControl = asyncControl;\n        asyncControl.onCancellationRequested.add(() -> close());\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        asyncControl.triggerReqeuestReady();\n    }\n\n    @Override\n    public void send(String message) {\n        String msg = \"SENT: \\n\" + message + \"\\n\\n\";\n        responseSubscriber.onNext(msg.getBytes());\n        super.send(message);\n    }\n\n    @Override\n    public void onMessage(String message) {\n        String msg = \"RECEIVED: \\n\" + message + \"\\n\\n\";\n        responseSubscriber.onNext(msg.getBytes());\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        responseSubscriber.onComplete();\n        asyncControl.triggerRequestSucceeded();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        responseSubscriber.onError(ex);\n        asyncControl.triggerRequestFailed(ex);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport rx.Subscriber;\nimport rx.AsyncControl;\n\npublic class MilkmanWebsocketClient extends WebSocketClient {\n    private final Subscriber<byte[]> responseSubscriber;\n    private final AsyncControl asyncControl;\n\n    public MilkmanWebsocketClient(URI serverUri, Subscriber<byte[]> responseSubscriber, AsyncControl asyncControl) {\n        super(serverUri);\n        this.responseSubscriber = responseSubscriber;\n        this.asyncControl = asyncControl;\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        asyncControl.setRequestReady();\n    }\n\n    public void send(String message) {\n        super.send(message);\n        byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);\n        responseSubscriber.onNext(messageBytes);\n    }\n\n    @Override\n    public void onMessage(String message) {\n        byte[] bytes = message.getBytes(StandardCharsets.UTF_8);\n        responseSubscriber.onNext(bytes);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        responseSubscriber.onComplete();\n        asyncControl.markRequestSuccess();\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        responseSubscriber.onError(ex);\n        asyncControl.markRequestFailure();\n    }\n}"
  },
  {
    "Task_id": 463,
    "Instruction": "Task Description: Implement a WebSocket client class in Java using the org.java_websocket library to establish a connection with a WebSocket server, handle incoming messages, and manage connection events.\n\nClass Description: WebSocketChatClient is a class that extends WebSocketClient from the org.java_websocket library. It provides functionality to connect to a WebSocket server and handle various WebSocket events such as connection opening, message reception, connection closing, and errors.\n\nAttributes:\n- Inherited from WebSocketClient: All attributes from the parent class WebSocketClient are available but not explicitly defined here.\n\nMethods:\n- Constructor: WebSocketChatClient(URI serverUri) -> void - Initializes the WebSocket client with the server URI.\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when the WebSocket connection is established. Prints \"Connected\" to the console.\n- onMessage: onMessage(String message) -> void - Called when a message is received from the server. Prints the message to the console.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the WebSocket connection is closed. Prints \"Disconnected\" to the console.\n- onError: onError(Exception ex) -> void - Called when an error occurs. Prints the stack trace of the exception.",
    "Canonical_solution": "import java.net.URI;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\nclass WebSocketChatClient extends WebSocketClient {\n\n  public WebSocketChatClient(URI serverUri) {\n    super(serverUri);\n  }\n\n  @Override\n  public void onOpen(ServerHandshake handshakedata) {\n    System.out.println(\"Connected\");\n  }\n\n  @Override\n  public void onMessage(String message) {\n    System.out.println(\"got: \" + message);\n  }\n\n  @Override\n  public void onClose(int code, String reason, boolean remote) {\n    System.out.println(\"Disconnected\");\n  }\n\n  @Override\n  public void onError(Exception ex) {\n    ex.printStackTrace();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.io.IOException;\n\npublic class WebSocketChatClient extends WebSocketClient {\n    public WebSocketChatClient(URI serverUri) {\n        super(serverUri);\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connected\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received: \" + message);\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Disconnected (\" + code + \"): \" + reason + \" (remote: \" + remote + \")\");\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        ex.printStackTrace();\n    }\n}"
  },
  {
    "Task_id": 465,
    "Instruction": "Task Description: Create a WebSocket client class in Java using the org.java_websocket library to establish a connection to a WebSocket server, handle incoming messages, and manage connection events.\n\nClass Description: The TestWebSocket class extends WebSocketClient to create a WebSocket client that connects to a specified localhost port. It overrides key WebSocket event-handling methods to manage connection lifecycle events, message reception, and errors.\n\nAttributes:\n- None (The class inherits all necessary attributes from WebSocketClient)\n\nMethods:\n- Constructor: TestWebSocket(int port) throws URISyntaxException - Initializes the WebSocket client with the specified port, constructing the WebSocket URI as \"ws://localhost:[port]\".\n- onOpen: onOpen(ServerHandshake handshakedata) -> void - Called when the WebSocket connection is successfully established.\n- onMessage: onMessage(String message) -> void - Called when a text message is received from the server.\n- onMessage: onMessage(ByteBuffer message) -> void - Called when a binary message is received from the server.\n- onClose: onClose(int code, String reason, boolean remote) -> void - Called when the WebSocket connection is closed.\n- onError: onError(Exception ex) -> void - Called when an error occurs on the WebSocket connection.",
    "Canonical_solution": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\nimport org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\n\npublic class TestWebSocket extends WebSocketClient {\n\n    public TestWebSocket(int port) throws URISyntaxException {\n        super(new URI(\"ws://localhost:\" + port));\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n    }\n\n    @Override\n    public void onMessage(String message) {\n    }\n\n    @Override\n    public void onMessage(ByteBuffer message) {\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onError(Exception ex) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 27,
    "right_result": "import org.java_websocket.client.WebSocketClient;\nimport org.java_websocket.handshake.ServerHandshake;\nimport java.net.URI;\nimport java.nio.ByteBuffer;\n\npublic class TestWebSocket extends WebSocketClient {\n    public TestWebSocket(int port) throws Exception {\n        super(new URI(\"ws://localhost:\" + port));\n    }\n\n    @Override\n    public void onOpen(ServerHandshake handshakedata) {\n        System.out.println(\"Connection opened\");\n    }\n\n    @Override\n    public void onMessage(String message) {\n        System.out.println(\"Received text message: \" + message);\n    }\n\n    @Override\n    public void onMessage(ByteBuffer message) {\n        System.out.println(\"Received binary message\");\n    }\n\n    @Override\n    public void onClose(int code, String reason, boolean remote) {\n        System.out.println(\"Connection closed. Code: \" + code + \", Reason: \" + reason + \", Remote: \" + remote);\n    }\n\n    @Override\n    public void onError(Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n    }\n}"
  },
  {
    "Task_id": 468,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from org.java_websocket. It provides lifecycle methods for managing WebSocket connections and includes a CountDownLatch for server startup synchronization.\n\nAttributes:\n- serverLatch: CountDownLatch - Used to signal when the server has started (nullable)\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer) -> void - Creates a server instance with specified address, decoder count, protocol drafts, and connection container\n- Constructor: MyWebSocketServer(int port, CountDownLatch serverLatch) -> void - Creates a server instance with specified port and startup latch\n- Constructor: MyWebSocketServer(int port) -> void - Creates a server instance with specified port (no latch)\n- onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects\n- onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n- onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n- onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.util.Collection;\nimport java.util.List;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    private CountDownLatch serverLatch = null;\n\n    public MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts,\n        Collection<WebSocket> connectionscontainer) {\n      super(address, decodercount, drafts, connectionscontainer);\n    }\n\n    public MyWebSocketServer(int port, CountDownLatch serverLatch) {\n      super(new InetSocketAddress(port));\n      this.serverLatch = serverLatch;\n    }\n\n    public MyWebSocketServer(int port) {\n      this(port, null);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n      ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n      if (serverLatch != null) {\n        serverLatch.countDown();\n      }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    private CountDownLatch serverLatch;\n    private Collection<WebSocket> connectionscontainer;\n\n    public MyWebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer) {\n        super(address);\n        setDecoderCount(decodercount);\n        setDrafts(drafts);\n        setConnectionContainer(connectionscontainer);\n        this.connectionscontainer = connectionscontainer;\n    }\n\n    public MyWebSocketServer(int port, CountDownLatch serverLatch) {\n        super(port);\n        this.serverLatch = serverLatch;\n    }\n\n    public MyWebSocketServer(int port) {\n        super(port);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        if (connectionscontainer != null) {\n            connectionscontainer.add(conn);\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        if (connectionscontainer != null) {\n            connectionscontainer.remove(conn);\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        if (serverLatch != null) {\n            serverLatch.countDown();\n        }\n    }\n}"
  },
  {
    "Task_id": 470,
    "Instruction": "Task Description: Implement a WebSocket server class for handling real-time communication between clients, including connection management, message broadcasting, and error handling.\n\nClass Description: ChatServer is a WebSocket server implementation that extends WebSocketServer from org.java_websocket library. It manages client connections, processes incoming messages (both text and binary), broadcasts messages to all connected clients, and handles connection events and errors.\n\nAttributes:\n- (Inherited from WebSocketServer) port: int - The port number on which the server listens\n- (Inherited from WebSocketServer) address: InetSocketAddress - The network address of the server\n- (Inherited from WebSocketServer) draft: Draft_6455 - The WebSocket protocol draft being used\n\nMethods:\n- ChatServer(int port) -> None - Constructor that initializes the server with specified port\n- ChatServer(InetSocketAddress address) -> None - Constructor that initializes the server with specified socket address\n- ChatServer(int port, Draft_6455 draft) -> None - Constructor that initializes the server with specified port and protocol draft\n- onOpen(WebSocket conn, ClientHandshake handshake) -> void - Handles new client connections, sends welcome message, and notifies other clients\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Handles client disconnections and notifies other clients\n- onMessage(WebSocket conn, String message) -> void - Processes incoming text messages and broadcasts to all clients\n- onMessage(WebSocket conn, ByteBuffer message) -> void - Processes incoming binary messages and broadcasts to all clients\n- onError(WebSocket conn, Exception ex) -> void - Handles errors that occur during WebSocket operations\n- onStart() -> void - Initializes server settings when the server starts",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ChatServer extends WebSocketServer {\n\n    public ChatServer(int port) {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    public ChatServer(int port, Draft_6455 draft) {\n        super(new InetSocketAddress(port), Collections.<Draft>singletonList(draft));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the server!\");\n        broadcast(\"new connection: \" + handshake.getResourceDescriptor());\n        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        broadcast(conn + \" has left the room!\");\n        System.out.println(conn + \" has left the room!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message.array());\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n        setConnectionLostTimeout(100);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.Collection;\n\npublic class ChatServer extends WebSocketServer {\n    public ChatServer(int port) {\n        super(port);\n    }\n\n    public ChatServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    public ChatServer(int port, Draft_6455 draft) {\n        super(port, draft);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the chat!\");\n        for (WebSocket client : getConnections()) {\n            if (client != conn) {\n                client.send(\"User joined\");\n            }\n        }\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        for (WebSocket client : getConnections()) {\n            if (client != conn) {\n                client.send(\"User left\");\n            }\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n        conn.close();\n    }\n\n    @Override\n    public void onStart() {\n        // Initialization code if needed\n    }\n\n    private void broadcast(String message) {\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n\n    private void broadcast(ByteBuffer message) {\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 471,
    "Instruction": "Task Description: Create a WebSocket server implementation using org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: MyWebSocketServer is a custom WebSocket server implementation that extends the WebSocketServer class from org.java_websocket. It provides lifecycle methods for managing client connections and communication.\n\nAttributes:\n- inherited from WebSocketServer: Various internal attributes for managing server state and connections\n\nMethods:\n- Constructor: MyWebSocketServer(InetSocketAddress inetSocketAddress) -> void - Initializes the server with specified socket address\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Called when a new client connects\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Called when a client disconnects\n- onMessage: onMessage(WebSocket conn, String message) -> void - Called when a message is received from a client\n- onError: onError(WebSocket conn, Exception ex) -> void - Called when an error occurs\n- onStart: onStart() -> void - Called when the server starts successfully",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class MyWebSocketServer extends WebSocketServer {\n\n    public MyWebSocketServer(InetSocketAddress inetSocketAddress) {\n        super(inetSocketAddress);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        // Handle new client connection\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        // Handle client disconnection\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        // Process received message from client\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        // Handle errors\n    }\n\n    @Override\n    public void onStart() {\n        // Server startup logic\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\n\npublic class MyWebSocketServer extends WebSocketServer {\n    public MyWebSocketServer(InetSocketAddress inetSocketAddress) {\n        super(inetSocketAddress);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        System.out.println(\"New client connected: \" + conn.getRemoteSocketAddress());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"Client disconnected: \" + conn.getRemoteSocketAddress() + \" (\" + reason + \")\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Received message from \" + conn.getRemoteSocketAddress() + \": \" + message);\n        conn.send(\"Echo: \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started on \" + getLocalAddress());\n    }\n}"
  },
  {
    "Task_id": 473,
    "Instruction": "Task Description: Implement a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library.\n\nClass Description: The SocketActivation class extends WebSocketServer to create a custom WebSocket server. It manages client connections, broadcasts messages to all connected clients, and handles server lifecycle events. The server tracks the number of connected clients and shuts down when no clients remain.\n\nAttributes:\n- clients: AtomicInteger - Tracks the number of currently connected clients\n\nMethods:\n- SocketActivation(ServerSocketChannel chan) -> None - Constructor that initializes the WebSocket server with the given ServerSocketChannel\n- onOpen(WebSocket conn, ClientHandshake handshake) -> None - Handles new client connections, sends welcome message, and broadcasts connection event\n- onClose(WebSocket conn, int code, String reason, boolean remote) -> None - Handles client disconnections, broadcasts departure event, and shuts down server if no clients remain\n- onMessage(WebSocket conn, String message) -> None - Broadcasts received text messages to all clients and logs the message\n- onMessage(WebSocket conn, ByteBuffer message) -> None - Broadcasts received binary messages to all clients and logs the message\n- onError(WebSocket conn, Exception ex) -> None - Handles and logs any errors that occur during WebSocket operations\n- onStart() -> None - Called when the server starts successfully, logs server startup",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class SocketActivation extends WebSocketServer {\n\n    private AtomicInteger clients = new AtomicInteger(0);\n\n    public SocketActivation(ServerSocketChannel chan) {\n        super(chan);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.send(\"Welcome to the server!\");\n        broadcast(\"new connection: \" + handshake.getResourceDescriptor());\n        if(clients.get() == 0) {\n            broadcast(\"You are the first client to join\");\n        }\n        System.out.println(conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room!\");\n        clients.incrementAndGet();\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        broadcast(conn + \" has left the room!\");\n        System.out.println(conn + \" has left the room!\");\n        if(clients.decrementAndGet() <= 0) {\n            System.out.println(\"No more clients left, exiting\");\n            System.exit(0);\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        broadcast(message.array());\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.ServerSocketChannel;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class SocketActivation extends WebSocketServer {\n    private AtomicInteger clients;\n\n    public SocketActivation(ServerSocketChannel chan) {\n        super(chan);\n        clients = new AtomicInteger(0);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        clients.incrementAndGet();\n        conn.send(\"Welcome to the WebSocket server!\");\n        broadcast(\"Client connected\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        clients.decrementAndGet();\n        if (clients.get() == 0) {\n            stop();\n        }\n        broadcast(\"Client disconnected\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        broadcast(message);\n        System.out.println(\"Received text message: \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        byte[] data = new byte[message.remaining()];\n        message.get(data);\n        broadcast(data);\n        System.out.println(\"Received binary message of length: \" + data.length);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"WebSocket server started\");\n    }\n\n    private void broadcast(String message) {\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n\n    private void broadcast(byte[] message) {\n        for (WebSocket client : getConnections()) {\n            client.send(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 474,
    "Instruction": "Task Description: Implement a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should assign unique IDs to clients and log connection events.\n\nClass Description: ChatServerAttachmentExample is a WebSocket server implementation that manages client connections, tracks clients with unique IDs, and handles text/binary messages. It extends WebSocketServer from the org.java_websocket library.\n\nAttributes:\n- index: Integer - Tracks the next available client ID to be assigned\n\nMethods:\n- Constructor(port: int) -> None - Creates server instance bound to specified port\n- Constructor(address: InetSocketAddress) -> None - Creates server instance bound to specified address\n- onOpen(conn: WebSocket, handshake: ClientHandshake) -> void - Handles new client connections, assigns ID\n- onClose(conn: WebSocket, code: int, reason: String, remote: boolean) -> void - Handles client disconnections\n- onMessage(conn: WebSocket, message: String) -> void - Processes text messages from clients\n- onMessage(conn: WebSocket, message: ByteBuffer) -> void - Processes binary messages from clients\n- onError(conn: WebSocket, ex: Exception) -> void - Handles connection errors\n- onStart() -> void - Called when server starts successfully",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class ChatServerAttachmentExample extends WebSocketServer {\n\n    Integer index = 0;\n\n    public ChatServerAttachmentExample(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public ChatServerAttachmentExample(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.setAttachment(index);\n        index++;\n        System.out.println(\n            conn.getRemoteSocketAddress().getAddress().getHostAddress() + \" entered the room! ID: \"\n                + conn.<Integer>getAttachment());\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(conn + \" has left the room! ID: \" + conn.<Integer>getAttachment());\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        System.out.println(conn + \": \" + message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ChatServerAttachmentExample extends WebSocketServer {\n    private int index;\n    private Map<Integer, WebSocket> clients;\n\n    public ChatServerAttachmentExample(int port) {\n        super(new InetSocketAddress(port));\n        this.index = 0;\n        this.clients = new HashMap<>();\n    }\n\n    public ChatServerAttachmentExample(InetSocketAddress address) {\n        super(address);\n        this.index = 0;\n        this.clients = new HashMap<>();\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        int clientId = index++;\n        clients.put(clientId, conn);\n        System.out.println(\"Client connected with ID: \" + clientId);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        for (Map.Entry<Integer, WebSocket> entry : clients.entrySet()) {\n            if (entry.getValue() == conn) {\n                clients.remove(entry.getKey());\n                System.out.println(\"Client disconnected. Code: \" + code + \", Reason: \" + reason);\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        System.out.println(\"Text message received: \" + message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer message) {\n        System.out.println(\"Binary message received, size: \" + message.remaining());\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.err.println(\"Error occurred: \" + ex.getMessage());\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started successfully.\");\n    }\n}"
  },
  {
    "Task_id": 475,
    "Instruction": "Task Description: Implement a WebSocket server class in Java using the org.java_websocket library to handle client connections, messages, disconnections, and errors.\n\nClass Description: The WSocketServer class extends WebSocketServer to create a custom WebSocket server that manages client connections and communication. It handles lifecycle events including connection opening, message reception, connection closing, and errors. The server can broadcast messages to all connected clients.\n\nAttributes:\n- Inherited attributes from WebSocketServer (base class handles socket connections and client management)\n\nMethods:\n- Constructor: WSocketServer(int port) throws UnknownHostException - Creates a server instance bound to the specified port.\n- Constructor: WSocketServer(InetSocketAddress address) - Creates a server instance bound to the specified socket address.\n- onOpen: onOpen(WebSocket conn, ClientHandshake handshake) -> void - Handles new client connections and sends a handshake confirmation.\n- onClose: onClose(WebSocket conn, int code, String reason, boolean remote) -> void - Handles client disconnections and notifies other clients.\n- onMessage: onMessage(WebSocket conn, String message) -> void - Processes incoming messages from clients and echoes them back.\n- onError: onError(WebSocket conn, Exception ex) -> void - Handles errors occurring during WebSocket operations.\n- sendToClient: sendToClient(String text) -> void - Broadcasts a message to all connected clients (thread-safe operation).",
    "Canonical_solution": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collection;\n\npublic class WSocketServer extends WebSocketServer {\n\n    public WSocketServer(int port) throws UnknownHostException {\n        super(new InetSocketAddress(port));\n    }\n\n    public WSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket webSocket, ClientHandshake clientHandshake) {\n        this.sendToClient(\"[Handshake Ok]\");\n    }\n\n    @Override\n    public void onClose(WebSocket webSocket, int i, String s, boolean b) {\n        this.sendToClient(webSocket + \" close\");\n    }\n\n    @Override\n    public void onMessage(WebSocket webSocket, String message) {\n        this.sendToClient(message);\n    }\n\n    @Override\n    public void onError(WebSocket webSocket, Exception e) {\n        e.printStackTrace();\n        if (webSocket != null) {\n            // Error handling for specific WebSocket\n        }\n    }\n\n    public void sendToClient(String text) {\n        Collection<WebSocket> con = connections();\n        synchronized (con) {\n            for (WebSocket c : con) {\n                c.send(text);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.List;\n\npublic class WSocketServer extends WebSocketServer {\n\n    public WSocketServer(int port) throws UnknownHostException {\n        super(port);\n    }\n\n    public WSocketServer(InetSocketAddress address) {\n        super(address);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        conn.sendTextMessage(\"Welcome to the WebSocket server!\");\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        String message = \"Client \" + conn.getRemoteSocketAddress() + \" has disconnected.\";\n        synchronized (this) {\n            for (WebSocket client : getClientList()) {\n                if (client != conn) {\n                    client.sendTextMessage(message);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.sendTextMessage(message);\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        ex.printStackTrace();\n    }\n\n    public synchronized void sendToClient(String text) {\n        for (WebSocket client : getClientList()) {\n            client.sendTextMessage(text);\n        }\n    }\n}"
  },
  {
    "Task_id": 476,
    "Instruction": "Task Description: Create a WebSocket server class that handles client connections, messages, and disconnections using the org.java_websocket library. The server should echo received messages back to clients and maintain a connection counter.\n\nClass Description: AutobahnSSLServerTest is a WebSocket server implementation that extends WebSocketServer from the org.java_websocket library. It handles client connections by maintaining a counter, processes incoming messages by echoing them back, and provides basic connection lifecycle management.\n\nAttributes:\n- counter: [int] - Static counter tracking the number of opened connections\n\nMethods:\n- Constructor: [AutobahnSSLServerTest](int port, Draft d) -> [void] - Creates a server instance bound to the specified port using the given WebSocket draft protocol\n- Constructor: [AutobahnSSLServerTest](InetSocketAddress address, Draft d) -> [void] - Creates a server instance bound to the specified address using the given WebSocket draft protocol\n- onOpen: [onOpen](WebSocket conn, ClientHandshake handshake) -> [void] - Handles new client connections, increments connection counter\n- onClose: [onClose](WebSocket conn, int code, String reason, boolean remote) -> [void] - Handles client disconnections\n- onError: [onError](WebSocket conn, Exception ex) -> [void] - Handles connection errors\n- onStart: [onStart]() -> [void] - Called when server starts successfully\n- onMessage: [onMessage](WebSocket conn, String message) -> [void] - Echoes received text messages back to the client\n- onMessage: [onMessage](WebSocket conn, ByteBuffer blob) -> [void] - Echoes received binary messages back to the client",
    "Canonical_solution": "import java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport org.java_websocket.WebSocket;\nimport org.java_websocket.drafts.Draft;\nimport org.java_websocket.drafts.Draft_6455;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\n\npublic class AutobahnSSLServerTest extends WebSocketServer {\n\n    private static int counter = 0;\n\n    public AutobahnSSLServerTest(int port, Draft d) throws UnknownHostException {\n        super(new InetSocketAddress(port), Collections.singletonList(d));\n    }\n\n    public AutobahnSSLServerTest(InetSocketAddress address, Draft d) {\n        super(address, Collections.singletonList(d));\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        counter++;\n        System.out.println(\"///////////Opened connection number\" + counter);\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        System.out.println(\"closed\");\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n        System.out.println(\"Error:\");\n        ex.printStackTrace();\n    }\n\n    @Override\n    public void onStart() {\n        System.out.println(\"Server started!\");\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 28,
    "right_result": "import org.java_websocket.WebSocket;\nimport org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.server.WebSocketServer;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\n\npublic class AutobahnSSLServerTest extends WebSocketServer {\n    private static int counter = 0;\n\n    public AutobahnSSLServerTest(int port, Draft d) {\n        super(port, d);\n    }\n\n    public AutobahnSSLServerTest(InetSocketAddress address, Draft d) {\n        super(address, d);\n    }\n\n    @Override\n    public void onOpen(WebSocket conn, ClientHandshake handshake) {\n        counter++;\n    }\n\n    @Override\n    public void onClose(WebSocket conn, int code, String reason, boolean remote) {\n        counter--;\n    }\n\n    @Override\n    public void onError(WebSocket conn, Exception ex) {\n    }\n\n    @Override\n    public void onStart() {\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, String message) {\n        conn.send(message);\n    }\n\n    @Override\n    public void onMessage(WebSocket conn, ByteBuffer blob) {\n        conn.send(blob);\n    }\n}"
  },
  {
    "Task_id": 48,
    "Instruction": "Task Description: Create a Java class that implements HTTP client functionality using Java's HttpClient for synchronous and asynchronous HTTP operations including GET, PUT, HEAD, and DELETE requests.\n\nClass Description: The BlobHttpClient class provides a wrapper around Java's HttpClient to perform common HTTP operations. It handles client initialization, request construction, and response processing with both synchronous and asynchronous options.\n\nAttributes:\nhttpClient: [HttpClient] - The underlying HTTP client instance used for all requests\n\nMethods:\nsetup(): [void] - Initializes the HttpClient instance with default configuration (follows normal redirects)\ncloseClient(): [void] - Closes the HttpClient instance and releases resources\nput: [HttpResponse<String>]([URI uri, String body]) -> [HttpResponse<String>] - Sends a synchronous PUT request with the provided body to the specified URI and returns the string response\nget: [HttpResponse<String>]([URI uri]) -> [HttpResponse<String>] - Sends a synchronous GET request to the specified URI and returns the string response\ngetAsync: [CompletableFuture<HttpResponse<String>>]([URI uri]) -> [CompletableFuture<HttpResponse<String>>] - Sends an asynchronous GET request to the specified URI and returns a CompletableFuture of the response\nhead: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous HEAD request to the specified URI and returns a response without body\ndelete: [HttpResponse<Void>]([URI uri]) -> [HttpResponse<Void>] - Sends a synchronous DELETE request to the specified URI and returns a response without body",
    "Canonical_solution": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpClient.Redirect;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class BlobHttpClient {\n\n    protected HttpClient httpClient;\n\n    public void setup() throws ExecutionException, InterruptedException {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .build();\n    }\n\n    public void closeClient() throws Exception {\n        httpClient.close();\n    }\n\n    protected HttpResponse<String> put(URI uri, String body) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .PUT(BodyPublishers.ofString(body))\n            .build();\n        HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());\n        return response;\n    }\n\n    protected HttpResponse<String> get(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.send(request, BodyHandlers.ofString());\n    }\n\n    protected CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .build();\n        return httpClient.sendAsync(request, BodyHandlers.ofString());\n    }\n\n    protected HttpResponse<Void> head(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).HEAD().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n\n    protected HttpResponse<Void> delete(URI uri) throws Exception {\n        HttpRequest request = HttpRequest.newBuilder(uri).DELETE().build();\n        return httpClient.send(request, BodyHandlers.discarding());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 17,
    "right_result": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class BlobHttpClient {\n    private HttpClient httpClient;\n\n    public void setup() {\n        httpClient = HttpClient.newBuilder()\n            .followRedirects(HttpClient.Redirect.NORMAL)\n            .build();\n    }\n\n    public void closeClient() {\n        if (httpClient != null) {\n            httpClient.close();\n        }\n    }\n\n    public HttpResponse<String> put(URI uri, String body) {\n        HttpRequest request = HttpRequest.newBuilder(uri)\n            .PUT(HttpRequest.BodyPublishers.ofString(body))\n            .build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<String> get(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public CompletableFuture<HttpResponse<String>> getAsync(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n        return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n    }\n\n    public HttpResponse<Void> head(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri).HEAD().build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofVoid());\n    }\n\n    public HttpResponse<Void> delete(URI uri) {\n        HttpRequest request = HttpRequest.newBuilder(uri).DELETE().build();\n        return httpClient.send(request, HttpResponse.BodyHandlers.ofVoid());\n    }\n}"
  },
  {
    "Task_id": 481,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles real-time client communication, including connection management, message processing, and error handling.\n\nClass Description: WebSocketServer is a Java EE WebSocket endpoint that manages client connections through WebSocket protocol. It handles connection events (open/close/error) and processes incoming messages, supporting different message operations like sending messages, reading status, and retrieving history.\n\nAttributes:\n- sessionPools: [ConcurrentHashMap<String, Session>] - Thread-safe map storing active client sessions with their IDs as keys\n\nMethods:\n- onOpen: [onOpen(String accessToken, Session session)] -> [void] - Handles new WebSocket connections, authenticates users, and manages session conflicts\n- onClose: [onClose(String accessToken)] -> [void] - Cleans up closed connections from session pool\n- onMessage: [onMessage(String accessToken, String msg)] -> [void] - Processes incoming JSON messages and delegates to appropriate operations\n- operation: [operation(String accessToken, MessageOperation messageOperation)] -> [void] - Executes different message operations based on operation type\n- sendMessage: [sendMessage(String sessionId, MessageVO message)] -> [void] - Sends message to specific client session by ID\n- sendMessage: [sendMessage(Session session, MessageVO message)] -> [void] - Sends message to given session object\n- onError: [onError(Session session, Throwable throwable)] -> [void] - Handles WebSocket communication errors",
    "Canonical_solution": "import cn.hutool.json.JSONUtil;\nimport cn.lili.common.security.AuthUser;\nimport cn.lili.common.security.context.UserContext;\nimport cn.lili.common.security.enums.UserEnums;\nimport cn.lili.modules.im.config.CustomSpringConfigurator;\nimport cn.lili.modules.im.entity.vo.MessageVO;\nimport cn.lili.modules.im.entity.enums.MessageResultType;\nimport cn.lili.modules.im.entity.vo.MessageOperation;\nimport com.alibaba.fastjson.JSON;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(value = \"/lili/webSocket/{accessToken}\", configurator = CustomSpringConfigurator.class)\n@Scope(\"prototype\")\npublic class WebSocketServer {\n\n    private static ConcurrentHashMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(@PathParam(\"accessToken\") String accessToken, Session session) {\n        AuthUser authUser = UserContext.getAuthUser(cache, accessToken);\n        String sessionId = UserEnums.STORE.equals(authUser.getRole()) ? authUser.getStoreId() : authUser.getId();\n        if (sessionPools.containsKey(sessionId)) {\n            Session oldSession = sessionPools.get(sessionId);\n            sendMessage(oldSession,\n                MessageVO.builder().messageResultType(MessageResultType.OFFLINE).result(\"\u7528\u6237\u5f02\u5730\u767b\u9646\").build());\n            try {\n                oldSession.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        sessionPools.put(sessionId, session);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"accessToken\") String accessToken) {\n        AuthUser authUser = UserContext.getAuthUser(accessToken);\n        sessionPools.remove(authUser);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"accessToken\") String accessToken, String msg) {\n        MessageOperation messageOperation = JSON.parseObject(msg, MessageOperation.class);\n        operation(accessToken, messageOperation);\n    }\n\n    private void operation(String accessToken, MessageOperation messageOperation) {\n        AuthUser authUser = UserContext.getAuthUser(accessToken);\n        switch (messageOperation.getOperationType()) {\n            case MESSAGE:\n                sendMessage(messageOperation.getTo(), new MessageVO(MessageResultType.MESSAGE, imMessage));\n                break;\n            case READ:\n                break;\n            case UNREAD:\n                sendMessage(authUser.getId(),\n                    new MessageVO(MessageResultType.UN_READ, imMessageService.unReadMessages(accessToken)));\n                break;\n            case HISTORY:\n                sendMessage(authUser.getId(), new MessageVO(MessageResultType.HISTORY,\n                    imMessageService.historyMessage(accessToken, messageOperation.getTo())));\n                break;\n            default:\n                break;\n        }\n    }\n\n    private void sendMessage(String sessionId, MessageVO message) {\n        Session session = sessionPools.get(sessionId);\n        sendMessage(session, message);\n    }\n\n    private void sendMessage(Session session, MessageVO message) {\n        if (session != null) {\n            try {\n                session.getBasicRemote().sendText(JSON.toJSONString(message, true));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n@ServerEndpoint\npublic class WebSocketServer {\n    private static final ConcurrentMap<String, Session> sessionPools = new ConcurrentHashMap<>();\n\n    public void onOpen(String accessToken, Session session) {\n        if (isValidAccessToken(accessToken)) {\n            String sessionId = session.getId();\n            if (sessionPools.containsKey(sessionId)) {\n                Session existingSession = sessionPools.get(sessionId);\n                try {\n                    existingSession.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            sessionPools.put(sessionId, session);\n        } else {\n            try {\n                session.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void onClose(String accessToken) {\n        String sessionId = accessToken;\n        sessionPools.remove(sessionId);\n    }\n\n    public void onMessage(String accessToken, String msg) {\n        try {\n            JSONObject json = new JSONObject(msg);\n            String operation = json.getString(\"operation\");\n            MessageOperation messageOperation = MessageOperation.valueOf(operation);\n            operation(accessToken, messageOperation);\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void operation(String accessToken, MessageOperation messageOperation) {\n        switch (messageOperation) {\n            case SEND_MESSAGE:\n                // Handle sending message\n                break;\n            case READ_STATUS:\n                // Handle reading status\n                break;\n            case GET_HISTORY:\n                // Handle retrieving history\n                break;\n            default:\n                // Handle unknown operation\n        }\n    }\n\n    public void sendMessage(String sessionId, MessageVO message) {\n        Session session = sessionPools.get(sessionId);\n        if (session != null) {\n            try {\n                session.getBasicRemote().sendObject(message);\n            } catch (IOException | EncodeException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMessage(Session session, MessageVO message) {\n        try {\n            session.getBasicRemote().sendObject(message);\n        } catch (IOException | EncodeException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void onError(Session session, Throwable throwable) {\n        System.err.println(\"WebSocket error: \" + throwable.getMessage());\n        try {\n            session.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private boolean isValidAccessToken(String accessToken) {\n        // Implementation for validating access token\n        return true;\n    }\n}"
  },
  {
    "Task_id": 482,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, disconnections, and errors using Java EE WebSocket API.\n\nClass Description: The WebsocketServerEndpoint class is a WebSocket server endpoint that manages client connections and message handling. It uses annotations to define WebSocket lifecycle events and maintains a map of message handlers for different message types.\n\nAttributes:\n- logger: Logger - Used for logging server events and errors\n- HANDLERS: Map<String, MessageHandler> - Static map storing message handlers keyed by message type\n\nMethods:\n- onOpen(Session session, EndpointConfig config) -> void - Handles new client connections, authenticates using access token from request parameters\n- onMessage(Session session, String message) -> void - Processes incoming messages from clients, delegates to appropriate message handler\n- onClose(Session session, CloseReason closeReason) -> void - Handles client disconnections, cleans up session\n- onError(Session session, Throwable throwable) -> void - Handles WebSocket communication errors\n- getMessageClass(MessageHandler handler) -> Class<? extends Message> - Helper method to determine message class type from handler's generic type information",
    "Canonical_solution": "import cn.iocoder.springboot.lab25.springwebsocket.handler.MessageHandler;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.AuthRequest;\nimport cn.iocoder.springboot.lab25.springwebsocket.message.Message;\nimport cn.iocoder.springboot.lab25.springwebsocket.util.WebSocketUtil;\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.aop.framework.AopProxyUtils;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n@ServerEndpoint(\"/\")\npublic class WebsocketServerEndpoint {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    private static final Map<String, MessageHandler> HANDLERS = new HashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        logger.info(\"[onOpen][session({}) connected]\", session);\n        List<String> accessTokenValues = session.getRequestParameterMap().get(\"accessToken\");\n        String accessToken = !CollectionUtils.isEmpty(accessTokenValues) ? accessTokenValues.get(0) : null;\n        AuthRequest authRequest = new AuthRequest().setAccessToken(accessToken);\n        MessageHandler<AuthRequest> messageHandler = HANDLERS.get(AuthRequest.TYPE);\n        if (messageHandler == null) {\n            logger.error(\"[onOpen][Auth message type, no message handler found]\");\n            return;\n        }\n        messageHandler.execute(session, authRequest);\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        logger.info(\"[onMessage][session({}) received message({})]\", session, message);\n        try {\n            JSONObject jsonMessage = JSON.parseObject(message);\n            String messageType = jsonMessage.getString(\"type\");\n            MessageHandler messageHandler = HANDLERS.get(messageType);\n            if (messageHandler == null) {\n                logger.error(\"[onMessage][Message type({}) has no handler]\", messageType);\n                return;\n            }\n            Class<? extends Message> messageClass = getMessageClass(messageHandler);\n            Message messageObj = JSON.parseObject(jsonMessage.getString(\"body\"), messageClass);\n            messageHandler.execute(session, messageObj);\n        } catch (Throwable throwable) {\n            logger.error(\"[onMessage][session({}) error processing message]\", session, throwable);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"[onClose][session({}) disconnected. Reason: {}]\", session, closeReason);\n        WebSocketUtil.removeSession(session);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.error(\"[onError][session({}) error occurred]\", session, throwable);\n    }\n\n    private Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);\n        Type[] interfaces = targetClass.getGenericInterfaces();\n        Class<?> superclass = targetClass.getSuperclass();\n        while ((Objects.isNull(interfaces) || interfaces.length == 0) && Objects.nonNull(superclass)) {\n            interfaces = superclass.getGenericInterfaces();\n            superclass = targetClass.getSuperclass();\n        }\n        if (Objects.nonNull(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType parameterizedType = (ParameterizedType) type;\n                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {\n                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {\n                            return (Class<Message>) actualTypeArguments[0];\n                        }\n                    }\n                }\n            }\n        }\n        throw new IllegalStateException(String.format(\"Cannot determine message type for handler %s\", handler));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\n@ServerEndpoint(\"/websocket\")\npublic class WebsocketServerEndpoint {\n    private static final Logger logger = Logger.getLogger(WebsocketServerEndpoint.class.getName());\n    private static final Map<String, MessageHandler<?>> HANDLERS = new HashMap<>();\n\n    static {\n        // Initialize handlers with example message types\n        HANDLERS.put(\"user\", new UserMessageHandler());\n        HANDLERS.put(\"chat\", new ChatMessageHandler());\n    }\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        String token = config.getHttpServletRequest().getParameter(\"token\");\n        if (token == null || !isValidToken(token)) {\n            session.close();\n            logger.warning(\"Unauthorized connection\");\n            return;\n        }\n        logger.info(\"Client connected: \" + session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(Session session, String message) {\n        try {\n            String type = extractMessageType(message);\n            MessageHandler handler = HANDLERS.get(type);\n            if (handler == null) {\n                logger.warning(\"Unknown message type: \" + type);\n                return;\n            }\n            Object msg = parseMessage(message, handler);\n            handler.handle(msg);\n        } catch (Exception e) {\n            logger.severe(\"Error processing message: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        logger.info(\"Client disconnected: \" + session.getId() + \", reason: \" + closeReason.getReasonPhrase());\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.severe(\"WebSocket error: \" + throwable.getMessage());\n        throwable.printStackTrace();\n        session.close();\n    }\n\n    private String extractMessageType(String message) {\n        // Extract message type from JSON payload\n        return new com.google.gson.Gson().fromJson(message, com.google.gson.JsonObject.class).get(\"type\").getAsString();\n    }\n\n    private Object parseMessage(String message, MessageHandler handler) {\n        com.google.gson.JsonObject msgObj = new com.google.gson.Gson().fromJson(message, com.google.gson.JsonObject.class);\n        String content = msgObj.get(\"content\").getAsString();\n        return new com.google.gson.Gson().fromJson(content, getMessageClass(handler));\n    }\n\n    private Class<? extends Message> getMessageClass(MessageHandler handler) {\n        Type type = ((ParameterizedType) handler.getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n        return (Class<? extends Message>) type;\n    }\n\n    private boolean isValidToken(String token) {\n        // Implement token validation logic\n        return true;\n    }\n}"
  },
  {
    "Task_id": 483,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for secure shell terminal communication, handling client connections, message exchange, and session management.\n\nClass Description: SecureShellWS is a Java EE WebSocket endpoint that facilitates secure shell terminal interactions between clients and servers. It manages terminal sessions, processes keyboard input commands, and handles connection lifecycle events.\n\nAttributes:\n- log: [Logger] - Logger instance for error and debug logging\n- keyMap: [Map<Integer, byte[]>] - Static mapping of key codes to their corresponding byte sequences for terminal control\n- httpSession: [HttpSession] - HTTP session associated with the WebSocket connection\n- session: [Session] - WebSocket session object for the current connection\n- sessionId: [Long] - Unique identifier for the terminal session\n\nMethods:\n- onOpen: [onOpen](Session session, EndpointConfig config) -> void - Handles new WebSocket connections, initializes session parameters, and starts output thread\n- onMessage: [onMessage](String message) -> void - Processes incoming JSON messages containing terminal commands or key inputs\n- onError: [onError](Session session, Throwable t) -> void - Handles WebSocket communication errors\n- onClose: [onClose]() -> void - Cleans up resources when WebSocket connection is closed, terminating all associated terminal sessions",
    "Canonical_solution": "import com.google.gson.Gson;\nimport io.bastillion.common.util.AppConfig;\nimport io.bastillion.common.util.AuthUtil;\nimport io.bastillion.manage.control.SecureShellKtrl;\nimport io.bastillion.manage.db.UserDB;\nimport io.bastillion.manage.model.SchSession;\nimport io.bastillion.manage.model.UserSchSessions;\nimport io.bastillion.manage.task.SentOutputTask;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.http.HttpSession;\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@ServerEndpoint(value = \"/admin/terms.ws\", configurator = GetHttpSessionConfigurator.class)\npublic class SecureShellWS {\n\n    private static final Logger log = LoggerFactory.getLogger(SecureShellWS.class);\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n\n    static {\n        keyMap.put(27, new byte[]{(byte) 0x1b});\n        keyMap.put(13, new byte[]{(byte) 0x0d});\n        keyMap.put(37, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x44});\n        keyMap.put(38, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x41});\n        keyMap.put(39, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x43});\n        keyMap.put(40, new byte[]{(byte) 0x1b, (byte) 0x4f, (byte) 0x42});\n        keyMap.put(8, new byte[]{(byte) 0x7f});\n        keyMap.put(9, new byte[]{(byte) 0x09});\n        keyMap.put(17, new byte[]{});\n        keyMap.put(46, \"\\033[3~\".getBytes());\n        keyMap.put(45, \"\\033[2~\".getBytes());\n        keyMap.put(33, \"\\033[5~\".getBytes());\n        keyMap.put(34, \"\\033[6~\".getBytes());\n        keyMap.put(35, \"\\033[4~\".getBytes());\n        keyMap.put(36, \"\\033[1~\".getBytes());\n    }\n\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n\n    @OnOpen\n    public void onOpen(Session session, EndpointConfig config) {\n        if (StringUtils.isNotEmpty(AppConfig.getProperty(\"websocketTimeout\"))) {\n            session.setMaxIdleTimeout(Long.parseLong(AppConfig.getProperty(\"websocketTimeout\")) * 60000);\n        } else {\n            session.setMaxIdleTimeout(0);\n        }\n\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class.getName());\n        try {\n            this.sessionId = AuthUtil.getSessionId(httpSession);\n            this.session = session;\n            new Thread(new SentOutputTask(sessionId, session, UserDB.getUser(AuthUtil.getUserId(httpSession)))).start();\n        } catch (GeneralSecurityException | SQLException ex) {\n            log.error(ex.toString(), ex);\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        if (session.isOpen() && StringUtils.isNotEmpty(message) && !\"heartbeat\".equals(message)) {\n            try {\n                Map jsonRoot = new Gson().fromJson(message, Map.class);\n                String command = (String) jsonRoot.get(\"command\");\n                Integer keyCode = null;\n                Double keyCodeDbl = (Double) jsonRoot.get(\"keyCode\");\n                if (keyCodeDbl != null) {\n                    keyCode = keyCodeDbl.intValue();\n                }\n\n                for (String idStr : (ArrayList<String>) jsonRoot.get(\"id\")) {\n                    Integer id = Integer.parseInt(idStr);\n                    UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n                    if (userSchSessions != null) {\n                        SchSession schSession = userSchSessions.getSchSessionMap().get(id);\n                        if (keyCode != null && keyMap.containsKey(keyCode)) {\n                            schSession.getCommander().write(keyMap.get(keyCode));\n                        } else {\n                            schSession.getCommander().print(command);\n                        }\n                    }\n                }\n                AuthUtil.setTimeout(httpSession);\n            } catch (IOException ex) {\n                log.error(ex.toString(), ex);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable t) {\n        log.error(t.toString(), t);\n    }\n\n    @OnClose\n    public void onClose() {\n        UserSchSessions userSchSessions = SecureShellKtrl.getUserSchSessionMap().get(sessionId);\n        if (userSchSessions != null) {\n            Map<Integer, SchSession> schSessionMap = userSchSessions.getSchSessionMap();\n            for (Integer sessionKey : schSessionMap.keySet()) {\n                SchSession schSession = schSessionMap.get(sessionKey);\n                schSession.getChannel().disconnect();\n                schSession.getSession().disconnect();\n                schSessionMap.remove(sessionKey);\n            }\n            schSessionMap.clear();\n            SecureShellKtrl.getUserSchSessionMap().remove(sessionId);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Thread;\nimport java.util.logging.Logger;\nimport org.json.JSONObject;\nimport org.json.JSONException;\n\n@ServerEndpoint\npublic class SecureShellWS extends Endpoint {\n    private static final Logger log = Logger.getLogger(SecureShellWS.class.getName());\n    private static final Map<Integer, byte[]> keyMap = new HashMap<>();\n    private HttpSession httpSession;\n    private Session session;\n    private Long sessionId;\n    private static long sessionIdCounter = 0;\n\n    static {\n        keyMap.put(127, new byte[]{-1, 27, 91, 50, 126}); // Backspace\n        keyMap.put(10, new byte[]{-1, 27, 91, 50, 126}); // Enter\n        keyMap.put(27, new byte[]{27}); // Escape\n        keyMap.put(91, new byte[]{91}); // [\n        keyMap.put(68, new byte[]{27, 91, 68}); // Left Arrow\n        keyMap.put(67, new byte[]{27, 91, 67}); // Right Arrow\n        keyMap.put(65, new byte[]{27, 91, 65}); // Up Arrow\n        keyMap.put(66, new byte[]{27, 91, 66}); // Down Arrow\n    }\n\n    @Override\n    public void onOpen(Session session, EndpointConfig config) {\n        this.session = session;\n        this.httpSession = (HttpSession) config.getUserProperties().get(HttpSession.class);\n        this.sessionId = ++sessionIdCounter;\n        startOutputThread();\n    }\n\n    private void startOutputThread() {\n        new Thread(() -> {\n            while (session.isOpen()) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    log.severe(\"Output thread interrupted\");\n                }\n            }\n        }).start();\n    }\n\n    @Override\n    public void onMessage(String message) {\n        try {\n            JSONObject json = new JSONObject(message);\n            String type = json.getString(\"type\");\n            if (type.equals(\"command\")) {\n                String command = json.getString(\"data\");\n                // Execute command and send output\n            } else if (type.equals(\"key\")) {\n                int keyCode = json.getInt(\"keyCode\");\n                byte[] sequence = keyMap.get(keyCode);\n                if (sequence != null) {\n                    // Send sequence to terminal process\n                }\n            }\n        } catch (JSONException e) {\n            log.severe(\"Invalid JSON message: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void onError(Session session, Throwable t) {\n        log.severe(\"WebSocket error: \" + t.getMessage());\n        session.close();\n    }\n\n    @Override\n    public void onClose() {\n        log.info(\"WebSocket connection closed\");\n        if (httpSession != null) {\n            httpSession.invalidate();\n        }\n        // Terminate any associated terminal sessions\n    }\n}"
  },
  {
    "Task_id": 484,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles client connections, messages, and broadcasts messages to connected clients.\n\nClass Description: WebSocketServer is a Java EE WebSocket endpoint that manages client connections, processes incoming messages, and provides functionality for sending messages to single or multiple clients. It uses annotations to define WebSocket lifecycle methods and maintains connection state.\n\nAttributes:\n- session: [Session] - The current WebSocket session for this endpoint instance\n- webSockets: [CopyOnWriteArraySet<WebSocketServer>] - Thread-safe set of all active WebSocket connections\n- sessionPool: [Map<String, Session>] - Mapping of user IDs to their corresponding WebSocket sessions\n\nMethods:\n- onOpen: [onOpen(Session session, @PathParam(\"userId\") String userId)] -> [void] - Handles new WebSocket connections and stores the session\n- onClose: [onClose()] -> [void] - Handles WebSocket connection closure and cleans up resources\n- onMessage: [onMessage(String message)] -> [void] - Processes incoming messages from clients\n- onError: [onError(Session session, Throwable error)] -> [void] - Handles WebSocket communication errors\n- sendAllMessage: [sendAllMessage(String message)] -> [void] - Broadcasts a message to all connected clients\n- sendOneMessage: [sendOneMessage(String userId, String message)] -> [void] - Sends a message to a specific client identified by user ID\n- sendMoreMessage: [sendMoreMessage(String[] userIds, String message)] -> [void] - Sends a message to multiple specified clients",
    "Canonical_solution": "import lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@Component\n@Slf4j\n@ServerEndpoint(\"/websocket/{userId}\")\npublic class WebSocketServer {\n\n    private Session session;\n    private static final CopyOnWriteArraySet<WebSocketServer> webSockets = new CopyOnWriteArraySet<>();\n    private static final Map<String, Session> sessionPool = new HashMap<String, Session>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(value = \"userId\") String userId) {\n        try {\n            this.session = session;\n            webSockets.add(this);\n            sessionPool.put(userId, session);\n            log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u6709\u65b0\u7684\u8fde\u63a5\uff0c\u603b\u6570\u4e3a:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n\n    @OnClose\n    public void onClose() {\n        try {\n            webSockets.remove(this);\n            log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u8fde\u63a5\u65ad\u5f00\uff0c\u603b\u6570\u4e3a:\" + webSockets.size());\n        } catch (Exception e) {\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u6536\u5230\u5ba2\u6237\u7aef\u6d88\u606f:\" + message);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void sendAllMessage(String message) {\n        log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011\u5e7f\u64ad\u6d88\u606f:\" + message);\n        for (WebSocketServer webSocket : webSockets) {\n            try {\n                if (webSocket.session.isOpen()) {\n                    webSocket.session.getAsyncRemote().sendText(message);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null && session.isOpen()) {\n            try {\n                log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011 \u5355\u70b9\u6d88\u606f:\" + message);\n                session.getAsyncRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMoreMessage(String[] userIds, String message) {\n        for (String userId : userIds) {\n            Session session = sessionPool.get(userId);\n            if (session != null && session.isOpen()) {\n                try {\n                    log.info(\"\u3010websocket\u670d\u52a1\u7aef\u3011 \u5355\u70b9\u6d88\u606f:\" + message);\n                    session.getAsyncRemote().sendText(message);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.OnError;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport java.util.HashMap;\n\n@ServerEndpoint(\"/websocket/{userId}\")\npublic class WebSocketServer {\n    private Session session;\n    private static final CopyOnWriteArraySet<WebSocketServer> webSockets = new CopyOnWriteArraySet<>();\n    private static final Map<String, Session> sessionPool = new HashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"userId\") String userId) {\n        this.session = session;\n        webSockets.add(this);\n        sessionPool.put(userId, session);\n    }\n\n    @OnClose\n    public void onClose() {\n        webSockets.remove(this);\n        String userId = findUserIdBySession(session);\n        if (userId != null) {\n            sessionPool.remove(userId);\n        }\n    }\n\n    private String findUserIdBySession(Session session) {\n        for (Map.Entry<String, Session> entry : sessionPool.entrySet()) {\n            if (entry.getValue().equals(session)) {\n                return entry.getKey();\n            }\n        }\n        return null;\n    }\n\n    @OnMessage\n    public void onMessage(String message) {\n        // Process message\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        // Handle error\n    }\n\n    public void sendAllMessage(String message) {\n        for (WebSocketServer server : webSockets) {\n            try {\n                server.session.getRemote().sendText(message);\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void sendOneMessage(String userId, String message) {\n        Session session = sessionPool.get(userId);\n        if (session != null) {\n            try {\n                session.getRemote().sendText(message);\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n\n    public void sendMoreMessage(String[] userIds, String message) {\n        for (String userId : userIds) {\n            Session session = sessionPool.get(userId);\n            if (session != null) {\n                try {\n                    session.getRemote().sendText(message);\n                } catch (Exception e) {\n                    // Handle exception\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 486,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java that handles real-time communication between multiple clients, specifically for broadcasting figures and binary data snapshots to connected peers.\n\nClass Description: The Whiteboard class is a WebSocket server endpoint that manages client connections and facilitates real-time data broadcasting. It maintains a list of connected peers and provides methods to handle connection events (open/close) and message broadcasting (figures and binary data).\n\nAttributes:\n- LOGGER: Logger - Used for logging server activities and debugging information\n- PRESENT: Object - A dummy object used as a value in the peers ConcurrentMap\n- peers: ConcurrentMap<Session, Object> - Thread-safe collection storing all connected client sessions\n\nMethods:\n- onOpen(Session peer) -> void - Handles new WebSocket connections by adding the client session to the peers map\n- onClose(Session peer) -> void - Handles WebSocket disconnections by removing the client session from the peers map\n- broadcastFigure(Figure figure, Session session) -> void - Broadcasts a Figure object to all connected clients except the sender\n- broadcastSnapshot(ByteBuffer data, Session session) -> void - Broadcasts binary data to all connected clients except the sender",
    "Canonical_solution": "import java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.websocket.EncodeException;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(value = \"/websocket\",\n    encoders = { FigureEncoder.class },\n    decoders = { FigureDecoder.class })\npublic class Whiteboard {\n\n    private static final Logger LOGGER = Logger.getLogger(Whiteboard.class.getName());\n    private static final Object PRESENT = new Object();\n    private static final ConcurrentMap<Session, Object> peers = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session peer) {\n        peers.put(peer, PRESENT);\n    }\n\n    @OnClose\n    public void onClose(Session peer) {\n        peers.remove(peer);\n    }\n\n    @OnMessage\n    public void broadcastFigure(Figure figure, Session session) throws IOException, EncodeException {\n        LOGGER.log(Level.INFO, \"boradcastFigure: {0}\", figure);\n        for (Session peer : session.getOpenSessions()) {\n            if (!peer.equals(session)) {\n                peer.getBasicRemote().sendObject(figure);\n            }\n        }\n    }\n\n    @OnMessage\n    public void broadcastSnapshot(ByteBuffer data, Session session) throws IOException {\n        LOGGER.log(Level.INFO, \"broadcastBinary: {0}\", data);\n        for (Session peer : session.getOpenSessions()) {\n            if (!peer.equals(session)) {\n                peer.getBasicRemote().sendBinary(data);\n            }\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.logging.Logger;\n\n@ServerEndpoint(\"/whiteboard\")\npublic class Whiteboard extends javax.websocket.Endpoint {\n    private static final Logger LOGGER = Logger.getLogger(Whiteboard.class.getName());\n    private static final Object PRESENT = new Object();\n    private final ConcurrentMap<Session, Object> peers = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session peer) {\n        peers.put(peer, PRESENT);\n        LOGGER.info(\"Client connected: \" + peer.getId());\n    }\n\n    @OnClose\n    public void onClose(Session peer) {\n        peers.remove(peer);\n        LOGGER.info(\"Client disconnected: \" + peer.getId());\n    }\n\n    public void broadcastFigure(Figure figure, Session session) {\n        for (Session peer : peers.keySet()) {\n            if (!peer.equals(session)) {\n                try {\n                    peer.getBasicRemote().sendObject(figure);\n                } catch (Exception e) {\n                    LOGGER.severe(\"Error sending figure: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    public void broadcastSnapshot(java.nio.ByteBuffer data, Session session) {\n        for (Session peer : peers.keySet()) {\n            if (!peer.equals(session)) {\n                try {\n                    peer.getBasicRemote().sendBinary(data);\n                } catch (Exception e) {\n                    LOGGER.severe(\"Error sending snapshot: \" + e.getMessage());\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 488,
    "Instruction": "Task Description: Implement a WebSocket server endpoint class in Java that handles client connections, messages, and disconnections, supporting both group broadcasting and private messaging.\n\nClass Description: WebSocket server endpoint class that manages client connections through WebSocket protocol, maintains active connections in a concurrent map, and provides message broadcasting and targeted messaging functionality.\n\nAttributes:\n- session: [Session] - The WebSocket session object representing a client connection\n- name: [String] - The identifier for the connected client\n- webSocketSet: [ConcurrentHashMap<String, WebSocket>] - Thread-safe map storing all active WebSocket connections with client names as keys\n\nMethods:\n- OnOpen([Session session, @PathParam(value = \"name\") String name]) -> [void] - Handles new client connections, stores the session and name, and notifies all clients\n- OnClose() -> [void] - Handles client disconnections, removes from active connections, and notifies all clients\n- OnMessage([String messageStr]) -> [void] - Processes incoming messages, routing to either private or group messaging based on message format\n- onError([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- GroupSending([String message]) -> [void] - Broadcasts a message to all connected clients\n- AppointSending([String name, String message]) -> [void] - Sends a message to a specific client identified by name",
    "Canonical_solution": "import javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@Component\n@ServerEndpoint(\"/websocket/{name}\")\npublic class WebSocket {\n    private Session session;\n    private String name;\n    private static ConcurrentHashMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void OnOpen(Session session, @PathParam(value = \"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        GroupSending(name + \" \u6765\u4e86\");\n    }\n\n    @OnClose\n    public void OnClose() {\n        webSocketSet.remove(this.name);\n        GroupSending(name + \" \u8d70\u4e86\");\n    }\n\n    @OnMessage\n    public void OnMessage(String messageStr) {\n        if (messageStr.indexOf(\"TOUSER\") == 0) {\n            String[] split = messageStr.split(\";\");\n            String[] split1 = split[0].split(\":\");\n            String[] split2 = split[1].split(\":\");\n            String name = split1[1];\n            String message = split2[1];\n            AppointSending(name, message);\n        } else {\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void GroupSending(String message) {\n        for (String name : webSocketSet.keySet()) {\n            try {\n                webSocketSet.get(name).session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void AppointSending(String name, String message) {\n        try {\n            webSocketSet.get(name).session.getBasicRemote().sendText(message);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.OnError;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport javax.websocket.server.PathParam;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n@ServerEndpoint(\"/websocket\")\npublic class WebSocket {\n    private Session session;\n    private String name;\n    private static final ConcurrentMap<String, WebSocket> webSocketSet = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session, @PathParam(\"name\") String name) {\n        this.session = session;\n        this.name = name;\n        webSocketSet.put(name, this);\n        notifyAllClients(\"Client \" + name + \" connected\");\n    }\n\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(name);\n        notifyAllClients(\"Client \" + name + \" disconnected\");\n    }\n\n    @OnMessage\n    public void onMessage(String messageStr) {\n        if (messageStr.startsWith(\"GROUP:\")) {\n            String groupMessage = messageStr.substring(6);\n            GroupSending(groupMessage);\n        } else if (messageStr.startsWith(\"PRIVATE:\")) {\n            String[] parts = messageStr.substring(8).split(\":\", 2);\n            if (parts.length == 2) {\n                String targetName = parts[0];\n                String content = parts[1];\n                AppointSending(targetName, content);\n            }\n        } else {\n            GroupSending(messageStr);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error) {\n        error.printStackTrace();\n    }\n\n    public void GroupSending(String message) {\n        for (WebSocket client : webSocketSet.values()) {\n            try {\n                client.session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void AppointSending(String name, String message) {\n        WebSocket targetClient = webSocketSet.get(name);\n        if (targetClient != null) {\n            try {\n                targetClient.session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private void notifyAllClients(String message) {\n        for (WebSocket client : webSocketSet.values()) {\n            try {\n                client.session.getBasicRemote().sendText(message);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 489,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for a chat room application that handles client connections, message broadcasting, and connection termination.\n\nClass Description: The ChatRoomServerEndpoint class is a WebSocket server endpoint that manages a chat room where multiple clients can connect, send messages, and receive broadcasts of all messages. It tracks connected users and handles connection lifecycle events.\n\nAttributes:\n- logger: Logger - Used for logging server activities and errors\n- ONLINE_USER_SESSIONS: Map<String, Session> - Static map storing all active user sessions with usernames as keys (inherited from WebSocketUtils)\n\nMethods:\n- openSession: (@PathParam(\"username\") String username, Session session) -> void - Handles new client connections, adds user to active sessions, and broadcasts welcome message\n- onMessage: (@PathParam(\"username\") String username, String message) -> void - Processes incoming messages from clients and broadcasts them to all connected users\n- onClose: (@PathParam(\"username\") String username, Session session) -> void - Handles client disconnections, removes user from active sessions, and broadcasts departure message\n- onError: (Session session, Throwable throwable) -> void - Handles any errors that occur during WebSocket communication and closes the problematic session",
    "Canonical_solution": "import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\nimport static com.neo.utils.WebSocketUtils.ONLINE_USER_SESSIONS;\nimport static com.neo.utils.WebSocketUtils.sendMessageAll;\n\n@RestController\n@ServerEndpoint(\"/chat-room/{username}\")\npublic class ChatRoomServerEndpoint {\n    private static final Logger logger = LoggerFactory.getLogger(ChatRoomServerEndpoint.class);\n\n    @OnOpen\n    public void openSession(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.put(username, session);\n        String message = \"\u6b22\u8fce\u7528\u6237[\" + username + \"] \u6765\u5230\u804a\u5929\u5ba4\uff01\";\n        logger.info(\"\u7528\u6237\u767b\u5f55\uff1a\"+message);\n        sendMessageAll(message);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"username\") String username, String message) {\n        logger.info(\"\u53d1\u9001\u6d88\u606f\uff1a\"+message);\n        sendMessageAll(\"\u7528\u6237[\" + username + \"] : \" + message);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.remove(username);\n        sendMessageAll(\"\u7528\u6237[\" + username + \"] \u5df2\u7ecf\u79bb\u5f00\u804a\u5929\u5ba4\u4e86\uff01\");\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"onClose error\",e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            logger.error(\"onError excepiton\",e);\n        }\n        logger.info(\"Throwable msg \"+throwable.getMessage());\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "ChatRoomServerEndpoint.java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n@ServerEndpoint(\"/chatroom\")\npublic class ChatRoomServerEndpoint {\n\n    private static final Logger logger = Logger.getLogger(ChatRoomServerEndpoint.class.getName());\n    public static final Map<String, Session> ONLINE_USER_SESSIONS = new java.util.HashMap<>();\n\n    @OnOpen\n    public void openSession(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.put(username, session);\n        logger.info(\"User \" + username + \" connected.\");\n        broadcastWelcome(username);\n    }\n\n    @OnMessage\n    public void onMessage(@PathParam(\"username\") String username, String message) {\n        logger.info(\"User \" + username + \" sent: \" + message);\n        broadcastMessage(username, message);\n    }\n\n    @OnClose\n    public void onClose(@PathParam(\"username\") String username, Session session) {\n        ONLINE_USER_SESSIONS.remove(username);\n        logger.info(\"User \" + username + \" disconnected.\");\n        broadcastDeparture(username);\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        logger.severe(\"Error occurred: \" + throwable.getMessage());\n        try {\n            session.close();\n        } catch (Exception e) {\n            logger.severe(\"Failed to close session: \" + e.getMessage());\n        }\n    }\n\n    private void broadcastWelcome(String username) {\n        for (Map.Entry<String, Session> entry : ONLINE_USER_SESSIONS.entrySet()) {\n            Session session = entry.getValue();\n            if (session.isOpen()) {\n                try {\n                    session.getBasicRemote().sendText(\"User \" + username + \" has joined the chat.\");\n                } catch (Exception e) {\n                    logger.severe(\"Failed to send welcome message: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    private void broadcastMessage(String username, String message) {\n        for (Map.Entry<String, Session> entry : ONLINE_USER_SESSIONS.entrySet()) {\n            Session session = entry.getValue();\n            if (session.isOpen()) {\n                try {\n                    session.getBasicRemote().sendText(username + \": \" + message);\n                } catch (Exception e) {\n                    logger.severe(\"Failed to broadcast message: \" + e.getMessage());\n                }\n            }\n        }\n    }\n\n    private void broadcastDeparture(String username) {\n        for (Map.Entry<String, Session> entry : ONLINE_USER_SESSIONS.entrySet()) {\n            Session session = entry.getValue();\n            if (session.isOpen()) {\n                try {\n                    session.getBasicRemote().sendText(\"User \" + username + \" has left the chat.\");\n                } catch (Exception e) {\n                    logger.severe(\"Failed to send departure message: \" + e.getMessage());\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 490,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java that handles binary data streams from clients and echoes them back.\n\nClass Description: The MyEndpointInputStream class is a WebSocket server endpoint that receives binary data streams from clients and sends back the same data. It uses Java EE's WebSocket API to manage client connections and data exchange.\n\nAttributes: None\n\nMethods:\n1. echoStream(InputStream stream, Session session) -> void - Handles incoming binary data streams from clients. Reads the first 12 bytes from the input stream and sends them back to the client as binary data.\n   - Input Parameters:\n     - stream: InputStream - The binary data stream received from the client\n     - session: Session - The WebSocket session representing the client connection\n   - Return Type: void\n   - Description: This method is triggered when a binary message is received. It reads 12 bytes from the input stream and echoes them back to the client using the session's basic remote interface. The method may throw IOException if there are issues with reading the stream or sending the response.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/inputstream\")\npublic class MyEndpointInputStream {\n\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        System.out.println(\"echoStream: \" + stream);\n        byte[] b = new byte[12];\n        stream.read(b);\n        session.getBasicRemote().sendBinary(ByteBuffer.wrap(b));\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\n@ServerEndpoint(\"/myendpoint\")\npublic class MyEndpointInputStream {\n    @OnMessage\n    public void echoStream(InputStream stream, Session session) throws IOException {\n        byte[] buffer = new byte[12];\n        int bytesRead = stream.read(buffer);\n        if (bytesRead > 0) {\n            session.getBasicRemote().sendBinary(ByteBuffer.wrap(buffer, 0, bytesRead));\n        }\n    }\n}"
  },
  {
    "Task_id": 492,
    "Instruction": "Task Description: Create a WebSocket server endpoint class in Java for deploying containers, handling client connections, and managing deployment processes with error handling.\n\nClass Description: The ContainerDeployServerEndpoint class is a WebSocket server endpoint that facilitates container deployment through WebSocket connections. It handles client connections, initiates container deployment, and manages errors during the process. The class uses Java EE WebSocket API and integrates with a ContainerService for deployment operations.\n\nAttributes:\n- containerService: [ContainerService] - Service responsible for container deployment operations (injected via Spring)\n- log: [Logger] - SLF4J logger instance for logging events and errors (provided by Lombok)\n\nMethods:\n- onOpen: [onOpen](Long id, Session session) -> void - Handles new WebSocket connections. Takes container ID and session as parameters. Sends connection confirmation, initiates deployment, and closes the session. Logs errors if deployment fails.\n- onError: [onError](Session session, Throwable throwable) -> void - Handles WebSocket errors. Takes the session and throwable as parameters. Closes the session and logs the error.\n  \nNote: The class uses @ServerEndpoint annotation to define the WebSocket endpoint path with a configurator, and includes @Component for Spring integration. The endpoint path includes a path parameter for container ID (/container/deploy/{id}).",
    "Canonical_solution": "import tech.powerjob.server.config.OmsEndpointConfigure;\nimport tech.powerjob.server.core.container.ContainerService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport javax.websocket.*;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\n\n@Slf4j\n@Component\n@ServerEndpoint(value = \"/container/deploy/{id}\", configurator = OmsEndpointConfigure.class)\npublic class ContainerDeployServerEndpoint {\n\n    @Resource\n    private ContainerService containerService;\n\n    @OnOpen\n    public void onOpen(@PathParam(\"id\") Long id, Session session) {\n        RemoteEndpoint.Async remote = session.getAsyncRemote();\n        remote.sendText(\"SYSTEM: connected successfully, start to deploy container: \" + id);\n        try {\n            containerService.deploy(id, session);\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] deploy container {} failed.\", id, e);\n            remote.sendText(\"SYSTEM: deploy failed because of the exception\");\n            remote.sendText(ExceptionUtils.getStackTrace(e));\n        }\n        try {\n            session.close();\n        }catch (Exception e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session for {} failed.\", id, e);\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.error(\"[ContainerDeployServerEndpoint] close session failed.\", e);\n        }\n        log.warn(\"[ContainerDeployServerEndpoint] session onError!\", throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnError;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@Component\n@ServerEndpoint(\"/container/deploy/{id}\")\npublic class ContainerDeployServerEndpoint {\n\n    private static final Logger log = LoggerFactory.getLogger(ContainerDeployServerEndpoint.class);\n\n    @Autowired\n    private ContainerService containerService;\n\n    @OnOpen\n    public void onOpen(Long id, Session session) {\n        try {\n            session.getBasicRemote().sendText(\"Connection established\");\n            containerService.deployContainer(id);\n        } catch (Exception e) {\n            log.error(\"Deployment failed for container {}\", id, e);\n        } finally {\n            try {\n                session.close();\n            } catch (IOException e) {\n                log.error(\"Error closing session\", e);\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        try {\n            session.close();\n        } catch (IOException e) {\n            log.error(\"Error closing session\", e);\n        }\n        log.error(\"WebSocket error occurred\", throwable);\n    }\n}"
  },
  {
    "Task_id": 493,
    "Instruction": "Task Description: Implement a WebSocket server endpoint in Java to handle real-time communication between clients, manage client connections, and broadcast messages to all connected clients.\n\nClass Description: MyWebSocket is a Java class that serves as a WebSocket server endpoint. It maintains a list of connected clients, handles connection events, processes incoming messages, and broadcasts messages to all connected clients while also logging messages to a database.\n\nAttributes:\n- onlineCount: [static int] - Tracks the number of currently connected clients\n- webSocketSet: [static CopyOnWriteArraySet<MyWebSocket>] - Thread-safe set containing all active WebSocket sessions\n- session: [Session] - Represents the WebSocket session for a connected client\n- contentService: [ContentService] - Service for persisting messages to a database (autowired via Spring)\n\nMethods:\n- onOpen: [onOpen]([Session session]) -> [void] - Handles new client connections, adds session to the set, and increments online count\n- onClose: [onClose]() -> [void] - Handles client disconnections, removes session from the set, and decrements online count\n- onMessage: [onMessage]([String message, Session session]) -> [void] - Processes incoming messages and broadcasts them to all connected clients\n- onError: [onError]([Session session, Throwable error]) -> [void] - Handles any errors that occur during WebSocket communication\n- sendMessage: [sendMessage]([String message]) -> [void] - Sends a message to the client and persists it to the database\n- getOnlineCount: [getOnlineCount]() -> [int] - Returns the current number of connected clients (synchronized)\n- addOnlineCount: [addOnlineCount]() -> [void] - Increments the online client count (synchronized)\n- subOnlineCount: [subOnlineCount]() -> [void] - Decrements the online client count (synchronized)",
    "Canonical_solution": "import com.crossoverJie.pojo.Content;\nimport com.crossoverJie.service.ContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.socket.server.standard.SpringConfigurator;\n\nimport javax.websocket.*;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@ServerEndpoint(value = \"/websocket\",configurator = SpringConfigurator.class)\npublic class MyWebSocket {\n    private static int onlineCount = 0;\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<MyWebSocket>();\n    private Session session;\n\n    @Autowired\n    private ContentService contentService;\n\n    @OnOpen\n    public void onOpen(Session session){\n        this.session = session;\n        webSocketSet.add(this);\n        addOnlineCount();\n        System.out.println(\"\u6709\u65b0\u8fde\u63a5\u52a0\u5165\uff01\u5f53\u524d\u5728\u7ebf\u4eba\u6570\u4e3a\" + getOnlineCount());\n    }\n\n    @OnClose\n    public void onClose(){\n        webSocketSet.remove(this);\n        subOnlineCount();\n        System.out.println(\"\u6709\u4e00\u8fde\u63a5\u5173\u95ed\uff01\u5f53\u524d\u5728\u7ebf\u4eba\u6570\u4e3a\" + getOnlineCount());\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u6d88\u606f:\" + message);\n        for(MyWebSocket item: webSocketSet){\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n                continue;\n            }\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable error){\n        System.out.println(\"\u53d1\u751f\u9519\u8bef\");\n        error.printStackTrace();\n    }\n\n    public void sendMessage(String message) throws IOException{\n        Content content = new Content() ;\n        content.setContent(message);\n        SimpleDateFormat sm = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:dd\") ;\n        content.setCreatedate(sm.format(new Date()));\n        contentService.insertSelective(content) ;\n        this.session.getBasicRemote().sendText(message);\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        MyWebSocket.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        MyWebSocket.onlineCount--;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\n@Component\n@ServerEndpoint(\"/websocket\")\npublic class MyWebSocket {\n\n    public static int onlineCount;\n    public static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<>();\n\n    private Session session;\n    @Autowired\n    private ContentService contentService;\n\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        webSocketSet.add(this);\n        addOnlineCount();\n    }\n\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this);\n        subOnlineCount();\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        contentService.persist(message);\n        broadcast(message);\n    }\n\n    public void sendMessage(String message) {\n        try {\n            session.getAsyncRemote().sendText(message);\n            contentService.persist(message);\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n\n    public int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public synchronized void addOnlineCount() {\n        onlineCount++;\n    }\n\n    public synchronized void subOnlineCount() {\n        onlineCount--;\n    }\n\n    private void broadcast(String message) {\n        for (MyWebSocket client : webSocketSet) {\n            client.sendMessage(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 494,
    "Instruction": "Task Description: Implement a WebSocket server endpoint for a chat application that broadcasts received messages to all connected clients.\n\nClass Description: The ChatEndpoint class represents a WebSocket server endpoint that handles real-time chat communication. It listens for incoming messages and broadcasts them to all currently connected clients.\n\nAttributes: None\n\nMethods:\n- message: [Name](String message, Session client) -> void - Handles incoming WebSocket messages. Receives a message string and the client session that sent it, then broadcasts the message to all connected sessions.\n  - Input Parameters:\n    - message: String - The chat message received from a client\n    - client: Session - The WebSocket session of the client that sent the message\n  - Output: None (messages are sent directly to client sessions)\n  - Throws: IOException, EncodeException - If there are issues sending messages to clients",
    "Canonical_solution": "import java.io.IOException;\nimport javax.websocket.EncodeException;\nimport javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatEndpoint {\n    @OnMessage\n    public void message(String message, Session client) throws IOException, EncodeException {\n        System.out.println(\"message: \" + message);\n        for (Session peer : client.getOpenSessions()) {\n            peer.getBasicRemote().sendText(message);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 26,
    "right_result": "import javax.websocket.OnMessage;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatEndpoint extends Endpoint {\n    private static final Set<Session> connectedSessions = new HashSet<>();\n\n    @Override\n    public void onOpen(Session session) {\n        connectedSessions.add(session);\n    }\n\n    @Override\n    public void onClose(Session session, int closeCode, String reason) {\n        connectedSessions.remove(session);\n    }\n\n    @OnMessage\n    public void message(String message, Session client) throws IOException, EncodeException {\n        for (Session session : connectedSessions) {\n            session.getBasicRemote().sendText(message);\n        }\n    }\n}"
  },
  {
    "Task_id": 496,
    "Instruction": "Task Description: Create a gRPC client class in Java that checks the health of a gRPC server using the gRPC Health Checking Protocol.\n\nClass Description: The GrpcHealthClient class establishes a connection to a gRPC server and provides functionality to check the server's health status. It manages the gRPC channel and stub for communication with the server.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- stub: [HealthStub] - The asynchronous gRPC stub for health check operations\n\nMethods:\n- GrpcHealthClient(String host, int port) -> [void] - Constructor that initializes the gRPC channel and stub with the specified server host and port\n- checkHealth() -> [HealthCheckResponse] - Sends a health check request to the server and returns the response\n- shutdown() -> [void] - Shuts down the gRPC channel gracefully",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.health.v1.HealthCheckRequest;\nimport io.grpc.health.v1.HealthCheckResponse;\nimport io.grpc.health.v1.HealthGrpc;\nimport io.grpc.health.v1.HealthGrpc.HealthStub;\n\npublic class GrpcHealthClient {\n\n    private final ManagedChannel channel;\n    private final HealthStub stub;\n\n    public GrpcHealthClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.stub = HealthGrpc.newStub(channel);\n    }\n\n    public HealthCheckResponse checkHealth() {\n        HealthCheckRequest request = HealthCheckRequest.getDefaultInstance();\n        AwaitableStreamObserver<HealthCheckResponse> responseObserver = new AwaitableStreamObserver<>();\n        stub.check(request, responseObserver);\n        return responseObserver.getSingle();\n    }\n\n    public void shutdown() {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.health.v1.HealthCheckRequest;\nimport io.grpc.health.v1.HealthCheckResponse;\nimport io.grpc.health.v1.HealthGrpc;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrpcHealthClient {\n    private ManagedChannel channel;\n    private HealthGrpc.HealthBlockingStub stub;\n\n    public GrpcHealthClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.stub = HealthGrpc.newBlockingStub(channel);\n    }\n\n    public HealthCheckResponse checkHealth() {\n        HealthCheckRequest request = HealthCheckRequest.newBuilder().setService(\"\").build();\n        return stub.check(request);\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdownGracefully().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}"
  },
  {
    "Task_id": 497,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for interacting with a database service, allowing for retrieval of blockchain data and dynamic properties.\n\nClass Description: The DatabaseGrpcClient class provides a gRPC client implementation for connecting to a database service. It establishes a connection to a gRPC server, provides methods to retrieve blockchain blocks and dynamic properties, and handles connection shutdown.\n\nAttributes:\n- channel: [ManagedChannel] - The communication channel between the client and the gRPC server\n- databaseBlockingStub: [DatabaseGrpc.DatabaseBlockingStub] - The blocking stub used to make synchronous RPC calls to the server\n\nMethods:\n- Constructor: [DatabaseGrpcClient](String host, int port) -> [void] - Creates a new client instance connecting to the specified host and port\n- Constructor: [DatabaseGrpcClient](String host) -> [void] - Creates a new client instance connecting to the specified host (using default port)\n- getBlock: [getBlock](long blockNum) -> [Block] - Retrieves a block from the blockchain; if blockNum is negative, returns the latest block\n- shutdown: [shutdown]() -> [void] - Shuts down the connection channel\n- getDynamicProperties: [getDynamicProperties]() -> [DynamicProperties] - Retrieves the dynamic properties of the blockchain",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.DatabaseGrpc;\nimport org.tron.api.GrpcAPI.EmptyMessage;\nimport org.tron.api.GrpcAPI.NumberMessage;\nimport org.tron.protos.Protocol.Block;\nimport org.tron.protos.Protocol.DynamicProperties;\n\npublic class DatabaseGrpcClient {\n\n  private final ManagedChannel channel;\n  private final DatabaseGrpc.DatabaseBlockingStub databaseBlockingStub;\n\n  public DatabaseGrpcClient(String host, int port) {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext()\n        .build();\n    databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n  }\n\n  public DatabaseGrpcClient(String host) {\n    channel = ManagedChannelBuilder.forTarget(host)\n        .usePlaintext()\n        .build();\n    databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n  }\n\n  public Block getBlock(long blockNum) {\n    if (blockNum < 0) {\n      return databaseBlockingStub.getNowBlock(EmptyMessage.newBuilder().build());\n    }\n    NumberMessage.Builder builder = NumberMessage.newBuilder();\n    builder.setNum(blockNum);\n    return databaseBlockingStub.getBlockByNum(builder.build());\n  }\n\n  public void shutdown() {\n    channel.shutdown();\n  }\n\n  public DynamicProperties getDynamicProperties() {\n    return databaseBlockingStub.getDynamicProperties(EmptyMessage.newBuilder().build());\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.stub.StreamObserver;\nimport com.example.database.DatabaseGrpc;\nimport com.example.database.DatabaseBlockingStub;\nimport com.example.database.Block;\nimport com.example.database.DynamicProperties;\nimport com.example.database.GetBlockRequest;\nimport com.example.database.DynamicPropertiesRequest;\n\npublic class DatabaseGrpcClient {\n    private ManagedChannel channel;\n    private DatabaseBlockingStub databaseBlockingStub;\n\n    public DatabaseGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port).usePlaintext().build();\n        this.databaseBlockingStub = DatabaseGrpc.newBlockingStub(channel);\n    }\n\n    public DatabaseGrpcClient(String host) {\n        this(host, 50051);\n    }\n\n    public Block getBlock(long blockNum) {\n        if (blockNum < 0) {\n            blockNum = 0;\n        }\n        return databaseBlockingStub.getBlock(GetBlockRequest.newBuilder().setBlockNum(blockNum).build());\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdown();\n        }\n    }\n\n    public DynamicProperties getDynamicProperties() {\n        return databaseBlockingStub.getDynamicProperties(DynamicPropertiesRequest.getDefaultInstance());\n    }\n}"
  },
  {
    "Task_id": 5,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java.\n\nFunction Description: This function creates a new topic in a Kafka cluster using the AdminClient API. It establishes a connection to the Kafka broker, defines the topic configuration (name, partition count, and replication factor), and creates the topic. The function ensures proper resource cleanup by closing the AdminClient after topic creation.\n\nInput:\n- brokerAddress: String - The address of the Kafka broker to connect to (e.g., \"localhost:9092\")\n- topicName: String - The name of the topic to be created\n- partitionCount: int - The number of partitions for the topic\n- replicationFactor: short - The replication factor for the topic\n\nOutput: void - The function does not return any value but creates the specified topic in the Kafka cluster. Any exceptions during topic creation will be thrown to the caller.\n\nNote: The function handles resource cleanup by closing the AdminClient in a finally block to prevent resource leaks.",
    "Canonical_solution": "import java.util.Collections;\nimport java.util.Map;\nimport org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\n\npublic void testDiskFailure() throws IOException {\n    AdminClient adminClient = KafkaCruiseControlUtils.createAdminClient(Collections\n        .singletonMap(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, broker(0).plaintextAddr()));\n    try {\n        adminClient.createTopics(Collections.singleton(new NewTopic(TOPIC0, PARTITION_COUNT, TOPIC0_REPLICATION_FACTOR)));\n    } finally {\n        KafkaCruiseControlUtils.closeAdminClientWithTimeout(adminClient);\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport java.util.Properties;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\n\npublic class KafkaTopicCreator {\n    public void createKafkaTopic(String brokerAddress, String topicName, int partitionCount, short replicationFactor) {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, brokerAddress);\n        AdminClient adminClient = null;\n        try {\n            adminClient = AdminClient.create(props);\n            NewTopic newTopic = new NewTopic(topicName, partitionCount, replicationFactor);\n            CreateTopicsResult result = adminClient.createTopics(Collections.singletonMap(topicName, newTopic));\n            result.all().get();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create Kafka topic\", e);\n        } finally {\n            if (adminClient != null) {\n                adminClient.close();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 501,
    "Instruction": "Task Description: Create a gRPC client class in Java for interacting with a Tron blockchain wallet service, implementing various wallet operations through gRPC calls.\n\nClass Description: The WalletGrpcClient class provides a Java interface to interact with a Tron blockchain node's wallet service using gRPC. It handles connection management and provides methods for account queries, transaction creation, and blockchain data retrieval.\n\nAttributes:\n- channel: [ManagedChannel] - The gRPC communication channel to the server\n- walletBlockingStub: [WalletGrpc.WalletBlockingStub] - The blocking stub for making synchronous RPC calls\n\nMethods:\n- WalletGrpcClient(String host, int port) - Constructor - Creates a client connecting to specified host and port\n- WalletGrpcClient(String host) - Constructor - Creates a client connecting to specified host (using target format)\n- shutdown() -> void - Shuts down the channel with 5-second timeout\n- queryAccount(byte[] address) -> Account - Queries account information by address\n- createTransaction(TransferContract contract) -> Transaction - Creates a transfer transaction\n- createTransferAssetTransaction(TransferAssetContract contract) -> Transaction - Creates an asset transfer transaction\n- createParticipateAssetIssueTransaction(ParticipateAssetIssueContract contract) -> Transaction - Creates an asset participation transaction\n- createAssetIssue(AssetIssueContract contract) -> Transaction - Creates an asset issuance transaction\n- voteWitnessAccount(VoteWitnessContract contract) -> Transaction - Creates a witness voting transaction\n- createWitness(WitnessCreateContract contract) -> Transaction - Creates a witness creation transaction\n- broadcastTransaction(Transaction signedTransaction) -> boolean - Broadcasts a signed transaction to network\n- getBlock(long blockNum) -> Block - Retrieves block by number (or latest if negative)\n- listNodes() -> Optional<NodeList> - Lists connected nodes\n- getAssetIssueByAccount(byte[] address) -> Optional<AssetIssueList> - Gets assets issued by account\n- getAssetIssueByName(String assetName) -> AssetIssueContract - Gets asset by name\n- getAssetIssueListByName(String assetName) -> Optional<AssetIssueList> - Gets asset list by name\n- getAssetIssueById(String assetId) -> AssetIssueContract - Gets asset by ID",
    "Canonical_solution": "import com.google.protobuf.ByteString;\nimport io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport java.util.Optional;\nimport java.util.concurrent.TimeUnit;\nimport org.tron.api.GrpcAPI.AssetIssueList;\nimport org.tron.api.GrpcAPI.BytesMessage;\nimport org.tron.api.GrpcAPI.EmptyMessage;\nimport org.tron.api.GrpcAPI.NodeList;\nimport org.tron.api.GrpcAPI.NumberMessage;\nimport org.tron.api.GrpcAPI.Return;\nimport org.tron.api.WalletGrpc;\nimport org.tron.protos.Protocol.Account;\nimport org.tron.protos.Protocol.Block;\nimport org.tron.protos.Protocol.Transaction;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.AssetIssueContract;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.ParticipateAssetIssueContract;\nimport org.tron.protos.contract.AssetIssueContractOuterClass.TransferAssetContract;\nimport org.tron.protos.contract.BalanceContract.TransferContract;\nimport org.tron.protos.contract.WitnessContract.VoteWitnessContract;\nimport org.tron.protos.contract.WitnessContract.WitnessCreateContract;\n\npublic class WalletGrpcClient {\n\n  private final ManagedChannel channel;\n  private final WalletGrpc.WalletBlockingStub walletBlockingStub;\n\n  public WalletGrpcClient(String host, int port) {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext()\n        .build();\n    walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n  }\n\n  public WalletGrpcClient(String host) {\n    channel = ManagedChannelBuilder.forTarget(host)\n        .usePlaintext()\n        .build();\n    walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n  }\n\n  public void shutdown() throws InterruptedException {\n    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n  }\n\n  public Account queryAccount(byte[] address) {\n    ByteString addressByteString = ByteString.copyFrom(address);\n    Account request = Account.newBuilder().setAddress(addressByteString).build();\n    return walletBlockingStub.getAccount(request);\n  }\n\n  public Transaction createTransaction(TransferContract contract) {\n    return walletBlockingStub.createTransaction(contract);\n  }\n\n  public Transaction createTransferAssetTransaction(TransferAssetContract contract) {\n    return walletBlockingStub.transferAsset(contract);\n  }\n\n  public Transaction createParticipateAssetIssueTransaction(\n      ParticipateAssetIssueContract contract) {\n    return walletBlockingStub.participateAssetIssue(contract);\n  }\n\n  public Transaction createAssetIssue(AssetIssueContract contract) {\n    return walletBlockingStub.createAssetIssue(contract);\n  }\n\n  public Transaction voteWitnessAccount(VoteWitnessContract contract) {\n    return walletBlockingStub.voteWitnessAccount(contract);\n  }\n\n  public Transaction createWitness(WitnessCreateContract contract) {\n    return walletBlockingStub.createWitness(contract);\n  }\n\n  public boolean broadcastTransaction(Transaction signedTransaction) {\n    Return response = walletBlockingStub.broadcastTransaction(signedTransaction);\n    return response.getResult();\n  }\n\n  public Block getBlock(long blockNum) {\n    if (blockNum < 0) {\n      return walletBlockingStub.getNowBlock(EmptyMessage.newBuilder().build());\n    }\n    NumberMessage.Builder builder = NumberMessage.newBuilder();\n    builder.setNum(blockNum);\n    return walletBlockingStub.getBlockByNum(builder.build());\n  }\n\n  public Optional<NodeList> listNodes() {\n    NodeList nodeList = walletBlockingStub\n        .listNodes(EmptyMessage.newBuilder().build());\n    if (nodeList != null) {\n      return Optional.of(nodeList);\n    }\n    return Optional.empty();\n  }\n\n  public Optional<AssetIssueList> getAssetIssueByAccount(byte[] address) {\n    ByteString addressByteString = ByteString.copyFrom(address);\n    Account request = Account.newBuilder().setAddress(addressByteString).build();\n    AssetIssueList assetIssueList = walletBlockingStub\n        .getAssetIssueByAccount(request);\n    if (assetIssueList != null) {\n      return Optional.of(assetIssueList);\n    }\n    return Optional.empty();\n  }\n\n  public AssetIssueContract getAssetIssueByName(String assetName) {\n    ByteString assetNameBs = ByteString.copyFrom(assetName.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetNameBs).build();\n    return walletBlockingStub.getAssetIssueByName(request);\n  }\n\n  public Optional<AssetIssueList> getAssetIssueListByName(String assetName) {\n    ByteString assetNameBs = ByteString.copyFrom(assetName.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetNameBs).build();\n\n    AssetIssueList assetIssueList = walletBlockingStub\n        .getAssetIssueListByName(request);\n    if (assetIssueList != null) {\n      return Optional.of(assetIssueList);\n    }\n    return Optional.empty();\n  }\n\n  public AssetIssueContract getAssetIssueById(String assetId) {\n    ByteString assetIdBs = ByteString.copyFrom(assetId.getBytes());\n    BytesMessage request = BytesMessage.newBuilder().setValue(assetIdBs).build();\n    return walletBlockingStub.getAssetIssueById(request);\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.Optional;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.nio.ByteString;\n\npublic class WalletGrpcClient {\n    private final ManagedChannel channel;\n    private final WalletGrpc.WalletBlockingStub walletBlockingStub;\n\n    public WalletGrpcClient(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpcClient(String host) {\n        this.channel = ManagedChannelBuilder.forTarget(host)\n                .usePlaintext()\n                .build();\n        this.walletBlockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdown();\n            try {\n                channel.awaitTermination(5, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public Account queryAccount(byte[] address) {\n        GetAccountRequest request = GetAccountRequest.newBuilder()\n                .setAddress(ByteString.copyFrom(address))\n                .build();\n        GetAccountResponse response = walletBlockingStub.queryAccount(request);\n        return response.getAccount();\n    }\n\n    public Transaction createTransaction(TransferContract contract) {\n        CreateTransactionRequest request = CreateTransactionRequest.newBuilder()\n                .setTransferContract(contract)\n                .build();\n        CreateTransactionResponse response = walletBlockingStub.createTransaction(request);\n        return response.getTransaction();\n    }\n\n    public Transaction createTransferAssetTransaction(TransferAssetContract contract) {\n        CreateTransactionRequest request = CreateTransactionRequest.newBuilder()\n                .setTransferAssetContract(contract)\n                .build();\n        CreateTransactionResponse response = walletBlockingStub.createTransferAssetTransaction(request);\n        return response.getTransaction();\n    }\n\n    public Transaction createParticipateAssetIssueTransaction(ParticipateAssetIssueContract contract) {\n        CreateTransactionRequest request = CreateTransactionRequest.newBuilder()\n                .setParticipateAssetIssueContract(contract)\n                .build();\n        CreateTransactionResponse response = walletBlockingStub.createParticipateAssetIssueTransaction(request);\n        return response.getTransaction();\n    }\n\n    public Transaction createAssetIssue(AssetIssueContract contract) {\n        CreateTransactionRequest request = CreateTransactionRequest.newBuilder()\n                .setAssetIssueContract(contract)\n                .build();\n        CreateTransactionResponse response = walletBlockingStub.createAssetIssue(request);\n        return response.getTransaction();\n    }\n\n    public Transaction voteWitnessAccount(VoteWitnessContract contract) {\n        CreateTransactionRequest request = CreateTransactionRequest.newBuilder()\n                .setVoteWitnessContract(contract)\n                .build();\n        CreateTransactionResponse response = walletBlockingStub.voteWitnessAccount(request);\n        return response.getTransaction();\n    }\n\n    public Transaction createWitness(WitnessCreateContract contract) {\n        CreateTransactionRequest request = CreateTransactionRequest.newBuilder()\n                .setWitnessCreateContract(contract)\n                .build();\n        CreateTransactionResponse response = walletBlockingStub.createWitness(request);\n        return response.getTransaction();\n    }\n\n    public boolean broadcastTransaction(Transaction signedTransaction) {\n        BroadcastTransactionRequest request = BroadcastTransactionRequest.newBuilder()\n                .setTransaction(signedTransaction)\n                .build();\n        BroadcastTransactionResponse response = walletBlockingStub.broadcastTransaction(request);\n        return response.getSuccess();\n    }\n\n    public Block getBlock(long blockNum) {\n        GetBlockRequest request = GetBlockRequest.newBuilder()\n                .setBlockNum(blockNum < 0 ? 0 : blockNum)\n                .build();\n        GetBlockResponse response = walletBlockingStub.getBlock(request);\n        return response.getBlock();\n    }\n\n    public Optional<NodeList> listNodes() {\n        ListNodesRequest request = ListNodesRequest.getDefaultInstance();\n        ListNodesResponse response = walletBlockingStub.listNodes(request);\n        return Optional.ofNullable(response.getNodeList());\n    }\n\n    public Optional<AssetIssueList> getAssetIssueByAccount(byte[] address) {\n        GetAssetIssueByAccountRequest request = GetAssetIssueByAccountRequest.newBuilder()\n                .setAddress(ByteString.copyFrom(address))\n                .build();\n        GetAssetIssueByAccountResponse response = walletBlockingStub.getAssetIssueByAccount(request);\n        return Optional.ofNullable(response.getAssetIssueList());\n    }\n\n    public AssetIssueContract getAssetIssueByName(String assetName) {\n        GetAssetIssueByNameRequest request = GetAssetIssueByNameRequest.newBuilder()\n                .setAssetName(assetName)\n                .build();\n        GetAssetIssueByNameResponse response = walletBlockingStub.getAssetIssueByName(request);\n        return response.getAssetIssueContract();\n    }\n\n    public Optional<AssetIssueList> getAssetIssueListByName(String assetName) {\n        GetAssetIssueListByNameRequest request = GetAssetIssueListByNameRequest.newBuilder()\n                .setAssetName(assetName)\n                .build();\n        GetAssetIssueListByNameResponse response = walletBlockingStub.getAssetIssueListByName(request);\n        return Optional.ofNullable(response.getAssetIssueList());\n    }\n\n    public AssetIssueContract getAssetIssueById(String assetId) {\n        GetAssetIssueByIdRequest request = GetAssetIssueByIdRequest.newBuilder()\n                .setAssetId(assetId)\n                .build();\n        GetAssetIssueByIdResponse response = walletBlockingStub.getAssetIssueById(request);\n        return response.getAssetIssueContract();\n    }\n}"
  },
  {
    "Task_id": 503,
    "Instruction": "Task Description: Create a Java class that implements a gRPC client for establishing and managing connections to a gRPC server, with methods to start the connection, retrieve the blocking stub, and shutdown the connection.\n\nClass Description: The GrpcClient class provides functionality to connect to a gRPC server using a ManagedChannel, create a blocking stub for synchronous communication, and properly shutdown the connection when done.\n\nAttributes:\n- channel: [ManagedChannel] - The channel used to communicate with the gRPC server\n- blockingStub: [WalletGrpc.WalletBlockingStub] - The blocking stub used to make synchronous RPC calls\n\nMethods:\n- startConnection(String host, int port) -> void - Establishes a connection to the gRPC server at the specified host and port, creating both the ManagedChannel and blocking stub\n- getBlockingStub() -> WalletGrpc.WalletBlockingStub - Returns the blocking stub for making RPC calls\n- shutdown() -> void - Shuts down the channel connection, waiting for up to 5 seconds for termination",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport org.tron.api.WalletGrpc;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrpcClient {\n\n    private ManagedChannel channel;\n    private WalletGrpc.WalletBlockingStub blockingStub;\n\n    public void startConnection(String host, int port) {\n        channel = ManagedChannelBuilder.forAddress(host, port)\n            .usePlaintext()\n            .build();\n        blockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpc.WalletBlockingStub getBlockingStub() {\n        return blockingStub;\n    }\n\n    public void shutdown() throws InterruptedException {\n        if (channel != null) {\n            channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.StatusRuntimeException;\nimport java.util.concurrent.TimeUnit;\n\npublic class GrpcClient {\n    private ManagedChannel channel;\n    private WalletGrpc.WalletBlockingStub blockingStub;\n\n    public void startConnection(String host, int port) {\n        this.channel = ManagedChannelBuilder.forAddress(host, port)\n                .usePlaintext()\n                .build();\n        this.blockingStub = WalletGrpc.newBlockingStub(channel);\n    }\n\n    public WalletGrpc.WalletBlockingStub getBlockingStub() {\n        return blockingStub;\n    }\n\n    public void shutdown() {\n        if (channel != null) {\n            channel.shutdown();\n            try {\n                if (!channel.awaitTermination(5, TimeUnit.SECONDS)) {\n                    channel.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 504,
    "Instruction": "Task Description: Implement a function to test the gRPC Server Reflection service by establishing a connection to a gRPC server, sending a reflection request, and processing the response.\n\nFunction Description: The function connects to a gRPC server running on localhost at port 9090 using plaintext communication. It creates an asynchronous stub for the Server Reflection service, sends a request to list all available services, and processes the response. The function ensures proper cleanup by shutting down the channel after completion.\n\nInput: None (The target server address is hardcoded as \"localhost:9090\")\n\nOutput: None (The function processes the reflection response internally via the checkResult method, which is not shown in the reference code)",
    "Canonical_solution": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc;\nimport io.grpc.reflection.v1alpha.ServerReflectionGrpc.ServerReflectionStub;\nimport io.grpc.reflection.v1alpha.ServerReflectionRequest;\nimport io.grpc.reflection.v1alpha.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\n\nvoid testReflectionService() {\n    final ManagedChannel channel = ManagedChannelBuilder.forTarget(\"localhost:9090\").usePlaintext().build();\n    try {\n        final ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n\n        final AwaitableStreamObserver<ServerReflectionResponse> resultObserver = new AwaitableStreamObserver<>();\n        final StreamObserver<ServerReflectionRequest> requestObserver = stub.serverReflectionInfo(resultObserver);\n        requestObserver.onNext(ServerReflectionRequest.newBuilder()\n                .setListServices(\"\")\n                .build());\n        requestObserver.onCompleted();\n        checkResult(resultObserver);\n    } finally {\n        channel.shutdown();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 23,
    "right_result": "import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport io.grpc.ServerReflectionGrpc;\nimport io.grpc.ServerReflectionRequest;\nimport io.grpc.ServerReflectionResponse;\nimport io.grpc.stub.StreamObserver;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestServerReflection {\n    public static void testServerReflection() {\n        ManagedChannel channel = ManagedChannelBuilder.forAddress(\"localhost\", 9090)\n                .usePlaintext()\n                .build();\n        CountDownLatch latch = new CountDownLatch(1);\n        try {\n            ServerReflectionGrpc.ServerReflectionStub stub = ServerReflectionGrpc.newStub(channel);\n            ServerReflectionRequest request = ServerReflectionRequest.newBuilder()\n                    .setType(ServerReflectionRequest.Type.LIST_SERVICES)\n                    .build();\n            StreamObserver<ServerReflectionResponse> responseObserver = new StreamObserver<ServerReflectionResponse>() {\n                @Override\n                public void onNext(ServerReflectionResponse response) {\n                    // Process the response internally via checkResult method\n                }\n\n                @Override\n                public void onError(Throwable t) {\n                    System.err.println(\"Error occurred: \" + t.getMessage());\n                    latch.countDown();\n                }\n\n                @Override\n                public void onCompleted() {\n                    System.out.println(\"Server reflection completed.\");\n                    latch.countDown();\n                }\n            };\n            stub.listServices(request, responseObserver);\n            latch.await();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            System.err.println(\"Interrupted: \" + e.getMessage());\n        } finally {\n            channel.shutdown();\n        }\n    }\n}"
  },
  {
    "Task_id": 506,
    "Instruction": "Task Description: Implement a gRPC server in Java that handles streaming requests and responses, following the structure and functionality of the provided reference code.\n\nClass Description: The HelloWorldServer class represents a gRPC server that listens on a specified port and provides a streaming greeting service. It manages server lifecycle operations (start, stop, await termination) and implements the gRPC service interface for handling client requests.\n\nAttributes:\n- server: [Server] - The gRPC server instance that handles incoming requests\n- logger: [Logger] - Logger instance for server activity logging\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50051 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting.\n\nNested Class:\n- GreeterImpl: [StreamingGreeterGrpc.StreamingGreeterImplBase] - Implements the gRPC service interface with streaming capabilities\n  Methods:\n  - sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) -> [void] - Handles client requests by sending multiple greeting responses in a stream. Takes a HelloRequest containing the client's name and a StreamObserver for sending responses. Sends three greeting messages with increasing excitement, then completes the stream.",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.examples.streaming.HelloReply;\nimport io.grpc.examples.streaming.HelloRequest;\nimport io.grpc.examples.streaming.StreamingGreeterGrpc;\nimport io.grpc.stub.StreamObserver;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n  private static final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n  private Server server;\n\n  public void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new GreeterImpl()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread() {\n              @Override\n              public void run() {\n                System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                HelloWorldServer.this.stop();\n                System.err.println(\"*** server shut down\");\n              }\n            });\n  }\n\n  public void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  public void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  static class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n    @Override\n    public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n      try {\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName()).build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!\").build());\n        Thread.sleep(100);\n        logger.info(\"Saying hi\");\n        responseObserver.onNext(\n            HelloReply.newBuilder().setMessage(\"Hello \" + req.getName() + \"!!\").build());\n      } catch (InterruptedException e) {\n        responseObserver.onError(e);\n      } finally {\n        responseObserver.onCompleted();\n      }\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.StreamObserver;\nimport java.util.logging.Logger;\n\npublic class HelloWorldServer {\n    private Server server;\n    private final Logger logger = Logger.getLogger(HelloWorldServer.class.getName());\n\n    public void start() throws IOException {\n        try {\n            server = ServerBuilder.forPort(50051)\n                    .addService(new GreeterImpl())\n                    .build()\n                    .start();\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                try {\n                    stop();\n                } catch (InterruptedException e) {\n                    logger.severe(\"Interrupted during shutdown\");\n                }\n            }));\n            logger.info(\"Server started, listening on \" + server.getPort());\n        } catch (Exception e) {\n            throw new IOException(\"Failed to start server\", e);\n        }\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    private class GreeterImpl extends StreamingGreeterGrpc.StreamingGreeterImplBase {\n        @Override\n        public void sayHelloStreaming(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n            String name = req.getName();\n            HelloReply reply1 = HelloReply.newBuilder().setMessage(\"Hello, \" + name).build();\n            HelloReply reply2 = HelloReply.newBuilder().setMessage(\"Hello again, \" + name).build();\n            HelloReply reply3 = HelloReply.newBuilder().setMessage(\"Hello once more, \" + name).build();\n            responseObserver.onNext(reply1);\n            responseObserver.onNext(reply2);\n            responseObserver.onNext(reply3);\n            responseObserver.onCompleted();\n        }\n    }\n}"
  },
  {
    "Task_id": 507,
    "Instruction": "Task Description: Create a gRPC server in Java that can handle multiple services, manage interceptors, and provide service discovery capabilities.\n\nClass Description: The GrpcServer class is responsible for initializing and managing a gRPC server instance. It handles server configuration, service registration, interceptor management, and provides methods for service discovery. The server can be started and stopped gracefully, and it maintains mappings of services and methods for lookup purposes.\n\nAttributes:\n- server: [Server] - The gRPC server instance\n- serviceNameMap: [Map<String, Class<? extends BindableService>>] - Mapping of service names to their implementation classes\n- fullMethodNameMap: [Map<String, Method>] - Mapping of full method names to their corresponding Method objects\n\nMethods:\n- GrpcServer: [Constructor](GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Initializes the server with given properties, interceptors and services\n- GrpcServer: [Constructor](ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) -> [void] - Alternative constructor accepting a pre-configured ServerBuilder\n- isRunning: [isRunning]() -> [boolean] - Checks if the server is currently running\n- port: [port]() -> [int] - Returns the port number the server is listening on\n- findClass: [findClass](ServiceDescriptor descriptor) -> [Class<? extends BindableService>] - Finds the implementation class for a given service descriptor\n- findMethod: [findMethod](MethodDescriptor<?, ?> descriptor) -> [Method] - Finds the Method object for a given method descriptor\n- resolve: [resolve](MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) -> [Method] - Resolves the Method object for a given method descriptor within a service class\n- onApplicationStart: [onApplicationStart]() -> [void] - Starts the server and begins awaiting termination\n- onApplicationStop: [onApplicationStop]() -> [void] - Shuts down the server gracefully",
    "Canonical_solution": "import io.grpc.BindableService;\nimport io.grpc.MethodDescriptor;\nimport io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.ServerInterceptor;\nimport io.grpc.ServerMethodDefinition;\nimport io.grpc.ServerServiceDefinition;\nimport io.grpc.ServiceDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.TimeUnit;\nimport org.ballcat.common.core.compose.ContextComponent;\nimport org.ballcat.common.thread.ThreadPool;\nimport org.ballcat.common.util.ClassUtils;\nimport org.ballcat.grpc.server.properties.GrpcServerProperties;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\n\npublic class GrpcServer implements ContextComponent {\n\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap;\n    private final Map<String, Method> fullMethodNameMap;\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        this(ServerBuilder.forPort(properties.getPort()), properties, interceptors, services);\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors,\n            List<BindableService> services) {\n        builder\n            .maxInboundMessageSize((int) properties.getMessageSize().toBytes())\n            .keepAliveTime(properties.getKeepAliveTime(), TimeUnit.MILLISECONDS)\n            .keepAliveTimeout(properties.getKeepAliveTimeout(), TimeUnit.MILLISECONDS);\n\n        interceptors.sort(AnnotationAwareOrderComparator.INSTANCE);\n        ListIterator<ServerInterceptor> iterator = interceptors.listIterator(interceptors.size());\n        while (iterator.hasPrevious()) {\n            builder.intercept(iterator.previous());\n        }\n\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n\n        for (BindableService service : services) {\n            builder.addService(service);\n            Class<? extends BindableService> cls = service.getClass();\n            ServerServiceDefinition serverServiceDefinition = service.bindService();\n            ServiceDescriptor serviceDescriptor = serverServiceDefinition.getServiceDescriptor();\n\n            this.serviceNameMap.put(serviceDescriptor.getName(), cls);\n\n            for (ServerMethodDefinition<?, ?> serverMethodDefinition : serverServiceDefinition.getMethods()) {\n                MethodDescriptor<?, ?> methodDescriptor = serverMethodDefinition.getMethodDescriptor();\n                String fullMethodName = methodDescriptor.getFullMethodName();\n                this.fullMethodNameMap.put(fullMethodName, resolve(methodDescriptor, cls));\n            }\n        }\n\n        this.server = builder.build();\n    }\n\n    public boolean isRunning() {\n        return !this.server.isShutdown() && !this.server.isTerminated();\n    }\n\n    public int port() {\n        return this.server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return this.serviceNameMap.get(descriptor.getName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return this.fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    protected Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        String bareMethodName = descriptor.getBareMethodName();\n        for (Method method : ClassUtils.methods(cls)) {\n            if (Objects.equals(method.getName(), bareMethodName)) {\n                return method;\n            }\n        }\n        return null;\n    }\n\n    public void onApplicationStart() {\n        this.server.start();\n        ThreadPool.instance().execute(\"GrpcServer\", this.server::awaitTermination);\n    }\n\n    public void onApplicationStop() {\n        this.server.shutdownNow();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport io.grpc.BindableService;\nimport io.grpc.ServiceDescriptor;\nimport io.grpc.MethodDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class GrpcServer {\n    private final Server server;\n    private final Map<String, Class<? extends BindableService>> serviceNameMap;\n    private final Map<String, Method> fullMethodNameMap;\n\n    public GrpcServer(GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        ServerBuilder<?> builder = ServerBuilder.forPort(properties.getPort());\n        for (ServerInterceptor interceptor : interceptors) {\n            builder.addInterceptor(interceptor);\n        }\n        for (BindableService service : services) {\n            builder.addService(service);\n        }\n        this.server = builder.build().start();\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n        for (BindableService service : services) {\n            Class<?> serviceClass = service.getClass();\n            String serviceName = getServiceNameFromClass(serviceClass);\n            serviceNameMap.put(serviceName, serviceClass);\n            ServiceDescriptor serviceDescriptor = service.getClass().getAnnotation(ServiceDescriptor.class);\n            if (serviceDescriptor != null) {\n                for (MethodDescriptor<?, ?> method : serviceDescriptor.getMethods()) {\n                    String methodName = method.getFullMethodName();\n                    fullMethodNameMap.put(methodName, getMethodFromService(serviceClass, method));\n                }\n            }\n        }\n    }\n\n    public GrpcServer(ServerBuilder<?> builder, GrpcServerProperties properties, List<ServerInterceptor> interceptors, List<BindableService> services) {\n        for (ServerInterceptor interceptor : interceptors) {\n            builder.addInterceptor(interceptor);\n        }\n        for (BindableService service : services) {\n            builder.addService(service);\n        }\n        this.server = builder.build().start();\n        this.serviceNameMap = new HashMap<>();\n        this.fullMethodNameMap = new HashMap<>();\n        for (BindableService service : services) {\n            Class<?> serviceClass = service.getClass();\n            String serviceName = getServiceNameFromClass(serviceClass);\n            serviceNameMap.put(serviceName, serviceClass);\n            ServiceDescriptor serviceDescriptor = service.getClass().getAnnotation(ServiceDescriptor.class);\n            if (serviceDescriptor != null) {\n                for (MethodDescriptor<?, ?> method : serviceDescriptor.getMethods()) {\n                    String methodName = method.getFullMethodName();\n                    fullMethodNameMap.put(methodName, getMethodFromService(serviceClass, method));\n                }\n            }\n        }\n    }\n\n    public boolean isRunning() {\n        return server.isRunning();\n    }\n\n    public int port() {\n        return server.getPort();\n    }\n\n    public Class<? extends BindableService> findClass(ServiceDescriptor descriptor) {\n        return serviceNameMap.get(descriptor.getName());\n    }\n\n    public Method findMethod(MethodDescriptor<?, ?> descriptor) {\n        return fullMethodNameMap.get(descriptor.getFullMethodName());\n    }\n\n    public Method resolve(MethodDescriptor<?, ?> descriptor, Class<? extends BindableService> cls) {\n        return getMethodFromService(cls, descriptor);\n    }\n\n    public void onApplicationStart() {\n        server.start();\n    }\n\n    public void onApplicationStop() {\n        server.shutdown();\n    }\n\n    private String getServiceNameFromClass(Class<?> serviceClass) {\n        return serviceClass.getSimpleName().replace(\"Impl\", \"\");\n    }\n\n    private Method getMethodFromService(Class<?> serviceClass, MethodDescriptor<?, ?> descriptor) {\n        for (Method method : serviceClass.getDeclaredMethods()) {\n            if (method.getName().equals(descriptor.getFullMethodName()) && matchParameterTypes(method.getParameterTypes(), descriptor.getMethod().getParameters())) {\n                return method;\n            }\n        }\n        return null;\n    }\n\n    private boolean matchParameterTypes(Class<?>[] methodParams, List<Type> descriptorParams) {\n        if (methodParams.length != descriptorParams.size()) {\n            return false;\n        }\n        for (int i = 0; i < methodParams.length; i++) {\n            if (!methodParams[i].getName().equals(descriptorParams.get(i).getTypeName())) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
  },
  {
    "Task_id": 508,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens for incoming requests and provides book-related services. The server should start on a specified port, handle graceful shutdown, and wait for termination.\n\nClass Description: The BookServer class represents a gRPC server implementation that hosts book-related services. It manages server lifecycle including startup, shutdown, and termination waiting.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the default port (50051) and registers the BookService. Also adds a shutdown hook for graceful termination.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running.\n- blockUntilShutdown() -> [void] - Blocks the main thread until the server is terminated.\n- main(String[] args) -> [void] - Entry point that creates and starts the server, then waits for shutdown. Throws IOException and InterruptedException.\n\nThe class follows gRPC server best practices including:\n1. Using ServerBuilder to create and configure the server\n2. Adding services before starting\n3. Implementing graceful shutdown\n4. Proper error handling\n5. Logging server status",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class BookServer {\n  private static final Logger logger = Logger.getLogger(BookServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50051;\n    server = ServerBuilder.forPort(port).addService(new BookService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  BookServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final BookServer server = new BookServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.util.logging.Logger;\n\npublic class BookServer {\n    private final Server server;\n    private final Logger logger;\n\n    public BookServer() {\n        this.logger = Logger.getLogger(BookServer.class.getName());\n        this.server = null;\n    }\n\n    public void start() {\n        try {\n            server = ServerBuilder.forPort(50051)\n                    .addService(new BookService())\n                    .build()\n                    .start();\n\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n                try {\n                    stop();\n                } catch (Exception e) {\n                    logger.severe(\"Error during shutdown: \" + e.getMessage());\n                }\n            }));\n        } catch (Exception e) {\n            logger.severe(\"Failed to start server: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void stop() {\n        if (server != null) {\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        BookServer server = new BookServer();\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    private class BookService extends BookServiceGrpc.BookServiceImplBase {\n        @Override\n        public void getBook(GetBookRequest request, StreamObserver<GetBookResponse> responseObserver) {\n            GetBookResponse response = GetBookResponse.newBuilder().setIsbn(\"123\").build();\n            responseObserver.onNext(response);\n            responseObserver.onCompleted();\n        }\n    }\n}"
  },
  {
    "Task_id": 51,
    "Instruction": "Task Description: Create a function to test if a given URL is reachable by making an HTTP GET request and verifying the response code.\n\nFunction Description: The function attempts to connect to a specified URL using an HTTP GET request. It checks if the response code is HTTP_OK (200) to determine if the URL is reachable. The connection is properly closed after the check.\n\nInput: \n- strUrl: String - The URL to be tested for reachability\n\nOutput: \n- None (The function throws an exception if the URL is unreachable or if the response code is not HTTP_OK)",
    "Canonical_solution": "import java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic void testUrlReachable(String strUtl) throws Exception {\n    URL url = new URL(strUtl);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(\"GET\");\n    conn.connect();\n    int rc = conn.getResponseCode();\n    assertEquals(HttpURLConnection.HTTP_OK, rc);\n    conn.disconnect();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.IOException;\n\npublic class UrlChecker {\n    public static void testUrlReachability(String strUrl) throws IOException {\n        URL url = new URL(strUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        int responseCode = conn.getResponseCode();\n        if (responseCode != HttpURLConnection.HTTP_OK) {\n            throw new IOException(\"URL is unreachable or response code is not 200: \" + responseCode);\n        }\n        conn.disconnect();\n    }\n}"
  },
  {
    "Task_id": 510,
    "Instruction": "Task Description: Create a Java class that implements a gRPC server using NettyServerBuilder to handle multiple language processing services.\n\nClass Description: The ZemberekGrpcServer class is responsible for initializing and managing a gRPC server that provides various Turkish language processing services. It uses Netty as the underlying transport layer and allows configuration of the server port and service implementations.\n\nAttributes:\n- port: [int] - The port number on which the gRPC server will listen for incoming connections.\n- context: [ZemberekContext] - The context object containing configuration and resources for language processing services.\n- DEFAULT_PORT: [static final int] - The default port number (6789) used when no specific port is provided.\n\nMethods:\n- Constructor: [ZemberekGrpcServer](int port, ZemberekGrpcConfiguration configuration) -> [void] - Initializes the server with the specified port and configuration.\n- getPort: [getPort]() -> [int] - Returns the port number the server is configured to use.\n- getContext: [getContext]() -> [ZemberekContext] - Returns the ZemberekContext object containing service configurations.\n- start: [start]() -> [void] - Starts the gRPC server, adds all service implementations, and begins listening for requests. This method blocks until the server terminates.\n- main: [main](String[] args) -> [void] - The entry point that creates and starts the server using default parameters.",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.netty.shaded.io.grpc.netty.NettyServerBuilder;\nimport zemberek.core.logging.Log;\n\npublic class ZemberekGrpcServer {\n\n    public static final int DEFAULT_PORT = 6789;\n\n    private final int port;\n    private ZemberekContext context;\n\n    public ZemberekGrpcServer(int port, ZemberekGrpcConfiguration configuration) {\n        this.port = port;\n        context = new ZemberekContext(configuration);\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public ZemberekContext getContext() {\n        return context;\n    }\n\n    public void start() throws Exception {\n        Server server = NettyServerBuilder.forPort(port)\n                .addService(new LanguageIdServiceImpl())\n                .addService(new PreprocessingServiceImpl())\n                .addService(new NormalizationServiceImpl(context))\n                .addService(new MorphologyServiceImpl(context))\n                .build()\n                .start();\n        Log.info(\"Zemberek grpc server started at port: \" + port);\n        server.awaitTermination();\n    }\n\n    public static void main(String[] args) throws Exception {\n        new ZemberekGrpcServer(DEFAULT_PORT, null).start();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.NettyServerBuilder;\nimport io.grpc.Server;\nimport java.util.concurrent.TimeUnit;\n\npublic class ZemberekGrpcServer {\n    private final int port;\n    private final ZemberekContext context;\n    public static final int DEFAULT_PORT = 6789;\n\n    public ZemberekGrpcServer(int port, ZemberekGrpcConfiguration configuration) {\n        this.port = port;\n        this.context = configuration.createContext();\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public ZemberekContext getContext() {\n        return context;\n    }\n\n    public void start() {\n        try {\n            Server server = NettyServerBuilder.forPort(port)\n                .addService(context.getServiceImplementation())\n                .build()\n                .start();\n            server.awaitTermination();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        ZemberekGrpcServer server = new ZemberekGrpcServer(DEFAULT_PORT, new ZemberekGrpcConfiguration());\n        server.start();\n    }\n}"
  },
  {
    "Task_id": 514,
    "Instruction": "Task Description: Implement a gRPC server in Java that listens on a specified port, provides a service, and handles graceful shutdown.\n\nClass Description: The ShelfServer class is responsible for creating and managing a gRPC server instance. It initializes the server on a specified port, adds the required service implementation, and provides methods for starting, stopping, and waiting for server termination.\n\nAttributes:\n- server: [io.grpc.Server] - The gRPC server instance that handles incoming requests\n- logger: [java.util.logging.Logger] - Logger instance for server status messages\n\nMethods:\n- start() -> [void] - Starts the gRPC server on the specified port (50052 by default) and registers a shutdown hook for graceful termination. Throws IOException if server fails to start.\n- stop() -> [void] - Initiates a graceful shutdown of the gRPC server if it's running\n- blockUntilShutdown() -> [void] - Blocks the calling thread until the server terminates. Throws InterruptedException if the thread is interrupted while waiting\n- main(String[] args) -> [void] - Entry point that creates and starts the server instance. Throws IOException and InterruptedException for server start and shutdown operations",
    "Canonical_solution": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n  private static final Logger logger = Logger.getLogger(ShelfServer.class.getName());\n\n  private Server server;\n\n  private void start() throws IOException {\n    int port = 50052;\n    server = ServerBuilder.forPort(port).addService(new ShelfService()).build().start();\n    logger.info(\"Server started, listening on \" + port);\n    Runtime.getRuntime()\n        .addShutdownHook(\n            new Thread(\n                () -> {\n                  System.err.println(\"*** shutting down gRPC server since JVM is shutting down\");\n                  ShelfServer.this.stop();\n                  System.err.println(\"*** server shut down\");\n                }));\n  }\n\n  private void stop() {\n    if (server != null) {\n      server.shutdown();\n    }\n  }\n\n  private void blockUntilShutdown() throws InterruptedException {\n    if (server != null) {\n      server.awaitTermination();\n    }\n  }\n\n  public static void main(String[] args) throws IOException, InterruptedException {\n    final ShelfServer server = new ShelfServer();\n    server.start();\n    server.blockUntilShutdown();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 24,
    "right_result": "import io.grpc.Server;\nimport io.grpc.ServerBuilder;\nimport java.io.IOException;\nimport java.util.logging.Logger;\n\npublic class ShelfServer {\n    private final Server server;\n    private final Logger logger;\n\n    public ShelfServer(int port) {\n        this.logger = Logger.getLogger(ShelfServer.class.getName());\n        this.server = ServerBuilder.forPort(port)\n                .addService(new ShelfServiceImpl())\n                .build();\n    }\n\n    public void start() throws IOException {\n        logger.info(\"Starting server on port \" + server.getPort());\n        server.start();\n        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n            try {\n                stop();\n            } catch (Exception e) {\n                logger.severe(\"Failed to stop server gracefully: \" + e.getMessage());\n            }\n        }));\n    }\n\n    public void stop() {\n        if (server != null) {\n            logger.info(\"Shutting down server\");\n            server.shutdown();\n        }\n    }\n\n    public void blockUntilShutdown() throws InterruptedException {\n        if (server != null) {\n            logger.info(\"Waiting for server to shutdown\");\n            server.awaitTermination();\n        }\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        int port = 50052;\n        ShelfServer server = new ShelfServer(port);\n        server.start();\n        server.blockUntilShutdown();\n    }\n\n    private static class ShelfServiceImpl extends io.grpc.BindableService {\n        @Override\n        public void shutdown() {\n            // No-op\n        }\n\n        @Override\n        public void start() {\n            // No-op\n        }\n\n        @Override\n        public void stop() {\n            // No-op\n        }\n    }\n}"
  },
  {
    "Task_id": 525,
    "Instruction": "Task Description: Create a Java class that implements a multithreaded TCP echo server capable of handling both plain and SSL/TLS encrypted connections. The server should echo back any data received from clients and support SSL renegotiation.\n\nClass Description: EchoServer is a Thread subclass that creates a TCP server listening on a specified port. It can operate in both plain and SSL/TLS modes, maintains connections in threads, and provides methods for graceful shutdown and connection management.\n\nAttributes:\n- port: int - The port number the server listens on\n- serverSocket: ServerSocket - The server socket accepting client connections\n- threads: List<Thread> - Synchronized list of active client handler threads\n- sockets: List<Socket> - Synchronized list of active client sockets\n- exceptions: List<Exception> - Synchronized list of encountered exceptions\n- renegotiate: AtomicBoolean - Flag to trigger SSL renegotiation\n\nMethods:\n- EchoServer(int port) -> void - Constructor for plain TCP server\n- EchoServer(SSLFactory sslFactory, int port) -> void - Constructor for SSL/TLS server\n- renegotiate() -> void - Triggers SSL renegotiation for all connections\n- run() -> void - Main server thread accepting connections and spawning handlers\n- closeConnections() -> void - Closes all active client connections\n- close() -> void - Shuts down the server gracefully\n- getExceptionCount() -> int - Returns count of encountered exceptions",
    "Canonical_solution": "import com.github.ambry.commons.SSLFactory;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLSocket;\n\npublic class EchoServer extends Thread {\n  public final int port;\n  private final ServerSocket serverSocket;\n  private final List<Thread> threads;\n  private final List<Socket> sockets;\n  private final List<Exception> exceptions;\n  private final AtomicBoolean renegotiate = new AtomicBoolean();\n\n  public EchoServer(int port) throws Exception {\n    this(null, port);\n  }\n\n  public EchoServer(SSLFactory sslFactory, int port) throws Exception {\n    this.port = port;\n    if (sslFactory == null) {\n      this.serverSocket = new ServerSocket(port);\n    } else {\n      SSLContext sslContext = sslFactory.getSSLContext();\n      this.serverSocket = sslContext.getServerSocketFactory().createServerSocket(port);\n      ((SSLServerSocket) this.serverSocket).setNeedClientAuth(true);\n    }\n    this.threads = Collections.synchronizedList(new ArrayList<Thread>());\n    this.sockets = Collections.synchronizedList(new ArrayList<Socket>());\n    this.exceptions = Collections.synchronizedList(new ArrayList<Exception>());\n  }\n\n  public void renegotiate() {\n    renegotiate.set(true);\n  }\n\n  @Override\n  public void run() {\n    try {\n      while (true) {\n        final Socket socket = serverSocket.accept();\n        sockets.add(socket);\n        Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              socket.setSoTimeout(3000);\n              DataInputStream input = new DataInputStream(socket.getInputStream());\n              DataOutputStream output = new DataOutputStream(socket.getOutputStream());\n              while (socket.isConnected() && !socket.isClosed()) {\n                long size = input.readLong();\n                if (renegotiate.compareAndSet(true, false)) {\n                  ((SSLSocket) socket).startHandshake();\n                }\n                byte[] bytes = new byte[(int) size - 8];\n                input.readFully(bytes);\n                output.writeLong(size);\n                output.write(bytes);\n                output.flush();\n              }\n            } catch (IOException e) {\n              // ignore, caused by client closed connection\n            } finally {\n              try {\n                socket.close();\n              } catch (IOException e) {\n                exceptions.add(e);\n              }\n            }\n          }\n        };\n        thread.start();\n        threads.add(thread);\n      }\n    } catch (IOException e) {\n      exceptions.add(e);\n    }\n  }\n\n  public void closeConnections() throws IOException {\n    for (Socket socket : sockets) {\n      socket.close();\n    }\n  }\n\n  public void close() throws IOException, InterruptedException {\n    this.serverSocket.close();\n    closeConnections();\n    for (Thread t : threads) {\n      t.join();\n    }\n    join();\n  }\n\n  public int getExceptionCount() {\n    return exceptions.size();\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class EchoServer extends Thread {\n    private final int port;\n    private ServerSocket serverSocket;\n    private final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());\n    private final List<Socket> sockets = Collections.synchronizedList(new ArrayList<>());\n    private final List<Exception> exceptions = Collections.synchronizedList(new ArrayList<>());\n    private final AtomicBoolean renegotiate = new AtomicBoolean(false);\n\n    public EchoServer(int port) {\n        this.port = port;\n        try {\n            serverSocket = new ServerSocket(port);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public EchoServer(SSLFactory sslFactory, int port) {\n        this.port = port;\n        try {\n            serverSocket = sslFactory.createServerSocket(port);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public void renegotiate() {\n        for (Socket socket : sockets) {\n            if (socket instanceof SSLSocket) {\n                try {\n                    ((SSLSocket) socket).renegotiate();\n                } catch (IOException e) {\n                    exceptions.add(e);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (!isInterrupted()) {\n                Socket clientSocket = serverSocket.accept();\n                sockets.add(clientSocket);\n                Thread handler = new Thread(new ClientHandler(clientSocket));\n                threads.add(handler);\n                handler.start();\n            }\n        } catch (IOException e) {\n            exceptions.add(e);\n        } finally {\n            closeConnections();\n        }\n    }\n\n    public void closeConnections() {\n        for (Socket socket : sockets) {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                exceptions.add(e);\n            }\n        }\n        sockets.clear();\n    }\n\n    public void close() {\n        closeConnections();\n        try {\n            serverSocket.close();\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n\n    public int getExceptionCount() {\n        return exceptions.size();\n    }\n\n    private class ClientHandler implements Runnable {\n        private final Socket socket;\n\n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        @Override\n        public void run() {\n            try (InputStream input = socket.getInputStream();\n                 OutputStream output = socket.getOutputStream()) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = input.read(buffer)) != -1) {\n                    output.write(buffer, 0, bytesRead);\n                    output.flush();\n                }\n            } catch (IOException e) {\n                exceptions.add(e);\n            } finally {\n                sockets.remove(socket);\n                threads.remove(Thread.currentThread());\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    exceptions.add(e);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 546,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP server capable of accepting client connections and sending messages to connected clients.\n\nClass Description: The HelloServer class represents a basic TCP server that listens for incoming client connections on a specified port. Once a client connects, the server can send messages to that client through the established connection.\n\nAttributes:\n- server: [ServerSocket] - The ServerSocket instance used to listen for incoming client connections\n- client: [Socket] - The Socket instance representing the connected client\n- out: [PrintStream] - The output stream used to send messages to the connected client\n\nMethods:\n- start: [Name]([int port]) -> [void] - Starts the server on the specified port, waits for a client connection, and prepares the output stream for communication\n- sendMessage: [Name]([String message]) -> [void] - Sends the specified message to the connected client\n- stop: [Name]() -> [void] - Closes the client connection and server socket, releasing all resources",
    "Canonical_solution": "import java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class HelloServer {\n\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n\n    public void start(int port) throws Exception {\n        server = new ServerSocket(port);\n        System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\u4e2d\uff0c\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\");\n        client = server.accept();\n        out = new PrintStream(client.getOutputStream());\n    }\n\n    public void sendMessage(String message) throws Exception {\n        out.println(message);\n    }\n\n    public void stop() throws Exception {\n        client.close();\n        server.close();\n        System.out.println(\"\u670d\u52a1\u5668\u5df2\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u9000\u51fa\u3002\");\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.PrintStream;\n\npublic class HelloServer {\n    ServerSocket server;\n    Socket client;\n    PrintStream out;\n\n    public void start(int port) {\n        try {\n            server = new ServerSocket(port);\n            client = server.accept();\n            out = new PrintStream(client.getOutputStream());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendMessage(String message) {\n        if (out != null) {\n            out.println(message);\n        }\n    }\n\n    public void stop() {\n        try {\n            if (client != null) client.close();\n            if (server != null) server.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 554,
    "Instruction": "Task Description: Create a Java class that implements a simple TCP echo server using ServerSocket to listen for client connections, receive messages, and send them back to the client with an \"ECHO : \" prefix until the client sends \"bye\" or an empty message.\n\nClass Description: The EchoServer class represents a TCP server that echoes back received messages to connected clients. It handles client connections, message processing, and resource cleanup.\n\nAttributes:\n- server: [ServerSocket] - The server socket listening for incoming connections\n- client: [Socket] - The socket representing the connected client\n- out: [PrintStream] - Output stream to send data to the client\n- buf: [BufferedReader] - Input stream to read data from the client\n- flag: [boolean] - Control flag for the server's main loop\n\nMethods:\n- EchoServer(int port) -> [void] - Constructor that initializes the server socket on the specified port\n- start() -> [void] - Starts the server, accepts client connections, and begins echoing messages\n- close() -> [void] - Closes client and server sockets to release resources",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class EchoServer {\n\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) throws Exception {\n        server = new ServerSocket(port);\n        flag = true;\n    }\n\n    public void start() throws Exception {\n        System.out.println(\"\u670d\u52a1\u5668\u8fd0\u884c\uff0c\u7b49\u5f85\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\");\n        client = server.accept();\n        out = new PrintStream(client.getOutputStream());\n        buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n        while (flag) {\n            String str = buf.readLine();\n            if (str == null || \"\".equals(str)) {\n                flag = false;\n            } else {\n                if (\"bye\".equals(str)) {\n                    flag = false;\n                } else {\n                    out.println(\"ECHO : \" + str);\n                }\n            }\n        }\n    }\n\n    public void close() throws Exception {\n        client.close();\n        server.close();\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 0,
    "right_result": "import java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.PrintStream;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class EchoServer {\n    private ServerSocket server;\n    private Socket client;\n    private PrintStream out;\n    private BufferedReader buf;\n    private boolean flag;\n\n    public EchoServer(int port) {\n        try {\n            server = new ServerSocket(port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        flag = true;\n        while (flag) {\n            try {\n                client = server.accept();\n                out = new PrintStream(client.getOutputStream());\n                buf = new BufferedReader(new InputStreamReader(client.getInputStream()));\n                String message;\n                while (true) {\n                    message = buf.readLine();\n                    if (message == null || message.trim().isEmpty() || message.trim().equals(\"bye\")) {\n                        break;\n                    }\n                    out.println(\"ECHO : \" + message);\n                    out.flush();\n                }\n                client.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void close() {\n        try {\n            if (client != null) client.close();\n            if (server != null) server.close();\n            flag = false;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
  },
  {
    "Task_id": 563,
    "Instruction": "Task Description: Create a Java function that tests a client-server connection using Socket programming, including handling connection events and verifying successful communication.\n\nFunction Description: The function establishes a TCP connection to a server, sends an HTTP GET request, and verifies both connection establishment and message delivery. It uses CountDownLatch for synchronization between the main thread and callback handlers. The function fails if either the connection or message delivery doesn't complete within specified timeouts.\n\nInput: None (uses DefaultServer class for host configuration)\n\nOutput: None (throws exceptions or asserts failures for unsuccessful operations)\n\nKey Operations:\n1. Creates Socket connection to default server\n2. Sets up server event handlers with callbacks\n3. Obtains input/output streams for communication\n4. Sends HTTP GET request\n5. Verifies connection establishment within 10 seconds\n6. Verifies message delivery within 10 seconds\n7. Properly closes resources\n8. Uses synchronization primitives for thread coordination",
    "Canonical_solution": "import java.net.Socket;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic void testConnectionFail() throws IOException, InterruptedException {\n    final Socket socket = new Socket(DefaultServer.getHostAddress(\"default\"), DefaultServer.getHostPort(\"default\"));\n    final CountDownLatch latch = new CountDownLatch(1);\n    final CountDownLatch connected = new CountDownLatch(1);\n    DefaultServer.setRootHandler(new ServerSentEventHandler(new ServerSentEventConnectionCallback() {\n        @Override\n        public void connected(final ServerSentEventConnection connection, final String lastEventId) {\n            final XnioIoThread thread = (XnioIoThread) Thread.currentThread();\n            connected.countDown();\n            thread.execute(new Runnable() {\n                @Override\n                public void run() {\n                    connection.send(\"hello\", new ServerSentEventConnection.EventCallback() {\n                        @Override\n                        public void done(ServerSentEventConnection connection, String data, String event, String id) {\n                        }\n\n                        @Override\n                        public void failed(ServerSentEventConnection connection, String data, String event, String id, IOException e) {\n                            latch.countDown();\n                        }\n                    });\n                    if(latch.getCount() > 0) {\n                        WorkerUtils.executeAfter(thread, this, 100, TimeUnit.MILLISECONDS);\n                    }\n                }\n            });\n        }\n    }));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    out.write((\"GET / HTTP/1.1\\r\\nHost:\" + DefaultServer.getHostAddress() +\"\\r\\n\\r\\n\").getBytes());\n    out.flush();\n    if(!connected.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n    out.close();\n    in.close();\n    if(!latch.await(10, TimeUnit.SECONDS)) {\n        Assert.fail();\n    }\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 1,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\npublic class ClientServerTest {\n    public void testClientServerConnection() throws Exception {\n        CountDownLatch connectLatch = new CountDownLatch(1);\n        CountDownLatch messageLatch = new CountDownLatch(1);\n        Socket socket = new Socket();\n\n        Thread connectThread = new Thread(() -> {\n            try {\n                socket.connect(new InetSocketAddress(DefaultServer.getDefaultHost(), DefaultServer.getDefaultPort()), 10000);\n                connectLatch.countDown();\n            } catch (Exception e) {\n                throw new RuntimeException(\"Connection failed\", e);\n            }\n        });\n        connectThread.start();\n\n        if (!connectLatch.await(10, TimeUnit.SECONDS)) {\n            throw new RuntimeException(\"Connection timeout\");\n        }\n\n        try (OutputStream out = socket.getOutputStream();\n             InputStream in = socket.getInputStream()) {\n            String request = \"GET / HTTP/1.1\\r\\nHost: \" + DefaultServer.getDefaultHost() + \"\\r\\n\\r\\n\";\n            out.write(request.getBytes());\n            out.flush();\n\n            Thread readThread = new Thread(() -> {\n                try {\n                    byte[] buffer = new byte[1024];\n                    int bytesRead;\n                    while ((bytesRead = in.read(buffer)) != -1) {\n                        if (bytesRead > 0) {\n                            messageLatch.countDown();\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(\"Reading response failed\", e);\n                }\n            });\n            readThread.start();\n\n            if (!messageLatch.await(10, TimeUnit.SECONDS)) {\n                throw new RuntimeException(\"Message delivery timeout\");\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Communication error\", e);\n        } finally {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 566,
    "Instruction": "Task Description: Create a Java class that implements Unix domain socket communication using SocketChannel for inter-process communication on Unix-like systems.\n\nClass Description: The UnixSocket class extends AbstractSocket and provides functionality for Unix domain socket communication. It uses Java's SocketChannel for establishing connections and supports input/output stream operations.\n\nAttributes:\n- socketAddress: [SocketAddress] - The address of the Unix domain socket\n- socketChannel: [SocketChannel] - The channel used for socket communication\n\nMethods:\n- UnixSocket(String path) -> [void] - Constructor that creates a Unix domain socket connection to the specified path. Throws various exceptions if the operation fails.\n- getInputStream() -> [InputStream] - Returns an input stream for reading data from the socket. Throws SocketException if the socket is closed, not connected, or input is shutdown.\n- getOutputStream() -> [OutputStream] - Returns an output stream for writing data to the socket. Throws SocketException if the socket is closed, not connected, or output is shutdown.\n- getLocalSocketAddress() -> [SocketAddress] - Returns the local socket address.\n- getRemoteSocketAddress() -> [SocketAddress] - Returns the remote socket address (same as local for Unix domain sockets).\n- close() -> [void] - Closes the socket channel and releases resources.\n- WrappedWritableByteChannel.write(ByteBuffer src) -> [int] - Inner class method that writes data from the buffer to the socket channel.\n- WrappedWritableByteChannel.isOpen() -> [boolean] - Inner class method that checks if the channel is open.\n- WrappedWritableByteChannel.close() -> [void] - Inner class method that closes the channel.",
    "Canonical_solution": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException,\n            IllegalAccessException, IOException {\n        Class<?> unixDomainSocketAddress = Class.forName(\"java.net.UnixDomainSocketAddress\");\n        this.socketAddress =\n                (SocketAddress) unixDomainSocketAddress.getMethod(\"of\", String.class)\n                        .invoke(null, path);\n        this.socketChannel = SocketChannel.open(this.socketAddress);\n    }\n\n    @Override\n    public InputStream getInputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isInputShutdown()) {\n            throw new SocketException(\"Socket input is shutdown\");\n        }\n        return Channels.newInputStream(socketChannel);\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException {\n        if (isClosed()) {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (!isConnected()) {\n            throw new SocketException(\"Socket is not connected\");\n        }\n        if (isOutputShutdown()) {\n            throw new SocketException(\"Socket output is shutdown\");\n        }\n        return Channels.newOutputStream(new WrappedWritableByteChannel());\n    }\n\n    @Override\n    public SocketAddress getLocalSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public SocketAddress getRemoteSocketAddress() {\n        return socketAddress;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        this.socketChannel.close();\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return UnixSocket.this.socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return UnixSocket.this.socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            UnixSocket.this.socketChannel.close();\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.SocketAddress;\nimport java.net.UnixSocketAddress;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\n\npublic class UnixSocket extends AbstractSocket {\n    private final SocketAddress socketAddress;\n    private final SocketChannel socketChannel;\n\n    public UnixSocket(String path) throws IOException {\n        this.socketAddress = new UnixSocketAddress(path);\n        this.socketChannel = SocketChannel.open(socketAddress);\n    }\n\n    public InputStream getInputStream() throws SocketException {\n        return new InputStream() {\n            @Override\n            public int read() throws IOException {\n                byte[] buffer = new byte[1];\n                int bytesRead = read(buffer, 0, 1);\n                return bytesRead == -1 ? -1 : buffer[0] & 0xFF;\n            }\n\n            @Override\n            public int read(byte[] b, int off, int len) throws IOException {\n                if (socketChannel == null || !socketChannel.isConnected()) {\n                    throw new SocketException(\"Socket not connected\");\n                }\n                if (socketChannel.isClosed()) {\n                    throw new SocketException(\"Socket closed\");\n                }\n                if (socketChannel.isInputShutdown()) {\n                    throw new SocketException(\"Input shutdown\");\n                }\n                int bytesRead = socketChannel.read(ByteBuffer.wrap(b, off, len));\n                return bytesRead;\n            }\n\n            @Override\n            public void close() throws IOException {\n                if (socketChannel != null) {\n                    socketChannel.close();\n                }\n            }\n        };\n    }\n\n    public OutputStream getOutputStream() throws SocketException {\n        return new OutputStream() {\n            private final WritableByteChannel channel = new WrappedWritableByteChannel();\n\n            @Override\n            public void write(int b) throws IOException {\n                if (socketChannel == null || !socketChannel.isConnected()) {\n                    throw new SocketException(\"Socket not connected\");\n                }\n                if (socketChannel.isClosed()) {\n                    throw new SocketException(\"Socket closed\");\n                }\n                if (socketChannel.isOutputShutdown()) {\n                    throw new SocketException(\"Output shutdown\");\n                }\n                ByteBuffer buffer = ByteBuffer.allocate(1);\n                buffer.put((byte) b);\n                buffer.flip();\n                channel.write(buffer);\n            }\n\n            @Override\n            public void write(byte[] b, int off, int len) throws IOException {\n                if (socketChannel == null || !socketChannel.isConnected()) {\n                    throw new SocketException(\"Socket not connected\");\n                }\n                if (socketChannel.isClosed()) {\n                    throw new SocketException(\"Socket closed\");\n                }\n                if (socketChannel.isOutputShutdown()) {\n                    throw new SocketException(\"Output shutdown\");\n                }\n                ByteBuffer buffer = ByteBuffer.wrap(b, off, len);\n                channel.write(buffer);\n            }\n\n            @Override\n            public void close() throws IOException {\n                channel.close();\n            }\n        };\n    }\n\n    public SocketAddress getLocalSocketAddress() {\n        return socketChannel.getLocalAddress();\n    }\n\n    public SocketAddress getRemoteSocketAddress() {\n        return socketChannel.getRemoteAddress();\n    }\n\n    public void close() throws IOException {\n        if (socketChannel != null) {\n            socketChannel.close();\n        }\n    }\n\n    private class WrappedWritableByteChannel implements WritableByteChannel {\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return socketChannel.write(src);\n        }\n\n        @Override\n        public boolean isOpen() {\n            return socketChannel.isOpen();\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 576,
    "Instruction": "Task Description: Create a Java class that handles socket communication for receiving and processing video stream data from an Android device using scrcpy (Screen Copy) technology.\n\nClass Description: ScrcpyInputSocketThread is a thread class that establishes a socket connection to receive video stream data from an Android device, processes the NAL units (Network Abstraction Layer units) from the stream, and manages the communication lifecycle.\n\nAttributes:\n- log: Logger - Logger instance for recording operational information\n- iDevice: IDevice - Represents the connected Android device\n- dataQueue: BlockingQueue<byte[]> - Queue for storing processed video data packets\n- scrcpyLocalThread: ScrcpyLocalThread - Reference to the main scrcpy control thread\n- androidTestTaskBootThread: AndroidTestTaskBootThread - Reference to the Android test task thread\n- session: Session - WebSocket session for sending device information\n- BUFFER_SIZE: int (static final) - Maximum buffer size for video data (10MB)\n- READ_BUFFER_SIZE: int (static final) - Chunk size for reading from the input stream (5KB)\n\nMethods:\n- Constructor(IDevice, BlockingQueue<byte[]>, ScrcpyLocalThread, Session) -> void - Initializes the thread with device, data queue, control thread, and session references\n- run() -> void - Main thread execution that:\n  1. Sets up port forwarding for scrcpy\n  2. Establishes socket connection to localhost\n  3. Sends device screen dimensions via WebSocket\n  4. Continuously reads and processes video stream data\n  5. Manages resources cleanup on termination\n  6. Handles NAL unit detection and packetization\n\nThe class implements proper resource management by:\n1. Closing sockets and streams in finally blocks\n2. Removing port forwarding when done\n3. Cleaning up session references\n4. Interrupting related threads when needed\n5. Handling IOExceptions during communication",
    "Canonical_solution": "import com.android.ddmlib.IDevice;\nimport jakarta.websocket.Session;\nimport org.cloud.sonic.agent.bridge.android.AndroidDeviceBridgeTool;\nimport org.cloud.sonic.agent.common.maps.ScreenMap;\nimport org.cloud.sonic.agent.tests.android.AndroidTestTaskBootThread;\nimport org.cloud.sonic.agent.tools.BytesTool;\nimport org.cloud.sonic.agent.tools.PortTool;\nimport org.slf4j.Logger;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ScrcpyInputSocketThread extends Thread {\n\n    private final Logger log = LoggerFactory.getLogger(ScrcpyInputSocketThread.class);\n    private IDevice iDevice;\n    private BlockingQueue<byte[]> dataQueue;\n    private ScrcpyLocalThread scrcpyLocalThread;\n    private AndroidTestTaskBootThread androidTestTaskBootThread;\n    private Session session;\n    private static final int BUFFER_SIZE = 1024 * 1024 * 10;\n    private static final int READ_BUFFER_SIZE = 1024 * 5;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.session = session;\n        this.androidTestTaskBootThread = scrcpyLocalThread.getAndroidTestTaskBootThread();\n        this.setDaemon(false);\n        this.setName(androidTestTaskBootThread.formatThreadName(\"android-scrcpy-input-socket-task-%s-%s-%s\"));\n    }\n\n    @Override\n    public void run() {\n        int scrcpyPort = PortTool.getPort();\n        AndroidDeviceBridgeTool.forward(iDevice, scrcpyPort, \"scrcpy\");\n        Socket videoSocket = new Socket();\n        InputStream inputStream = null;\n        try {\n            videoSocket.connect(new InetSocketAddress(\"localhost\", scrcpyPort));\n            inputStream = videoSocket.getInputStream();\n            if (videoSocket.isConnected()) {\n                String sizeTotal = AndroidDeviceBridgeTool.getScreenSize(iDevice);\n                BytesTool.sendText(session, String.format(\"{\\\"msg\\\":\\\"size\\\",\\\"width\\\":\\\"%s\\\",\\\"height\\\":\\\"%s\\\"}\", \n                    sizeTotal.split(\"x\")[0], sizeTotal.split(\"x\")[1]));\n            }\n            int readLength;\n            int naLuIndex;\n            int bufferLength = 0;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (scrcpyLocalThread.isAlive()) {\n                readLength = inputStream.read(buffer, bufferLength, READ_BUFFER_SIZE);\n                if (readLength > 0) {\n                    bufferLength += readLength;\n                    for (int i = 5; i < bufferLength - 4; i++) {\n                        if (buffer[i] == 0x00 &&\n                                buffer[i + 1] == 0x00 &&\n                                buffer[i + 2] == 0x00 &&\n                                buffer[i + 3] == 0x01\n                        ) {\n                            naLuIndex = i;\n                            byte[] naluBuffer = new byte[naLuIndex];\n                            System.arraycopy(buffer, 0, naluBuffer, 0, naLuIndex);\n                            dataQueue.add(naluBuffer);\n                            bufferLength -= naLuIndex;\n                            System.arraycopy(buffer, naLuIndex, buffer, 0, bufferLength);\n                            i = 5;\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (scrcpyLocalThread.isAlive()) {\n                scrcpyLocalThread.interrupt();\n                log.info(\"scrcpy thread closed.\");\n            }\n            if (videoSocket.isConnected()) {\n                try {\n                    videoSocket.close();\n                    log.info(\"scrcpy video socket closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inputStream != null) {\n                try {\n                    inputStream.close();\n                    log.info(\"scrcpy input stream closed.\");\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        AndroidDeviceBridgeTool.removeForward(iDevice, scrcpyPort, \"scrcpy\");\n        if (session != null) {\n            ScreenMap.getMap().remove(session);\n        }\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "import java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\nimport javax.websocket.Session;\n\npublic class ScrcpyInputSocketThread extends Thread {\n    private final Logger log;\n    private final IDevice iDevice;\n    private final BlockingQueue<byte[]> dataQueue;\n    private final ScrcpyLocalThread scrcpyLocalThread;\n    private final AndroidTestTaskBootThread androidTestTaskBootThread;\n    private final Session session;\n    private static final int BUFFER_SIZE = 10 * 1024 * 1024;\n    private static final int READ_BUFFER_SIZE = 5 * 1024;\n\n    public ScrcpyInputSocketThread(IDevice iDevice, BlockingQueue<byte[]> dataQueue, ScrcpyLocalThread scrcpyLocalThread, Session session) {\n        this.log = Logger.getLogger(ScrcpyInputSocketThread.class.getName());\n        this.iDevice = iDevice;\n        this.dataQueue = dataQueue;\n        this.scrcpyLocalThread = scrcpyLocalThread;\n        this.androidTestTaskBootThread = androidTestTaskBootThread;\n        this.session = session;\n    }\n\n    @Override\n    public void run() {\n        Socket socket = null;\n        InputStream inputStream = null;\n        OutputStream outputStream = null;\n        try {\n            iDevice.forwardPort(8080, 8080);\n            socket = new Socket();\n            socket.connect(new InetSocketAddress(\"localhost\", 8080), 5000);\n            inputStream = socket.getInputStream();\n            outputStream = socket.getOutputStream();\n            int width = iDevice.getScreenSize().getWidth();\n            int height = iDevice.getScreenSize().getHeight();\n            String dimensions = String.format(\"{\\\"width\\\":%d,\\\"height\\\":%d}\", width, height);\n            session.getBasicRemote().sendText(dimensions);\n            byte[] buffer = new byte[0];\n            while (true) {\n                if (Thread.currentThread().isInterrupted()) break;\n                byte[] chunk = new byte[READ_BUFFER_SIZE];\n                int bytesRead = inputStream.read(chunk);\n                if (bytesRead == -1) break;\n                byte[] newBuffer = new byte[buffer.length + bytesRead];\n                System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);\n                System.arraycopy(chunk, 0, newBuffer, buffer.length, bytesRead);\n                buffer = newBuffer;\n                int pos = 0;\n                while (pos < buffer.length) {\n                    if (pos + 3 < buffer.length && buffer[pos] == 0x00 && buffer[pos+1] == 0x00 && buffer[pos+2] == 0x00 && buffer[pos+3] == 0x01) {\n                        byte[] nalUnit = Arrays.copyOfRange(buffer, pos, pos + 4);\n                        dataQueue.put(nalUnit);\n                        pos += 4;\n                    } else if (pos + 2 < buffer.length && buffer[pos] == 0x00 && buffer[pos+1] == 0x00 && buffer[pos+2] == 0x01) {\n                        byte[] nalUnit = Arrays.copyOfRange(buffer, pos, pos + 3);\n                        dataQueue.put(nalUnit);\n                        pos += 3;\n                    } else {\n                        pos++;\n                    }\n                }\n                buffer = Arrays.copyOfRange(buffer, pos, buffer.length);\n            }\n        } catch (IOException | InterruptedException e) {\n            log.severe(\"Error in ScrcpyInputSocketThread: \" + e.getMessage());\n        } finally {\n            try {\n                if (socket != null) socket.close();\n                if (inputStream != null) inputStream.close();\n                if (outputStream != null) outputStream.close();\n                iDevice.removeForwardPort(8080);\n                if (session != null) session.close();\n                scrcpyLocalThread.interrupt();\n                androidTestTaskBootThread.interrupt();\n            } catch (IOException e) {\n                log.severe(\"Error closing resources: \" + e.getMessage());\n            }\n        }\n    }\n}"
  },
  {
    "Task_id": 588,
    "Instruction": "Task Description: Create a Java class that establishes and manages a TCP client connection to a server using sockets, enabling bidirectional communication through input/output streams.\n\nClass Description: The GreysConsole class represents a TCP client that connects to a specified server address, maintains the connection, and provides mechanisms for sending and receiving data. It handles connection lifecycle and resource cleanup.\n\nAttributes:\n- socket: [Socket] - The underlying TCP socket connection to the server\n- socketWriter: [BufferedWriter] - Buffered writer for sending data to the server\n- socketReader: [BufferedReader] - Buffered reader for receiving data from the server\n- isRunning: [boolean] - Flag indicating whether the connection is active\n\nMethods:\n- connect: [InetSocketAddress] -> [Socket] - Establishes a connection to the server at the specified address, configures socket options, and initializes I/O streams\n- shutdown: [void] -> [void] - Closes all resources (socket and streams) and marks the connection as inactive\n- GreysConsole (constructor): [InetSocketAddress] -> [void] - Creates a new instance and establishes connection to the specified server address",
    "Canonical_solution": "import com.github.ompc.greys.core.command.Commands;\nimport jline.console.ConsoleReader;\nimport jline.console.completer.Completer;\nimport jline.console.history.FileHistory;\nimport jline.console.history.History;\nimport jline.console.history.MemoryHistory;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport static com.github.ompc.greys.core.util.GaStringUtils.DEFAULT_PROMPT;\nimport static java.io.File.separatorChar;\nimport static java.lang.System.getProperty;\nimport static jline.console.KeyMap.CTRL_D;\nimport static jline.internal.Preconditions.checkNotNull;\nimport static org.apache.commons.io.IOUtils.closeQuietly;\nimport static org.apache.commons.lang3.StringUtils.EMPTY;\nimport static org.apache.commons.lang3.StringUtils.isNotBlank;\n\npublic class GreysConsole {\n\n    private final Socket socket;\n    private BufferedWriter socketWriter;\n    private BufferedReader socketReader;\n    private volatile boolean isRunning;\n\n    public GreysConsole(InetSocketAddress address) throws IOException {\n        this.socket = connect(address);\n        this.isRunning = true;\n    }\n\n    private Socket connect(InetSocketAddress address) throws IOException {\n        final Socket socket = new Socket();\n        socket.setSoTimeout(0);\n        socket.connect(address, 60 * 1000);\n        socket.setKeepAlive(true);\n        socketWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n        socketReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        return socket;\n    }\n\n    private void shutdown() {\n        isRunning = false;\n        closeQuietly(socketWriter);\n        closeQuietly(socketReader);\n        closeQuietly(socket);\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 1,
    "right_result": "import java.net.Socket;\nimport java.net.InetSocketAddress;\nimport java.io.BufferedWriter;\nimport java.io.BufferedReader;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class GreysConsole {\n    private Socket socket;\n    private BufferedWriter socketWriter;\n    private BufferedReader socketReader;\n    private boolean isRunning;\n\n    public GreysConsole(InetSocketAddress address) {\n        this.socket = connect(address);\n        isRunning = true;\n    }\n\n    public Socket connect(InetSocketAddress address) {\n        Socket socket = new Socket();\n        try {\n            socket.connect(address);\n            socket.setKeepAlive(true);\n            OutputStream os = socket.getOutputStream();\n            InputStream is = socket.getInputStream();\n            socketWriter = new BufferedWriter(new OutputStreamWriter(os));\n            socketReader = new BufferedReader(new InputStreamReader(is));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return socket;\n    }\n\n    public void shutdown() {\n        if (isRunning) {\n            try {\n                if (socket != null) {\n                    socket.close();\n                }\n                if (socketWriter != null) {\n                    socketWriter.close();\n                }\n                if (socketReader != null) {\n                    socketReader.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            isRunning = false;\n        }\n    }\n}"
  },
  {
    "Task_id": 591,
    "Instruction": "Here is the structured instruction for the given class-level reference code:\n\nTask Description: Implement a UDP-based position forwarding service that sends GPS position data in Wialon protocol format to a specified server.\n\nClass Description: PositionForwarderWialon is a class that handles the forwarding of position data to a remote server using UDP. It formats the position data according to the Wialon protocol, manages the UDP socket connection, and provides methods for sending position data and handling results.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- address: InetAddress - The target server's IP address\n- port: int - The target server's port number\n\nMethods:\n- PositionForwarderWialon(Config config, ExecutorService executorService) -> void - Constructor that initializes the UDP connection. Takes a configuration object and an executor service for background packet receiving.\n- sendPosition(Position position, String uniqueId, ResultHandler resultHandler) -> void - Formats and sends position data to the server. Takes a Position object, device unique ID, and a callback handler for results.\n- compressData(byte[] data) -> ByteBuf - Static method that compresses data using Deflater. Takes a byte array and returns a compressed ByteBuf.\n- formatAttributes(Map<String, Object> attributes) -> String - Static helper method that formats position attributes into a string. Takes a map of attributes and returns a formatted string.\n\nInterface:\n- ResultHandler: Functional interface with onResult(boolean success, Throwable throwable) method for handling send operation results.",
    "Canonical_solution": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport org.traccar.config.Config;\nimport org.traccar.config.Keys;\nimport org.traccar.helper.Checksum;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.Position;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.concurrent.ExecutorService;\nimport java.util.stream.Collectors;\nimport java.util.zip.Deflater;\n\npublic class PositionForwarderWialon {\n\n    private final DatagramSocket socket;\n    private final InetAddress address;\n    private final int port;\n\n    public PositionForwarderWialon(Config config, ExecutorService executorService) {\n        try {\n            URI url = new URI(config.getString(Keys.FORWARD_URL));\n            address = InetAddress.getByName(url.getHost());\n            port = url.getPort();\n            socket = new DatagramSocket();\n            executorService.submit(() -> {\n                byte[] buffer = new byte[1024];\n                while (!executorService.isShutdown()) {\n                    try {\n                        socket.receive(new DatagramPacket(buffer, buffer.length));\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n        } catch (IOException | URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void sendPosition(Position position, String uniqueId, ResultHandler resultHandler) {\n        DateFormat dateFormat = new SimpleDateFormat(\"ddMMyy;HHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        String payload = String.format(\n                \"%s;%02d%.5f;%s;%03d%.5f;%s;%d;%d;%d;NA;NA;NA;NA;;%s;%s\",\n                dateFormat.format(position.getFixTime()),\n                (int) Math.abs(position.getLatitude()),\n                Math.abs(position.getLatitude()) % 1 * 60,\n                position.getLatitude() >= 0 ? \"N\" : \"S\",\n                (int) Math.abs(position.getLongitude()),\n                Math.abs(position.getLongitude()) % 1 * 60,\n                position.getLongitude() >= 0 ? \"E\" : \"W\",\n                (int) UnitsConverter.kphFromKnots(position.getSpeed()),\n                (int) position.getCourse(),\n                (int) position.getAltitude(),\n                position.getString(Position.KEY_DRIVER_UNIQUE_ID, \"NA\"),\n                formatAttributes(position.getAttributes()));\n\n        String message = uniqueId + \"#D#\" + payload + \"\\r\\n\";\n        byte[] buffer = message.getBytes();\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, port);\n\n        try {\n            socket.send(packet);\n            resultHandler.onResult(true, null);\n        } catch (IOException e) {\n            resultHandler.onResult(false, e);\n        }\n    }\n\n    public static ByteBuf compressData(byte[] data) {\n        ByteBuf container;\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n\n        ByteBuf compressedData = Unpooled.buffer(data.length);\n        byte[] tempBuffer = new byte[1024];\n\n        try {\n            while (!deflater.finished()) {\n                int count = deflater.deflate(tempBuffer);\n                compressedData.writeBytes(tempBuffer, 0, count);\n            }\n            container = Unpooled.buffer(3 + compressedData.readableBytes());\n            container.writeByte(0xFF);\n            container.writeShortLE(compressedData.readableBytes());\n            container.writeBytes(compressedData);\n        } finally {\n            deflater.end();\n            compressedData.release();\n        }\n\n        return container;\n    }\n\n    public static String formatAttributes(Map<String, Object> attributes) {\n        if (attributes.isEmpty()) {\n            return \"NA\";\n        }\n        return attributes.entrySet().stream()\n                .map(entry -> {\n                    Object value = entry.getValue();\n                    int type;\n                    if (value instanceof Double || value instanceof Float) {\n                        type = 2;\n                    } else if (value instanceof Number) {\n                        type = 1;\n                    } else {\n                        type = 3;\n                    }\n                    return entry.getKey() + \":\" + type + \":\" + value;\n                })\n                .collect(Collectors.joining(\",\"));\n    }\n\n    public interface ResultHandler {\n        void onResult(boolean success, Throwable throwable);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport java.util.zip.Deflater;\n\npublic class PositionForwarderWialon {\n    private DatagramSocket socket;\n    private InetAddress address;\n    private int port;\n\n    public PositionForwarderWialon(Config config, ExecutorService executorService) {\n        try {\n            socket = new DatagramSocket();\n            address = InetAddress.getByName(config.getServerAddress());\n            port = config.getServerPort();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize socket\", e);\n        }\n    }\n\n    public void sendPosition(Position position, String uniqueId, ResultHandler resultHandler) {\n        try {\n            Map<String, Object> attributes = new HashMap<>();\n            attributes.put(\"id\", uniqueId);\n            attributes.put(\"lat\", position.getLatitude());\n            attributes.put(\"lon\", position.getLongitude());\n            String formatted = formatAttributes(attributes);\n            byte[] data = formatted.getBytes();\n            ByteBuf compressedData = compressData(data);\n            byte[] sendData = new byte[compressedData.readableBytes()];\n            compressedData.readBytes(sendData);\n            DatagramPacket packet = new DatagramPacket(sendData, sendData.length, address, port);\n            socket.send(packet);\n            resultHandler.onResult(true, null);\n        } catch (Exception e) {\n            resultHandler.onResult(false, e);\n        }\n    }\n\n    public static ByteBuf compressData(byte[] data) {\n        ByteBuf buffer = Unpooled.buffer();\n        Deflater deflater = new Deflater();\n        deflater.setInput(data);\n        deflater.finish();\n        byte[] compressed = new byte[1024];\n        int compressedLength;\n        while ((compressedLength = deflater.deflate(compressed)) > 0) {\n            buffer.writeBytes(compressed, 0, compressedLength);\n        }\n        deflater.end();\n        return buffer;\n    }\n\n    public static String formatAttributes(Map<String, Object> attributes) {\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n            sb.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\",\");\n        }\n        if (sb.length() > 0) {\n            sb.setLength(sb.length() - 1);\n        }\n        return sb.toString();\n    }\n}\n\n@FunctionalInterface\npublic interface ResultHandler {\n    void onResult(boolean success, Throwable throwable);\n}"
  },
  {
    "Task_id": 592,
    "Instruction": "Task Description: Implement a DNS resolver class that handles UDP communication for DNS query processing, sending DNS payloads to a specified local port and receiving responses.\n\nClass Description: The DNSResolver class provides functionality to send DNS query payloads via UDP to a local port and receive the corresponding DNS responses. It handles the creation of UDP sockets and packets for communication.\n\nAttributes:\nmPort: int - The local port number to which DNS queries will be sent\nmLocalhost: InetAddress - The local host address used for UDP communication\n\nMethods:\nDNSResolver(int localPort) -> void - Constructor that initializes the DNS resolver with the specified local port number\nprocessDNS(byte[] payload) -> byte[] - Sends the given DNS payload to the configured local port via UDP and returns the received DNS response\n    - Input: payload (byte[]) - The DNS query payload to be sent\n    - Output: byte[] - The received DNS response data",
    "Canonical_solution": "import java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class DNSResolver {\n\n    private final int mPort;\n    private InetAddress mLocalhost = null;\n\n    public DNSResolver(int localPort) {\n        mPort = localPort;\n    }\n\n    public byte[] processDNS(byte[] payload) throws IOException {\n        if (mLocalhost == null) mLocalhost = InetAddress.getLocalHost();\n\n        DatagramPacket packet = new DatagramPacket(payload, payload.length, mLocalhost, mPort);\n        DatagramSocket datagramSocket = new DatagramSocket();\n        datagramSocket.send(packet);\n\n        byte[] buf = new byte[1024];\n        packet = new DatagramPacket(buf, buf.length);\n        datagramSocket.receive(packet);\n        datagramSocket.close();\n\n        return packet.getData();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.util.Arrays;\n\npublic class DNSResolver {\n    private int mPort;\n    private InetAddress mLocalhost;\n\n    public DNSResolver(int localPort) {\n        mPort = localPort;\n        try {\n            mLocalhost = InetAddress.getLoopbackAddress();\n        } catch (Exception e) {\n            mLocalhost = null;\n        }\n    }\n\n    public byte[] processDNS(byte[] payload) {\n        try {\n            DatagramSocket socket = new DatagramSocket(mPort);\n            DatagramPacket sendPacket = new DatagramPacket(payload, payload.length, mLocalhost, 53);\n            socket.send(sendPacket);\n            byte[] receiveBuffer = new byte[512];\n            DatagramPacket receivePacket = new DatagramPacket(receiveBuffer, receiveBuffer.length);\n            socket.receive(receivePacket);\n            return Arrays.copyOf(receiveBuffer, receivePacket.getLength());\n        } catch (Exception e) {\n            return new byte[0];\n        }\n    }\n}"
  },
  {
    "Task_id": 594,
    "Instruction": "Task Description: Implement a UDP client class in Java that can receive data packets from a UDP server and process them, including extracting the sender's address and port information.\n\nClass Description: The UDPClient class is designed to handle UDP communication as a client. It creates a UDP socket bound to a specific port, receives incoming packets, processes the data, and provides information about the sender. The class includes methods for receiving data and cleaning up resources.\n\nAttributes:\n- socket: DatagramSocket - The UDP socket used for communication\n- packet: DatagramPacket - The packet object used for receiving data\n- buffer: byte[] - The buffer used to store incoming packet data\n\nMethods:\n- UDPClient(int port) -> void - Constructor that initializes the UDP client. Takes a port number as input to bind the socket.\n  - port: int - The port number to bind the socket to\n- receiveData() -> String - Receives a UDP packet, extracts the data, and returns it along with sender information\n  - Returns: String - The received data concatenated with sender's IP address and port\n- close() -> void - Closes the socket and releases system resources",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPClient {\n\n    private DatagramSocket socket;\n    private DatagramPacket packet;\n    private byte[] buffer;\n\n    public UDPClient(int port) throws Exception {\n        this.buffer = new byte[1024];\n        this.socket = new DatagramSocket(port);\n        this.packet = new DatagramPacket(buffer, buffer.length);\n    }\n\n    public String receiveData() throws Exception {\n        socket.receive(packet);\n        String data = new String(packet.getData(), 0, packet.getLength());\n        return data + \"from \" + packet.getAddress().getHostAddress() + \":\" + packet.getPort();\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\n\npublic class UDPClient {\n    private DatagramSocket socket;\n    private DatagramPacket packet;\n    private byte[] buffer;\n\n    public UDPClient(int port) {\n        try {\n            socket = new DatagramSocket(port);\n            buffer = new byte[1024];\n            packet = new DatagramPacket(buffer, buffer.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String receiveData() {\n        try {\n            socket.receive(packet);\n            String data = new String(packet.getData(), 0, packet.getLength());\n            InetAddress address = packet.getAddress();\n            int port = packet.getPort();\n            return data + \" from \" + address.getHostAddress() + \":\" + port;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"Error receiving data\";\n        }\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}"
  },
  {
    "Task_id": 6,
    "Instruction": "Task Description: Create a Kafka topic using the AdminClient API in Java.\n\nFunction Description: This function creates a new Kafka topic with the specified name, number of partitions, and replication factor. It uses the Kafka AdminClient to interact with the Kafka broker and handles potential exceptions during the topic creation process.\n\nInput: \n- topic: String - The name of the Kafka topic to be created.\n\nOutput: \n- void - The function does not return any value but creates the topic in Kafka and stores the AdminClient instance in the class field.\n\nExceptions:\n- InterruptedException: If the thread is interrupted while waiting for the topic creation to complete.\n- ExecutionException: If the topic creation fails during execution.\n- TimeoutException: If the topic creation takes longer than the specified timeout period.",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport wiremock.com.google.common.collect.ImmutableMap;\n\nprivate AdminClient adminClient;\n\nprivate void createTopic(String topic) throws InterruptedException, ExecutionException, TimeoutException {\n    AdminClient adminClient = AdminClient\n        .create(ImmutableMap.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaContainer.getBootstrapServers()));\n    Collection<NewTopic> topics = Collections.singletonList(new NewTopic(topic, 3, (short) 1));\n    adminClient.createTopics(topics).all().get(30, TimeUnit.SECONDS);\n    this.adminClient = adminClient;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 34,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.List;\nimport java.util.concurrent.Future;\n\npublic class KafkaTopicManager {\n    private AdminClient adminClient;\n\n    public void createTopic(String topic) throws InterruptedException, ExecutionException, TimeoutException {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\");\n        adminClient = AdminClient.create(props);\n        NewTopic newTopic = new NewTopic(topic, 3, (short) 1);\n        List<Future<CreateTopicsResult>> futures = adminClient.createTopics(Collections.singletonList(newTopic));\n        for (Future<CreateTopicsResult> future : futures) {\n            future.get(10, TimeUnit.SECONDS);\n        }\n    }\n}"
  },
  {
    "Task_id": 601,
    "Instruction": "Task Description: Create a Java class that implements UDP communication functionality for sending and receiving packets, with configurable buffer size and port management.\n\nClass Description: The SnmpUdpHandler class provides UDP network communication capabilities for both sending and receiving datagram packets. It encapsulates the Java DatagramSocket functionality with additional convenience methods for packet handling and resource management.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket used for communication\n- bufferSize: int - The size of the buffer used for receiving packets (default 1024)\n- address: InetAddress - The IP address the socket is bound to\n- port: int - The port number the socket is bound to\n\nMethods:\n- SnmpUdpHandler(int port, InetAddress address) -> void - Constructor that initializes the UDP socket bound to the specified port and address\n- sendPacket(byte[] data, InetAddress destination, int destPort) -> void - Sends a UDP packet containing the specified data to the given destination address and port\n- receivePacket() -> byte[] - Receives a UDP packet and returns its data as a byte array\n- close() -> void - Closes the UDP socket and releases system resources\n- getPort() -> int - Returns the local port number the socket is bound to\n- setBufferSize(int size) -> void - Sets the buffer size used for receiving packets",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class SnmpUdpHandler {\n\n    private DatagramSocket socket;\n    private int bufferSize = 1024;\n    private InetAddress address;\n    private int port;\n\n    public SnmpUdpHandler(int port, InetAddress address) throws SocketException {\n        this.port = port;\n        this.address = address;\n        this.socket = new DatagramSocket(port, address);\n    }\n\n    public void sendPacket(byte[] data, InetAddress destination, int destPort) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        byte[] buffer = new byte[bufferSize];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    public int getPort() {\n        return socket != null ? socket.getLocalPort() : port;\n    }\n\n    public void setBufferSize(int size) {\n        this.bufferSize = size;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.DatagramPacket;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class SnmpUdpHandler {\n    private DatagramSocket socket;\n    private int bufferSize = 1024;\n    private InetAddress address;\n    private int port;\n\n    public SnmpUdpHandler(int port, InetAddress address) throws IOException {\n        this.socket = new DatagramSocket(port, address);\n        this.address = address;\n        this.port = socket.getLocalPort();\n    }\n\n    public void sendPacket(byte[] data, InetAddress destination, int destPort) throws IOException {\n        DatagramPacket packet = new DatagramPacket(data, data.length, destination, destPort);\n        socket.send(packet);\n    }\n\n    public byte[] receivePacket() throws IOException {\n        byte[] buffer = new byte[bufferSize];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        socket.receive(packet);\n        return Arrays.copyOf(buffer, packet.getLength());\n    }\n\n    public void close() {\n        if (socket != null) {\n            socket.close();\n        }\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public void setBufferSize(int size) {\n        bufferSize = size;\n    }\n}"
  },
  {
    "Task_id": 602,
    "Instruction": "Task Description: Create a UDP server class that listens for incoming packets on a specified port, processes the received data, and provides a method to retrieve the received message.\n\nClass Description: The UdpServer class implements a Runnable interface to handle UDP communication asynchronously. It creates a datagram socket bound to a specified port, receives incoming packets, stores the message content, and allows retrieval of the received message. The server operates with a timeout of 60 seconds.\n\nAttributes:\n- serverSocket: DatagramSocket - The UDP socket used for communication\n- message: String - Stores the received message from the client\n\nMethods:\n- UdpServer(int port) -> void - Constructor that initializes the UDP server on the specified port and starts the receiver thread\n- run() -> void - The thread's main execution method that receives incoming packets and processes the data\n- getMessage() -> String - Retrieves the received message after processing",
    "Canonical_solution": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UdpServer implements Runnable {\n\n    private final DatagramSocket serverSocket;\n    private String message;\n\n    public UdpServer(int port) throws SocketException, InterruptedException {\n        serverSocket = new DatagramSocket(port);\n        serverSocket.setSoTimeout(60000);\n        final Thread thread = new Thread(this);\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    @Override\n    public synchronized void run() {\n        final byte[] data = new byte[1024];\n        final DatagramPacket packet = new DatagramPacket(data, data.length);\n        try {\n            serverSocket.receive(packet);\n            message = new String(packet.getData()).trim();\n        } catch (IOException e) {\n            message = \"Exception while receiving sentry call. \" + e.getMessage();\n        }\n    }\n\n    public synchronized String getMessage() throws InterruptedException {\n        return message;\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketTimeoutException;\nimport java.nio.charset.StandardCharsets;\n\npublic class UdpServer implements Runnable {\n    private DatagramSocket serverSocket;\n    private String message;\n\n    public UdpServer(int port) {\n        try {\n            serverSocket = new DatagramSocket(port);\n            serverSocket.setSoTimeout(60000);\n            message = \"\";\n            Thread thread = new Thread(this);\n            thread.start();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        try {\n            serverSocket.receive(packet);\n            message = new String(packet.getData(), 0, packet.getLength(), StandardCharsets.UTF_8);\n        } catch (SocketTimeoutException e) {\n            // Timeout, message remains empty\n        } catch (Exception e) {\n            // Handle other exceptions\n        } finally {\n            if (serverSocket != null) {\n                serverSocket.close();\n            }\n        }\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}"
  },
  {
    "Task_id": 606,
    "Instruction": "Task Description: Create a Java class for handling UDP communication that can both send and receive datagram packets, with proper socket management and error handling.\n\nClass Description: The UdpCommunicationHandler class provides a wrapper for Java's UDP socket functionality, enabling both sending and receiving of datagram packets. It manages socket lifecycle and provides status checking methods.\n\nAttributes:\n- socket: DatagramSocket - The underlying UDP socket for communication\n- bindAddress: InetSocketAddress - The address and port to which the socket is bound\n\nMethods:\n- UdpCommunicationHandler(String bindIp, int bindPort) -> void - Constructor that initializes and binds the UDP socket to the specified IP and port\n- sendData(byte[] data, String targetIp, int targetPort) -> void - Sends the provided data as a UDP packet to the specified target IP and port\n- receiveData() -> byte[] - Receives incoming UDP packet data and returns it as a byte array\n- close() -> void - Closes the UDP socket if it's open\n- isBound() -> boolean - Returns whether the socket is currently bound to an address\n- isClosed() -> boolean - Returns whether the socket is closed",
    "Canonical_solution": "import java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.io.IOException;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket socket;\n    private InetSocketAddress bindAddress;\n\n    public UdpCommunicationHandler(String bindIp, int bindPort) throws SocketException {\n        this.bindAddress = new InetSocketAddress(bindIp, bindPort);\n        this.socket = new DatagramSocket(null);\n        this.socket.bind(this.bindAddress);\n    }\n\n    public void sendData(byte[] data, String targetIp, int targetPort) throws IOException {\n        InetSocketAddress targetAddress = new InetSocketAddress(targetIp, targetPort);\n        DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress);\n        this.socket.send(packet);\n    }\n\n    public byte[] receiveData() throws IOException {\n        byte[] buffer = new byte[800];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        this.socket.receive(packet);\n        return packet.getData();\n    }\n\n    public void close() {\n        if (this.socket != null && !this.socket.isClosed()) {\n            this.socket.close();\n        }\n    }\n\n    public boolean isBound() {\n        return this.socket != null && this.socket.isBound();\n    }\n\n    public boolean isClosed() {\n        return this.socket == null || this.socket.isClosed();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.net.InetAddress;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class UdpCommunicationHandler {\n    private DatagramSocket socket;\n    private InetSocketAddress bindAddress;\n\n    public UdpCommunicationHandler(String bindIp, int bindPort) {\n        try {\n            InetAddress address = InetAddress.getByName(bindIp);\n            bindAddress = new InetSocketAddress(address, bindPort);\n            socket = new DatagramSocket(bindAddress);\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + bindIp);\n            socket = null;\n        } catch (SocketException e) {\n            System.err.println(\"Socket creation error: \" + e.getMessage());\n            socket = null;\n        }\n    }\n\n    public void sendData(byte[] data, String targetIp, int targetPort) {\n        try {\n            InetAddress targetAddress = InetAddress.getByName(targetIp);\n            DatagramPacket packet = new DatagramPacket(data, data.length, targetAddress, targetPort);\n            socket.send(packet);\n        } catch (UnknownHostException e) {\n            System.err.println(\"Unknown host: \" + targetIp);\n        } catch (IOException e) {\n            System.err.println(\"Error sending data: \" + e.getMessage());\n        }\n    }\n\n    public byte[] receiveData() {\n        byte[] buffer = new byte[65507];\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n        try {\n            socket.receive(packet);\n            return Arrays.copyOf(buffer, packet.getLength());\n        } catch (IOException e) {\n            System.err.println(\"Error receiving data: \" + e.getMessage());\n            return null;\n        }\n    }\n\n    public void close() {\n        if (socket != null && !socket.isClosed()) {\n            socket.close();\n            socket = null;\n        }\n    }\n\n    public boolean isBound() {\n        return socket != null && socket.getLocalAddress() != null;\n    }\n\n    public boolean isClosed() {\n        return socket == null || socket.isClosed();\n    }\n}"
  },
  {
    "Task_id": 608,
    "Instruction": "Task Description: Implement a UDP-based client class for network communication that can send and receive datagram packets, manage connections, and handle timeouts.\n\nClass Description: ConnectDatagram is a UDP client class that extends a base Connection class. It provides functionality for sending and receiving XDR-encoded data over UDP, managing socket connections, and handling peer address information.\n\nAttributes:\n- ds: DatagramSocket - The UDP socket used for communication\n- dp: DatagramPacket - The packet used for receiving data\n- addr: InetAddress - The IP address of the server/peer\n\nMethods:\n- ConnectDatagram(String server, int port, int maxSize) -> void - Constructor that initializes the UDP connection with server address, port, and maximum packet size\n- sendOne(Xdr x) -> void - Sends an XDR-encoded packet to the server\n- receiveOne(Xdr x, int timeout) -> void - Receives an XDR-encoded packet with a specified timeout\n- getPeer() -> InetAddress - Returns the address of the peer that sent the last received packet\n- dropConnection() -> void - Placeholder for connection cleanup (UDP is connectionless)\n- checkConnection() -> void - Placeholder for connection verification (UDP is connectionless)\n- finalize() -> void - Cleans up resources by closing the socket when the object is garbage collected",
    "Canonical_solution": "import java.io.*;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class ConnectDatagram extends Connection {\n\n    DatagramSocket ds;\n    DatagramPacket dp;\n    InetAddress addr;\n\n    public ConnectDatagram(String server, int port, int maxSize) throws IOException {\n        super(server, port, \"udp\", maxSize);\n        ds = new DatagramSocket();\n        addr = InetAddress.getByName(server);\n        start();\n    }\n\n    void sendOne(Xdr x) throws IOException {\n        ds.send(new DatagramPacket(x.xdr_buf(), x.xdr_offset(), addr, port));\n    }\n\n    void receiveOne(Xdr x, int timeout) throws IOException {\n        ds.setSoTimeout(timeout);\n        dp = new DatagramPacket(x.xdr_buf(), x.xdr_buf().length);\n        ds.receive(dp);\n    }\n\n    InetAddress getPeer() {\n        return dp.getAddress();\n    }\n\n    void dropConnection() {\n    }\n\n    void checkConnection() {\n    }\n\n    protected void finalize() throws Throwable {\n        if (ds != null) {\n            ds.close();\n            ds = null;\n        }\n        super.finalize();\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.*;\nimport java.io.*;\n\npublic class ConnectDatagram extends Connection {\n    private DatagramSocket ds;\n    private DatagramPacket dp;\n    private InetAddress addr;\n    private int port;\n\n    public ConnectDatagram(String server, int port, int maxSize) {\n        try {\n            this.addr = InetAddress.getByName(server);\n            this.port = port;\n            this.dp = new DatagramPacket(new byte[maxSize], maxSize);\n            this.ds = new DatagramSocket();\n            ds.setReceiveBufferSize(maxSize);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void sendOne(Xdr x) {\n        try {\n            byte[] data = x.encode();\n            DatagramPacket packet = new DatagramPacket(data, data.length, addr, port);\n            ds.send(packet);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void receiveOne(Xdr x, int timeout) {\n        try {\n            ds.setSoTimeout(timeout);\n            ds.receive(dp);\n            byte[] receivedData = dp.getData();\n            int length = dp.getLength();\n            x.decode(receivedData, 0, length);\n        } catch (SocketTimeoutException e) {\n            // Handle timeout\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public InetAddress getPeer() {\n        return dp.getAddress();\n    }\n\n    public void dropConnection() {\n        // Placeholder\n    }\n\n    public void checkConnection() {\n        // Placeholder\n    }\n\n    protected void finalize() throws Throwable {\n        try {\n            if (ds != null) {\n                ds.close();\n            }\n        } finally {\n            super.finalize();\n        }\n    }\n}"
  },
  {
    "Task_id": 610,
    "Instruction": "Task Description: Implement a UDP-based tracker client for peer-to-peer file sharing systems that can connect to a tracker server, maintain connection state, and handle announce requests and responses.\n\nClass Description: UDPTrackerClient is a specialized tracker client that communicates with BitTorrent trackers using UDP protocol. It handles connection establishment, announcement of peer information, and manages timeouts and retries for reliable communication.\n\nAttributes:\n- logger: Logger - Logger instance for tracking client activities\n- UDP_BASE_TIMEOUT_SECONDS: int - Base timeout value for UDP communication\n- UDP_MAX_TRIES: int - Maximum number of retry attempts\n- UDP_MAX_TRIES_ON_STOPPED: int - Maximum retries for STOPPED events\n- UDP_PACKET_LENGTH: int - Maximum UDP packet size\n- address: InetSocketAddress - Tracker server address\n- random: Random - Random number generator for transaction IDs\n- socket: DatagramSocket - UDP communication socket\n- connectionExpiration: Date - When the current connection expires\n- connectionId: long - Current connection identifier\n- transactionId: int - Current transaction identifier\n- stop: boolean - Flag to indicate if client should stop operations\n\nMethods:\n- UDPTrackerClient(List<Peer> peers, URI tracker) -> void - Constructor that initializes the client with peer list and tracker URI\n- announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) -> void - Main method to announce peer information to tracker\n- handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) -> void - Processes announce responses from tracker\n- close() -> void - Closes the client and releases resources\n- buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) -> UDPAnnounceRequestMessage - Constructs announce request message\n- validateTrackerResponse(TrackerMessage message) -> void - Validates tracker response messages\n- handleTrackerConnectResponse(TrackerMessage message) -> void - Processes connection responses from tracker\n- send(ByteBuffer data) -> void - Sends data to tracker server\n- recv(int attempt) -> ByteBuffer - Receives data from tracker server with timeout handling",
    "Canonical_solution": "import com.turn.ttorrent.common.AnnounceableInformation;\nimport com.turn.ttorrent.common.Peer;\nimport com.turn.ttorrent.common.TorrentLoggerFactory;\nimport com.turn.ttorrent.common.protocol.AnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;\nimport com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;\nimport com.turn.ttorrent.common.protocol.udp.UDPAnnounceRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectRequestMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPConnectResponseMessage;\nimport com.turn.ttorrent.common.protocol.udp.UDPTrackerMessage;\nimport org.slf4j.Logger;\n\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.UnsupportedAddressTypeException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Random;\n\npublic class UDPTrackerClient extends TrackerClient {\n\n  protected static final Logger logger =\n          TorrentLoggerFactory.getLogger(UDPTrackerClient.class);\n\n  private static final int UDP_BASE_TIMEOUT_SECONDS = 15;\n  private static final int UDP_MAX_TRIES = 8;\n  private static final int UDP_MAX_TRIES_ON_STOPPED = 1;\n  private static final int UDP_PACKET_LENGTH = 512;\n\n  private final InetSocketAddress address;\n  private final Random random;\n\n  private DatagramSocket socket;\n  private Date connectionExpiration;\n  private long connectionId;\n  private int transactionId;\n  private boolean stop;\n\n  public UDPTrackerClient(List<Peer> peers, URI tracker)\n          throws UnknownHostException {\n    super(peers, tracker);\n\n    for (Peer peer : peers) {\n      if (!(InetAddress.getByName(peer.getIp()) instanceof Inet4Address)) {\n        throw new UnsupportedAddressTypeException();\n      }\n    }\n\n    this.address = new InetSocketAddress(\n            tracker.getHost(),\n            tracker.getPort());\n\n    this.socket = null;\n    this.random = new Random();\n    this.connectionExpiration = null;\n    this.stop = false;\n  }\n\n  @Override\n  public void announce(final AnnounceRequestMessage.RequestEvent event,\n                       boolean inhibitEvents, final AnnounceableInformation torrent, final List<Peer> peers) throws AnnounceException {\n    int maxAttempts = AnnounceRequestMessage.RequestEvent\n            .STOPPED.equals(event)\n            ? UDP_MAX_TRIES_ON_STOPPED\n            : UDP_MAX_TRIES;\n    int attempts = -1;\n\n    try {\n      this.socket = new DatagramSocket();\n      this.socket.connect(this.address);\n\n      while (++attempts <= maxAttempts) {\n        this.transactionId = this.random.nextInt();\n\n        if (this.connectionExpiration != null) {\n          if (new Date().before(this.connectionExpiration)) {\n            for (Peer peer : peers) {\n              this.send(this.buildAnnounceRequest(event, torrent, peer).getData());\n            }\n\n            try {\n              this.handleTrackerAnnounceResponse(\n                      UDPTrackerMessage.UDPTrackerResponseMessage\n                              .parse(this.recv(attempts)), inhibitEvents, torrent.getHexInfoHash());\n              return;\n            } catch (SocketTimeoutException ste) {\n              if (stop) {\n                return;\n              }\n            }\n          }\n        }\n\n        this.send(UDPConnectRequestMessage\n                .craft(this.transactionId).getData());\n\n        try {\n          this.handleTrackerConnectResponse(\n                  UDPTrackerMessage.UDPTrackerResponseMessage\n                          .parse(this.recv(attempts)));\n          attempts = -1;\n        } catch (SocketTimeoutException ste) {\n          if (stop) {\n            return;\n          }\n        }\n      }\n\n      throw new AnnounceException(\"Timeout while announcing\" +\n              this.formatAnnounceEvent(event) + \" to tracker!\");\n    } catch (IOException ioe) {\n      throw new AnnounceException(\"Error while announcing\" +\n              this.formatAnnounceEvent(event) +\n              \" to tracker: \" + ioe.getMessage(), ioe);\n    } catch (MessageValidationException mve) {\n      throw new AnnounceException(\"Tracker message violates expected \" +\n              \"protocol (\" + mve.getMessage() + \")\", mve);\n    }\n  }\n\n  @Override\n  protected void handleTrackerAnnounceResponse(TrackerMessage message,\n                                               boolean inhibitEvents, String hexInfoHash) throws AnnounceException {\n    this.validateTrackerResponse(message);\n    super.handleTrackerAnnounceResponse(message, inhibitEvents, hexInfoHash);\n  }\n\n  @Override\n  protected void close() {\n    this.stop = true;\n    if (this.socket != null && !this.socket.isClosed()) {\n      this.socket.close();\n    }\n  }\n\n  private UDPAnnounceRequestMessage buildAnnounceRequest(\n          final AnnounceRequestMessage.RequestEvent event, final AnnounceableInformation torrent, final Peer peer) {\n    return UDPAnnounceRequestMessage.craft(\n            this.connectionId,\n            transactionId,\n            torrent.getInfoHash(),\n            peer.getPeerIdArray(),\n            torrent.getDownloaded(),\n            torrent.getUploaded(),\n            torrent.getLeft(),\n            event,\n            peer.getAddress().getAddress(),\n            0,\n            AnnounceRequestMessage.DEFAULT_NUM_WANT,\n            peer.getPort());\n  }\n\n  private void validateTrackerResponse(TrackerMessage message)\n          throws AnnounceException {\n    if (message instanceof ErrorMessage) {\n      throw new AnnounceException(((ErrorMessage) message).getReason());\n    }\n\n    if (message instanceof UDPTrackerMessage &&\n            (((UDPTrackerMessage) message).getTransactionId() != this.transactionId)) {\n      throw new AnnounceException(\"Invalid transaction ID!\");\n    }\n  }\n\n  private void handleTrackerConnectResponse(TrackerMessage message)\n          throws AnnounceException {\n    this.validateTrackerResponse(message);\n\n    if (!(message instanceof ConnectionResponseMessage)) {\n      throw new AnnounceException(\"Unexpected tracker message type \" +\n              message.getType().name() + \"!\");\n    }\n\n    UDPConnectResponseMessage connectResponse =\n            (UDPConnectResponseMessage) message;\n\n    this.connectionId = connectResponse.getConnectionId();\n    Calendar now = Calendar.getInstance();\n    now.add(Calendar.MINUTE, 1);\n    this.connectionExpiration = now.getTime();\n  }\n\n  private void send(ByteBuffer data) {\n    try {\n      this.socket.send(new DatagramPacket(\n              data.array(),\n              data.capacity(),\n              this.address));\n    } catch (IOException ioe) {\n      logger.info(\"Error sending datagram packet to tracker at {}: {}.\", this.address, ioe.getMessage());\n    }\n  }\n\n  private ByteBuffer recv(int attempt)\n          throws IOException, SocketException, SocketTimeoutException {\n    int timeout = UDP_BASE_TIMEOUT_SECONDS * (int) Math.pow(2, attempt);\n    logger.trace(\"Setting receive timeout to {}s for attempt {}...\",\n            timeout, attempt);\n    this.socket.setSoTimeout(timeout * 1000);\n\n    try {\n      DatagramPacket p = new DatagramPacket(\n              new byte[UDP_PACKET_LENGTH],\n              UDP_PACKET_LENGTH);\n      this.socket.receive(p);\n      return ByteBuffer.wrap(p.getData(), 0, p.getLength());\n    } catch (SocketTimeoutException ste) {\n      throw ste;\n    }\n  }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 2,
    "right_result": "import java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.DatagramSocket;\nimport java.net.DatagramPacket;\nimport java.nio.ByteBuffer;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.List;\nimport java.util.logging.Logger;\n\npublic class UDPTrackerClient {\n    private final Logger logger;\n    private final int UDP_BASE_TIMEOUT_SECONDS = 5;\n    private final int UDP_MAX_TRIES = 3;\n    private final int UDP_MAX_TRIES_ON_STOPPED = 10;\n    private final int UDP_PACKET_LENGTH = 65507;\n    private final InetSocketAddress address;\n    private final Random random;\n    private DatagramSocket socket;\n    private Date connectionExpiration;\n    private long connectionId;\n    private int transactionId;\n    private boolean stop;\n\n    public UDPTrackerClient(List<Peer> peers, URI tracker) {\n        this.logger = Logger.getLogger(UDPTrackerClient.class.getName());\n        this.random = new Random();\n        this.address = new InetSocketAddress(tracker.getHost(), tracker.getPort());\n        this.socket = new DatagramSocket();\n        this.stop = false;\n    }\n\n    public void announce(AnnounceRequestMessage.RequestEvent event, boolean inhibitEvents, AnnounceableInformation torrent, List<Peer> peers) {\n        if (stop) return;\n        UDPAnnounceRequestMessage request = buildAnnounceRequest(event, torrent, peers.get(0));\n        send(request.toByteBuffer());\n        ByteBuffer response = recv(1);\n        handleTrackerAnnounceResponse(new TrackerMessage(response), inhibitEvents, torrent.getInfoHash());\n    }\n\n    private void handleTrackerAnnounceResponse(TrackerMessage message, boolean inhibitEvents, String hexInfoHash) {\n        validateTrackerResponse(message);\n        if (message.getType() == TrackerMessage.Type.Announce) {\n            // process announce response\n        }\n    }\n\n    public void close() {\n        stop = true;\n        if (socket != null) socket.close();\n    }\n\n    private UDPAnnounceRequestMessage buildAnnounceRequest(AnnounceRequestMessage.RequestEvent event, AnnounceableInformation torrent, Peer peer) {\n        // build request with event, torrent info, peer info, connectionId, transactionId\n        return new UDPAnnounceRequestMessage(event, torrent.getInfoHash(), peer.getId(), peer.getPort(), connectionId, transactionId);\n    }\n\n    private void validateTrackerResponse(TrackerMessage message) {\n        // validate message type, transactionId, etc.\n    }\n\n    private void send(ByteBuffer data) {\n        byte[] buffer = new byte[data.remaining()];\n        data.get(buffer);\n        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address);\n        socket.send(packet);\n    }\n\n    private ByteBuffer recv(int attempt) {\n        ByteBuffer response = ByteBuffer.allocate(UDP_PACKET_LENGTH);\n        long timeout = UDP_BASE_TIMEOUT_SECONDS * 1000;\n        if (attempt > UDP_MAX_TRIES) {\n            timeout *= attempt;\n        }\n        socket.setSoTimeout((int) timeout);\n        try {\n            byte[] buffer = new byte[UDP_PACKET_LENGTH];\n            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n            socket.receive(packet);\n            response.put(buffer, 0, packet.getLength());\n            response.flip();\n        } catch (Exception e) {\n            if (attempt < UDP_MAX_TRIES) {\n                return recv(attempt + 1);\n            } else {\n                logger.severe(\"Failed to receive response after \" + UDP_MAX_TRIES + \" attempts\");\n            }\n        }\n        return response;\n    }\n}"
  },
  {
    "Task_id": 8,
    "Instruction": "Task Description: Create a Kafka topic using Java's AdminClient API with configurable properties, partitions, and replication factor.\n\nClass Description: The KafkaTopicCreator class provides functionality to create Kafka topics programmatically. It encapsulates the AdminClient configuration and topic creation logic, handling the connection lifecycle and operation timeout.\n\nAttributes:\n- adminClientProperties: Map<String, Object> - Configuration properties for the AdminClient, initialized from KafkaProperties\n- operationTimeout: int - Timeout duration in seconds for Kafka operations (default: 30)\n\nMethods:\n- createTopic(String topicName, int partitions, short replicationFactor) -> void - Creates a new Kafka topic with the specified name, partition count, and replication factor. Throws Exception if operation fails or times out.\n- getAdminClientProperties() -> Map<String, Object> - Returns an unmodifiable view of the AdminClient configuration properties\n\nConstructor:\n- KafkaTopicCreator(KafkaProperties kafkaProperties) - Initializes the class with Kafka configuration properties",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.AdminClientConfig;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.springframework.boot.autoconfigure.kafka.KafkaProperties;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\npublic class KafkaTopicCreator {\n\n    private final Map<String, Object> adminClientProperties;\n    private final int operationTimeout = 30;\n\n    public KafkaTopicCreator(KafkaProperties kafkaProperties) {\n        this.adminClientProperties = kafkaProperties.buildAdminProperties(null);\n    }\n\n    public void createTopic(String topicName, int partitions, short replicationFactor) throws Exception {\n        try (AdminClient adminClient = AdminClient.create(this.adminClientProperties)) {\n            NewTopic newTopic = new NewTopic(topicName, partitions, replicationFactor);\n            CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singletonList(newTopic));\n            KafkaFuture<Void> future = createTopicsResult.all();\n            future.get(this.operationTimeout, TimeUnit.SECONDS);\n        }\n    }\n\n    public Map<String, Object> getAdminClientProperties() {\n        return Collections.unmodifiableMap(this.adminClientProperties);\n    }\n}",
    "Code_level": "Class-level",
    "FSMID_for_test": 34,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeoutException;\n\npublic class KafkaTopicCreator {\n    private final Map<String, Object> adminClientProperties;\n    private final int operationTimeout;\n    private AdminClient adminClient;\n\n    public KafkaTopicCreator(KafkaProperties kafkaProperties) {\n        this.adminClientProperties = kafkaProperties.getProperties();\n        this.operationTimeout = 30;\n        this.adminClient = AdminClient.create(adminClientProperties);\n    }\n\n    public void createTopic(String topicName, int partitions, short replicationFactor) throws Exception {\n        try {\n            NewTopic newTopic = new NewTopic(topicName, partitions, replicationFactor);\n            adminClient.createTopics(Collections.singletonList(newTopic)).get(operationTimeout, TimeUnit.SECONDS);\n        } catch (ExecutionException | TimeoutException e) {\n            throw new Exception(\"Failed to create topic: \" + topicName, e);\n        } finally {\n            if (adminClient != null) {\n                adminClient.close();\n            }\n        }\n    }\n\n    public Map<String, Object> getAdminClientProperties() {\n        return Collections.unmodifiableMap(adminClientProperties);\n    }\n}"
  },
  {
    "Task_id": 9,
    "Instruction": "Task Description: Create a Java class that provides functionality for managing Kafka topics using the Kafka AdminClient API. The class should be able to create and configure an AdminClient instance and use it to create new Kafka topics.\n\nClass Description: The KafkaTopicManager class encapsulates operations for interacting with Kafka topics through the AdminClient API. It provides methods to initialize an AdminClient connection and create new topics with specified configurations.\n\nAttributes:\n- adminClient: AdminClient - The Kafka AdminClient instance used for topic management operations\n\nMethods:\n- createAndConfigureAdminClient(String bootstrapServers) -> AdminClient - Creates and configures a Kafka AdminClient instance with the specified bootstrap servers\n- autoCreateMetricsTopic(AdminClient adminClient, String topicName) -> TopicDescription - Creates a new Kafka topic with default configuration (1 partition and replication factor of 1) and returns its description",
    "Canonical_solution": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.CreateTopicsResult;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport java.util.Collections;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutionException;\n\npublic AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n    Properties adminProps = new Properties();\n    adminProps.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n    AdminClient adminClient = AdminClient.create(adminProps);\n    return adminClient;\n}\n\npublic TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) throws ExecutionException, InterruptedException {\n    NewTopic testTopic = new NewTopic(topicName, 1, (short) 1);\n    CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singleton(testTopic));\n    createTopicsResult.all().get();\n    TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topicName)).values().get(topicName).get();\n    return topicDescription;\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 33,
    "right_result": "import org.apache.kafka.clients.admin.AdminClient;\nimport org.apache.kafka.clients.admin.NewTopic;\nimport org.apache.kafka.clients.admin.TopicDescription;\nimport org.apache.kafka.common.config.TopicConfig;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class KafkaTopicManager {\n    private AdminClient adminClient;\n\n    public AdminClient createAndConfigureAdminClient(String bootstrapServers) {\n        Properties props = new Properties();\n        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        adminClient = AdminClient.create(props);\n        return adminClient;\n    }\n\n    public TopicDescription autoCreateMetricsTopic(AdminClient adminClient, String topicName) {\n        NewTopic newTopic = new NewTopic(topicName, 1, (short) 1);\n        adminClient.createTopics(Collections.singletonList(newTopic)).all().get();\n        return adminClient.describeTopics(Collections.singletonList(topicName)).all().get().get(topicName);\n    }\n}"
  },
  {
    "Task_id": 92,
    "Instruction": "Task Description: Create a function that performs an HTTP GET request to a specified URL and returns the response as a string.\n\nFunction Description: The function should establish an HTTP connection to the provided URL, send a GET request, read the response stream, and return the content as a UTF-8 encoded string. It should handle resource cleanup properly by closing all streams and disconnecting the HTTP connection.\n\nInput: \n- requestUrl: String - The URL to which the HTTP GET request will be sent\n\nOutput: \n- String - The response content from the HTTP GET request, or null if an error occurs",
    "Canonical_solution": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nprivate static String httpRequest(String requestUrl) {\n    StringBuffer buffer = null;\n    BufferedReader bufferedReader = null;\n    InputStreamReader inputStreamReader = null;\n    InputStream inputStream = null;\n    HttpURLConnection httpUrlConn = null;\n    try {\n        // \u5efa\u7acbget\u8bf7\u6c42\n        URL url = new URL(requestUrl);\n        httpUrlConn = (HttpURLConnection) url.openConnection();\n        httpUrlConn.setDoInput(true);\n        httpUrlConn.setRequestMethod(\"GET\");\n        // \u83b7\u53d6\u8f93\u5165\u6d41\n        inputStream = httpUrlConn.getInputStream();\n        inputStreamReader = new InputStreamReader(inputStream, \"UTF-8\");\n        bufferedReader = new BufferedReader(inputStreamReader);\n        // \u4ece\u8f93\u5165\u6d41\u83b7\u53d6\u7ed3\u679c\n        buffer = new StringBuffer();\n        String str = null;\n        while ((str = bufferedReader.readLine()) != null) {\n            str = new String(str.getBytes(), \"UTF-8\");\n            buffer.append(str);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        if (bufferedReader != null) {\n            try {\n                bufferedReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStreamReader != null) {\n            try {\n                inputStreamReader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        if (httpUrlConn != null) {\n            httpUrlConn.disconnect();\n        }\n    }\n    return buffer.toString();\n}",
    "Code_level": "Function-level",
    "FSMID_for_test": 16,
    "right_result": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class HttpUtils {\n    public static String getResponseString(String requestUrl) {\n        try {\n            URL url = new URL(requestUrl);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode != HttpURLConnection.HTTP_OK) {\n                return null;\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n            StringBuilder response = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.append(line);\n            }\n            reader.close();\n            connection.disconnect();\n            return response.toString();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}"
  }
]